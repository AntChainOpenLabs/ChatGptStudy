1. {"Vulnerability Type": "Admin can rug users", "Vulnerability Location": "Controller.sol#L22-L34", "Repair Method": "Use non-upgradeable CollateralToken contract to hold user's allowances instead", "Vulnerability Information": "Admin of the upgradeable proxy contract of Controller.sol can rug users."}
2. {"Vulnerability Type": "No use of upgradeable SafeERC20 contract", "Vulnerability Location": "Controller.sol#L5", "Repair Method": "Make use of Open Zeppelin's upgradeable version of the SafeERC20.sol contract", "Vulnerability Information": "Controller.sol makes use of Open Zeppelin's ReentrancyGuardUpgradeable.sol in the file but does not use an upgradeable version of SafeERC20.sol."}
3. {"Vulnerability Type": "QTokens with the same symbol will lead to mistakes", "Vulnerability Location": "QTokenStringUtils.sol#L115-L130, L181-L199", "Repair Method": "Include the full year in the token's symbol", "Vulnerability Information": "QTokens with the same symbol will lead to mistakes."}
4. {"Vulnerability Type": "Incorrect strike price displayed in name/symbol of qToken", "Vulnerability Location": "options/QTokenStringUtils.sol#L38, L90, L136, L206", "Repair Method": "Fix the bug in the `_slice()` function", "Vulnerability Information": "Incorrect strike price displayed in name/symbol of qToken."}

{"Vulnerability Type": "Arbitrary code execution", "Vulnerability Location": "Controller.sol#L497-L516", "Repair Method": "Probe for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided", "Vulnerability Information": "A malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented."}

{"Vulnerability Type": "Arithmetic", "Vulnerability Location": "QuantCalculator.calculateClaimableCollateral", "Repair Method": "Add explicit rounding on fixed-point multiplication and division operations", "Vulnerability Information": "The vulnerability allows minting spread collateral-less and conjuring collateral claims out of thin air with implicit arithmetic rounding and flawed int to uint conversion."}

{"Vulnerability Type": "Arbitrary Token Minting", "Vulnerability Location": "CollateralToken.sol", "Repair Method": "Remove the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter.", "Vulnerability Information": "An address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens, posing a serious centralization risk."}

{"Vulnerability Type": "Timelock Stalemate", "Vulnerability Location": "ConfigTimelockController.sol", "Repair Method": "Declare a constant with a MAXIMUM_DELAY and set the minimum delay below this value. Add a check to require sufficient gas to be paid.", "Vulnerability Information": "The state variable minimum delay can be set to an arbitrary value, up to type(uint256).max, and could potentially render the QuantConfig contract unusable."}

{"Vulnerability Type": "Replay Attack", "Vulnerability Location": "EIP712MetaTransaction.sol", "Repair Method": "Failed transactions should still increase the nonce. Add a check to require sufficient gas to be paid.", "Vulnerability Information": "Once the low-level call fails, the whole transaction will be reverted, and the same transaction can be replayed by anyone using the same signature."}

{"Vulnerability Type": "Wrong Implementation", "Vulnerability Location": "EIP712MetaTransaction.sol", "Repair Method": "Use onlyInitializing modifier instead of initializer modifier in the initializer function. Declare the contract as abstract and the initializer function as internal.", "Vulnerability Information": "EIP712MetaTransaction's initializer function uses the initializer modifier instead of onlyInitializing modifier, and the contract is not declared as abstract."}

{"Vulnerability Type": "Usage of deprecated Chainlink functions", "Vulnerability Location": "ChainlinkOracleManager.sol#L120, ChainlinkFixedTimeOracleManager.sol#L81, ChainlinkFixedTimeOracleManager.sol#L84", "Repair Method": "Switch to latestRoundData() as described in the Chainlink documentation", "Vulnerability Information": "The Chainlink functions latestAnswer() and getAnswer() are deprecated and should be replaced with latestRoundData() and getRoundData() respectively."}

{"Vulnerability Type": "Low-level transfer via call() can fail silently", "Vulnerability Location": "TimelockController.sol#L414-L415", "Repair Method": "Check for the account's existence prior to transferring", "Vulnerability Information": "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, which can cause transfers to fail silently."}

{"Vulnerability Type": "Spreads can be minted with a deactivated oracle", "Vulnerability Location": "FundsCalculator.sol#L91-L117", "Repair Method": "Require the oracle to be active on spreads minting as well", "Vulnerability Information": "When an oracle is deactivated, it is still available for option spreads minting, allowing users to mint new options within spreads that rely on a deactivated oracle."}

{"Vulnerability Type": "OperateProxy.callFunction() should check if the callee is a contract", "Vulnerability Location": "Controller.sol#L550-L558, OperateProxy.sol#L10-L19", "Repair Method": "Add a check and throw when the callee is not a contract", "Vulnerability Information": "The OperateProxy.callFunction() function does not check if the callee is a contract, which can cause non-contract addresses to be called and considered successful, potentially causing malfunction or fund loss."}

