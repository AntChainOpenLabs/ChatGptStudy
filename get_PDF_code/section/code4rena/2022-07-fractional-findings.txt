{"Vulnerability Type": "Uninitialized Proxy", "Vulnerability Location": "VaultFactory.sol", "Repair Method": "Add init in `Vault`'s constructor (and make the `init` function `public` instead of `external`) or add init in `VaultFactory.sol` constructor", "Vulnerability Information": "The implementation vault is not initialized, which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via the `execute` function) to a function with the `selfdestruct` opcode. Once the implementation is destroyed all of the vaults will be unusable. This is a critical bug, since ALL assets held by ALL vaults will be lost."}

1. {"Vulnerability Type": "Stealing NFTs and ETH + Fractional tokens", "Vulnerability Location": "Migration.sol module", "Repair Method": "Update the totalEth and totalFractions variables in the withdrawContribution function", "Vulnerability Information": "The withdrawContribution function does not update the totalEth and totalFractions variables, leading to an inflation of ETH and fractional tokens if the user calls join, withdrawContribution and join again."}
2. {"Vulnerability Type": "Buyout module can be bypassed", "Vulnerability Location": "fallback() function", "Repair Method": "Track which installed plugins might require permissions alongside the methods mapping in storage", "Vulnerability Information": "The fallback() function can bypass permission/auth checks imposed in execute() function, leading to unintended vulnerabilities like loss of vault NFTs."}
3. {"Vulnerability Type": "TotalSupply not updated before _mint", "Vulnerability Location": "FERC1155.sol::mint function", "Repair Method": "Update totalSupply before _mint", "Vulnerability Information": "TotalSupply is updated after an external call, leading to a vault being created with an incorrect buyout status."}

{"Vulnerability Type": "Asset Burning", "Vulnerability Location": "Migration.sol", "Repair Method": "Perform additional validation to ensure that the `_proposalId` submitted is valid. Check if `newVault` points to a valid vault address before transferring the assets from old vault to new vault. Implement validation checks to ensure that the `_to` address is not `address(0)` within the `Buyout.withdrawERC721` function.", "Vulnerability Information": "An attacker could call `Migration.migrateVaultERC20`, `Migration.migrateVaultERC721`, and/or `Migration.migrateVaultERC1155` with an invalid `_proposalId` parameter, causing the assets within the vault to be burned. The vulnerability occurs after a successful vault migration."}

{"Vulnerability Type": "Residual Allowance Exploit", "Vulnerability Location": "batchDepositERC20, batchDepositERC721, batchDepositERC1155 functions in BaseVault.sol", "Repair Method": "Update the affected functions to remove the 'from' parameter, and use 'msg.sender' instead", "Vulnerability Information": "Malicious users can exploit residual allowance to steal assets"} 

{"Vulnerability Type": "Frontrunning and Plugin Overwriting", "Vulnerability Location": "createFor() function in VaultRegistry.sol", "Repair Method": "Unify the criteria related to the entry points for a user to deploy a vault, check if the plugin that is willing to be installed is not overwriting the 'methods' mapping, and timelock the process of plugin installation", "Vulnerability Information": "Vault owner can frontrun a plugin call and change its implementation"}

1. {"Vulnerability Type": "Re-entrancy", "Vulnerability Location": "modules/Migration.sol::commit", "Repair Method": "Follow Checks, Effects, Interactions patterns. Consider adding reentrancy guard.", "Vulnerability Information": "Assets can be compromised directly. One can drain eth out from migration module to buyout module using custom made FERC1155 token."}
2. {"Vulnerability Type": "Mismatched Proposal ID and Vault", "Vulnerability Location": "modules/Migration.sol", "Repair Method": "Save for each proposal which vault it corresponds to. Verify that user supplies a matching vault-proposal pair, or have `userProposalFractions` save the relevant vault also, not just a general proposal id.", "Vulnerability Information": "When joining or leaving a migration proposal, Fractional does not check whether the user supplied `proposalId` and `vault` match the actual vault that the proposal belongs to."}
3. {"Vulnerability Type": "Replay Attack", "Vulnerability Location": "modules/Migration.sol", "Repair Method": "Change the length of either the migration period or the buyout period to match so that a proposal can't be replayed.", "Vulnerability Information": "Failed proposal can be committed again and eth stolen from migration contract in combination with other vulnerabilities submitted."}

{"Vulnerability Type": "Arbitrary Royalties", "Vulnerability Location": "VaultRegistry.sol line 147, FERC1155.sol line 217", "Repair Method": "Define clearly how users are intended to deploy vaults under which privileges. Set a maximum cap for the royalties and timelock that function so that vault owners have to wait a certain amount of time before changing the royalties in order to bring predictability for the community.", "Vulnerability Information": "A vault owner can set arbitrary secondary market royalties and steal a considerable amount of FERC1155 transferred."}

1. {"Vulnerability Type": "Incorrect Calculation", "Vulnerability Location": "Buyout.cash function", "Repair Method": "Decrement ethBalance from buyout info", "Vulnerability Information": "The function Buyout.cash allows a user to cash out proceeds (Ether) from a successful vault buyout. However, due to how buyoutShare is calculated in Buyout.cash, users (fractional vault token holders) cashing out would receive more Ether than they are entitled to."}
2. {"Vulnerability Type": "Time Constraint Bypass", "Vulnerability Location": "end function in the Buyout contract", "Repair Method": "Add a new field to record the amount of fraction tokens deposited by sellFractions", "Vulnerability Information": "The time constraint of selling fractions can be bypassed by directly transferring fraction tokens to the buyout contract."}

1. {"Vulnerability Type": "DoS attack", "Vulnerability Location": "initializeBuyout() function in Buyout.sol", "Repair Method": "Allow other users to offer a higher buyout while a buyout is running or require a user to hold a minimum percent of fractions to start a buyout", "Vulnerability Information": "A user can create a buyout with as little as 1 wei, without any fractions. Once a buyout is created, nobody else can create another buyout on the same vault till the previous buyout ends. This leads to the fact that with as little as 1 wei a user can block a vault from holding a buyout for 4 days."}
2. {"Vulnerability Type": "Array out of bounds", "Vulnerability Location": "propose() function in Migration.sol", "Repair Method": "Add a check in propose() to make sure that the lengths of selectors and plugins match", "Vulnerability Information": "In propose() in Migration.sol, there is no check that the lengths of the selectors and plugins arrays are the same. This means that if a migration is successful, the install() function in Vault.sol could revert because we access an array out of bounds. This prevents a new vault being created thereby permanently locking assets inside the vault."}
3. {"Vulnerability Type": "Forced buyouts", "Vulnerability Location": "end() function in Buyout.sol", "Repair Method": "Save the status of the proposer after a failed buyout and implement functions to allow the proposer to withdraw the ERC1155 tokens and eth", "Vulnerability Information": "In the end function of the Buyout contract, when the buyout fails, ERC1155 tokens are sent to the proposer. A malicious proposer can start a buyout using a contract that cannot receive ERC1155 tokens, and if the buyout fails, the end function fails because it cannot send ERC1155 tokens to the proposer. This prevents a new buyout from being started."}

{"Vulnerability Type": "Perpetual Buyout Vulnerability", "Vulnerability Location": "Buyout.sol", "Repair Method": "Prevent re-entrancy in the `start` function by using the `nonReentrant` modifier provided by OpenZeppelin's ReentrancyGuard contract, or use an equivalent custom solution.", "Vulnerability Information": "A user can start a perpetual buyout that cannot be stopped except by making the buyout succeed. This can be done by creating a malicious contract that will call back to `start` when it receives ETH via its `receive` function. The user then starts the perpetual buyout by calling `start` from the malicious contract. If `end` is called then the method `_sendEthOrWeth` will attempt to send ETH to the malicious contract. The contract will simply call back to `start` sending the ETH it has just received. The impact is that `end` can never be called on this buyout proposal if the buyout auction has failed. Worse, no new buyout proposal can be made since the current one is still live, and it is never in a state where it is not live."}

{"Vulnerability Type": "Inconsistent State Variable", "Vulnerability Location": "Buyout module", "Repair Method": "Calculate fraction price at the time of buy/sell according to the current total supply and add functionality to update the lastTotalSupply with an event notifying about the fraction-price change before the user buys/sells", "Vulnerability Information": "The total supply might change between the time the buyout starts till the buy/sell time, and the `fractionPrice` stored in the module might not represent the real price anymore. This can cause issues such as the buyout proposer paying the entire buyout price but ending up with only part of the vault, users buying fractions for more than they're really worth, and users getting a lower price than intended while selling their fractions."}

{"Vulnerability Type": "Division rounding", "Vulnerability Location": "Divisions in EVM", "Repair Method": "Request the user to send the intended fraction price (as a function arg) and then make sure he sent enough ETH. This way the user is well aware of the fraction price.", "Vulnerability Information": "Divisions in EVM are rounded down, which means when the fraction price is close to 1 (e.g. 0.999) it would effectively be zero, when it's close to 2 (1.999) it would be rounded to 1 losing close to 50% of the intended price."}

1. {"Vulnerability Type": "Use of payable.transfer() may lock user funds", "Vulnerability Location": "src/modules/Migration.sol", "Repair Method": "Use address.call{value:x}() instead", "Vulnerability Information": "The use of `payable.transfer()` is heavily frowned upon because it can lead to the locking of funds."}
2. {"Vulnerability Type": "migrateFractions may be called more than once by the same user which may lead to loss of tokens for other users", "Vulnerability Location": "Migrations.t.sol", "Repair Method": "Set the `userProposalEth` and `userProposalFractions` to 0 after the user's tokens have been migrated", "Vulnerability Information": "The `migrateFractions` function in the `Migration.sol` contract is used to send new vault tokens to the user calculated based on the amount of ETH and fractions the user contributed to the migration proposal."}
3. {"Vulnerability Type": "Migration's leave function allows leaving a committed proposal", "Vulnerability Location": "src/modules/Migration.sol", "Repair Method": "Revert in `leave` if `proposal.isCommited == true`", "Vulnerability Information": "The `leave` function allows to leave a proposal even if the proposal has been committed and failed."}
4. {"Vulnerability Type": "Delegate call in Vault#_execute can alter Vault's ownership", "Vulnerability Location": "Vault.sol", "Repair Method": "Check the `nonce` variable before and after the `delegatecall` inside the `_execute()` function", "Vulnerability Information": "The `Vault#execute` function calls a target contract's function via `delegatecall` if the caller is either the owner of the Vault or the target contract is part of a merkle tree."}

1. {"Vulnerability Type": "High Severity", "Vulnerability Location": "[H-17]", "Repair Method": "Add a new storage variable for currently active proposal id. Allow calling `settleVault` only for active proposal id (and also only if buyout's proposer equals `Migration` address, otherwise there can be a different successful buyout not connected to the active proposal). Also add appropriate checks with active proposal in the other functions as well (don't allow to commit if there is an active proposal etc).", "Vulnerability Information": "If one proposal starts a buyout which fails, and then another proposal starts a buyout which succeeds, then both of them will be commited and `settleVault` can be called on any of them. If it's called on the failed proposal first, then it will settle even though buyout has failed (and it can proceed to withdraw all tokens to a new vault)."}
2. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "[M-10]", "Repair Method": "Consider requiring that the new total supply should be greater than the old one", "Vulnerability Information": "Setting the severity to Medium as this is a fund loss impact conditional on a user not understanding the particulars of the implementation."}
3. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "[M-04]", "Repair Method": "Like in solmate ERC1155.sol add the `ERC2981` interfaceId on the `FERC1155` contract", "Vulnerability Information": "The EIP-2981: NFT Royalty Standard implementation is incomplete, missing the implementation of `function supportsInterface(bytes4 interfaceID) external view returns (bool);` from the EIP-165: Standard Interface Detection."}
4. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "[M-08]", "Repair Method": "Add these conditions to join() and leave()", "Vulnerability Information": "`Migration.join()` and `Migration.leave()` can still work after unsucessful migration."}
5. {"Vulnerability Type": "High Severity", "Vulnerability Location": "[H-11]", "Repair Method": "When calling propose require that `_newFractionSupply` is greater than some value (i.e. 1E18).", "Vulnerability Information": "If the supply of the fraction is set to say 10 then any user that uses `migrateFractions` with less than 10% of the contributions will receive no shares at all due to precision loss."}

1. {"Vulnerability Type": "Incorrect Withdrawal Amount", "Vulnerability Location": "Migration::withdrawContribution", "Repair Method": "Migration should send the user back his share of whatever was received back from Buyout, not his original contribution. Upon a failed proposal's end, there should be a hook call from Buyout to Migration to update the proposal with the change needed.", "Vulnerability Information": "When a user calls `withdrawContribution`, it will try to send him back his original contribution for the proposal. But if the proposal has been committed, and other users have interacted with the buyout, Migration will receive back a different amount of ETH and tokens. Therefore it shouldn't send the user back his original contribution, but should send whatever his share is of whatever was received back from Buyout."}
2. {"Vulnerability Type": "Fraudulent Fraction Stealing", "Vulnerability Location": "Migration.sol and Buyout.sol", "Repair Method": "Buyout `start` function should include amount of fractions a proposer deposits, and Migration's `commit` function should specify correct fractions amount when starting a buyout.", "Vulnerability Information": "Any fractions deposited into any proposal can be stolen at any time until it is committed. When `Migration` contract starts a buyout, it takes all fractions it has, not just the fractions from the proposal. This is easily exploitable by anyone."}

1. {"Vulnerability Type": "Fund Stuck", "Vulnerability Location": "Migration.sol", "Repair Method": "Modify the checks for the 'leave' and 'withdrawContribution' functions to allow users to withdraw their funds from the proposal when the buyout auction proposer is not 'Migration.sol'. Also, track the latest 'proposalId' that started the buyout on a vault to allow other proposals' contributors to withdraw their funds.", "Vulnerability Information": "Funds in migration proposals could potentially be stuck forever if a buyout auction on the same vault is started by another party."}
2. {"Vulnerability Type": "Division by Zero", "Vulnerability Location": "Migration.sol", "Repair Method": "Handle the case when 'proposal.totalFractions' is equal to the total supply by using 'redeem' instead of starting a buyout.", "Vulnerability Information": "When 'proposal.totalFractions' is equal to the total supply, there is a division by zero in '_calculateTotal'."}

