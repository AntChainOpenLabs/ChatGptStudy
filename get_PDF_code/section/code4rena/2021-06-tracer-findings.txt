{"Vulnerability Type": "Missing events for critical parameter changing operations by owner", "Vulnerability Location": "Owner setter functions", "Repair Method": "Emit events when critical addresses/values are updated", "Vulnerability Information": "The owner of the contract can change critical parameters without emitting events, leading to loss of funds/confidence and reputational hit."}

{"Vulnerability Type": "Deflationary tokens are not supported", "Vulnerability Location": "deposit() functions of Insurance and TracerPerpetualSwaps", "Repair Method": "Measure asset change before and after asset-transferring functions", "Vulnerability Information": "Assuming external ERC20 balance increases by the same amount as amount parameter of transferFrom can lead to avoiding taxes and loss of funds."}

{"Vulnerability Type": "Malicious owner can arbitrarily change fee to any % value", "Vulnerability Location": "Fee setter function", "Repair Method": "Implement Emit event and provide timelock for users to react and establish upper threshold for fees", "Vulnerability Information": "Malicious owner can change fees without any event or timelock, leading to loss of funds/confidence and reputational hit."}

{"Vulnerability Type": "Malicious owner can drain the market at any time using SafetyWithdraw", "Vulnerability Location": "withdrawERC20Token() in SafetyWithdraw", "Repair Method": "Design a pause/unpause feature where deposits are paused (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner", "Vulnerability Information": "Malicious owner can withdraw all tracerQuoteTokens deposited, leading to loss of funds/confidence and reputational hit."}

{"Vulnerability Type": "Avoid paying insurance", "Vulnerability Location": "deposit() function of Insurance.sol", "Repair Method": "Set timelock on withdrawing insurance", "Vulnerability Information": "It is possible to avoid paying insurance by manipulating the system, leading to loss of funds and grief attack."}

{"Vulnerability Type": "Insurance slippage reimbursement can be used to steal insurance fund", "Vulnerability Location": "claimReceipt() function in Liquidation contract", "Repair Method": "Disallow duplicate orders in the orders argument of claimReceipt()", "Vulnerability Information": "An attacker can abuse the system to make a profit by liquidating themselves and repeatedly submitting bad trades for slippage reimbursement, leading to draining of insurance fund."}

{"Vulnerability Type": "Wrong trading pricing calculations", "Vulnerability Location": "recordTrade() function in Pricing contract", "Repair Method": "Pass fillAmount parameter to recordTrade() and calculate hourlyTracerPrices[currentHour].trades summing fillAmount instead of 1 every trade", "Vulnerability Information": "An agent can manipulate trading prices by spamming a high amount of trades, leading to manipulation of the market."}

{"Vulnerability Type": "Use of deprecated Chainlink API", "Vulnerability Location": "latestAnswer() function

{"Vulnerability Type": "Wrong funding index", "Vulnerability Location": "TracerPerpetualSwaps.settle function", "Repair Method": "Check if setting it to currentGlobalFundingIndex or to currentGlobalFundingIndex 1 is correct", "Vulnerability Information": "It might be possible for first-time depositors to skip having to pay the first funding rate period as the accountLastUpdatedIndex + 1 < currentGlobalFundingIndex check will still return false when the funding rates are updated the next time."}
{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "executeTrade function in Trader contract", "Repair Method": "Add a reentrancy guard to prevent users from reentering critical functions", "Vulnerability Information": "Reentrancy could happen in the executeTrade function of Trader since the makeOrder.market can be a user-controlled external contract."}
{"Vulnerability Type": "Critical ownership transfer", "Vulnerability Location": "Tracer Perpetuals Factory contract", "Repair Method": "Use a two-step address change to governance address separately using setter functions", "Vulnerability Information": "The ownership of this contract is transferred to governance address in the constructor. This critical address transfer in one-step is very risky because it is irrecoverable from any mistakes."}
{"Vulnerability Type": "Wrong price scale", "Vulnerability Location": "GasOracle contract", "Repair Method": "Check chainlink.decimals() to know the decimals of the oracle answers and scale the answers to 18 decimals", "Vulnerability Information": "The scaling depends on the underlying decimals of the two oracles and could be anything. If the scale is wrong, the gas price can be heavily inflated or under-reported."}
{"Vulnerability Type": "Trader orders can be front-run", "Vulnerability Location": "Trader contract", "Repair Method": "Maintain an off-chain order book that is the entry point for users to make orders and for market makers to interact with", "Vulnerability Information": "The current design allows for a griefing attack where an attacker can deny any other user from trading by observing the mempool and front-running their trades by creating their own order and match it against the counter order instead."}
{"Vulnerability Type": "Underflow", "Vulnerability Location": "LibBalances.applyTrade function", "Repair Method": "Write a require check that ensures tokenDecimals <= 18 before running the above functions", "Vulnerability Information": "The contracts assume that all tokens will have <=18 decimals. The scaler computations will underflow and be defined when it should not be."}
{"Vulnerability Type": "No check transferFrom() return value", "Vulnerability Location": "TracerPerpetualSwaps:deposit and Insurance:deposit", "Repair Method": "Wrap the call into a require() or use openzeppelin's SafeERC20 library", "Vulnerability Information": "The smart contract doesn't check the return value of token.transfer() and token.transferFrom(), some erc20 token might not revert in case of error but return false."}
{"Vulnerability Type": "Logic error", "Vulnerability Location": "LibBalances.applyTrade function", "Repair Method": "Change +fee to -fee in the highlighted line", "Vulnerability Information": "The current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both."}
{"Vulnerability Type": "Use of incorrect index", "Vulnerability Location": "updateFundingRate() function in Pricing.sol", "Repair Method": "Use [

{"Vulnerability Type": "Escrow Claim Vulnerability", "Vulnerability Location": "executeTrade function in Trader.sol and claimReceipt function in Liquidation.sol", "Repair Method": "Limit who can call executeTrade function", "Vulnerability Information": "A liquidator can claim the liquidation escrow by creating a second account, setting up a complimentary trade resulting in a large slippage, executing the trade between their own two accounts, and calling claimReceipt with the receiptId of the executed order within the required period."}

