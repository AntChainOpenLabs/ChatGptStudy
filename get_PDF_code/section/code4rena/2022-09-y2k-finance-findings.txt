{"Vulnerability Type": "Possible loss of user funds", "Vulnerability Location": "Vault contract and Controller contract", "Repair Method": "Allow users to withdraw their full deposit amounts if they have deposited in only one vault and no one has deposited in the counterparty vault", "Vulnerability Information": "Users who deposit in one vault can lose all deposits and receive nothing when counterparty vault has no deposits"} 

{"Vulnerability Type": "Change of control vulnerability", "Vulnerability Location": "VaultFactory contract", "Repair Method": "Verify that the incoming Controller's VaultFactory address is the same as the VaultFactory's address itself", "Vulnerability Information": "It's possible to change for Vault and lost control on it"}

{"Vulnerability Type": "design flaw", "Vulnerability Location": "PegOracle", "Repair Method": "Support markets only for assets that have access to an oracle with price against canonical value x/ETH or x/USD.", "Vulnerability Information": "A design flaw in the case of using 2 oracles (aka PegOracle) where PegOracle treats both assets symmetrically."}

{"Vulnerability Type": "admin privilege", "Vulnerability Location": "StakingRewards.recoverERC20()", "Repair Method": "Add an additional check to require that the rewardsToken cannot be withdrawn.", "Vulnerability Information": "StakingRewards: recoverERC20() can be used as a backdoor by the owner to retrieve rewardsToken."}

{"Vulnerability Type": "non-compliant implementation", "Vulnerability Location": "Vault.sol", "Repair Method": "Modify all functions listed to meet the specifications of EIP-4626.", "Vulnerability Information": "Vault.sol is not EIP-4626 compliant and can cause integration problems in the future that can lead to a wide range of issues for both parties."}

1. {"Vulnerability Type": "Admin privilege", "Vulnerability Location": "function changeController()", "Repair Method": "Allow the change of controller address only in the `VaultFactory()`", "Vulnerability Information": "Admin can unilaterally withdraw all user funds from both risk and insure vaults."}
2. {"Vulnerability Type": "Griefing attack", "Vulnerability Location": "function withdraw()", "Repair Method": "Change the approval requirement to be for the caller, not receiver", "Vulnerability Information": "Anyone can withdraw to `receiver` once the `receiver` is `isApprovedForAll(owner, receiver)`. The funds will be sent to `receiver`, but it will happen whenever an arbitrary `msg.sender` wants."}
3. {"Vulnerability Type": "Incorrect oracle tracking", "Vulnerability Location": "tokenToOracle", "Repair Method": "Change `tokenToOracle` to represent the pair of tokens, either by creating a `Pair` struct as the key, or by nesting a mapping inside of another mapping", "Vulnerability Information": "Oracles are tracked by individual token, instead of by pair, leading to surprise results."}
4. {"Vulnerability Type": "Fee-on-Transfer", "Vulnerability Location": "SemiFungibleVault.deposit, Controller.triggerDepeg, Controller.triggerEndEpoch", "Repair Method": "Check the actual balance differences when fee-on-transfer tokens should be supported. If they are not supported, this should be clearly documented.", "Vulnerability Information": "Certain tokens charge a fee for transfers and this is not correctly handled in multiple places, leading to a loss of funds."}

1. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "Controller contract, StakingRewards contract", "Repair Method": "Accumulate the differences that occur due to rounding and let the users claim them in the end according to their shares", "Vulnerability Information": "Significant loss of precision possible due to rounding down in notifyRewardAmount function of StakingRewards contract."}
2. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "Controller contract", "Repair Method": "Change the isDisaster modifier to revert when price of a pegged asset is equal to the strike price of a Vault", "Vulnerability Information": "Depeg event can happen at incorrect price due to incorrect condition in isDisaster modifier of Controller contract."}
3. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "Controller contract, PegOracle contract", "Repair Method": "Check for stale prices by performing necessary round or timestamp checks", "Vulnerability Information": "Different Oracle issues can return outdated prices due to incorrect timestamp check in getLatestPrice function of PegOracle contract and inconsistency in how price1 and price2 are taken in Controller contract."}
4. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "Controller contract", "Repair Method": "Add code to limit the periodFinish in notifyRewardAmount function of StakingRewards contract", "Vulnerability Information": "After the vault expires, users may still receive rewards through the StakingRewards contract in Controller contract."}
5. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "Controller contract", "Repair Method": "Accumulate the differences that occur due to rounding and let the users claim them in the end according to their shares", "Vulnerability Information": "Rewards are not rolled over in Controller contract."}

1. {"Vulnerability Type": "Improper reward balance checks", "Vulnerability Location": "StakingRewards.sol#notifyRewardAmount()", "Repair Method": "Consider changing the function notifyRewardAmount to addRward and use transferFrom to transfer rewardsToken into the contract", "Vulnerability Information": "Improper reward balance checks can make some users unable to withdraw their rewards"}
2. {"Vulnerability Type": "Inability to withdraw funds before epoch start time", "Vulnerability Location": "Vault contract", "Repair Method": "Add some logic to give users the ability to withdraw funds before epoch start time", "Vulnerability Information": "Users funds lost because they can't withdraw() their funds before epoch startTime and they are stuck in positions that become unprofitable even when epoch is not started"}
3. {"Vulnerability Type": "Dilution of reward rate", "Vulnerability Location": "StakingRewards contract", "Repair Method": "Consider not extending the reward payouts by rewardsDuration on every call", "Vulnerability Information": "StakingRewards reward rate can be dragged out and diluted"}
4. {"Vulnerability Type": "Fees taken on risk collateral", "Vulnerability Location": "Vault contract", "Repair Method": "Fee calculations should be restructured to only take fees on premiums and insurance payouts", "Vulnerability Information": "Fees are taken on risk collateral"}
5. {"Vulnerability Type": "Payout required if pegged asset goes higher than underlying", "Vulnerability Location": "Pegged asset ratio calculation", "Repair Method": "The ratio returned should always the ratio of the pegged asset to the underlying (i.e. pegged/underlying)", "Vulnerability Information": "Risk users are required to payout if the price of the pegged asset goes higher than underlying"}

{"Vulnerability Type": "Loss of precision", "Vulnerability Location": "PegOracle.sol and Controller.sol contracts", "Repair Method": "Use a formula that transforms the relative price to 1e18, and avoid dividing and multiplying by different values that lead to loss of precision", "Vulnerability Information": "The first multiplication is first divided by `1e6` and then re-multiplied by `uint256 decimals = 10**(18-(priceFeed.decimals()));` which leads to loss of precision. This behavior will make the relative price between the assets incorrect."}

{"Vulnerability Type": "Preventing winners to withdraw", "Vulnerability Location": "Controller.sol:L198", "Repair Method": "Relax the use of getLatestPrice() for informational purpose only in the DepegInsurance event emission", "Vulnerability Information": "At the end of an epoch, the triggerEndEpoch() is called to trigger 'epoch end without depeg event', making risk users the winners and entitling them to withdraw (risk + hedge) from the vault. In the case of the Arbitrum sequencer going down or restarting, there is a grace period of one hour before the getLatestPrice() returns to execute without reverting. This means that the triggerEndEpoch() cannot complete during this time, because it calls the getLatestPrice()."}

1. {"Vulnerability Type": "Smart contract logic", "Vulnerability Location": "Vault.sol", "Repair Method": "Update the epochHasNotStarted modifier to check if block.timestamp is less than or equal to idEpochBegin[id] instead of idEpochBegin[id] timewindow", "Vulnerability Information": "The timewindow can be changed unexpectedly, blocking users from calling the deposit function."}
2. {"Vulnerability Type": "Smart contract logic", "Vulnerability Location": "Vault.sol", "Repair Method": "Update the beforeWithdraw function to use multiplication before division instead of division before multiplication", "Vulnerability Information": "It is possible that receiver and treasury can receive nothing when calling the withdraw function due to division being performed before multiplication."}

{"Vulnerability Type": "Incorrect handling of pricefeed decimals", "Vulnerability Location": "PegOracle.sol#L46-L83", "Repair Method": "Change the math used to handle pricefeed decimals to return correct results for all decimals", "Vulnerability Information": "The code only works for pricefeeds of 8 decimals, any others give wrong/incorrect data."}

{"Vulnerability Type": "Staking unable to be paused", "Vulnerability Location": "StakingRewards.sol#stake", "Repair Method": "Create simple external pause and unpause functions that can be called by owner", "Vulnerability Information": "StakingRewards.sol inherits pausable and implements the whenNotPaused modifier on stake, but doesn't implement any method to actually pause or unpause the contract."}

