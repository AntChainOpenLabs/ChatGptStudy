{"Vulnerability Type": "flash loan attack", "Vulnerability Location": "NonUSTStrategy contract", "Repair Method": "Add checks to ensure that the exchange rate from DAI to UST has not gone up before withdrawing or depositing from the vault", "Vulnerability Information": "The NonUSTStrategy contract is vulnerable to attacks by flash loans on curve pools."}

{"Vulnerability Type": "validation", "Vulnerability Location": "claimYield, _withdraw, and _unsponsor functions", "Repair Method": "Validate that the recipient address is not empty before executing the function", "Vulnerability Information": "The claimYield, _withdraw, and _unsponsor functions should validate that the recipient address is not empty to prevent accidental burns."}

{"Vulnerability Type": "token compatibility", "Vulnerability Location": "Strategy contracts", "Repair Method": "Verify the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest. Add support in contracts for rebasing/inflationary/deflationary tokens before accepting user-supplied tokens", "Vulnerability Information": "The Strategy contracts do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time."}

{"Vulnerability Type": "NFT minting", "Vulnerability Location": "Vault contract", "Repair Method": "Use _safeMint() instead of mint() to ensure that the receiver of the NFT is able to accept them. Add reentrancy guards to the deposit function", "Vulnerability Information": "The deposit function in the Vault contract calls mint() which does not ensure that the receiver of the NFT is able to accept them."}

{"Vulnerability Type": "centralization risk", "Vulnerability Location": "BaseStrategy contract", "Repair Method": "Allow depositors to call uninvest for UST vaults. For nonUST vaults that pay per curve swap, add trusted multisig instead of just the backend's EOA", "Vulnerability Information": "The current implementation requires trusted key holders to send transactions to initialize withdrawals from EthAnchor before the users can withdraw funds from the contract, introducing a high centralization risk."}

{"Vulnerability Type": "token transfer fees", "Vulnerability Location": "Vault contract", "Repair Method": "Do not use ERC20 tokens with fees", "Vulnerability Information": "If the underlying token of a vault charges a fee for every transfer, any deposit to the protocol will fail."}

1. {"Vulnerability Type": "Changing strategy can be bricked", "Vulnerability Location": "setStrategy function in Vault.sol", "Repair Method": "Keep an internal aUST balance of the strategy, which will be updated upon deposit and redeem, and use it (instead of raw aUST balance) to check if the strategy holds no aUST funds. Another option is to add capability for the strategy to send the aUST to the vault.", "Vulnerability Information": "A vault wouldn't let the strategy be changed unless the strategy holds no funds. Since anybody can send funds to the strategy, a griefing attack is possible."}
2. {"Vulnerability Type": "Withdrawers can get more value returned than expected with reentrant call", "Vulnerability Location": "onDepositBurned function in Vault.sol", "Repair Method": "Add reentrancy guards. Simplify some of the shares logic.", "Vulnerability Information": "The impact of this is that users can get significantly more UST withdrawn than they would be allotted if they had done non-reentrant withdraw calls."}
3. {"Vulnerability Type": "sponsor() function in open to reentrancy attacks", "Vulnerability Location": "sponsor() function in Vault.sol", "Repair Method": "Add a reentrancy guard modifier to the sponsor() function in Vault.sol", "Vulnerability Information": "In `Vault.sol` the `sponsor()` function does not have a reentrancy guard allowing an attacker to reenter the function because the `depositors.mint()` function has as callback to the msg.sender."}
4. {"Vulnerability Type": "Improper handling of swap fees allows attacker to steal funds from other users", "Vulnerability Location": "NonUSTStrategy.sol", "Repair Method": "Change the way new shares are issued: Swap from Vault asset (eg. FRAX) to UST in `deposit()`. Using the UST amount out / total underlying UST for the amount of new shares issued to the depositor. The depositor should be paying for the swap fee and slippage.", "Vulnerability Information": "`NonUSTStrategy` will swap the deposited non-UST assets into UST before depositing to EthAnchor. However, the swap fee is not attributed to the depositor correctly like many other yield farming vaults involving swaps (`ZapIn`)."}
5. {"Vulnerability Type": "Consider alternative price feed + ensure _minLockPeriod > 0 to prevent flash loan attacks", "Vulnerability Location": "constructor function in Vault.sol", "Repair Method": "Ensure that `_minLockPeriod` is non-zero in the constructor. Consider an alternative price feed.", "Vulnerability Information": "It is critical to ensure that `_minLockPeriod > 0` because it is immutable and cannot be changed once set. A zero `minLockPeriod` will allow for flash loan attacks to occur."}
6. {"Vulnerability Type": "unsponsor, claimYield and withdraw might fail unexpectedly", "Vulnerability Location": "withdraw, claimYield, and unsponsor functions in Vault.sol", "Repair Method": "When the system doesn't have enough balance to make the transfer, withdraw from the strategy. Users of the protocol should be made aware of the risk.", "Vulnerability Information": "`totalUnderlying()` includes the invested assets, they are not in the contract balance. When a user calls withdraw, claimYield or unsponsor, the system might not have enough assets in the balance and the transfer would fail."}

1. {"Vulnerability Type": "reentrancy attack", "Vulnerability Location": "deposit() function in Vault.sol", "Repair Method": "Add reentrancy guard modifiers to deposit(), withdraw(), and other important protocol functions", "Vulnerability Information": "The deposit() function in Vault.sol is vulnerable to reentrancy attacks due to the lack of reentrancy guard modifiers."}
2. {"Vulnerability Type": "missing setter function", "Vulnerability Location": "exchangeRateFeeder in BaseStrategy.sol", "Repair Method": "Add a setter function for exchangeRateFeeder", "Vulnerability Information": "BaseStrategy.sol does not have a setter function for exchangeRateFeeder, which may change in the future according to EthAnchor's documentation."}
3. {"Vulnerability Type": "manipulation of totalShares", "Vulnerability Location": "forceUnsponsor() function in Vault.sol", "Repair Method": "Add a minimum balance reserve that cannot be withdrawn by anyone in any case", "Vulnerability Information": "The forceUnsponsor() function in Vault.sol may open a window for attackers to manipulate the totalShares and freeze users' funds at a certain deposit amount."}
4. {"Vulnerability Type": "unequal losses for late users", "Vulnerability Location": "investedAssets() function in BaseStrategy.sol and NonUSTStrategy.sol", "Repair Method": "Add a new storage variable called totalLoss to maintain a stable value of share / adjustedUnderlying", "Vulnerability Information": "Late users may take more losses than expected when the underlying contract (EthAnchor) suffers investment losses."}
5. {"Vulnerability Type": "missing timelock", "Vulnerability Location": "setPerfFeePct function in BaseStrategy.sol", "Repair Method": "Put setter functions of key/critical variables behind a timelock", "Vulnerability Information": "The setPerfFeePct function in BaseStrategy.sol should be put behind a timelock to give more trust to users."}
6. {"Vulnerability Type": "missing performance fee calculation", "Vulnerability Location": "investedAssets() function in BaseStrategy.sol and NonUSTStrategy.sol", "Repair Method": "Calculate the expected performance fee to be charged if all the strategy's assets are withdrawn from the Anchor protocol", "Vulnerability Information": "The investedAssets() function in BaseStrategy.sol and NonUST

{"Vulnerability Type": "Arithmetic", "Vulnerability Location": "totalUnderlyingMinusSponsored() function", "Repair Method": "Add a check to prevent underflow by comparing totalSponsored with totalUnderlying before subtraction", "Vulnerability Information": "The totalUnderlyingMinusSponsored() function can revert on underflow when sponsorAmount > totalUnderlying(), which can happen in certain scenarios. The fix is to add a check to prevent underflow by comparing totalSponsored with totalUnderlying before subtraction."}

