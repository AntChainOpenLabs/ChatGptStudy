1. {"Vulnerability Type": "Missing input validation", "Vulnerability Location": "addInvestor() function in InvestorDistribution.sol", "Repair Method": "Add input validation to check the availability of tokens before adding an investor", "Vulnerability Information": "The addInvestor() function does not check how many tokens are available from investors_supply, which could lead to an attacker claiming all available tokens."}
2. {"Vulnerability Type": "Inadequate input validation", "Vulnerability Location": "claim() function in AirdropDistribution.sol", "Repair Method": "Remove the assert statement and add a validation check to prevent claiming the airdrop again", "Vulnerability Information": "The assert statement in the claim() function prevents claiming the last part of the airdrop, but an alternative path exists to claim it. This could impact the availability of the protocol."}
3. {"Vulnerability Type": "Missing input validation", "Vulnerability Location": "BasicSale contract", "Repair Method": "Add the missing approve() call in the constructor of the BasicSale contract", "Vulnerability Information": "The BasicSale contract is missing the approve() call, which could lead to all mainToken sent to the contract being stuck there forever."}
4. {"Vulnerability Type": "Inadequate ownership transfer process", "Vulnerability Location": "transferOwnership() function in Swap.sol", "Repair Method": "Implement a two-step process for ownership transfer to ensure the nominated EOA account is a valid and active account", "Vulnerability Information": "The current ownership transfer process could lead to the owner accidentally transferring ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier."}
5. {"Vulnerability Type": "Inadequate input validation", "Vulnerability Location": "claimExact() and validate() functions in AirdropDistribution.sol", "Repair Method": "Add a validation check to prevent claiming the airdrop again in the validate() function", "Vulnerability Information": "An attacker could claim the airdrop repeatedly by exploiting the check in the claimExact() function and the lack of validation in the validate() function."}

{"Vulnerability Type": "Investor can't claim the last tokens", "Vulnerability Location": "InvestorDistribution.sol", "Repair Method": "Remove the require statement", "Vulnerability Information": "Investor can't claim the last part of their claimable tokens due to a require statement in the claim() function."}

{"Vulnerability Type": "Can not update target price", "Vulnerability Location": "SwapUtils.sol", "Repair Method": "Change the condition in the require statement to include WEI_UNIT", "Vulnerability Information": "The sanity checks in rampTargetPrice are broken, preventing the admin from ramping the target price."}

{"Vulnerability Type": "Unchecked low-level calls", "Vulnerability Location": "PublicSale.sol", "Repair Method": "Check the return value of the low-level call or use SafeERC20 library", "Vulnerability Information": "Multiple calls to transferFrom and transfer are frequently done without checking the results, which can result in Ether being locked in the contract."}

{"Vulnerability Type": "Overwrite benRevocable", "Vulnerability Location": "Vesting.sol", "Repair Method": "Whitelist the calling of vest() or check if values for benRevocable are already set", "Vulnerability Information": "Anyone can call the vest() function and overwrite the value of benRevocable, effectively erasing any previous value."}

{"Vulnerability Type": "NFT flashloans can bypass sale constraints", "Vulnerability Location": "PublicSale.sol", "Repair Method": "Transfer and lock the NFT for at least 1 block or take a snapshot of user balances", "Vulnerability Information": "The constraint that only NFT holders can access the sale for the first 4 weeks can be easily bypassed with the help of flash loans."}

{"Vulnerability Type": "Get virtual price is not monotonically increasing", "Vulnerability Location": "SwapUtils.sol", "Repair Method": "Remove the getVirtualPrice function or make the precision multiplier an immutable parameter", "Vulnerability Information": "The virtualPrice function is not monotonically increasing regardless of the market due to the precision multiplier being changeable."}

{"Vulnerability Type": "Swaps are not split when trade crosses target price", "Vulnerability Location": "SwapUtils.sol", "Repair Method": "Split trades that cross the target price into two trades using both amplifiers", "Vulnerability Information": "Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for the entire trade."}

1. {"Vulnerability Type": "Ideal balance calculation error", "Vulnerability Location": "SwapUtils.sol", "Repair Method": "Replace self.balances with _xp(self, newBalances)", "Vulnerability Information": "When a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool. The current implementation does not calculate ideal balance correctly."}
2. {"Vulnerability Type": "Unbounded timelock loop", "Vulnerability Location": "Vesting.sol", "Repair Method": "Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments. Restrict the vestment contribution of a beneficiary where require(beneficiary == msg.sender)", "Vulnerability Information": "The timelocks for any beneficiary are unbounded, and can be vested by someone who is not the beneficiary. When the array becomes significantly big enough, the vestments will no longer be claimable for the beneficiary."}
3. {"Vulnerability Type": "LPToken set_minter() error", "Vulnerability Location": "LPToken.sol", "Repair Method": "Check that _minter doesn't equal zero before setting it as the new minter", "Vulnerability Information": "The function LPToken.set_minter() doesn't check that _minter doesn't equal zero before it sets it as the new minter."}
4. {"Vulnerability Type": "SwapUtils implementation error", "Vulnerability Location": "SwapUtils.sol", "Repair Method": "Add Swap.targetPrice and change the _xp() function", "Vulnerability Information": "Based on the context, the tokenPrecisionMultipliers used in price calculation should be calculated in real-time based on initialTargetPrice, futureTargetPrice, futureTargetPriceTime, and current time, just like getA() and getA2(). However, in the current implementation, tokenPrecisionMultipliers used in price calculation is the stored value, it will only be changed when the owner called rampTargetPrice() and stopRampTargetPrice()."}
5. {"Vulnerability Type": "MainToken set_mint_multisig() error", "Vulnerability Location": "MainToken.sol", "Repair Method": "Check that _minting_multisig doesn't equal zero before setting it as the new minting_multisig", "Vulnerability Information": "The function MainToken.set_mint_multisig() doesn't check that _minting_multisig doesn't equal zero before it sets it as the new minting_multisig."}
6. {"Vulnerability Type": "Arbitrage space creation error", "Vulnerability Location": "Swap.sol", "Repair Method": "Ramp the tokenPrecisionMultipliers as the aPrecise is ramped", "Vulnerability Information": "stopRampTargetPrice would set the tokenPrecisionMultipliers to originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT); Once the tokenPrecisionMultipliers is changed, the price in the AMM pool would change. Arbitrager can sandwich stopRampTargetPrice to gain profit."}

