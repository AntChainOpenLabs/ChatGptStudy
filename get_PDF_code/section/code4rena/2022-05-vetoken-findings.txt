1. {"Vulnerability Type": "Loss of Funds", "Vulnerability Location": "VeTokenMinter.sol", "Repair Method": "Implement a timelock on VeTokenMinter.withdraw() and changing the destination to an address that owner has no control over", "Vulnerability Information": "Compromised owner can drain funds from VeTokenMinter.sol."}
2. {"Vulnerability Type": "Smart Contract Misconfiguration", "Vulnerability Location": "25_deploy_angle_pools.js", "Repair Method": "Update to the Warden suggested addresses", "Vulnerability Information": "Incorrect deployment parameters."}
3. {"Vulnerability Type": "Logic Error", "Vulnerability Location": "VE3DRewardPool.sol", "Repair Method": "Add a check for already existing extraRewards before adding them", "Vulnerability Information": "No check for existing extraRewards during push."}
4. {"Vulnerability Type": "Loss of Funds", "Vulnerability Location": "VE3DRewardPool.sol", "Repair Method": "Check for values and add validation in addReward()", "Vulnerability Information": "Deposited staking tokens can be lost if rewards token info added by mistake in addReward() in VE3DRewardPool and there is no checking to ensure this would not happen."}

{"Vulnerability Type": "Insufficient balance", "Vulnerability Location": "VeTokenMinter.mint function", "Repair Method": "Update the internal accounting of VeTokenMinter contract during withdrawal so that the actual balance of the $VE3D tokens is taken into consideration within the VeTokenMinter.mint, and the contract will not attempt to transfer more tokens than what it has.", "Vulnerability Information": "Users will not be able to get their rewards from the reward contract at certain point of time if admin withdraws $VE3D token from the VeTokenMinter contract."}

{"Vulnerability Type": "Incompatibility", "Vulnerability Location": "VE3DRewardPool.sol", "Repair Method": "Exclude veBal/Bal as a supported asset or create a special wrapper for Bal that adds the Bal as one sided liquidity then stakes the LP.", "Vulnerability Information": "VE3DRewardPool.sol is incompatible with Bal/veBal."}

1. {"Vulnerability Type": "lack of check for zero-transfer", "Vulnerability Location": "stashRewards() function in ExtraRewardStashV2.sol", "Repair Method": "Add a check to run the transfer only when the amount is positive", "Vulnerability Information": "If an arbitrary token doesn't allow for zero amount transfers, the stashRewards() managed extra rewards retrieval can become unavailable."}
2. {"Vulnerability Type": "incorrect reward token", "Vulnerability Location": "constructor in BaseRewardPool.sol", "Repair Method": "Add a check in the constructor to ensure that the stakingToken is not set as the rewardToken", "Vulnerability Information": "If the rewardToken is set as the stakingToken by mistake, user funds can be lost."}
3. {"Vulnerability Type": "duplicate rewards", "Vulnerability Location": "addExtraReward() function in VE3DRewardPool.sol", "Repair Method": "Prevent the same addresses from being added multiple times to the extraRewards array", "Vulnerability Information": "The same reward address can be added multiple times to the extraRewards array, causing rewards to be disbursed twice and breaking protocol invariants."}

1. {"Vulnerability Type": "Unused rewards locked forever", "Vulnerability Location": "VE3DRewardPool and BaseRewardPool contracts", "Repair Method": "Add mechanism to recalculate rewardRate or calculate undistributed rewards based on rewardRate and when totalSupply() is 0", "Vulnerability Information": "If totalSupply() is 0 for some period, rewards will not be added to rewardPerTokenStored and those period rewards would not distribute to any address and those rewards will be stuck in contract forever."}
2. {"Vulnerability Type": "Contracts not robust to upgrades", "Vulnerability Location": "Integration with underlying upgradeable contracts", "Repair Method": "Make VoterProxy upgradeable or add upgradeable intermediate contracts between staker and gauge", "Vulnerability Information": "Contracts should be robust to upgrades of underlying gauges and eventually changes of the underlying tokens."}
3. {"Vulnerability Type": "Malicious operator can rug pull", "Vulnerability Location": "withdrawAll and execute functions in VoterProxy contract", "Repair Method": "Use multi-sig wallet as operator", "Vulnerability Information": "A compromised or malicious operator can withdraw all tokens by calling the function withdrawAll or call an arbitrary address with any value."}

1. {"Vulnerability Type": "Unbounded Array", "Vulnerability Location": "VE3DRewardPool and VE3DLocker contracts", "Repair Method": "Implement a method for removing old reward tokens which are no longer in use, set a hard limit on the number of reward tokens that can be added, or allow rewards to be iterated and distributed on a per token basis rather than all tokens at once.", "Vulnerability Information": "The `addReward()` function allows the owner to add a new reward token to the unbounded list `rewardTokens`, which when appended to cannot be shortened. This can cause a state where all transactions which iterate over this list will revert, making it impossible to withdraw any rewards from the contract."}
2. {"Vulnerability Type": "Fee Calculation", "Vulnerability Location": "Booster contract", "Repair Method": "Implement a validation check to ensure that `lockFeesIncentive` and `stakerLockFeesIncentive` add up to 100% to eliminate any risk of misconfiguration.", "Vulnerability Information": "The `setFeeInfo()` function is responsible for setting the allocation of gauge fees between lockers and $VE3D stakers. However, there is no validation check to ensure that `_lockFeesIncentive` and `_stakerLockFeesIncentive` add up to `10000`. This can cause the remaining gauge fee to be stuck in the `Booster` contract perpetually, resulting in users losing their gauge fee."}
3. {"Vulnerability Type": "Balance Discrepancy", "Vulnerability Location": "Booster and VE3DRewardPool contracts", "Repair Method": "Use the balance before and after the transfer to calculate the received amount instead of assuming that it would be equal to the amount passed as a parameter.", "Vulnerability Information": "As arbitrary ERC20 tokens can be passed, the amount here should be calculated every time to take into consideration a possible fee-on-transfer or deflation. This can cause a discrepancy between the amount passed as a parameter and the actual amount received, resulting in tokens being stuck in the contract."}

{"Vulnerability Type": "Incorrect assumption of 1-1 mapping between gauge and LP tokens", "Vulnerability Location": "VoterProxy contract, withdrawAll function", "Repair Method": "Use the total supply of pool.token to calculate the amount to withdraw when withdrawing all, and poke the gauge for exchange rates and check available tokens after withdrawing", "Vulnerability Information": "The VoterProxy contract incorrectly assumes a 1-1 mapping between the gauge and the LP tokens, which may lead to a loss of funds when calling withdrawAll."}

{"Vulnerability Type": "Inflation and reward stealing", "Vulnerability Location": "BaseRewardPool's stake() function and rewardPerToken() function", "Repair Method": "Add boundaries to reward the stakers to be consistent inside the limits", "Vulnerability Information": "The first user who calls BaseRewardPool's stake() function with 1 wei can inflate the rewardPerTokenStored and rewards can be stolen. The rewardPerToken() function depends on the denominator as totalSupply(), the whole multiplying will be divided by 1 wei which will inflate the rewardPerTokenStored astronomically. There is no obstacle for the user to withdraw it in the withdraw function."}

{"Vulnerability Type": "Loop dependence on pausable token", "Vulnerability Location": "VE3DRewardPool claim function", "Repair Method": "Add a second getReward() function that accepts an array of tokens to interact with instead of withdrawing all token bundles together", "Vulnerability Information": "If one token has pausable transfer, user cannot claim rewards or withdraw if they have multiple rewards include that pause token."}

{"Vulnerability Type": "Incorrectly set maxTime", "Vulnerability Location": "Constructor of VeAssetDepositor contract", "Repair Method": "Set the value of _maxTime in advance for each veAsset and not relying on manual inputting during the constructoring as the risk of misconfiging it is high. Otherwise, add an emergency measure that can help change _maxTime but this function needs to be protected with the highest security (eg. with timelock and multisig).", "Vulnerability Information": "If the owner inputs the _maxTime that is higher than the capacity of each vaults of veTokens, it will cause IVoteEscrow(escrow).increase_unlock_time(_value) to get rejected."}

{"Vulnerability Type": "Missing sane bounds on asset weights", "Vulnerability Location": "updateveAssetWeight function in VeTokenMinter contract", "Repair Method": "Have sane upper/lower limits on the values.", "Vulnerability Information": "The admin may fat-finger a change, or be malicious, and have the weights be extreme ranging from zero to type(uint256).max, which would cause the booster to pay out unexpected amounts."}

{"Vulnerability Type": "Duplicate LP token", "Vulnerability Location": "addPool function in PoolManager contract", "Repair Method": "Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken addPool function should fail.", "Vulnerability Information": "The first pool calling depositAll will take away all lpToken and deposit them under their own pid. This leaves no balance for the 2nd pool."}

{"Vulnerability Type": "User can lose extra rewards", "Vulnerability Location": "clearExtraRewards function in BaseRewardPool contract", "Repair Method": "If rewardManager wants to clear extra rewards then all existing stakes on extra rewards must be withdrawn and claimed so that user extra rewards are not lost.", "Vulnerability Information": "rewardManager can at any time delete the extra Rewards. This impacts the extra rewards earned by existing staker. The existing staker will have no way to claim these extra rewards."}

1. {"Vulnerability Type": "Not updating totalWeight", "Vulnerability Location": "VeTokenMinter contract", "Repair Method": "Rewrite removeOperator function to reduce totalWeight and set veAssetWeights to 0", "Vulnerability Information": "Remaining operators do not receive a fair share of the total rewards and a portion of the rewards are not given out at all."}
2. {"Vulnerability Type": "Rounding error", "Vulnerability Location": "notifyRewardAmount function in VE3DRewardPool and BaseRewardPool contracts", "Repair Method": "Add extra amount to queuedRewards or add other mechanism to recover it", "Vulnerability Information": "Some tokens will be locked and not distributed due to rounding error in rewardRate calculation."}

{"Vulnerability Type": "Reward token stuck", "Vulnerability Location": "Booster._earmarkRewards function, VoterProxy contract, ExtraRewardStashV3 contract", "Repair Method": "Trigger Booster.setGaugeRedirect during deployment or update Booster._earmarkRewards function to claim both veAsset and extra rewards from the stash contract instead of VoterProxy contract", "Vulnerability Information": "When claiming veAsset and extra rewards from the Angle's gauge, the VoterProxy contract is used to claim veAsset and all reward tokens are sent to VoterProxy contract. As a result, extra reward tokens (e.g. DAI, WETH) are stuck in the VoterProxy contract and cannot be collected by users."}

1. {"Vulnerability Type": "Owner privilege escalation", "Vulnerability Location": "setFeeManager function", "Repair Method": "Allow owner to change feeManager after initial setup", "Vulnerability Information": "Owner should be allowed to change fees manager in case if he feels current fee manager is behaving maliciously."}
2. {"Vulnerability Type": "Governance privilege escalation", "Vulnerability Location": "burn function in VeToken.sol", "Repair Method": "Delete the burn function or modify it to only allow msg.sender to burn the token", "Vulnerability Information": "Governance can arbitrarily burn VeToken from any address."}
3. {"Vulnerability Type": "Admin privilege escalation", "Vulnerability Location": "veTokenMinter contract", "Repair Method": "Hardcode the minters or set them as immutable", "Vulnerability Information": "Admin can dilute tokens by minting an excess amount of tokens."}
4. {"Vulnerability Type": "Logic error", "Vulnerability Location": "totalSupplyAtEpoch, balanceAtEpochOf, pendingLockAtEpochOf, and totalSupply functions in VE3DLocker.sol", "Repair Method": "Fix the underflow issue in the inversely traverse for loops", "Vulnerability Information": "Inversely traverse for loops always reverts due to underflow."}
5. {"Vulnerability Type": "Centralization risk", "Vulnerability Location": "setOperator, execute, withdraw, and withdrawAll functions in VoterProxy.sol", "Repair Method": "Remove the ability for the owner to change the operator or put it behind a time lock and multisig/dao", "Vulnerability Information": "Owner may set the operator to an address they own and drain all token balances."}

{"Vulnerability Type": "Permanently frozen user funds", "Vulnerability Location": "Booster's shutdownPool function", "Repair Method": "Update shutdownPool logic to mark the pool shutdown only if withdraw was successful", "Vulnerability Information": "shutdownPool marks shutdown successful even if it's not (i.e. when withdrawAll() call wasn't successful). As withdrawing logic expect that the pool in shutdown has already provided the funds, and makes no additional attempts to retrieve them, user funds will be frozen permanently as there are no mechanics in place to turn shutdown off for a pool."}

