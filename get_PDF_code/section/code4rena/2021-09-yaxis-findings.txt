{"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "Vault contract and Controller contract", "Repair Method": "Check withdrawal amount against getPricePerFullShare() and use a single source of truth for mapping, revert transaction when there's insufficient liquidity, specify minimum return amount when calling swap", "Vulnerability Information": "Vault withdrawals can be frontrun to cause users to burn tokens without receiving funds in return, treating all tokens exactly the same creates (huge) arbitrage opportunities, token -> vault mapping can be overwritten, controller does not raise an error when there's insufficient liquidity, controller is vulnerable to sandwich attack"}

{"Vulnerability Type": "Medium Severity", "Vulnerability Location": "VaultHelper deposits", "Repair Method": "Measure the asset change right before and after the asset-transferring routines", "Vulnerability Information": "VaultHelper deposits don't work with fee-on transfer tokens"}

{"Vulnerability Type": "High Severity", "Vulnerability Location": "addToken function in Manager.sol", "Repair Method": "Add a check for duplicates", "Vulnerability Information": "No safety check in addToken"}

{"Vulnerability Type": "High Severity", "Vulnerability Location": "setCap function in Controller.sol", "Repair Method": "Subtract the difference of the balance", "Vulnerability Information": "set cap breaks vault's Balance"}

{"Vulnerability Type": "High Severity", "Vulnerability Location": "removeToken function in Manager.sol", "Repair Method": "Withdraw all tokenA from all strategies, swap tokenA for tokenB in the vault, and remove the token via the Manager function", "Vulnerability Information": "removeToken would break the vault/protocol."}

{"Vulnerability Type": "Medium Severity", "Vulnerability Location": "addLiquidity function in NativeStrategyCurve3Crv.sol", "Repair Method": "Add liquidity in equal proportion to the curve pool balances, not the contract balances", "Vulnerability Information": "Adding asymmetric liquidity in _addLiquidity results in fewer LP tokens minted than what should be wanted"}

Note: There is no vulnerability type mentioned in the text for [H-09].

{"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "multiple locations", "Repair Method": "implement additional access control checks, consider price differences between tokens, add estimated quantities for swapped-out stablecoin and minted 3CRV, track time-weighted-average reserve amount, use slippage checks when swapping and minting tokens", "Vulnerability Information": "various vulnerabilities including stealing funds from multi-token vaults, missing access control checks, decreasing share price, manipulable voting power, and harvest frontrunning"}

{"Vulnerability Type": "ERC20 return values not checked", "Vulnerability Location": "ERC20.transfer() and ERC20.transferFrom() functions", "Repair Method": "Use OpenZeppelinâ€™s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens", "Vulnerability Information": "The ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success. This parameter needs to be checked for success."}

{"Vulnerability Type": "Controller.setCap sets wrong vault balance", "Vulnerability Location": "Controller.setCap function", "Repair Method": "Sub the _diff instead of the balance", "Vulnerability Information": "The Controller.setCap function sets a cap for a strategy and withdraws any excess amounts (_diff). The vault balance is decreased by the entire strategy balance instead of by this _diff."}

{"Vulnerability Type": "Vault.withdraw sometimes burns too many shares", "Vulnerability Location": "Vault.withdraw function", "Repair Method": "Recompute shares to burn based on the lower payout", "Vulnerability Information": "The Vault.withdraw function attempts to withdraw funds from the controller if there are not enough in the vault already. In the case the controller could not withdraw enough, i.e., where _diff < _toWithdraw, the user will receive less output tokens than their fair share would entitle them to."}

{"Vulnerability Type": "Vault: Swaps at parity with swap fee = withdrawal fee", "Vulnerability Location": "Vault contract", "Repair Method": "Prevent users from depositing and withdrawing in the same transaction, setWithdrawalProtectionFee() could have a requirement for the value to be non-zero, use price oracles to accurately calculate the shares to be transferred to users for deposits, or token amounts to be sent for withdrawals", "Vulnerability Information": "The vault treats all assets to be of the same price. Given that one can also deposit and withdraw in the same transaction, this offers users the ability to swap available funds held in the vault at parity, with the withdrawal protection fee (0.1%) effectively being the swap fee."}

{"Vulnerability Type": "Vault.withdraw mixes normalized and standard amounts", "Vulnerability Location": "Vault.withdraw function", "Repair Method": "Denormalize derived token amount before using them", "Vulnerability Information": "The Vault.balance function uses the balanceOfThis function which scales (\"normalizes\") all balances to 18 decimals. Note that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized."}

{"Vulnerability Type": "Controller.inCaseStrategyGetStuck does not update balance", "Vulnerability Location": "Controller.inCaseStrategyGetStuck function", "Repair Method": "Call updateBalance(_vault, _strategy) in inCaseStrategyGetStuck", "Vulnerability Information": "The Controller.inCaseStrategyGetStuck withdraws from a strategy but does not call updateBalance(_vault, _strategy) afterwards."}

{"Vulnerability Type": "Vault.balance() mixes normalized and standard amounts", "Vulnerability Location": "Vault.balance function", "Repair Method": "Use a consistent usage of _normalizeDecimals", "Vulnerability Information": "The Vault.balance function uses the balanceOfThis function which scales (\"normalizes\") all balances to 18 decimals. Note that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized."}

1. {"Vulnerability Type": "wrong estimates", "Vulnerability Location": "Harvester.getEstimates", "Repair Method": "Change the path to WETH-YAXIS in Harvester.getEstimates", "Vulnerability Information": "The `Harvester.getEstimates` contract tries to estimate a `YAXIS` amount but uses the wrong path and/or amount."}
2. {"Vulnerability Type": "access control", "Vulnerability Location": "setHalted() in Manager.sol", "Repair Method": "Change access control to onlyGovernance from onlyStrategist for setHalted()", "Vulnerability Information": "A malicious strategist can halt the entire protocol and force a permanent shutdown."}

