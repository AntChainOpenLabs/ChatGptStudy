1. {"Vulnerability Type": "Duplicate entry", "Vulnerability Location": "addUToken function in MarketRegistry.sol", "Repair Method": "Modify addUToken and addUserManager functions to check if the utoken/usermanager already existed", "Vulnerability Information": "Duplicate utoken and usermanager can be added which cannot be deleted."}
2. {"Vulnerability Type": "Whitelist check on wrong address", "Vulnerability Location": "_beforeTokenTransfer function in UnionToken.sol", "Repair Method": "Check against 'from' instead of 'msg.sender' to enforce the whitelist", "Vulnerability Information": "UnionToken should check whitelist on 'from'."}
3. {"Vulnerability Type": "Inflated comptroller rewards", "Vulnerability Location": "calculateRewardsByBlocks function in Comptroller.sol", "Repair Method": "Limit curInflationIndex or change the lookup table, or limit it to a percentage from startInflationIndex", "Vulnerability Information": "Comptroller rewards can be artificially inflated and drained by manipulating totalStaked - totalFrozen."}
4. {"Vulnerability Type": "Loss of funds", "Vulnerability Location": "deposit function in AssetManager.sol", "Repair Method": "Revert or stop execution if the token is not supported", "Vulnerability Information": "User funds can be lost in case of unsupported market token deposit."}
5. {"Vulnerability Type": "Disabled loan repayment", "Vulnerability Location": "FixedInterestRateModel.sol", "Repair Method": "Add a check in setInterestRate function to disallow setting the interest rate too high", "Vulnerability Information": "Change in interest rate can disable repay of loan."}

{"Vulnerability Type": "Low precision percentages", "Vulnerability Location": "AssetManager.rebalance function", "Repair Method": "Remove the final zero balance check, or make sure that the last market that is actually deposited to receives all remaining tokens", "Vulnerability Information": "The rebalance function will fail due to low precision of percentages as they are in base points, i.e, the lowest unit is 1 = 0.01%. This will leave dust in the contract in most cases as the tokens have much higher precision."}

{"Vulnerability Type": "Borrow accrues interest after balance check", "Vulnerability Location": "UToken.borrow function", "Repair Method": "Move the 'accrueInterest' call to the beginning of the function", "Vulnerability Information": "The 'borrow' function first checks the borrowed balance and the old credit limit before accruing the actual interest on the market. Thus the borrowed balance of the user does not include the latest interest as it uses the old global borrowIndex but the new borrowIndex is only set in 'accrueInterest'. This will lead to borrowers being able to borrow more than maxBorrow and more than their credit limit as these checks are performed before updating accruing interest."}

{"Vulnerability Type": "Expensive sort function", "Vulnerability Location": "SumOfTrust.sol, CreditLimitByMedian.sol, UserManager.sol", "Repair Method": "Set the MAX_TRUST_LIMIT so that everything still works, probably include a margin for future changes in gas costs", "Vulnerability Information": "Both SumOfTrust.sol and CreditLimitByMedian.sol contain an expensive sort function. This is used by UserManager.sol via the functions getLockedAmount and getCreditLimit. If the list of stakers would be very long then the sort would take up all the gas and revert. Attackers could make the list of stakers longer by voting in themselves (as soon as they have 3 accounts voted in), this would result in a griefing attack. The number of stakers and borrowers is limited in the function updateTrust by applying a limit of MAX_TRUST_LIMIT. However this limit is quite high (100), if that amount of stakers would be present then an out of gas error would probably occur with the sort."}

{"Vulnerability Type": "Rebalance fails if market has high utilization", "Vulnerability Location": "AssetManager.rebalance function", "Repair Method": "Withdraw only what's available and rebalance on that instead of trying to pull all tokens from each market first", "Vulnerability Information": "The rebalance function iterates through the markets and withdraws all tokens in the moneyMarkets[i].withdrawAll call. Rebalancing will fail if a single market has a liquidity crunch. Withdraw only what's available and rebalance on that instead of trying to pull all tokens from each market first."}

{"Vulnerability Type": "totalStaked ≥ totalFrozen should be checked before and after totalFrozen is updated", "Vulnerability Location": "UserManager.updateTotalFrozen and UserManager.batchUpdateTotalFrozen functions", "Repair Method": "Add an additional require statement to check that totalStaked is still ≥ totalFrozen after _updateTotalFrozen is called", "Vulnerability Information": "The require statement in updateTotalFrozen and batchUpdateTotalFrozen to check that totalStaked ≥ totalFrozen should be done both before and after _updateTotalFrozen is called to ensure that totalStake is still ≥ totalFrozen. This will serve as a sanity check to ensure that the integrity of the system is not compromised."}

{"Vulnerability Type": "debtWriteOff updates totalFrozen immaturely, thereby losing staker rewards", "Vulnerability Location": "UserManager.debtWriteOff function", "Repair Method": "Move the withdrawRewards call to before updateTotalFrozen is called", "Vulnerability Information": "debtWriteOff updates totalFrozen before withdrawing unionToken rewards. As the borrower is overdue, this means the staker calling debtWriteOff will lose his rewards if for example totalStaked == totalFrozen. Staker loses rewards. Or at the very least, inconsistency at

{"Vulnerability Type": "Wrong implementation", "Vulnerability Location": "CreditLimitByMedian.sol#getLockedAmount()", "Repair Method": "Change to: `newLockedAmount = array[i].lockedAmount + amount;`", "Vulnerability Information": "The current implementation is wrong and makes it impossible to unlock `lockedAmount` in `CreditLimitByMedian` model."}

