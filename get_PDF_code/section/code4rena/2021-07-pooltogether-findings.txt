1. {"Vulnerability Type": "ERC20 token transfer vulnerability", "Vulnerability Location": "SwappableYieldSource.redeemToken function", "Repair Method": "Use _depositToken.safeTransfer(msg.sender, redeemableBalance) instead of ERC20.transferFrom(address(this), msg.sender, redeemableBalance)", "Vulnerability Information": "Some deposit token implementations might fail as transferFrom checks if the contract approved itself for the redeemableBalance instead of skipping the allowance check in case the sender is the from address. This can make the transaction revert and the deposited funds will be unrecoverable for the user."}
2. {"Vulnerability Type": "Missing deposit token check", "Vulnerability Location": "SwappableYieldSource.transferFunds function", "Repair Method": "Check that the deposit tokens are the same before transferring funds", "Vulnerability Information": "If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference."}
3. {"Vulnerability Type": "Single-step ownership transfer/renounce", "Vulnerability Location": "SwappableYieldSource contract", "Repair Method": "Override the inherited methods to null functions and use separate functions for a two-step address change", "Vulnerability Information": "Critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes."}
4. {"Vulnerability Type": "Infinite approval vulnerability", "Vulnerability Location": "SwappableYieldSource contract", "Repair Method": "Decrease approval after swapping the yield source", "Vulnerability Information": "After swapping a yield source, the old yield source still has infinite approval."}
5. {"Vulnerability Type": "Rug pull vulnerability", "Vulnerability Location": "SwappableYieldSource.swapYieldSource function", "Repair Method": "Check that the YieldSource is from a trusted registry before allowing the swap", "Vulnerability Information": "If either the owner or the asset manager have malicious intent, this function allows them to instantly rug all funds."}

1. {"Vulnerability Type": "Temporary Inconsistent State", "Vulnerability Location": "setYieldSource function, supplyTokenTo function, balanceOfToken function, _mintShares function, _tokenToShares function, _sharesToToken function", "Repair Method": "Remove setYieldSource function or temporarily disable actions like supplyTokenTo, redeemToken and balanceOfToken after setYieldSource and until transferFunds has been done", "Vulnerability Information": "The use of setYieldSource leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same."}
2. {"Vulnerability Type": "Inconsistent Balance", "Vulnerability Location": "supplyTokenTo function", "Repair Method": "Get the actual received amount by calculating the difference of token balance before and after the transfer", "Vulnerability Information": "The supplyTokenTo function of SwappableYieldSource assumes that amount of _depositToken is transferred to itself after calling the safeTransferFrom function (and thus it supplies amount of token to the yield source). However, this may not be true if the _depositToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount."}
3. {"Vulnerability Type": "Incorrect Usage of Function", "Vulnerability Location": "safeApprove function", "Repair Method": "Use logic similar to SwappableYieldSource instead of using safeApprove", "Vulnerability Information": "Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelinâ€™s safeApprove() which has been documented as (1) Deprecated because of approve-like race condition and (2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise."}

