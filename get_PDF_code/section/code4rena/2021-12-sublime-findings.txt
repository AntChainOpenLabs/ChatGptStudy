{"Vulnerability Type": "denial of service", "Vulnerability Location": "Pool.sol:645, SavingsAccountUtil.sol", "Repair Method": "Remove all msg.value from the transferTokens function and just transfer _amount regularly", "Vulnerability Information": "If the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back."}

{"Vulnerability Type": "possibility to drain contract assets", "Vulnerability Location": "SavingsAccount.sol:160, SavingsAccount.sol:162, SavingsAccount.sol:164-L167, SavingsAccount.sol:169, SavingsAccount.sol:171-L177, SavingsAccount.sol:179-L181", "Repair Method": "Add a check for _currentStrategy to be from strategy list and implement getSharesForTokens() to always return 0", "Vulnerability Information": "A malicious actor can manipulate switchStrategy() function in a way to withdraw tokens that are locked in SavingsAccount contract."}

{"Vulnerability Type": "misspelled external function name", "Vulnerability Location": "AaveYield.sol: liquidityToken, _withdrawETH, _depositETH", "Repair Method": "Modify IWETHGateway(wethGateway).getAWETHAddress() to IWETHGateway(wethGateway).getWETHAddress()", "Vulnerability Information": "In AaveYield.sol the functions liquidityToken, _withdrawETH, _depositETH make a conditional call to IWETHGateway(wethGateway).getAWETHAddress(). This function does not exist in the wethGateway contract, causing these function to fail with the error 'Fallback not allowed'."}

{"Vulnerability Type": "ether can be locked in the contract without a way to retrieve it", "Vulnerability Location": "PoolFactory.sol:260-317", "Repair Method": "If msg.value is greater than 0, make sure the _collateralToken address is set to address(0)", "Vulnerability Information": "If a borrower calls the createPool function with a non-zero value, but also includes an ERC20 token address for _collateralToken, then the Ether value sent will be locked in the PoolFactory contract forever."}

{"Vulnerability Type": "missing approve(0)", "Vulnerability Location": "CreditLine.sol:647, CreditLine.sol:779, AaveYield.sol:324", "Repair Method": "Use approve(_spender, 0) to set the allowance to zero immediately before each of the existing approve() calls", "Vulnerability Information": "There are 3 instances where the IERC20.approve() function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling approve(_spender, 0)."}

1. {"Vulnerability Type": "Price manipulation", "Vulnerability Location": "function getLatestPrice(address num, address den) external view override returns (uint256, uint256)", "Repair Method": "Query both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. It may also be useful to track historic values and ensure that there are no sharp changes in price.", "Vulnerability Information": "If for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result."}
2. {"Vulnerability Type": "Unauthorized liquidation", "Vulnerability Location": "function liquidate(uint256 _id, address _collateralAsset, address _borrowAsset, uint256 _totalCollateralTokens, uint256 _totalBorrowTokens, address _lender) external payable", "Repair Method": "Add a require statement to check that the sender is the lender if autoLiquidation is false.", "Vulnerability Information": "Anyone can liquidate a position that has autoLiquidation set to false. Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens that normally have to be transferred when autoLiquidation is true."}
3. {"Vulnerability Type": "Frozen funds", "Vulnerability Location": "function withdrawAll() external", "Repair Method": "Account for tokens received in both cases, which are _amount after unlockTokens for withdrawAll and _tokensReceived for switchStrategy.", "Vulnerability Information": "Full withdrawal and moving funds between strategies can lead to wrong accounting if the corresponding market has tight liquidity, which can be the case at least for AaveYield. That is, as the whole amount is required to be moved at once from Aave, both withdrawAll and switchStrategy will incorrectly account for partial withdrawal as if it was full whenever the corresponding underlying yield pool had liquidity issues."}
4. {"Vulnerability Type": "Missing fund transfer", "Vulnerability Location": "function liquidate(uint256 _id, address _collateralAsset, address _borrowAsset, uint256 _totalCollateralTokens, uint256 _total

1. {"Vulnerability Type": "Wrong implementation", "Vulnerability Location": "NoYield.sol#emergencyWithdraw()", "Repair Method": "Assign received variable before transferring", "Vulnerability Information": "The emergencyWithdraw() function does not work as expected because the received variable is not assigned before transferring."}
2. {"Vulnerability Type": "Missing check", "Vulnerability Location": "Pool.sol#depositCollateral()", "Repair Method": "Require loan status to be collection or active", "Vulnerability Information": "Collateral can be deposited in a finished loan because the depositCollateral function does not check the status of the pool."}
3. {"Vulnerability Type": "Wrong implementation", "Vulnerability Location": "NoYield.sol#emergencyWithdraw()", "Repair Method": "Handle the case where _asset is the zero address", "Vulnerability Information": "ETH tokens can never be withdrawn from the NoYield contract in the event of an emergency because the contract considers ETH as a zero address asset."}
4. {"Vulnerability Type": "Rebasing issue", "Vulnerability Location": "AaveYield.lockTokens()", "Repair Method": "Create a non-rebasing wrapper LP token", "Vulnerability Information": "Aave's share tokens are rebasing, breaking current strategy code and leading to loss of interest for users."}
5. {"Vulnerability Type": "Missing check", "Vulnerability Location": "Extension contract transfer logic", "Repair Method": "Rerun the voting logic in removeVotes", "Vulnerability Information": "Extension voting threshold check needs to rerun on each transfer to avoid extensions that should be granted after a token transfer not being granted."}
6. {"Vulnerability Type": "Oracle issue", "Vulnerability Location": "CreditLine#_borrowTokensToLiquidate", "Repair Method": "Consult the inverse of borrowToken/collateralToken", "Vulnerability Information": "In CreditLine#_borrowTokensToLiquidate, the oracle is used in the wrong way, leading to loss/gain of funds for the liquidator/lender."}
7. {"Vulnerability Type": "Decimal issue", "Vulnerability Location": "YearnYield.getTokensForShares()", "Repair Method": "Divide by 10^vault.decimals() instead of 1e18", "Vulnerability Information": "Yearn token <> shares conversion decimal issue leads to too much or too little being paid out, resulting in a loss for either the protocol or user."}

1. {"Vulnerability Type": "Unlinked address can link immediately again", "Vulnerability Location": "linkAddress() function in Verification.sol", "Repair Method": "Add a line of code to reset pendingLinkAddresses in linkAddress() function", "Vulnerability Information": "After a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission."}
2. {"Vulnerability Type": "Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss", "Vulnerability Location": "depositFromSavingsAccount() function in SavingsAccountUtil.sol", "Repair Method": "Change the return value of savingsAccountTransfer() function to return the actual shares received", "Vulnerability Information": "The recorded shares received can be wrong, causing fund loss to the lenders."}

