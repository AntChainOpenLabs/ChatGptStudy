1. {"Vulnerability Type": "High Severity", "Vulnerability Location": "Governance.sol", "Repair Method": "Add a check for minimum VOTES totalSupply before allowing proposal submission and execution", "Vulnerability Information": "Anyone can pass any proposal alone before first VOTES are minted."}
2. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "TRSRY.sol", "Repair Method": "Use openzeppelin's safeERC20 or implement a code existence check", "Vulnerability Information": "Solmate safetransfer and safetransferfrom does not check the codesize of the token address, which may lead to fund loss."}
3. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "Governance.sol", "Repair Method": "Store the proposal metadata in the same INSTR contract or ensure that the proposal doesn't exist", "Vulnerability Information": "It is possible to overwrite proposals in certain circumstances."}
4. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "PRICE.sol", "Repair Method": "Add the missing checks for stale data", "Vulnerability Information": "Using Chainlink's latestRoundData API without checking for stale prices can lead to loss of funds to end-users."}

1. {"Vulnerability Type": "front-running vulnerability", "Vulnerability Location": "TRSRY: front-runnable setApprovalFor", "Repair Method": "Change the logic to increase/decrease allowances", "Vulnerability Information": "An attacker may be able to withdraw more than intended by front-running the setApprovalFor function."}
2. {"Vulnerability Type": "governance vulnerability", "Vulnerability Location": "Governance.sol", "Repair Method": "Increase the endorsement threshold or implement other solutions to temporarily liberate the governance system", "Vulnerability Information": "A malicious user with a relatively low voting power can prevent any other proposal from being activated, potentially holding the governance system hostage."}
3. {"Vulnerability Type": "funds redeployment vulnerability", "Vulnerability Location": "RBS may redeploy funds automatically if price stays above or below wall for longer than _config.regenWait", "Repair Method": "Add a check to verify that the price is within the wall price before regenerating or reset the count and observations array to clear out positive values", "Vulnerability Information": "The system may redeploy funds even if the price never comes back inside the wall price, leading to a loss of treasury funds."}
4. {"Vulnerability Type": "inconsistency in staleness checks", "Vulnerability Location": "PRICE.sol", "Repair Method": "Make the freshness requirements consistent for OHM and reserve token oracles", "Vulnerability Information": "The freshness requirements for OHM and reserve token oracles are inconsistent, which may cause the getCurrentPrice() function to revert."}

1. {"Vulnerability Type": "Reentrancy attack", "Vulnerability Location": "OlympusGovernance#executeProposal", "Repair Method": "Use nonReentrant modifier or move the line `activeProposal = ActivatedProposal(0, 0);` before the for loop.", "Vulnerability Information": "Given that the activeProposal change is done before the for loop, if this function is call through one `kernel.executeAction(instruction,target)` we can call the same instructions (in the same order) again and again, which may or may not affect funds (depending on the instructions)."}
2. {"Vulnerability Type": "Preventing vote revocation", "Vulnerability Location": "VoterRegistration contract", "Repair Method": "Consider allowing to call the reclaimVotes function to reclaim any user's vote, thus avoiding the user storing his VOTES tokens in userVotesForProposal", "Vulnerability Information": "There is a way for users to prevent their votes from being revoked by voter_admin."}
3. {"Vulnerability Type": "Reentrancy attack", "Vulnerability Location": "TRSRY: reenter from  OlympusTreasury::repayLoan  to  Operator::swap", "Repair Method": "Unknown", "Vulnerability Information": "One can repay loan to the treasury with the value from the `Operator::swap`. If the attacker can take debt of the reserve currency for the attack contract `Reenterer`, the contract can call `OlympusTreasury::repayLoan` and in the middle of repay call `Operator::swap` function."}

{"Vulnerability Type": "Inconsistant parameter requirements", "Vulnerability Location": "RANGE.sol and Operator.sol", "Repair Method": "Add same validation for the parameters between constructor() and Set() functions", "Vulnerability Information": "Inconsistant parameter requirements between constructor() and Set() functions in RANGE.sol and Operator.sol."}

{"Vulnerability Type": "Impossible to activate a new proposal", "Vulnerability Location": "Governance.sol", "Repair Method": "Add a constant like EXECUTION_EXPIRE and modify reclaimVotes() function", "Vulnerability Information": "In Governance.sol, it might be impossible to activate a new proposal forever after failed to execute the previous active proposal."}

{"Vulnerability Type": "Low market bonds/swaps not working", "Vulnerability Location": "TRSRY.sol", "Repair Method": "Determine capacity from actual tokens held by treasury", "Vulnerability Information": "Low market bonds/swaps not working after loan is taken from treasury."}

{"Vulnerability Type": "Missing checks", "Vulnerability Location": "Kernel._deactivatePolicy", "Repair Method": "Add a check to ascertain that the policy being removed is registered in the Kernel", "Vulnerability Information": "Missing checks in Kernel._deactivatePolicy."}

{"Vulnerability Type": "Loss of precision", "Vulnerability Location": "Moving average precision is lost", "Repair Method": "Store the cumulative sum and return sum / numObs on request", "Vulnerability Information": "The precision is lost in moving average calculations as the difference is calculated separately and added each time, while it typically can be small enough to lose precision in the division involved."}

{"Vulnerability Type": "Lack of synchronization check", "Vulnerability Location": "Protocol's Walls / cushion bonds remain active even if heart is not beating", "Repair Method": "Add a check for beat out of sync", "Vulnerability Information": "The Walls of the RBS mechanism offer zero slippage swaps at the high and low of the moving average spread. The capacity to be swapped at these prices is usually very large, so it must make sure to only be enabled when the prices are guaranteed to be synced. However, there is no such check."}

{"Vulnerability Type": "Confusion between loan and withdraw approval", "Vulnerability Location": "TRSRY susceptible to loan / withdraw confusion", "Repair Method": "Implement a separate mapping called loanApproval", "Vulnerability Information": "Treasury allocates approvals in the withdrawApproval mapping which is set via setApprovalFor(). In both withdrawReserves() and in getLoan(), _checkApproval() is used to verify user has enough approval and subtracts the withdraw / loan amount. Therefore, there is no differentiation in validation between loan approval and withdraw approval."}

{"Vulnerability Type": "Lack of time delay", "Vulnerability Location": "activateProposal() need time delay", "Repair Method": "Add time delay when activating a proposal", "Vulnerability Information": "There is no time lock or delay when activating a proposal, the previous one could be replaced immediately."}

{"Vulnerability Type": "Denial of Service", "Vulnerability Location": "Griefing/DOS of withdrawals by EOAs from treasury (TRSRY) possible", "Repair Method": "Add a mapping(address = bool) of all addresses that have been active policies some time in the past to the kernel", "Vulnerability Information": "Any withdrawals from the treasury by an approved EOA can be denied by a malicious actor that watches the mempool."}

1. {"Vulnerability Type": "Incorrect initial bond market price", "Vulnerability Location": "Operator.sol lines 363-469", "Repair Method": "Update initial price to open bond market at current price rather than wall price", "Vulnerability Information": "Initial bond market price is set to wall price rather than current price as indicated in documentation."}
2. {"Vulnerability Type": "Observation-weighted-average-price used instead of time-weighted one", "Vulnerability Location": "PRICE.sol lines 1134-144", "Repair Method": "Call an internal version of `beat()` that doesn't revert in functions that swap user assets. Track the timestamps of when each `beat()` is called, and include the amount of time that has passed since the last beat, in the TWAP calculation", "Vulnerability Information": "The algorithm does not take into account the time between observations, leading to the TWAP price being incorrect."}
3. {"Vulnerability Type": "Activating same Policy multiple times in Kernel possible", "Vulnerability Location": "Kernel.sol line 296", "Repair Method": "Check `getPolicyIndex[policy_] != 0` instead of relying on a value of an untrusted contract", "Vulnerability Information": "It is possible to activate the same policy multiple times for the same Kernel, breaking uniqueness invariants and potentially leading to a DoS attack."}

1. {"Vulnerability Type": "Transferring votes to another user for endorsing the same proposal again", "Vulnerability Location": "endorseProposal function in Governance.sol and activateProposal function in Governance.sol", "Repair Method": "Add an additional function for reclaiming the endorsed votes back to the user and reducing the proposal's endorsed votes accordingly before the proposal is activated. After the proposal is activated, the endorsed votes should be counted as the voted votes.", "Vulnerability Information": "One user can first use her or his votes to endorse a proposal and then transfer these votes to another user. The other user can use these votes to endorse the same proposal again afterwards."}
2. {"Vulnerability Type": "Heart will stop if all rewards are swept", "Vulnerability Location": "_issueReward function in Heart.sol and withdrawUnspentRewards function in Heart.sol", "Repair Method": "Add a check for available tokens min(reward, rewardToken.balanceOf(address(this)));", "Vulnerability Information": "The function doesn't check for available tokens. In case of calling withdrawUnspentRewards, the heart will stop until a caller incentive is deposited again."}
3. {"Vulnerability Type": "Admin cannot be changed to EOA after deployment", "Vulnerability Location": "executeAction function in Kernel.sol and store function in INSTR.sol", "Repair Method": "Allow EOA addresses as instruction targets or disallow non-contract admin addresses.", "Vulnerability Information": "After contracts are deployed and initialized, the admin address in Kernel contract can only be set to a contract."}

1. {"Vulnerability Type": "Inconsistent State", "Vulnerability Location": "M-07", "Repair Method": "Remove the endorsed votes for the user from the proposal's endorsed votes when the user's votes are revoked", "Vulnerability Information": "Endorsed votes by a user do not decrease after the user's votes are revoked."}
2. {"Vulnerability Type": "Inconsistent State", "Vulnerability Location": "M-10", "Repair Method": "Add or remove the corresponding votes to or from the proposal's voted votes for the user when issueVotesTo or revokeVotesFrom is called during voting, or disable issueVotesTo and revokeVotesFrom when an active proposal exists", "Vulnerability Information": "Voted votes cannot change after the user is issued new votes or the user's old votes are revoked during voting."}
3. {"Vulnerability Type": "Missing Feature", "Vulnerability Location": "M-21", "Repair Method": "Add expiration for the active proposal, for example, 2 weeks, and allow users to reject the proposal and reclaim VOTES tokens after the expiration time", "Vulnerability Information": "Active proposal does not expire."}

1. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "M-20", "Repair Method": "Forbid wallSpread to be 100%", "Vulnerability Information": "The `beat` cannot be called anymore and price information will not be updated if the wallspread is set to 10000 (100%) and lower wall is active."}
2. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "M-27", "Repair Method": "Perform the same check for `MigrateKernel`", "Vulnerability Information": "The `DeactivatePolicy` action tries to call `setActiveStatus` on the policy. However, this has a `onlyKernel` modifier and the call will therefore fail when it is done after the value of `kernel` was changed."}
3. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "M-01", "Repair Method": "Conditionally regenerate each side if they are active", "Vulnerability Information": "`Operator::setReserveFactor` sets new `reserveFactor` value. This parameter is used in `fullCapacity` function to calculate how much capacity is available by high/low side. Changing this value means that the capacity of sides has changed and the sides should be regenerated to include this changes."}
4. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "M-17", "Repair Method": "Add a total supply cap to `VOTES`", "Vulnerability Information": "Because `VOTES` can be minted by `voter_admin`, and there is no cap on totalSupply, the `voter_admin` has the privileged ability to mint as many `VOTES` as they want in order to get any proposal to pass or veto it."}
5. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "M-30", "Repair Method": "Change this line to `lastBeat = block.timestamp (block.timestamp lastBeat) % frequency();`", "Vulnerability Information": "`beat()` function is allowed to be called by anyone once in `frequency()` period. However if `beat()` was last time called more then `frequency()` time ago then user can execute `beat()` function `(block.timestamp lastBeat)/frequency()` times in a row in same block and get rewards."}

