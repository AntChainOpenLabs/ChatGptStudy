1. {"Vulnerability Type": "selfdestruct may cause the funds to be lost", "Vulnerability Location": "FixedPrice.sol and OpenEdition.sol", "Repair Method": "don't use selfdestruct, use modified state to represent that the contract has completed the sale", "Vulnerability Information": "After the contract is destroyed, the subsequent execution of the contract's `#buy()` will always succeed, the msg.value will be locked in this address."}
2. {"Vulnerability Type": "Inconsistency in fees", "Vulnerability Location": "FixedPrice.sol", "Repair Method": "Revise the `cancel` function", "Vulnerability Information": "fees are deducted even when seller cancels before the sale startTime which could lead to loss of funds."}
3. {"Vulnerability Type": "Editions should be checked if they are actually deployed from the legitimate Escher721Factory", "Vulnerability Location": "FixedPriceFactory.sol, LPDAFactory.sol, and OpenEditionFactory.sol", "Repair Method": "Track all the deployed `Escher721` contracts in the `Escher721Factory.sol` and validate the `sale.edition` before creating sales contracts", "Vulnerability Information": "Malicious creators can create fake contracts that implemented `IEscher721` and fake buyers to get free earnings."}

{"Vulnerability Type": "Stealing refunds after sale has ended", "Vulnerability Location": "LPDA.sol", "Repair Method": "Don't allow buying 0 NFTs or don't allow buying if newId == finalId since the sale has ended", "Vulnerability Information": "saleReceiver and feeReceiver can steal refunds after sale has ended"}

{"Vulnerability Type": "Obsolete selfdestruct() function", "Vulnerability Location": "FixedPrice.sol and OpenEdition.sol", "Repair Method": "Change the architecture to avoid using selfdestruct() function", "Vulnerability Information": "selfdestruct() function will not be available after EIP-4758 and it will break the logic of the project"}

{"Vulnerability Type": "Ownership change", "Vulnerability Location": "Escher721Factory.sol, AccessControlUpgradeable.sol", "Repair Method": "Override the grantRole() function of AccessControlUpgradeable.sol to disable the granting of roles after initialization. Store the created editions in a mapping to prevent problems like these.", "Vulnerability Information": "Ownership of EscherERC721.sol contracts can be changed, thus creator roles become useless."}

{"Vulnerability Type": "Token minting", "Vulnerability Location": "FixedPrice.sol, OpenEdition.sol, LPDA.sol", "Repair Method": "Mint the tokens to the sale contract, reserve a range of tokens to a particular minter, or have a single minter role at a given time. Alternatively, have the ERC-721 contract manage the sequential IDs and have the sales contracts simply request minting of the next token ID.", "Vulnerability Information": "Sale contracts can be bricked if any other minter mints a token with an id that overlaps the sale."}

{"Vulnerability Type": "Use of payable.transfer() Might Render ETH Impossible to Withdraw", "Vulnerability Location": "LPDA.sol, FixedPrice.sol, OpenEdition.sol", "Repair Method": "Use of call with its returned boolean checked in combination with re-entrancy guard or Address.sendValue() available in OpenZeppelin Contract’s Address library", "Vulnerability Information": "The transfer will inevitably fail when the smart contract does not implement a payable fallback function, or implements a payable fallback function which would incur more than 2300 gas units, or implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300."}

{"Vulnerability Type": "Missing Function", "Vulnerability Location": "Escher721 contract", "Repair Method": "Add a function to expose the internal _setTokenRoyalty function to the artist", "Vulnerability Information": "Escher721 contract does not have setTokenRoyalty function"}

1. {"Vulnerability Type": "Unsafe downcasting operation", "Vulnerability Location": "LPDA.sol and FixedPrice.sol", "Repair Method": "Use safe casting library to make sure the downcast does not provide an unexpected truncate value", "Vulnerability Information": "The downcasting in LPDA.sol and FixedPrice.sol is damaging because it truncated user's fund."}
2. {"Vulnerability Type": "Creator can still 'cancel' a sale after it has started by revoking permissions", "Vulnerability Location": "OpenEdition contract", "Repair Method": "Make the 'cancel' function unrestricted or implement additional architecture changes to prevent the revocation of the minting permissions if some conditions are met", "Vulnerability Information": "The owner of the sale contract can still virtually cancel a sale after it has started by simply revoking the minting permissions to the sale contract."}

1. {"Vulnerability Type": "Integer Underflow", "Vulnerability Location": "LPDA.getPrice()", "Repair Method": "Add a validation in the LPDAFactory.createLPDASale function to ensure that the given duration and drop per second settings can't underflow the price.", "Vulnerability Information": "LPDA price can underflow the price due to bad settings and potentially brick the contract."}
2. {"Vulnerability Type": "Integer Overflow", "Vulnerability Location": "OpenEdition.buy()", "Repair Method": "Modify the validation to use uint256 instead of uint24 for the amount variable.", "Vulnerability Information": "OpenEdition.buy() might revert due to uint overflow when it should work."}

1. {"Vulnerability Type": "NFT mintable after Auction deadline expires", "Vulnerability Location": "buy() function in LPDA.sol contract", "Repair Method": "Introduce a require to validate if the purchase is being made within the endTime", "Vulnerability Information": "The buy function on the LPDA.sol contract is not validating if the auction is still running, allowing a purchase to be made after the stipulated time."}
2. {"Vulnerability Type": "buy() in LPDA.sol can be manipulated by buyers", "Vulnerability Location": "require(newId <= temp.finalId, \"TOO MANY\") in LPDA.sol contract", "Repair Method": "Refactor the affected code line to check if newId is greater than temp.finalId and adjust the amountSold and amount variables accordingly", "Vulnerability Information": "A buyer could plan on buying early at higher prices to make sure he would secure a portion of NFTs he desired. When the number of NFTs still available got smaller and that sale.endTime were yet to hit, he would then watch the mempool and repeatedly attempt to thwart the final group of buyers from successfully completing their respective transactions amidst the efforts to prolong the Dutch auction till sale.endTime was reached."}

