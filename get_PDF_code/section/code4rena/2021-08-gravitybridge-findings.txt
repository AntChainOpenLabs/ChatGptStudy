{"Vulnerability Type": "Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms", "Vulnerability Location": "check_for_events function in ethereum_event_watcher.rs", "Repair Method": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results. Additionally, you could require that validators sign ERC20 creation requests.", "Vulnerability Information": "An attacker can trigger a perpetual state of returning the GravityError::EthereumRestError(Web3Error::BadResponse error by deploying ERC20s generated by the public function in Gravity.sol and specifying a large string as the denom, name, or symbol. This will freeze the bridge by disallowing attestations to take place."}

{"Vulnerability Type": "Freeze Bridge via Non-UTF8 Token Name/Symbol/Denom", "Vulnerability Location": "ERC20DeployedEvent function in ethereum_events.rs", "Repair Method": "Check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent.", "Vulnerability Information": "Manual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. This will freeze the bridge by disallowing any attestations to take place."}

{"Vulnerability Type": "Incorrect accounting on transfer-on-fee/deflationary tokens in Gravity", "Vulnerability Location": "sendToCosmos function in Gravity.sol", "Repair Method": "Get the received amount by calculating the difference of token balance (using balanceOf) before and after the transferFrom.", "Vulnerability Information": "If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than the amount passed as a parameter of the SendToCosmosEvent event, causing the Cosmos side to think more tokens are locked on the Ethereum side."}

{"Vulnerability Type": "The function updateValset does not have enough sanity checks", "Vulnerability Location": "updateValset function in Gravity.sol", "Repair Method": "Add an on-chain check that the combined power of all new validators is above the state_powerThreshold. Also, add a check that the size of the new validator is less than a certain number. Alternatively, do the updating as a two-step process: the current set of validators proposes a pending set of validators, and the pending set of validators need to do the transition to become the new set of validators, going through the same threshold checks.", "Vulnerability Information": "The current set of validators can add a new set without checking that the combined power of all new validators is above the state_powerThreshold, causing the contract to be effectively stuck. Additionally, a large number of validators can cause gas limit issues."}

{"Vulnerability Type": "Win all relayer rewards", "Vulnerability Location": "find_latest_valset function in Gravity.sol", "Repair Method": "Add a check that the number of active relayers is above a certain threshold. Alternatively

{"Vulnerability Type": "Cannot actually submit evidence", "Vulnerability Location": "`SubmitBadSignatureEvidence` handler in `module`/`x`/`gravity`/`handler.go`", "Repair Method": "Handle the `MsgSubmitBadSignatureEvidence` in `module`/`x`/`gravity`/`handler.go`", "Vulnerability Information": "The `SubmitBadSignatureEvidence` is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless."}

{"Vulnerability Type": "Crash Eth Oracle On Any LogicCallEvent", "Vulnerability Location": "`eth_oracle_main_loop` and `check_for_events` in `eth_oracle_main_loop`", "Repair Method": "Implement the method `from_log` in `LogicCallExecutedEvent` and handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.", "Vulnerability Information": "A sufficiently large validator set or sufficiently rapid validator update, could cause both the `eth_oracle_main_loop` and `relayer_main_loop` to fall into a state of perpetual errors."}

{"Vulnerability Type": "Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayers", "Vulnerability Location": "`find_latest_valset` in `orchestrator/relayer/src/find_latest_valset.rs`", "Repair Method": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.", "Vulnerability Information": "A sufficiently large validator set or sufficiently rapid validator update, could cause both the `eth_oracle_main_loop` and `relayer_main_loop` to fall into a state of perpetual errors."}

