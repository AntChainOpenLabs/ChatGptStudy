{"Vulnerability Type": "Possible to bypass limitPerAccount", "Vulnerability Location": "FixedPriceDrop.sol", "Repair Method": "Use a mapping to track how many NFTs an address has bought instead of relying on balanceOf", "Vulnerability Information": "It is possible to bypass the saleConfig.limitPerAccount set by the creator by transferring the NFTs out."}

{"Vulnerability Type": "Creator fees may be burned", "Vulnerability Location": "royaltyInfo, getRoyalties, or getFeeRecipients functions", "Repair Method": "Treat address(0) as if no recipient was returned such that the other priorities / methods take over", "Vulnerability Information": "`royaltyInfo`, `getRoyalties`, or `getFeeRecipients` may return `address(0)` as the recipient address. While the value 0 is correctly handled for the royalties itself, it is not for the address. In such a case, the ETH amount will be sent to `address(0)`, i.e. it is burned and lost."}

{"Vulnerability Type": "Forget to check zero royalty amount", "Vulnerability Location": "MarketFees.sol", "Repair Method": "Add check if royaltyAmount is greater than 0 or not in 3rd priority", "Vulnerability Information": "Wrong return of `cretorShares` and `creatorRecipients` can make real royalties party can't gain the revenue of sale."}

{"Vulnerability Type": "Malicious Creator can steal from collectors upon minting with a custom NFT contract", "Vulnerability Location": "INFTDropCollectionMint.mintCountTo()", "Repair Method": "Add an additional check in NFTDropMarketFixedPriceSale.mintCountTo() using ERC721(nftContract).balanceOf()", "Vulnerability Information": "In the case of a fixed price sale where `nftContract` is a custom NFT contract that adheres to `INFTDropCollectionMint`, a malicious creator can set a malicious implementation of `INFTDropCollectionMint.mintCountTo()` that would result in collectors calling this function losing funds without receiving the expected amount of NFTs."}

1. {"Vulnerability Type": "Loss of Funds", "Vulnerability Location": "NFTDropMarketFixedPriceSale.createFixedPriceSale", "Repair Method": "Add an additional check in NFTDropMarketFixedPriceSale.mintCountTo() using ERC721(nftContract).balanceOf() or specify in INFTDropCollectionMint that mintCountTo must revert if called after all tokens have been minted", "Vulnerability Information": "mintFromFixedPriceSale for a custom contract can lead to users losing funds"}
2. {"Vulnerability Type": "Gas Stealing", "Vulnerability Location": "mixins/shared/MarketFees.sol#L130", "Repair Method": "Consider only providing a higher amount of gas (SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT", "Vulnerability Information": "NFT creator sales revenue recipients can steal gas"}

1. {"Vulnerability Type": "NFT locking", "Vulnerability Location": "NFTCollection.sol:262-274, NFTDropCollection.sol:171-187", "Repair Method": "Change _mint and mintCountTo functions to use _safeMint instead of _mint", "Vulnerability Information": "When calling _mint or mintCountTo function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's ERC721Upgradeable contract's _mint function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked."}
2. {"Vulnerability Type": "Royalty manipulation", "Vulnerability Location": "getRoyalties function", "Repair Method": "Ignore the results if totalShares sums to 10,000 or change royalty logic to use the values returned by collections directly", "Vulnerability Information": "If one creator specified a share that is larger than BASIS_POINTS, the first creator gets all of the royalties. Depending on how these are set (which is not in the control of the project), this can be exploited by the first creator."}

