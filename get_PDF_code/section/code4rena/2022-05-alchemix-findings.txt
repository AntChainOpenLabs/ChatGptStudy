1. {"Vulnerability Type": "DoS", "Vulnerability Location": "wrap and unwrap functions in FuseTokenAdapterV1.sol", "Repair Method": "Change the lines of code in wrap and unwrap functions to check for the correct return value of the mint and redeem functions respectively", "Vulnerability Information": "The wrap and unwrap functions in FuseTokenAdapterV1.sol have a wrong check which can cause the functions to revert even when they have worked correctly."}
2. {"Vulnerability Type": "Unusable Contract", "Vulnerability Location": "bumpExchangeRate function in gALCX.sol", "Repair Method": "Add handling when totalSupply is 0 but alcx.balanceOf(address(this)) is more than 0", "Vulnerability Information": "An attacker can make the gALCX contract unusable when totalSupply is 0 by sending ALCX tokens directly to the contract instead of using the stake function."}
3. {"Vulnerability Type": "Loss of Funds", "Vulnerability Location": "YearnTokenAdapter.sol", "Repair Method": "Allow the user to specify the slippage value themselves", "Vulnerability Information": "YearnTokenAdapter.sol allows slippage of 100% when withdrawing from the vault which can cause a loss of funds."}
4. {"Vulnerability Type": "Storage Slot Collision", "Vulnerability Location": "AlchemicTokenV2Base.sol, CrossChainCanonicalBase.sol, CrossChainCanonicalAlchemicTokenV2.sol, TransmuterV2.sol", "Repair Method": "Add appropriate storage gap at the end of upgradeable contracts", "Vulnerability Information": "None of the intended upgradeable contracts in the code base contain storage gap which can lead to storage slot collision."}

1. {"Vulnerability Type": "Unbounded minting of synthetic tokens", "Vulnerability Location": "AlchemistV2.sol#L676-L683, AlchemistV2.sol#L704, Limiters.sol#L84", "Repair Method": "Add an additional method to the Limiters library that can increment the mint limit and call it during a burn call in the AlchemistV2 contract", "Vulnerability Information": "An attacker can repeatedly call mint followed by burn after depositing some collateral with deposit. If this is appropriately sized and timed, it can cause the mint call to fail for another user due to the check that is called during mint."}
2. {"Vulnerability Type": "Depression of new gALCX token denomination", "Vulnerability Location": "gALCX.sol#L93-L94, gALCX.sol#L15, gALCX.sol#L69-L76, gALCX.sol#L85-L93", "Repair Method": "Require a minimum deposit value or require the first depositor to freeze a big enough initial amount of liquidity", "Vulnerability Information": "An attacker can become the first depositor for a recently created gALCX contract, providing a tiny amount of ALCX tokens by calling stake(1). Then the attacker can directly transfer a large amount of ALCX to the gALCX contract and run bumpExchangeRate(), effectively setting the cost of 1 gALCX to be a large amount of ALCX. All subsequent depositors will have their ALCX token investments rounded to the nearest divisor of the initial tiny deposit, with the remainder divided between all current depositors, i.e. the subsequent depositors lose value to the attacker."}
3. {"Vulnerability Type": "Approval failure for non-standard tokens", "Vulnerability Location": "AutoleverageBase.sol#L61-L63, AutoleverageBase.sol#L147-L147, AutoleverageBase.sol#L178-L179", "Repair Method": "Set the approval to 0 initially before setting the actual allowance", "Vulnerability Information": "Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved."}

1. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "AlchemicTokenV2Base.sol#L111-L124, AlchemicTokenV2Base.sol#L189-L191", "Repair Method": "Change the permissioning on `lowerHasMinted()` to be restricted to a higher permissioned role like `onlySentinel()` , or deprecate this function", "Vulnerability Information": "Alchemist can mint AlTokens above their assigned ceiling by calling lowerHasMinted()"}
2. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "ThreePoolAssetManager.sol#L896-L905, ThreePoolAssetManager.sol#L915-L919, EthAssetManager.sol#L566-L573", "Repair Method": "Consider controlling the decimals at the construction time or add the meta token decimals to calculations similarly to stables", "Vulnerability Information": "EthAssetManager and ThreePoolAssetManager don't control Meta tokens decimals"}
3. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "TransmuterBuffer.sol#L377-L379", "Repair Method": "Introduce a function to remove the underlying or simply delete the array so it can be reconstructed with a sequence of registerAsset calls", "Vulnerability Information": "registerAsset misuse can permanently disable TransmuterBuffer and break the system"}
4. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "TransmuterBuffer.sol", "Repair Method": "Implement a slippage calculation similar to `_alchemistWithdraw` to protect against it", "Vulnerability Information": "TransmuterBuffer.sol calls depositUnderlying with no slippage bounds"}

1. {"Vulnerability Type": "Approval race condition", "Vulnerability Location": "YearnTokenAdapter's wrap function", "Repair Method": "Approve zero before doing so for the amount", "Vulnerability Information": "Some ERC20 forbid the approval of positive amount when the allowance is positive."}
2. {"Vulnerability Type": "Incorrect price calculation", "Vulnerability Location": "Lido adapter's price function", "Repair Method": "Add extra steps to price() to approximate the rate for converting stETH to ETH", "Vulnerability Information": "The Lido adapter incorrectly calculates the price of WETH in terms of WstETH."}
3. {"Vulnerability Type": "Debt repayment with depegged underlyingToken", "Vulnerability Location": "AlchemistV2's repay function", "Repair Method": "Market buy using the underlyingToken to alToken and then burn() the alToken to reduce debt", "Vulnerability Information": "Debt can be repaid with a depegged underlyingToken, which can be exploited by arbitrageurs and drives the market price of alToken to match the worst depegged underlyingToken."}
4. {"Vulnerability Type": "Division by zero", "Vulnerability Location": "AlchemistV2's functions: _distributeCredit(), _distributeUnlockedCredit(), _calculateUnrealizedDebt(), _convertSharesToYieldTokens(), donate()", "Repair Method": "Prevent totalShares from becoming zero once it is set, transfer the first 1000 shares to a 'burn' account, or transfer all pending credit to the last user and set the required variables to zero", "Vulnerability Information": "If totalShares for a token falls to zero while there is pendingCredit the contract will become stuck."}

1. {"Vulnerability Type": "User fund freeze", "Vulnerability Location": "TransmuterBuffer's setAlchemist", "Repair Method": "Require that all exposure to the old Alchemist is closed before switching to the new one", "Vulnerability Information": "setAlchemist doesn't check whether there are any open positions left with the old Alchemist before switching to the new one, which can lead to user fund freeze."}
2. {"Vulnerability Type": "Hard coded slippage", "Vulnerability Location": "TransmuterBuffer's _alchemistWithdraw", "Repair Method": "Add a function argument with a default value of 1% to allow caller-defined slippage", "Vulnerability Information": "_alchemistWithdraw uses hard coded 1% slippage threshold, which can lead to user losses or exchange functionality unavailability."}

