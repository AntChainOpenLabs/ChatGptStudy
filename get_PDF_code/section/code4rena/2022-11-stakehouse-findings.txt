1. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "SavETHVault.sol", "Repair Method": "Verify the smartWallet is a valid existent smartWallet before ETH transfer by checking its owner", "Vulnerability Information": "The smartWallet address is not guaranteed correct, and ETH may be lost."}
2. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "GiantMevAndFeesPool.sol", "Repair Method": "Always pass the liquid staking manager address, check its real and then request either the savETH vault or staking funds vault to prove the validity of vaults", "Vulnerability Information": "The bringUnusedETHBackIntoGiantPool function can be used to steal LPTokens."}
3. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "GiantSavETHVaultPool.sol", "Repair Method": "Take a list of LiquidStakingManager addresses instead of vault addresses", "Vulnerability Information": "Giant pools can be drained due to weak vault authenticity check."}

{"Vulnerability Type": "reentrancy attack", "Vulnerability Location": "_distributeETHRewardsToUserForToken function", "Repair Method": "Implement checks-effects-interactions pattern to prevent reentrancy attacks", "Vulnerability Information": "The recipient can execute a reentrancy attack calling several times the different function to steal funds or take advantage of other users/protocol."}

{"Vulnerability Type": "Freezing of funds", "Vulnerability Location": "GiantPoolBase.sol, GiantSavETHVaultPool.sol", "Repair Method": "Add a check to ensure that the user has interacted with Giant LP Token at least one day before the withdrawal command is executed", "Vulnerability Information": "A hacker can prevent users from withdrawing dETH or LPTokens in giant pools. This bug causes a revert in WithdrawLP GiantMevAndFeesPool, WithdrawLP GiantSavETHVaultPool, and WithdrawDETH GiantSavETHVaultPool. The giant pools will become insolvent to returning ETH, dETH or vault LPTokens."}

{"Vulnerability Type": "Theft of ETH", "Vulnerability Location": "Syndicate.sol", "Repair Method": "Use += operator instead of = in the updateAccruedETHPerShares function and keep the state updated after each operation instead of using a lazy call", "Vulnerability Information": "A malicious user can steal all claimable ETH belonging to free floating SLOT holders. The logic for keeping the rewards up-to-date is also quite complex in my opinion. The main thing that triggered it for me was the lazy call to updateAccruedETHPerShares. Why not keep the state updated after each operation instead?"}

1. {"Vulnerability Type": "griefing attack", "Vulnerability Location": "_depositETHForStaking function", "Repair Method": "Handle the case where the remaining amount to be completed is smaller than `MIN_STAKING_AMOUNT`, and allow the deposit in that case.", "Vulnerability Information": "Vaults can be griefed and made impossible to use for depositing by constantly making sure the remaining amount to be added to complete the deposit to the maxStakingAmountPerValidator, is under `MIN_STAKING_AMOUNT`."}
2. {"Vulnerability Type": "depegging of tokens", "Vulnerability Location": "N/A", "Repair Method": "Add mechanism to ensure the dETH is pegged via burning if case the ETH got slashed. Consider when the node do not maintain a minimum 32 ETH staking balance, who is in charge of adding the ETH balance to increase the staking balance or withdraw the ETH and distribute the fund.", "Vulnerability Information": "dETH / ETH / LPTokenETH can become depegged due to ETH 2.0 reward slashing."}
3. {"Vulnerability Type": "loss of funds", "Vulnerability Location": "GiantPoolBase.withdrawLPTokens function", "Repair Method": "The GiantPool should store information about which LP tokens it receives for staking ETH. When calling the `GiantPoolBase.withdrawLPTokens` function it can then be checked if the LP tokens to be withdrawn were indeed transferred to the GiantPool in exchange for staking ETH.", "Vulnerability Information": "Withdrawing wrong LPToken from GiantPool leads to loss of funds."}

{"Vulnerability Type": "Stealing deposits", "Vulnerability Location": "StakingFundsVault contract", "Repair Method": "Exclude newly staked amounts in the accumulatedETHPerLPShare calculations", "Vulnerability Information": "Old stakers can steal deposits of new stakers in StakingFundsVault."}

{"Vulnerability Type": "Incorrect accounting", "Vulnerability Location": "SyndicateRewardsProcessor contract", "Repair Method": "Increase the claimed amount by the due amount instead of setting it equal to the due amount", "Vulnerability Information": "The claimed amount is set equal to the calculated due amount instead of being increased by the due amount, allowing LP token holders to repeatedly claim rewards and steal other LP token holders' ETH from the fees and MEV vault."}

1. {"Vulnerability Type": "Fund loss", "Vulnerability Location": "GiantSavETHVaultPool.bringUnusedETHBackIntoGiantPool()", "Repair Method": "Update the value of 'idleETH' in the function 'bringUnusedETHBackIntoGiantPool()'", "Vulnerability Information": "The value of 'idleETH' does not get increased in the function 'bringUnusedETHBackIntoGiantPool()', causing the contract to lose track of the real idle ETH balance of the contract."}
2. {"Vulnerability Type": "Funds theft", "Vulnerability Location": "LiquidStakingManager.rotateNodeRunnerOfSmartWallet()", "Repair Method": "Restrict the 'rotateNodeRunnerOfSmartWallet()' function to DAO only with the 'onlyDAO' modifier", "Vulnerability Information": "DAO or LSD network owner can swap node runner of the smart contract to their own EOA, allowing them to withdraw ETH or claim rewards from node runner. There are no checks done when swapping the node runner whether there are funds in the smart contract that belongs to the node runner."}
3. {"Vulnerability Type": "Reentrancy", "Vulnerability Location": "GiantMevAndFeesPool.withdrawETH()", "Repair Method": "Add 'idleETH -= _amount' before sending ETH to the user", "Vulnerability Information": "GiantMevAndFeesPool.withdrawETH() is vulnerable to reentrancy attack as GiantMevAndFeesPool.claimRewards() does not have the nonReentrant modifier. This allows the user to call any function in the fallback."}
4. {"Vulnerability Type": "Frontrun attack", "Vulnerability Location": "LiquidStakingManager.rotateNodeRunnerOfSmartWallet()", "Repair Method": "Restrict the 'rotateNodeRunnerOfSmartWallet()' function to DAO only with the 'onlyDAO' modifier", "Vulnerability Information": "rotateNodeRunnerOfSmartWallet() is vulnerable to a frontrun attack if the current node runner is malicious. If that is the case, the DAO would purposely call the same function with the '_wasPreviousNodeRunnerMalicious' flag turned on. An actual node runner that has been malicious could monitor the mempool and frontrun the DAO transaction that wanted to slash it and submit the transaction before the DAO to avoid getting banned and rotate their EOA representation of the node."}

1. {"Vulnerability Type": "Functionality", "Vulnerability Location": "GiantSavETHVaultPool.sol, GiantMevAndFeesPool.sol", "Repair Method": "Add a fallback or receive function to the pools and increase idleETH with the received ETH", "Vulnerability Information": "Giant pools cannot receive ETH from vaults, causing an insolvency issue when many users want to withdraw ETH and there is not enough liquidity inside the giant pools."}
2. {"Vulnerability Type": "Loss of Funds", "Vulnerability Location": "GiantMevAndFeesPool.sol", "Repair Method": "Encourage users to claim rewards before transferring tokens and document this limitation in detail", "Vulnerability Information": "When users transfer GiantLP, some rewards may be lost due to beforeTokenTransfer not calling StakingFundsVault.claimRewards to claim the latest rewards."}
3. {"Vulnerability Type": "Functionality", "Vulnerability Location": "LiquidStakingManager.sol", "Repair Method": "Update the require statement in updateNodeRunnerWhitelistStatus function to check for isNodeRunnerWhitelisted[_nodeRunner] != isWhitelisted", "Vulnerability Information": "Calling updateNodeRunnerWhitelistStatus function always reverts, preventing the DAO from whitelisting any trusted node runners and limiting the protocol's usability."}

{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "withdrawETHForKnot function in LiquidStakingManager.sol", "Repair Method": "Use mutex locks to prevent reentrancy or use the Checks-Effects-Interactions pattern to ensure that all state changes are made before any external calls are made", "Vulnerability Information": "The reentrancy bug in the withdrawETHForKnot function allows a node runner to reenter the LiquidStakingManager and stake deposited funds from the vaults before the BLS key is banned, causing a permanent freeze of user funds and making the protocol insolvent."}

1. {"Vulnerability Type": "Stealing ETH from Giant Pool", "Vulnerability Location": "GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool function", "Repair Method": "Increase idleETH in the function bringUnusedETHBackIntoGiantPool when sending ETH back to the Giant Pool", "Vulnerability Information": "The attacker can steal most of the ETH from the Giant Pool by exploiting the vulnerability in the function bringUnusedETHBackIntoGiantPool."}
2. {"Vulnerability Type": "Locking Rewards for All Users", "Vulnerability Location": "GiantMevAndFeesPool and LPToken contracts", "Repair Method": "Protect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because transfer is not protected and can trigger the before and after hooks", "Vulnerability Information": "Any malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users by exploiting the vulnerability in the inherited functions of the ERC20 tokens."}

{"Vulnerability Type": "Loss of EIP1559 rewards", "Vulnerability Location": "LiquidStakingManager.sol, Syndicate.sol", "Repair Method": "Update the updateAccruedETHPerShares function to handle EIP1559 rewards received by the syndicate during the period when it has no registered knots. Node runners should index the chain when the knot is removed from the LSD network and update their fee recipient.", "Vulnerability Information": "EIP1559 rewards received by the syndicate during the period when it has no registered knots can be lost."}

1. {"Vulnerability Type": "stealing ETH", "Vulnerability Location": "function withdrawETH from GiantMevAndFeesPool", "Repair Method": "Modify the code to decrease the idleETH after burning lpTokenETH", "Vulnerability Information": "The function withdrawETH from GiantMevAndFeesPool can steal most of eth because of idleETH is reduced before burning token."}
2. {"Vulnerability Type": "unfair reward distribution", "Vulnerability Location": "function totalRewardsReceived in GiantMevAndFeesPool", "Repair Method": "Rework the way accumulatedETHPerLPShare and claimed is used", "Vulnerability Information": "Any user being the first to claim rewards from GiantMevAndFeesPool can unexpectedly collect them all."}
3. {"Vulnerability Type": "reentrancy and fund theft", "Vulnerability Location": "function withdrawDETH in GiantSavETHVaultPool", "Repair Method": "Check the provided addresses and have some reentrancy defense mechanism", "Vulnerability Information": "Possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defense."}

1. {"Vulnerability Type": "ETH sent can be lost", "Vulnerability Location": "executeAsSmartWallet function in LiquidStakingManager.sol and execute function in OwnableSmartWallet.sol", "Repair Method": "Update the execute function in OwnableSmartWallet.sol to revoke all approvals given by the previous owner when ownership is transferred to a new owner. Update the executeAsSmartWallet function in LiquidStakingManager.sol to forward the sent ETH amount to the smart wallet contract.", "Vulnerability Information": "When calling the executeAsSmartWallet function by the DAO, an ETH amount can be sent but not forwarded to the smart wallet contract, causing the sent amount to become locked in the LiquidStakingManager contract."}
2. {"Vulnerability Type": "Multiple approvals can lead to unwanted ownership transfers", "Vulnerability Location": "approve function in OwnableSmartWallet.sol", "Repair Method": "Create an array to keep track of all approvals given by the previous owner and revoke all of them when ownership is transferred to a new owner.", "Vulnerability Information": "When ownership is transferred from one user to another, not all approvals given by the previous owner are revoked, leading to potential unwanted transfers of ownership."}

1. {"Vulnerability Type": "Arbitrary Execution", "Vulnerability Location": "LiquidStakingManager.sol", "Repair Method": "Disallow DAO admin from performing arbitrary execution to access user's fund", "Vulnerability Information": "DAO admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution."}
2. {"Vulnerability Type": "Adding non-EOA representative", "Vulnerability Location": "LiquidStakingManager.sol", "Repair Method": "Add a check to ensure that _newRepresentative is an EOA in functions rotateEOARepresentative and rotateEOARepresentativeOfNodeRunner", "Vulnerability Information": "It is not allowed to add non-EOA representative to the smart wallet. But, this limitation can be bypassed by rotating representatives."}

{"Vulnerability Type": "failure to distribute rewards", "Vulnerability Location": "function withdrawETH() in GiantPoolBase", "Repair Method": "Calculate and transfer user's unclaimed funds before any actions that change user's balance", "Vulnerability Information": "Function withdrawETH() in GiantPoolBase does not call _distributeETHRewardsToUserForToken() or _onWithdraw() which would make users lose their remaining rewards."}

{"Vulnerability Type": "ineffective banning of malicious node runner", "Vulnerability Location": "function registerBLSPublicKeys() and function rotateNodeRunnerOfSmartWallet() in LiquidStakingManager.sol", "Repair Method": "Add a function that can directly set bannedNodeRunners for a node runner and can only be called by the DAO", "Vulnerability Information": "Node runner who is already known to be malicious cannot be banned before corresponding smart wallet is created."}

1. {"Vulnerability Type": "Reentrancy", "Vulnerability Location": "LiquidStakingManager.sol#withdrawETHForKnow", "Repair Method": "Ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy.", "Vulnerability Information": "The _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned."}
2. {"Vulnerability Type": "Incorrect Calculation", "Vulnerability Location": "GiantMevAndFeesPool.previewAccumulatedETH", "Repair Method": "Calculate the accumulated ETH value for all stakingFundVaults, not only for one stakingFundsVault.", "Vulnerability Information": "The formula for calculating the accumulated ETH value is not correct, causing any third-party contract that relies on this calculation to behave incorrectly."}

1. {"Vulnerability Type": "Cross-chain replay attacks", "Vulnerability Location": "deployLPToken function", "Repair Method": "Include the chain.id in the data", "Vulnerability Information": "Mistakes made on one chain can be re-applied to a new chain. If a user does `deployLPToken` using the wrong network, an attacker can replay the action on the correct chain, and steal the funds."}
2. {"Vulnerability Type": "Rotating LPTokens to banned BLS public key", "Vulnerability Location": "rotateLPTokens function", "Repair Method": "Add a check to ensure that the new LPToken is not related to a banned BLS public key", "Vulnerability Information": "It is possible to rotate `LPTokens` to a banned BLS public key. This is not a safe action, because it can result in insolvency of the project (specially if the banned BLS public key was malicious)."}
3. {"Vulnerability Type": "Unstaking does not update the mapping", "Vulnerability Location": "unstaking function", "Repair Method": "Update the mapping `sETHUserClaimForKnot` to the correct value", "Vulnerability Information": "If a user stakes some sETH, and after some time decides to unstake some amount of sETH, later s/he will not be qualified or be less qualified to claim ETH on the remaining staked sETH."}
4. {"Vulnerability Type": "Funds are not claimed from syndicate for valid BLS keys of first key is invalid", "Vulnerability Location": "claimRewards function", "Repair Method": "Drop the `i==0` requirement and use a hasClaimed boolean instead", "Vulnerability Information": "If the first BLS public key is not part of the syndicate, then _claimFundsFromSyndicateForDistribution will not be called, even on BLS keys that are eligible for syndicate rewards. This leads to reduced rewards for user."}

1. {"Vulnerability Type": "User receives less rewards than they are eligible for", "Vulnerability Location": "StakingFundsVault.sol", "Repair Method": "Call updateAccumulatedETHPerLP() at the start of the function.", "Vulnerability Information": "The issue is that `updateAccumulatedETHPerLP()` is not guaranteed to be called, which means the ETH reward distribution in _distribute would use stale value, and users will not receive as many rewards as they should."}
2. {"Vulnerability Type": "Stuck ether funds", "Vulnerability Location": "GiantMevAndFeesPool.sol, GiantSavETHVaultPool.sol", "Repair Method": "Update `idleETH` in withdrawUnusedETHToGiantPool", "Vulnerability Information": "idleETH variable is not updated. idleETH  is the available ETH for withdrawing and depositing eth for staking. Since there is no other places that updates idleETH other than depositing eth for staking and withdrawing eth, the eth withdrawn from the vault will be stuck forever."}
3. {"Vulnerability Type": "Attacker can grift syndicate staking", "Vulnerability Location": "LiquidStakingManager.sol, Syndicate.sol", "Repair Method": "Only allow staking through the LiquidStakingManager, i.e. add access control to `Syndicate.stake`.", "Vulnerability Information": "`LiquidStakingManager._autoStakeWithSyndicate` always stakes a fixed amount of 12 ETH. However, `Syndicate.stake` only allows a total staking amount of 12 ETH and reverts otherwise."}
4. {"Vulnerability Type": "User griefing", "Vulnerability Location": "GiantMevAndFeesPool.sol", "Repair Method": "batchRotateLPTokens should have logic to enforce that this specific rotation is logical", "Vulnerability Information": "batchRotateLPTokens allows any user to rotate LP tokens of stakingFundsVaults around. There is a check that sender has over 0.5 ether of lpTokenETH, to prevent griefing. However, this check is unsatisfactory as user can at any stage deposit ETH to receive lpTokenETH and burn it to receive back ETH."}

{"Vulnerability Type": "Stuck Funds", "Vulnerability Location": "GiantLP with a transferHookProcessor", "Repair Method": "Update the beforeTokenTransfer function in GiantMevAndFeesPool to remove the zero address check or remove the transferHookProcessor from GiantLP", "Vulnerability Information": "The transferHookProcessor in GiantLP calls beforeTokenTransfer in GiantMevAndFeesPool with a zero address check, causing any withdraw function with a burn operation to revert and leaving users' funds stuck in the Giant Pool contracts."}

{"Vulnerability Type": "Integer Overflow", "Vulnerability Location": "SyndicateRewardsProcessor contract, afterTokenTransfer() function", "Repair Method": "Reduce 'claimed[]' when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[].", "Vulnerability Information": "When a user transfers away GiantMevAndFeesPool tokens, the pool's claimed[] computed is left unchanged and still corresponds to what they had claimed with their old (higher) number of tokens. The erroneous claimed value can cause an integer overflow when the claimed[] value is subtracted, leading to inability for this user to access some functions of the GiantMevAndFeesPool including such things as being able to transfer their tokens (overflow is triggered in a callback attempting to pay out their rewards). These overflows will occur in SyndicateRewardsProcessor's _previewAccumulatedETH() and _distributeETHRewardsToUserForToken(), the latter of which is called in a number of places. When rewards are later accumulated in the pool, the user will not be able to claim certain rewards owed to them because of the incorrect (high) claimed[] value. The excess rewards will be orphaned in the pool."}

{"Vulnerability Type": "Compromised or malicious DAO", "Vulnerability Location": "deployNewLiquidStakingDerivativeNetwork function, updateDAOAddress function, rotateEOARepresentativeOfNodeRunner function, rotateNodeRunnerOfSmartWallet function, withdrawETHForKnot function", "Repair Method": "Deploy a configurable governance contract as the DAO instead of explicitly setting the DAO's address. Implement a two-step procedure for transferring the DAO's role. Implement additional checks to prevent unauthorized actions by a compromised or malicious DAO.", "Vulnerability Information": "A compromised or malicious DAO can restrict actions of node runners who are not malicious, causing severe consequences including ETH losses."}

{"Vulnerability Type": "Loss of Funds", "Vulnerability Location": "_onDepositETH() function in GiantMevAndFeesPool contract", "Repair Method": "When deposit happens, contract should first send remaining rewards, then increase the user's balance and then set the user claim to max.", "Vulnerability Information": "When `_onDepositETH()` is called in giant pool, it calls `_setClaimedToMax()` to make sure new ETH stakers are not entitled to ETH earned by previous stakers, but this can cause users to lose their remaining rewards when they deposit."}

1. {"Vulnerability Type": "Incorrect checking", "Vulnerability Location": "_assertUserHasEnoughGiantLPToClaimVaultLP()", "Repair Method": "Check the LPToken being operated on for lastInteractedTimestamp rather than lpTokenETH", "Vulnerability Information": "The batch operations of `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol are meaningless because they will fail whenever more than one lpToken is passed."}
2. {"Vulnerability Type": "DAO commission", "Vulnerability Location": "_updateDAORevenueCommission()", "Repair Method": "Add a maximum cap on how much commission DAO can take from node runners", "Vulnerability Information": "Node runners can have all their stake rewards taken by the DAO as commissions can be set to a 100%."}
3. {"Vulnerability Type": "Minimum balance", "Vulnerability Location": "batchRotateLPTokens()", "Repair Method": "Dynamically calculate the minimum balance for rotating LP Tokens", "Vulnerability Information": "The `GiantSavETHVaultPool` and `GiantMevAndFeesPool` both have a `batchRotateLPTokens` function that allows to move staked ETH to another key."}
4. {"Vulnerability Type": "ETH amount check", "Vulnerability Location": "withdrawETH()", "Repair Method": "Remove the `require(_amount = MIN_STAKING_AMOUNT, \"Invalid amount\");` statement", "Vulnerability Information": "The `GiantPoolBase.withdrawETH` function requires that the amount to withdraw is at least as big as the `MIN_STAKING_AMOUNT`."}
5. {"Vulnerability Type": "Address check", "Vulnerability Location": "registerBLSPublicKeys()", "Repair Method": "Build the protocol with the assumption that `_eoaRepresentative == EOA`", "Vulnerability Information": "The underlying assumption of `eoaRepresentative` being an EOA can be untrue."}

{"Vulnerability Type": "Authorization", "Vulnerability Location": "registerBLSPublicKeys function", "Repair Method": "Use isBLSPublicKeyBanned instead of isBLSPublicKeyPartOfLSDNetwork", "Vulnerability Information": "Banned BLS public keys can still be registered as the function isBLSPublicKeyPartOfLSDNetwork only checks if the public key is part of the LSD network and not if it is banned."}

