{"Vulnerability Type": "optional flash loan risk mitigation", "Vulnerability Location": "switchEoaOnly() function", "Repair Method": "Add logic preventing multiple txs to the protocol from the same address/tx.origin within the same block when smart contracts are allowed", "Vulnerability Information": "The current mitigation is to optionally prevent contracts, except whitelisted partner ones, from interacting with the protocol to prevent any flash loan manipulations. A more robust approach would be to add logic preventing multiple txs to the protocol from the same address/tx.origin within the same block when smart contracts are allowed."}

{"Vulnerability Type": "implicit underflows", "Vulnerability Location": "Exposure.sol L178, PnL.sol L112, Buoy3Pool.sol L87", "Repair Method": "Replace int256(a-b) with int256(a)-int256(b), and replace int256(-x) with -int256(x)", "Vulnerability Information": "There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert."}

{"Vulnerability Type": "safe address cannot be removed", "Vulnerability Location": "addSafeAddress() function", "Repair Method": "Change addSafeAddress() to isSafeAddress() with an additional bool parameter to allow both the enabling AND disabling of safe addresses", "Vulnerability Information": "If there is a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern."}

{"Vulnerability Type": "incorrect use of operator", "Vulnerability Location": "require() on L357 of Controller.sol", "Repair Method": "Change || to && in require() on L357 of Controller.sol to prevent arbitrary addresses from going past this check. Or, consider exercising explicit access control for the authorized vault adaptors.", "Vulnerability Information": "The operator used in the require() is || instead of &&, which allows an arbitrary msg.sender, i.e. attacker, to bypass the check."}

{"Vulnerability Type": "early user can break minting", "Vulnerability Location": "GToken.factor() function", "Repair Method": "On first mint (total base supply == 0), lock some of the first minter's tokens by minting ~1% of the initial amount to the zero address instead of to the first minter", "Vulnerability Information": "The first user can manipulate the factor such that it always returns 0. This means all deposits and future value accrues to the attacker who holds the only base tokens."}

1. {"Vulnerability Type": "High Severity", "Vulnerability Location": "Exposure.sol L178", "Repair Method": "Initializing `maxDelta` and `minDelta`, Check that `maxIndex` and `minIndex` are not the same, require (`maxIndex` != `minIndex`)", "Vulnerability Information": "The function `sortVaultsByDelta` doesn't always work as expected."}
2. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "Buoy3Pool.sol L207 and L214-L216", "Repair Method": "Use the `latestRoundData` function to get the price instead, add checks on the return data with proper revert messages if the price is stale or the round is incomplete", "Vulnerability Information": "Use of deprecated Chainlink function `latestAnswer`."}
3. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "Buoy3Pool", "Repair Method": "Add checks similar to `latestTimestamp` and `latestRoundare`, make `calculateShare` an abstract function that is implemented in the specific adaptors", "Vulnerability Information": "Usage of deprecated ChainLink API in `Buoy3Pool`."}
4. {"Vulnerability Type": "High Severity", "Vulnerability Location": "Buoy3Pool.safetyCheck", "Repair Method": "Check if `b/c` is within `BASIS_POINTS`", "Vulnerability Information": "`safetyCheck` function has several issues that impact how precise the checks are."}

