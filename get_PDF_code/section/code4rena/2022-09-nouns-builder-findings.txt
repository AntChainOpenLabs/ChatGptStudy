{"Vulnerability Type": "Loss of Veto Power can Lead to 51% Attack", "Vulnerability Location": "Governor.sol#L76, Governor.sol#L596-L602", "Repair Method": "Add zero address check for vetoer address at initialize(). Change updateVetoer() vetoer address changing process to 2-step process", "Vulnerability Information": "Lack of zero address check and lack of 2 step address changing process for vetoer address can lead to DAO owner losing their veto power unintentionally and open to 51% attack which can drain their entire treasury."}

{"Vulnerability Type": "Tokens without properties can be minted and cannot be rendered", "Vulnerability Location": "MetadataRenderer.sol#L171, MetadataRenderer.sol#L216-L219, MetadataRenderer.sol#L222", "Repair Method": "In the onMinted() function of MetadataRenderer, ensure that properties.length is greater than 0", "Vulnerability Information": "It's possible to mint tokens when properties haven't yet been set in MetadataRenderer. Such tokens won't be possible to render due to a check in the getAttributes function of MetaRenderer contract. There's no way to fix such tokens after they were minted since the number of properties of each token is stored individually, thus a patched MetadataRenderer and a proxy contract need to be deployed."}

{"Vulnerability Type": "Increasing voting power by incentivizing", "Vulnerability Location": "Governor.sol#L248-L297", "Repair Method": "Add blacklist check for `_castVote` function and create a function to delete the voting power and add the address to the blacklist", "Vulnerability Information": "If the benefit to be gained from the outcome of the vote is less than the cost of obtaining the right to vote, the outcome of the vote is influenced."}

{"Vulnerability Type": "Changing treasury owner through transferOwnership() can break Governer.sol and Auction.sol", "Vulnerability Location": "Governor.sol#L21, Ownable.sol#L63, Auction.sol#L22", "Repair Method": "Modify `transferOwnership()` in the relevant contracts so that if ownership is transferred, then `settings.treasury` is changed accordingly", "Vulnerability Information": "If ownership is transferred, then `settings.treasury` is not modified when subsequent proposals are passed, and therefore `settings.treasury` is not able to modify any governance parameters such as `proposalThreshold`."}

{"Vulnerability Type": "Malicious pausing the contract", "Vulnerability Location": "Auction.sol#L204, Auction.sol#L206, Auction.sol#L235", "Repair Method": "Add a special check for upper bound of `gasLeft` at start of `_createAuction` function", "Vulnerability Information": "Contract can be paused by any user by passing special amount of gas for the call of `settleCurrentAndCreateNewAuction`."}

1. {"Vulnerability Type": "Incorrect computation", "Vulnerability Location": "Token.sol#L118", "Repair Method": "Replace the line 118 of `Token.sol` by `baseTokenId = (baseTokenId + schedule) % 100;`", "Vulnerability Information": "The IDs of the founders tokens are wrongly computed, some of them can have an id higher than 100 and then never be minted."}
2. {"Vulnerability Type": "Delegation to address(0)", "Vulnerability Location": "ERC721Votes.sol#L179-L190", "Repair Method": "Don't allow delegation to address(0) by adding a check or if someone tries to delegate to address(0), delegate to the NFT owner instead", "Vulnerability Information": "If a user delegates to address(0) that vote gets lost."}

{"Vulnerability Type": "Double voting power through self delegation", "Vulnerability Location": "ERC721Votes contract", "Repair Method": "Make the delegates function public rather than external and call this function rather than accessing the delegation mapping directly", "Vulnerability Information": "The owner of one or many ERC721Votes tokens can double their voting power once (and only once) by delegating to their own address as their first delegation. This exploit relies on the initial default value of the delegation mapping in ERC721Votes, which is why it will only work once per address."}

1. {"Vulnerability Type": "Mismatching length", "Vulnerability Location": "MetadataRenderer.addProperties()", "Repair Method": "Check length of both arrays in MetadataRenderer.addProperties() method", "Vulnerability Information": "It is not possible to mint a ERC721 token if its properties has different length than its items."}
2. {"Vulnerability Type": "Unchecked operation", "Vulnerability Location": "ERC721Votes._afterTokenTransfer()", "Repair Method": "Change delegate transfer in afterTokenTransfer to _moveDelegateVotes(delegates(_from), delegates(_to), 1)", "Vulnerability Information": "User can get unlimited votes"}
3. {"Vulnerability Type": "Front-running", "Vulnerability Location": "Governor.propose()", "Repair Method": "Add a per-account nonce storage variable to the Governor contract and include the proposalCreatorNonces[msg.sender]++ nonce within the computed proposal id", "Vulnerability Information": "Creating a new governance proposal can be prevented by anyone"}

1. {"Vulnerability Type": "Auction parameters can be changed during ongoing auction", "Vulnerability Location": "Auction.sol#L307-L335", "Repair Method": "Do not apply changed parameters on ongoing auctions. Add a timelock for the changes", "Vulnerability Information": "The auction parameters can be changed anytime, even during ongoing auctions, and take effect immediately. Users may need time to react to the changes."}
2. {"Vulnerability Type": "Minting is not possible when a property has no items", "Vulnerability Location": "MetadataRenderer.sol#L194", "Repair Method": "Ensure that each newly added property has at least one item. After adding properties and items, ensure that the next token can be minted and rendered without errors", "Vulnerability Information": "If a property without items was added, minting becomes impossible."}
3. {"Vulnerability Type": "Compromised or malicious vetoer can veto any proposals with unrestricted power", "Vulnerability Location": "Governor.sol#L385-L405", "Repair Method": "Consider adding a token supply threshold governance configuration. After the token supply exceeds this threshold, restrict the vetoer's power by allowing them to veto a proposal only during a defined period after the voting is done or only when the number of support and against votes are very close or the number of support votes is much higher than the against votes", "Vulnerability Information": "The `settings.vetoer`, which is the first founder defined by the `FounderParams`, can call the `veto` function to veto any proposals that are not yet executed, which immediately blocks these proposals from execution."}

1. {"Vulnerability Type": "Incorrect token distribution", "Vulnerability Location": "Token::_addFounders, mint function, burn function", "Repair Method": "Decrement settings.totalSupply value when a token is burned or adjust founder's percentage based on the actual available tokens", "Vulnerability Information": "When tokens are burned, the percentage of founder's tokens increases, and the increasing speed depends on how many tokens were not sold."}
2. {"Vulnerability Type": "Incorrect quorum calculation", "Vulnerability Location": "Governor.sol", "Repair Method": "Adjust the calculations in proposal.quorum() and governor.proposalThreshold() in such a way that they take into account the burned tokens and the tokens currently held by the auction contract or decrease token.totalSupply() whenever a token gets burned", "Vulnerability Information": "The protocol calculates the quorumVotes taking into account burned tokens and tokens held in the auction contract, which don't have any actual voting power."}

{"Vulnerability Type": "Delegation to zero address", "Vulnerability Location": "ERC721Votes's delegate() and delegateBySig() functions", "Repair Method": "Prohibit zero address as a delegation destination by adding a check in the _delegate() function", "Vulnerability Information": "Delegating to zero address results in owner's votes elimination in the checkpoint, which disables governance token burning and transfer whenever the owner delegated to zero address. The vulnerability can be fixed by prohibiting zero address as a delegation destination."}

{"Vulnerability Type": "DAO proposal can pass with 0 votes in favor", "Vulnerability Location": "Governor.sol#L441", "Repair Method": "Require at least 1 vote for a proposal to be considered Succeeded", "Vulnerability Information": "A proposal can be created directly after deployment and can pass even if nobody votes, giving an attacker sudo powers. This is due to `proposal.proposal.proposalThreshold` and `proposal.quorumVotes` being set to 0 at such early stages."}

1. {"Vulnerability Type": "Truncation in casting", "Vulnerability Location": "initialize function of the `Token` contract", "Repair Method": "Don't truncate the `founderPct` variable to a uint8 when adding it to the totalOwnership variable, or alternatively check that it is less than `type(uint8).max` (or less or equal to 100)", "Vulnerability Information": "The initialize function of the `Token` contract receives an array of `FounderParams`, which contains the ownership percent of each founder as a `uint256`. The initialize function checks that the sum of the percents is not more than 100, but the value that is added to the sum of the percent is truncated to fit in `uint8`. This leads to an error because the value that is used for assigning the base tokens is the original, not truncated, `uint256` value."}
2. {"Vulnerability Type": "Governance settings vulnerability", "Vulnerability Location": "Governor.sol#L588", "Repair Method": "Implement reasonable range bounds reverting where appropriate. In particular for the above apply:*   Governor settings `quorumThresholdBps` <= 10_000*   Governor settings `proposalThresholdBps` <= 10_000*   Treasury settings `delay` <= 6 months*   Auction settings `duration` <= 6 months*   Auction settings `timeBuffer` <= 6 monthsAdd these checks to the `initialize()` functions and in the setter / update functions where these individual settings properties can be updated.", "Vulnerability Information": "The protocol assumes founders and proposals will set sane settings. However there are some settings that if set incorrectly will block proposals from being created or succeeding and block auctions from completing."}
3. {"Vulnerability Type": "Founder percentages not always respected", "Vulnerability Location": "Token.sol#L110", "Repair Method": "Consider using another distribution scheme. Instead of the current 'greedy' scheme (minting until a slot is free), it would make sense to mint the tokens for the founders every 100 tokens, i.e. everytime when `tokenId % 100 == 0`. Like that, it is ensured that the actual percentages are equal to the desired percentages.", "Vulnerability Information": "Because of the 'greedy' minting scheme for founders (tokens to founders are minted until `_isForFounder

1. {"Vulnerability Type": "Indefinite increase in voting power", "Vulnerability Location": "_transferFrom() function", "Repair Method": "Votes should only be counted when delegated", "Vulnerability Information": "It is possible to indefinitely increase voting power by creating new accounts (addresses) and delegating. This will lead to unfair governance as a user can vote with more votes than actual."}
2. {"Vulnerability Type": "Irretrievably stuck highest bid", "Vulnerability Location": "Auction.sol#L248-L254", "Repair Method": "Force settle if a bid was there, or handle token0 like any other", "Vulnerability Information": "If the first auction is paused and unpaused in a protocol deployed with no founder fees, the highest bid (as well as the first NFT), will get stuck in the protocol with no ability to retrieve either of them."}

{"Vulnerability Type": "infinite loop", "Vulnerability Location": "Token.sol#L179", "Repair Method": "Use `_tokenId` instead of `baseTokenId`", "Vulnerability Information": "The `Token::mint` function has a while loop which will keep looping as long as `_isForFounder` returns true. The `_isForFounder` function will return true if the given `_tokenId`'s recipient is still vesting. However, to check the recipient it is checking the `baseTokenId` which is `_tokenId % 100`. If the `tokenRecipient` of 0 to 99 are currently vesting, it will keep returning true and the while loop in the `mint` function will not stop."}

{"Vulnerability Type": "index out of bounds", "Vulnerability Location": "MetadataRenderer.sol#L188-L198", "Repair Method": "The maximum amount of properties an owner can add should be less than the maximum amount of attributes any token can have. Consider either limiting the `properties` variable in `MetadataRenderer.sol` to 15 or allow any number of attributes to be added to a token.", "Vulnerability Information": "When a token is minted, the `MetadataRenderer.sol` `onMinted` function is called which will set the particular token's attributes to a random item from one of the properties. A token has a maximum of 16 attributes, the first one being the total number of properties. The properties from which the token receives its attributes are supplied by the owner of the `MetadataRenderer.sol` contract by calling `addProperties`. The issue is that the number of properties the owner can supply is not limited. If the number of properties is more than 15 then the `onMinted` function will revert due to the limit on the number of attributes a token may have."}

{"Vulnerability Type": "try-catch block", "Vulnerability Location": "Auction.sol#L234", "Repair Method": "Remove the `Error` so that it'll catch any kind of revert", "Vulnerability Information": "The `_createAuction` function wraps the `token.mint()` call in a try-catch block, however this will only catch reverts that comes from the require keyword and not the reverts with custom errors or other kinds of errors (arithmetic over/underflow etc.). In case of an error at the `mint()` function the auction won't be settled till the owner intervenes and pauses the contract."}

1. {"Vulnerability Type": "Delegation vulnerability", "Vulnerability Location": "_afterTokenTransfer() callback function in ERC721Votes.sol", "Repair Method": "Include delegates() call in _afterTokenTransfer() function to deal with the delegate instead of the owner", "Vulnerability Information": "If a user delegates their votes to themselves and then delegates to someone else, their NFT transfers and burning will be disabled due to the _afterTokenTransfer() callback function running the _moveDelegateVotes() with an owner instead of the delegate."}
2. {"Vulnerability Type": "Low quorum votes vulnerability", "Vulnerability Location": "quorum() and propose() functions in Governor.sol", "Repair Method": "Add a minimum quorum votes governance configuration that is at least 1 or set proposal.quorumVotes to the minimum quorum votes when quorum() returns 0", "Vulnerability Information": "At the early stage of the deployed DAO, it is possible that the quorum votes have no effect at all for determining whether the proposal is defeated or succeeded when the token supply is low, which can lead to critical proposals being passed or vice versa."}

{"Vulnerability Type": "Incorrect vote accounting", "Vulnerability Location": "ERC721Votes.getPastVotes(..) function", "Repair Method": "Batch multiple checkpoints writes per block/timestamp", "Vulnerability Information": "Multiple vote checkpoints per block will lead to incorrect vote accounting"} 

{"Vulnerability Type": "Quorum could be less than intended", "Vulnerability Location": "Governor contract", "Repair Method": "Compute the total supply afterwards or take the vote with a timestamp of proposal.timeCreated 1 to not count the block during which the tx was submitted", "Vulnerability Information": "There could be tokens minted between the quorum computation and the vote, which would lead to a quorum lower than intended."}

{"Vulnerability Type": "Precision issue", "Vulnerability Location": "Governor contract", "Repair Method": "Increase division to a more precise value such as 1e18 to allow high total supply NFT to always set threshold as 1", "Vulnerability Information": "Precision is not enough for proposalThreshold and quorum. Collections with at least 20000 NFTs in total supply may have some trouble."}

1. {"Vulnerability Type": "Cancellation vulnerability", "Vulnerability Location": "Governor.sol", "Repair Method": "Change the check in `cancel` to match the requirement in `propose`", "Vulnerability Information": "A proposal can be cancelled by anyone if the proposal has exactly proposalThreshold votes."}
2. {"Vulnerability Type": "Voting vulnerability", "Vulnerability Location": "Governor.sol", "Repair Method": "Governance configuration can be added to indicate whether the majority of votes is needed or not for supporting and passing a proposal", "Vulnerability Information": "State function does not require majority of votes for supporting and passing a proposal."}

