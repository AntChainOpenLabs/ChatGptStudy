1. {"Vulnerability Type": "DOS and fund loss", "Vulnerability Location": "Staking contract's rebase() function and Yieldy contract's rebase() function", "Repair Method": "Set a high initial value for rebasingCredits to prevent the attack", "Vulnerability Information": "It's possible to perform DOS and fund loss in Staking by transferring tokens directly to the contract and making rebasingCredits / updatedTotalSupply equal to 0."}
2. {"Vulnerability Type": "User fund loss", "Vulnerability Location": "LiquidityReserve contract's addLiquidity() function", "Repair Method": "Add more precision when calculating IrToken to prevent the attack", "Vulnerability Information": "It's possible for an attacker to manipulate totalLockedValue and make totalLockedValue/lrFoxSupply very high, causing users to receive very low IrToken and lose funds."}

{"Vulnerability Type": "Yield of LiquidityReserve can be stolen", "Vulnerability Location": "LiquidityReserve.sol", "Repair Method": "store the earned fees and distribute them across multiple blocks to make sure the attack wouldnâ€™t be worth it, add a small fee when removing liquidity, which would make the attack unprofitable, prevent users from withdrawing before X blocks or add a locking mechanism", "Vulnerability Information": "Using sandwich attacks and JIT (Just-in-time liquidity), the yield of `LiquidityReserve` could be extracted for liquidity providers."}

{"Vulnerability Type": "Cannot mint to exactly max supply using _mint function", "Vulnerability Location": "_mint function in the contract", "Repair Method": "Change to require(_totalSupply <= MAX_SUPPLY, \"Max supply\");", "Vulnerability Information": "Cannot mint to exactly max supply using `_mint` function."}

{"Vulnerability Type": "Removal of liquidity from the reserve can be griefed", "Vulnerability Location": "LiquidityReserve.sol and Staking.sol", "Repair Method": "Keep track of submitted amounts during the cooldown, and batch-submit them during the next open window, rather than making it first-come-first-served", "Vulnerability Information": "Users may be unable to withdraw/remove their liquidity from the `LiquidityReserve` if a user decides to grief the contract."}

1. {"Vulnerability Type": "Incorrect rebase percentage calculation", "Vulnerability Location": "Yieldy.sol line 91", "Repair Method": "Check if updatedTotalSupply is greater than MAX_SUPPLY before calling _storeRebase function", "Vulnerability Information": "If updatedTotalSupply is greater than MAX_SUPPLY, the _profit amount is not fully used, but _storeRebase function is still called with _profit amount, leading to incorrect rebasePercent calculation."}
2. {"Vulnerability Type": "Burn access control can be bypassed", "Vulnerability Location": "transferFrom function in Yieldy.sol", "Repair Method": "Add a non-zero address check for _to argument in transferFrom function", "Vulnerability Information": "The transferFrom method does not check if the _to argument is the zero address, which can lead to token burns without calling the burn function, bypassing the access control onlyRole(MINTER_BURNER_ROLE)."}
3. {"Vulnerability Type": "Users of Migration.sol may forfeit rebase rewards", "Vulnerability Location": "moveFundsToUpgradedContract function in Migration.sol", "Repair Method": "Add an input bool _trigger and call rebase function if _trigger is true", "Vulnerability Information": "Users of moveFundsToUpgradedContract function in Migration.sol may forfeit rebase rewards because it calls instantUnstake(false), skipping the optional rebase. Adding an input bool _trigger and calling rebase function if _trigger is true allows users to optionally call rebase if they are concerned about losing pending rebase rewards."}
4. {"Vulnerability Type": "Token transfers in LiquidityReserve and Staking contract don't support deflationary ERC20 tokens, and user funds can be lost if stacking token was deflationary", "Vulnerability Location": "Staking.sol line 419-445 and LiquidityReserve.sol line 120-126", "Repair Method": "Do not support deflationary tokens", "Vulnerability Information": "If the token is deflationary, the contract will receive less token than requested amount, but the contract does not check for the real transferred amount. This can cause other users who staked to lose funds. The protocol logics are not suitable for deflationary tokens and funds would be lost."}
5. {"Vulnerability Type": "Inconsistent balance when fee-on transfer tokens", "Vulnerability Location": "Yieldy.sol line 54", "Repair Method": "Get the before balance, then safeTransferFrom, and then get the after balance to make sure no fees were added", "Vulnerability Information": "When IERC20Upgradeable(TOKE_TOKEN) is set to totalTokeAmount, it will be different once safetransfer has fees as some types of tokens may charge a certain fee for transfer and transferfrom. It may be better to get the before balance, then safeTransferFrom, and then get the after balance to make sure no fees were added."}
6. {"Vulnerability Type": "MINIMUM_LIQUIDITY checks missing - Bringing Liquidity below required min", "Vulnerability Location": "removeLiquidity function in LiquidityReserve.sol", "Repair Method": "Add a check to require that the balance liquidity is greater than MINIMUM_LIQUIDITY", "Vulnerability Information": "The whale who provided most liquidity to the contract can simply use removeLiquidity function and can remove all of their liquidity. This can leave the residual liquidity to be less than MINIMUM_LIQUIDITY, which is incorrect."}
7. {"Vulnerability Type": "MINTER_BURNER_ROLE can burn any amount of Yieldy from an arbitrary address", "Vulnerability Location": "Yieldy.sol", "Repair Method": "Change burn() function to only allow the caller to burn their own tokens", "Vulnerability Information": "Using the burn() function of Yieldy, an address with MINTER_BURNER_ROLE can burn an arbitrary amount of tokens from any address, posing a serious centralization risk. Consider removing the MINTER_BURNER_ROLE and changing the burn() function to only allow the caller to burn their own tokens."}

1. {"Vulnerability Type": "Arbitrage", "Vulnerability Location": "function stake(uint256 _amount, address _recipient) public {", "Repair Method": "Set a high enough fee on instantUnstakeReserve to make arbitrage not profitable. Potentially disallow the warm-up period to be violated for instant unstaking through curve at the very least.", "Vulnerability Information": "There is a huge arbitrage opportunity for people who deposit 1 block before the `rebase()`. They can call `instantUnstakeReserve` or `instantUnstakeCurve` to unstake the staked amount, increasing the profit that needs to be distributed on the next rebase. The `instantUnstakeReserve` does not burn the `YIELD_TOKEN`, and even if there is a fee on it, there is still a chance for profit."}
2. {"Vulnerability Type": "Denial of Service", "Vulnerability Location": "function removeAddress(uint256 _index) public {", "Repair Method": "Use `pop` to remove an entry in an array and move the last element to the removed entry position.", "Vulnerability Information": "The `BatchRequests.removeAddress` logic is wrong and will produce a denial of service. Removing the element from the array is done using the `delete` statement, which is not the proper way to remove an entry from an array. It will just set that position to `address(0)`, causing the call to `canBatchContracts` to `address(0)` and denying service."}
3. {"Vulnerability Type": "Logic Flaw", "Vulnerability Location": "function claim(address _recipient) public {", "Repair Method": "Call the rebase function before calling the function in the Yieldy contract that uses the rebasingCreditsPerToken variable.", "Vulnerability Information": "In the Yieldy contract, functions such as balanceOf/creditsForTokenBalance/tokenBalanceForCredits/transfer/transferFrom/burn/mint will use the rebasingCreditsPerToken variable, so before calling these functions in the Staking contract, make sure that the rebase of this epoch has occurred. Therefore, the rebase function should also be called in the unstake/claim/claimWithdraw function of the Staking contract."}
4. {"Vulnerability Type": "Withdrawal Issue", "Vulnerability Location": "function withdraw(uint256 _amount, bool asEth) external {", "Repair Method": "Handle the case where the underlying asset is WETH/ETH separately and pass this boolean in that case.", "Vulnerability Information": "The `withdraw` function of the ETH Tokemak pool has an additional parameter `asEth`. When the staking token is ETH/WETH and no withdrawals would be possible, the call to `withdraw` will fail, leaving the funds locked."}
5. {"Vulnerability Type": "Denial of Service", "Vulnerability Location": "function stake(uint256 _amount, address _recipient) public {", "Repair Method": "Disallow deposit to another address when `warmUpPeriod > 0`.", "Vulnerability Information": "In the `Staking.sol#stake()` function, you can specify an arbitrary address as the `_recipient`. When `warmUpPeriod > 0`, with as little as 1 wei of `YIELDY_TOKEN`, the `_recipient`'s `warmUpInfo` will be pushed back until `epoch.number + warmUpPeriod`. Consider changing to not allow deposit to another address when `warmUpPeriod > 0`."}

1. {"Vulnerability Type": "Unsecure transferFrom", "Vulnerability Location": "Yieldy.sol#L212", "Repair Method": "Check that the from account has a creditAmount balance.", "Vulnerability Information": "The security of the Yieldy contract is delegated to the compiler used. The allowance of an account does not have to reflect the real balance of an account, however in the transferFrom method, it is the value that is checked in order to verify that the user has enough balance to make the transfer."}
2. {"Vulnerability Type": "coolDown & warmUp period do not work when a low _firstEpochEndTime is passed to initialize", "Vulnerability Location": "Staking.sol constructor", "Repair Method": "Require that _firstEpochEndTime is larger than block.timestamp or set the expiry of the first epoch to block.timestamp + _epochDuration.", "Vulnerability Information": "In the constructor of Staking.sol, it is not enforced that the _firstEpochEndTime is larger than the current block.timestamp. If a low value is accidentally passed (or even 0), rebase can be called multiple times in succession, causing the epoch.number to increase."}
3. {"Vulnerability Type": "Staking preSign could use some basic validations", "Vulnerability Location": "Staking.sol#preSign", "Repair Method": "Add basic validation for tokenOut, minOut and receiver.", "Vulnerability Information": "The function preSign accepts any orderUid. Because of how Cowswap works, accepting any orderUid can be used as a rug-vector."}
4. {"Vulnerability Type": "Rebases can be frontrun with very little token downtime even when warmUpPeriod > 0", "Vulnerability Location": "Staking.sol#instantUnstakeCurve", "Repair Method": "Tokens unstaked during the warm up period should not be allowed to accumulate any rebases.", "Vulnerability Information": "Rebases can be frontrun with very little token downtime even when warmUpPeriod > 0. A user can call stake the block before epoch.endTime <= block.timestamp, allowing the user to bypass the forced rebase called in L416 of the the stake function."}
5. {"Vulnerability Type": "instantUnstake fee can be avoided", "Vulnerability Location": "Staking.sol#instantUnstake", "Repair Method": "Calculate amount less fee using a muldiv operation over (1 - fee).", "Vulnerability Information": "Users can utilize the instantUnstake function without paying the liquidity provider fee using rounding errors in the fee calculation."}
6. {"Vulnerability Type": "Staking: rebase() does not rebase according to the status of the current epoch.", "V

1. {"Vulnerability Type": "DoS", "Vulnerability Location": "BatchRequests.sendWithdrawalRequests", "Repair Method": "Add `offset` and `limit` function parameters to implement a \"paginated\" for loop.", "Vulnerability Information": "Sending batch withdrawal requests can possibly DoS due to reaching the block gas limit."}
2. {"Vulnerability Type": "Approval", "Vulnerability Location": "Staking.setCurvePool", "Repair Method": "Set approvals for the new curve pool address in the same `setCurvePool()` function.", "Vulnerability Information": "No way to set CURVE_POOL approval after setting new curve pool address."}
3. {"Vulnerability Type": "Incorrect Withdrawal", "Vulnerability Location": "_requestWithdrawalFromTokemak function", "Repair Method": "Modify Staking.sol#L326 to if (amountToRequest > 0) tokePoolContract.requestWithdrawal(amountToRequest);", "Vulnerability Information": "Incorrect withdrawal requested."}
4. {"Vulnerability Type": "Out-of-gas", "Vulnerability Location": "BatchRequests.sol#L16, BatchRequests.sol#L36, BatchRequests.sol#L91", "Repair Method": "Use a pattern that includes `from` and `to` parameters to limit the number of iterations in the for loop.", "Vulnerability Information": "Possible DOS (out-of-gas) on loops."}
5. {"Vulnerability Type": "Withdrawal", "Vulnerability Location": "sendWithdrawalRequest function", "Repair Method": "Remove the requirement in L362 that checks if currentCycleIndex is equal to lastTokeCycleIndex.", "Vulnerability Information": "Withdrawals initiated after cycle withdrawal request won't be withdrawn in the correct cycle."}
6. {"Vulnerability Type": "Withdrawal", "Vulnerability Location": "unstake function", "Repair Method": "Make `rebase()` mandatory when calling `unstake()`.", "Vulnerability Information": "User can initiate withdraw for previous epoch if rebase hasn't been called since end of epoch."}
7. {"Vulnerability Type": "Frontrunning", "Vulnerability Location": "instantUnstake function", "Repair Method": "Introduce an upper limit for fees and add timelock to change fee size.", "Vulnerability Information": "instantUnstake function can be frontrunned with fee increase."}

