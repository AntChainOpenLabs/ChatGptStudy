1. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "TridentNFT.permit function", "Repair Method": "Change the require logic to recoveredAddress != address(0) && (recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress])", "Vulnerability Information": "If a user accidentally set the zero address as the operator, tokens can be stolen by anyone as a wrong signature yield recoveredAddress == 0."}
2. {"Vulnerability Type": "High Severity", "Vulnerability Location": "ConcentratedLiquidityPoolManager.sol#L90-L94", "Repair Method": "Lock the positions during a set time while they are staked.", "Vulnerability Information": "Possible attacks on Seconds * Liquidity calculation."}
3. {"Vulnerability Type": "High Severity", "Vulnerability Location": "ConcentratedLiquidityPoolManager.reclaimIncentive function", "Repair Method": "In reclaimIncentive, reduce incentive.rewardsUnclaimed by the withdrawn amount.", "Vulnerability Information": "ConcentratedLiquidityPoolManager's incentives can be stolen."}
4. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "Incentive.addIncentive function", "Repair Method": "Add a check: require(incentive.secondsClaimed == 0, '!secondsClaimed')", "Vulnerability Information": "Incentive should check that it hasn't started yet."}
5. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "ConcentratedLiquidityPoolManager.subscribe, getReward, and claimReward functions", "Repair Method": "Change positionId to incentiveId in the referenced lines of code.", "Vulnerability Information": "Wrong usage of positionId in ConcentratedLiquidityPoolManager."}
6. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "Incentives for different pools", "Repair Method": "Make sure the developers are at least aware of something like this when choosing incentive amounts for different pools. Carefully choose incentive amounts for each pool.", "Vulnerability Information": "Incentives for different pools should differ by a large factor."}

{"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "ConcentratedLiquidityPoolManager.sol, ConcentratedLiquidityPosition.sol, ConcentratedLiquidityPool.sol", "Repair Method": "Check whether the result of DyDxMath.getDy or DyDxMath.getDx exceeds type(uint128).max or not. If so, then revert the transaction. Or consider using the SafeCast library from OpenZeppelin instead. Consider removing the unchecked statement to check for integer overflow or casting both amount1Actual and reserve1 to type uint256 before adding them and comparing to the _balance(token). Consider making ConcentratedLiquidityPosition.sol#burn() always use address(this) as recipient and transfer proper amounts to the user. Make adding token0 or token1 as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when collect().", "Vulnerability Information": "Multiple vulnerabilities in the smart contract code of the Concentrated Liquidity Pool of SushiSwap, including integer overflow, incorrect usage of typecasting, and wrong implementation, which could allow attackers to steal yield or funds from the pool."}

{"Vulnerability Type": "unsafe cast", "Vulnerability Location": "ConcentratedLiquidityPool.burn function", "Repair Method": "Use SafeCast library everywhere a typecast is done", "Vulnerability Information": "The burn function performs an unsafe cast of a uint128 type to a *signed* integer."}

{"Vulnerability Type": "uninitialized variable", "Vulnerability Location": "ConcentratedLiquidityPoolManager.claimReward function", "Repair Method": "Set stake.initialized before calling claimReward function", "Vulnerability Information": "The claimReward function requires stake.initialized but it is never set."}

{"Vulnerability Type": "incorrect variable update", "Vulnerability Location": "ConcentratedLiquidityPool.burn function", "Repair Method": "Decrease the reserve by what is transferred out", "Vulnerability Information": "The burn function sends out amount0/amount1 tokens but only updates the reserves by decreasing it by the fees of these amounts."}

{"Vulnerability Type": "integer underflow", "Vulnerability Location": "ConcentratedLiquidityPoolManager.claimReward and getReward functions", "Repair Method": "Check whether the rewards exceeds the incentive.rewardsUnclaimed", "Vulnerability Information": "There could be an integer underflow error when the reward of an incentive is claimed, forcing users to wait for a sufficient period or reduce their liquidity to claim the rewards."}

{"Vulnerability Type": "incorrect variable update", "Vulnerability Location": "ConcentratedLiquidityPool.mint/burn functions", "Repair Method": "Change the inequalities to if (priceLower <= currentPrice && currentPrice < priceUpper)", "Vulnerability Information": "The mint/burn functions add/remove liquidity when (priceLower < currentPrice && currentPrice < priceUpper). Shouldn't it also be changed if priceLower == currentPrice?"}

{"Vulnerability Type": "incorrect variable update", "Vulnerability Location": "ConcentratedLiquidityPool.secondsPerLiquidity variable", "Repair Method": "Update secondsPerLiquidity prior to the change in liquidity", "Vulnerability Information": "secondsPerLiquidity should be modified whenever pool liquidity changes."}

{"Vulnerability Type": "unsafe math", "Vulnerability Location": "ConcentratedLiquidityPool.rangeFeeGrowth and rangeSecondsInside functions", "Repair Method": "Use unchecked math", "Vulnerability Information": "The fee growth mechanism, and by extension, secondsPerLiquidity mechanism of Uniswap V3 has the ability to underflow. It is therefore a necessity for the math to (ironically) be unsafe / unchecked."}

1. {"Vulnerability Type": "range fee growth underflow", "Vulnerability Location": "RangeFeeGrowth function in ConcentratedLiquidityPool.sol", "Repair Method": "Modify the tick's algorithm or RangeFeeGrowth function", "Vulnerability Information": "The function RangeFeeGrowth would revert the transaction in some cases when a pool crosses a tick, and feeGrowthBelow + feeGrowthAbove is not necessarily smaller than _feeGrowthGlobal."}
2. {"Vulnerability Type": "incorrect feeGrowthGlobal accounting when crossing ticks", "Vulnerability Location": "ConcentratedLiquidityPool.sol and Ticks.sol", "Repair Method": "Switch the 0 and 1 in Ticks.cross()", "Vulnerability Information": "Swap fees are taken from the output, but the logic in Ticks.cross() is reversed, causing wrong fee accounting."}
3. {"Vulnerability Type": "double yield when calling collect() before burn()", "Vulnerability Location": "ConcentratedLiquidityPosition.sol", "Repair Method": "Make ConcentratedLiquidityPosition.sol#burn() call position.pool.collect() before position.pool.burn(), or change ConcentratedLiquidityPosition.sol#collect() into a public method and call it after position.pool.burn()", "Vulnerability Information": "When a user calls ConcentratedLiquidityPosition.sol#collect() to collect their yield, they may get double the amount of yield when they call burn() to remove liquidity, which dilutes the yield belonging to other users."}
4. {"Vulnerability Type": "wrong implementation", "Vulnerability Location": "ConcentratedLiquidityPool.sol", "Repair Method": "Change reserve0 and reserve1 in ConcentratedLiquidityPool.burn() to subtract amount0 and amount1 instead of amount0fees and amount1fees", "Vulnerability Information": "The reserves are not updated correctly when LP tokens are burned, causing essential features of the contract to malfunction."}
5. {"Vulnerability Type": "initialPrice should be checked to be within allowable range", "Vulnerability Location": "ConcentratedLiquidityPool.sol", "Repair Method": "Check that initialPrice is within the acceptable range", "Vulnerability Information": "No check is performed for the initial price, which can prevent the usability of all other functions."}

1. {"Vulnerability Type": "Understanding vulnerability", "Vulnerability Location": "High Severity section", "Repair Method": "N/A", "Vulnerability Information": "Explanation of the fee growth mechanism and why using nearestTick as the reference point for fee growth calculations instead of the pool tick might not be a wise choice."}
2. {"Vulnerability Type": "Gas Limit vulnerability", "Vulnerability Location": "Medium Severity section", "Repair Method": "Have a starting index parameter to start the iteration from. Also, tickCount can be made use of more meaningfully to limit the number of iterations performed.", "Vulnerability Information": "getTickState() attempts to fetch the state of all inserted ticks (including MIN_TICK and MAX_TICK) of a pool. Depending on the tick spacing, this function may run out of gas."}

