1. {"Vulnerability Type": "Incorrect data location specifier", "Vulnerability Location": "withdrawBounty() function in Auction.sol", "Repair Method": "Change storage specifier of bounty to 'storage' instead of 'memory'", "Vulnerability Information": "The data location specifier used for bounty is memory which makes a copy of the _bounties array member instead of a reference, resulting in bounties never being set to inactive."}
2. {"Vulnerability Type": "Reentrancy", "Vulnerability Location": "mintTo() and burn() functions in Basket.sol", "Repair Method": "Move external calls after state updates in accordance with the check-effect-interact pattern", "Vulnerability Information": "The functions make external calls prior to updating the state, allowing attackers to mint free basket tokens and reenter the function to mint more tokens than deposited."}
3. {"Vulnerability Type": "Reentrancy", "Vulnerability Location": "settleAuction() function in Auction.sol", "Repair Method": "Move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern", "Vulnerability Information": "The function calls withdrawBounty() before setting auctionOngoing = false, allowing reentrancy and enabling a malicious publisher to bypass the index timelock mechanism and rug the basket."}
4. {"Vulnerability Type": "Owner privilege escalation", "Vulnerability Location": "Factory contract", "Repair Method": "Add a timelock to Factory functions or add checks in the setters to avoid specific edge cases", "Vulnerability Information": "The owner of Factory contract can modify the values of auctionMultiplier and auctionDecrement at any time, allowing them to steal all Basket funds during an auction."}
5. {"Vulnerability Type": "Unauthorized token transfer", "Vulnerability Location": "bondForRebalance() and settleAuction() functions in Auction.sol", "Repair Method": "Check outputTokens are part of the previous basket tokens", "Vulnerability Information": "If unrelated ERC20 tokens end up in the basket contract, anyone can use bondForRebalance() and settleAuction() to retrieve additional tokens, including bounties specified in a token that is not protected."}

1. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "settleAuction function in Auction.sol", "Repair Method": "Set a minimum ibRatio when a publisher publishes a new index and kill the auction if the ibRatio is too low", "Vulnerability Information": "The settleAuction function in Auction.sol can cause huge damage to the protocol if the newRatio is really close to zero under network failure."}
2. {"Vulnerability Type": "High Severity", "Vulnerability Location": "settleAuction function in Auction.sol", "Repair Method": "Add re-entrancy checks (for example, OpenZeppelin's 'locks') to the settleAuction function, require the list of input tokens to match the output, and set the time difference (bondTimestamp, auctionStart) to be 0 to negate the ability to further manipulate the ibRatio", "Vulnerability Information": "The settleAuction function in Auction.sol allows re-entrancy attacks that can steal all funds from the basket."}

1. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "validateWeights function in Basket contract", "Repair Method": "Change validateWeights to check for 0 length token", "Vulnerability Information": "Zero weighted baskets are allowed to steal funds."}
2. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "settleAuction function in Auction contract", "Repair Method": "Calculate the new irate in bondForRebalance", "Vulnerability Information": "settleAuction may be impossible if locked at a wrong time."}
3. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "bondForRebalance, settleAuction, and bondBurn functions in Auction contract", "Repair Method": "Move to a mapping of bonders that rebalance", "Vulnerability Information": "Bonding mechanism allows malicious user to DOS auctions."}
4. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "transfer function in Auction contract", "Repair Method": "Use safeTransfer or check the return value if length of returned data is 0", "Vulnerability Information": "Use safeTransfer instead of transfer."}

1. {"Vulnerability Type": "Incorrect approval", "Vulnerability Location": "createBasket function in Factory.sol", "Repair Method": "Find the balance of the current contract before and after the transferFrom to see how much tokens were received, and approve only what was received", "Vulnerability Information": "The function safeTransferFrom may not transfer exactly bProposal.weights[i] amount of tokens, for tokens with a fee on transfer. This means that the safeApprove call in the next line would be approving more tokens than what was received, leading to accounting issues."}
2. {"Vulnerability Type": "Admin privilege", "Vulnerability Location": "setAuctionMultiplier function in Factory.sol", "Repair Method": "Add a check to ensure that the auctionMultiplier is not set to zero", "Vulnerability Information": "Setting auctionMultiplier to zero by factory owner would stop the auction settling, function would always revert, causing a safe math error and newRatio to revert."}
3. {"Vulnerability Type": "Integer underflow", "Vulnerability Location": "handleFees function in Basket.sol", "Repair Method": "Add require statements to check that licenseFee is not greater than BASE", "Vulnerability Information": "If licenseFee is greater than BASE, line 118 in Basket.sol will always underflow and revert, causing no functions that contain handleFees() to pass."}
4. {"Vulnerability Type": "Lack of checks", "Vulnerability Location": "setBondPercentDiv function in Factory.sol", "Repair Method": "Add require statements to check that newBondPercentDiv is within a certain range", "Vulnerability Information": "setBondPercentDiv has no checks for min and max, allowing the owner to prevent bonding by setting the bondPercentDiv to 0."}
5. {"Vulnerability Type": "Minting vulnerability", "Vulnerability Location": "pullUnderlying function in Basket.sol", "Repair Method": "Add a check to pullUnderlying to require that tokenAmount is greater than 0", "Vulnerability Information": "If a user is minting a small amount of shares, the calculated amount of tokens to pull from the user can be less than 1, and therefore no tokens will be pulled. However, the shares would still be minted, allowing the user to end up with more tokens than they started with."}
6. {"Vulnerability Type": "Stealing user funds", "Vulnerability Location": "settleAuction function in Auction.sol", "Repair Method": "Add a sanity check in settleAuction to require that newRatio is greater than basket.ibRatio()", "Vulnerability Information": "If nobody has settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio is less than or equal to ibRatio, or even until newRatio is approximately 0, and then bond and settle and

{"Vulnerability Type": "Mishandling bounty state", "Vulnerability Location": "Auction.sol#withdrawBounty()", "Repair Method": "Change 'Bounty memory bounty' to 'Bounty storage bounty'", "Vulnerability Information": "Mishandling bounty state could potentially disrupt settleAuction() if bounty.active is not set to false when the bounty is claimed."}

{"Vulnerability Type": "Unintentional influence", "Vulnerability Location": "Factory.sol#setAuctionDecrement()", "Repair Method": "Add a timelock delay to all functions affecting protocol execution or add checks in setAuctionDecrement()", "Vulnerability Information": "The onlyOwner role can unintentionally frontrun a settleAuction() transaction by making changes to auctionDecrement and auctionMultiplier, potentially causing the auction bonder to overcompensate during a rebalance. Additionally, there is no way for an auction bonder to recover their tokens in the event this does happen."}

{"Vulnerability Type": "Failed auction freezing funds", "Vulnerability Location": "Basket.sol#auctionBurn()", "Repair Method": "Update ibRatio when burning auction bond", "Vulnerability Information": "A failed auction will freeze part of the funds because the auctionBurn() function will _burn() the auction bond without updating the ibRatio. Once the bond of a failed auction is burned, the proportional underlying tokens won't be able to be withdrawn, in other words, being frozen in the contract."}

{"Vulnerability Type": "Disruption of minting and burning", "Vulnerability Location": "Basket.sol#handleFees()", "Repair Method": "Limit the max value of feePct", "Vulnerability Information": "handleFees() could potentially cause disruption of minting and burning if feePct is greater than BASE, which can happen when timeDiff * licenseFee is greater than ONE_YEAR."}

{"Vulnerability Type": "Division by zero", "Vulnerability Location": "Basket.sol#handleFees()", "Repair Method": "Add a check to handleFees() if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. Reset ibRatio to BASE at this point.", "Vulnerability Information": "Basket becomes unusable if everybody burns their shares because the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0."}

1. {"Vulnerability Type": "Unsafe approve", "Vulnerability Location": "Basket.sol#L224-L228", "Repair Method": "Use safeApprove instead and set the allowance to 0 before calling it", "Vulnerability Information": "Unsafe approve would halt the auction and burn the bond"}
2. {"Vulnerability Type": "Incorrect fee calculation", "Vulnerability Location": "Basket.sol line 118", "Repair Method": "Replace BASE feePct in the denominator with BASE", "Vulnerability Information": "Fee calculation is potentially incorrect"}
3. {"Vulnerability Type": "Late auction bond settlement failure", "Vulnerability Location": "Auction.sol#settleAuction()", "Repair Method": "Calculate and require newRatio > 0 in bondForRebalance(), or limit the max value of decrement and make sure newRatio always > 0 in settleAuction()", "Vulnerability Information": "Auction bond could potentially not being able to be settled, cause funds loss to bonder"}

