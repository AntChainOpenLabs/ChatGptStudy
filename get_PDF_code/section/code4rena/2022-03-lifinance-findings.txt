1. {"Vulnerability Type": "ERC20 bridging functions do not revert on non-zero msg.value", "Vulnerability Location": "AnyswapFacet.sol, CBridgeFacet.sol, HopFacet.sol, NXTPFacet.sol", "Repair Method": "Consider reverting when bridging functions with non-native target are called with non-zero native amount added", "Vulnerability Information": "Any native funds mistakenly sent along with plain ERC20 bridging calls will be lost."}
2. {"Vulnerability Type": "msg.value is Sent Multiple times When Performing a Swap", "Vulnerability Location": "LibSwap.sol, Swapper.sol", "Repair Method": "Only allow fromAssetId to be the native token once in _swapData in Swapper._executeSwaps(). If it occurs more than once the transaction should revert.", "Vulnerability Information": "If Swapper._executeSwaps() is called with the native token as the swapData.fromAssetId more than once and msg.value > 0 then more value will be transferred out of the contract than is received."}
3. {"Vulnerability Type": "Reputation Risks with contractOwner", "Vulnerability Location": "DiamondCutFacet.sol, WithdrawFacet.sol, DexManagerFacet.sol", "Repair Method": "Implement extra safeguards such as limiting the time period where sensitive functions can be used, having a waiting period before pushed update is executed, and using a multisig to mitigate single point of failure in case contractOwner private key leaks.", "Vulnerability Information": "contractOwner has complete freedom to change any functionality and withdraw/rug all assets."}

1. {"Vulnerability Type": "Arbitrary token approval", "Vulnerability Location": "AnyswapFacet.sol#L35-L53", "Repair Method": "Whitelist Anyswap tokens and routers, restrict attacker's ability to use malicious contracts, call IAnyswapToken(_anyswapData.token).underlying() only once and pass the value to _startBridge()", "Vulnerability Information": "AnyswapFacet can be exploited to approve arbitrary tokens."}
2. {"Vulnerability Type": "Loss of funds", "Vulnerability Location": "GenericSwapFacet.sol#L23-L30", "Repair Method": "Add a check that _lifiData.receivingAssetId equals the receivingAssetId of the last index of the SwapData array, or simply use the receivingAssetId of the last index of the SwapData array for sending the final tokens to the user", "Vulnerability Information": "Reliance on lifiData.receivingAssetId can cause loss of funds."}
3. {"Vulnerability Type": "Loss of funds", "Vulnerability Location": "CBridgeFacet.sol#L68", "Repair Method": "Change = to == at line 68", "Vulnerability Information": "Should prevent users from sending more native tokens in the startBridgeTokensViaCBridge function."}

1. {"Vulnerability Type": "Excess funds not returned", "Vulnerability Location": "LibSwap.sol#L29-L58", "Repair Method": "Store the contract’s from balance before and after the swap. Refund any excess back to the user.", "Vulnerability Information": "It is probable for `_swapData.fromAmount` to be greater than the actual amount used (eg. when swapping for an exact output, or when performing another swap after swapping with an exact input). However, these funds aren’t returned back to the user and are left in the lifi contract."}
2. {"Vulnerability Type": "Missing checks for returned tokens", "Vulnerability Location": "GenericSwapFacet.sol#L23-L30, LibSwap.sol#L48", "Repair Method": "Add checks to ensure that some tokens have been returned via the swaps. Use function signature whitelists as opposed to contract address whitelists. Alternatively, add a `require` statement in `swapTokensGeneric()` to ensure that at least a single token was received.", "Vulnerability Information": "Every function that stems from the `GenericSwapFacet` lacks checks to ensure that some tokens have been returned via the swaps. In `LibSwap.sol` in the `swap()` function, the swap call is sent to the target DEX. A return of success is required, otherwise the operation will revert."}
3. {"Vulnerability Type": "Free swaps given certain conditions", "Vulnerability Location": "LibSwap.swap(), GenericSwapFacet.sol", "Repair Method": "Ensure funds are always subtracted from users account in `swap`, even if LiFi has enough balance to do the swap.", "Vulnerability Information": "Anyone can get swaps for free given certain conditions in swap. Remaining or unaccounted ERC20 balance could be freely taken through `swapTokensGenerics` and `swap`."}

{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "Functions which call `Swapper._executeSwap()` such as `GenericSwapFacet.swapTokensGeneric()`, `CBridgeFacet.swapAndStartBridgeTokensViaCBridge()`, `AnyswapFacet.swapAndStartBridgeTokensViaAnyswap()`, `HopFacet.swapAndStartBridgeTokensViaHop()`, `NXTPFacet.swapAndStartBridgeTokensViaNXTP()`, and `NXTPFacet.swapAndCompleteBridgeTokensViaNXTP()`", "Repair Method": "Add a reentrancy guard over every function which may send or receive tokens. Ensure the same slot is used to store the reentrancy guard so all required functions are covered by a single guard.", "Vulnerability Information": "There is a reentrancy vulnerability in functions which call `Swapper._executeSwap()` which would allow the attacker to change their `postSwapBalance`. The issue occurs since it is possible for an attacker to reenter this function during `_executeSwaps()`, that is because execute swap makes numerous external calls, such as to the AMM, or to untrusted ERC20 token addresses."}

1. {"Vulnerability Type": "Infinite approval vulnerability", "Vulnerability Location": "AnyswapFacet.sol#L131-L157", "Repair Method": "Whitelisting the `_anyswapData.router` rather than trusting user's inputs; Or, only `approve()` for the amount that required for the current transaction instead of infinite approval.", "Vulnerability Information": "Infinite approval to an arbitrary address can be used to steal all the funds from the contract."}
2. {"Vulnerability Type": "Failed transfer vulnerability", "Vulnerability Location": "LibSwap.sol#L42-L46", "Repair Method": "Use low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin's `Address.sendValue`.", "Vulnerability Information": "Failed transfer with low level call won't revert."}
3. {"Vulnerability Type": "Missing functionality vulnerability", "Vulnerability Location": "CBridgeFacet.sol#L150-L156", "Repair Method": "Add the `payable` keyword to the CBridge interface. The external `sendNative()` call should include sending the native tokens together with it.", "Vulnerability Information": "cBridge integration fails to send native tokens."}
4. {"Vulnerability Type": "Looping vulnerability", "Vulnerability Location": "DexManagerFacet.sol#L71-L73", "Repair Method": "Replace `return` with `break`. Emit an event whenever a DEX is added or removed.", "Vulnerability Information": "DexManagerFacet: batchRemoveDex() removes first dex only."}
5. {"Vulnerability Type": "Unsafe transfer vulnerability", "Vulnerability Location": "WithdrawFacet.sol#L28-L31", "Repair Method": "Using low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin's `Address.sendValue`.", "Vulnerability Information": "WithdrawFacet's withdraw calls native payable.transfer, which can be unusable for DiamondStorage owner contract."}

