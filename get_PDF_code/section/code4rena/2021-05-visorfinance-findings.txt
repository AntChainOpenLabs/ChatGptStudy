{"Vulnerability Type": "Unhandled return value", "Vulnerability Location": "timeLockERC20() function", "Repair Method": "Replace use of solidityIERC20(token).transferFrom(msg.sender, address(this), amount) with solidityTransferHelper.safeTransferFrom(token, msg.sender, address(this), amount)", "Vulnerability Information": "ERC20 implementations are not always consistent. Some implementations of `transfer` and `transferFrom` could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into `require()` statements or use safe wrapper functions implementing return value/data checks to handle these failures."}

{"Vulnerability Type": "Unbounded loop", "Vulnerability Location": "_removeNft() function", "Repair Method": "Use a mapping (e.g., `mapping(address=Nft[]) nfts`) to store the received NFTs into separate arrays according to `nftContract` instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly.", "Vulnerability Information": "The function `_removeNft` uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas."}

{"Vulnerability Type": "Permanent lock", "Vulnerability Location": "timeLockERC721() and transferERC721() functions", "Repair Method": "Add `delete timelockERC721s timelockERC721Keys[nftContract][i]];` after L510.", "Vulnerability Information": "If a particular NFT token was timelocked for a certain duration by the owner using `timeLockERC721()` with a delegate as the recipient and then transferred out of the vault by the delegate via `transferERC721()` but without unlocking it explicitly using `timeUnlockERC721()`, and if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the `transferERC721()` call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock). The impact is that, without access/control to the earlier timelock recipient, this NFT token is now locked in the vault forever."}

{"Vulnerability Type": "Block size limit", "Vulnerability Location": "timelockERC721Keys loop", "Repair Method": "Transfer by index instead of token ID", "Vulnerability Information": "Looping through the `timelockERC721Keys` could exceed the block size limit."}

{"Vulnerability Type": "NFT transfer approval not removed", "Vulnerability Location": "approveTransferERC721() and transferERC721() functions", "Repair Method": "Add a boolean parameter to approveTransferERC721() and set the nftApprovals to that parameter which can be true for giving approval and false for removing/revoking approval. Call approveTransferERC721() with the boolean false to remove approval before making a transfer in transferERC721() on L515 if msg.sender != _getOwner().", "Vulnerability Information": "NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens."}

{"Vulnerability Type": "timelockERC721s not cleaned", "Vulnerability Location": "transferERC721() function", "Repair Method": "Check if the timelockERC721s mapping should also be cleaned from transferERC721 and adapt the code accordingly.", "Vulnerability Information": "transferERC721 doesn't clean timelockERC721s."}

{"Vulnerability Type": "Approval for NFT transfers not removed after transfer", "Vulnerability Location": "transferERC721() function", "Repair Method": "Reset the approval on transfer.", "Vulnerability Information": "Approval for NFT transfers is not removed after transfer."}

