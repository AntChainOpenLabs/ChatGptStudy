{"Vulnerability Type": "Increase voting power by tokenizing the address that locks the token", "Vulnerability Location": "AuraLocker.sol#L258-L295", "Repair Method": "Implement a whitelist or blacklist to restrict the type of address that can lock the token", "Vulnerability Information": "A bad actor could lock the token through a smart contract, tokenize it, and accumulate voting power that could dictate the future of the protocol."}

{"Vulnerability Type": "User will lose funds", "Vulnerability Location": "AuraClaimZap.sol#L224-L226", "Repair Method": "Check if the user has enabled lock for cvx before transferring cvx from the user to the contract", "Vulnerability Information": "If the user calls claimRewards with Options.LockCvx as false, their cvx funds can get stuck in the contract."}

{"Vulnerability Type": "BaseRewardPool4626 is not IERC4626 compliant", "Vulnerability Location": "BaseRewardPool4626.sol", "Repair Method": "Review the necessary functions and emits required on eip-4626 and add them to BaseRewardPool4626", "Vulnerability Information": "BaseRewardPool4626 is not compliant with the eip-4626 standard, making it irrelevant for projects to integrate with it."}

{"Vulnerability Type": "CrvDepositorWrapper.sol relies on oracle that isn't frequently updated", "Vulnerability Location": "CrvDepositorWrapper.sol#L56-L65", "Repair Method": "Consider using chainlink oracles for both BAL and ETH to get a real-time estimate of the LP value", "Vulnerability Information": "The oracle used by CrvDepositorWrapper is infrequently updated, which can result in an inaccurate oracle and high levels of slippage."}

{"Vulnerability Type": "safeRewardTransfer can cause loss of funds", "Vulnerability Location": "ConvexMasterChef.sol#L299-L306", "Repair Method": "Use usual safeTransfer instead of safeRewardTransfer", "Vulnerability Information": "The safeRewardTransfer function in ConvexMasterChef can cause depositors to be sent less tokens than needed or none at all, resulting in a loss of funds."}

{"Vulnerability Type": "Integer overflow", "Vulnerability Location": "AuraLocker.sol#L176-L177, AuraLocker.sol#L802-L814, AuraLocker.sol#L864", "Repair Method": "Increase the size of the rewardPerTokenStored to either uint256 or update both rewardRate and rewardPerTokenStored to be uint224", "Vulnerability Information": "There is a potential overflow in the rewards calculations which would lead to updateReward() always reverting. The impact of this overflow is that all reward tokens will be permanently locked in the contract."}

{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "ConvexMasterChef.sol#L209-L221, ConvexMasterChef.sol#L239-L250", "Repair Method": "Consider adding a direct reentrancy control, e.g. nonReentrant modifier. Also, consider finishing all internal state updates prior to external calls.", "Vulnerability Information": "Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future, the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount."}

{"Vulnerability Type": "Governance Susceptibility", "Vulnerability Location": "AuraLocker.sol#L594-L609, AuraLocker.sol#L611-L618", "Repair Method": "Track the delegated balances only in the total voting supply to properly track the voting power of each individual.", "Vulnerability Information": "The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances."}

1. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "ExtraRewardsDistributor.sol", "Repair Method": "Disallow users to call getReward function for other users", "Vulnerability Information": "User can forfeit other user rewards"}
2. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "BalLiquidityProvider.sol", "Repair Method": "Remove or change the requirement for balances to be equal to input variables", "Vulnerability Information": "DDOS in BalLiquidityProvider"}
3. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "AuraLocker.sol", "Repair Method": "Add a check to queueNewRewards to disallow funding once endTime has been reached", "Vulnerability Information": "Rewards distribution can be delayed/never distributed"}
4. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "AuraVestedEscrow.sol", "Repair Method": "Add a check to disallow funding once endTime has been reached", "Vulnerability Information": "Reward can be vested even after endTime"}

1. {"Vulnerability Type": "Reward locking", "Vulnerability Location": "ExtraRewardsDistributor.sol#L233-L240, AuraLocker.sol#L334-L337", "Repair Method": "Allow users to supply endEpochIndex to the claim reward functions and only calculate reward from startIndex to min(auraLocker.epochCount() - 1, endEpochIndex). Add support for partial reward claiming.", "Vulnerability Information": "Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed."}
2. {"Vulnerability Type": "Incorrect reward distribution", "Vulnerability Location": "ConvexMasterChef.sol#L96", "Repair Method": "Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken add function should fail.", "Vulnerability Information": "Duplicate LP token could lead to incorrect reward distribution."}
3. {"Vulnerability Type": "Griefing attack", "Vulnerability Location": "ExtraRewardsDistributor.sol#L74", "Repair Method": "Allow the backdating of rewards, which will cost more gas.", "Vulnerability Information": "Users can grief reward distributions by spending dust."}
4. {"Vulnerability Type": "Inaccurate reward calculation", "Vulnerability Location": "AuraLocker.sol#L396:#L405", "Repair Method": "Change the last line in the code above to: reward = uint256(locked).mul(rRate).div(denominator);", "Vulnerability Information": "AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance."}

1. {"Vulnerability Type": "Incorrect reward calculation", "Vulnerability Location": "ConvexMasterChef contract, updatePool() function", "Repair Method": "Add a check that _lpToken is not cvx in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.", "Vulnerability Information": "When the _lpToken is the same token as cvx, reward calculation for that pool in the updatePool() function can be incorrect."}
2. {"Vulnerability Type": "DoS with block gas limit", "Vulnerability Location": "massUpdatePools() function", "Repair Method": "Limit the max number of loop iterations to prevent hitting block gas limit.", "Vulnerability Information": "massUpdatePools() is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo."}

1. {"Vulnerability Type": "Lack of voting power allocation", "Vulnerability Location": "AuraLocker._lock() function", "Repair Method": "Update the AuraLocker._lock() function to automatically delegate to the account to trigger the checkpointing if there is no delegatee", "Vulnerability Information": "Users who lock their AURA tokens in the AuraLocker do not receive voting power unless they delegate to themselves, which is not mentioned in the documentation. This can lead to missed opportunities to vote on critical protocol decisions or flow of incentives."}
2. {"Vulnerability Type": "Penalty charged due to admin actions", "Vulnerability Location": "AuraBalRewardPool.getReward() function", "Repair Method": "Do not charge the penalty if the AuraLocker has been shut down", "Vulnerability Information": "Users are charged a penalty when claiming rewards from the AuraBalRewardPool if they do not pass it into the AuraLocker, but if the AuraLocker has been shut down, the penalty path is the only option, which is unfair to users."}

1. {"Vulnerability Type": "Incorrect implementation", "Vulnerability Location": "CrvDepositor.sol", "Repair Method": "Change the implementation of the 2-week buffer for lock by changing the name of unlockTime to unlockTimeInWeeks and modifying the code in L94-102 and L127-L134", "Vulnerability Information": "The implementation of the 2-week buffer for lock in CrvDepositor.sol is incorrect as unlockInWeeks is being used as a number in weeks instead of seconds, leading to a 2-second buffer instead of a 2-week buffer."}
2. {"Vulnerability Type": "Incorrect implementation", "Vulnerability Location": "ConvexMasterChef.sol", "Repair Method": "Remove the _withUpdate variable in the add() and set() functions and always call the massUpdatePools() function before updating totalAllocPoint variable", "Vulnerability Information": "The use of add() and set() functions in ConvexMasterChef.sol without calling massUpdatePools() to update all pools can lead to incorrect reward calculation due to the modification of the totalAllocPoint variable without updating the pending reward first."}

