{"Vulnerability Type": "Missing slippage checks", "Vulnerability Location": "function", "Repair Method": "Add a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.", "Vulnerability Information": "There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated.This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%."}

{"Vulnerability Type": "Result of transfer / transferFrom not checked", "Vulnerability Location": "call to transferFrom or transfer", "Repair Method": "Always check the result of transferFrom and transfer.", "Vulnerability Information": "A call to `transferFrom` or `transfer` is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of 'false' is returned."}

{"Vulnerability Type": "Synth realise is vulnerable to flash loan attacks", "Vulnerability Location": "Synth.sol L187-L199", "Repair Method": "1. Calculate token's price from a reliable source. Implement a TWAP oracle or uses chainlink oracle. 2. Calculate lp token value based on anti-flashloan formula.", "Vulnerability Information": "Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack."}

{"Vulnerability Type": "Vulnerable Pool initial rate", "Vulnerability Location": "poolFactory.sol L45-L62", "Repair Method": "Add a require statement in `createPoolADD` to check that initial balance is zero.", "Vulnerability Information": "`Pool` is created in function `createPoolADD`. The price (rate) of the token is determined in this function. Since the address is deterministic, the attacker can front-run the `createPoolADD` transaction and sends tokens to Pool's address."}

{"Vulnerability Type": "Insufficient validation for proposal creation", "Vulnerability Location": "`new*Proposal()` functions", "Repair Method": "1. Restrict and validate the `typeStr` submitted. 2. Have a 'catch-all-else' proposal that will only call `_completeProposal()` in `finaliseProposal()`. 3. Do null validation checks in `newAddressProposal()` and `newParamProposal()`.", "Vulnerability Information": "Creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions."}

1. {"Vulnerability Type": "Flash loan manipulation", "Vulnerability Location": "getPoolShareWeight function in Utils contract", "Repair Method": "Record the current timestamp when a user's weight in the DaoVault or BondVault is recalculated and force the new weight to take effect only after a certain period, e.g., a block time.", "Vulnerability Information": "An attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight."}
2. {"Vulnerability Type": "Dead fund in the Pool", "Vulnerability Location": "calcLiquidityHoldings function in Pool contract", "Repair Method": "Unknown", "Vulnerability Information": "The lpToken minted by the Pool contract is actually the mix of two types of tokens. One is the original lpTokens user get by calling addForMember. This lpToken is similar to lp of Uniswap, Crv, Sushi, ... etc. The other one is the debt-lp token the Synth contract will get when the user calls mintSynth."}
3. {"Vulnerability Type": "SynthVault rewards can be gamed", "Vulnerability Location": "_deposit function in SynthVault contract", "Repair Method": "Track a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.", "Vulnerability Information": "The spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity."}
4. {"Vulnerability Type": "Hijack token pool by burning liquidity token", "Vulnerability Location": "burn function in Pool contract", "Repair Method": "Remove burn or restrict it to privileged users only.", "Vulnerability Information": "Pool allows users to burn lp tokens without withdrawing the tokens."}
5. {"Vulnerability Type": "Resetting user rewards can be used to grief them and make them loose rewards", "Vulnerability Location": "_deposit and depositForMember functions in SynthVault contract", "Repair Method": "Harvest for the user right before changing mapMemberSynth_lastTime", "Vulnerability Information": "The function _deposit sets mapMemberSynth_lastTime to a date in the future in synthVault.sol."}

{"Vulnerability Type": "Improper access control", "Vulnerability Location": "Dao.claimAllForMember()", "Repair Method": "Remove the member parameter in the claimAllForMember function and replace all member to msg.sender to allow only the user himself to claim unlocked bonded LP tokens.", "Vulnerability Information": "The claimAllForMember function of Dao is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member."}

{"Vulnerability Type": "Manipulation of incentives", "Vulnerability Location": "BondVault deposits match any deposited token amount with the BASE amount to provide liquidity", "Repair Method": "Track a TWAP spot price of the TOKEN < BASE pair and check if the BASE incentive is within a range of the TWAP. This circumvents that the DAO commits BASE at bad prices.", "Vulnerability Information": "An attacker can manipulate the pool and have the DAO commit BASE at bad prices which they then later buy back to receive a profit on BASE."}

{"Vulnerability Type": "Misleading modifier", "Vulnerability Location": "Several contracts implement an onlyDAO modifier", "Repair Method": "Rename it to onlyDeployer or onlyDeployerOrDAO depending on who has access.", "Vulnerability Information": "Some implementations are wrong and either allow the DAO or the deployer to execute, or even only the deployer."}

{"Vulnerability Type": "Loss of rewards", "Vulnerability Location": "SynthVault.withdraw function", "Repair Method": "Recommend claiming the rewards with the user's deposited balance first in withdraw.", "Vulnerability Information": "The SynthVault.withdraw function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards."}

{"Vulnerability Type": "Fund Drainage and Proposal Manipulation", "Vulnerability Location": "DAOVault", "Repair Method": "Create a separate role and modifier for the DEPLOYER, so that he is only able to call withdraw() but not depositLP(). Include the missing purgeDeployer() function.", "Vulnerability Information": "The DEPLOYER can drain the funds in the DAOVault and manipulate proposal results."}

{"Vulnerability Type": "Unwithdrawable funds", "Vulnerability Location": "BondVault.sol: claimForMember() function", "Repair Method": "The _claimable deduction should occur after the condition check. Alternatively, change the condition check to if (mapBondAsset_memberDetails[asset].bondedLP[member] == 0).", "Vulnerability Information": "A user that claims his bonded LP asset by calling dao.claimForMember(), or a malicious attacker helps a user to claim by calling dao.claimAllForMember(), either which is done such that _claimable is exactly half of

1. {"Vulnerability Type": "arbitrary synth mint/burn", "Vulnerability Location": "Pool's mintSynth logic, Synth's mintSynth logic, and Synth's authorization logic", "Repair Method": "Check the provided synth's underlying token in mintSynth", "Vulnerability Information": "Pool can mint arbitrary Synth provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs."}
2. {"Vulnerability Type": "block usage of addCuratedPool", "Vulnerability Location": "curatedPoolCount() function and addCuratedPool() function", "Repair Method": "Create a variable curatedPoolCount and increase it in addCuratedPool and decrease it in removeCuratedPool", "Vulnerability Information": "The function curatedPoolCount() contains a for loop over the array arrayPools. If arrayPools would be too big then the loop would run out of gas and curatedPoolCount() would revert. This would mean that addCuratedPool() cannot be executed anymore (because it calls curatedPoolCount() )."}
3. {"Vulnerability Type": "in the beginning its relatively easy to gain majority share", "Vulnerability Location": "Dao.sol", "Repair Method": "Make sure you initially have a majority vote", "Vulnerability Information": "When the DAO is just deployed it is relatively easy to gain a large (majority) share, by depositing a lot in the DAOVault and/of BONDVault. Then you could submit a proposal and vote it in. Luckily there is a coolOffPeriod of 3 days. But if others are not paying attention in these 3 days you might get your vote passed by voting for it with your majority share. The riskiest proposal would be to replace the DAO (moveDao), because that way you could take over everything."}
4. {"Vulnerability Type": "pools can be created without initial liquidity", "Vulnerability Location": "PoolFactory.createPoolADD function", "Repair Method": "Burn some initial LP tokens or take a pool creation fee instead", "Vulnerability Information": "The protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call PoolFactory.createPoolADD, receive the LP tokens in addForMember and withdraw liquidity again."}
5. {"Vulnerability Type": "dividend reward can be gamed", "Vulnerability Location": "Router.addDividend function", "Repair Method": "Compute the dividends based on volume traded over a timespan instead of looking at individual trades", "Vulnerability Information": "The normalAverageFee variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool arrayFeeSize (20) times (use buyTo). The fees of the single wei trades will be zero and thus the normalAverageFee will also be zero as, see addTradeFee. The attacker then does a trade that generates some non-zero fees, setting the normalAverageFee to this trade's fee. The feeDividend is then computed as _fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2. Half of the dailyAllocation is sent to the pool. The attacker repeats the above steps until the reserve is almost empty. Each time the dailyAllocation gets smaller but it's still possible to withdraw almost all of it. The reserve can be emptied by the attacker. Counting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short."}

1. {"Vulnerability Type": "Misuse of AMM model", "Vulnerability Location": "Pool.sol", "Repair Method": "Maintain a debt variable in the Pool and use tokenAmount debt when the Pool calculates the token price", "Vulnerability Information": "The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space."}
2. {"Vulnerability Type": "Failing Max Value Allowance", "Vulnerability Location": "Pool.sol & Synth.sol", "Repair Method": "Remove the condition in the _approve function", "Vulnerability Information": "This affects the approveAndCall implementation since it uses type(uint256).max as the allowance amount, but the resulting allowance set is zero."}
3. {"Vulnerability Type": "DAO upgrade issue", "Vulnerability Location": "Reserve.sol", "Repair Method": "Call setIncentiveAddresses(..) when a DAO upgrade is done", "Vulnerability Information": "When the DAO is upgraded via moveDao, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract."}
4. {"Vulnerability Type": "Unnecessary approval", "Vulnerability Location": "Synth.approveAndCall", "Repair Method": "Only approve amount instead of max value", "Vulnerability Information": "The Synth.approveAndCall function approves the recipient contract with the max value instead of only the required amount."}
5. {"Vulnerability Type": "Members lose SPARTA tokens", "Vulnerability Location": "Router.sol", "Repair Method": "Transfer BASE SPARTA to the Pool before swapTo() so they get sent to the member along with the converted TOKENs via swapTo(). Use swap(BASE) instead of swapTo() so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.", "Vulnerability Information": "When a member calls removeLiquiditySingle() requesting only SPARTA in return, i.e. toBASE = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool."}
6. {"Vulnerability Type": "Unnecessary approval", "Vulnerability Location": "Pool.approveAndCall", "Repair Method": "Only approve amount instead of max value", "Vulnerability Information": "The Pool.approveAndCall function approves the recipient contract with the max value instead of only the required amount."}

