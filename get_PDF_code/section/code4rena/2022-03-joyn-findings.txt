1. {"Vulnerability Type": "Not handling return value", "Vulnerability Location": "CoreCollection.sol and ERC721Payable.sol", "Repair Method": "Add a require statement to check the return value of transferFrom command", "Vulnerability Information": "Not handling return value of transferFrom command can create inconsistency"}
2. {"Vulnerability Type": "ERC20 transferFrom return values not checked", "Vulnerability Location": "CoreCollection.sol", "Repair Method": "Check the success boolean of all transferFrom calls or use OZ’s SafeERC20’s safeTransferFrom() function", "Vulnerability Information": "ERC20 transferFrom return values not checked"}
3. {"Vulnerability Type": "CoreCollection's token transfer can be disabled", "Vulnerability Location": "RoyaltyVault.sol and Splitter.sol", "Repair Method": "Introduce action threshold to sendToSplitter() or try to send the fees and record the amounts not yet distributed", "Vulnerability Information": "CoreCollection's token transfer can be disabled"}
4. {"Vulnerability Type": "ERC20 tokens with no return value will fail to transfer", "Vulnerability Location": "RoyaltyVault.sol", "Repair Method": "Consider using OpenZeppelin’s SafeERC20", "Vulnerability Information": "ERC20 tokens with no return value will fail to transfer"}
5. {"Vulnerability Type": "CoreCollection can be reinitialized", "Vulnerability Location": "CoreCollection.sol", "Repair Method": "Add onlyUnInitialized modifier to the initialize function", "Vulnerability Information": "CoreCollection can be reinitialized"}

{"Vulnerability Type": "Potential permanent lock of tokens", "Vulnerability Location": "CoreCollection.setRoyaltyVault function", "Repair Method": "Check if payableToken is the same as royaltyVault.royaltyAsset while assigning vaults to CoreProxy", "Vulnerability Information": "Mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault."}

{"Vulnerability Type": "Storage collision", "Vulnerability Location": "CoreProxy contract", "Repair Method": "Use EIP1967 to set proxy variables at fixed positions to avoid storage conflicts", "Vulnerability Information": "Storage collision because of lack of EIP1967 could cause conflicts and override sensible variables"}

{"Vulnerability Type": "Front-running attack", "Vulnerability Location": "createSplit() function", "Repair Method": "Use a whitelist on project creation or ask user to sign their address and check the signature against msg.sender", "Vulnerability Information": "An attacker may front-run any createSplit() transaction in the mem pool and create another createSplit() transaction with a higher gas price that uses the same merkleRoot but changes the other fields"}

{"Vulnerability Type": "Duplicate NFTs can be minted", "Vulnerability Location": "mintToken() function", "Repair Method": "Add reentrancy protections to prevent users from abusing this behaviour and follow the checks-effects pattern such that all external/state changing calls are made at the end", "Vulnerability Information": "If the user mints the last token, they can reenter and mint duplicate NFTs as the way tokenId is generated will wrap around to the start again"}

{"Vulnerability Type": "Ineffective handling of FoT or Rebasing Tokens", "Vulnerability Location": "RoyaltyVault.sendToSplitter() function", "Repair Method": "Document clearly that rebasing token should not be used in the protocol or handle rebasing tokens balance checks before and after the transfer to ensure accurate accounting", "Vulnerability Information": "Certain ERC20 tokens may change user's balances over time or charge a fee when a transfer is called and the accounting of these tokens is not handled by RoyaltyVault.sol or Splitter.sol"}

{"Vulnerability Type": "Not Equipped to Handle On-Chain Royalties", "Vulnerability Location": "RoyaltyVault.sol", "Repair Method": "Implement the necessary functionality to allow for the collection of fees through an on-chain mechanism. ERC2981 outlines the appropriate behaviour for this.", "Vulnerability Information": "RoyaltyVault.sol is not equipped to handle on-chain royalties from secondary sales."}

{"Vulnerability Type": "Gas inefficiency", "Vulnerability Location": "Splitter contract", "Repair Method": "Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.", "Vulnerability Information": "Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover."}

{"Vulnerability Type": "Unauthorized access", "Vulnerability Location": "Splitter contract", "Repair Method": "Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.", "Vulnerability Information": "Anyone can call incrementWindow to steal the tokens in the contract."}

{"Vulnerability Type": "Centralization risk", "Vulnerability Location": "RoyaltyVault contract", "Repair Method": "Add a maximum value for the `_platformFee` say 5% (or some reasonable value based on the needs of the platform). Also consider calling `sendToSplitter()` before adjusting the `platformFee`. This will only allow the owner to change the fee for future value excluding the current contract balance.", "Vulnerability Information": "Owner of RoyaltyVault can take all funds."}

{"Vulnerability Type": "Timelock", "Vulnerability Location": "RoyaltyVault contract", "Repair Method": "Consider adding a timelock to `setPlatformFee()`", "Vulnerability Information": "Add a timelock to setPlatformFee()"}

1. {"Vulnerability Type": "Differing percentage denominators causes confusion and potentially brick claims", "Vulnerability Location": "Splitter.sol line 14", "Repair Method": "Remove PERCENTAGE_SCALE because it is unused, or replace its value with 10_000 and use that instead.", "Vulnerability Information": "If an incorrect denominator is used, the calculated claimable amount could exceed the actual available funds in the contract, causing claims to fail and funds to be permanently locked."}
2. {"Vulnerability Type": "CoreCollection: Starting index is pseudo-randomly generated, allowing for gameable NFT launches", "Vulnerability Location": "FortuneTeller function predictStartingIndexes", "Repair Method": "Consider exploring the use of commit-reveal schemes (eg. blockhash of a future block, less gameable but not foolproof) or VRFs.", "Vulnerability Information": "The metadata could be scrapped beforehand to determine the rare NFTs. Thus, NFT mints can be gamed / exploited."}
3. {"Vulnerability Type": "Fixed Amount of Gas Sent in Call May Be Insufficient", "Vulnerability Location": "attemptETHTransfer function", "Repair Method": "Consider removing the gas field to use the default amount and protect from reentrancy by using reentrancy guards and the check-effects-interaction pattern. Note this pattern is already applied correctly.", "Vulnerability Information": "If the receiver is a contract this may be insufficient to process the receive() function. As a result, the user would be unable to receive funds from this function."}
4. {"Vulnerability Type": "DoS: claimForAllWindows() May Be Made Unusable By An Attacker", "Vulnerability Location": "Splitter.claimForAllWindows() function", "Repair Method": "Consider modifying the function claimForAllWindows() to instead claim for range of windows. Pass the function a startWindow and endWindow and only iterate through windows in that range. Ensure that endWindow < currentWindow.", "Vulnerability Information": "When the value of currentWindow is raised sufficiently high Splitter.claimForAllWindows() will not be able to be called due to the block gas limit."}
5. {"Vulnerability Type": "Funds cannot be withdrawn in CoreCollection.withdraw", "Vulnerability Location": "CoreCollection.withdraw function", "Repair Method": "Replace transferFrom with transfer", "Vulnerability Information": "The usage of transferFrom can result in serious issues. In fact, many ERC20 always require that in transferFrom allowance[from][msg.sender] = amount, so in this case the call to the withdraw function will revert as the allowance[CoreCollection][CoreCollection] == 0 and therefore the funds cannot be withdrawn and will be locked forever in the contract."}

