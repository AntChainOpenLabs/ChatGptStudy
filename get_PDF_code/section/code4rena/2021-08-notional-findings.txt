1. {"Vulnerability Type": "Potential DOS", "Vulnerability Location": "Contracts inheriting UUPSUpgradeable.sol", "Repair Method": "Initialize the implementation contract for NoteERC20.sol and check the correct permissions before deploying the proxy contract or performing any contract upgrades", "Vulnerability Information": "If the implementation contract is left uninitialized, it is possible for any user to gain ownership of the onlyOwner role in the implementation contract for NoteERC20.sol."}
2. {"Vulnerability Type": "Manipulation of liquidity token value", "Vulnerability Location": "AssetHandler.getLiquidityTokenValue function", "Repair Method": "Do not use the current market reserves to determine the value of LP tokens. Implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables", "Vulnerability Information": "The liquidity token value is the sum of the value of the individual claims on cash and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, which means the value depends on the current market reserves which can be manipulated."}
3. {"Vulnerability Type": "Access restriction bypass", "Vulnerability Location": "NotionalV1ToNotionalV2.notionalCallback function", "Repair Method": "Fix the authorization check", "Vulnerability Information": "The access restrictions on NotionalV1ToNotionalV2.notionalCallback can be circumvented by simply providing sender = this as sender is a parameter of the function that can be chosen by the attacker."}
4. {"Vulnerability Type": "Event emission on unsuccessful action", "Vulnerability Location": "nTokenERC20Proxy functions", "Repair Method": "Only emit events on success", "Vulnerability Information": "The nTokenERC20Proxy functions emit events all the time, even if the return value from the inner call returns false, indicating an unsuccessful action."}

1. {"Vulnerability Type": "ERC20 missing return value check", "Vulnerability Location": "CompoundToNotionalV2.enableToken", "Repair Method": "Use OpenZeppelin’s SafeERC20 versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens", "Vulnerability Information": "The enableToken function performs an ERC20.approve() call but does not check the success return value."}
2. {"Vulnerability Type": "Forced liquidations by borrowing large amounts of an asset", "Vulnerability Location": "N/A", "Repair Method": "N/A", "Vulnerability Information": "Consider an attacker who borrows enough to greatly increase the oracle rate."}
3. {"Vulnerability Type": "DOS by Frontrunning NoteERC20 initialize() Function", "Vulnerability Location": "NoteERC20.sol and Router.sol", "Repair Method": "Ensure the NoteERC20.sol proxy contract is deployed and initialized in the same transaction, or ensure the initialize() function is callable only by the deployer of the NoteERC20.sol contract", "Vulnerability Information": "The scripts/deployment.py does not follow this pattern when deploying NoteERC20.sol's proxy contract."}
4. {"Vulnerability Type": "TokenHandler.safeTransferOut does not work on non-standard compliant tokens like USDT", "Vulnerability Location": "TokenHandler.safeTransferOut", "Repair Method": "Use OpenZeppelin’s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens", "Vulnerability Information": "The TokenHandler.safeTransferOut function uses the standard IERC20 function for the transfer call and proceeds with a checkReturnCode function to handle non-standard compliant tokens that don't return a return value."}
5. {"Vulnerability Type": "ERC20 return values not checked", "Vulnerability Location": "CompoundToNotionalV2.notionalCallback", "Repair Method": "Use OpenZeppelin’s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens", "Vulnerability Information": "Some tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a success boolean."}
6. {"Vulnerability Type": "Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed", "Vulnerability Location": "CompoundToNotionalV2.notionalCallback", "Repair Method": "Fix the authorization check", "Vulnerability Information": "The access restrictions can be circumvented by simply providing sender = this, as sender is a parameter of the function that can be chosen by the attacker."}

1. {"Vulnerability Type": "bad practice", "Vulnerability Location": "TokenHandler.sol, L174", "Repair Method": "Use `call` instead of `.transfer` and check for reentrancy", "Vulnerability Information": "The use of `.transfer` in `TokenHandler.sol` L174 to send ether is now considered bad practice as gas costs can change which would break the code."}
2. {"Vulnerability Type": "non-standard compliant token transfer", "Vulnerability Location": "TokenHandler.safeTransferIn", "Repair Method": "Use OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens", "Vulnerability Information": "The `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work, as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value."}
3. {"Vulnerability Type": "missing return value check", "Vulnerability Location": "TokenHandler.setToken", "Repair Method": "Use OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens", "Vulnerability Information": "The `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value."}
4. {"Vulnerability Type": "allowance check", "Vulnerability Location": "nTokenAction", "Repair Method": "Default to the `nTokenAllowance` case instead of reverting if the `nTokenWhitelist` allowance is not enough", "Vulnerability Information": "The `nTokenAction` implements two token approvals, the `nTokenWhitelist` which is always used first, and the `nTokenAllowance` which is checked second. If the `nTokenWhitelist` does _not_ have enough allowance for the transfer, the transaction fails, even in the case where `nTokenAllowance` still has enough allowance."}
5. {"Vulnerability Type": "unlimited mint", "Vulnerability Location": "nTokenAction.sol", "Repair Method": "Add `(sender != recipient)`", "Vulnerability Information": "The implementation of the transfer function in `nTokenAction.sol` is different from the usual erc20 token transfer function. This happens because it counts the incentive that the user gets, but with a self-transfer, it can lead to unlimited mint."}
6. {"Vulnerability Type": "inaccurate price data", "Vulnerability Location": "ExchangeRate.sol", "Repair Method": "Do not fetch the latest price and wait for the callback instead", "Vulnerability Information": "The method `.latestRoundData()` on an oracle returns the latest updated price from the oracle, but this is not the current price of an asset."}
7. {"Vulnerability Type": "privilege escalation", "Vulnerability Location": "GovernorAlpha", "Repair Method": "Update the vulnerable contract to `TimelockController v3.4.2`", "Vulnerability Information": "The `GovernorAlpha` inherits from a vulnerable `TimelockController`. This `TimelockController` allows an `EXECUTOR` role to escalate privileges and also gain the proposer role."}

