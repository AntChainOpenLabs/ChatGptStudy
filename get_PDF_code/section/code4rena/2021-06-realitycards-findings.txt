{"Vulnerability Type": "Critical", "Vulnerability Location": "`changeUberOwner()` function in `Factory`, `Orderbook`, and `Treasury` contracts", "Repair Method": "Change the single-step change of `uberOwner` address to a two-step process where the current `uberOwner` first approves a new address as a `pendingUberOwner`. That `pendingUberOwner` has to then claim the ownership in a separate transaction which cannot be done if they do not have the correct private key.", "Vulnerability Information": "If the current `uberOwner` incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the `uberOwner` cannot be corrected and none of the other functions that require `uberOwner` caller can be executed."}

{"Vulnerability Type": "Unchecked ERC20 transfers", "Vulnerability Location": "`topupMarketBalance()` function in `RCTreasury.sol`", "Repair Method": "Use something like OpenZeppelin’s `SafeERC20`. Set up an allow list for tokens, which are knowingly safe. Consider a different approach to the `balancedBooks` modifier.", "Vulnerability Information": "If the underlying ERC20 used is not reverting on failures, but is returning “false” instead, a malicious actor could call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings. After this, `deposit`, `withdrawDeposit`, `payRent`, `payout`, `sponsor`, etc. could be locked up and always failing with “Books are unbalanced”."}

{"Vulnerability Type": "Payout issue", "Vulnerability Location": "`payout` function in `RCTreasury.sol`", "Repair Method": "Check and update the `isForeclosed` state in the payout function.", "Vulnerability Information": "The function payout of `RCTreasury.sol` doesn't undo the `isForeclosed` state of a user. This could lead to a user not being allowed to place new bids without calling some other function that will cancel their foreclosure first."}

{"Vulnerability Type": "Wrong calculation", "Vulnerability Location": "`_collectRentAction` method in `RCTreasury.sol`", "Repair Method": "Change `refundTime = block.timestamp - marketLockingTime;` to `_refundTime = _timeUserForeclosed - marketLockingTime;`", "Vulnerability Information": "The method `_collectRentAction` contains a wrong calculation which could lead to funds being drained by the miscalculation."}

{"Vulnerability Type": "Missing modifier", "Vulnerability Location": "`refundUser()` and `topupMarketBalance()` functions in `RCTreasury.sol`", "Repair Method": "Add the `balancedBooks` modifier to the two functions above where it is missing.", "Vulnerability Information": "The `balancedBooks` modifier is missing in the `refundUser()` and `topupMarketBalance()` functions which also perform similar actions. The impact is that any miscalculations in these functions will lead to the system becoming insolvent."}

{"Vulnerability Type": "Possible locked-ether", "Vulnerability Location": "`RCOrderbook.sol`", "Repair Method": "Adding a way to retrieve locked funds would mitigate the issue.", "Vulnerability Information": "The functions in `RCOrderbook.sol` could possibly lock funds due to it being a payable function with no withdraw function associated."}

{"Vulnerability Type": "Deposits issue", "Vulnerability Location": "Deposit function", "Repair Method": "Measure the asset

{"Vulnerability Type": "Access Control", "Vulnerability Location": "RCMarket.sol", "Repair Method": "Add a check in the ownerOf function to ensure that the _cardId is less than numberOfCards. Add an onlyFactory modifier to the upgradeCard function to ensure that only the factory contract can call it.", "Vulnerability Information": "The ownerOf and onlyTokenOwner functions in RCMarket.sol do not check if the _cardId/_token is smaller than numberOfCards, allowing access to cards of other markets. The upgradeCard function can be called via another market, circumventing the isMarketApproved check. This can be used to steal assets."}

{"Vulnerability Type": "Denial of Service", "Vulnerability Location": "RCTreasury.sol", "Repair Method": "Remove the contract limit or set the limit very high if it keeps happening. Alternatively, use the maxContractBalance variable as a toggle on whether deposits are allowed.", "Vulnerability Information": "The maxContractBalance check in the deposit function of RCTreasury.sol can be abused by a whale to stop anyone from depositing by front-running a user's deposit with a deposit that pushes the contract balance to the maxContractBalance limit first. This prevents users from renting cards and allows an attacker to manipulate the outcome of a market in their favor."}

{"Vulnerability Type": "Access Control", "Vulnerability Location": "RCTreasury.sol", "Repair Method": "Enforce the deposit whitelist on the user address instead of msgSender().", "Vulnerability Information": "The deposit whitelist in the deposit() function of RCTreasury.sol is enforced on the msg.sender address instead of the user address, allowing users to continue depositing via another whitelisted msgSender() even if their corresponding msgSender() is removed from the whitelist. This can lead to griefing of other parts of the system."}

{"Vulnerability Type": "ERC721 Compliance", "Vulnerability Location": "NFT Hub implementation", "Repair Method": "Add support for approval in NFT transfers by using the _beforeTokenTransfer hook and checking that only the factory or the market can do a transfer before the market has entered the withdraw state.", "Vulnerability Information": "The L2 NFT Hub implementation deviates from ERC721 by ignoring the presence of any approvers in the overriding function implementations of transferFrom() and safeTransferFrom(). This can cause system interactions with NFT platforms to fail if they expect ERC721 adherence."}

{"Vulnerability Type": "Access Control", "Vulnerability Location": "RCTreasury.sol", "Repair Method": "Make the collectRentUser function private and create a new public method with onlyOrderbook modifier.", "Vulnerability Information": "The collectRentUser function in RCTreasury.sol can be called by anyone with an arbitrary user address and timestamp, allowing them to affect deposits of any user and turn the owner of the token. This can be used to become the owner of a token by calling newRental with a small price."}

{"Vulnerability Type": "Access Control", "Vulnerability Location": "RCTreasury

1. {"Vulnerability Type": "ERC721 spec implementation issue", "Vulnerability Location": "RCNftHubL2.safeTransferFrom function", "Repair Method": "Implement the IERC721Receiver check in safeTransferFrom", "Vulnerability Information": "The safeTransferFrom function does not correctly implement the ERC721 spec."}
2. {"Vulnerability Type": "Parameter constraint issue", "Vulnerability Location": "rentAllCards function", "Repair Method": "Modify the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership", "Vulnerability Information": "The _maxSumOfPrices parameter constraint for rentAllCards function is broken in the function implementation."}
3. {"Vulnerability Type": "Emergency pause issue", "Vulnerability Location": "public/external functions", "Repair Method": "Apply marketPaused and globalPause check clearly in the beginning of all public/external functions which move tokens/funds in/out or change contract state in any way. Also, validate all possible control flows to check that market/global pausing works in all scenarios and applies to all contract state and not specific functionalities", "Vulnerability Information": "There are still public/external functions that are unguarded by marketPaused and globalPause flags which can affect contract state in paused scenarios."}
4. {"Vulnerability Type": "Variable consistency issue", "Vulnerability Location": "minRentalDayDivisor variable", "Repair Method": "Accept or at least document the risk of change to code to prevent this from happening", "Vulnerability Information": "The minRentalDayDivisor can be different between markets and treasury."}
5. {"Vulnerability Type": "Sequence of events issue", "Vulnerability Location": "RCFactory.createMarket function", "Repair Method": "Add a check to ensure that _timestamps[0] is less than _timestamps[1]", "Vulnerability Information": "RCFactory.createMarket does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so."}
6. {"Vulnerability Type": "Market-specific pause issue", "Vulnerability Location": "Treasury.sponsor function", "Repair Method": "Add checks for marketPaused in the Treasury for sponsor", "Vulnerability Information": "The treasury only checks its globalPause field but does not check its market-specific marketPaused field for Treasury.sponsor."}

{"Vulnerability Type": "Missing call to removeOldBids", "Vulnerability Location": "withdrawDeposit() function of Treasury", "Repair Method": "Add call to removeOldBids() on L355 of withdrawDeposit() of Treasury", "Vulnerability Information": "If we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's bidRate in the conditional on L357 and therefore do not prevent the foreclosure in withdrawDeposit that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book."}

{"Vulnerability Type": "Function returns a shorter user's foreclosure time than expected", "Vulnerability Location": "foreclosureTimeUser function of RCTreasury", "Repair Method": "Change depositAbleToWithdraw(_user) at line 669 to user[_user].deposit. Or, change user[_user].lastRentCalc at both line 672 and 678 to block.timestamp.", "Vulnerability Information": "The function foreclosureTimeUser of RCTreasury underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card."}

