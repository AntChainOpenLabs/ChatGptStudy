{"Vulnerability Type": "incomplete verification", "Vulnerability Location": "contracts/MerkleVesting.sol, contracts/MerkleDropFactory.sol", "Repair Method": "Add EIP-712 protections and add a mechanism to allow tokens to be transferred to a different address using EIP-2612 `permit()`", "Vulnerability Information": "Contracts should clarify what is the intended behavior for Merkle trees with multiple leafs with the same address. If there's a fork, since anyone can call `withdraw()`, an attacker can monitor the blockchain for calls to `withdraw()`, and then make the same call with the same arguments on the other chain, which will send funds to the unsupported address."}

{"Vulnerability Type": "lack of input validation", "Vulnerability Location": "contracts/PermissionlessBasicPoolFactory.sol", "Repair Method": "Add input validation to prevent pool owners from preventing withdrawals of specific receipts", "Vulnerability Information": "Pool owners can prevent withdrawals of specific receipts without impacting any other functionality. Receipts are non-transferrable, so a malicious owner can monitor the blockchain for receipt creations, and inspect which account holds the receiptId. Next, by changing settings in a custom reward token that reverts for specific addresses, the owner can prevent that specific receipt owner from withdrawing."}

{"Vulnerability Type": "lack of input validation", "Vulnerability Location": "ERC20 standard transfer functions", "Repair Method": "Use safeTransferFrom of SafeERC20.sol instead of transfer", "Vulnerability Information": "ERC20 standard allows transfer function of some contracts to return bool or return nothing. This could lead to funds stuck in the contract without possibility to retrieve them."}

{"Vulnerability Type": "incomplete verification", "Vulnerability Location": "contracts/MerkleDropFactory.sol, contracts/MerkleVesting.sol", "Repair Method": "Add EIP-712 protections and add a mechanism to allow tokens to be transferred to a different address using EIP-2612 `permit()`", "Vulnerability Information": "Bank is a token vesting, airdrop and payroll tool. It uses merkle trees to massively scale token distributions with integrated vesting (time locks). If someone generates an exchange address for their drops, that address may only be valid for that chain (e.g. exchange supports BTC but not BSV), and any funds sent to the unsupported chain are lost. If there's a fork, since anyone can call `withdraw()`, an attacker can monitor the blockchain for calls to `withdraw()`, and then make the same call with the same arguments on the other chain, which will send funds to the unsupported address."}

{"Vulnerability Type": "incomplete verification", "Vulnerability Location": "function fundPool(uint poolId) internal", "Repair Method": "Update amount to contract balance increase after transfer", "Vulnerability Information": "Every time transferFrom or transfer function in ERC20 standard is called there is a possibility that underlying smart contract did not transfer the exact amount entered. It is required to find out contract balance increase/decrease after the transfer. This pattern also prevents from re-entrancy attack vector."}

{"Vulnerability Type": "Malicious token reward", "Vulnerability Location": "PermissionlessBasicPoolFactory.withdraw function", "Repair Method": "Add an emergencyWithdraw function that ignores failed reward token transfers", "Vulnerability Information": "Malicious token reward could disable withdrawals"}

{"Vulnerability Type": "Incorrect receiptId check", "Vulnerability Location": "getRewards() function in PermissionlessBasicPoolFactory contract", "Repair Method": "Add a check for uninitialized receipts with owner field as non-zero", "Vulnerability Information": "getRewards() in PermissionlessBasicPoolFactory calculate wrong reward amount for receiptId==0"}

{"Vulnerability Type": "Failure to verify ERC20 transfer success", "Vulnerability Location": "MerkleVesting withdrawal function", "Repair Method": "Add a check that verifies that the transfer has succeeded", "Vulnerability Information": "MerkleVesting withdrawal does not verify that tokens were transferred successfully"}

{"Vulnerability Type": "Excess deposited rebasing tokens", "Vulnerability Location": "Pools and Merkle-tree-related contracts", "Repair Method": "Provide a function for the pool owner to withdraw excess deposited tokens and repay any associated taxes", "Vulnerability Information": "Rebasing tokens go to the pool owner, or remain locked in the various contracts"}

{"Vulnerability Type": "Hash Collision", "Vulnerability Location": "MerkleLib.sol, MerkleDropFactory.sol", "Repair Method": "Use `leaf = keccak(abi.encodePacked(destination, value))` in `withdraw()` as this will reduce the size of the leaf data being hashed to 52 bytes. Since `keccak256` prevents length extension attacks a different length of data to be hashed can be assumed to give different hashes and prevent a collision between a leaf and other nodes in the tree.", "Vulnerability Information": "The size of a `leaf` is the same size of the parent data that is hashed, both are 64 bytes. As a result it is possible to have a hash collision between a leaf and any node in the tree. This allows for proofs to be repeated multiple times by taking subtrees as leaves."}

{"Vulnerability Type": "Denial of Service (DoS)", "Vulnerability Location": "PermissionlessBasicPoolFactory.sol", "Repair Method": "Allow `withdrawExcessRewards()` to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria.", "Vulnerability Information": "If one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call `withdraw()` for that token. The impact of one user not being able to call `withdraw()` is that the owner will now never be able to call `withdrawExcessRewards()` and therefore lock not only the users rewards and deposit but also and excess rewards attributed to the owner."}

{"Vulnerability Type": "Zero Division", "Vulnerability Location": "MerkleResistor.sol", "Repair Method": "Scale up `coinsPerSecond` by `PRECISION`, then scale down when executing withdrawals.", "Vulnerability Information": "It is possible for `coinsPerSecond` to be zero. In these cases, the `startTime` calculation will revert from division by zero, preventing initialization, and by extension, withdrawals of vested tokens."}

{"Vulnerability Type": "Unchecked Transfer", "Vulnerability Location": "withdraw() function", "Repair Method": "Wrap the transfer with a require", "Vulnerability Information": "When the transfer is made in the withdraw() function, it is not validated if the transfer was done correctly. This could be a conflict since not being able to perform it would return a false and that case would not be handled, the most common is to revert."}

{"Vulnerability Type": "PermissionlessBasicPoolFactory's withdraw can become frozen on zero reward token transfers", "Vulnerability Location": "withdraw() function in PermissionlessBasicPoolFactory.sol", "Repair Method": "Control for zero amounts in reward transfer cycle by adding a check for zero amounts in the for loop in line 224-L231", "Vulnerability Information": "Reward tokens that do not allow for zero amount transfers can prevent user pool exit."}

{"Vulnerability Type": "DoS: Attacker may significantly increase the cost of  withdrawExcessRewards()  by creating a significant number of excess receipts", "Vulnerability Location": "withdrawExcessRewards() function in PermissionlessBasicPoolFactory.sol", "Repair Method": "Add a minimum deposit amount for each pool that can be configured by the pool owner or allow the owner to call withdrawExcessRewards() given some other criteria such as a fixed period of time has passed since the end of the auction and 90% of the deposits have been withdrawn", "Vulnerability Information": "An attacker may cause a DoS attack on withdrawExcessRewards() by creating an excessive number of receipts with minimal value."}

{"Vulnerability Type": "ERC20 tokens with different decimals than 18 leads to loss of funds", "Vulnerability Location": "addPool() function in PermissionlessBasicPoolFactory.sol", "Repair Method": "Add support for different numbers of decimals than 18 by dynamically checking decimals() for the tokens that are part of the rewards calculations or add new require statements to addPool() that will be checking that the number of decimals for all ERC20 tokens is 18", "Vulnerability Information": "Contract PermissionlessBasicPoolFactory calculates rewards by using hardcoded value of decimals 18 (1e18) for ERC20 tokens."}

{"Vulnerability Type": "Owner of a pool may prevent any taxes being withdrawn", "Vulnerability Location": "withdrawTaxes() function in PermissionlessBasicPoolFactory.sol", "Repair Method": "Implement a try-catch condition around the withdrawal of reward tokens. In the catch statement re-instate the taxes[poolId][i] = tax if the transfer fails or force taxes to be paid during withdraw()", "Vulnerability Information": "It is possible for the owner of a pool to prevent taxes from being paid without impacting any other functionality."}

{"Vulnerability Type": "Pool owners can prevent the payment of taxes", "Vulnerability Location": "withdrawTaxes() function in PermissionlessBasicPoolFactory.sol", "Repair Method": "Add another transfer to withdraw() to increase gas costs or add a custom reward token that always reverts for transfers to globalBenericiary", "Vulnerability Information": "Pool owners can prevent taxes from being paid without impacting any other functionality

{"Vulnerability Type": "Excess ether not returned", "Vulnerability Location": "SpeedBumpPriceGate: passThruGate()", "Repair Method": "Add a check to return excess ether to the user", "Vulnerability Information": "The passThruGate function did not return the excess ether, which would cause asset loss to the user."}

{"Vulnerability Type": "Unbounded loop", "Vulnerability Location": "PermissionlessBasicPoolFactory: withdraw()", "Repair Method": "Allow the specification of an offset and length to the withdraw() function", "Vulnerability Information": "The withdraw() has an unbounded loop with external calls. If the gas costs of functions change between when deposits are made and when rewards are withdrawn, or if the gas cost of the deposit (transferFrom()) is less than the gas cost of the withdrawal (transfer()), then the withdraw() function may revert due to exceeding the block size gas limit."}

{"Vulnerability Type": "Out of range check", "Vulnerability Location": "MerkleIdentity.sol: merkleIndex check", "Repair Method": "Change the range check to include 0", "Vulnerability Information": "This line checks that the index is valid. However, the trees start at index 1, therefore index 0 should fail this check, but it doesn't."}

{"Vulnerability Type": "Lack of input validation", "Vulnerability Location": "SpeedBumpPriceGate.sol: addGate()", "Repair Method": "Add a check to require priceIncreaseDenominator > 0", "Vulnerability Information": "If priceIncreaseDenominator is set to 0 when addGate(), in passThruGate() the tx will revert at L72 because of div by 0."}

{"Vulnerability Type": "Lack of input validation", "Vulnerability Location": "MerkleDropFactory: depositTokens()", "Repair Method": "Add a check to ensure 0 < treeIndex <= numTrees", "Vulnerability Information": "The function depositTokens() does not first check to ensure that the treeIndex exists."}

{"Vulnerability Type": "Centralisation Risk", "Vulnerability Location": "PermissionlessBasicPoolFactory: setGlobalTax()", "Repair Method": "Put some reasonable upper bounds on the tax rate", "Vulnerability Information": "It is possible for the owner to increase the tax rate to 99.9% in setGlobalTax()."}

