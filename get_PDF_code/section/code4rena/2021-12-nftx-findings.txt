1. {"Vulnerability Type": "Vault locking", "Vulnerability Location": "NFTXMarketplaceZap.sol and NFTXStakingZap.sol", "Repair Method": "Remove the locking logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)", "Vulnerability Information": "A malicious user could transfer any amount of a vault's vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace."}
2. {"Vulnerability Type": "Missing non-reentrancy modifier", "Vulnerability Location": "Multiple functions in various contracts", "Repair Method": "Add nonReentrant modifier to the functions", "Vulnerability Information": "Reentrancy represents a real and significant risk and should be protected against regardless of if you can foresee the external event that causes lack of protection to be an issue."}
3. {"Vulnerability Type": "Ignoring transfer return value", "Vulnerability Location": "Multiple functions in various contracts", "Repair Method": "Use safeTransfer instead of transfer and check the transfer return value", "Vulnerability Information": "The transfer return value has to be checked as there are popular tokens, such as USDT that transfer/transferFrom method doesnâ€™t return anything."}
4. {"Vulnerability Type": "Denial of Service", "Vulnerability Location": "NFTXSimpleFeeDistributor.sol", "Repair Method": "The contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function", "Vulnerability Information": "If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS."}

{"Vulnerability Type": "Siphoning rewards", "Vulnerability Location": "NFTXInventoryStaking, NFTXSimpleFeeDistributor", "Repair Method": "Add a delay to users token deposits into the XTokenUpgradeable such that miners cannot feasibly censor a transaction for the specified time interval and users cannot frontrun a transaction to distribute rewards. The interval should be chosen such that enough time is provided for the transaction to be included in a block, given poor network conditions. Alternatively, implement a Time-Weighted-Average-Balance (TWAB) implementation. Additionally, restrict the distribute function in NFTXSimpleFeeDistributor to a given role.", "Vulnerability Information": "Dishonest stakers can siphon rewards from xToken holders through the deposit function in NFTXInventoryStaking."}

{"Vulnerability Type": "Frontrunning fees", "Vulnerability Location": "NFTXVaultFactoryUpgradeable", "Repair Method": "Add a timelock to change fees. In that way, frontrunning wouldn't be possible and users would know the fees they are agreeing with.", "Vulnerability Information": "Pool Manager can frontrun entry fee to 100% and users could lose all their deposits."}

{"Vulnerability Type": "Contract replacement", "Vulnerability Location": "NFTXVaultFactory", "Repair Method": "Restrict the ability to change the factory implementation to pre-production stages or make nftxVaultFactory immutable by allowing changing it only once. If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.", "Vulnerability Information": "NFTXVaultFactoryUpgradeable implementation can be replaced in production breaking the system."}

{"Vulnerability Type": "Incorrect transfer", "Vulnerability Location": "NFTXStakingZap, NFTXMarketplaceZap", "Repair Method": "Fix the address in transferFromERC721 function to transfer to the correct address.", "Vulnerability Information": "NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address."}

1. {"Vulnerability Type": "Loss of user assets", "Vulnerability Location": "buyAndSwap1155WETH() function in NFTXMarketplaceZap.sol contract", "Repair Method": "Update the buyAndSwap1155WETH function to use maxWethIn instead of msg.value when executing the _buyVaultToken method", "Vulnerability Information": "The buyAndSwap1155WETH function may cause loss of user assets as it uses msg.value instead of maxWethIn when executing the _buyVaultToken method."}
2. {"Vulnerability Type": "No access control", "Vulnerability Location": "assignFees() function in NFTXVaultFactoryUpgradeable contract", "Repair Method": "Remove the assignFees() function", "Vulnerability Information": "The assignFees() function in NFTXVaultFactoryUpgradeable contract has no access control, allowing any user to update all fees to zero."}
3. {"Vulnerability Type": "Loss of funds", "Vulnerability Location": "buyAndSwap721WETH() function in NFTXMarketplaceZap.sol contract", "Repair Method": "Update the buyAndSwap721WETH function to return unused WETH/ETH back to msg.sender instead of 'to'", "Vulnerability Information": "The buyAndSwap721WETH function in NFTXMarketplaceZap.sol contract does not return unused WETH/ETH back to msg.sender, causing loss of funds if the user sends the wrong amount."}
4. {"Vulnerability Type": "Token approval", "Vulnerability Location": "approve() function in XTokenUpgradeable contract", "Repair Method": "Override the approve() function and track rebalanced amounts in the _allowances field", "Vulnerability Information": "The approve() function in XTokenUpgradeable contract uses xToken shares instead of the equivalent rebalanced amount, allowing the approved spender to spend more tokens than desired."}
5. {"Vulnerability Type": "Unchecked return value", "Vulnerability Location": "addLiquidity721ETHTo() function in NFTXStakingZap contract", "Repair Method": "Check the return value of the low-level call and revert the entire transaction if the refund call fails", "Vulnerability Information": "The addLiquidity721ETHTo() function in NFTXStakingZap contract performs a low-level .call but does not check the return value, causing the caller to lose all refunds of msg.value amountEth if the call

{"Vulnerability Type": "Failure to check for existing receiver", "Vulnerability Location": "NFTXSimpleFeeDistributor#addReceiver", "Repair Method": "Add a mapping address = bool isReceiver that will update whenever receivers are added, modified to a new address or removed.", "Vulnerability Information": "The addReceiver() function fails to check if the _receiver already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions."}

{"Vulnerability Type": "Return variable can remain unassigned", "Vulnerability Location": "_sendForReceiver function", "Repair Method": "Add a return value to the else block of the _sendForReceiver() function. Alternatively, if isContract should never be set to False, the code should be designed to prevent a receiver from being added with this value.", "Vulnerability Information": "The _sendForReceiver() function only sets a return function in the 'if' code block, not the 'else' case. If the 'else' case is true, no value is returned."}

{"Vulnerability Type": "Return value of the _sendForReceiver function is not set", "Vulnerability Location": "_sendForReceiver function", "Repair Method": "Add a return value to the else block of the _sendForReceiver() function.", "Vulnerability Information": "In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time."}

{"Vulnerability Type": "Double spending of fees", "Vulnerability Location": "_sendForReceiver function", "Repair Method": "Add a return value to the else block of the _sendForReceiver() function.", "Vulnerability Information": "As _sendForReceiver doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list."}

