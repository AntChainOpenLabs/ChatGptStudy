{"Vulnerability Type": "Variable balance token causing fund lock and loss", "Vulnerability Location": "VTVLVesting.sol#L295, VTVLVesting.sol#L388", "Repair Method": "Disallow such kind of variable balance token", "Vulnerability Information": "Some ERC20 token's balance could change, one example is stETH. The balance could become insufficient at the time of `withdraw()`. User's fund will be locked due to DoS."}

{"Vulnerability Type": "Tokens with lower number of decimals can result in postponed linear vesting for user", "Vulnerability Location": "VTVLVesting.sol#L174", "Repair Method": "Enforce the contract to work with only 18 decimal tokens with a `require` statement in the constructor", "Vulnerability Information": "Unexpected postponing of vesting can result in waiting times for users to receive their must-be-vested tokens."}

{"Vulnerability Type": "Two address tokens can be withdrawn by the admin even if they are vested", "Vulnerability Location": "VTVLVesting.sol#L446-L451", "Repair Method": "Replace the address check with a balance check record the vesting token balance of the contract before and after the transfer and assert that they are equal", "Vulnerability Information": "The admin can withdraw the vested funds and break the system, because the balance of the contract can be less than the vested amount."}

{"Vulnerability Type": "Supply cap of  VariableSupplyERC20Token  is not properly enforced", "Vulnerability Location": "VariableSupplyERC20Token.sol#L36-L46", "Repair Method": "Treat `2  256 1` as infinity instead of `0`", "Vulnerability Information": "The admin of the token is not constrained to minting `maxSupply_`, they can mint any number of tokens."}

1. {"Vulnerability Type": "Not able to create claim", "Vulnerability Location": "VTVLVesting.sol#L418-L437", "Repair Method": "Update `startTimestamp to 0` on `revokeClaim()`.", "Vulnerability Information": "If admin revoked any recipientâ€™s claim, admin can not create claim for the same recipient because `startTimestamp` is not updated to initial value on revoke claim."}
2. {"Vulnerability Type": "Possible DoS on vestingRecipients due to lack of disposal mechanism", "Vulnerability Location": "VTVLVesting.sol#L224, VTVLVesting.sol#L245, VTVLVesting.sol#L302, VTVLVesting.sol#L317", "Repair Method": "In the `withdraw()` function you could remove the element from `vestingRecipients` that no longer has vesting.", "Vulnerability Information": "When the smart contracts start to be used, the variable in storage vestingRecipients will start to be filled with addresses, as there is no mechanism to eliminate elements, this will cause the `allVestingRecipients()` function to generate a DoS yes has many addressess."}

1. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "VTVLVesting.sol", "Repair Method": "Add require check that force `_startTimestamp` to be greater than `block.timestamp`", "Vulnerability Information": "Vesting Schedule Start and End Time can be Set in the Past."}
2. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "VTVLVesting.sol", "Repair Method": "Validate `_releaseIntervalSecs` comparing to user's `_linearVestAmount` and `_startTimestamp` `_endTimestamp`.", "Vulnerability Information": "`_releaseIntervalSecs` is not validated."}
3. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "VTVLVesting.sol", "Repair Method": "Add `ReentrancyGuard`'s `nonReentrant` to the `withdrawAdmin` function.", "Vulnerability Information": "Reentrancy may allow an admin to steal funds."}

{"Vulnerability Type": "Incorrect Calculation", "Vulnerability Location": "_baseVestedAmount() function in VTVLVesting.sol", "Repair Method": "Perform the intermediate calculation of linearVestAmount using the uint256 type.", "Vulnerability Information": "The _baseVestedAmount() function calculates vested amount for some (claim, timestamp) pair. It is wrapped by several functions, like vestedAmount, which is used in withdraw() to calculate how much a user can retrieve from their claim. The vulnerability is due to the inadequate size of uint112 for the calculation of linearVestAmount, which can cause overflow and permanent freeze of vested tokens. The repair method is to perform the intermediate calculation of linearVestAmount using the uint256 type."}

{"Vulnerability Type": "Incorrect Historical Values", "Vulnerability Location": "_baseVestedAmount() and vestedAmount() functions in VTVLVesting.sol", "Repair Method": "For active claims, there is no reason to consider `_claim.amountWithdrawn`, as it will always have been below or equal to `vestAmt` at any point in time. So only consider `vestAmt` for inactive claims. For them, return the lowest of `vestAmt` and  `_claim.amountWithdrawn`. This will keep the values monotonic with time without distorting the historical values.", "Vulnerability Information": "The _baseVestedAmount() and vestedAmount() functions in VTVLVesting.sol return incorrect historical values due to the fact that `_claim.amountWithdrawn` is always the amount withdrawn to date, whereas `vestAmt` takes account of time, `_referenceTs`. This creates a security risk for VTVL and can result in an undesirable distribution of resources. The repair method is to only consider `vestAmt` for inactive claims and return the lowest of `vestAmt` and `_claim.amountWithdrawn`."}

