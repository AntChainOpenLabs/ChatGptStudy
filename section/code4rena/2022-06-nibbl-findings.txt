{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "Basket's withdraw multiple tokens function", "Repair Method": "Check ownership of id=0 in every iteration or don't allow ownership transfer in the multiple-token-transfer functions", "Vulnerability Information": "Reentrancy bug in Basket's withdraw multiple tokens function which gives attacker ability to transfer basket ownership and spend it but withdraw all the tokens out of basket"}

1. {"Vulnerability Type": "Loss of NFT", "Vulnerability Location": "buy function in NibblVault.sol", "Repair Method": "Add sanity checks to ensure a sane expected value for _initialTokenSupply and _initialTokenPrice", "Vulnerability Information": "Lack of sanity check on _initialTokenSupply and _initialTokenPrice can lead to a seller losing his NFT."}
2. {"Vulnerability Type": "Fee avoidance", "Vulnerability Location": "buy function in NibblVault.sol", "Repair Method": "Charge the fee for SecondaryCurve part using _chargeFeeSecondaryCurve function", "Vulnerability Information": "In the buy function of the NibblVault contract, when msg.value < _lowerCurveDiff, the fee for SecondaryCurve part is not charged."}
3. {"Vulnerability Type": "Integer overflow", "Vulnerability Location": "_updateTwav() and _getTwav() functions in Twav.sol", "Repair Method": "Add unchecked keyword in every line you add/subtract cumulative prices", "Vulnerability Information": "_updateTwav() and _getTwav() will revert when cumulativePrice overflows."}
4. {"Vulnerability Type": "Missing name and symbol", "Vulnerability Location": "Basket.sol contract", "Repair Method": "Pass name and symbol variables as immutable so they are hardcoded in the implementation byte code", "Vulnerability Information": "Basket NFTs have no name and symbol."}

{"Vulnerability Type": "Timelock Manipulation", "Vulnerability Location": "NibblVaultFactoryData.sol line 6, NibblVaultFactory.sol line 158-169, NibblVault.sol line 37", "Repair Method": "Implement functionality for bidder to cancel the bid or increase/decrease the UPDATE_TIME/BUYOUT_DURATION so the invariant BUYOUT_DURATION < UPDATE_TIME holds", "Vulnerability Information": "The NibblVault buyout duration is longer than the update timelock, which allows an attacker to initiate a buyout and then the administrator can update the vault implementation, leaving the bidder in a bad state and losing funds. The vulnerability can be fixed by implementing functionality for bidder to cancel the bid or increasing/decreasing the UPDATE_TIME/BUYOUT_DURATION so the invariant BUYOUT_DURATION < UPDATE_TIME holds."}

{"Vulnerability Type": "Ineffective TWAV Implementation", "Vulnerability Location": "NibblVault contract, _getTwav() function", "Repair Method": "Implement a proper TWAV that provides the average value of a security over a specified time. The time period/windows of the TWAV must be explicitly defined (e.g. 15 minutes, 1 hour, 24 hours) in the contract.", "Vulnerability Information": "The current TWAV implementation only has a period of 1 minute, which is too short to prevent price manipulation. A user could call the updateTWAV function to add the new valuation/observation to the twavObservations array each time a new Ethereum block is mined. As such, the current implementation becomes the average value of a security over a specific number of observations (in this case 4 observations), thus it can be considered as Observation weighted average valuation (OWAV). There is a fundamental difference between TWAV and OWAV."}

{"Vulnerability Type": "State Change Vulnerability", "Vulnerability Location": "NibblVault.updateTWAV function", "Repair Method": "Add the whenNotPaused modifier to the function", "Vulnerability Information": "Calling NibblVault.updateTWAP function will change the state of the system. It will cause the TWAP to be updated and buyout to be rejected in certain condition. When the system is in Pause mode, the system state should be frozen. However, it was possible for someone to call the NibblVault.updateTWAP function during the Pause mode, thus making changes to the system state."}

{"Vulnerability Type": "Incorrect Functionality", "Vulnerability Location": "Twav._getTwav function", "Repair Method": "Replace timestamp with cumulativeValuation", "Vulnerability Information": "The if condition of Twav._getTwav() is missing some edge cases. In this case, this function will return 0 which is different from the correct value and it will affect the main functions like NibblVault.buy() and NibblVault.sell(). I think this condition is to confirm at least 4 values were saved for twav calculation. Btw this timestamp would be zero even though there are more than 4 values properly as it's modularized by 2**32. In this case, the if condition will be false and this function will return 0."}

{"Vulnerability Type": "Arithmetic Overflow/Underflow", "Vulnerability Location": "Twav._getTwav function", "Repair Method": "Handle underflow consistently", "Vulnerability Information": "Since _blockTimestamp is uint32, subtraction underflow is desired at _twavObservationCurrent.timestamp - _twavObservationPrev.timestamp. The timestamp subtraction may revert due to underflow. Since _getTwav() is used in NibblVault._rejectBuyout(), if it reverts and there is a buyout, an essential feature of the NibblVault contract will be unavailable, causing users' funds to be frozen in the contract."}

1. {"Vulnerability Type": "Functionality", "Vulnerability Location": "NibblVault.sol", "Repair Method": "Reset buyoutEndTime when the system is paused", "Vulnerability Information": "Buyout cannot be rejected when paused"}
2. {"Vulnerability Type": "Arithmetic", "Vulnerability Location": "initialize function in NibblVault.sol", "Repair Method": "Add overflow checks or use OpenZeppelin safe cast helpers", "Vulnerability Information": "uint32 _secondaryReserveRatio can be overflowed by setting a relatively small _initialTokenSupply and _initialTokenPrice"}

