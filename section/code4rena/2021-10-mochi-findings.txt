1. {"Vulnerability Type": "MEV vulnerability", "Vulnerability Location": "ReferralFeePoolV0.claimRewardAsMochi()", "Repair Method": "Add a 'minReceivedAmount' parameter to the function and have the front-end calculate the minimum amount based on current price", "Vulnerability Information": "The function ignores slippage, making it vulnerable to MEV searchers."}
2. {"Vulnerability Type": "Contract address change vulnerability", "Vulnerability Location": "MochiVault.mint()", "Repair Method": "Disallow setting a new NFT address or ensure that the new NFT's IDs start at the old NFT's IDs", "Vulnerability Information": "Changing the engine.nft address can overwrite existing collateralized debt positions."}
3. {"Vulnerability Type": "Permission control vulnerability", "Vulnerability Location": "MochiVaultFactory.deployVault()", "Repair Method": "Add a permission check to the function", "Vulnerability Information": "Anyone can create a vault without permission control."}
4. {"Vulnerability Type": "Contract-breaking vulnerability", "Vulnerability Location": "MochiEngine.setNFT()", "Repair Method": "Remove the function", "Vulnerability Information": "Changing the NFT contract breaks the entire protocol."}
5. {"Vulnerability Type": "Sandwich attack vulnerability", "Vulnerability Location": "MochiTreasury.veCRVlock()", "Repair Method": "Add an 'onlyOwner' modifier to the function", "Vulnerability Information": "The function is vulnerable to sandwich attacks."}
6. {"Vulnerability Type": "Inaccurate accounting vulnerability", "Vulnerability Location": "MochiVault.debtIndex()", "Repair Method": "Use 'increasingDebt' consistently in all calculations", "Vulnerability Information": "The contract's debt is inconsistent with the total sum of all users' debt."}
7. {"Vulnerability Type": "Token theft vulnerability", "Vulnerability Location": "VestedRewardPool.vest() and VestedRewardPool.lock()", "Repair Method": "Create a single externally facing function which calls safeTransferFrom(), vest(), and lock() in a single transaction", "Vulnerability Information": "The functions do not utilize safeTransferFrom() and are vulnerable to frontrunning attacks."}
8. {"Vulnerability Type": "Sandwich attack vulnerability", "Vulnerability Location": "FeePoolV0.distributeMochi()", "Repair Method": "Calculate a minimum return based on TWAP and check the slippage", "Vulnerability Information": "The

{"Vulnerability Type": "Anyone can extend withdraw wait period by depositing zero collateral", "Vulnerability Location": "deposit function in MochiVault.sol", "Repair Method": "Add require(amount > 0, \"zero\") at the start of the function, as depositing zero collateral does not seem to be a necessary use case to support. It may also be worthwhile to consider only allowing the owner of a position to deposit collateral.", "Vulnerability Information": "A malicious user can call the deposit function with amount = 0, which would reset the amount of time the owner has to wait before they can withdraw their collateral from their position."}

{"Vulnerability Type": "MochiTreasuryV0.sol Is Unusable In Its Current State", "Vulnerability Location": "MochiTreasuryV0.sol", "Repair Method": "Update this contract to potentially use another escrow service that enables msg.sender to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds usdm tokens instead, removing the need to convert half of the tokens to Curve tokens.", "Vulnerability Information": "MochiTreasuryV0.sol interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, VotingEscrow.vy does not allow contracts to call the create_lock(), increase_amount() and increase_unlock_time() functions."}

{"Vulnerability Type": "Improper Validation Of create2 Return Value", "Vulnerability Location": "BeaconProxyDeployer.deploy() function in BeaconProxyDeployer.sol", "Repair Method": "Update iszero(result) to iszero(extcodesize(result)) in the line mentioned above.", "Vulnerability Information": "The function does not revert properly if there is a failed contract deployment or revert from the create2 opcode as it does not properly check the returned address for bytecode."}

{"Vulnerability Type": "Unchecked ERC20 transfer calls", "Vulnerability Location": "DutchAuctionLiquidator and other contracts", "Repair Method": "Use cheapTransfer and cheapTransferFrom functions which check for a return value.", "Vulnerability Information": "ERC20 transfer and transferFrom calls normally return true on a successful transfer. In DutchAuctionLiquidator the call asset.transfer(msg.sender, _collateral); is made. asset refers to whichever ERC20 asset is used for the vault of that auction. If asset is an ERC20 token which does not comply with the EIP-20 standard it might return false on a failed transaction rather than revert."}

{"Vulnerability Type": "Referrer can drain ReferralFeePoolV0", "Vulnerability Location": "claimRewardAsMochi function in ReferralFeePoolV0.sol", "Repair Method": "Add the following lines rewards -= reward[msg.sender]; reward[msg.sender] = 0;", "Vulnerability Information": "Function claimRewardAsMochi in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool."}

{"Vulnerability Type": "Griefing attack to block withdraws", "Vulnerability Location": "deposit function in MochiVault.sol", "Repair Method": "Create a mechanism where you only block the withdraw of recently deposited funds", "Vulnerability Information": "Every time you deposit some assets in the vault (via deposit() of MochiVault.sol) then lastDeposit[_id] is set to block.timestamp. The modifier wait() checks this value and makes sure you cannot withdraw for delay() blocks. The default value for delay() is 3 minutes. Knowing this delay you can do a griefing attack."}

{"Vulnerability Type": "registerAsset() can overwrite _assetClass value", "Vulnerability Location": "registerAsset() function in MochiProfileV0.sol", "Repair Method": "Add require(_assetClass[_asset] ==0,\"Already exists\"); in function registerAsset()", "Vulnerability Information": "Everyone can call the function registerAsset() of MochiProfileV0.sol. Assuming the liquidity for the asset is sufficient, registerAsset() will reset the _assetClass of an already registered asset to AssetClass.Sigma."}

{"Vulnerability Type": "A malicious user can potentially escape liquidation by creating a dust amount position and trigger the liquidation by themself", "Vulnerability Location": "triggerLiquidation() function in MochiLiquidator.sol", "Repair Method": "Consider making liquidated positions unable to be used (for depositing and borrowing) again.", "Vulnerability Information": "In the current implementation, a liquidated position can be used for depositing and borrowing again. However, if there is a liquidation auction ongoing, even if the position is now liquidatable, the call of triggerLiquidation() will still fail."}

{"Vulnerability Type": "Liquidation underflow", "Vulnerability Location": "MochiVault.sol, DutchAuctionLiquidator.sol", "Repair Method": "Change 'details[_id].debt -= _usdm;' to 'details[_id].debt = 0;' in MochiVault.sol", "Vulnerability Information": "Any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow."}

{"Vulnerability Type": "Stale or incorrect data", "Vulnerability Location": "ChainlinkAdapter.sol", "Repair Method": "Add checks to ensure latestRoundData() returns valid data", "Vulnerability Information": "If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle, consumers of this contract may continue using outdated stale or incorrect data."}

{"Vulnerability Type": "Treasury share overwritten", "Vulnerability Location": "FeePoolV0.sol", "Repair Method": "Remove the line where 'treasuryShare' is flushed in distributeMochi() function", "Vulnerability Information": "When distributeMochi() is called to distribute mochi tokens to veCRV holders, both mochiShare and treasuryShare is flushed from the contract when there are still usdm tokens in the contract."}

{"Vulnerability Type": "Incorrect token update", "Vulnerability Location": "UniswapV2LPAdapter.sol, SushiswapV2LPAdapter.sol", "Repair Method": "Call 'router.update(underlying, _proof)' instead of 'router.update(_asset, _proof)'", "Vulnerability Information": "The update function retrieves the underlying from the LP token pair (_asset) but then calls router.update(_asset, _proof) which is the LP token itself again."}

{"Vulnerability Type": "Borrowing max cf", "Vulnerability Location": "MochiVault.sol", "Repair Method": "Revert if 'details[_id].debt' + '_amount' > 'maxMinted' with 'cf'", "Vulnerability Information": "Borrow function in MochiVault will borrow to max cf when trying to borrow cf instead of revert with 'cf' as specified in the supplied test."}

{"Vulnerability Type": "Unexpectedly flushed treasuryShare", "Vulnerability Location": "ReferralFeePoolV0.sol", "Repair Method": "Change the length of 'path' array to 

1. {"Vulnerability Type": "Callable when locking has been toggled", "Vulnerability Location": "MochiTreasuryV0.withdrawLock()", "Repair Method": "Add require(lockCrv, \"!lock\"); to withdrawLock() to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.", "Vulnerability Information": "withdrawLock() does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly."}
2. {"Vulnerability Type": "Unsupported Sushiswap-only assets", "Vulnerability Location": "UniswapV2TokenAdapter.supports", "Repair Method": "In aboveLiquidity, if the UniswapV2 liquidity is less than the minimum liquidity, instead of returning, compare the Sushiswap liquidity against this threshold.", "Vulnerability Information": "The UniswapV2TokenAdapter does not support Sushiswap-only assets."}
3. {"Vulnerability Type": "Path-dependant and inaccurate debt accrual", "Vulnerability Location": "MochiVault.accrueDebt", "Repair Method": "Don't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time, i.e., reduce it by the discount of all users (instead of current caller only) when accruing to correctly track the debt.", "Vulnerability Information": "Debt accrual is path-dependant and inaccurate."}
4. {"Vulnerability Type": "Liquidation factor less than collateral factor for Sigma type", "Vulnerability Location": "MochiProfileV0", "Repair Method": "The max collateral factor for the Sigma type should be higher than its liquidation factor.", "Vulnerability Information": "The liquidation factor is less than the collateral factor for the Sigma type in MochiProfileV0."}

