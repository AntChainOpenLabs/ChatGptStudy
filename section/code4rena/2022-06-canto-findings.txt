{"Vulnerability Type": "Missing zero address check", "Vulnerability Location": "AccountantDelegate.initialize()", "Repair Method": "Add a require() check for zero address for the treasury parameter before changing the treasury address in the initialize function.", "Vulnerability Information": "AccountantDelegate.initialize() is missing a zero address check for `treasury_` parameter, which could maybe allow treasury to be mistakenly set to 0 address."}

{"Vulnerability Type": "Transferring underlying token to CNote contract", "Vulnerability Location": "CNote.sol", "Repair Method": "Instead of checking the underlying token balance via balanceOf(address(this)) the contract could hold an internal balance of the token, mitigating the impact of tokens being forcefully transferred to the contract.", "Vulnerability Information": "The contract expects the balance of the underlying token to == 0 at all points when calling the contract functions by requiring getCashPrior() == 0, which checks token.balanceOf(address(this)) where token is the underlying asset."}

{"Vulnerability Type": "Accountant address can be set to zero", "Vulnerability Location": "CNote._setAccountantContract()", "Repair Method": "An additional require check to ensure `accountant_` parameter is not 0 address can be used in addition to the require check for caller is admin.", "Vulnerability Information": "In `CNote._setAccountantContract()`, the require() check only works when `address(_accountant) != address(0)` , leading to the ability to set `_accountant` state variable to the zero address, as well as setting admin to zero address."}

{"Vulnerability Type": "TotalSupply is broken", "Vulnerability Location": "ERC20.sol", "Repair Method": "Remove `_initialSupply`.", "Vulnerability Information": "`_totalSupply` is not initialized to 0, leading to an inaccurate total supply, which could easily break integrations, computations of market cap, etc."}

{"Vulnerability Type": "reentrancy", "Vulnerability Location": "CNote updates the accounts after sending the funds, allowing for reentrancy", "Repair Method": "Move accounting update before funds are sent out", "Vulnerability Information": "Updating the records after external interactions allows for funds draining by reentrancy."}

{"Vulnerability Type": "incorrect amount taken", "Vulnerability Location": "CNote.sol#L129", "Repair Method": "Revise CNote.sol#L129 to use repayAmountFinal instead of repayAmount", "Vulnerability Information": "User is asked to send repayAmount instead of repayAmountFinal, leading to loss of user funds."}

{"Vulnerability Type": "stealing wrapped manifest", "Vulnerability Location": "WETH.sol#L85", "Repair Method": "Remove the approve(address owner, address spender) function", "Vulnerability Information": "Allows anyone to steal all wrapped manifest from the WETH.sol contract."}

{"Vulnerability Type": "frontrunnable initializer", "Vulnerability Location": "_setAccountantContract() function in CNote.sol", "Repair Method": "Add access control to the function", "Vulnerability Information": "An attacker can monitor the mempool and frontrun the transaction in order to become both accountant and admin."}

{"Vulnerability Type": "initialization error", "Vulnerability Location": "AccountantDelegate.sol#L29", "Repair Method": "Change the require statement to check balanceOf(msg.sender) against totalSupply()", "Vulnerability Information": "The function checks whether the accountant has received the correct amount of tokens, but compares the accountant's balance with the _initialSupply, which is always 0."}

1. {"Vulnerability Type": "Wrong implementation of access control", "Vulnerability Location": "lending-market/Note.sol", "Repair Method": "Check if `msg.sender` is authorized to call `_setAccountantAddress()` regardless of whether `accountant` is already set or not", "Vulnerability Information": "The `_mint_to_Accountant()` function calls `_setAccountantAddress()` when `accountant == address(0)`, which will always be the case when `_mint_to_Accountant()` is called for the first time. And `_setAccountantAddress()` only checks if `msg.sender == admin` when `accountant != address(0)` which will always be `false`, therefore the access control is not working."}
2. {"Vulnerability Type": "Computes the wrong totalSupply()", "Vulnerability Location": "WETH.sol", "Repair Method": "Compute `totalSupply()` using the native `balance` function instead of the balance of the contract itself stored in the `balanceOf` mapping", "Vulnerability Information": "This contract computes the `totalSupply()` using the balance of the contract itself stored in the `balanceOf` mapping, when instead it should be using the native `balance` function. This way, `totalSupply()` always returns zero as the `WETH` contract itself has no way of calling `deposit` to itself and increase its own balance."}
3. {"Vulnerability Type": "Oracle may be attacked", "Vulnerability Location": "BaseV1-core.sol", "Repair Method": "Calculate TWAP average of `_reserve0` and `_reserve1` in the `_update` function by using cumulative reserve difference from last update to now which has a duration of periodSize = 1800 minutes. And when querying for current price you can just return `_reserve0` and `_reserve1`", "Vulnerability Information": "Attacker may use huge amount of their fund to pump the token in a liquidity pair for one entire block. The oracle will capture the manipulated price as current TWAP implementation may only cover 1 block if timed correctly."}
4. {"Vulnerability Type": "Note: When _initialSupply != 0, the _mint_to_Accountant function will fail", "Vulnerability Location": "Note.sol", "Repair Method": "Check if `_totalSupply + amount` overflows before calling `_mint(msg.sender, type(uint).max)` in `_mint_to_Accountant` function", "Vulnerability Information": "In Note contract, if `_initialSupply != 0`, `_totalSupply` will overflow when the `_mint_to_Accountant` function executes `_mint(msg.sender, type(uint).max)`."}
5. {"Vulnerability Type": "Anyone can create Proposal Unigov Proposal-Store.sol", "

1. {"Vulnerability Type": "Manipulation of token reserves", "Vulnerability Location": "zeroswap/UniswapV2Pair.sol", "Repair Method": "Consider removing the migrator", "Vulnerability Information": "Token reserves per lp token can be manipulated due to lack of MINIMUM_LIQUIDITY when minting the first liquidity with migrator."}
2. {"Vulnerability Type": "Overprivileged admin", "Vulnerability Location": "Comptroller.sol", "Repair Method": "Implement timelock for `_grantComp()`, implement hard coded recipient so funds cannot be arbitrarily sent to any address, implement a limit to the amount that can be granted", "Vulnerability Information": "Admin can `_grantComp()` to any address using any amount and drain the contract."}
3. {"Vulnerability Type": "Wrong address usage", "Vulnerability Location": "Comptroller.sol", "Repair Method": "Parse the WETH contract's address to the Comptroller through the constructor or another function instead of being hardcoded", "Vulnerability Information": "The Comptroller uses the wrong address for the WETH contract."}
4. {"Vulnerability Type": "Lack of access control", "Vulnerability Location": "NoteInterest.sol", "Repair Method": "Add access control for only trusted parties", "Vulnerability Information": "Anyone can set the `baseRatePerYear` after the `updateFrequency` has passed."}
5. {"Vulnerability Type": "Wrong init code hash", "Vulnerability Location": "UniswapV2Library.sol", "Repair Method": "Update the init code hash from `hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'` to the value of `UniswapV2Factory.pairCodeHash()`", "Vulnerability Information": "Wrong init code hash in `UniswapV2Library.pairFor()` will break `UniswapV2Oracle`, `UniswapV2Router02`, `SushiRoll`."}

1. {"Vulnerability Type": "Wrong implementation of getBorrowRate()", "Vulnerability Location": "lending-market/NoteInterest.sol", "Repair Method": "Implement a proper algorithm to calculate the borrow rate based on market conditions", "Vulnerability Information": "The current implementation returns a random rate based on the caller's address and baseRatePerYear."}
2. {"Vulnerability Type": "Unable to check state() if proposalId == 0", "Vulnerability Location": "GovernorBravoDelegate.sol", "Repair Method": "Implement a check to prevent queueing a proposalId with a value of 0 via the queue() function", "Vulnerability Information": "There is no check to prevent queueing a proposalId with a value of 0 via the queue() function."}
3. {"Vulnerability Type": "Incorrect condition always bound to fail", "Vulnerability Location": "GovernorBravoDelegate.sol", "Repair Method": "Remove initialProposalId = proposalCount; in the _initiate function", "Vulnerability Information": "The state function check GovernorBravoDelegate.sol#L115 will always fail since proposalId cannot lie in between initialProposalId and proposalCount due to an initialization in _initiate function."}
4. {"Vulnerability Type": "It's not possible to execute governance proposals through the GovernorBravoDelegate contract", "Vulnerability Location": "GovernorBravoDelegate.sol", "Repair Method": "Delete the line where executed is set to true", "Vulnerability Information": "It's not possible to execute a proposal through the GovernorBravoDelegate contract because the executed property of it is set to true when it's queued up."}
5. {"Vulnerability Type": "AccountantDelegate: sweepInterest function will destroy the cnote in the contract", "Vulnerability Location": "AccountantDelegate.sol", "Repair Method": "Redeem the cNote instead of destroying it in the sweepInterest function", "Vulnerability Information": "In the sweepInterest function of the AccountantDelegate contract, all cnote tokens in the contract will be transferred to address 0."}
6. {"Vulnerability Type": "Only the state() of the latest proposal can be checked", "Vulnerability Location": "GovernorBravoDelegate.sol", "Repair Method": "Change the state() function to proposalCount <= proposalId", "Vulnerability Information": "The current implementation of the state() function will only return the state from the latest proposal."}
7. {"Vulnerability Type": "WETH.allowance() returns wrong result", "Vulnerability Location": "WETH.sol", "Repair Method": "Change L104 to return _allowance[owner][spender];", "Vulnerability Information": "In this function, the return keyword is missing and it will always output 0 in this case."}

