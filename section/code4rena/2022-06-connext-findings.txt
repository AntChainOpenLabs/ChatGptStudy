1. {"Vulnerability Type": "Malicious relayer exploit", "Vulnerability Location": "SponsorVault.sol#L234-L263", "Repair Method": "Set reimburse limits accordingly and add balance checks", "Vulnerability Information": "A malicious relayer could create a large number of transactions with the max reimbursed relay fee specified in SponsorVault between chains for which they relay all of them."}
2. {"Vulnerability Type": "Arbitrary call execute failure handler issue", "Vulnerability Location": "Executor.sol#L113-L192, Executor.sol#L194-L213", "Repair Method": "Provide a way for user to cancel the execution, get ERC20 refund into the recovery address and acknowledge contract in the source chain that the bridge is failed to claim back NFT", "Vulnerability Information": "Current implementation of arbitrary call execute failure handler may break some use case for example NFT bridge."}
3. {"Vulnerability Type": "Diamond upgrade falsification", "Vulnerability Location": "DiamondCutFacet.sol#L16-L29, LibDiamond.sol#L94-L118, LibDiamond.sol#L222-L240", "Repair Method": "Add `_init` and `_calldata` to the proposition hash", "Vulnerability Information": "Diamond is to be upgraded after a certain delay to give time to the community to verify changes made by the developers. If the proposition can be falsified, the contract admins can exploit the contract in any way of their choice."}

{"Vulnerability Type": "Router owner could steal all the funds within SponsorVault", "Vulnerability Location": "BridgeFacet.sol#L541, SponsorVault.sol#L196", "Repair Method": "Reconsider the need of having a sponsor in Connext as extreme care have to be taken in its design to ensure that it will not be exploited", "Vulnerability Information": "Router owner can intentionally perform many large transfer between their own wallets in two different domain to siphon all the funds from the SponsorVault, and then proceed to withdraw all liquidity from his router."}

{"Vulnerability Type": "Incorrect Adopted mapping on updating wrapper token", "Vulnerability Location": "AssetFacet.sol#L100", "Repair Method": "Add another property to tell us the canonical ID(s?) that are currently pointing to the wrapper contract as the adopted asset", "Vulnerability Information": "If wrapper is changed then all variables storing this wrapper should also update."}

{"Vulnerability Type": "Double-Spend Issue", "Vulnerability Location": "BridgeFacet.sol#L411", "Repair Method": "Enforce a check in _executeSanityChecks to ensure that transfer data is only executed on the intended destination domain. Sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. Additionally, the execute calldata should also have a field that corresponds to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains.", "Vulnerability Information": "Malicious Relayer can Replay Execute Calldata on Different Chains Causing Double-Spend Issue"}

1. {"Vulnerability Type": "Token Approval Vulnerability", "Vulnerability Location": "BridgeFacet.sol#L984, AssetLogic.sol#L347", "Repair Method": "Set the allowance to zero before increasing the allowance", "Vulnerability Information": "Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals."}
2. {"Vulnerability Type": "Incorrect Token Repayment", "Vulnerability Location": "PortalFacet.sol#L80, PortalFacet.sol#L112", "Repair Method": "Pass the `adopted` token to `_backLoan()` instead of `_local`", "Vulnerability Information": "When repaying the AAVE Portal in `repayAavePortal()`, the `_local` asset is used to repay the loan in `_backLoan()` rather than the `adopted` asset. This is likely to cause issues in production when actually repaying loans if the asset/token being repayed to AAVE is not the same as the asset/token that was borrowed."}

1. {"Vulnerability Type": "Delay bypass", "Vulnerability Location": "LibDiamond.diamondCut()", "Repair Method": "Add an additional check in diamondCut() to ensure that acceptanceTimes is not equal to 0", "Vulnerability Information": "If rescindDiamondCut() is called, it sets acceptanceTimes to 0, which can bypass the delay time check in diamondCut()."}
2. {"Vulnerability Type": "Single point of failure", "Vulnerability Location": "BridgeFacet._handleExecuteTransaction()", "Repair Method": "Implement a fail-safe design where failure of an external call to SponsorVault will not disrupt the cross-chain communication, such as using try-catch blocks", "Vulnerability Information": "If there is an error within SponsorVault contract, the entire execute transaction will revert, causing cross-chain communication to fail. SponsorVault contract is a single point of failure for a domain."}

1. {"Vulnerability Type": "Missing slippage limit in token swap", "Vulnerability Location": "SponsorVault.sol#L187-L220", "Repair Method": "Specify slippage when calling swap tokens", "Vulnerability Information": "In reimburseLiquidityFees() of SponserVault contract swaps tokens without slippage limit so its possible to perform sandwich attack and it create MEV."}
2. {"Vulnerability Type": "Malicious relayer could cause a router to provide more liquidity than it should", "Vulnerability Location": "BridgeFacet.sol#L636", "Repair Method": "Generate the routerHash with the following items should help to prevent this attack: transferId, pathLength, _args.routers[] array", "Vulnerability Information": "Malicious Relayer Could Cause A Router To Provide More Liquidity Than It Should."}

1. {"Vulnerability Type": "Incorrect argument ordering", "Vulnerability Location": "swapAsset() function in BridgeFacet.sol, AssetLogic.sol, and SwapUtils.sol", "Repair Method": "Correct the argument ordering in the swapAsset() function", "Vulnerability Information": "The swapAsset() function facilitates two swaps, either using the internal or external pool. But if an internal pool exists, a swap will be unsuccessful because the call to s.swapStorages[_canonicalId].swapInternal() takes two incorrect arguments due to an incorrect ordering."}
2. {"Vulnerability Type": "Fee-on-transfer token vulnerability", "Vulnerability Location": "_handleExecuteTransaction function in BridgeFacet.sol and Executor.sol", "Repair Method": "Approve only one step to avoid an extra token transfer", "Vulnerability Information": "The _handleExecuteTransaction function may not work correctly on fee-on-transfer tokens. Moreover, if it fails, funds may be locked forever. As duplicated fees are applied to fee-on-transfer tokens when executing an arbitrary call message passing request, the Executor contract increases the allowance on that token for that target contract in full amount without any fee, which may open a vulnerability to steal dust fund in the contract. Failure occurs when trying to send the full amount without any fee, which is not possible because the fee is already applied one time."}

{"Vulnerability Type": "Loss of funds", "Vulnerability Location": "BridgeFacet.execute function", "Repair Method": "Update the implementation of the BridgeFacet.execute so that it will fail gracefully and not revert when the swap fails or other functions fails. Relayers should be entitled to relayer fee regardless of the outcome of the BridgeFacet.execute call for their effort.", "Vulnerability Information": "Relayers pay for the gas cost to trigger the execute function, and in return for their effort, they are reimbursed with the relayer fee. However, it is possible that the BridgeFacet.execute function will revert under certain circumstances when triggered by the relayers. When the BridgeFacet.execute reverts, the relayers will not receive any relayer fee."}

{"Vulnerability Type": "Arbitrary balance increase", "Vulnerability Location": "PortalFacet.repayAavePortal function", "Repair Method": "After the call to swapFromLocalAssetIfNeededForExactOut() add the following check: if (_local == adopted) { require(routerBalance >= amountIn); }", "Vulnerability Information": "The caller of repayAavePortal() can trigger an underflow to arbitrarily increase the caller's balance through an underflow. The attacker is able to trigger an underflow and increase their balance arbitrarily high. The repayAavePortal() function only verifies that routerBalance < _maxIn."}

{"Vulnerability Type": "Malicious relayer could favor their routers", "Vulnerability Location": "BridgeFacet.execute function", "Repair Method": "Two possible methods: 1) Verify the execute calldata received from the relayer is valid and has not been altered by signing the execute calldata with the sequencer's private key and attaching the signature to the execute calldata. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. 2) Embed the selected router(s) within the slow nomad message and use both transfer ID + selected router as the array index within the BridgeFacet.execute function.", "Vulnerability Information": "A malicious relayer could always swap the router(s) within the execute calldata with the router(s) owned by malicious relayer, and submit it to the chain for execution. This could cause the original router chosen by the sequencer to lose the opportunity to earn the liquidity fee, disrupting the balance and fairness of the protocol."}

1. {"Vulnerability Type": "Router owner could be rugged by admin", "Vulnerability Location": "RoutersFacet.removeRouter and RoutersFacet.removeRouterLiquidityFor functions", "Repair Method": "Update contract implementation to allow router owners to withdraw their liquidity even after their router has been removed by Connext Admin", "Vulnerability Information": "Router owner who provides liquidity could be rugged by Connext admin. When this happens, the router owner funds will be struck within the RoutersFacet contract, and there is no way for the router owner to retrieve their liquidity."}
2. {"Vulnerability Type": "Attacker can perform griefing for process() in PromiseRouter by reverting calls to callback() in callbackAddress", "Vulnerability Location": "PromiseRouter.process function", "Repair Method": "Use a try/catch statement for the ICallback(callbackAddress).callback(transferId, _msg.returnSuccess(), _msg.returnData()) call", "Vulnerability Information": "Attacker can setup callbackAddress that reverts on callback() and cause process() caller griefing."}

{"Vulnerability Type": "Unenforced Repayment of AAVE Portal Loan", "Vulnerability Location": "BridgeFacet.sol#L984", "Repair Method": "Implement a multisig or validation system to mitigate the risk of a single trusted actor from turning rogue and performing malicious actions. Alternatively, escrow the amount received from nomad in an Escrow contract and implement a function called settleAAVEPortalLoan within the Escrow contract, which contains the logic to perform the necessary actions to repay AAVE portal loan.", "Vulnerability Information": "Routers are not enforced to repay AAVE Portal loan, which can lead to Connext incurring a large amount of debt from AAVE portal."}

{"Vulnerability Type": "Division Rounding Error", "Vulnerability Location": "BridgeFacet.sol#L753-L803, BridgeFacet.sol#L526-L616", "Repair Method": "Perform better calculations. One possible solution is to make the last router pay the swept balance and then be reconciled this amount once the bridge transfer is complete.", "Vulnerability Information": "Division rounding error in _handleExecuteLiquidity() and _reconcile() make routerBalances and contract fund balance get out of sync and cause fund loss."}

{"Vulnerability Type": "Missing modifier", "Vulnerability Location": "StableSwapFacet.sol#L279-L286", "Repair Method": "Add the 'whenNotPaused' modifier to all functions that perform swaps or liquidity additions.", "Vulnerability Information": "Two swapping functions contain the 'whenNotPaused' modifier while 'swapExactOut()' and 'addSwapLiquidity()' do not. All functions to swap and add liquidity should contain the same modifiers to stop transactions while paused."}

{"Vulnerability Type": "Incorrect implementation", "Vulnerability Location": "SwapUtils.sol#L1053-L1062", "Repair Method": "Reset 'self.adminFees[i]' to 0 every time it's withdrawn.", "Vulnerability Information": "'self.adminFees[i]' should be reset to 0 every time it's withdrawn. Otherwise, the 'adminFees' can be withdrawn multiple times. The admin may just be unaware of this issue and casualty 'withdrawAdminFees()' from time to time, and rug all the users slowly."}

{"Vulnerability Type": "Ignoring underlying token amount withdrawn from Aave pool", "Vulnerability Location": "BridgeFacet's  _executePortalTransfer", "Repair Method": "Adjust for the amount actually withdrawn and introduce a buffer that stores minted but not yet used atoken amount", "Vulnerability Information": "Can introduce underlying token deficit by accounting for full underlying amount received from Aave unconditionally on what was actually withdrawn from Aave pool."}

{"Vulnerability Type": "Unsupported tokens with decimals larger than 18", "Vulnerability Location": "getPriceFromDex and getPriceFromChainlink functions", "Repair Method": "Check if decimals are 18 and normalize the value by dividing the decimals difference", "Vulnerability Information": "Many functions across the codebase will revert due to underflow for tokens with decimals larger than 18."}

