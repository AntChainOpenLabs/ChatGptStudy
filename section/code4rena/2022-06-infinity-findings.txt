{"Vulnerability Type": "Permanent Fund Freeze", "Vulnerability Location": "takeOrders() and takeMultipleOneOrders() functions in InfinityExchange.sol", "Repair Method": "Add a check for msg.value to be zero for cases when it is not utilized", "Vulnerability Information": "ETH funds of a user will be permanently lost if ETH is mistakenly sent over with ERC20 based takeOrders and takeMultipleOneOrders calls."}

{"Vulnerability Type": "Malicious Sell Order", "Vulnerability Location": "MatchOneToManyOrders and matchOrders functions in InfinityExchange.sol", "Repair Method": "Ban empty NFT transfers by requiring numNfts to be bigger than zero and ensuring ERC1155 transfers at least 1 item", "Vulnerability Information": "The MatchOneToManyOrders function does not check whether a given sell order is malicious, i.e., containing no NFT tokens but still requiring payment, which may cause the sellers to maliciously profit."}

{"Vulnerability Type": "Arbitrary WETH transfer", "Vulnerability Location": "function matchOneToOneOrders", "Repair Method": "Allow users to input a maximum fee/gas cost they are willing to spend on each order. Pulling an arbitrary amount from a user's wallet without any restriction is a dangerous practice given that many users give large/infinite approval to contracts.", "Vulnerability Information": "The function `matchOneToOneOrders` transfers an arbitrary amount of WETH from the user, `buy.signer`, in its inner call to `_execMatchOneToOneOrders`. The amount charged to the user is calculated dynamically based off of the gas consumption consumed during the trace. Notably, this amount is controlled by the seller since the seller's token can be malicious and purposefully consume a large amount of gas to grief the buyer."}

{"Vulnerability Type": "Order matching logic", "Vulnerability Location": "function canExecTakeOrder", "Repair Method": "Hash all the items and put them into a list. Then check whether the lists match.", "Vulnerability Information": "When any user provides a `sellOrder` and they are trying to sell multiple tokens from *n* (n > 1) different `ERC1155` collections in a single order, hackers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price. The logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct. The problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not mean `takerItems` exactly matches all items in `makerOrder`, which means violation of the order."}

1. {"Vulnerability Type": "Malicious governance can steal WETH from buyers", "Vulnerability Location": "updateWethTranferGas function in InfinityExchange.sol", "Repair Method": "Set a sanity check in updateWethTranferGas so governance can't set it to unreasonable value. Consider using timelock for setting governance settings.", "Vulnerability Information": "Malicious governance can use updateWethTranferGas to steal WETH from buyers."}
2. {"Vulnerability Type": "Gas refunds computed in a way where the first order's buyer pays less than the later ones", "Vulnerability Location": "startGasPerOrder variable in InfinityExchange.sol", "Repair Method": "Initialize startGasPerOrder outside the for-loop.", "Vulnerability Information": "InfinityExchange computes gas refunds in a way where the first order's buyer pays less than the later ones."}
3. {"Vulnerability Type": "Maker order buyer is forced to reimburse the gas cost at any tx.gasprice", "Vulnerability Location": "gasCost computation in InfinityExchange.sol", "Repair Method": "Consider adding a new parameter to maker buy orders, maxGasCost, to allow the buyer to limit the max gas they agreed to pay.", "Vulnerability Information": "Maker order buyer is forced to reimburse the gas cost at any tx.gasprice."}

1. {"Vulnerability Type": "ERC721/ERC1155 interoperability issue", "Vulnerability Location": "function _transferNFTs", "Repair Method": "Reorder the checks to prioritize ERC1155 interface over ERC721 interface", "Vulnerability Information": "Many real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected."}
2. {"Vulnerability Type": "Arbitrary modification of protocol fee rate", "Vulnerability Location": "function setProtocolFee", "Repair Method": "Consider making the protocol fee rate a constant, or changing to the protocol fee always be paid by the taker, or changing to the new protocol fee only applies to the orders created after the rate updated", "Vulnerability Information": "Protocol fee rate can be arbitrarily modified by the owner and the new rate will apply to all existing orders."}
3. {"Vulnerability Type": "Reentrancy", "Vulnerability Location": "function matchOneToManyOrders", "Repair Method": "Conform to CEI and set the nonce to true before executing external calls", "Vulnerability Information": "Reentrancy from `matchOneToManyOrders`. `matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent."}

1. {"Vulnerability Type": "Locked Funds", "Vulnerability Location": "_updateUserStakedAmounts() function", "Repair Method": "Do not set userstakedAmounts.amount to 0 if none of its tokens are removed (vestedAmount == 0)", "Vulnerability Information": "Calling unstake() can cause locked funds."}
2. {"Vulnerability Type": "Overpayment", "Vulnerability Location": "takeOrders() and takeMultipleOneOrders() functions", "Repair Method": "Calculate and refund overpayment amounts to callers", "Vulnerability Information": "Overpayment of native ETH is not refunded to buyer."}
3. {"Vulnerability Type": "NFT Loss", "Vulnerability Location": "areNumItemsValid() and matchOrders() functions", "Repair Method": "Replace check buy.constraints[0] <= sell.constraints[0] with numConstructedItems <= sell.constraints[0] and remove doItemsIntersect(sell.nfts, buy.nfts)", "Vulnerability Information": "Sellers may lose NFTs when orders are matched with matchOrders()."}
4. {"Vulnerability Type": "Invalid Order", "Vulnerability Location": "canExecMatchOrder() and doItemsIntersect() functions", "Repair Method": "Remove doItemsIntersect(sell.nfts, buy.nfts) from canExecMatchOrder() function", "Vulnerability Information": "Incorrect condition marks valid order as invalid."}
5. {"Vulnerability Type": "None", "Vulnerability Location": "", "Repair Method": "", "Vulnerability Information": "No vulnerability mentioned in this section."}

{"Vulnerability Type": "Loss of funds", "Vulnerability Location": "matchOneToManyOrders(), takeOrders(), and matchOrders() functions in InfinityOrderBookComplication.sol and InfinityExchange.sol contracts", "Repair Method": "Add checks to ensure that an order's one collection's token ids are not duplicates in doTokenIdsIntersect() function", "Vulnerability Information": "The code doesn't check that different ids in one collection are different, so it's possible to sell one id multiple times instead of selling multiple id one time in one collection of order, leading to loss of funds for ERC1155 tokens."}

1. {"Vulnerability Type": "Accumulated ETH fees cannot be retrieved", "Vulnerability Location": "rescueETH() function in InfinityExchange.sol", "Repair Method": "Add contract balance to the funds transferred in rescueETH() function", "Vulnerability Information": "ETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract."}
2. {"Vulnerability Type": "Missing Complication check in takeMultipleOneOrders", "Vulnerability Location": "takeMultipleOneOrders() function in InfinityExchange.sol", "Repair Method": "Add canExecTakeOneOrder function in IComplication.sol and implement it in InfinityOrderBookComplication (and future Complications) to support takeMultipleOneOrders operation, then modify takeMultipleOneOrders to use the check", "Vulnerability Information": "An order's type and its rules are defined in its Complication. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers."}
3. {"Vulnerability Type": "_transferNFTs() succeeds even if no transfer is performed", "Vulnerability Location": "_transferNFTs() function in InfinityExchange.sol", "Repair Method": "If neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a transferFrom and check the balance before and after to ensure that it succeeded", "Vulnerability Information": "If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller."}

{"Vulnerability Type": "Missing input validation", "Vulnerability Location": "matchOneToManyOrders() function in InfinityOrderBookComplication.sol and _execMatchOneMakerSellToManyMakerBuys() function in InfinityExchange.sol", "Repair Method": "Add input validation to ensure that buy orders with empty tokenIds cannot be matched with sell orders unless there are no other buy orders with specified tokenIds that match the sell order's tokenIds", "Vulnerability Information": "A maker buy order with no specified NFT tokenIds may get fulfilled in matchOneToManyOrders without receiving any NFT, allowing a buyer to pay full price and receive nothing in return."}

{"Vulnerability Type": "Wrong Order Matching", "Vulnerability Location": "Functions matchOneToOneOrders(), matchOneToManyOrders(), matchOrders(), takeMultipleOneOrders(), takeOrders()", "Repair Method": "Add checks to ensure that seller != buyer", "Vulnerability Information": "Functions for order matching and execution do not check if seller and buyer are different, which can result in fund loss or griefing."}

