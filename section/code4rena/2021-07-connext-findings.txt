{"Vulnerability Type": "Malicious router can block cross-chain-transfers", "Vulnerability Location": "In variantTransactionData call", "Repair Method": "Add penalty mechanism for non-responsive routers that agreed off-chain, slashing part of their added liquidity", "Vulnerability Information": "A router could pretend to take on a user's cross-chain transfer, the user sends their prepare transaction, locking up funds on the sending chain. But then the router simply doesn't respond or responds with a prepare transaction of amount=0."}

{"Vulnerability Type": "Router liquidity on receiving chain can be double-dipped by the user", "Vulnerability Location": "fulfill() function in TransactionManager.sol", "Repair Method": "Remove the transferAsset() call from the second catch block for execute() function", "Vulnerability Information": "If addFunds() has reverted earlier, toSend amount would already have been transferred to the receivingAddress. If execute() also fails, it is again transferred."}

{"Vulnerability Type": "Signatures use only tx ID instead of entire digest", "Vulnerability Location": "recoverFulfillSignature() function", "Repair Method": "Include hashInvariantTransactionData(txData) in signatures so that they cannot be replayed with different txData (but same tx ID) whose preparedBlockNumber is 0", "Vulnerability Information": "The signature check in recoverFulfillSignature() only uses transaction ID (along with the relayer fee) which can be accidentally reused by the user."}

{"Vulnerability Type": "Anyone can arbitrarily add router liquidity", "Vulnerability Location": "addLiquidity() function in TransactionManager.sol", "Repair Method": "Consider the use of msg.sender in addLiquidity() or evaluate this risk otherwise", "Vulnerability Information": "However, anyone can call this function on the routerâ€™s behalf."}

{"Vulnerability Type": "activeTransactionBlocks are vulnerable to DDoS attacks", "Vulnerability Location": "removeUserActiveBlocks() function", "Repair Method": "Introduce an upper limit for activeTransactionBlocks or optimize the algorithm using EnumerableMap", "Vulnerability Information": "There is a potential issue in function removeUserActiveBlocks and the for loop inside it. As there is no limit for activeTransactionBlocks, it may grow so large that the for loop may never finish."}

{"Vulnerability Type": "Approval is not reset if the call to IFulfillHelper fails", "Vulnerability Location": "fulfill() function in TransactionManager.sol", "Repair Method": "Place approval inside the try/catch block or reset approval if the call fails", "Vulnerability Information": "If the call fails, it transfers these assets directly. However, in such case the approval is not reset, so a malicious callTo can pull these tokens later."}

{"Vulnerability Type": "Expired transfers will lock user funds on the sending chain", "Vulnerability Location": "transferAsset() function in TransactionManager.sol", "Repair Method": "Change receivingAssetId to sendingAssetId in transferAsset() function", "Vulnerability Information": "The cancelling relayer is being paid in receivingAssetId on the sendingChain instead of in sendingAssetID."}

