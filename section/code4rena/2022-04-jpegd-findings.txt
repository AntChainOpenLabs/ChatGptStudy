1. {"Vulnerability Type": "Reentrancy", "Vulnerability Location": "yVault.sol#L144-L145", "Repair Method": "Make `safeTransferFrom` the last call in `deposit`", "Vulnerability Information": "In `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens."}
2. {"Vulnerability Type": "Improper Access Control", "Vulnerability Location": "yVault.sol#L61, yVaultLPFarming.sol#L54", "Repair Method": "Modify the code to `require(msg.sender == tx.origin);`", "Vulnerability Information": "The noContract modifier does not work as expected."}
3. {"Vulnerability Type": "Improper Path", "Vulnerability Location": "StrategyPUSDConvex.sol#L311-L334, StrategyPUSDConvex.sol#L410-L430", "Repair Method": "Consider allowing the admin to set a path for the rewardTokens", "Vulnerability Information": "_swapUniswapV2 may use an improper path which can cause a loss of the majority of the rewardTokens."}
4. {"Vulnerability Type": "Share Dilution", "Vulnerability Location": "yVault.sol#L148-L153", "Repair Method": "Send the first min liquidity LP tokens to the zero address to enable share dilution. Ensure the number of shares to be minted is non-zero: `require(_shares != 0, \"zero shares minted\");`", "Vulnerability Information": "yVault: First depositor can break minting of shares."}
5. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "package.json#L18-L19", "Repair Method": "Upgrade `@openzeppelin/contracts` and `@openzeppelin/contracts-upgradeable` to version 4.4.1 or higher.", "Vulnerability Information": "Update initializer modifier to prevent reentrancy during initialization."}

1. {"Vulnerability Type": "incorrect function signature", "Vulnerability Location": "StrategyPUSDConvex.balanceOfJPEG", "Repair Method": "Pass `address(this)` as argument of `earned`", "Vulnerability Information": "StrategyPUSDConvex.balanceOfJPEG uses incorrect function signature while calling extraReward.earned, causing the function to unexpectedly revert everytime."}
2. {"Vulnerability Type": "trust assumption", "Vulnerability Location": "yVaultLPFarming", "Repair Method": "Return if `currentBalance ≤ previousBalance` or properly handle potential shortfall", "Vulnerability Information": "yVaultLPFarming: No guarantee JPEG currentBalance > previousBalance."}
3. {"Vulnerability Type": "data overwrite", "Vulnerability Location": "NFTVault.sol, JPEGLock.sol", "Repair Method": "Release the tokens of the existing schedule or revert in `finalizePendingNFTValueETH()` if there is an existing lock schedule", "Vulnerability Information": "Existing user’s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds."}
4. {"Vulnerability Type": "accrual failure", "Vulnerability Location": "yVaultLPFarming", "Repair Method": "Set a new controller on a vault carefully and requires a migration", "Vulnerability Information": "Setting new controller can break YVaultLPFarming."}

1. {"Vulnerability Type": "Insufficient validation", "Vulnerability Location": "_collateralPriceUsd() function", "Repair Method": "Add validation for stale price and round completeness", "Vulnerability Information": "Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong `answer` return value."}
2. {"Vulnerability Type": "Failure to handle edge case", "Vulnerability Location": "Controller.sol and StrategyPUSDConvex.sol", "Repair Method": "Replace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`", "Vulnerability Information": "The controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done. The migration would therefore revert."}
3. {"Vulnerability Type": "Lack of functionality", "Vulnerability Location": "LPFarming.sol", "Repair Method": "Add a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed", "Vulnerability Information": "A part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock. Since there is no function for the admin (or users) to withdraw the remaining, the reward will be stucked in the pool forever."}
4. {"Vulnerability Type": "Lack of validation", "Vulnerability Location": "CryptoPunksHelper.sol", "Repair Method": "Restrict the receiver address to not be address zero", "Vulnerability Information": "In the NFT helper contract, there is no validation on that the receiver address must not be address zero. Therefore, it allows owner or an attacker who gain access to the owner address to burn NFTs forever through the functions by transferring the NFTs to address zero."}

1. {"Vulnerability Type": "Incorrect reward calculation", "Vulnerability Location": "LPFarming.sol#L141-L154, LPFarming.sol#L288-L311", "Repair Method": "Add a check that _lpToken is not jpeg in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.", "Vulnerability Information": "When _lpToken is jpeg, reward calculation is incorrect."}
2. {"Vulnerability Type": "Deprecated API usage", "Vulnerability Location": "FungibleAssetVaultForDAO.sol#L105, NFTVault.sol#L459", "Repair Method": "Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete.", "Vulnerability Information": "Chainlink pricer is using a deprecated API."}
3. {"Vulnerability Type": "Interest calculation error", "Vulnerability Location": "NFTVault.sol#L590-L595", "Repair Method": "Perform the multiplication by `elapsedTime` before the division by the denominator or `365 days`.", "Vulnerability Information": "Division before Multiplication May Result In No Interest Being Accrued."}
4. {"Vulnerability Type": "Locked rewards", "Vulnerability Location": "LPFarming.sol#L190", "Repair Method": "Declare a new variable `totalLPSupply` to the struct `PoolInfo`, and use it instead of `pool.lpToken.balanceOf(address(this))`.", "Vulnerability Information": "Rewards will be locked if user transfer directly to pool without using deposit function."}
5. {"Vulnerability Type": "Accruing interest on bad debts", "Vulnerability Location": "NFTVault.sol#L844-L851", "Repair Method": "Add a stored value to record the amount of bad debt, and add a public function that allows anyone to mark a bad debt to get some reward. and change `accrue` function.", "Vulnerability Information": "Bad debts should not continue to accrue interest."}

1. {"Vulnerability Type": "Wrong calculation for yVault price per share if decimals != 18", "Vulnerability Location": "yVault.getPricePerFullShare() function", "Repair Method": "Use vault decimals() instead of hardcoded 1e18 decimals", "Vulnerability Information": "The price per share calculation does not return the correct price for underlying tokens that do not have 18 decimals. This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user."}
2. {"Vulnerability Type": "setDebtInterestApr should accrue debt first", "Vulnerability Location": "setDebtInterestApr function in NFTVault.sol", "Repair Method": "Call accrue() first in setDebtInterestApr before setting the new settings.debtInterestApr", "Vulnerability Information": "The new debt interest rate is applied retroactively to the unaccrued period on next accrue() call. It should never be applied retroactively to a previous time window as this is unfair & wrong. Borrowers can incur more debt than they should."}

