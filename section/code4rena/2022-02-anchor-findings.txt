1. {"Vulnerability Type": "Arbitrary Balance Increase", "Vulnerability Location": "anchor_beth_reward/src/user.rs#L187-L212", "Repair Method": "Option 1: Only allow the global_index to be updated once per block and cap the amount of rewards that may be paid per block. Option 2: Induce a wait time before the user may begin earning rewards, requiring a second transaction from the user to begin collecting their reward.", "Vulnerability Information": "An attacker may arbitrarily increase their bEth balance either by flashloan or purchase of wormhole eth, then converting it to bEth via anchor_beth_converter. The attacker may then have a significant portion of the total balance, and since the attacker controls a large portion of the bEth balance, they will receive a higher portion of the rewards. The logic for update_global_index() does not account for sudden balance increases."}
2. {"Vulnerability Type": "Missing Whitelist Check", "Vulnerability Location": "CrossAnchorBridge.sol#L167-L175, CrossAnchorBridge.sol#L250-L253, CrossAnchorBridge.sol#L255-L258", "Repair Method": "Uncomment the whitelist codes to ensure that only whitelisted tokens can be processed properly on the Terra side.", "Vulnerability Information": "In the current implementation of CrossAnchorBridge, all require that 'Check that token is a whitelisted token' is commented out, allowing users to send transactions with non-whitelisted tokens that cannot be processed properly on the Terra side, potentially leading to frozen funds."}
3. {"Vulnerability Type": "Out-of-Date Data", "Vulnerability Location": "overseer/src/contract.rs#L192", "Repair Method": "Call execute_epoch_operations function after config update to ensure that reward calculation is done with up-to-date data.", "Vulnerability Information": "When the anc_purchase_factor is updated by the owner, execute_epoch_operations is not called, causing out-of-date data and possible wrong bAsset rewards/borrow limits calculation."}
4. {"Vulnerability Type": "Sandwich Attack", "Vulnerability Location": "collector/src/contract.rs#L130-L137", "Repair Method": "Consider setting an ANC/asset belief_price from an oracle to prevent an attacker from creating a contract to perform a sandwich attack.", "Vulnerability Information": "The collector contract allows anyone to sweep, swapping an asset token to ANC through astro port. However, belief_price is not set and config.max_spread might not be set or misconfigured, allowing an attacker to create a contract to perform a sandwich attack to make a profit on this trade."}
5. {"Vulnerability Type": "Missing Access Control", "Vulnerability Location": "anchor_airdrop_registry/src/contract.rs#L109, anchor_airdrop_registry/src/contract.rs#L71", "Repair Method": "Add at least simple access control checks in the contract to ensure that FabricateMIRClaim and FabricateANCClaim can only be called by the Hub and not by others.", "Vulnerability Information": "FabricateMIRClaim and FabricateANCClaim should only be issued by the Hub contract, but execute_fabricate_anchor_claim and execute_fabricate_mir_claim do not restrict the caller, allowing anyone to submit these messages."}
6. {"Vulnerability Type": "Incorrect Undelegation Amount", "Vulnerability Location": "anchor_basset_hub/src/config.rs#L90-L97", "Repair Method": "Remove the ability to

1. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "anchor_basset_reward pending yields can be stolen", "Repair Method": "update state.global_index before changing the user's balance and/or transfer rewards and update global_index in one transaction", "Vulnerability Information": "If the pending yield on an underlying strategy can be harvested and cause a surge of rewards to all existing investors, especially if the harvest can be triggered permissionlessly."}
2. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "Potential lock of rewards in the custody contracts", "Repair Method": "Handle the reply on either success or failure, i.e., using ReplyOn::Always, to avoid the failure of the swap to cause tokens to be locked", "Vulnerability Information": "The rewards are locked in the contract until someone triggers swap_to_stable_denom again, and the last swap succeeds."}
3. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "Spend limit on owner can be bypassed", "Repair Method": "Decrease the config.spend_limit by the amount spend after successful spend", "Vulnerability Information": "The owner is only allowed to spend amount uptil config.spend_limit. However it was observed that this config.spend_limit is never decreased even if owner has spend an amount."}
4. {"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "Governance Voting Dis-proportionally Favours Users Who Stake And Vote After A Poll Has Been Created And Had Its Snapshot Taken", "Repair Method": "Implement a check-pointing mechanism such that when a user casts a vote, the user's staked balance is checked at the block height upon which the snapshot was taken instead of checking its most up-to-date staked balance", "Vulnerability Information": "Poll voters are actually incentivised to stake tokens after a poll has had its snapshot taken in order to maximise their voting power."}

1. {"Vulnerability Type": "Stolen Tokens", "Vulnerability Location": "staking.rs", "Repair Method": "1. Always round up in `withdraw_share` 2. Always recompute the `withdraw_amount` with the new `withdraw_share` even if the `amount` parameter was set. 3. Use a `share` parameter (instead of the `amount` parameter) and use it as `withdraw_share`. Rounding down on the resulting `withdraw_amount` is bad for the attacker as burning a share leads to fewer tokens.", "Vulnerability Information": "Staking tokens can be stolen when withdrawing from the staking contract due to rounding down of shares calculation."}
2. {"Vulnerability Type": "Spend Limit Revert", "Vulnerability Location": "borrow.rs", "Repair Method": "Consider removing the `spend_limit` or allowing users to specify an amount when `claim_rewards`.", "Vulnerability Information": "The `claim_rewards` function may revert due to the `spend_limit` set on the distributor contract."}
3. {"Vulnerability Type": "Disrupted Price Feeds", "Vulnerability Location": "oracle.rs", "Repair Method": "Change the implementation of `feed_prices` to check whether the price is stale or not. Consider implementing a mean shorting function that pulls multiple price feeds so that if one is stale it gets rejected.", "Vulnerability Information": "The `feed_prices` function in the oracle contract can accept stale prices, which can disrupt price feeds and result in wrongful liquidation of user positions."}
4. {"Vulnerability Type": "Predictable Randomness", "Vulnerability Location": "bond.rs", "Repair Method": "Keep track of all bonds with a `bond_id` and create a map of `bond_id - validator`. If a validator's stake decreased due to slashing, take the remaining unstake amount proportionally from all other validators.", "Vulnerability Information": "The `pick_validator` function used for unbonding can be predicted, allowing a validator to steal rewards and increase their own."}

{"Vulnerability Type": "Loss of Yield", "Vulnerability Location": "compute_interest_raw function in borrow.rs file", "Repair Method": "Accrue markets regularly or switch to a compound interest formula", "Vulnerability Information": "The borrow rate uses a simple interest formula to compute the accrued debt, instead of a compounding formula. This means the actual borrow rate and interest for suppliers depend on how often updates are made. This difference should be negligible in highly active markets, but it could lead to a lower borrow rate in low-activity markets, leading to suppliers losing out on interest."}

