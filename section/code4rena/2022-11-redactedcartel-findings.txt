1. {"Vulnerability Type": "Smart contract logic vulnerability", "Vulnerability Location": "AutoPxGlp.sol and PirexGmx.sol", "Repair Method": "Check balance before operation and balance after", "Vulnerability Information": "Tokens with fees will break the depositGlp() logic."}
2. {"Vulnerability Type": "Denial of Service (DoS)", "Vulnerability Location": "AutoPxGmx.sol", "Repair Method": "Set amountOutMinimum to zero when calling compound()", "Vulnerability Information": "Preventing any user from calling the functions withdraw, redeem, or depositGmx in contract AutoPxGmx."}

{"Vulnerability Type": "Share price manipulation attack", "Vulnerability Location": "PirexERC4626.sol", "Repair Method": "1. Require a reasonably high minimal amount of assets during first deposit. 2. Mint a fixed and high amount of shares on the first deposit. 3. Seed the pools during deployment. 4. Send first 1000 wei of shares to the zero address.", "Vulnerability Information": "pxGMX and pxGLP tokens can be stolen from depositors in AutoPxGmx and AutoPxGlp vaults by manipulating the price of a share."}

{"Vulnerability Type": "Reward tokens mismanagement", "Vulnerability Location": "PirexRewards.sol", "Repair Method": "Expose hard coded reward tokens in PirexGmx contract and update global and user reward states only after ensuring that at least one reward token was distributed", "Vulnerability Information": "Mismanagement of reward tokens by the owner can cause users to lose rewards due to the fact that reward state of a user is updated before their rewards are claimed and it's the reward token addresses set by the owner of the PirexRewards contract that are used to transfer rewards."}

{"Vulnerability Type": "Arithmetic", "Vulnerability Location": "PirexERC4626.convertToShares and AutoPxGmx.previewWithdraw functions", "Repair Method": "Update the previewWithdraw function to round up instead of round down when computing the number of shares to be burned.", "Vulnerability Information": "Malicious users can withdraw the assets from the vault for free, effectively allowing them to drain the assets of the vault. Ensure that at least 1 share is burned when the users withdraw their assets."}

1. {"Vulnerability Type": "Granting Insufficient Allowance", "Vulnerability Location": "AutoPxGmx.setPlatform function", "Repair Method": "Ensure that allowance is given to the new platform address so that it can pull the GMX tokens from the vault.", "Vulnerability Information": "When the owner calls the `AutoPxGmx.setPlatform` function to update the `platform` to a new address, it does not grant any allowance to the new platform address. As a result, the new platform (PirexGMX) will not be able to pull the GMX tokens from the vault. Thus, the deposit feature of the vault will break, and no one will be able to deposit."}
2. {"Vulnerability Type": "Sandwich Attack", "Vulnerability Location": "AutoPxGmx.compound function", "Repair Method": "Consider using poolFee as the fee and using an onchain price oracle to calculate the amountOutMinimum.", "Vulnerability Information": "AutoPxGmx.compound allows anyone to call to compound the reward and get the incentive. However, AutoPxGmx.compound calls `SWAP_ROUTER`.exactInputSingle with some of the parameters provided by the caller, which allows the user to perform a sandwich attack for profit."}
3. {"Vulnerability Type": "Blocking Migration", "Vulnerability Location": "PirexGmx.initiateMigration function", "Repair Method": "Think about how to make contract ensure that he doesn't control any gmxVester and glpVester tokens before migration.", "Vulnerability Information": "`PirexGmx.initiateMigration` can be blocked so contract will not be able to migrate his funds to another contract using gmx. As you can see `gmxRewardRouterV2.signalTransfer(newContract);` is called to start migration. As a result migration will never be possible as there is no possibility for PirexGmx to burn those gmxVester and glpVester tokens."}

{"Vulnerability Type": "Loss of assets", "Vulnerability Location": "AutoPxGlp::compound function", "Repair Method": "Use GMX oracle to get current price and check it against some other price feed (e.g. ChainLink). Don't depend on user passing minimum amounts of USDG and GLP tokens.", "Vulnerability Information": "Compounded assets may be lost because `AutoPxGlp::compound` can be called by anyone and minimum amount of GLP and USDG are under caller's control. The only check concerning minValues is that they are not zero (1 will work, however from the perspective of real tokens e.g. 1e6, or 1e18 it's virtually zero)."}

{"Vulnerability Type": "broken logic", "Vulnerability Location": "configureGmxState() function of PirexGmx contract", "Repair Method": "Reset the spending approval of old stakedGmx address to zero before setting approval for new stakedGmx address in configureGmxState() function", "Vulnerability Information": "The configureGmxState() function of PirexGmx contract doesn't properly call safeApprove() for stakedGmx address, which can cause different behavior in setContract() and configureGmxState() for handling stakedGmx address changes, contract won't reset approval for old stakedGmx address which is a threat because contract in that address can steal all the GMX balance any time in the future if that old address had been compromised, and contract won't reset approval for old stakedGmx address, if owner use configureGmxState() to change the stakeGmx value then it won't be possible to set stakedGmx value to previous ones by using either configureGmxState() or setContract() and contract would be in broken state."}

{"Vulnerability Type": "loss of reward", "Vulnerability Location": "migrateReward() function of PirexGmx contract", "Repair Method": "Set the producer of PirexRewards to the new PirexGmx in completeMigration() or set the old PirexGmx's pirexRewards to address(0) in migrateReward() function", "Vulnerability Information": "The migrateReward() function of PirexGmx contract may cause users to lose reward before PirexRewards.sol set new PirexGmx, which can be solved by setting the producer of PirexRewards to the new PirexGmx in completeMigration() or setting the old PirexGmx's pirexRewards to address(0) in migrateReward() function."}

{"Vulnerability Type": "Loss of fee and reward", "Vulnerability Location": "AutoPxGmx and AutoPxGlp contracts, specifically in the compound() function", "Repair Method": "Contract should keep track of its previous balance when compound() is executed and update this balance in deposits, withdraws, and claims so it can detect rewards that directly transferred to the contract without a call to compound()", "Vulnerability Information": "An attacker can call PirexRewards.claim(pxGmx/pxGpl, AutoPx*) directly, which transfers rewards to AutoPx* pool without compound logic get executed and fee calculation logic and pxGmx wouldn't be executed for those rewards. This bug would cause fee loss in AutoPxGmx and AutoPxGlp for the contract and pxGmx's reward loss for users in AutoPxGlp."}

{"Vulnerability Type": "Division by zero", "Vulnerability Location": "_calculateRewards() function in PirexGmx contract", "Repair Method": "Check that totalSupply() is not zero before using it", "Vulnerability Information": "The _calculateRewards() function in PirexGmx contract does not handle reward calculation properly, and it would revert when totalSupply() is zero which will cause claimRewards() to revert if one of 4 rewardTracker's totalSupply was zero."}

1. {"Vulnerability Type": "Loss of rewards", "Vulnerability Location": "PirexRewards.claim function", "Repair Method": "Implement RewardPerToken for users and global instead of calculating rewards based on the ratio of userRewards and globalRewards. If the amount is zero, either revert the transaction or do not clear out the user's accrued reward state variable since the user did not receive anything yet.", "Vulnerability Information": "If the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the PirexRewards.claim function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards."}
2. {"Vulnerability Type": "Redemption blocking", "Vulnerability Location": "PirexGmx contract's redeem related functions", "Repair Method": "Reserve some time range for redemption only. e.g. 1 of every 7 days.", "Vulnerability Information": "The redeem related functions are likely to be blocked due to the cooldownDuration limit on redeem/unstake in the GlpManager contract of GMX. While there is at least one deposit/stake operation in the past cooldownDuration time, redemption would fail. This limitation is user-based, and PirexGmx contract is one such user."}

1. {"Vulnerability Type": "ERC-4626 standard implementation issue", "Vulnerability Location": "AutoPxGmx.maxWithdraw and AutoPxGlp.maxWithdraw functions", "Repair Method": "Implement the maxWithdraw function in AutoPxGmx and AutoPxGlp contracts that overrides the function in PirexERC4626 and takes into account the withdrawalPenalty.", "Vulnerability Information": "The maxWithdraw function in AutoPxGmx and AutoPxGlp contracts returns an amount of assets that is too big to be withdrawn, causing the call to withdraw to revert."}
2. {"Vulnerability Type": "Hardcoded address issue", "Vulnerability Location": "SWAP_ROUTER in AutoPxGmx.sol", "Repair Method": "Do not hardcode the SWAP_ROUTER in AutoPxGmx.sol, pass this parameter in the constructor.", "Vulnerability Information": "The SWAP_ROUTER address is hardcoded as an EOA address in Avalanche, causing the AutoPxGmx.sol to not work in Avalanche."}

{"Vulnerability Type": "Incorrect reward calculation", "Vulnerability Location": "PirexRewards.sol", "Repair Method": "Implement RewardPerToken for users and global", "Vulnerability Information": "The existing reward distribution design in the PirexRewards contract will cause some users to receive fewer reward tokens than they are entitled to and cause some users to receive more rewards than they are entitled to due to the miscalculation within the existing reward distribution design."}

