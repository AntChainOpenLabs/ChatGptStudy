1. {"Vulnerability Type": "Use of transferFrom() instead of safeTransferFrom()", "Vulnerability Location": "TokenManagerERC20.sol", "Repair Method": "Use OpenZeppelin’s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.", "Vulnerability Information": "Tokens that don’t correctly implement the latest EIP20 spec will be unusable in the protocol as they revert the transaction because of the missing return value."}
2. {"Vulnerability Type": "Transactions can be replayed when a connectedChain is removed and then reconnected", "Vulnerability Location": "MessageProxy.sol", "Repair Method": "Instead of delete/reset the counter, consider leaving the counter as it is when removeConnectedChain, _addConnectedChain also should not reset the counter.", "Vulnerability Information": "Once the incomingMessageCounter resets to 0, all the past messages (transactions) can be replayed with the old signatures."}
3. {"Vulnerability Type": "transferredAmount on mainnet can be drained if a malicious account can mint more tokens on Schain", "Vulnerability Location": "DepositBoxERC20.sol, ERC20OnChain.sol, TokenManagerERC20.sol", "Repair Method": "Disable minting function to be called directly in ERC20OnChain. Only allow minting when bridging tokens over.", "Vulnerability Information": "Anyone on Schain that is able to mint more tokens, other than the mint action from postMessage in tokenManagerERC20 by bridging tokens over, can potentially drain the locked tokens in transferredAmount in depositBoxERC20 on mainnet by calling exit with the same amount of tokens in transferredAmount[schainHash][token]." }

1. {"Vulnerability Type": "Token transfer vulnerability", "Vulnerability Location": "TokenManagerERC20.exitToMainERC20()", "Repair Method": "Prevent moving schain native tokens to Ethereum MAINNET by adding require(chainHash != MAINNET_HASH)", "Vulnerability Information": "Tokens on the schain will be frozen on TokenManagerERC20, but they will not receive tokens on Ethereum."}
2. {"Vulnerability Type": "NFT URI change vulnerability", "Vulnerability Location": "ERC721OnChain.setTokenURI()", "Repair Method": "Disallow the owner of an NFT to change its token URI", "Vulnerability Information": "A user that owns an NFT can just spoof any other NFT data by changing the token URI to any of the other NFTs."}

1. {"Vulnerability Type": "Smart contract vulnerability", "Vulnerability Location": "DepositBoxEth.sol, DepositBoxERC20.sol, DepositBoxERC721.sol, DepositBoxERC1155.sol, TokenManagerERC20.sol", "Repair Method": "Add a long time lock for killing, cache whether automaticDeploy is enabled on a certain schain, remove setEthErc20Address() function, update forceBurn function for only owner can burn his tokens", "Vulnerability Information": "Various vulnerabilities in the smart contracts including rug pull, frozen funds, centralization risk, and arbitrary burning of tokens."}

1. {"Vulnerability Type": "Gas price extortion", "Vulnerability Location": "CommunityPool.sol", "Repair Method": "Use a gas price oracle rather than tx.gasprice or set a maximum gas price and have incentives for nodes submitting at a lower gas price", "Vulnerability Information": "The function refundGasByUser() can be exploited by the message sender to drain nodes and SChain owners of their balances when processing incoming messages."}
2. {"Vulnerability Type": "Incompatibility with rebasing/deflationary/inflationary tokens", "Vulnerability Location": "DepositBoxERC20 contract", "Repair Method": "Add support for such tokens before accepting user-supplied tokens or check before/after balance on the vault", "Vulnerability Information": "The DepositBoxERC20 contract does not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time."}
3. {"Vulnerability Type": "Reentrancy", "Vulnerability Location": "MessageProxyForSchain contract", "Repair Method": "Add a messageInProgressLocker modifier to postIncomingMessages", "Vulnerability Information": "The postIncomingMessages function calls _callReceiverContract(fromChainHash, messages[i], startingCounter + 1) which gives control to a contract that is potentially attacker controlled before updating the incomingMessageCounter."}
4. {"Vulnerability Type": "Loss of pending messages", "Vulnerability Location": "MessageProxy.sol", "Repair Method": "Check if there are any pending or unprocessed messages while removeConnectedChain is called and revert in that case or implement some functionality like pause just locally for the chain to be removed before the actual removeConnectedChain is called", "Vulnerability Information": "If there are any unprocessed messages to be executed or processed while removeConnectedChain is called, then they may be stuck from getting processed on the other end."}

