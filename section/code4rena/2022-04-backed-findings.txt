{"Vulnerability Type": "Reentrancy Attack", "Vulnerability Location": "NFTLoanFacilitator.sol#L205-L208, NFTLoanFacilitator.sol#L215-L218", "Repair Method": "Use `nonReentrant` modifier on `lend()` to prevent reentrancy attack or block ERC777 tokens", "Vulnerability Information": "An attacker can manipulate `loanInfo` by reentrancy attack when any lenders try to buyout. The attacker can set bad values of `lendInfo` (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect."}

{"Vulnerability Type": "Denial of Service (DoS)", "Vulnerability Location": "NFTLoanFacilitator.sol#L205-L208, NFTLoanFacilitator.sol#L215-L218", "Repair Method": "Don't transfer `ERC20(loanAssetContractAddress)` to `currentLoanOwner` in `lend()`, use a global mapping to record redemption of lenders and add an external function `redeem` for lenders to transfer `ERC20(loanAssetContractAddress)` or block ERC777 tokens", "Vulnerability Information": "If an attacker (lender) lends to a loan, the attacker can always revert transactions when any lenders try to buyout, making anyone can not buyout the loan of the attacker."}

{"Vulnerability Type": "Reentrancy Attack", "Vulnerability Location": "NFTLoanFacilitator.sol#L214-L221, NFTLoanFacilitator.sol#L230-L250", "Repair Method": "Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely. If desired, also require that the lender cannot be the same account as the borrower of a loan.", "Vulnerability Information": "If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest."}

1. {"Vulnerability Type": "Protocol doesn't handle fee on transfer tokens", "Vulnerability Location": "NFTLoanFacilitator.sol#L155-L160", "Repair Method": "Calculate the originationFee based on the requested loan amount or calculate the amount received from the initial transfer and use this amount to calculate the originationFee", "Vulnerability Information": "Loans can be created with tokens that support fee on transfer, which can cause the second transfer to fail or be received at a loss for the borrower and lender."}
2. {"Vulnerability Type": "mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk", "Vulnerability Location": "NFTLoanFacilitator.sol#L102-L102", "Repair Method": "Use safeMint in NFTLoanTicket.sol#mint()", "Vulnerability Information": "If mintBorrowTicketTo is a contract that does not implement the onERC721Received method, the BorrowTicket NFT will be used later to get back the user's funds, which can put users' funds at risk."}

{"Vulnerability Type": "Min loan amount semantics", "Vulnerability Location": "NFTLoanFacilitator.sol#L148", "Repair Method": "Add a `maxLoanAmount` parameter to limit the loan amount that can be matched to the collateral NFT's worth.", "Vulnerability Information": "The loan amount is used as a min loan amount. It can be matched as high as possible (realistically up to the collateral NFT's worth to remain in profit) and the borrower has to pay interest on the entire amount instead of just on the desired loan amount when the loan was created."}
{"Vulnerability Type": "Precision loss", "Vulnerability Location": "NFTLoanFacilitator.sol#L167-L179", "Repair Method": "Use OpenZeppelin/Math.sol#L39-L42 to avoid precision loss and change the check to `previousInterestRate != 0 && previousInterestRate < Math.ceilDiv(previousInterestRate * requiredImprovementRate, SCALAR)`.", "Vulnerability Information": "When `previousInterestRate` is less than `10` and `requiredImprovementRate` is `100`, due to precision loss, the new `interestRate` is allowed to be the same as the previous one."}
{"Vulnerability Type": "Incorrect function call", "Vulnerability Location": "NFTLoanFacilitator.sol#L241", "Repair Method": "Add a check that there actually is something to repay by requiring `loan.lastAccumulatedTimestamp > 0` before calling `repayAndCloseLoan`.", "Vulnerability Information": "The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan (matched with `lend`). Users should use `closeLoan` in this case but the contract should disallow calling `repayAndCloseLoan` because users can lose funds."}

1. {"Vulnerability Type": "Unchecked transfer", "Vulnerability Location": "NFTLoanFacilitator.sol#L116-L126", "Repair Method": "Use safeTransferFrom instead of transferFrom", "Vulnerability Information": "The sendCollateralTo address is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen."}
2. {"Vulnerability Type": "Incorrect loan amount calculation", "Vulnerability Location": "NFTLoanFacilitator.sol#L309", "Repair Method": "Store originationFeeRate in the Loan struct at the time of origination to guarantee a borrower gets the fee rate that was present when they created the loan", "Vulnerability Information": "The borrower might not get the desired min loan amount if the originationFeeRate changes, as the minLoanAmount is calculated based on the current origination fee rate and not the rate at the time of loan creation."}

