1. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "NotionalTradeModule.sol", "Repair Method": "Use a safe downcast function for uint88 values", "Vulnerability Information": "Silent overflow of _fCashAmount when a value greater than uint88 is passed into the _mint function."}
2. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "DebtIssuanceModule.sol", "Repair Method": "Implement a function that reads how many fCash assets are at the address and send them away if they aren't of the correct asset and maturity", "Vulnerability Information": "fCash of the wrong maturity and asset can be sent to wrapper address before wrapper is deployed, breaking the mint completely."}
3. {"Vulnerability Type": "Re-entrancy Attack", "Vulnerability Location": "DebtIssuanceModule.sol, ERC777.sol", "Repair Method": "Consider removing the ERC777 interface from wfCash or implementing protocol-wide cross-contract reentrancy prevention", "Vulnerability Information": "DOS set token through erc777 hook, allowing for a re-entrancy attack on the setToken contract."}

{"Vulnerability Type": "Incorrect logic", "Vulnerability Location": "_isUnderlying() function in NotionalTradeModule contract", "Repair Method": "Change the logic of _isUnderlying() in NotionalTradeModule so it returns correct results for all fcash tokens. One simple solution can be that it first check payment token value with asset token value.", "Vulnerability Information": "The logic of _isUnderlying() in NotionalTradeModule is wrong which will cause mintFCashPosition() and redeemFCashPosition() revert on fcash tokens which asset token is underlying token (asset.tokenType == TokenType.NonMintable)"}

1. {"Vulnerability Type": "Residual Allowance Might Allow Tokens In SetToken To Be Stolen", "Vulnerability Location": "_mintFCashPosition function", "Repair Method": "Approve the allowance on-demand whenever _mintFCashPosition is called, and reset the allowance back to zero after each minting process to eliminate any residual allowance.", "Vulnerability Information": "Having residual allowance increases the risk of the asset tokens being stolen from the SetToken contract."}
2. {"Vulnerability Type": "Users Might Not Be Able To Purchase Or Redeem SetToken", "Vulnerability Location": "_redeemMaturedPositions function", "Repair Method": "Consider alternate method of updating the asset position so that the SetToken's core functions (e.g. issuance and redemption) will not be locked if one of the matured fCash redemptions fails. Evaluate if _redeemMaturedPositions really need to be called during SetToken's issuance and redemption. If not, consider removing them from the hooks, so that any issue or revert within _redeemMaturedPositions won't cause the SetToken's issuance and redemption functions to stop working entirely. Consider implementing additional function to give manager/user an option to specify a list of matured fCash positions to redeem instead of forcing them to redeem all matured fCash positions at one go.", "Vulnerability Information": "If one of the fCash redemptions fails, it will cause the entire function to revert. If this happens, no one could purchase or redeem the setToken because moduleIssueHook and modileRedeemHook hooks will revert every single time."}

{"Vulnerability Type": "Rounding Issues", "Vulnerability Location": "previewWithdraw and previewMint functions", "Repair Method": "Ensure that the rounding of vault's functions behave as expected. Following are the expected rounding direction for each vault function: previewMint(uint256 shares) Round Up ⬆, previewWithdraw(uint256 assets) Round Up ⬆, previewRedeem(uint256 shares) Round Down ⬇, previewDeposit(uint256 assets) Round Down ⬇, convertToAssets(uint256 shares) Round Down ⬇, convertToShares(uint256 assets) Round Down ⬇", "Vulnerability Information": "The result of the previewMint and previewWithdraw should be rounded up. The current implementation of convertToShares function will round down the number of shares returned due to how solidity handles Integer Division. ERC4626 expects the returned value of convertToShares to be rounded down. Thus, this function behaves as expected. previewWithdraw and previewMint functions rely on NotionalV2.getfCashBorrowFromPrincipal and NotionalV2.getDepositFromfCashLend functions. Due to the nature of time-boxed contest, I was unable to verify if NotionalV2.getfCashBorrowFromPrincipal and NotionalV2.getDepositFromfCashLend functions return a rounded down or up value. If a rounded down value is returned from these functions, previewWithdraw and previewMint functions would not behave as expected."}

1. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "wfCashERC4626 contract", "Repair Method": "Check if asset token is underlying token or not and set useUnderlying based on that", "Vulnerability Information": "deposit() and mint() and _redeemInternal() in wfCashERC4626() will revert for all fcash that asset token is underlying token because they always call _mintInternal() with useUnderlying==True"}
2. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "wfCashLogic.sol#L216", "Repair Method": "Throw an error mentioning that fCash can no longer be transferred if opts.transferfCash is true and maturity is reached", "Vulnerability Information": "transferfCash does not work as expected"}
3. {"Vulnerability Type": "Control Flow", "Vulnerability Location": "_redeemInternal() function", "Repair Method": "N/A", "Vulnerability Information": "User can alter amount returned by redeem function due to control transfer"}

