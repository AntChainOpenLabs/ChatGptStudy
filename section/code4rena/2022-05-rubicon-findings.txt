1. {"Vulnerability Type": "Smart contract vulnerability", "Vulnerability Location": "strategistBootyClaim() function in BathPair.sol", "Repair Method": "Add require() statement at the beginning of the function to prevent strategists from claiming rewards for the same asset/quote parameters. Update the state of 2 mappings before transfer.", "Vulnerability Information": "Strategists can take more rewards than they should using the function strategistBootyClaim(). A strategist can call the function using same asset/quote parameters. Two mappings that save rewards will be updated for asset already after the first block but totalFillsPerAsset and balance of this contract for quote would be still positive as there would be remaining rewards for other strategists. So the strategist can get paid once more for the same asset. A reentrancy attack is possible also because two mappings are updated after transfer funds."}
2. {"Vulnerability Type": "Token reentrancy", "Vulnerability Location": "release() function in BathBuddy.sol", "Repair Method": "Add a mutex such as nonReentrant, or the synchronized modifier used in the other contracts. Implement checks-effects-interactions pattern.", "Vulnerability Information": "If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period. In the function release, there’s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array wouldn’t be updated, enabling the withdrawal of the vested amount before the vesting period ends."}
3. {"Vulnerability Type": "Smart contract vulnerability", "Vulnerability Location": "tailOff() function in BathPair.sol", "Repair Method": "Whitelist the addresses that can be used as `_stratUtil`. Add a check in `rebalance` to prevent transferring underlying token.", "Vulnerability Information": "Strategists can call `tailOff` with malicious payload to steal all funds within any BathToken. `BathPair.tailOff` allows arbitrary `_stratUtil` address. `BathToken.rebalance` allows underlying token as `filledAssetToRebalance`. These allow malicious strategists to input any token address, including the underlying token of a BathToken, and transfer them to a contract of their choosing. Whitelist the addresses that can be used as `_stratUtil`. Add a check in `rebalance` to prevent transferring underlying token."}

1. {"Vulnerability Type": "Reentrancy", "Vulnerability Location": "BathToken.initialize()", "Repair Method": "Add `onlyBathHouse` modifier to `initialize` function in `BathToken` to avoid reentrancy from malicious tokens.", "Vulnerability Information": "Malicious pools can be deployed through BathHouse. Reentrancy in `BathToken.initialize()` can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker."}
2. {"Vulnerability Type": "No Storage Gap for Upgradeable Contracts", "Vulnerability Location": "ExpiringMarket and RubiconMarket contracts", "Repair Method": "Add appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates. `uint256[50] private __gap;`", "Vulnerability Information": "For upgradeable contracts, there must be storage gap to allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments."}
3. {"Vulnerability Type": "Admin rug vectors", "Vulnerability Location": "BathHouse.sol and BathToken.sol contracts", "Repair Method": "Validate input arguments and require specific upgrade paths for each contract, not just allowing the admin to set whatever they decide, add limit to number of bonus tokens.", "Vulnerability Information": "There are multiple functions that the admin can call to brick various parts of the system, leading to user's funds being locked. Even if the owner is benevolent the fact that there is a rug vector available may negatively impact the protocol's reputation."}

1. {"Vulnerability Type": "User will lose funds", "Vulnerability Location": "swapForETH or swapWithETH/swapEntireBalance/swap function", "Repair Method": "Add a check to require a minimum length for the route parameter", "Vulnerability Information": "User will lose funds if user accidentally pass route with only 1 value which is route[0]=X WETH while calling swapForETH or swapWithETH/swapEntireBalance/swap function."}
2. {"Vulnerability Type": "Disproportionate reward distribution", "Vulnerability Location": "vestedAmount function in BathBuddy contract", "Repair Method": "Keep a tally of the fees accrued in a separate variable and work out a fairer system for distributing rewards to HODLers", "Vulnerability Information": "When a whale withdraws their tokens and receives rewards from the BathBuddy contract the fees they pay will erroneously become part of the calculation performed in function vestedAmount. This means that any subsequent withdrawer of funds may receive a disproportionate amount of tokens."}

{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "BathToken.sol#_deposit()", "Repair Method": "Add reentrancy guards or break the CEI pattern for deposits and perform the interaction first", "Vulnerability Information": "There is a risk of re-entrancy attack to mint more shares due to the lack of reentrancy guard on the _deposit() function."}

1. {"Vulnerability Type": "Inconsistent Order Book Accounting", "Vulnerability Location": "offer() function in RubiconMarket.sol", "Repair Method": "Get the actual received amount by calculating the difference of token balance before and after the transfer, and set the info.pay_amt to the actual received amount. Alternatively, implement whitelisting mechanism so that deflationary tokens will not be supported if the risk of allowing permissionless creation of pool with arbitrary token deems to be significant.", "Vulnerability Information": "A transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount."}
2. {"Vulnerability Type": "Excess Ether Not Returned", "Vulnerability Location": "swapWithETH/buyAllAmountWithETH/offerWithETH/depositWithETH functions in RubiconRouter.sol", "Repair Method": "Return excess ether to msg.sender, or require msg.value == max_fill_withFee/pay_amt/amount/amtWithFee.", "Vulnerability Information": "When msg.value is greater than the specified maximum value, the excess ether will not be returned to the user."}
3. {"Vulnerability Type": "Strategist Fund Transfer", "Vulnerability Location": "placeMarketMakingTrades() function in BathPair.sol", "Repair Method": "Limit the amount of funds a strategist has access to.", "Vulnerability Information": "The strategist is able to use user funds to trade on the RubiconMarket and transfer user funds to themselves."}
4. {"Vulnerability Type": "Cannot Deposit Deflationary Token", "Vulnerability Location": "openBathTokenSpawnAndSignal function in BathHouse.sol", "Repair Method": "Set initialLiquidityNew = newBathTokenUnderlying.balanceOf(address(this)) after line 163 and initialLiquidityExistingBathToken  = desiredPairedAsset.balanceOf(address(this)) after line 178.", "Vulnerability Information": "Function openBathTokenSpawnAndSignal will always revert when newBathTokenUnderlying or desiredPairedAsset is a deflationary token."}

1. {"Vulnerability Type": "Use of unsafe transfer functions", "Vulnerability Location": "RubiconRouter.sol[L251, L303, L320, L348, L377, L406, L471], peripheral_contracts/BathBuddy.sol[L114], rubiconPools/BathPair.sol[L601, L615], rubiconPools/BathToken.sol[L353, L357, L602, L605]", "Repair Method": "Use OpenZeppelin’s safeTransfer()/safeTransferFrom() functions instead of transfer()/transferFrom() functions or add a require() statement that checks the return value of ERC20 token transfers", "Vulnerability Information": "Failure to use safeTransfer()/safeTransferFrom() functions or add a require() statement to check the return value of ERC20 token transfers can cause silent failures of transfers and affect token accounting in contract."}
2. {"Vulnerability Type": "Multiple Unsafe Arithmetic Operations", "Vulnerability Location": "RubiconMarket.sol[L844, L857, L883, L898, L927, L951]", "Repair Method": "Use the mul operation exposed by the DSMath library to guarantee all operations are performed safely and cannot overflow", "Vulnerability Information": "Performing unsafe multiplications using the unitary denominations of either 1 ether (1e18) or 109 (1e9) can easily lead to overflows when used as a multiplier for large amounts of assets. Purchasing and selling amounts will be improperly fulfilled as well as improperly tracked as 'sold out'/'bought out'."}

{"Vulnerability Type": "Token Manipulation", "Vulnerability Location": "BathBuddy Vesting Wallet", "Repair Method": "Update the reward mechanism to ensure that the `bonusTokens` are distributed fairly and rewards of each user are accrued correctly. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This makes flash-loan attack infeasible as such an attack has to happen within the same block/transaction.", "Vulnerability Information": "An attacker could steal almost all the `bonusTokens` in the BathBuddy Vesting Wallet by depositing a large amount of tokens into a BathToken Pool to gain a significant share of the pool and then withdrawing all the shares immediately. The withdraw call will trigger the `BathToken.distributeBonusTokenRewards`, and since the attacker holds an overwhelming amount of share in the pool, they will receive almost all the `bonusToken` in the BathBuddy Vesting wallet, leaving behind a dust amount of `bonusToken` in the wallet."}

{"Vulnerability Type": "Lack of Access Control", "Vulnerability Location": "offer(uint, ERC20, uint, ERC20) and insert(uint, unint)", "Repair Method": "Implement necessary access controls to ensure only authorized users can access or remove these functions to reduce the attack surface of the protocol", "Vulnerability Information": "The functions `offer(uint, ERC20, uint, ERC20)` and `insert(uint, unint)` should only be accessible by the keepers as per the comments. However, there is no authorization logic or access control implemented. Therefore, anyone could call these two functions. These additional interfaces might potentially allow an attacker to implement sophisticated techniques to compromise the protocol in the future."}

{"Vulnerability Type": "front-running", "Vulnerability Location": "BathPair.sol#rebalancePair()", "Repair Method": "Add a new variable to track rebalancingAmount on BathToken. BathToken should be notified for any pending rebalancing amount changes via BathPair in order to avoid sudden surge of pricePerShare over rebalancePair(). rebalancingAmount should be considered as part of underlyingBalance().", "Vulnerability Information": "BathPair.sol#rebalancePair() can be front run to steal the pending rebalancing amount."}

{"Vulnerability Type": "Denial of Service (DoS)", "Vulnerability Location": "RubiconMarket.feeTo", "Repair Method": "Check if feeTo is set to a non-zero address before transferring fees.", "Vulnerability Information": "RubiconMarket.feeTo set to zero-address can DoS buy function."}

{"Vulnerability Type": "centralization risk", "Vulnerability Location": "BathToken.sol#L346-L369", "Repair Method": "Use timeLock, or avoid admin accounts.", "Vulnerability Information": "Centralized risks allows rogue pool behavior in BathToken."}

{"Vulnerability Type": "centralization risk", "Vulnerability Location": "AqueductDistributionLive and AqueductAddress", "Repair Method": "Delete deprecated code, but reserve variable declaration for slots if using upgradable contracts.", "Vulnerability Information": "Deprecated variables may cause DoS."}

{"Vulnerability Type": "incorrect calculation", "Vulnerability Location": "BathToken.sol#L199-L210", "Repair Method": "Set the name before using it.", "Vulnerability Information": "Wrong DOMAIN_SEPARATOR."}

{"Vulnerability Type": "lockup of funds", "Vulnerability Location": "BathBuddy.sol#L69", "Repair Method": "Remove the receive() function if the contract isn't supposed to handle ETH. Otherwise, add the necessary logic to release the ETH it gets.", "Vulnerability Information": "BathBuddy locks up Ether it receives."}

1. {"Vulnerability Type": "Approval vulnerability", "Vulnerability Location": "Rubicon contracts: BathHouse.sol, RubiconRouter.sol, BathToken.sol", "Repair Method": "Set the allowance to 0 before setting it to the new value.", "Vulnerability Information": "When creating a pair, the paired asset's approval is not set to 0 before it is updated, causing the function to revert when using USDT."}
2. {"Vulnerability Type": "Sync issue", "Vulnerability Location": "Rubicon contract: BathPair.sol", "Repair Method": "Sync RubiconMarketAddress between BathPair and BathHouse.", "Vulnerability Information": "RubiconMarketAddress in BathPair is initialized only once and can get out of sync with the market in BathHouse."}
3. {"Vulnerability Type": "Bonus token vulnerability", "Vulnerability Location": "Rubicon contracts: BathToken.sol, BathBuddy.sol", "Repair Method": "Add the required validations to avoid duplicate additions of bonus tokens.", "Vulnerability Information": "The function setBonusToken allows the same BonusToken to be added more than once to the array bonusTokens, causing early withdrawers to get Bonus in multiples of what they actually have the right to."}
4. {"Vulnerability Type": "Fund transfer vulnerability", "Vulnerability Location": "Rubicon contract: RubiconRouter.sol", "Repair Method": "Add a transfer of fund to the function maxSellAllAmount.", "Vulnerability Information": "maxSellAllAmount function does not transfer user's fund into its address, causing the function to always revert when RubiconMarket tries to take tokens from it."}
5. {"Vulnerability Type": "Access control vulnerability", "Vulnerability Location": "Rubicon contract: RubiconRouter.sol", "Repair Method": "Set the owner of offer_id to msg.sender in offerWithETH function and check it in cancelForETH function.", "Vulnerability Information": "Offers created through offerWithETH() can be cancelled by anyone."}

1. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "RubiconMarket contract", "Repair Method": "Move the `require` check for `buyEnabled` to the `buy` function", "Vulnerability Information": "Buys can not be disabled if offer matching is disabled"}
2. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "RubiconMarket contract", "Repair Method": "Consider removing the functionality to toggle `matchingEnabled` or only allow changing `matchingEnabled` to `false` without changing the value back to `true`", "Vulnerability Information": "Changing `matchingEnabled` in `RubiconMarket` breaks protocol"}
3. {"Vulnerability Type": "High Severity", "Vulnerability Location": "RubiconRouter contract", "Repair Method": "Implement `cancelForERC` function to cancel this offer. And set the owner of offer_id to msg.sender in offerForETH function and check it in cancelForERC function", "Vulnerability Information": "Offers created through offerForETH cannot be cancelled"}
4. {"Vulnerability Type": "High Severity", "Vulnerability Location": "BathToken contract", "Repair Method": "Implement a setter method for the `rewardsVestingWallet` state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address", "Vulnerability Information": "BathToken LPs Unable To Receive Bonus Token Due To Lack Of Wallet Setter Method"}
5. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "RubiconRouter contract", "Repair Method": "Replace `transfer()` calls with `call()`. Keep in mind to check whether the call was successful by validating the return value", "Vulnerability Information": "Use `call()` instead of `transfer()` when transferring ETH in RubiconRouter"}

1. {"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "RubiconRouter.sol", "Repair Method": "Check the contract's WETH balance before the caller is supposed to send the WETH and after the WETH is sent to confirm the contract has received enough WETH from the caller.", "Vulnerability Information": "The `withdrawForETH` function in `RubiconRouter.sol` could be used to drain the WETH in the contract."}
2. {"Vulnerability Type": "Ineffective ReserveRatio Enforcement", "Vulnerability Location": "BathPair.sol", "Repair Method": "Check that the reserveRatio for each of the underlying liquidity pools (asset and quote bathTokens) is observed before and after function execution.", "Vulnerability Information": "It was possible for the strategists to bypass the Reserve Ratio restriction and utilize all the funds in the pools, causing the pools to be illiquid."}

{"Vulnerability Type": "previewWithdraw calculates shares wrongly", "Vulnerability Location": "previewWithdraw function in BathToken.sol", "Repair Method": "Change the formula in previewWithdraw to calculate the correct amount of shares to be burned", "Vulnerability Information": "The previewWithdraw function returns less shares than the required assets due to a wrong formula, which can cause the withdraw function to always revert."}

{"Vulnerability Type": "No cap on fees can result in a DOS in BathToken.withdraw()", "Vulnerability Location": "setFeeBPS function in BathToken.sol", "Repair Method": "Add a limit to the constructors where a fee is set and to all the configuration functions for fees", "Vulnerability Information": "The owner can set an arbitrary fee which can result in a DOS if set to a value above 100%."}

{"Vulnerability Type": "maxSellAllAmount and maxBuyAllAmount functions can be unintentionally paused (always revert)", "Vulnerability Location": "maxSellAllAmount and maxBuyAllAmount functions in RubiconRouter.sol", "Repair Method": "Calculate the fee before passing the amount to the RubiconMarket's buyAll, sellAll function", "Vulnerability Information": "The two functions maxSellAllAmount and maxBuyAllAmount will always revert in case at least (100-fee)% of user's balance can be matched with orders."}

{"Vulnerability Type": "RubiconRouter.swapEntireBalance() doesn't handle the slippage check properly", "Vulnerability Location": "swapEntireBalance function in RubiconRouter.sol", "Repair Method": "Pass buy_amt_min directly to _swap() function", "Vulnerability Information": "The swapEntireBalance function allows the user to pass a buy_amt_min value which is the minimum number of tokens they should receive from the swap. But, the function doesn't pass the value to the underlying swap function."}

{"Vulnerability Type": "RubiconRouter _swap does not pass whole amount to RubiconMarket", "Vulnerability Location": "_swap function in RubiconRouter.sol", "Repair Method": "Change the parameter to the correct formula in sellAllAmount function", "Vulnerability Information": "The fee is wrongly accounted for in _swap function, which can lead to not all of the user's funds being forwarded to RubiconMarket."}

{"Vulnerability Type": "Incorrect Functionality", "Vulnerability Location": "RubiconMarket.sol#isClosed()", "Repair Method": "Update the isClosed() function to return the value of the stopped storage variable", "Vulnerability Information": "The isClosed() function always returns false, making the market unable to be stopped as designed."}

