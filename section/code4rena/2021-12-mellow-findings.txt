1. {"Vulnerability Type": "High Severity", "Vulnerability Location": "AaveVault does not update TVL on deposit/withdraw", "Repair Method": "Update the TVL when depositing and withdrawing before doing anything else", "Vulnerability Information": "Allows an attacker to deposit tokens, get a fair share of the old TVL, update the TVL to include the interest, and then withdraw the LP tokens receiving a larger share of the new TVL, receiving back their initial deposit + the share of the interest."}
2. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "Users can avoid paying vault fees", "Repair Method": "Fees must always be charged on each deposit and withdrawal, even within the same block as it could be that a huge interest 'harvest' comes in that an attacker sandwiches", "Vulnerability Information": "Allows a user to avoid paying any fees if they deposit right after a charge fee interaction and withdraw within again managementFeeChargeDelay time period."}
3. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "Bad redirects can make it impossible to deposit & withdraw", "Repair Method": "The redirects[i] = j matrix needs to be restricted. If i is redirected to j, j may not redirect itself. Check for this when setting the redirects array.", "Vulnerability Information": "If the redirects array is misconfigured, it's possible that all amountsByVault are set to zero. There are many misconfigurations that can lead to not being able to deposit to the pool anymore."}
4. {"Vulnerability Type": "High Severity", "Vulnerability Location": "UniV3Vault.sol#collectEarnings() can be front run", "Repair Method": "Consider including fees in tvl().", "Vulnerability Information": "In the current implementation, unharvested yields are not included in tvl(), making it vulnerable to front-run attacks that steal pending yields."}
5. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "UniswapV3's path issue for swapExactOutput", "Repair Method": "Don't reverse the path byte-by-byte but element-by-element.", "Vulnerability Information": "The UniV3Trader.swapExactOutput function with multi-hops is broken and cannot be used."}

1. {"Vulnerability Type": "Precision Loss", "Vulnerability Location": "YearnVault.sol#pull()", "Repair Method": "Change the code to withdraw the actual token amount from the YearnVault contract instead of relying on the calculated token amount.", "Vulnerability Information": "The actual token withdrew from `yToken.withdraw()` will most certainly be less than the `tokenAmounts[i]`, due to precision loss in the calculation of `yTokenAmount`. As a result, `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);` in `LpIssuer.sol#withdraw()` will revert due to insufficient balance."}
2. {"Vulnerability Type": "Cache Invalidation", "Vulnerability Location": "LpIssuer.sol#withdraw()", "Repair Method": "Call `updateTvls` at the beginning of `withdraw` function if the `_subvault` will cache tvl", "Vulnerability Information": "`AaveVault` cache `tvl` and update it at the end of each `_push` and `_pull`. When withdrawing from `LpIssuer`, `tokenAmounts` is calculated using the cached `tvl` to be pulled from `AaveVault`. This will lead to user missing out their share of the accrued interest / donations to Aave since the last `updateTvls`."}
3. {"Vulnerability Type": "Front-running", "Vulnerability Location": "LpIssuer.deposit()", "Repair Method": "Add minimum return amount checks. Accept a function parameter that can be chosen by the user indicating their expected LP amount for their deposit `tokenAmounts`, then check that the actually minted LP token amount is above this parameter.", "Vulnerability Information": "The `LPIssuer.deposit` first computes balanced amounts on the user's defined `tokenAmounts`. The idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be balanced, meaning, the `depositAmount / tvl` ratio should be equal for all vault tokens. But the strategist can front-run the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance. This front-run can happen accidentally whenever the strategist rebalances. Users can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended."}
4. {"Vulnerability Type": "Incorrect Formula", "Vulnerability Location": "LpIssuer.sol#_chargeFees()", "Repair Method": "Change the formula to calculate `toMint` to `(baseSupply * (minLpPriceFactor * performanceFee) / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR`", "Vulnerability Information": "A certain amount of lp tokens (shares of the vault) will be minted to the `strategyPerformanceTreasury` as `performanceFee`, the amount is calculated based on the `minLpPriceFactor`. However, the current formula for `toMint` is wrong, which issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. Causing users to lose 50% to 100% of their funds after a few times."}
5. {"Vulnerability Type": "Missing

{"Vulnerability Type": "Decrease in _numberOfValidTokens by admin", "Vulnerability Location": "ProtocolGovernance.removeFromTokenWhitelist function", "Repair Method": "Decrease _numberOfValidTokens only if the token was previously allowed", "Vulnerability Information": "The admin can repeatedly call the removeFromTokenWhitelist function and decrease _numberOfValidTokens to zero, even if the token was never allowed before. This leads to an incorrect tokenWhitelist."}

