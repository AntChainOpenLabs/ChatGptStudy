1. {"Vulnerability Type": "Frontrunning", "Vulnerability Location": "depositEther transaction", "Repair Method": "N/A", "Vulnerability Information": "A malicious validator can frontrun depositEther transaction for its pubKey and deposit 1 ether for different withdrawal credential, thereby setting withdrawal credit before deposit of 32 ether by contract and thereby when 32 deposit ether are deposited, the withdrawal credential is also what was set before rather than the one being sent in depositEther transaction."}
2. {"Vulnerability Type": "Slashing penalty", "Vulnerability Location": "ETH staking balance", "Repair Method": "Add mechanism to ensure frxETH is pegged via burning if case the ETH got slashed", "Vulnerability Information": "The main risk in ETH 2.0 POS staking is the slashing penalty, in that case the frxETH will not be pegged and the validator cannot maintain a minimum 32 ETH staking balance."}
3. {"Vulnerability Type": "Non-conforming ERC20 tokens", "Vulnerability Location": "recoverERC20 function", "Repair Method": "Use OpenZeppelin's safeTransfer", "Vulnerability Information": "There are tokens that do not return a value on success, which will cause the call to revert, even when the transfer would have been successful. This means that those tokens will be stuck forever and not be recoverable."}

1. {"Vulnerability Type": "Yield Stealing", "Vulnerability Location": "deposit() and redeem() functions", "Repair Method": "Release the lastRewardAmount immediately or only allow users to redeem yields received after 1 rewards cycle after the deposit", "Vulnerability Information": "Malicious users can steal yields from innocent users by picking special timing to deposit() and redeem()."}
2. {"Vulnerability Type": "Volatile previewMint() result", "Vulnerability Location": "mintWithSignature() function in sfrxETH contracts", "Repair Method": "Modify the smart contract to prevent the return value of previewMint() from changing while the transaction is waiting to be included in a block", "Vulnerability Information": "The result of previewMint() changes with the state of the contract, which causes the value of amount to be volatile in the mintWithSignature function when approveMax is false."}
3. {"Vulnerability Type": "Unbounded Loop", "Vulnerability Location": "removeValidator() and removeMinter() functions", "Repair Method": "Designate one minter as a 'pre-minter' that has a batch of tokens minted to it beforehand, then auxiliary contracts can connect to that instead of ERC20PermitPermissionedMint.sol instead", "Vulnerability Information": "There is an unbounded loop in removeValidator() and removeMinter() functions such that if the validators or minters_array array gets sufficiently large, this function call will fail due to exceeding the gas limit."}

1. {"Vulnerability Type": "Incorrect accounting", "Vulnerability Location": "recoverEther function and moveWithheldETH function", "Repair Method": "Update currentWithheldETH in recoverEther function and add a non-feedback payable empty function to receive special ETH without increasing the frxeth supply", "Vulnerability Information": "recoverEther and moveWithheldETH functions do not update currentWithheldETH and send withheld ETH back to the frxETHMinter contract itself, leading to incorrect accounting and duplication of accounting for the ETHs which have been already converted to the frxETH tokens."}
2. {"Vulnerability Type": "Out of gas", "Vulnerability Location": "depositEther function", "Repair Method": "Specify an upper limit for the number of deposits such that progress is possible", "Vulnerability Information": "depositEther function always iterates over all deposits that are possible with the current balance, leading to out of gas error when a lot of ETH was deposited into the contract or it was not called in a long time."}

{"Vulnerability Type": "Wrong accounting logic", "Vulnerability Location": "sfrxETH.beforeWithdraw function", "Repair Method": "Call syncRewards() before decrementing storedTotalAssets", "Vulnerability Information": "The assets have not been transferred out yet, meaning asset.balanceOf(address(this)) still has the old value. On the other hand, storedTotalAssets was already updated. Therefore, the nextRewards calculation will be inflated by the amount for which the withdrawal was requested. This has severe consequences: During the following reward period, lastRewardAmount is too high, which means that too many rewards are paid out to users who want to withdraw. A user could exploit this to steal the assets of other users. When syncRewards() is called the next time, it is possible that the nextRewards calculation underflows because lastRewardAmount  asset.balanceOf(address(this)). This is very bad because syncRewards() will be called in every withdrawal (after the rewardsCycleEnd) and none of them will succeed because of the underflow."}

{"Vulnerability Type": "DoS", "Vulnerability Location": "depositEther() function", "Repair Method": "Use try/catch to skip the wrong validator", "Vulnerability Information": "If 1 validators is used before, the whole deposit function will revert, causing DoS. And in the next rewards cycle, lastRewardAmount will be linearly added to storedTotalAssets, their sum is the return value of totalAssets(). Temporarily the depositEther() function will be inaccessible. Until the governance calls the registry to pop the wrong validator."}

{"Vulnerability Type": "Centralization risk", "Vulnerability Location": "admin privileges in frxETHMinter.sol, ERC20PermitPermissionedMint.sol, and OperatorRegistry.sol", "Repair Method": "Set all admin functions behind either a timelocked DAO or at least a timelocked multisig contract", "Vulnerability Information": "Admin can add or remove validator from OperatorRegistry.sol, set minter address or remove minter address in frxETH.sol, minter set by admin can mint or burn any amount of frxETH token, set ETE deduction ratio, withdraw any amount of ETH or ERC20 token in frcETHMinter.sol. Without significant redesign it is not possible to avoid the admin being able to rug pull the protocol."}

