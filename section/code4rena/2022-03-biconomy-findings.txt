1. {"Vulnerability Type": "Unbounded for loops", "Vulnerability Location": "LiquidityFarming.sol: L270-L285", "Repair Method": "Remove rewardRateLog and change setRewardPerSecond() function", "Vulnerability Information": "Unbounded for loops can potentially freeze users' funds in edge cases."}
2. {"Vulnerability Type": "Contract incompatibility", "Vulnerability Location": "TokenManager.sol", "Repair Method": "Add support for rebasing/inflation/deflation tokens before accepting user-supplied tokens", "Vulnerability Information": "The scope contracts do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time."}
3. {"Vulnerability Type": "Contract breaking", "Vulnerability Location": "LiquidityProviders.sol: L116", "Repair Method": "Only allow setting the lpToken contract once", "Vulnerability Information": "Setting new LP token will break contract."}
4. {"Vulnerability Type": "Permanent loss of rewards", "Vulnerability Location": "LiquidityFarming.sol: L229-L253", "Repair Method": "Add a new parameter named 'force' for withdraw() and require(force || unpaidRewards == 0) before deleting nftInfo", "Vulnerability Information": "Deleting nft Info can cause users' nft.unpaidRewards to be permanently erased."}

1. {"Vulnerability Type": "Call to non-existing contracts returns success", "Vulnerability Location": "LiquidityFarming.sol#L140, L145, L187", "Repair Method": "Use interfaces if possible", "Vulnerability Information": "Low level calls (call, delegate call and static call) return success if the called contract doesnâ€™t exist (not deployed or destructed). This makes a user be able to send his funds to non-existing addresses."}
2. {"Vulnerability Type": "Improper state handling of exclusion removals", "Vulnerability Location": "WhitelistPeriodManager.sol#L178-L184, L115-L125", "Repair Method": "Prevent exclusion removals or validate addresses in setIsExcludedAddresses", "Vulnerability Information": "The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping."}
3. {"Vulnerability Type": "Incentive Pool can be drained without rebalancing the pool", "Vulnerability Location": "LiquidityPool.sol#L149-L173, L263-L277", "Repair Method": "Disallow `toChainId` to be the source chain or require `receiver` is not `msg.sender` in `depositErc20`", "Vulnerability Information": "`depositErc20` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state."}
4. {"Vulnerability Type": "DoS by gas limit", "Vulnerability Location": "LiquidityFarming.sol#L220, L233", "Repair Method": "Limit the number of nfts that can be deposited or use pagination", "Vulnerability Information": "In `deposit` function it is possible to push to `nftIdsStaked` of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit."}
5. {"Vulnerability Type": "Owners have absolute control over protocol", "Vulnerability Location": "LiquidityFarming.sol#L174-L192", "Repair Method": "Make executors decentralized and add TimeLock for parameter changes", "Vulnerability Information": "Owners have full control over the protocol."}

{"Vulnerability Type": "Frontrunning", "Vulnerability Location": "setPerTokenWalletCap() function in WhitelistPeriodManager.sol", "Repair Method": "Add a require statement to check that _perTokenWalletCap is less than or equal to getMaxCommunityLpPositon(_token) programmatically", "Vulnerability Information": "The setPerTokenWalletCap() function in WhitelistPeriodManager.sol can be frontrun by an innocent user adding liquidity to their position between when the getMaxCommunityLpPositon() function is called and when the setPerTokenWalletCap() function is called, leading to some denial of service conditions."}

{"Vulnerability Type": "Free deposit", "Vulnerability Location": "depositErc20() function in LiquidityPool.sol", "Repair Method": "Check that tokenAddress is not NATIVE in depositErc20() function", "Vulnerability Information": "The depositErc20() function in LiquidityPool.sol allows setting tokenAddress = NATIVE and does not throw an error, allowing an attacker to deposit infinite native tokens by not paying anything."}

{"Vulnerability Type": "Manipulation of share price", "Vulnerability Location": "removeLiquidity() function in LiquidityProviders.sol", "Repair Method": "Lock part of the first mint's liquidity to maintain a minimum amount of totalReserve[token], so that the share price cannot be easily manipulated", "Vulnerability Information": "The share price of the liquidity can be manipulated to an extremely low value, making it possible for sharesToTokenAmount(totalNFTShares, _tokenAddress) to overflow in removeLiquidity() and therefore freeze users' funds."}

{"Vulnerability Type": "Contract breakage", "Vulnerability Location": "setLiquidityPool() function in LiquidityProviders.sol", "Repair Method": "Only allow setting the liquidityPool contract once", "Vulnerability Information": "Owners can change the liquidityPool variable any time with the setLiquidityPool function. Changing the liquidityPool to a different contract will make it impossible for the users to withdraw their liquidity using removeLiquidity because the tokens are still in the old liquidityPool and cannot be retrieved. Changing the liquidityPool requires a sophisticated migration mechanism."}

1. {"Vulnerability Type": "LP token redemption failure", "Vulnerability Location": "LiquidityProviders.sol#L388, LiquidityProviders.sol#L392, LiquidityPool.sol#L285", "Repair Method": "Compute LP shares based on actual available pool balance instead of totalReserve", "Vulnerability Information": "LP token holders cannot redeem their tokens when the pool is in the deficit state due to the computation of LP shares based on providedLiquidity instead of currentLiquidity."}
2. {"Vulnerability Type": "Token transfer failure", "Vulnerability Location": "LiquidityPool.sol#L171, LiquidityPool.sol#L273", "Repair Method": "Make checks for transfer amount consistent and include rewards in both checks", "Vulnerability Information": "Sending tokens close to the maximum can fail and result in loss of tokens due to inconsistent checks for transfer amount."}
3. {"Vulnerability Type": "Frontrunning attack", "Vulnerability Location": "LiquidityPool.sol#L175-L188", "Repair Method": "Implement time-weighted checks for available vs supplied liquidity or use alternative approaches such as dutch auction style deposit system", "Vulnerability Information": "Malicious users can manipulate the liquidity pool state to gain double rewards through frontrunning deposits."}
4. {"Vulnerability Type": "Token gas price overcharge", "Vulnerability Location": "LiquidityPool.sol#L330-L337", "Repair Method": "Use tokenGasPrice value with decimals of 18 and divide by 1e18 in contract", "Vulnerability Information": "Improper tokenGasPrice design can overcharge users for gas cost by a huge margin for tokens with small denominations."}

{"Vulnerability Type": "Improper state handling", "Vulnerability Location": "WhitelistPeriodManager : Improper state handling of exclusion additions", "Repair Method": "Check that the address to be excluded is not holding any LP token at the time of exclusion", "Vulnerability Information": "The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is added to the `isExcludedAddress` mapping."}
{"Vulnerability Type": "Unsupported token withdrawal", "Vulnerability Location": "Unsupported tokens cannot be withdrawn", "Repair Method": "Allow withdrawals even if the token was unsupported to allow users to reclaim their funds", "Vulnerability Information": "Users won't be able to withdraw their liquidity anymore because of this check in `removeLiquidity`."}
{"Vulnerability Type": "Wrong formula", "Vulnerability Location": "Wrong formula when add fee  incentivePool  can lead to loss of funds.", "Repair Method": "Change lines 319-322 to: incentivePool[tokenAddress] += (amount * (transferFeePerc * tokenManager.getTokensInfo(tokenAddress).equilibriumFee)) / BASE_DIVISOR;", "Vulnerability Information": "The `getAmountToTransfer` function of `LiquidityPool` updates `incentivePool[tokenAddress]` by adding some fee to it but the formula is wrong."}
{"Vulnerability Type": "Improper upper bound definition", "Vulnerability Location": "Improper Upper Bound Definition on the Fee", "Repair Method": "Consider defining upper and lower bounds on the equilibriumFee and maxFee", "Vulnerability Information": "The equilibriumFee and maxFee does not have any upper or lower bounds."}
{"Vulnerability Type": "Wrong condition checking", "Vulnerability Location": "wrong condition checking in price calculation", "Repair Method": "Change the code to: if (reserve != 0) { return totalSharesMinted[_baseToken] / totalReserve[_baseToken]; } return BASE_DIVISOR;", "Vulnerability Information": "The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition."}
{"Vulnerability Type": "Bricking the contract", "Vulnerability Location": "A  pauser  can brick the contracts", "Repair Method": "Remove `renouncePauser()`, or require the contract not in `paused` mode when `renouncePauser()`", "Vulnerability Information": "A malicious or compromised `pauser` can call `pause()` and `renouncePauser()` to brick the contract and all the funds can be frozen."}

1. {"Vulnerability Type": "Precision Loss", "Vulnerability Location": "LiquidityFarming.sol#L265-L291, LiquidityProviders.sol#L286-L292", "Repair Method": "1. Consider lowering the BASE_DIVISOR so that the initial share price can be higher; 2. Consider making ACC_TOKEN_PRECISION larger to prevent precision loss;", "Vulnerability Information": "Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss."}
2. {"Vulnerability Type": "Division by Zero", "Vulnerability Location": "LiquidityProviders.sol#L192", "Repair Method": "Return 0 in case totalSharesMinted[_tokenAddress] is zero.", "Vulnerability Information": "The public sharesToTokenAmount function does not check if the denominator totalSharesMinted[_tokenAddress] is zero. Calling functions like getFeeAccumulatedOnNft and sharesToTokenAmount from another contract should never revert."}

