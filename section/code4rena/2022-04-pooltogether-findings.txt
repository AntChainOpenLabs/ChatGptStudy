1. {"Vulnerability Type": "Owner or Manager can rug rewards", "Vulnerability Location": "function claimRewards(address _to) external onlyManagerOrOwner", "Repair Method": "Use a `poolAddressesProviderRegistry`-like contract to determine where the rewards should go, instead of letting an address be passed in", "Vulnerability Information": "A malicious owner or manager can steal all Aave rewards that are meant for PoolTogether users."}
2. {"Vulnerability Type": "Loss of funds due to rounding", "Vulnerability Location": "function supplyTokenTo(uint256 _depositAmount, address _to)", "Repair Method": "Only take the correct amount of user tokens to prevent loss due to rounding", "Vulnerability Information": "When user uses `supplyTokenTo()` to deposit tokens and get `share` in `FieldSource`, because of rounding in division, the user gets a lower amount of `share`."}
3. {"Vulnerability Type": "Emission Manager can authorize users to claim rewards on behalf of the contract", "Vulnerability Location": "RewardsController contract", "Repair Method": "Ensure that the `RewardsController` contract is owned by PoolTogether's multisig", "Vulnerability Information": "Authorized claimers can claim rewards on behalf of the `AaveV3YieldSource` contract, effectively bypassing any restrictions put in place by this proprietary contract and its `claimRewards()` function."}
4. {"Vulnerability Type": "Deposit amount requires to be updated to contract balance increase", "Vulnerability Location": "function supplyTokenTo(uint256 _depositAmount, address _to)", "Repair Method": "Find out contract balance increase/decrease after the transfer to prevent re-entrancy attack vector", "Vulnerability Information": "Every time `transferFrom` or `transfer` function in ERC20 standard is called, there is a possibility that the underlying smart contract did not transfer the exact amount entered."}

{"Vulnerability Type": "Price manipulation", "Vulnerability Location": "AaveV3YieldSource.sol", "Repair Method": "Require a minimal amount of share tokens to be minted for the first minter, and send a portion of the initial mints as a reserve to the DAO address so that the pricePerShare can be more resistant to manipulation. Also, consider adding require(_shares > 0, \"AaveV3YS/shares-gt-zero\"); before _burn(msg.sender, _shares);", "Vulnerability Information": "A malicious early user/attacker can manipulate the vault's pricePerShare to take an unfair share of future users' deposits."}

{"Vulnerability Type": "Incorrect share conversions", "Vulnerability Location": "AaveV3YieldSource.sol", "Repair Method": "One share must always equal one token. Consider removing the conversion function and ensuring that the share token is always equal to the underlying asset token.", "Vulnerability Information": "Yield source does not correctly calculate share conversions. Incorrect share conversions lead to incorrect pricing of assets and loss of principal."}

