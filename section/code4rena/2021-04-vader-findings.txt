{"Vulnerability Type": "race condition", "Vulnerability Location": "init function in multiple contracts", "Repair Method": "Add a check to the init function so that only the deployer can call it", "Vulnerability Information": "The init function can be called by anyone, leading to a race condition when the contract is deployed."}

{"Vulnerability Type": "front running", "Vulnerability Location": "Vader.redeemToMember() function", "Repair Method": "Restrict the Vader.redeemToMember() function so that only the USDV contract can call it. Pass the amount parameter from USDV.redeem() or USDV.redeemForMember() to Vader.redeemToMember() to avoid the need to sweep the entire USDV balance.", "Vulnerability Information": "The USDV balance of the Vader contract is vulnerable to theft through the Vader.redeemToMember() function due to front running."}

{"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "transferTo() function in multiple contracts", "Repair Method": "Remove transferTo() and use permit + transferFrom() instead to move tokens from tx.origin.", "Vulnerability Information": "Tokens can be stolen through the transferTo() function in VADER, USDV, and SYNTHS contracts."}

{"Vulnerability Type": "copy-paste bug", "Vulnerability Location": "calcReward() function in Vault.sol", "Repair Method": "Change variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER.", "Vulnerability Information": "The calcReward() function in Vault.sol has a copy-paste bug leading to incorrect harvest rewards."}

{"Vulnerability Type": "smart contract vulnerability", "Vulnerability Location": "Vault Weight accounting in withdrawals", "Repair Method": "Index the weight by the synth as well.", "Vulnerability Information": "Vault Weight accounting is wrong for withdrawals when depositing two different synths."}

{"Vulnerability Type": "slippage protection", "Vulnerability Location": "Router.swapWithSynthsWithLimit function", "Repair Method": "Use the base output from the first trade to check for slippage protection.", "Vulnerability Information": "Wrong slippage protection on Token -> Token trades in the Router.swapWithSynth

{"Vulnerability Type": "unhandled return value", "Vulnerability Location": "Pools.sol#L211", "Repair Method": "Check the return value and revert on 0/false or use OpenZeppelin’s SafeERC20 wrapper functions", "Vulnerability Information": "The transfer call of transferOut() could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious."}

{"Vulnerability Type": "wrong calculation", "Vulnerability Location": "Utils.calcLiquidityUnits", "Repair Method": "Fix the equation", "Vulnerability Information": "The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore."}

{"Vulnerability Type": "lack of input validation", "Vulnerability Location": "replacePool() function in Router.sol", "Repair Method": "Check if oldToken exists and is curated as part of input validation in replacePool() function", "Vulnerability Information": "Using a non-existing oldToken (even 0 address) passes the check on L236 and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function."}

{"Vulnerability Type": "allowing duplicated anchors", "Vulnerability Location": "listAnchor function in Router.sol", "Repair Method": "Only allow listAnchor to be called from the deployer by adding a require statement. Also, check if an anchor is added before by require(_isCurated == false)", "Vulnerability Information": "If the same anchor is added three times, then this anchor biases the result of getAnchorPrice."}

{"Vulnerability Type": "flash attack mitigation", "Vulnerability Location": "isMature() function in USDV.sol", "Repair Method": "Initialize blockDelay to = 1 at declaration or in constructor", "Vulnerability Information": "blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to = 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0, which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks."}

{"Vulnerability Type": "unintentional removal of liquidity", "Vulnerability Location": "removeLiquidity function in Pools.sol", "Repair Method": "Consider making the function _removeLiquidity external, which can be utilized by the router, providing information of which person removes his liquidity", "Vulnerability Information": "The removeLiquidity function in Pools.sol uses tx.origin to determine the person who wants to remove liquidity. However, such a design is dangerous since the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack, and he could unintentionally remove liquidity."}

{"Vulnerability Type": "vault rewards can be gamed", "Vulnerability Location": "_deposit function in Vault.sol", "Repair Method": "Make the rewards based on the actual synths deposited instead of a global weight tracker. Alternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths", "Vulnerability Information": "An attacker can deposit valueless custom tokens and inflate their member weight, and anyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling harvest(realSynth) with a valuable 'real' synth."}

{"Vulnerability Type": "anyone can list anchors/curate tokens", "Vulnerability Location": "listAnchor function in Router.sol", "Repair Method": "Make listAnchor

{"Vulnerability Type": "Incorrect operator", "Vulnerability Location": "deploySynth() function in Pools.sol", "Repair Method": "Change ‘||’ operator to ‘&&’ in the require statement", "Vulnerability Information": "The ‘deploySynth()’ function in ‘Pools.sol’ is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s ‘deploySynth()’ function. However, the ‘require()’ incorrectly uses the ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters."}

{"Vulnerability Type": "Transfer fee vulnerability", "Vulnerability Location": "Vader._transfer function", "Repair Method": "Increase the balance of recipient by the full amount and then burn the fee on the recipient", "Vulnerability Information": "The ‘Vader._transfer’ function burns the transfer fee on ‘msg.sender’ but this address might not be involved in the transfer at all due to ‘transferFrom’. Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality."}

{"Vulnerability Type": "Access restriction vulnerability", "Vulnerability Location": "Router.curatePool and replacePool functions", "Repair Method": "Prevent the replacing of curations through flash loans. Also, consider making pool curations DAO-exclusive actions", "Vulnerability Information": "The ‘Router.curatePool’ and ‘replacePool’ don't have any access restriction. An attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools. Curated pools determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control."}

{"Vulnerability Type": "Flash loan vulnerability", "Vulnerability Location": "flashProof modifier", "Repair Method": "Apply the modifier to individual addresses that interact with the protocol instead of ‘tx.origin’", "Vulnerability Information": "The ‘flashProof’ modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block. However, it performs this check on ‘tx.origin’ and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction."}

{"Vulnerability Type": "Missing functionality vulnerability", "Vulnerability Location": "DAO contract

{"Vulnerability Type": "User may not get IL protection", "Vulnerability Location": "Functions `removeLiquidity()` and `removeLiquidityDirectly()` in Pools.sol", "Repair Method": "Add access control (e.g. via a modifier `onlyRouter`) so `removeLiquidity()` function of Pools contract can be called only from corresponding Router contract’s `removeLiquidity()` function which provides IL protection. Alternatively, highlight in the specification and user documentation about which contract interfaces provide IL protection to users.", "Vulnerability Information": "Functions `removeLiquidity()` and `removeLiquidityDirectly()` when called directly, do not provide the the user with IL protection unlike when calling the corresponding `removeLiquidity()` function in `Router.sol`. This should be prevented, at least for `removeLiquidity()` or highlighted in the specification and user documentation."}
{"Vulnerability Type": "Swap token can be traded as fake base token", "Vulnerability Location": "`Pools.swap` function in Pools.sol", "Repair Method": "Check that `base` is either `USDV` or `VADER`.", "Vulnerability Information": "The `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `swap(token, token, member, toBase=false)` which yields a wrong swap result. It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased (and `token` balance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again."}
{"Vulnerability Type": "Wrong calcAsymmetricShare calculation", "Vulnerability Location": "The `Utils.calcAsymmetricShare` function", "Repair Method": "Clarify if the comment or the code is correct and fix them if not.", "Vulnerability Information": "The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 2 * U * u + U^2))/U^3` but the `Utils.calcAsymmetricShare` function computes `(uA * 2U^2 2uU + u^2) / U^3` which is not equivalent as can be seen from the `A

1. {"Vulnerability Type": "Denial of Service (DoS)", "Vulnerability Location": "`DAO.cancelProposal(id, id)` function", "Repair Method": "Check that `oldProposalID` != `newProposalID` before cancelling the proposal", "Vulnerability Information": "Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved. An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed."}
2. {"Vulnerability Type": "Re-execution of Completed Proposals", "Vulnerability Location": "Completed proposals", "Repair Method": "Add an `executed` flag to the proposals and disallow voting/finalising on already executed proposals", "Vulnerability Information": "A proposal that is completed has its state reset, including the votes. Users can just vote on it again and it can be executed again. Completed proposals should most likely not be allowed to be voted on / executed again. This could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the `FinalisedProposal` event has fired."}
3. {"Vulnerability Type": "Execution of Cancelled Proposals", "Vulnerability Location": "`cancelProposal` function", "Repair Method": "Set a cancel flag and check for it in `finaliseProposal` and in execution", "Vulnerability Information": "Proposals that passed the threshold ('finalized') can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution. Proposals cannot be cancelled."}
4. {"Vulnerability Type": "Arithmetic", "Vulnerability Location": "Code block with division and multiplication", "Repair Method": "Rearrange the order of operations to perform multiplication before division", "Vulnerability Information": "The code block performs division before multiplication, which can lead to incorrect results. The order of operations should be rearranged to perform multiplication before division."}

