{"Vulnerability Type": "Token Reentrancy Attack", "Vulnerability Location": "_close() function in LineOfCredit.sol", "Repair Method": "Add reentrancy protection on `close()` function", "Vulnerability Information": "The lender can draw out extra credit token from borrower's account when the credit token is ERC20 extensive with hook, such as ERC777 token. And the `count` state variable would also be underflowed, cause the line contract can't be 'REPAID', the borrower will never be able to get back the collateral."}

{"Vulnerability Type": "Malicious trading", "Vulnerability Location": "SpigotedLine.sol, SpigotedLineLib.sol", "Repair Method": "Limit the functionality for the borrower to use or add additional checks to prevent malicious trading", "Vulnerability Information": "Lender can trade claimToken in a malicious way to steal the borrower's money via `claimAndRepay()` in SpigotedLine by using malicious zeroExTradeData. The bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85 to steal money of the borrower."}

{"Vulnerability Type": "Locked ETH in protocol", "Vulnerability Location": "receiveTokenOrETH function in LineLib.sol and multiple functions in LineOfCredit.sol", "Repair Method": "Refund excessive ETH back to the sender or revert the transaction if the sent ETH is not equal to the required amount", "Vulnerability Information": "Excessive ETH is not refunded and is permanently locked in the protocol, impacting multiple scenarios for both borrowers and lenders. The bug resides in receiveTokenOrETH function when receiving ETH, where excessive ETH is added to the balance of LineOfCredit although only amount is used in internal accounting, resulting in locked ETH that cannot be withdrawn."}

{"Vulnerability Type": "Non-existing revenue contract can be passed to claimRevenue to send all tokens to treasury", "Vulnerability Location": "SpigotLib.claimRevenue and SpigotLib._claimRevenue functions", "Repair Method": "Check that a revenue contract was registered before, revert if it does not", "Vulnerability Information": "An attacker can just regularly call `claimRevenue` with this token and a non-existing revenue contract. All of the tokens that were sent to the spigot since the last call will be sent to the treasury and none to the escrow, i.e. a borrower can ensure that no revenue will be available for the lender, no matter what the configured split is."}

{"Vulnerability Type": "Whitelisted functions aren't scoped to revenue contracts and may lead to unnoticed calls due to selector clashing", "Vulnerability Location": "Whitelisted functions in the Spigot contract", "Repair Method": "Associate whitelisted functions to particular revenue contracts (for example, using a `mapping(address = mapping(bytes4 = bool))`) and validate that the selector for the call is enabled for that specific revenue contract in the `operate` function", "Vulnerability Information": "A bad actor can try to use an innocent looking function that matches the selector of another function (in a second revenue contract) that has malicious intentions."}

{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "_close(Credit memory credit, bytes32 id) function in LineOfCredit.sol", "Repair Method": "Send tokens only at the end of _close() or add a reentrancyGuard", "Vulnerability Information": "A reentrancy bug in LineOfCredit.sol allows the lender to steal other lenders tokens if they are lending the same tokens type (loss of funds). Reentrancy is possible if the borrower is lending tokens that can change the control flow. Such tokens are based on ERC20 such as ERC777, ERC223 or other customized ERC20 tokens that alert the receiver of transactions."}

{"Vulnerability Type": "Variable balance ERC20 support", "Vulnerability Location": "addCollateral(), _getCollateralValue(), increaseCredit(), depositAndClose(), depositAndRepay(), close()", "Repair Method": "checking the before and after balance of token transfer, recording the relative shares of each user instead of specific amount, if necessary, call ERC20(token).balanceOf() to confirm the balance, disallow such kind of tokens", "Vulnerability Information": "Some ERC20 tokens may have tricky balances that change over time, causing inaccurate calculations of collateral value and loss of funds."}

{"Vulnerability Type": "Mistakenly sent eth could be locked", "Vulnerability Location": "receiveTokenOrETH()", "Repair Method": "Add check for msg.value in the ERC20 part to ensure no eth is sent", "Vulnerability Information": "If ERC20 and eth are transferred at the same time, mistakenly sent eth will be ignored and locked in the contract."}

{"Vulnerability Type": "addCredit / increaseCredit cannot be called by lender first when token is ETH", "Vulnerability Location": "addCredit(), increaseCredit(), mutualConsent(), _mutualConsent()", "Repair Method": "Implement an external function to grant consent to avoid this scenario. Also consider reverting when ETH is sent along but the other party has not given their consent yet.", "Vulnerability Information": "When the lender performs the calls first and sends ETH along with the call, the call will not revert. It will instead set the consent for him, but the sent ETH is lost. Even when the lender thinks about this and does not provide any ETH on the first call, the borrower has to perform the second call. Of course, he will not provide the ETH with this call, but this will cause the transaction to revert. There is now no way for the borrower to also grant consent but still let the lender perform the call."}

{"Vulnerability Type": "Mistaken Payment", "Vulnerability Location": "LineLib.receiveTokenOrETH function", "Repair Method": "Check if payment in ETH, then verify that the sender is msg.sender in addCredit function", "Vulnerability Information": "Borrower can mistakenly add own money to credit if credit is in ETH."}

{"Vulnerability Type": "Use of Solidity's transfer() function", "Vulnerability Location": "LineLib.sol", "Repair Method": "Use low-level call.value(amount) with the corresponding result check or use OpenZeppelin Address.sendValue", "Vulnerability Information": "Using Solidity's transfer() function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw."}

{"Vulnerability Type": "Borrowing vulnerability", "Vulnerability Location": "LineOfCredit contract", "Repair Method": "Do not skip any elements when sorting new borrows into the ids queue", "Vulnerability Information": "Borrower can craft a borrow that cannot be liquidated, even by arbiter."}

1. {"Vulnerability Type": "Functionality", "Vulnerability Location": "LineOfCredit.declareInsolvent()", "Repair Method": "Review and amend the whileBorrowing() modifier", "Vulnerability Information": "The call to declareInsolvent() would revert when contract status reaches liquidation point after repayment of credit position 1."}
2. {"Vulnerability Type": "Functionality", "Vulnerability Location": "MutualConsent contract", "Repair Method": "Add a function to revoke consent for a function call, make consent valid only for a certain amount of time, or invalidate existing consents for a function when function is called with different arguments", "Vulnerability Information": "Mutual consent cannot be revoked and stays valid forever."}
3. {"Vulnerability Type": "Functionality", "Vulnerability Location": "SpigotedLine.useAndRepay function", "Repair Method": "Assert that amount is less or equal than credit.principal + credit.interestAccrued", "Vulnerability Information": "Repaying a line of credit with a higher than necessary claimed revenue amount will force the borrower into liquidation."}

{"Vulnerability Type": "Borrower can close a credit without repaying debt", "Vulnerability Location": "LineOfCredit.sol close() function", "Repair Method": "Consider ensuring that a credit with the user-supplied ID exists before closing it", "Vulnerability Information": "A borrower can close a credit without repaying the debt to the lender. The lender will be left with a bad debt and the borrower will keep the borrowed amount and the collateral."}

{"Vulnerability Type": "Lender can reject closing a position", "Vulnerability Location": "LineOfCredit.sol _close() function", "Repair Method": "Consider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly", "Vulnerability Information": "If the used credit token is native ETH, the lender can reject the closing of the credit by reverting the token transfer. This prevents the borrower from closing the credit line and has several consequences."}

