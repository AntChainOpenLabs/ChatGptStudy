1. {"Vulnerability Type": "Fake ERC1155 token creation", "Vulnerability Location": "NameWrapper.sol#L820-L821, NameWrapper.sol#L524, NameWrapper.sol#L572", "Repair Method": "Add nonReentrant modifiers with ReentrancyGuard implementation from openzeppelin or fix the individual re-entrancy issue by saving ERC1155 data and requiring it to match the data after transfer", "Vulnerability Information": "It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper due to re-entrancy possibility in NameWrapper._transferAndBurnFuses."}
2. {"Vulnerability Type": "Non-compliance with ERC1155 standard", "Vulnerability Location": "ERC1155Fuse.sol#L274-L284", "Repair Method": "Revert even if the 'to' address already owns the token", "Vulnerability Information": "ERC1155Fuse: _transfer does not revert when sent to the old owner violating the EIP-1155 standard."}

1. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "ETHRegistrarController.sol, BaseRegistrarImplementation.sol, NameWrapper.sol", "Repair Method": "Update the code to check whether the node is already wrapped before updating the preimage DB", "Vulnerability Information": "Users can create extra ENS records at no cost by exploiting the functionCall in the _setRecords function. The preimage DB (i.e., NameWrapper.names) can be maliciously manipulated/corrupted."}
2. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "NameWrapper.sol", "Repair Method": "When wrapping node X, check whether NameWrapper.names[X] is empty directly, and update the preimage DB if it is empty", "Vulnerability Information": "The preimage DB (i.e., NameWrapper.names) can be maliciously manipulated/corrupted."}

1. {"Vulnerability Type": "PARENT_CANNOT_CONTROL bypass", "Vulnerability Location": "NameWrapper.sol#L356, NameWrapper.sol#L295, ENSRegistry.sol#L74", "Repair Method": "auto-burn CANNOT_UNWRAP or leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping", "Vulnerability Information": "The PARENT_CANNOT_CONTROL fuse can be bypassed by maliciously unwrapping parent node."}
2. {"Vulnerability Type": "DNSSEC signature verification", "Vulnerability Location": "DNSSECImpl.sol#L186-L190", "Repair Method": "Check label by label instead of comparing the entire name", "Vulnerability Information": "DNSSECImpl.verifySignature compares strings incorrectly, allowing malicious zones to forge DNSSEC trust chain."}
3. {"Vulnerability Type": "expiry violation", "Vulnerability Location": "NameWrapper.sol#L504, NameWrapper.sol#L356", "Repair Method": "auto-burn CANNOT_UNWRAP or force the parent to have CANNOT_UNWRAP burnt if they want to set expiries on a child via setSubnodeOwner / setSubnodeRecord / setChildFuses", "Vulnerability Information": "The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy."}
4. {"Vulnerability Type": "subdomain renew", "Vulnerability Location": "ETHRegistrarController.sol#L201, NameWrapper.sol#L271", "Repair Method": "Renew using Namewrapper's renew contract", "Vulnerability Information": "Renew of 2nd level domain is not done properly."}

{"Vulnerability Type": "use of transferFrom instead of safeTransferFrom", "Vulnerability Location": "function unwrapETH2LD(bytes32 labelhash, address newRegistrant, address newController) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash))", "Repair Method": "Use of safeTransferFrom instead of transferFrom", "Vulnerability Information": "The use of transferFrom instead of safeTransferFrom to transfer ERC721 token can result in locking up the token in an unprepared contract or rejection of ERC-721 safeTransfers."}

{"Vulnerability Type": "over-extended permissioning", "Vulnerability Location": "function wrapETH2LD(bytes32 labelhash, address to) public override", "Repair Method": "Limit the approval to the tokens managed by the wrapper contract and not extend to unwrapped domains", "Vulnerability Information": "The current permissioning for wrapETH2LD allows msg.senders who are not owner to call it if they are EITHER approved for all on the ERC721 registrar or approved on the wrapper, which is an over-extension of approval."}

{"Vulnerability Type": "wrong equals logic", "Vulnerability Location": "function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool)", "Repair Method": "Change the equals function to use '==' instead of '='", "Vulnerability Information": "The equals function with offset might return true when equals without offset returns false, which can lead to unexpected behavior."}

{"Vulnerability Type": "transfer() depends on gas consts", "Vulnerability Location": "function transfer(address payable recipient, uint256 amount) public override", "Repair Method": "Use of .call instead of .transfer or .send method", "Vulnerability Information": "The transfer() function forwards only 2300 gas, which may not be enough in the future if the recipient is a contract and gas costs change, leading to the breaking of existing contracts functionality."}

1. {"Vulnerability Type": "Incorrect logic", "Vulnerability Location": "NameWrapper.sol#L955-L961", "Repair Method": "Burning any fuse (including `PARENT_CANNOT_CONTROL`) must require `CANNOT_UNWRAP` fuse to be burned", "Vulnerability Information": "There is a general incorrect logic of allowing to burn only `PARENT_CANNOT_CONTROL` fuse without burning `CANNOT_UNWRAP` fuse."}
2. {"Vulnerability Type": "Incorrect implementation", "Vulnerability Location": "RRUtils.sol#L266-L268", "Repair Method": "Use the naive implementation instead", "Vulnerability Information": "Comparing serial numbers should follow RFC1982 due to the possibility of numbers wrapping around. `RRUtils.serialNumberGte` tried to follow the RFC but failed to do so, leading to incorrect results in comparison."}
3. {"Vulnerability Type": "Incorrect condition", "Vulnerability Location": "BytesUtils.sol#L66-L70", "Repair Method": "Mask calculation formula should be corrected", "Vulnerability Information": "Due to incorrect condition in `ByteUtil.compare` function, irrelevant characters are masked out only for strings shorter than `32` characters."}
4. {"Vulnerability Type": "Failure to check input validity", "Vulnerability Location": "BytesUtils.sol#L44-L51", "Repair Method": "Check whether the `offset`, `len` are within the length of `self`, as well as for the `other`", "Vulnerability Information": "Compare will return false answer without reverting when the inputs are not valid."}

