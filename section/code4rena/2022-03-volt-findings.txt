{"Vulnerability Type": "address desync", "Vulnerability Location": "Core.sol#L27, CoreRef.sol#L22, CoreRef.sol#L199", "Repair Method": "Dynamically fetch vcon from Core whenever CoreRef uses it, and avoid storing a static copy locally or expose a public API to update _vcon in CoreRef", "Vulnerability Information": "vcon address is allowed to be updated by GOVERNOR in Core, however, this change will not be reflected in CoreRef._vcon. Moreover, since CoreRef._vcon cannot be updated due to contract design, it is also impossible to fix this manually."}

{"Vulnerability Type": "assumption", "Vulnerability Location": "OracleRef.sol#L104", "Repair Method": "Assume that both oracles will use the same scaling factor and thus we will not need a second value for the backup oracle", "Vulnerability Information": "OracleRef assumes that the backup oracle uses the same normalizer as the main oracle. This generally isn't the case as it could be a completely different oracle, not even operated by Chainlink."}

{"Vulnerability Type": "division by zero", "Vulnerability Location": "Deviation.sol#L23", "Repair Method": "Add protection to check if a is 0", "Vulnerability Information": "Division by 0 can lead to accidentally revert."}

{"Vulnerability Type": "insolvency", "Vulnerability Location": "NonCustodialPSM.sol#L236-L248", "Repair Method": "Provide a way to directly inject funds from a separately held stability fund in addition to pcvDeposit, limit the redeem amount to total user's share of the pcvDeposit and its stability fund part", "Vulnerability Information": "NonCustodialPSM can become insolvent as CPI index rises. The contract can end up in the situation when no redeem be possible, i.e. NonCustodialPSM can become insolvent."}

1. {"Vulnerability Type": "Oracle price does not compound", "Vulnerability Location": "ScalingPriceOracle.sol#L136", "Repair Method": "Update the oraclePrice in requestCPIData() instead of fulfill. Cover the scenario of multi-month accumulation in tests.", "Vulnerability Information": "The oracle does not correctly compound the monthly APRs it resets on fulfill. The oraclePrice storage variable is only set in _updateCPIData as part of the oracle fulfill callback. It always resets to 1.0 after every fulfill instead of compounding it."}
2. {"Vulnerability Type": "Updating rate limit for addresses restores their entire buffer amount", "Vulnerability Location": "MultiRateLimited.sol#L280", "Repair Method": "Keep the old buffer value, capped by the new bufferCap.", "Vulnerability Information": "When the bufferCap is updated for an address in _updateAddress, the address's allowed buffer (bufferStored) is replenished to the entire bufferCap. The address could frontrun the updateAddress call and spend their entire buffer, then the buffer is replenished and they can spend their entire buffer a second time."}
3. {"Vulnerability Type": "Setting new buffer does not reduce current buffer to cap", "Vulnerability Location": "RateLimited.sol#L142", "Repair Method": "Update the buffer after setting the new cap.", "Vulnerability Information": "The RateLimited.setBufferCap function first updates the buffer and then sets the new cap, but does not apply the new cap to the updated buffer. The updated buffer value can be larger than the new buffer cap which should never be the case."}

