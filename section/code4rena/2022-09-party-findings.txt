{"Vulnerability Type": "Fund Theft", "Vulnerability Location": "BuyCrowdfund and CollectionBuyCrowdfund contracts", "Repair Method": "Disable the option to have unlimited maximumPrice for BuyCrowdfund and CollectionBuyCrowdfund contracts", "Vulnerability Information": "An attacker can list an NFT they own and inflate to zero all users' contributions, keeping the NFT and all the money."}

{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "TokenDistributor.sol", "Repair Method": "Do not allow reentrancy in these functions", "Vulnerability Information": "ERC777 tokensToSend hook can be exploited to drain contract."}

{"Vulnerability Type": "Collision Attack", "Vulnerability Location": "Crowdfund.sol and TokenDistributor.sol", "Repair Method": "Use the standard, 32-bytes, output of keccak256()", "Vulnerability Information": "Only part of keccak256() is used as hash, making it susceptible to collision attacks."}

{"Vulnerability Type": "Majority Attack", "Vulnerability Location": "ProposalExecutionEngine.sol, FractionalizeProposal.sol", "Repair Method": "Enforce a minimum cooldown between proposals. A specific fix here would be to call `distribute()` at the end of FractionalizeProposal so that there is no window to steal the funds.", "Vulnerability Information": "A majority attack can steal precious NFT from the party by crafting and chaining two proposals."}

{"Vulnerability Type": "Majority Attack", "Vulnerability Location": "BuyCrowdfund / CollectionBuyCrowdfund", "Repair Method": "Add a Crowdfund property called minimumPrice, which will be visible to all. `Buy()` function should not accept NFT price < minimumPrice.", "Vulnerability Information": "Early contributor can always become majority of crowdfund leading to rugging risks."}

{"Vulnerability Type": "DOS Attack", "Vulnerability Location": "Crowdfund.sol, BuyCrowdfundBase.sol", "Repair Method": "Permission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper. Cap the callValue (and therefore final price) to `totalContributions`.", "Vulnerability Information": "Attacker can DOS private party by donating ETH then calling buy."}

{"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "AuctionCrowdfund contract", "Repair Method": "Check if the NFT was acquired for free by verifying that the contract balance is equal to totalContributions before determining whether the NFT was gifted to the contract or not", "Vulnerability Information": "If the contract was bid on before the NFT was gifted to the contract, lastBid will not be totalContributions"} 

{"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "Crowdfund contract", "Repair Method": "Disallow an initial contribution when opts.initialContributor is not set", "Vulnerability Information": "Possibility to burn all ETH in Crowdfund under some circumstances"}

{"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "AuctionCrowdfund contract", "Repair Method": "Remove the line `lastBid_ = totalContributions;` and let it be the last bid amount which crowdfund users actually bided with", "Vulnerability Information": "NFT Owner can stuck Crowdfund user funds"}

{"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "AuctionCrowdfund's bid() function", "Repair Method": "Introduce a new option variable to AuctionCrowdfunds called speedBump. Inside the bid() function, calculate seconds since last bid, multiplied by the price change factor. This product must be smaller than the chosen speedBump. Using this scheme, the protocol would have resistance to sudden bid spikes. Optionally, allow a majority funder to override the speed bump.", "Vulnerability Information": "An attacker can force AuctionCrowdfunds to bid their entire contribution up to maxBid."}

{"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol", "Repair Method": "Block calls to opensea.validate() in Arbitrary call proposals. When a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc.", "Vulnerability Information": "Safeguards can be bypassed by cancelling in-progress proposal allowing the majority to steal NFT."}

{"Vulnerability Type": "Smart Contract Vulnerability", "Vulnerability Location": "transferEth function", "Repair Method": "Use WETH to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract. Escrow the ETH refund and/or the governance NFT to be claimed by the contributor later (possibly to a different address) if either transfer fails.", "Vulnerability Information": "Calling transferEth function can revert if receiver input corresponds to a contract that is unable to receive ETH through its receive or fallback function."}

{"Vulnerability Type": "Majority attack", "Vulnerability Location": "ListOnOpenseaProposal contract", "Repair Method": "Pass a revertOnFail flag to `_settleZoraAuction` and handle it differently for each proposal type", "Vulnerability Information": "A majority attack can easily bypass Zora auction stage and steal the NFT from the party."}

{"Vulnerability Type": "Rounding error", "Vulnerability Location": "Crowdfund.sol and PartyGovernance.sol contracts", "Repair Method": "Ensure that the individual votingPower sum to the total contribution", "Vulnerability Information": "Possible that unanimous votes is unachievable"}

{"Vulnerability Type": "Value leakage", "Vulnerability Location": "ArbitraryCallsProposal contract", "Repair Method": "Refund the remaining ethAvailable back to the user at the end of `_executeArbitraryCalls` function", "Vulnerability Information": "Excess eth is not refunded"}

{"Vulnerability Type": "Double voting", "Vulnerability Location": "PartyGovernanceNFT contract", "Repair Method": "Query the voting power at `values.proposedTime 1`", "Vulnerability Information": "Can vote multiple times by transferring NFT in same block as proposal"}

1. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "Crowdfund.sol burn() function, PartyGovernanceNFT.sol mint() and _adjustVotingPower() functions", "Repair Method": "Add a check to see if the delegate is already set before resetting it in the mint() function or track the most recent request via contribute()/delegateVotingPower() calls timestamps. ", "Vulnerability Information": "Previously nominated delegate can reset the delegation."}
2. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "AuctionCrowdfund.sol _buy() function", "Repair Method": "Cap the callValue to maximumPrice in the _buy() function.", "Vulnerability Information": "The settledPrice maybe exceed maximumPrice."}
3. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "AuctionCrowdfund.sol _buy() function", "Repair Method": "Restrict who can call the bid() function to host-only in some crowdfunds.", "Vulnerability Information": "Maximum bid will always be used in Auction."}

