{"Vulnerability Type": "Handling of ERC20 tokens", "Vulnerability Location": "Function purchase in the codebase", "Repair Method": "Use SafeERC20 library to handle token transfers or consider checking the actual balances transferred", "Vulnerability Information": "The current version of the codebase does not handle special cases of tokens, e.g. deflationary, rebasing, or those that return true/false on success."}

{"Vulnerability Type": "Incorrect implementation", "Vulnerability Location": "MixinTransfer.sol#transferFrom function", "Repair Method": "Reset the key manager regardless of the status of the recipient's key", "Vulnerability Information": "The key manager is not being reset when transferring the key, allowing attackers to keep the role of key manager after the transfer."}

{"Vulnerability Type": "Arbitrage opportunity", "Vulnerability Location": "Unlock contract", "Repair Method": "Use the average of multiple oracle sources so that the price of UDT tokens reacts faster or distribute UDT tokens based on the duration of key ownership", "Vulnerability Information": "It is possible to purchase many keys across many locks for the UDT token that is distributed to the referrer and sell them on some other exchanges where the price of UDT is higher."}

{"Vulnerability Type": "Frontrunning", "Vulnerability Location": "MixinRefunds contract", "Repair Method": "Apply a penalty for the difference in price before changing the lock price or store the amount paid for the latest key", "Vulnerability Information": "A malicious user is able to withdraw all payments that were paid to a lock owner if the owner increases the keyPrice."}

{"Vulnerability Type": "Potential economic attack", "Vulnerability Location": "`Unlock.sol#recordKeyPurchase()`", "Repair Method": "Consider setting a global daily upper limit of total UDT grants to referrers, plus, an upper limit for UDT minted per purchase.", "Vulnerability Information": "The `Unlock.sol#recordKeyPurchase()` function can be exploited by creating a lock and calling `purchase()` many times to mint UDT, or by using a special gas saving token to get a gas refund on `transfer`. This can lead to potential economic attacks on UDT grants to the referrer."}

{"Vulnerability Type": "Refund mechanism issue", "Vulnerability Location": "`MixinRefunds.sol#L144:#L152`", "Repair Method": "Save the amount the user paid, and refund according to that, or have a kind of a price snapshot/version mechanism.", "Vulnerability Information": "The refund mechanism doesn't take into account that key price can change, and calculates refund according to current key price, not price actually paid. A user refunding can get less (or more) funds than deserved."}

{"Vulnerability Type": "Missing scaling factor", "Vulnerability Location": "`Unlock.recordKeyPurchase` function", "Repair Method": "Consider adding a scaling factor to the term `2 * valueInETH / grossNetworkProduct` and divide by it at the end of the computation again.", "Vulnerability Information": "The `Unlock.recordKeyPurchase` function computes the `maxTokens` curve without a scaling factor, which might not be computed as intended and lead to being able to receive more token rewards than intended."}

{"Vulnerability Type": "Value extraction by miners", "Vulnerability Location": "`UnlockProtocol`", "Repair Method": "Use an oracle service to determine the average gas price and ensure it is within some normal bounds that has not been subjected to arbitrary value manipulation.", "Vulnerability Information": "MEV miners can mint larger than expected UDT total supply by submitting their own transactions or cooperating with a malicious user, reimbursing a portion (or all) of the `tx.gasprice` used. This can lead to value extractions outside of the pool."}

1. {"Vulnerability Type": "Wrong design/implementation", "Vulnerability Location": "`freeTrial`", "Repair Method": "Disable `cancelAndRefund()` for users who transferred time to another user", "Vulnerability Information": "The current design/implementation of `freeTrial` allows users to get full refund before the `freeTrial` ends. Plus, a user can transfer partial of their time to another user using `shareKey`. This makes it possible for the attacker to steal from the protocol by transferring `freeTrial` time from multiple addresses to one address and adding up to `expirationDuration` and call refund to steal from the protocol."}
2. {"Vulnerability Type": "Insufficient access control", "Vulnerability Location": "`PublicLock.initialize()`", "Repair Method": "Implement valid access control on the `PublicLock` contract to ensure only the relevant deployer can `initialize()`", "Vulnerability Information": "The `Unlock.sol` contract uses `setLocktemplate()` to initialize the implementation contract for the `PublicLock` proxy. `PublicLock.initialize()` does not have any relevant access control and does not prevent arbitrary users from initializing. This means that a malicious user could front run the `setLocktemplate()` forcing the deployer of `PublicLock`'s implementation to redeploy."}
3. {"Vulnerability Type": "Key transfer issue", "Vulnerability Location": "`transferFrom`", "Repair Method": "Add a require statement in the beginning of `transferFrom`: `require(_from != _recipient, 'TRANSFER_TO_SELF');`", "Vulnerability Information": "If calling `transferFrom` with `_from == _recipient`, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0). A key manager or approved might accidentally destroy user's token."}
4. {"Vulnerability Type": "Key generation issue", "Vulnerability Location": "`MixinPurchase:shareKey`", "Repair Method": "Rethink the whole `shareKey` function", "Vulnerability Information": "`shareKey` function allows a user to share some time with another user that doesn't already has/had a key and this generates a new key. This even allows the user to generate more keys than `_maxNumberOf

1. {"Vulnerability Type": "Infinite free trial", "Vulnerability Location": "purchase(), cancelAndRefund()", "Repair Method": "Add a mapping(address = uint256) freeTrialEnds and make sure each address can only get 1 freeTrial.", "Vulnerability Information": "Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends."}
2. {"Vulnerability Type": "Missing maxNumberOfKeys checks", "Vulnerability Location": "shareKey(), grantKey(), _assignNewTokenId()", "Repair Method": "Add a check to _assignNewTokenId that will revert if we need to record a new key and maxNumberOfKeys has been reached.", "Vulnerability Information": "More keys can be minted than maxNumberOfKeys since shareKey and grantKey do not check if the lock is sold out."}
3. {"Vulnerability Type": "Inaccurate fees computation", "Vulnerability Location": "MixinTransfer.shareKey()", "Repair Method": "Change the first if branch condition to timePlusFee <= timeRemaining. In the else branch, compute the time without fee as time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN).", "Vulnerability Information": "The shareKey function computes the fee inaccurately, resulting in the receiver receiving less time than they are owed."}
4. {"Vulnerability Type": "Approvals not cleared after key transfer", "Vulnerability Location": "transferFrom(), _setKeyManagerOf()", "Repair Method": "The _setKeyManagerOf function should not handle clearing approvals of single-token approvals (approved) as these are two separate approval types. The transferFrom function should always call _clearApproval in the (previousExpiration <= block.timestamp) case.", "Vulnerability Information": "It's possible to sell someone a key and then claim it back as the approvals are not always cleared."}

