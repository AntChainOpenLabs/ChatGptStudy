1. {"Vulnerability Type": "High Severity", "Vulnerability Location": "Vault.sol contract", "Repair Method": "Add a check at the beginning of the `utilize()` function to ensure that the `controller` state variable is not set to the zero address", "Vulnerability Information": "Tokens can be burned with no access control"}
2. {"Vulnerability Type": "High Severity", "Vulnerability Location": "PoolTemplate unlock function", "Repair Method": "Change `insurances[_id].status == false;` to `insurances[_id].status = false;`", "Vulnerability Information": "Typo in PoolTemplate unlock function results in user being able to unlock multiple times"}
3. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "PoolTemplate", "Repair Method": "Add a check in `applyCover` that `_incidentTimestamp` is less than the current date and the `span` argument is greater than 0 in the `insure` method", "Vulnerability Information": "Signature replay"}
4. {"Vulnerability Type": "High Severity", "Vulnerability Location": "Vault.sol contract", "Repair Method": "Consider adding constrains (eg. timelock) to `Registry#supportMarket()`. Consdier adding constrains (upper bound for each pool, and index pool for example) to `Vault#borrowValue()`", "Vulnerability Information": "A malicious/compromised Registry or Factory admin can drain all the funds from the Vault contracts"}

1. {"Vulnerability Type": "Wrong design/implementation of permission control", "Vulnerability Location": "Vault.sol", "Repair Method": "Change the design/implementation to make sure that the allowances approved by the users can only be used by themselves", "Vulnerability Information": "Allows malicious/compromised Registry or Factory admin to steal funds from users' wallet balances"}

2. {"Vulnerability Type": "Initial pool deposit can be stolen", "Vulnerability Location": "PoolTemplate.sol", "Repair Method": "Set the initial depositor to `Factory.createMarket`'s `msg.sender`, instead of being able to pick a whitelisted one as `_references[4]`", "Vulnerability Information": "Initial pool deposit can be stolen"}

3. {"Vulnerability Type": "Precision loss while converting between `the amount of shares` and `the amount of underlying tokens`", "Vulnerability Location": "IndexTemplate.sol", "Repair Method": "Change the code to use `vault.underlyingValue(address(this))` instead of `_value + _cds` to compensate for the precision loss", "Vulnerability Information": "IndexTemplate.sol#compensate() will most certainly fail"}

1. {"Vulnerability Type": "Malicious token transfer", "Vulnerability Location": "Factory.createMarket(), PoolTemplate.initialize(), Vault.withdrawRedundant(), Vault.setController()", "Repair Method": "Disallow setting a new controller if a controller is already existing, or put a timelock on the function. Parse a `_creator` address to `PoolTemplate.sol` which will act as the depositor and be set to `msg.sender` in `Factory.createMarket()`", "Vulnerability Information": "Malicious actors can transfer tokens from unsuspecting users or drain funds from the Vault contract."}
2. {"Vulnerability Type": "Infinite insurance period", "Vulnerability Location": "PoolTemplate.applyCover()", "Repair Method": "Require that the market be in a `Trading` state to allow another `applyCover` call.", "Vulnerability Information": "The owner could potentially extend the insurance period indefinitely in the `applyCover` function without ever allowing the market to resume."}
3. {"Vulnerability Type": "Unsupported tokens with fee on transfer", "Vulnerability Location": "Vault.addValue()", "Repair Method": "Compare before and after balance to get the actual transferred amount.", "Vulnerability Information": "ERC20 tokens that charge fee for every `transfer()` / `transferFrom()` are not supported."}

1. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "Vault.sol - repayDebt()", "Repair Method": "Make repayDebt() accept an amount up-to and including the value of the debt for the given borrower", "Vulnerability Information": "Any user can pay the debt for any borrower in `Vault.sol`, by using `repayDebt()`. This function allows anyone to repay any amount of borrowed value, up-to and including the `totalDebt` value; it works by setting the `debts[_target]` to zero, and decreasing `totalDebt` by the given amount, up to zero. However, all debts of the other borrowers are left untouched. If a malicious (but generous) user were to repay the debt for all the borrowers, markets functionality regarding borrowing would be DOSed: the vault would try to decrease the debt of the market, successfully, but would fail to decrease `totalDebt` as it would result in an underflow."}
2. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "IndexTemplate - compensate()", "Repair Method": "Change the implementation to redeem the premium (withdrawCredit?) to cover the whole amount", "Vulnerability Information": "In IndexTemplate, function compensate, When `_amount < _value`, and `<= totalLiquidity()`, the value of `_compensated` is not set, so it gets a default value of 0. But nevertheless, in both cases, it calls `vault.offsetDebt`, even when the`_compensated` is 0 (no else block)."}
3. {"Vulnerability Type": "High Severity", "Vulnerability Location": "PoolTemplate.sol - first deposit to a pool", "Repair Method": "Implement a check to ensure that the first deposit is not too small to mint liquidity for the next liquidity providers", "Vulnerability Information": "If there is no liquidity in the pool, the first deposit determines the total liquidity, if the amount is too small the minted liquidity for the next liquidity providers will round down to zero. An attacker can steal all money from liquidity providers."}
4. {"Vulnerability Type": "High Severity", "Vulnerability Location": "IndexTemplate.sol - resume()", "Repair Method": "Change the implementation to check if the pool is in PayingOut mode before unlocking it", "

1. {"Vulnerability Type": "Unbounded iteration", "Vulnerability Location": "PoolTemplate.sol line 703", "Repair Method": "Keep the array size small", "Vulnerability Information": "The transactions could fail if the array get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality."}
2. {"Vulnerability Type": "Withdrawal without obligation to withdraw", "Vulnerability Location": "PoolTemplate.sol line 279", "Repair Method": "Extend the lockup period at least by a factor of 2 or force underwriter to withdraw after lockup period", "Vulnerability Information": "There are no obligations to withdraw after the lockup period and the capital will keep earning premium during lockup. A strategy for underwriter is to keep requesting withdrawal every `lockup period` to keep their average lockup to `lockup period/2`."}
3. {"Vulnerability Type": "Admin can withdraw credit after applyCover", "Vulnerability Location": "PoolTemplate.sol line 416-421", "Repair Method": "Lock the credit control when pool is in payout status", "Vulnerability Information": "When an incident is reported for a certain pool, the index pool can still `withdrawCredit()` from the pool, which allows the index pool to escape from the responsibility for the risks of invested pools. Making the LPs of the pool take an unfair share of the responsibility."}

