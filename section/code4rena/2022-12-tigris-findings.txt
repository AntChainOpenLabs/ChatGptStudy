1. {"Vulnerability Type": "Arbitrage", "Vulnerability Location": "StableVault.sol", "Repair Method": "Utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their \"neutral\" USD price rather than their subjective on-chain price or equality assumption.", "Vulnerability Information": "The `StableVault` contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices, the balance sheet of the contract can be arbitraged (especially by flash-loans) to swap an undesirable asset for a more desirable asset acquiring an arbitrage in the price by selling the traded asset."}
2. {"Vulnerability Type": "Overflow", "Vulnerability Location": "TradingLibrary.pnl()", "Repair Method": "Remove the `unchecked` block.", "Vulnerability Information": "An overflow in `TradingLibrary.pnl()` enables all funds from the vault contracts to be drained given a certain fee configuration is present."}

{"Vulnerability Type": "Bypassing maximum PnL check", "Vulnerability Location": "addToPosition() function", "Repair Method": "Add a check for addToPosition() function, revert if PnL = 500%, enforce users to close the order to take a limited profit.", "Vulnerability Information": "An attacker can exploit the implementation missing to check the maximum PnL limitation while addToPosition() to get more profit than expected."}

{"Vulnerability Type": "Bypass delay security check", "Vulnerability Location": "_checkDelay() function", "Repair Method": "Implement additional security measures to prevent profitable opening and closing in the same transaction with two different prices in the 'valid signature pool'", "Vulnerability Information": "The protection provided by the current implementation is not enough, an attacker can long with low price and short with high price at the same transaction but two orders to lock profit and take risk-free funds."}

1. {"Vulnerability Type": "Centralization risks", "Vulnerability Location": "Trading.sol, StableVault.sol, StableToken.sol, PairsContract.sol", "Repair Method": "Add functionality to withdraw funds at the last given price in case no signed data is given for a certain period", "Vulnerability Information": "The owner can freeze withdraws and use timelock to steal all funds. The project heavily relies on nodes/oracles, which are EOAs that sign the current price. The owner has a few ways to drain all funds."}
2. {"Vulnerability Type": "Token decimal underflow", "Vulnerability Location": "Trading.sol", "Repair Method": "Update calculations in the contract to account for tokens with decimals higher than 18", "Vulnerability Information": "A deposit or withdrawal of tokens with decimals higher than 18 will always revert."}

{"Vulnerability Type": "Race Condition", "Vulnerability Location": "Trading.sol", "Repair Method": "Keep a record if allowance was already set on an address and create an external function that can be called by the owner to approve the a token address", "Vulnerability Information": "Traders will not be able to initiate a market order, add margin, add to position, or initiate limit order if USDT is set as the margin asset and protocol is deployed on Ethereum due to the `_handleDeposit` function calling the `USDT` margin asset `approve` function with `type(uint).max`, causing the transaction to revert from the second time `approve` is called."}

{"Vulnerability Type": "Accounting", "Vulnerability Location": "Lock.sol", "Repair Method": "Add `totalLocked[_asset] += amount` to the `Lock.extendLock` function", "Vulnerability Information": "Assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow, resulting in the amount of assets deposited using `Lock.extendLock` being lost."}

{"Vulnerability Type": "Incorrect computation", "Vulnerability Location": "Trading.addToPosition function", "Repair Method": "Call the _handleDeposit function with the correct margin value that the user has input on and is supposed to pay, instead of using _addMargin _fee as the third parameter to _handleDeposit function.", "Vulnerability Information": "When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset."}

{"Vulnerability Type": "Minting multiple NFTs with the same token id", "Vulnerability Location": "GovNFT contract", "Repair Method": "Track the consumed messages, and add a consumed flag whenever the function lzReceive is called, because it will either immediately mint the NFT or add it to the failed messages to be minted later.", "Vulnerability Information": "Failure in endpoint can cause minting more than one NFT with the same token id in different chains."}

{"Vulnerability Type": "Reentrancy Attack", "Vulnerability Location": "Position contract's mint() function", "Repair Method": "Follow the check-effect-interaction pattern", "Vulnerability Information": "The mint() function in the Position contract doesn't follow check-effect-interaction pattern and it's possible to perform reentrancy attack during mint() function which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value."}

{"Vulnerability Type": "Transfer restriction bypass", "Vulnerability Location": "function _transfer(address from, address to, uint256 _id) internal override", "Repair Method": "Replace require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\"); with require(bond.expireEpoch <= block.timestamp/DAY, \"Transfer after expired not allowed\");", "Vulnerability Information": "BondNFTs can revert when transferred if epoch[tigAsset] is not updated to the current day, which can happen if rewards are not distributed in the same day. This can cause BondNFTs listed on open markets to not fulfill orders and BondNFTs deposited as collateral to not release the collateral."}

{"Vulnerability Type": "Incorrect calculation of new price while adding position", "Vulnerability Location": "addToPosition function", "Repair Method": "Use the correct formula for calculating PnL payout", "Vulnerability Information": "The vulnerability occurs due to the incorrect calculation of PnL payout while adding a position in the addToPosition function. The expected PnL payout is calculated using an incorrect formula, which can result in incorrect payouts to users."}

1. {"Vulnerability Type": "Inaccurate reward calculation", "Vulnerability Location": "BondNFT.sol#claim()", "Repair Method": "Update all the epochs between bond.expireEpoch-1 and epoch[bond.asset] in accRewardsPerShare[][]", "Vulnerability Information": "In `BondNFT.sol#claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed."}
2. {"Vulnerability Type": "Stale price feed", "Vulnerability Location": "TradingLibrary.sol#verifyPrice()", "Repair Method": "Check for `updatedAt` to not be too far in the past or check `answeredInRound` against the current `roundId` to avoid using a stale price returned by the Chainlink price feed", "Vulnerability Information": "The Chainlink price verification logic in the following `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale."}

{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "BondNFT.claim() function", "Repair Method": "Forcing an expired bond to release() and adding a check to claim() function to revert if an expired bond is claimed", "Vulnerability Information": "A malicious user can exploit this vulnerability to steal all assets in BondNFT contract by repeatedly calling claim() function of an expired bond, which updates accRewardsPerShare and increases pending rewards of all other users."}

1. {"Vulnerability Type": "Approval vulnerability", "Vulnerability Location": "function claimGovFees() public", "Repair Method": "Add an `approve(0)` before approving", "Vulnerability Information": "Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved."}
2. {"Vulnerability Type": "Bypassing limit vulnerability", "Vulnerability Location": "_closePosition() function in Trading.sol", "Repair Method": "Check the `maxWinPercent` between the partial payout and partial margin", "Vulnerability Information": "Users can bypass the `maxWinPercent` limit using a partial closing."}
3. {"Vulnerability Type": "Referral vulnerability", "Vulnerability Location": "createReferralCode() function in Referrals.sol", "Repair Method": "Prevent someone from setting 0x0 hash for their referral code", "Vulnerability Information": "One can become referral of hash 0x0 and because all users default referral hash is 0x0 so he would become all users referral by default and earn a lot of fees while users didn't approve it."}

1. {"Vulnerability Type": "assets stuck in contract", "Vulnerability Location": "Lock.sol: claimGovFees function", "Repair Method": "Allow the owner to rescue stuck tokens from the Lock contract", "Vulnerability Information": "When calling `Lock.claimGovFees`, assets that are set to be not allowed or assets that don't have any shares yet in the `BondNFT` contract will cause a silent failure in `BondNFT.distribute`. The funds from the `GovNFT` contract will get transferred into the `Lock` contract and then will be stuck there. They cannot be recovered."}
2. {"Vulnerability Type": "wrong position value", "Vulnerability Location": "executeLimitOrder() function", "Repair Method": "Correct the calculation to use margin after fees", "Vulnerability Information": "At `executeLimitOrder()` the position size that's added is wrongly calculated it uses margin before fees, while the actual position is created after subtracting fees. The OpenInterest would register wrong values (11% diff in the case of PoC), which will distort the balance between long and short positions (the whole point of the OpenInterest is to balance them to be about equal)." }

{"Vulnerability Type": "Flawed reward distribution", "Vulnerability Location": "BondNFT contract, unreleased locks", "Repair Method": "Update the totalShares value for active bonds only", "Vulnerability Information": "Unreleased locks cause other existing bonds to not receive the full amount of tokens, resulting in bond owners receiving less rewards than they should. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. This causes a loss of funds for every bond holder."}

1. {"Vulnerability Type": "Incorrect calculation", "Vulnerability Location": "addToPosition() function of Trading.sol", "Repair Method": "Replace the formula in line 734 with the corrected formula", "Vulnerability Information": "The formula used for calculating `_newPrice` in `addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function."}
2. {"Vulnerability Type": "Incorrect fee calculation", "Vulnerability Location": "Line 734 of Trading.sol", "Repair Method": "Replace the formula in line 734 with the corrected formula", "Vulnerability Information": "Formula for `fee paid` in Line 734 is incorrect leading to incorrect margin calculations."}

{"Vulnerability Type": "Riskless trades due to delay check", "Vulnerability Location": "Trading.limitClose() function", "Repair Method": "Modify delay checking in limitClose() function to also consider whether the position is below the stop-loss", "Vulnerability Information": "The position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking in limitClose() should be modified to also consider whether the position is below the stop-loss."}

1. {"Vulnerability Type": "Approved operators cannot call certain functions", "Vulnerability Location": "Trading.initiateCloseOrder", "Repair Method": "Allow operators of token's owner to call functions on behalf of owner.", "Vulnerability Information": "Functions that accept Position token in Trading are checking that the caller is owner of token using `_checkOwner` function. This function doesn't allow approved operators of token's owner to pass the check. As a result, functions are not possible to call for them on behalf of owner."}
2. {"Vulnerability Type": "Bond lock extension forces user to extend for at least current period", "Vulnerability Location": "BondNFT.extendLock", "Repair Method": "Change the current implementation to allow extending the bond for any period, as long as it respects the minimum bond period.", "Vulnerability Information": "The current implementation forces a user to extend their bonds for at least their current bond period. This means that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created."}
3. {"Vulnerability Type": "safeTransferMany() function doesn't actually use safe transfer", "Vulnerability Location": "GovNFT.safeTransferMany() and BondNFT.safeTransferMany()", "Repair Method": "Call `_safeTransfer()` instead of `_transfer()`.", "Vulnerability Information": "Both `BondNFT` and `GovNFT` have a function named `safeTransferMany()` which its name implies is supposed to safe transfer many tokens at once. However, the function doesn't actually safe transfer. Users might use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but will get their funds stuck in a contract that doesn't support ERC721."}

1. {"Vulnerability Type": "Unused Variable", "Vulnerability Location": "GovNFT: setMaxBridge function", "Repair Method": "Consider applying the maxBridge variable", "Vulnerability Information": "The maxBridge variable is not used to limit the number of GovNFTs crossing chain, even though the setMaxBridge function is provided."}
2. {"Vulnerability Type": "Bot Fee Manipulation", "Vulnerability Location": "Trading: limitClose() function", "Repair Method": "Don't allow updating sl or tp and executing limitClose() at the same block", "Vulnerability Information": "A user can use a proxy contract to update the stop-loss value and then limitClose() the order, taking the bot fees to themselves."}

1. {"Vulnerability Type": "Abuse of stop losses and high leverage", "Vulnerability Location": "function limitClose()", "Repair Method": "Execute take profit and stop loss trades at the current price rather than the price specified by the user", "Vulnerability Information": "User can abuse how stop losses are priced to open high leverage trades with huge upside and very little downside."}
2. {"Vulnerability Type": "Incorrect use of block.number for trade delay", "Vulnerability Location": "function _checkDelay()", "Repair Method": "Measure delay using block.timestamp rather than block.number", "Vulnerability Information": "_checkDelay will not work correctly on Arbitrum allowing users to exploit multiple valid prices."}

{"Vulnerability Type": "Incorrect state variable update", "Vulnerability Location": "BondNFT.distribute() function", "Repair Method": "Update epoch[asset] in distribute() function even when totalShares[_tigAsset] is equal to 0. Only the division by zero and fund transfer should be prevented when totalShare is zero and epoch[asset] index should be updated.", "Vulnerability Information": "When totalShares[_tigAsset] is equal to 0, epoch[asset] won't get updated in distribute() function, leading to wrong values for bond's mint epoch when createLock() is called."}

{"Vulnerability Type": "Lack of Approval", "Vulnerability Location": "Trading._handleOpenFees function", "Repair Method": "Add IStable(_tigAsset).approve(address(gov), type(uint).max) in the _handleOpenFees function", "Vulnerability Information": "Governance NFT holder, whose NFT was minted before Trading._handleOpenFees function is called, can lose deserved rewards after Trading._handleOpenFees function is called due to lack of approval for spending any of the Trading contract's _tigAsset balance."}

1. {"Vulnerability Type": "Calculation Error", "Vulnerability Location": "Trading#initiateMarketOrder", "Repair Method": "Consider referral fees when calculating fees in _handleOpenFees function", "Vulnerability Information": "The _handleOpenFees function does not consider referral fees when calculating fees, leading to the opening of a position greater than expected."}
2. {"Vulnerability Type": "Validation Error", "Vulnerability Location": "Trading.executeLimitOrder", "Repair Method": "Validate StopLoss/TakeProfit for the new price in Trading.executeLimitOrder", "Vulnerability Information": "StopLoss/TakeProfit is not validated again for the new price in Trading.executeLimitOrder, leading to unexpected losses for users."}

