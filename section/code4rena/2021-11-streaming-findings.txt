{"Vulnerability Type": "frontrun attack", "Vulnerability Location": "LockeERC20 contract's approve() function", "Repair Method": "Change the approve function to either accept the old amount of allowance and require the current allowance to be equal to that, or change to two different functions that increase and decrease the allowance instead of straight on changing it.", "Vulnerability Information": "A user can steal another user's tokens if he frontrun before he changes the allowance."}

{"Vulnerability Type": "logic issue", "Vulnerability Location": "Streaming contract's recoverTokens() function", "Repair Method": "Set redeemedDepositTokens to be depositTokenAmount in the function creatorClaimSoldTokens, since claiming the sold tokens is like 'redeeming' them in a sense. This would fix the logic issue in recoverTokens.", "Vulnerability Information": "recoverTokens doesn't work when isSale is true."}

{"Vulnerability Type": "token theft", "Vulnerability Location": "Streaming contract's recoverTokens() function", "Repair Method": "Add a special case for recoverTokens when token == depositToken == rewardToken and then the excess should be ERC20(token).balanceOf(address(this)) - (depositTokenAmount + redeemedDepositTokens + rewardTokenAmount + rewardTokenFeeAmount);", "Vulnerability Information": "Tokens can be stolen when depositToken == rewardToken."}

{"Vulnerability Type": "token theft", "Vulnerability Location": "Streaming contract's recoverTokens() function", "Repair Method": "Track the claimed rewards as well, just like the claimed deposits are tracked. Decrease rewardTokenAmount in claimReward because at this point rewardTokenAmount is not used to update the cumulativeRewardPerToken anymore.", "Vulnerability Information": "Reward token not correctly recovered."}

{"Vulnerability Type": "token theft", "Vulnerability Location": "Streaming contract's arbitraryCall() and recoverTokens() functions", "Repair Method": "Add airdrop tokens balance mapping, record what is gathered in arbitraryCall and prohibit their free withdrawal in recoverTokens similarly to incentives[].", "Vulnerability Information": "Any arbitraryCall gathered airdrop can be stolen with recoverTokens."}

1. {"Vulnerability Type": "High Severity", "Vulnerability Location": "Creating rewardTokens without streaming depositTokens", "Repair Method": "Make the line dependable on a positive amount 0 of the tokens", "Vulnerability Information": "Attackers can create loss of funds for (honest) stakers."}
2. {"Vulnerability Type": "High Severity", "Vulnerability Location": "Wrong calculation of excess depositToken allows stream creator to retrieve depositTokenFlashloanFeeAmount", "Repair Method": "Exclude depositTokenFlashloanFeeAmount when calculating excess depositToken", "Vulnerability Information": "Part of users' funds (depositToken) will be transferred to the protocol governance as fees, causing some users unable to withdraw or can only withdraw part of their deposits."}
3. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "arbitraryCall() can get blocked by an attacker", "Repair Method": "Accept the risk but clearly communicate to users that this can happen", "Vulnerability Information": "If the address 'who' is a token that could be send as an incentive by an attacker via createIncentive() then such claim can be made unusable."}
4. {"Vulnerability Type": "High Severity", "Vulnerability Location": "__abdicate() function - 2 Bugs", "Repair Method": "Set emergency_gov and pendingGov to zero address in __abdicate() function", "Vulnerability Information": "The __abdicate() functionality can be used as a backdoor using emergency governor or leaving a pending governor to claim later."}
5. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "This protocol doesn't support all fee on transfer tokens", "Repair Method": "Make it clear for stream creators that the contract only supports fee on transfer tokens if they reduce the fee from the transfer amount", "Vulnerability Information": "Some fee on transfer tokens, do not reduce the fee directly from the transferred amount, but subtracts it from remaining balance of sender."}

1. {"Vulnerability Type": "DOS", "Vulnerability Location": "function exit() public lock updateStream(msg.sender)", "Repair Method": "Do arithmetic operations in two steps or upcast to uint256 and then downcast. Alternatively, find a threshold where it breaks and add a require condition to not allow total stake per user greater than the threshold.", "Vulnerability Information": "The function reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when the user calls `exit` or `withdraw` function it will revert and that user will not be able to withdraw funds permanently."}
2. {"Vulnerability Type": "Storage variable manipulation", "Vulnerability Location": "public uint112 unstreamed;", "Repair Method": "Add the following line to `withdraw` to fix this issue: unstreamed -= amount;", "Vulnerability Information": "`unstreamed` is incremented on calls to `stake`, but it is not being decremented on calls to `withdraw`. As a result, a malicious user could simply stake, immediately withdraw their staked amount, and they will have increased `unstreamed`. They could do this repeatedly or with large amounts to intentionally inflate `unstreamed` to be as large as they want."}
3. {"Vulnerability Type": "Improper implementation of function", "Vulnerability Location": "function arbitraryCall(address who, bytes memory data) public lock externallyGoverned", "Repair Method": "Consider adding a mapping: `isIncentiveToken`, setting `isIncentiveToken[incentiveToken] = true` in `createIncentive()`, and `require(!isIncentiveToken[who], ...)` in `arbitraryCall()`.", "Vulnerability Information": "The `Locke.arbitraryCall()` function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping. However, the token can still be called prior to any user creating an incentive, so it's possible for the `arbitraryCall()` function to be used to set an allowance on an incentive token before the contract has actually received any of the token through `createIncentive()`. In summary: 1. If some possible incentive tokens are known prior to being provided, the `arbitraryCall()` function can be used to pre-approve a token allowance for a malicious recipient. 2. Once a user calls `createIncentive()` and provides one of the pre-approved tokens, the malicious recipient can call `transferFrom` on the provided incentive token and withdraw the tokens."}
4. {"Vulnerability Type": "Improper implementation of function", "Vulnerability Location": "function updateStreamInternal(address who) internal {...", "Repair Method": "Change the code in updateStream() to: if (acctTimeDelta > 0 ) {    // some time has passed since this user last interacted    // update ts not yet streamed    if (ts.tokens > 0)             ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));    ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)}", "Vulnerability Information": "Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0. Now after some time he stakes some tokens again. At the second stake `updateStream()` is called and the following if condition is false because `ts.tokens==0`. Thus `ts.lastUpdate` is not updated and stays at the value from the first withdraw. Now he does a second withdraw. `updateStream()` is called and calculates the updated value of `ts.tokens`. However, it uses `ts.lastUpdate`, which is the time from the first withdraw and not from the second stake. So the value of `ts.token` is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw."}
5. {"Vulnerability Type": "Improper implementation of function", "Vulnerability Location": "function ts.tokens sometimes calculated incorrectly", "Repair Method": "Change the code in updateStream() to: if (acctTimeDelta > 0 ) {    // some time has passed since this user last interacted    // update ts not yet streamed    if (ts.tokens > 0)             ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));    ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)}", "Vulnerability Information": "The issue here is that `ts.tokens` is calculated incorrectly. Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in `ts.tokens` being 0. Now after some time he stakes some tokens

