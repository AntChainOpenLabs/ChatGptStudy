1. {"Vulnerability Type": "Possible lost msg.value", "Vulnerability Location": "depositCollateral function in GeneralVault.sol, LidoVault.sol, and ConvexCurveLPVault.sol", "Repair Method": "Check if msg.value is zero when the asset is ERC20 and check if msg.value is equal to _amount when the asset is ETH", "Vulnerability Information": "In the depositCollateral function call, if the asset is an ERC20 and msg.value is sent, the funds will be lost. In LidoVault, if ETH is sent as the asset and more value than _amount is sent, the excess will be lost."}
2. {"Vulnerability Type": "Hard-coded slippage may freeze user funds during market turbulence", "Vulnerability Location": "GeneralVault.sol and LidoVault.sol", "Repair Method": "Either let users determine the maximum slippage they're willing to take or have a slippage control parameter set by the operator", "Vulnerability Information": "The hardcoded slippage control of 99% in GeneralVault can cause user funds to get locked during market turbulence. The withdrawal of the LidoVault takes a swap from the curve pool, and if the market is down, the vault cannot withdraw at the current market."}
3. {"Vulnerability Type": "ConvexCurveLPVault's _transferYield can become stuck with zero reward transfer", "Vulnerability Location": "_transferYield function in ConvexCurveLPVault.sol", "Repair Method": "Run the transfers in _transferYield only when yieldAmount is positive", "Vulnerability Information": "In the _transferYield function, there are no checks for the amounts to be transferred, and if an arbitrary token that doesn't allow for zero amount transfers is added to the reward list, the reward retrieval can become unavailable. This can cause the processYield call to revert, making reward gathering unavailable until either such token be removed from pool's reward token list or some non-zero reward amount be earned."}

{"Vulnerability Type": "Unintended Behavior", "Vulnerability Location": "LidoVault.sol#L142", "Repair Method": "Return the function after the success check", "Vulnerability Information": "The check for value transfer success is made after the return statement in  _withdrawFromYieldPool  of  LidoVault."}

{"Vulnerability Type": "Denial of Service", "Vulnerability Location": "smart-contracts/YieldManager.sol#L129-L136", "Repair Method": "Include an offset and length as is done in `YieldManager.distributeYield()`.", "Vulnerability Information": "processYield()  and  distributeYield()  may run out of gas and revert due to long list of extra rewards/yields."}

{"Vulnerability Type": "Unintended Behavior", "Vulnerability Location": "smart-contracts/GeneralVault.sol#L121-L124", "Repair Method": "Check `_asset` and use hard coded decimal value (`18`) for native ETH.", "Vulnerability Information": "Withdrawing ETH collateral with max uint256 amount value reverts transaction."}

{"Vulnerability Type": "Unintended Behavior", "Vulnerability Location": "smart-contracts/YieldManager.sol#L129-L134, YieldManager.sol#L160-L161", "Repair Method": "Use flashbots or some other means of submitting the distributeYield call that skips the mempool. A better mitigation could use something like snapshotting who has deposited since the last yield distribution and only give these depositers yield based on the size of their deposits the next time yield is distributed.", "Vulnerability Information": "Yield can be unfairly divided because of MEV/Just-in-time stablecoin deposits."}

{"Vulnerability Type": "Hardcoded Value", "Vulnerability Location": "`YieldManager` contract, `UNISWAP_FEE` variable", "Repair Method": "Hardcode the best Uniswap paths in a mapping and pass it to the swapping library, add the possibility to do swaps through an efficient aggregator like 1Inch or Paraswap", "Vulnerability Information": "The hardcoded `UNISWAP_FEE` reduces the possibilities and leads to non-optimal routes, causing significant losses compared to optimal routing. All swaps using ETH path will use the wrong pool, leading to a significant loss of revenue."}

