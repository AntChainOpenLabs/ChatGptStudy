{"Vulnerability Type": "Funds theft", "Vulnerability Location": "HybridPool contract", "Repair Method": "Consider not using `bento.toAmount` to track the reservers and balances, but use `balanceOf` instead (as done in the other two pools).", "Vulnerability Information": "An attacker can call the `bento.harvest` function during the callback function of a flash swap of the `HybridPool` to reduce the number of input tokens that he has to pay to the pool, as long as there is any unrealized profit in the strategy contract of the underlying asset."}

{"Vulnerability Type": "Rounding errors", "Vulnerability Location": "TridentRouter contract", "Repair Method": "Rounding the final `getAmountOut` division upwards would fix this.", "Vulnerability Information": "Some rare tokens have 0 decimals, and for these tokens, small losses of precision will be amplified by the lack of decimals."}

{"Vulnerability Type": "Back-running vulnerability", "Vulnerability Location": "_depositToBentoBox and _depositFromUserToBentoBox functions in TridentRouter contract", "Repair Method": "Directly push the remaining ETH to the sender to prevent any ETH left in the router.", "Vulnerability Information": "In these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation."}

{"Vulnerability Type": "Use of both ETH and WETH", "Vulnerability Location": "_depositToBentoBox function in TridentRouter contract", "Repair Method": "Each batch must use `refundETH` at the end. Furthermore, we recommend still depositing `address(this).balance` ETH into Bento and if it's less than `underlyingAmount` use `WETH` only for the remaining token difference.", "Vulnerability Information": "The `TridentRouter._depositToBentoBox` function only uses the `ETH` in the contract if it's higher then the desired `underlyingAmount`. Otherwise, the ETH is ignored and the function uses WETH from the user."}

{"Vulnerability Type": "Failure when adding liquidity to index pool", "Vulnerability Location": "TridentRouter contract", "Repair Method": "The router should calculate the optimal parameters for users.", "Vulnerability Information": "`TridentRouter` is easy to fail when trying to provide liquidity to an index pool. Users would either transfer extra tokens or fail."}

{"Vulnerability Type": "Flash swap vulnerability", "Vulnerability Location": "IndexPool contract", "Repair Method": "Flashswap is not implemented correctly. It may need a migration to redeploy all `indexPools` if the issue is found after main-net launch.", "Vulnerability Information": "In the `IndexPool` contract, `flashSwap` does not work. The callback function is called prior to token transfer. The sender won't receive tokens in the callBack function."}

1. {"Vulnerability Type": "Unsafe cast", "Vulnerability Location": "IndexPool.mint function", "Repair Method": "Use SafeCast library everywhere a typecast is done", "Vulnerability Information": "Unsafe cast in IndexPool mint leads to attack"}

2. {"Vulnerability Type": "Error in pow implementation", "Vulnerability Location": "IndexPool.sol L286-L291", "Repair Method": "Add brackets for 'for' loop", "Vulnerability Information": "Index Pool always swap to Zero"}

3. {"Vulnerability Type": "Integer overflow", "Vulnerability Location": "IndexPool.sol L110", "Repair Method": "Cast amountIn to uint256", "Vulnerability Information": "Overflow in the mint function of IndexPool causes LPs' funds to be stolen"}

4. {"Vulnerability Type": "Pricing/Fee issue", "Vulnerability Location": "HybridPool.sol L425-L441", "Repair Method": "Calculate the swapping fee based on the stable swap curve", "Vulnerability Information": "Hybrid pool uses wrong non_optimal_mint_fee"}

5. {"Vulnerability Type": "Incorrect calculation", "Vulnerability Location": "TridentRouter.complexPath function", "Repair Method": "Cache the balanceShares value once before the second for loop starts", "Vulnerability Information": "Router's complexPath percentagePaths don't work as expected"}

6. {"Vulnerability Type": "Data inconsistency", "Vulnerability Location": "HybridPool's reserve", "Repair Method": "Make sure that the reserves are in the correct amounts", "Vulnerability Information": "HybridPool's reserve is converted to 'amount' twice"}

7. {"Vulnerability Type": "Data inconsistency", "Vulnerability Location": "ConstantProductPool.burnSingle function", "Repair Method": "Call _getAmountOut with the balances instead of the reserves", "Vulnerability Information": "ConstantProductPool.burnSingle swap amount computations should use balance"}

8. {"Vulnerability Type": "Incorrect function implementation", "Vulnerability Location": "TridentHelper.withdrawFromWETH function", "Repair Method": "Remove the data.length = 32 from the require and only check if success is true", "Vulnerability Information": "withdrawFromWETH always reverts"}

1. {"Vulnerability Type": "High Severity", "Vulnerability Location": "IndexPool.mint function in IndexPool.sol", "Repair Method": "Allow the first liquidity provider to use custom amountIn values for each token or always take the MIN_BALANCE of each token", "Vulnerability Information": "The first liquidity provider is forced to supply assets in the same amount, which may cause a significant amount of fund loss."}
2. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "HybridPool.sol", "Repair Method": "Revert the transactions if approximation does not converge", "Vulnerability Information": "Approximations may finish with inaccurate values."}
3. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "ConstantProductPool and HybridPool in MathUtils.sol", "Repair Method": "Distribute the minted fee to existing LPs first by incrementing reserve0 and reserve1 with the fee amounts", "Vulnerability Information": "Adding and removing unbalanced liquidity yields slightly more tokens than swap."}
4. {"Vulnerability Type": "High Severity", "Vulnerability Location": "MathUtils.sol", "Repair Method": "Add an else condition to the difference function to mitigate it", "Vulnerability Information": "Absolute difference is not calculated properly when a > b in MathUtils."}
5. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "IndexPool.sol", "Repair Method": "Add a way to send barFees to barFeeTo, same as the other pools", "Vulnerability Information": "No bar fees for IndexPools."}
6. {"Vulnerability Type": "High Severity", "Vulnerability Location": "IndexPool.sol", "Repair Method": "Determine an optimized parameter for the user", "Vulnerability Information": "IndexPool's INIT_POOL_SUPPLY is not fair."}
7. {"Vulnerability Type": "High Severity", "Vulnerability Location": "IndexPool.sol", "Repair Method": "Change the _pow function to the _compute function, which supports exponents in WAD", "Vulnerability Information": "Incorrect usage of _pow in _computeSingleOutGivenPoolIn of IndexPool."}

1. {"Vulnerability Type": "Incorrect multiplication", "Vulnerability Location": "_computeSingleOutGivenPoolIn function of IndexPool", "Repair Method": "Change (BASE normalizedWeight) * _swapFee to _mul((BASE normalizedWeight), _swapFee)", "Vulnerability Information": "The _computeSingleOutGivenPoolIn function of IndexPool uses the raw multiplication (i.e., *) to calculate the zaz variable. However, since both (BASE normalizedWeight) and _swapFee are in WAD, the _mul function should be used instead to calculate the correct value of zaz. Otherwise, zaz would be 10^18 times larger than the expected value and causes an integer underflow when calculating amountOut. The incorrect usage of multiplication prevents anyone from calling the function successfully."}
2. {"Vulnerability Type": "pow overflows", "Vulnerability Location": "IndexPool contract, pow is used in calculating price", "Repair Method": "The weightRatio is an 18 decimals number. It should be divided by (BASE)^exp. The scale in the contract is not consistent. Recommend the dev to check all the scales/ decimals.", "Vulnerability Information": "In the IndexPool contract, pow is used in calculating price. However, Pow is easy to cause overflow. If the weightRatio is large (e.g. 10), there's always overflow. Lp providers can still provide liquidity to the pool where no one can swap. All pools need to redeploy. I consider this a high-risk issue."}
3. {"Vulnerability Type": "Poor conversion", "Vulnerability Location": "A number of functions in IndexPool contract", "Repair Method": "The fixed implementation is provided in the article section", "Vulnerability Information": "A number of functions in IndexPool contract suffer from the erroneous conversion of Balancer V1's implementation."}
4. {"Vulnerability Type": "initial LP supply computation is wrong", "Vulnerability Location": "IndexPool constructor function", "Repair Method": "Do not mint the initial token supply to the zero address in the constructor. Do it like Uniswap/Balancer and let the first liquidity provider provide arbitrary token amounts, then mint the initial pool supply. If reserve == 0, amountIn should just take the pool balances that were transferred to this account. In case the initial mint to the zero address in the constructor was done to prevent the Uniswap-attack where the price of a single wei of LP token can be very high and price out LPs, send a small fraction of this initial LP supply (~1000) to the zero address after it was minted to the first supplier in mint.", "Vulnerability Information": "The IndexPool constructor function already mints INIT_POOL_SUPPLY = 100 * 1e18 = 1e20 LP tokens to the zero address. When trying to use the pool, someone has to provide the actual initial reserve tokens in mint. On the first mint, the pool reserves are zero and the token amount required to mint is just this ratio itself."}
5. {"Vulnerability Type": "flashSwap sends entire fee to barFeeTo", "Vulnerability Location": "HybridPool flashSwap function", "Repair Method": "The flashSwap function should use the same fee mechanism as swap and only send barFee * fee / MAX_FEE to the barFeeTo. See _handleFee function.", "Vulnerability Information": "The HybridPool.flashSwap function sends the entire trade fees fee to the barFeeTo. It should only send barFee * fee to the barFeeTo address. LPs are not getting paid at all when this function is used. There is no incentive to provide liquidity."}

