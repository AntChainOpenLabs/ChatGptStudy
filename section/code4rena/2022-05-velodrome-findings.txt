1. {"Vulnerability Type": "Malicious user can populate rewards array with tokens of their interest", "Vulnerability Location": "Bribe.sol#notifyRewardAmount()", "Repair Method": "Added a whitelist check for reward tokens", "Vulnerability Information": "Malicious user can populate `rewards` array with different tokens early reaching limit of `MAX_REWARD_TOKENS` sending very small amount of different tokens."}
2. {"Vulnerability Type": "Griefing Attack By Extending The Reward Duration", "Vulnerability Location": "Gauge.notifyRewardAmount", "Repair Method": "Consider implementing validation to ensure that this function is callable by anyone only if the previous reward period has already expired", "Vulnerability Information": "It would be possible to exploit the system by repeatedly calling it with dust reward amount to extend an active reward period."}
3. {"Vulnerability Type": "Alter velo receptions computation", "Vulnerability Location": "RedemptionReceiver.sol#L44", "Repair Method": "Ensure that the provided addresses are not `address(0)`", "Vulnerability Information": "The `deployer` can modify the values to obtain different values than expected."}
4. {"Vulnerability Type": "WeVE (FTM) may be lost forever if redemption process is failed", "Vulnerability Location": "RedemptionSender.sol#L28-L51", "Repair Method": "Write refund lzReceive handler on RedemptionSender", "Vulnerability Information": "WeVE (FTM) may be lost forever if redemption process is failed."}
5. {"Vulnerability Type": "Gauge set can be front run if bribe and gauge constructors aren't run atomically", "Vulnerability Location": "Bribe.sol#setGauge()", "Repair Method": "Either running Bribe and then Gauge constructors atomically, or introducing an owner role in Bribe constructor and onlyOwner access control in setGauge", "Vulnerability Information": "A malicious user can run setGauge after Bribe, but before Gauge constructor, making Bribe contract unusable."}

{"Vulnerability Type": "Temporary DOS", "Vulnerability Location": "notifyRewardAmount() in Bribe/Gauge contracts, deliverBribes() in Gauge contract, distribute() and getReward() in Voter contract", "Repair Method": "Set access levels for notifyRewardAmount() functions, move the line IGauge(_gauge).deliverBribes() out of If in Voter.distribute(), update reward balance accounting in withdrawToken()", "Vulnerability Information": "It is possible to call notifyRewardAmount() in Bribe or Gauge contract with malicious tokens and contract will add them to reward tokens list and then attacker can interrupt Gauge.deliverBribes() logic (by failing all contract transaction in that malicious token). Rewards aren't updated before user's balance change in Gauge's withdrawToken. Rewards can be locked in Bribe contract because distributing them depends on base token reward amount and Gauge.deliverBribes() is not always called by Voter.distribute()"}

1. {"Vulnerability Type": "Bribe Rewards Struck In Contract If Deposited During First Epoch", "Vulnerability Location": "Bribe.sol", "Repair Method": "Implement logic to handle the edge case where bribe rewards are added during first epoch. Consider aligning the start of bribe period with VELO emission period.", "Vulnerability Information": "Bribe rewards added to the `Bribe` contract in the first epoch will not be claimable by any voters, and the rewards will struck in the `Bribe` contract."}
2. {"Vulnerability Type": "Bribe Rewards Not Collected In Current Period Will Be Lost Forever", "Vulnerability Location": "Gauge.sol", "Repair Method": "Devise a new implementation to allow bribe rewards not collected to be accured to future epochs so that the bribe rewards will not be lost. Consider referencing the Solidy's `Bribe` contract, which support these requirements.", "Vulnerability Information": "If the bribe rewards are not collected in the current period, they will not be accrued to future epoch, and they will be lost forever."}

{"Vulnerability Type": "Incorrect implementation", "Vulnerability Location": "VotingEscrow contract", "Repair Method": "Call onERC721Received() in _mint() and ensure that the return value equals IERC721Receiver.onERC721Received.selector in both _mint() and safeTransferFrom()", "Vulnerability Information": "The ERC721 standard says that for the function call to be valid, it must return the bytes4 function selector, otherwise it's invalid. If a user of the escrow system uses a contract that is attempting to explicitly reject NFTs by returning zero in its onERC721Received() function, the VotingEscrow will interpret that response as success and will transfer the NFT, potentially locking it forever."}

{"Vulnerability Type": "Logic flaw", "Vulnerability Location": "VotingEscrow contract", "Repair Method": "Consider changing _removeTokenFrom() argument to be the owner", "Vulnerability Information": "The warden has shown how an approved user is unable to execute ordinary operations due to a logic flaw. While the impact may make Medium Severity valid, as the owner can still operate, but delegated users cannot, I believe the finding shows a logical flaw in the system in that it doesn't work as intended."}

1. {"Vulnerability Type": "Blocking LayerZero channel", "Vulnerability Location": "RedemptionReceiver contract", "Repair Method": "Implement non-blocking approach as described in LayerZero docs and LayerZero's example implementation", "Vulnerability Information": "An attacker can initiate a transaction they know will fail to block the channel between FTM and Optimism, making the RedemptionSender & Receiver unusable."}
2. {"Vulnerability Type": "Wrong calculation for rewardRate[token]", "Vulnerability Location": "Gauge.sol#notifyRewardAmount()", "Repair Method": "Calculate rewardRate based on timeUntilNextPeriodFinish to next period finish", "Vulnerability Information": "The updated rewardRate for the token can be much lower than expected, making the total amount of reward tokens less than the total amount of rewards accumulated by all the users. This makes the users who claim the rewards later unable to retrieve their rewards as the balance can be insufficient."}

1. {"Vulnerability Type": "Handling of fee-on-transfer tokens", "Vulnerability Location": "Bribe.sol", "Repair Method": "Disallow tokens with fee-on-transfer mechanics to be added as reward tokens or add the amount of tokens received to epochRewards and store it in tokenRewardsPerEpoch[token][adjustedTstamp]", "Vulnerability Information": "If a fee-on-transfer token is added as a reward token and deposited, the tokens will be locked in the `Bribe` contract, and voters will be unable to withdraw their rewards."}
2. {"Vulnerability Type": "Insufficient gas estimation", "Vulnerability Location": "RedemptionSender.sol", "Repair Method": "Use the `estimateFees()` endpoint to estimate the required gas", "Vulnerability Information": "If the user does not include enough tokens for gas, the transaction will fail."}
3. {"Vulnerability Type": "Checkpoint system vulnerability", "Vulnerability Location": "Gauge.sol", "Repair Method": "Create a new checkpoint each time user's `voted` status changes instead of overwriting the `voted` in last one or rethink how to incentivize users to vote for specific gauges", "Vulnerability Information": "Users can vote right before claiming rewards and reset their votes just after receiving rewards to pass the `if` statement and get rewards for the full period since the last interaction with the gauge."}

1. {"Vulnerability Type": "Smart Contract", "Vulnerability Location": "Bribe.sol#L83-L90", "Repair Method": "Set tokenRewardsPerEpoch[token][epochStart] to 0 after transferring rewards in deliverReward() function", "Vulnerability Information": "Wrong reward distribution in Bribe because deliverReward() won't set tokenRewardsPerEpoch[token][epochStart] to 0 after transferring rewards."}
2. {"Vulnerability Type": "Smart Contract", "Vulnerability Location": "VotingEscrow.sol#L1106", "Repair Method": "Add 'string version' to the EIP712Domain string and build the domainSeparator in the constructor", "Vulnerability Information": "Wrong DOMAIN_TYPEHASH definition broke the EIP 712 and the delegateBySig function."}
3. {"Vulnerability Type": "Smart Contract", "Vulnerability Location": "VotingEscrow.sol#L462-L467, L301-L316, L517-L528", "Repair Method": "Call _moveTokenDelegates(owner, address(0)) in _burn() function", "Vulnerability Information": "Users can get unlimited votes by depositing a token, locking it, waiting for the lock to expire, transferring the token to another address, and repeating."}

1. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "VotingEscrow.sol#L517-L528", "Repair Method": "Add _moveTokenDelegates(delegates(_to), address(0), _tokenId) to remove delegates in _burn() function", "Vulnerability Information": "Owner's delegates should be decreased in _burn()"}
2. {"Vulnerability Type": "High Severity", "Vulnerability Location": "Gauge.sol#L302-L313", "Repair Method": "Update the index to be _nCheckPoints-1 in _writeCheckpoint() function", "Vulnerability Information": "User rewards stop accruing after any _writeCheckpoint calling action"}
3. {"Vulnerability Type": "Medium Severity", "Vulnerability Location": "VeloGovernor.sol#L44-L48", "Repair Method": "Allow governance to call setProposalNumerator and setTeam functions", "Vulnerability Information": "setProposalNumerator and setTeam functions of the VeloGovernor contract can only be called by team without allowing governance to call."}

