{"Vulnerability Type": "Reentrancy", "Vulnerability Location": "function _createComment(DataTypes.CommentData memory vars) internal", "Repair Method": "Store the new `pubCount` in a variable before the comment is created and use it during the creation rather than choosing it afterwards.", "Vulnerability Information": "An attacker is able to emit a comment containing some information that does not match the actual information of a post, allowing him/her to trick light clients into responding to a post that they otherwise would have avoided. The attacker can use this to propagate scams, serve malware, or otherwise poison other user's profiles with unwanted content."}

{"Vulnerability Type": "Frontrunning", "Vulnerability Location": "PublishingLogic.sol#L50", "Repair Method": "Implement a commit/reveal scheme for the handle and the entire profile creation", "Vulnerability Information": "The LensHub/PublishingLogic.createProfile function can be frontrun by other whitelisted profile creators. An attacker can observe pending createProfile transactions and frontrun them, own that handle, and demand ransom from the original transaction creator."}

{"Vulnerability Type": "Value Leakage", "Vulnerability Location": "FeeCollectModule.sol#L99", "Repair Method": "Whitelist certain important infrastructure providers, like different frontends, as referrers and only allow these to be used instead of users submitting their alt profiles", "Vulnerability Information": "In the fee collect modules like FeeCollectModule there is no prevention of someone submitting a second profile they own as the referrerProfileId in processCollect to receive back part of the fees paid. The referral system is essentially broken as all rational agents will submit a second profile they control to get back part of the fees."}

{"Vulnerability Type": "Functionality", "Vulnerability Location": "PublishingLogic.sol#L308-309", "Repair Method": "Prohibit zero collection module to be whitelisted", "Vulnerability Information": "In case when zero collection module be white listed and then zero collection module set to a post (done by different actors), its functionality will be partially broken: every collecting and mirroring of it will be reverted with Errors.PublicationDoesNotExist."}

1. {"Vulnerability Type": "Imprecise management of users' allowance", "Vulnerability Location": "FeeFollowModule.sol#L75-L91", "Repair Method": "Add a non-upgradeable contract for processing user payments", "Vulnerability Information": "Improper management of users' `allowance` is the root cause of some of the biggest attacks in the history of DeFi security."}
2. {"Vulnerability Type": "Name squatting", "Vulnerability Location": "LensHub.sol#L142", "Repair Method": "Consider auctioning off handles to the highest bidder or at least taking a fee such that the cost of name squatting is not zero", "Vulnerability Information": "Creating profiles through `LensHub/PublishingLogic.createProfile` does not cost anything and will therefore result in 'name squatting'."}
3. {"Vulnerability Type": "Collect modules can fail on zero amount transfers", "Vulnerability Location": "FeeCollectModule.sol#L176, LimitedFeeCollectModule.sol#L194, TimedFeeCollectModule.sol#L190, LimitedTimedFeeCollectModule.sol#L205, FeeFollowModule.sol#L90", "Repair Method": "Consider checking the treasury fee amount and do transfer only when it is positive", "Vulnerability Information": "Treasury fee can be zero, while collect modules do attempt to send it in such a case anyway as there is no check in place."}

1. {"Vulnerability Type": "Approvals not cleared", "Vulnerability Location": "ApprovalFollowModule.sol#L32", "Repair Method": "Consider resetting all approvals upon transfer", "Vulnerability Information": "Upon transfer, the old approvals are not cleared. This can lead to similar issues as OpenSea not cancelling their sale offers upon NFT transfer."}
2. {"Vulnerability Type": "Following deleted profiles", "Vulnerability Location": "InteractionLogic.sol#L49", "Repair Method": "Change to: if (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i]) revert Errors.TokenDoesNotExist();", "Vulnerability Information": "The problem is that there might be a new profile with the same handle as the deleted one, allowing following deleted profiles."}
3. {"Vulnerability Type": "Ineffective Whitelist", "Vulnerability Location": "LensHub.sol#L146", "Repair Method": "Consider limiting the number of profile creations per whitelisted user or severely limiting who is allowed to create profiles, basically making profile creation a centralized system.", "Vulnerability Information": "A single whitelisted account can create as many profiles as they want and send the profile NFT to other users."}
4. {"Vulnerability Type": "Inappropriate handling of referralFee", "Vulnerability Location": "FeeCollectModule.sol#L163-L172", "Repair Method": "Change to: try IERC721(HUB).ownerOf(referrerProfileId) returns (address referralRecipient) { uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX; adjustedAmount = adjustedAmount referralAmount; address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId); IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);} catch { emit LogNonExistingReferrer(referrerProfileId);}", "Vulnerability Information": "If the publication is a `Mirror` and there is a `referralFee` set by the original publication, the user won't be able to collect from a `Mirror` that was published by a burned profile."}
5. {"Vulnerability Type": "Missing whenNotPaused", "Vulnerability Location": "LensHub.sol#L929", "Repair Method": "Add whenNotPasued to `_beforeTokenTransfer`", "Vulnerability Information": "In case where the governance wants to stop all activity, they still can't stop transferring profiles nfts."}

{"Vulnerability Type": "Restrictive functionality", "Vulnerability Location": "Base fee modules in FeeModuleBase.sol, LimitedFeeCollectModule.sol, TimedFeeCollectModule.sol, LimitedTimedFeeCollectModule.sol, and FeeFollowModule.sol", "Repair Method": "Add a separate constant for minimum fee amount in nominal terms", "Vulnerability Information": "BPS_MAX constant is used as minimal fee amount requirement, which restricts functionality for some currencies with small decimals and market rates."}

