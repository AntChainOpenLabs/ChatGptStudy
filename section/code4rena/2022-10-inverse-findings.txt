1. {"Vulnerability Type": "Avoidable misconfiguration", "Vulnerability Location": "Market.sol#L281-L283", "Repair Method": "Make callOnDepositCallback a configurable parameter in Market.sol or always call the onDeposit callback and leave it empty in case there's no extra functionality that needs to be executed for that escrow.", "Vulnerability Information": "If a user creates a market with the INVEscrow implementation as escrowImplementation and false as callOnDepositCallback, the deposits made by users in the escrow (through the market) would not mint xINV tokens for them."}
2. {"Vulnerability Type": "Denial of Service (DoS)", "Vulnerability Location": "Oracle.sol#L78-L105, Oracle.sol#L112-L144, Market.sol#L344-L347, Market.sol#L323-L327", "Repair Method": "Update the Oracle contract's viewPrice and getPrice functions to refactor feeds[token].feed.latestAnswer() into try feeds[token].feed.latestAnswer() returns (int256 price) { ... } catch Error(string memory) { ... }. The logic for getting the collateral token's price from the Chainlink oracle data feed should be placed in the try block while some fallback logic when the access to the Chainlink oracle data feed is denied should be placed in the catch block. If getting the fixed price for the collateral token is considered as a fallback logic, then setting the fixed price for the token should become mandatory, which is different from the current implementation. Otherwise, fallback logic for getting the token's price from a fallback oracle is needed.", "Vulnerability Information": "When Chainlink's multisigs block access to price feeds, executing feeds[token].feed.latestAnswer() will revert, causing denial of service when calling functions like getCollateralValueInternal and getWithdrawalLimitInternal."}

{"Vulnerability Type": "Smart Contract Reentrancy", "Vulnerability Location": "withdrawInternal function in Market.sol", "Repair Method": "Mark the affected functions as nonReentrant", "Vulnerability Information": "ERC777 reentrancy when withdrawing can be used to withdraw all collateral"}

1. {"Vulnerability Type": "DOS", "Vulnerability Location": "function repay(address user, uint amount) public", "Repair Method": "Use `min(debt, amount)` as the amount to repay.", "Vulnerability Information": "The `repay` function can be frontrun by an attacker, causing the victim's transaction to fail and preventing them from calling the `repay` function."}
2. {"Vulnerability Type": "Oracle attack", "Vulnerability Location": "function liquidate(address user) public", "Repair Method": "Instead of using the 2 day lowest price during the liquidation, the team could either take the current oracle price, while still using the 2 day period for any direct agent interaction to minimize attacks both from users side and liquidators side.", "Vulnerability Information": "Using the 2 day low exchange rate in `Market.liquidate()` makes the system highly at risk in an oracle attack."}
3. {"Vulnerability Type": "DOS", "Vulnerability Location": "function forceReplenish(address user, uint amount) public", "Repair Method": "Use `min(deficit, amount)` as the amount to replenish.", "Vulnerability Information": "`Market::forceReplenish` can be DoSed by a borrower or any other malicious party front running the transaction with a dust amount to prevent the replenish."}
4. {"Vulnerability Type": "Incorrect value returned", "Vulnerability Location": "function viewPrice(address token, uint collateralFactor) public view returns (uint)", "Repair Method": "Add a check to report a dampened price if the current price is lower than the two-day low.", "Vulnerability Information": "`Oracle`'s `viewPrice` function doesn't always report a dampened price, which can cause wrong values to be returned by public read-only functions that call it."}

1. {"Vulnerability Type": "Unhandled return values", "Vulnerability Location": "transfer and transferFrom functions in Market.sol", "Repair Method": "Wrap calls into require() statements to check for failures or use OpenZeppelin’s SafeERC20 wrapper functions", "Vulnerability Information": "Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting."}
2. {"Vulnerability Type": "Insufficient check on forceReplenish function", "Vulnerability Location": "forceReplenish, repay, and withdraw functions in Market.sol", "Repair Method": "Check the user's DBR deficit when calling the repay function and adjust the amount input accordingly. Use getCreditLimitInternal() instead of getCollateralValueInternal()", "Vulnerability Information": "Users can call forceReplenish() even when they are on liquidation position, leading to over-collateralization or bad debt."}
3. {"Vulnerability Type": "Inconsistent implementation", "Vulnerability Location": "repay function in Market.sol", "Repair Method": "Check the user's DBR deficit when calling the repay function and adjust the amount input accordingly", "Vulnerability Information": "The user can get some DOLA even if they are on liquidation position."}

1. {"Vulnerability Type": "Smart Contract Logic", "Vulnerability Location": "function liquidate(address user, uint repaidDebt) public {", "Repair Method": "Limit the debt increase in the function forceReplenish so that the new debt after replenish will not be over the threshold and ensure that the liquidation does not decrease the health index in the function liquidate", "Vulnerability Information": "Liquidation should make a borrower healthier, but if the borrower's debt is over some threshold (still less than collateral value), liquidation makes the borrower debt 'unhealthier'. Repeating liquidation can lead to various problems and the attacker can take the DOLA out of the market."}
2. {"Vulnerability Type": "Oracle Manipulation", "Vulnerability Location": "Oracle.sol#L124", "Repair Method": "Increase the interval to a three-day interval to fix the issue", "Vulnerability Information": "The two-day feature of the oracle can be gamed where you only have to manipulate the oracle for ~2 blocks. If you manipulate the oracle at the last block of day X and at the first block of day X + 1, you bypass the two-day feature of the oracle."}
3. {"Vulnerability Type": "Arithmetic Overflow/Underflow", "Vulnerability Location": "Oracle.sol#L87", "Repair Method": "If feedDecimals + tokenDecimals exceeds 36, then divide the price by 10^decimals to normalize the price", "Vulnerability Information": "The Oracle contract normalizes prices in both viewPrices and getPrices functions to adjust for potential decimal differences between feed and token decimals and the expected return value. However, these functions assume that feedDecimals and tokenDecimals won't exceed 18, which may cause an overflow (and a revert) for the general case, rendering the Oracle useless in these cases."}

{"Vulnerability Type": "Stale Price", "Vulnerability Location": "Oracle.sol", "Repair Method": "Update the code to use latestRoundData function and validate the roundId and updatedAt values to ensure the returned price is not stale.", "Vulnerability Information": "The Chainlink oracle data feed is not sufficiently validated and can return stale prices, which can cause inaccurate calculations for credit and withdrawal limits and result in unexpected liquidation of a user's debt."}

1. {"Vulnerability Type": "Protocol withdrawals of collateral can be unexpectedly locked", "Vulnerability Location": "Market.setCollateralFactorBps()", "Repair Method": "Consider a minimum for this value, to go along with the maximum value check already present in the setter function. While this will still reduce the quantity of collateral that can be withdrawn by users, it would allow for some withdraws to occur. An explicit withdrawal lock could be implemented, making the semantic clear. This function could have modified access controls to enable faster reactions vs governance alone.", "Vulnerability Information": "Protocol withdrawals of collateral can be unexpectedly locked if governance sets the  collateralFactorBps  to 0."}
2. {"Vulnerability Type": "User can free from liquidation fee if its escrow balance is less than the calculated liquidation fee", "Vulnerability Location": "if(escrow.balance() = liquidationFee)", "Repair Method": "User should pay all the remaining escrow balance if the calculated liquidation fee is greater than its escrow balance.", "Vulnerability Information": "User can free from liquidation fee if its escrow balance less than the calculated liquidation fee."}
3. {"Vulnerability Type": "User can borrow DOLA indefinitely without settling DBR deficit by keeping their debt close to the allowed maximum", "Vulnerability Location": "function repay(address user, uint amount) public {", "Repair Method": "Allow replenishing to push the debt under the water and disallow repaying the debt with an outstanding DBR deficit.", "Vulnerability Information": "User can borrow DOLA indefinitely without settling DBR deficit by keeping their debt close to the allowed maximum."}

