1. {"Vulnerability Type": "Inconsistent view functions", "Vulnerability Location": "AmmConvexGauge.sol: L107-L111, L129-L134", "Repair Method": "Add if statement to claimableRewards() function to check if inflationRecipient is set to address(0)", "Vulnerability Information": "The view functions used for a user to check their claimable rewards vary in their implementation. This can cause users to believe they are due X amount but will receive Y."}
2. {"Vulnerability Type": "Double counting of fees", "Vulnerability Location": "BkdLocker.sol: L70-L75, L302-L322, L332", "Repair Method": "Add require statement to migrate() function to check if newRewardToken is not equal to rewardToken", "Vulnerability Information": "Users can claim more fees than expected if governance migrates current rewardToken again by fault."}

{"Vulnerability Type": "AMM Staker control over share calculation", "Vulnerability Location": "AmmGauge.sol contract, line 147", "Repair Method": "Update the way the `totalStaked` variable is evaluated and how the `Integral` is calculated on pool inception to prevent the first staker from having control over share calculation. Deployer can also make 2 or 3 initial deposits to mitigate the attack.", "Vulnerability Information": "The first staker can take control of how the subsequent shares are going to be distributed by simply staking 1wei amount of the token and frontrunning future stakers. The vulnerability is related to how the variables are updated and with the amounts that the Gauge allows users to stake (anything but zero)."}

1. {"Vulnerability Type": "Uninitialized Variable", "Vulnerability Location": "LpGauge.sol", "Repair Method": "Initialize poolLastUpdate variable in the constructor", "Vulnerability Information": "Users can claim extremely large rewards or lock rewards from LpGauge due to uninitialised poolLastUpdate variable."}
2. {"Vulnerability Type": "Failure to Deposit Fees", "Vulnerability Location": "FeeBurner.sol", "Repair Method": "Add a pool denominated in ETH to ensure the logic goes through", "Vulnerability Information": "BkdLocker depositFees can be blocked if burnFees fails if none of the pool tokens have underlying token as native ETH token."}
3. {"Vulnerability Type": "Lack of Slippage Check", "Vulnerability Location": "FeeBurner.sol", "Repair Method": "Initiate the transaction with a default slippage of 99% or perform own swaps to ensure a more reliable outcome", "Vulnerability Information": "FeeBurner initiates swap without any slippage checks if Chainlink oracle fails."}

{"Vulnerability Type": "Access Control", "Vulnerability Location": "Minter.sol#startInflation()", "Repair Method": "Initialize 'lastEvent' and 'lastInflationDecay' in 'constructor()' or add 'require(lastEvent != 0 && lastInflationDecay != 0, \"...\")' to 'executeInflationRateUpdate()'", "Vulnerability Information": "The 'executeInflationRateUpdate()' method does not check the value of 'lastEvent' and 'lastInflationDecay' and uses them directly, which can bypass the 'startInflation()' method and render the constraints of 'totalAvailableToNow' incorrect and useless."}

{"Vulnerability Type": "Accounting", "Vulnerability Location": "StakerVault.sol, LpGauge.sol", "Repair Method": "Method 1: Forbid a transfer between strategy and non-strategy. Method 2: Update 'StakerVault.strategiesTotalStaked' and 'StakerVault._poolTotalStaked' correctly", "Vulnerability Information": "Strategy in 'StakerVault.sol' can steal more rewards even though it's designed strategies shouldn't get rewards. Also, there will be a problem with a rewarding system in 'LpGauge.sol' so that some normal users wouldn't get rewards properly."}

1. {"Vulnerability Type": "Reward calculation", "Vulnerability Location": "AmmGauge.sol", "Repair Method": "Call externally `_poolCheckpoint()` between Alice stake call and Bobs' and before checking the accumulated rewards", "Vulnerability Information": "The first staker within the `AmmGauge` may not get the rewards if the pool is not checkpointed right after he stakes and before he wants to claim the rewards."}
2. {"Vulnerability Type": "DoS", "Vulnerability Location": "InflationManager.sol, KeeperGauge.sol, TopUpActionFeeHandler.sol, TopUpAction.sol", "Repair Method": "Add an on-chain check to ensure that the keeper gauge is not in use before removing them", "Vulnerability Information": "When `_removeKeeperGauge` is called, there is no guarantee that the keeper gauge isn't currently in use by any `TopUpActionFeeHandler`. If it's still in use, any top up action executions will be disabled as reporting fees in `KeeperGauge.sol` will revert."}

1. {"Vulnerability Type": "uint underflow error", "Vulnerability Location": "StakerVault.unstake(), StakerVault.unstakeFor()", "Repair Method": "Modify StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom() functions", "Vulnerability Information": "StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked."}
2. {"Vulnerability Type": "admin/governance rug", "Vulnerability Location": "multiple locations", "Repair Method": "Implement a trust-minimizing approach or formalize a governance process with safeguards in place", "Vulnerability Information": "There are multiple ways for admins/governance to rug users."}
3. {"Vulnerability Type": "total supply not guaranteed", "Vulnerability Location": "_executeInflationRateUpdate()", "Repair Method": "Modify _executeInflationRateUpdate() function", "Vulnerability Information": "Total Supply is not guaranteed and is not deterministic."}

1. {"Vulnerability Type": "Front-running attack", "Vulnerability Location": "BkdLocker#depositFees()", "Repair Method": "Switch to a rewardRate-based gradual release model or force rewards to linearly vest", "Vulnerability Information": "The attacker can front-run the depositFees() function to steal the newly added rewardToken."}
2. {"Vulnerability Type": "Contract initialization vulnerability", "Vulnerability Location": "BkdLocker#initialize()", "Repair Method": "Add another variable to check the status of initialization of the contract", "Vulnerability Information": "The BkdLocker contract can be initialized multiple times with different values for configuration parameters."}
3. {"Vulnerability Type": "Denial of Service (DoS)", "Vulnerability Location": "_calcTotalClaimable() function in KeeperGauge.sol", "Repair Method": "Generate a behavior for the case that perPeriodTotalFees[i] == 0", "Vulnerability Information": "Division by zero in _calcTotalClaimable() function can cause a DoS if perPeriodTotalFees[i] is 0."}

1. {"Vulnerability Type": "Incorrect order of operations", "Vulnerability Location": "Minter.sol#_executeInflationRateUpdate()", "Repair Method": "Move the call to checkpointAllGauges() to before the currentInflationAmountKeeper is updated", "Vulnerability Information": "When _executeInflationRateUpdate() is called, if an _INFLATION_DECAY_PERIOD has past since lastInflationDecay, it will update the InflationRate for all of the gauges. However, in the current implementation, the rates will be updated first, followed by the rewards being settled using the new rates on the gauges using inflationManager().checkpointAllGauges(). If the _INFLATION_DECAY_PERIOD has passed for a long time before executeInflationRateUpdate() is called, the users may lose a significant amount of rewards."}
2. {"Vulnerability Type": "Deprecated transfer usage", "Vulnerability Location": "SwapperRouter.sol#140", "Repair Method": "Use call instead of transfer", "Vulnerability Information": "The usage of deprecated transfer to send ETH can cause Swap to revert. The original transfer used to send eth uses a fixed stipend 2300 gas. This was used to prevent reentrancy. However, this limits the protocol to interact with other contracts that need more than that to process the transaction. The repair method is to use call instead."}

1. {"Vulnerability Type": "Inaccurate amount distribution", "Vulnerability Location": "Updating weights in Minter.sol", "Repair Method": "Checkpoint every LpStakerVault, KeeperGauge or AmmGauge when updating the weights of one of them", "Vulnerability Information": "When updating pool inflation rates, other pools see their `currentRate` being modified without having `poolCheckpoint` called, which leads to false computations. This will lead to either users losing a part of their claims, but can also lead to too many tokens could be distributed, preventing some users from claiming due to the `totalAvailableToNow` requirement in `Minter`."}
2. {"Vulnerability Type": "Stuck fees", "Vulnerability Location": "RewardHandler.sol", "Repair Method": "Call burnFees() before delisting a pool", "Vulnerability Information": "Unclaimed fees from pool will be stuck. When delisting a pool the pool's reference is removed from address provider. Since the list no longer contains the pool those fees will not be processed and will remain stuck in the contract."}

