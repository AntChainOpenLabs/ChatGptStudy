[
    {
        "Code":"\/\/ SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.0;\r\n\r\nimport \".\/RoleAware.sol\";\r\nimport \".\/MarginRouter.sol\";\r\nimport \"..\/libraries\/UniswapStyleLib.sol\";\r\n\r\n\/\/\/ Stores how many of token you could get for 1k of peg\r\nstruct TokenPrice {\r\n    uint256 blockLastUpdated;\r\n    uint256 tokenPer1k;\r\n    address[] liquidationPairs;\r\n    address[] inverseLiquidationPairs;\r\n    address[] liquidationTokens;\r\n    address[] inverseLiquidationTokens;\r\n}\r\n\r\n\/\/\/ @title The protocol features several mechanisms to prevent vulnerability to\r\n\/\/\/ price manipulation:\r\n\/\/\/ 1) global exposure caps on all tokens which need to be raised gradually\r\n\/\/\/    during the process of introducing a new token, making attacks unprofitable\r\n\/\/\/    due to lack  of scale\r\n\/\/\/ 2) Exponential moving average with cautious price update. Prices for estimating\r\n\/\/\/    how much a trader can borrow need not be extremely current and precise, mainly\r\n\/\/\/    they must be resilient against extreme manipulation\r\n\/\/\/ 3) Liquidators may not call from a contract address, to prevent extreme forms of\r\n\/\/\/    of front-running and other price manipulation.\r\nabstract contract PriceAware is Ownable, RoleAware {\r\n    address public immutable peg;\r\n    mapping(address => TokenPrice) public tokenPrices;\r\n    \/\/\/ update window in blocks\r\n    uint16 public priceUpdateWindow = 8;\r\n    uint256 public UPDATE_RATE_PERMIL = 80;\r\n    uint256 public UPDATE_MAX_PEG_AMOUNT = 50_000;\r\n    uint256 public UPDATE_MIN_PEG_AMOUNT = 1_000;\r\n\r\n    constructor(address _peg) Ownable() {\r\n        peg = _peg;\r\n    }\r\n\r\n    \/\/\/ Set window for price updates\r\n    function setPriceUpdateWindow(uint16 window) external onlyOwner {\r\n        priceUpdateWindow = window;\r\n    }\r\n\r\n    \/\/\/ Set rate for updates\r\n    function setUpdateRate(uint256 rate) external onlyOwner {\r\n        UPDATE_RATE_PERMIL = rate;\r\n    }\r\n\r\n    function setUpdateMaxPegAmount(uint256 amount) external onlyOwner {\r\n        UPDATE_MAX_PEG_AMOUNT = amount;\r\n    }\r\n\r\n    function setUpdateMinPegAmount(uint256 amount) external onlyOwner {\r\n        UPDATE_MIN_PEG_AMOUNT = amount;\r\n    }\r\n\r\n    \/\/\/ Get current price of token in peg\r\n    function getCurrentPriceInPeg(\r\n        address token,\r\n        uint256 inAmount,\r\n        bool forceCurBlock\r\n    ) public returns (uint256) {\r\n        TokenPrice storage tokenPrice = tokenPrices[token];\r\n        if (forceCurBlock) {\r\n            if (\r\n                block.number - tokenPrice.blockLastUpdated > priceUpdateWindow\r\n            ) {\r\n                \/\/ update the currently cached price\r\n                return getPriceFromAMM(token, inAmount);\r\n            } else {\r\n                \/\/ just get the current price from AMM\r\n                return viewCurrentPriceInPeg(token, inAmount);\r\n            }\r\n        } else if (tokenPrice.tokenPer1k == 0) {\r\n            \/\/ do the best we can if it's at zero\r\n            return getPriceFromAMM(token, inAmount);\r\n        }\r\n\r\n        if (block.number - tokenPrice.blockLastUpdated > priceUpdateWindow) {\r\n            \/\/ update the price somewhat\r\n            getPriceFromAMM(token, inAmount);\r\n        }\r\n\r\n        return (inAmount * 1000 ether) \/ tokenPrice.tokenPer1k;\r\n    }\r\n\r\n    \/\/\/ Get view of current price of token in peg\r\n    function viewCurrentPriceInPeg(address token, uint256 inAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (token == peg) {\r\n            return inAmount;\r\n        } else {\r\n            TokenPrice storage tokenPrice = tokenPrices[token];\r\n            uint256[] memory pathAmounts =\r\n                UniswapStyleLib.getAmountsOut(\r\n                    inAmount,\r\n                    tokenPrice.liquidationPairs,\r\n                    tokenPrice.liquidationTokens\r\n                );\r\n            uint256 outAmount = pathAmounts[pathAmounts.length - 1];\r\n            return outAmount;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @dev retrieves the price from the AMM\r\n    function getPriceFromAMM(address token, uint256 inAmount)\r\n        internal\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        if (token == peg) {\r\n            return inAmount;\r\n        } else {\r\n            TokenPrice storage tokenPrice = tokenPrices[token];\r\n            uint256[] memory pathAmounts =\r\n                UniswapStyleLib.getAmountsOut(\r\n                    inAmount,\r\n                    tokenPrice.liquidationPairs,\r\n                    tokenPrice.liquidationTokens\r\n                );\r\n            uint256 outAmount = pathAmounts[pathAmounts.length - 1];\r\n\r\n            if (\r\n                outAmount > UPDATE_MIN_PEG_AMOUNT &&\r\n                outAmount < UPDATE_MAX_PEG_AMOUNT\r\n            ) {\r\n                setPriceVal(tokenPrice, inAmount, outAmount);\r\n            }\r\n\r\n            return outAmount;\r\n        }\r\n    }\r\n\r\n    function setPriceVal(\r\n        TokenPrice storage tokenPrice,\r\n        uint256 inAmount,\r\n        uint256 outAmount\r\n    ) internal {\r\n        _setPriceVal(tokenPrice, inAmount, outAmount, UPDATE_RATE_PERMIL);\r\n        tokenPrice.blockLastUpdated = block.number;\r\n    }\r\n\r\n    function _setPriceVal(\r\n        TokenPrice storage tokenPrice,\r\n        uint256 inAmount,\r\n        uint256 outAmount,\r\n        uint256 weightPerMil\r\n    ) internal {\r\n        uint256 updatePer1k = (1000 ether * inAmount) \/ (outAmount + 1);\r\n        tokenPrice.tokenPer1k =\r\n            (tokenPrice.tokenPer1k *\r\n                (1000 - weightPerMil) +\r\n                updatePer1k *\r\n                weightPerMil) \/\r\n            1000;\r\n    }\r\n\r\n    \/\/\/ add path from token to current liquidation peg\r\n    function setLiquidationPath(address[] memory path, address[] memory tokens)\r\n        external\r\n    {\r\n        require(\r\n            isTokenActivator(msg.sender),\r\n            \"not authorized to set lending cap\"\r\n        );\r\n\r\n        address token = tokens[0];\r\n\r\n        TokenPrice storage tokenPrice = tokenPrices[token];\r\n        tokenPrice.liquidationPairs = new address[](path.length);\r\n        tokenPrice.inverseLiquidationPairs = new address[](path.length);\r\n        tokenPrice.liquidationTokens = new address[](tokens.length);\r\n        tokenPrice.inverseLiquidationTokens = new address[](tokens.length);\r\n\r\n        for (uint256 i = 0; path.length > i; i++) {\r\n            tokenPrice.liquidationPairs[i] = path[i];\r\n            tokenPrice.inverseLiquidationPairs[i] = path[path.length - i - 1];\r\n        }\r\n\r\n        for (uint256 i = 0; tokens.length > i; i++) {\r\n            tokenPrice.liquidationTokens[i] = tokens[i];\r\n            tokenPrice.inverseLiquidationTokens[i] = tokens[\r\n                tokens.length - i - 1\r\n            ];\r\n        }\r\n\r\n        uint256[] memory pathAmounts =\r\n            UniswapStyleLib.getAmountsIn(1000 ether, path, tokens);\r\n        uint256 inAmount = pathAmounts[0];\r\n        _setPriceVal(tokenPrice, inAmount, 1000 ether, 1000);\r\n    }\r\n\r\n    function liquidateToPeg(address token, uint256 amount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        if (token == peg) {\r\n            return amount;\r\n        } else {\r\n            TokenPrice storage tP = tokenPrices[token];\r\n            uint256[] memory amounts =\r\n                MarginRouter(router()).authorizedSwapExactT4T(\r\n                    amount,\r\n                    0,\r\n                    tP.liquidationPairs,\r\n                    tP.liquidationTokens\r\n                );\r\n\r\n            uint256 outAmount = amounts[amounts.length - 1];\r\n\r\n            return outAmount;\r\n        }\r\n    }\r\n\r\n    function liquidateFromPeg(address token, uint256 targetAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        if (token == peg) {\r\n            return targetAmount;\r\n        } else {\r\n            TokenPrice storage tP = tokenPrices[token];\r\n            uint256[] memory amounts =\r\n                MarginRouter(router()).authorizedSwapT4ExactT(\r\n                    targetAmount,\r\n                    type(uint256).max,\r\n                    tP.inverseLiquidationPairs,\r\n                    tP.inverseLiquidationTokens\r\n                );\r\n\r\n            return amounts[0];\r\n        }\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-04-marginswap#h-03-price-feed-can-be-manipulated",
                "Location":"PriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true)",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.Anyone can trigger an update to the price feed by calling PriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true). If the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts. This simulation uses the reserves of the Uniswap pairs which can be changed drastically using flash loans to yield almost arbitrary output amounts, and thus prices. Wrong prices break the core functionality of the contracts such as borrowing on margin, liquidations, etc.",
                "Repair":"Recommend against using the Uniswap spot price as the real price. Uniswap itself warns against this and instead recommends implementing a TWAP price oracle using the price*CumulativeLast variables."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.0;\r\n\r\nimport \".\/lib\/LibMath.sol\";\r\nimport \".\/lib\/LibPrices.sol\";\r\nimport \".\/Interfaces\/IPricing.sol\";\r\nimport \".\/Interfaces\/ITracerPerpetualSwaps.sol\";\r\nimport \".\/Interfaces\/IInsurance.sol\";\r\nimport \".\/Interfaces\/IOracle.sol\";\r\nimport \"prb-math\/contracts\/PRBMathSD59x18.sol\";\r\n\r\ncontract Pricing is IPricing {\r\n    using LibMath for uint256;\r\n    using LibMath for int256;\r\n    using PRBMathSD59x18 for int256;\r\n\r\n    address public tracer;\r\n    IInsurance public insurance;\r\n    IOracle public oracle;\r\n\r\n    \/\/ pricing metrics\r\n    Prices.PriceInstant[24] internal hourlyTracerPrices;\r\n    Prices.PriceInstant[24] internal hourlyOraclePrices;\r\n\r\n    \/\/ funding index => funding rate\r\n    mapping(uint256 => Prices.FundingRateInstant) public fundingRates;\r\n\r\n    \/\/ funding index => insurance funding rate\r\n    mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;\r\n\r\n    \/\/ market's time value\r\n    int256 public override timeValue;\r\n\r\n    \/\/ funding index\r\n    uint256 public override currentFundingIndex;\r\n\r\n    \/\/ timing variables\r\n    uint256 public startLastHour;\r\n    uint256 public startLast24Hours;\r\n    uint8 public override currentHour;\r\n\r\n    event HourlyPriceUpdated(uint256 price, uint256 currentHour);\r\n    event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);\r\n    event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);\r\n\r\n    \/**\r\n     * @dev Set tracer perps factory\r\n     * @dev ensure that oracle contract is returning WAD values. This may be done\r\n     *      by wrapping the raw oracle in an adapter (see contracts\/oracle)\r\n     * @param _tracer The address of the tracer this pricing contract links too\r\n     *\/\r\n    constructor(\r\n        address _tracer,\r\n        address _insurance,\r\n        address _oracle\r\n    ) {\r\n        tracer = _tracer;\r\n        insurance = IInsurance(_insurance);\r\n        oracle = IOracle(_oracle);\r\n        startLastHour = block.timestamp;\r\n        startLast24Hours = block.timestamp;\r\n    }\r\n\r\n    \/**\r\n     * @notice Updates pricing information given a trade of a certain volume at\r\n     *         a set price\r\n     * @param tradePrice the price the trade executed at\r\n     *\/\r\n    function recordTrade(uint256 tradePrice) external override onlyTracer {\r\n        uint256 currentOraclePrice = oracle.latestAnswer();\r\n        if (startLastHour <= block.timestamp - 1 hours) {\r\n            \/\/ emit the old hourly average\r\n            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);\r\n            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);\r\n\r\n            \/\/ update funding rate for the previous hour\r\n            updateFundingRate();\r\n\r\n            \/\/ update the time value\r\n            if (startLast24Hours <= block.timestamp - 24 hours) {\r\n                \/\/ Update the interest rate every 24 hours\r\n                updateTimeValue();\r\n                startLast24Hours = block.timestamp;\r\n            }\r\n\r\n            \/\/ update time metrics after all other state\r\n            startLastHour = block.timestamp;\r\n\r\n            \/\/ Check current hour and loop around if need be\r\n            if (currentHour == 23) {\r\n                currentHour = 0;\r\n            } else {\r\n                currentHour = currentHour + 1;\r\n            }\r\n\r\n            \/\/ add new pricing entry for new hour\r\n            updatePrice(tradePrice, currentOraclePrice, true);\r\n        } else {\r\n            \/\/ Update old pricing entry\r\n            updatePrice(tradePrice, currentOraclePrice, false);\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * @notice Updates both the latest market price and the latest underlying asset price (from an oracle) for a given tracer market given a tracer price\r\n     *         and an oracle price.\r\n     * @param marketPrice The price that a tracer was bought at, returned by the TracerPerpetualSwaps.sol contract when an order is filled\r\n     * @param oraclePrice The price of the underlying asset that the Tracer is based upon as returned by a Chainlink Oracle\r\n     * @param newRecord Bool that decides if a new hourly record should be started (true) or if a current hour should be updated (false)\r\n     *\/\r\n    function updatePrice(\r\n        uint256 marketPrice,\r\n        uint256 oraclePrice,\r\n        bool newRecord\r\n    ) internal {\r\n        \/\/ Price records entries updated every hour\r\n        if (newRecord) {\r\n            \/\/ Make new hourly record, total = marketprice, numtrades set to 1;\r\n            Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);\r\n            hourlyTracerPrices[currentHour] = newHourly;\r\n            \/\/ As above but with Oracle price\r\n            Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);\r\n            hourlyOraclePrices[currentHour] = oracleHour;\r\n        } else {\r\n            \/\/ If an update is needed, add the market price to a running total and increment number of trades\r\n            hourlyTracerPrices[currentHour].cumulativePrice =\r\n                hourlyTracerPrices[currentHour].cumulativePrice +\r\n                marketPrice;\r\n            hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;\r\n            \/\/ As above but with oracle price\r\n            hourlyOraclePrices[currentHour].cumulativePrice =\r\n                hourlyOraclePrices[currentHour].cumulativePrice +\r\n                oraclePrice;\r\n            hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * @notice Updates the funding rate and the insurance funding rate\r\n     *\/\r\n    function updateFundingRate() internal {\r\n        \/\/ Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable\r\n        ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);\r\n        Prices.TWAP memory twapPrices = getTWAPs(currentHour);\r\n        int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();\r\n        uint256 underlyingTWAP = twapPrices.underlying;\r\n        uint256 derivativeTWAP = twapPrices.derivative;\r\n\r\n        int256 newFundingRate = PRBMathSD59x18.mul(\r\n            derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,\r\n            _tracer.fundingRateSensitivity().toInt256()\r\n        );\r\n\r\n        \/\/ Create variable with value of new funding rate value\r\n        int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;\r\n        int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;\r\n\r\n        \/\/ as above but with insurance funding rate value\r\n        int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;\r\n        int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;\r\n\r\n        \/\/ Call setter functions on calculated variables\r\n        setFundingRate(newFundingRate, cumulativeFundingRate);\r\n        emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);\r\n        setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);\r\n        emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);\r\n        \/\/ increment funding index\r\n        currentFundingIndex = currentFundingIndex + 1;\r\n    }\r\n\r\n    \/**\r\n     * @notice Given the address of a tracer market this function will get the current fair price for that market\r\n     *\/\r\n    function fairPrice() external view override returns (uint256) {\r\n        return Prices.fairPrice(oracle.latestAnswer(), timeValue);\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/\/  SETTER FUNCTIONS   \/\/\/\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/**\r\n     * @notice Calculates and then updates the time Value for a tracer market\r\n     *\/\r\n    function updateTimeValue() internal {\r\n        (uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();\r\n\r\n        timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);\r\n    }\r\n\r\n    \/**\r\n     * @notice Sets the values of the fundingRate struct\r\n     * @param fundingRate The funding Rate of the Tracer, calculated by updateFundingRate\r\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\r\n     *\/\r\n    function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\r\n        fundingRates[currentFundingIndex] = Prices.FundingRateInstant(\r\n            block.timestamp,\r\n            fundingRate,\r\n            cumulativeFundingRate\r\n        );\r\n    }\r\n\r\n    \/**\r\n     * @notice Sets the values of the fundingRate struct for a particular Tracer Marker\r\n     * @param fundingRate The insurance funding Rate of the Tracer, calculated by updateFundingRate\r\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\r\n     *\/\r\n    function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\r\n        insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(\r\n            block.timestamp,\r\n            fundingRate,\r\n            cumulativeFundingRate\r\n        );\r\n    }\r\n\r\n    \/\/ todo by using public variables lots of these can be removed\r\n    \/**\r\n     * @return each variable of the fundingRate struct of a particular tracer at a particular funding rate index\r\n     *\/\r\n    function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\r\n        return fundingRates[index];\r\n    }\r\n\r\n    \/**\r\n     * @return all of the variables in the funding rate struct (insurance rate) from a particular tracer market\r\n     *\/\r\n    function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\r\n        return insuranceFundingRates[index];\r\n    }\r\n\r\n    \/**\r\n     * @notice Gets an 8 hour time weighted avg price for a given tracer, at a particular hour. More recent prices are weighted more heavily.\r\n     * @param hour An integer representing what hour of the day to collect from (0-24)\r\n     * @return the time weighted average price for both the oraclePrice (derivative price) and the Tracer Price\r\n     *\/\r\n    function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {\r\n        return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);\r\n    }\r\n\r\n    \/**\r\n     * @notice Gets a 24 hour tracer and oracle price for a given tracer market\r\n     * @return the average price over a 24 hour period for oracle and Tracer price\r\n     *\/\r\n    function get24HourPrices() public view override returns (uint256, uint256) {\r\n        return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));\r\n    }\r\n\r\n    \/**\r\n     * @notice Gets the average tracer price for a given market during a certain hour\r\n     * @param hour The hour of which you want the hourly average Price\r\n     * @return the average price of the tracer for a particular hour\r\n     *\/\r\n    function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {\r\n        return Prices.averagePrice(hourlyTracerPrices[hour]);\r\n    }\r\n\r\n    \/**\r\n     * @notice Gets the average oracle price for a given market during a certain hour\r\n     * @param hour The hour of which you want the hourly average Price\r\n     *\/\r\n    function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {\r\n        return Prices.averagePrice(hourlyOraclePrices[hour]);\r\n    }\r\n\r\n    \/**\r\n     * @dev Used when only valid tracers are allowed\r\n     *\/\r\n    modifier onlyTracer() {\r\n        require(msg.sender == tracer, \"PRC: Only Tracer\");\r\n        _;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-06-tracer#h-01-wrong-trading-pricing-calculations",
                "Location":"recordTrade function. Pricing.sol#L129",
                "Type":"Price oracle manipulation",
                "Description":"Non-AMM price oracle manipulation..In the Pricing contract, an agent can manipulate the trading prices by spamming a high amount of trades. Indeed an agent can create a high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn’t even need large funds); next he/she pairs the orders with another account and calls Trader.executeTrade; now every order calls a Pricing.recordTrade using the arbitrary price set by the agent. Since the trades are all made in the same hour, by the way hourlyTracerPrices[currentHour] is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the fundingRates and the fairPrice, allowing a malicious agent the ability to manipulate the market.",
                "Repair":"Recommend passing the fillAmount parameter to recordTrade(...), and calculate hourlyTracerPrices[currentHour].trades summing fillAmount instead of 1 every trade."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.3;\r\nimport \".\/Pool.sol\";  \r\nimport \".\/interfaces\/iPOOLFACTORY.sol\";\r\n\r\ncontract Synth is iBEP20 {\r\n    address public BASE;\r\n    address public LayerONE; \/\/ Underlying relevant layer1 token\r\n    uint public genesis;\r\n    address public DEPLOYER;\r\n\r\n    string _name; string _symbol;\r\n    uint8 public override decimals; uint256 public override totalSupply;\r\n\r\n    mapping(address => uint) private _balances;\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n    mapping(address => uint) public mapSynth_LPBalance;\r\n    mapping(address => uint) public mapSynth_LPDebt;\r\n   \r\n    function _DAO() internal view returns(iDAO) {\r\n        return iBASE(BASE).DAO();\r\n    }\r\n    \r\n    \/\/ Restrict access\r\n    modifier onlyDAO() {\r\n        require(msg.sender == DEPLOYER, \"!DAO\");\r\n        _;\r\n    }\r\n\r\n    \/\/ Restrict access\r\n    modifier onlyPool() {\r\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, \"!curated\");\r\n        _;\r\n    }\r\n    \r\n    constructor (address _base, address _token) {\r\n        BASE = _base;\r\n        LayerONE = _token;\r\n        string memory synthName = \"-SpartanProtocolSynthetic\";\r\n        string memory synthSymbol = \"-SPS\";\r\n        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));\r\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));\r\n        decimals = iBEP20(_token).decimals();\r\n        DEPLOYER = msg.sender;\r\n        genesis = block.timestamp;\r\n    }\r\n\r\n    \/\/========================================iBEP20=========================================\/\/\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    \/\/ iBEP20 Transfer function\r\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    \/\/ iBEP20 Approve, change allowance functions\r\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"!approval\");\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"!owner\");\r\n        require(spender != address(0), \"!spender\");\r\n        if (_allowances[owner][spender] < type(uint256).max) { \/\/ No need to re-approve if already max\r\n            _allowances[owner][spender] = amount;\r\n            emit Approval(owner, spender, amount);\r\n        }\r\n    }\r\n    \r\n    \/\/ iBEP20 TransferFrom function\r\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        \/\/ Unlimited approval (saves an SSTORE)\r\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\r\n            uint256 currentAllowance = _allowances[sender][msg.sender];\r\n            require(currentAllowance >= amount, \"!approval\");\r\n            _approve(sender, msg.sender, currentAllowance - amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    \/\/iBEP677 approveAndCall\r\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\r\n        _approve(msg.sender, recipient, type(uint256).max); \/\/ Give recipient max approval\r\n        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); \/\/ Amount is passed thru to recipient\r\n        return true;\r\n    }\r\n\r\n    \/\/iBEP677 transferAndCall\r\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); \/\/ Amount is passed thru to recipient \r\n        return true;\r\n    }\r\n\r\n    \/\/ Internal transfer function\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"!sender\");\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"!balance\");\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    \/\/ Internal mint (upgrading and daily emissions)\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"!account\");\r\n        totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    \/\/ Burn supply\r\n    function burn(uint256 amount) external virtual override {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) external virtual {  \r\n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\r\n        _approve(account, msg.sender, decreasedAllowance); \r\n        _burn(account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"!account\");\r\n        require(_balances[account] >= amount, \"!balance\");\r\n        _balances[account] -= amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    \/\/==================================== SYNTH FUNCTIONS =================================\/\/\r\n\r\n    \/\/ Handle received LP tokens and mint Synths\r\n    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){\r\n        uint lpUnits = _getAddedLPAmount(msg.sender); \/\/ Get the received LP units\r\n        mapSynth_LPDebt[msg.sender] += amount; \/\/ Increase debt by synth amount\r\n        mapSynth_LPBalance[msg.sender] += lpUnits; \/\/ Increase lp balance by LPs received\r\n        _mint(member, amount); \/\/ Mint the synths & tsf to user\r\n        return amount;\r\n    }\r\n    \r\n    \/\/ Handle received Synths and burn the LPs and Synths\r\n    function burnSynth() external returns (bool){\r\n        uint _syntheticAmount = balanceOf(address(this)); \/\/ Get the received synth units\r\n        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) \/ mapSynth_LPDebt[msg.sender]; \/\/ share = amount * part\/total\r\n        mapSynth_LPBalance[msg.sender] -= _amountUnits; \/\/ Reduce lp balance\r\n        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; \/\/ Reduce debt by synths being burnt\r\n        if(_amountUnits > 0){\r\n            _burn(address(this), _syntheticAmount); \/\/ Burn the synths\r\n            Pool(msg.sender).burn(_amountUnits); \/\/ Burn the LP tokens\r\n        }\r\n        return true;\r\n    }\r\n\r\n    \/\/ Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)\r\n    function realise(address pool) external {\r\n        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); \/\/ Get the SPARTA value of the LP tokens\r\n        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); \/\/ Get the SPARTA value of the synths\r\n        if(baseValueLP > baseValueSynth){\r\n            uint premium = baseValueLP - baseValueSynth; \/\/ Get the premium between the two values\r\n            if(premium > 10**18){\r\n                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); \/\/ Get the LP value of the premium\r\n                mapSynth_LPBalance[pool] -= premiumLP; \/\/ Reduce the LP balance\r\n                Pool(pool).burn(premiumLP); \/\/ Burn the premium of the LP tokens\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/ Check the received token amount\r\n    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){\r\n        if(_amount > 0) {\r\n            uint startBal = iBEP20(_token).balanceOf(address(this)); \/\/ Get existing balance\r\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); \/\/ Transfer tokens in\r\n            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; \/\/ Calculate received amount\r\n        }\r\n        return _actual;\r\n    }\r\n\r\n    \/\/ Check the received LP tokens amount\r\n    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){\r\n        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); \/\/ Get total balance held\r\n        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){\r\n            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; \/\/ Get received amount\r\n        } else {\r\n            _actual = 0;\r\n        }\r\n        return _actual;\r\n    }\r\n\r\n    function getmapAddress_LPBalance(address pool) external view returns (uint){\r\n        return mapSynth_LPBalance[pool];\r\n    }\r\n\r\n    function getmapAddress_LPDebt(address pool) external view returns (uint){\r\n        return mapSynth_LPDebt[pool];\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-07-spartan#h-05-synth-realise-is-vulnerable-to-flash-loan-attacks",
                "Location":"realise fucntion",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.Synth realise function calculates baseValueLP and baseValueSynth base on AMM spot price which is vulnerable to flash loan attack. Synth’s lp is subject to realise whenever the AMM ratio is different than Synth’s debt ratio. The attack does not necessarily require a flash loan. A big whale of the lp token holders could keep calling realise by shifting token ratio of AMM pool back and forth. The vulnerability is located at Synth.sol L187-L199. Where the formula here is dangerous.",
                "Repair":"There are a few steps that might solve the issue: calculate token’s price from a reliable source. Implement a TWAP oracle or uses chainlink oracle. calculate lp token value based on anti-flashloan formula. Alpha finance’s formula is a good reference: https://blog.alphafinance.io/fair-lp-token-pricing"
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.3;\r\nimport \".\/interfaces\/iBEP20.sol\";\r\nimport \".\/interfaces\/iDAO.sol\";\r\nimport \".\/interfaces\/iBASE.sol\";\r\nimport \".\/interfaces\/iPOOL.sol\";\r\nimport \".\/interfaces\/iSYNTH.sol\";\r\nimport \".\/interfaces\/iUTILS.sol\";\r\nimport \".\/interfaces\/iRESERVE.sol\";\r\nimport \".\/interfaces\/iSYNTHFACTORY.sol\";\r\nimport \".\/interfaces\/iPOOLFACTORY.sol\";\r\n\r\ncontract SynthVault {\r\n    address public BASE;\r\n    address public DEPLOYER;\r\n\r\n    uint256 public minimumDepositTime;  \/\/ Withdrawal & Harvest lockout period; intended to be 1 hour\r\n    uint256 public totalWeight;         \/\/ Total weight of the whole SynthVault\r\n    uint256 public erasToEarn;          \/\/ Amount of eras that make up the targeted RESERVE depletion; regulates incentives\r\n    uint256 public vaultClaim;          \/\/ The SynthVaults's portion of rewards; intended to be ~10% initially\r\n    address [] public stakedSynthAssets; \/\/ Array of all synth assets that have ever been staked in (scope: vault)\r\n    uint private lastMonth;             \/\/ Timestamp of the start of current metric period (For UI)\r\n    uint public genesis;                \/\/ Timestamp from when the synth was first deployed (For UI)\r\n\r\n    uint256 public map30DVaultRevenue; \/\/ Tally of revenue during current incomplete metric period (for UI)\r\n    uint256 public mapPast30DVaultRevenue; \/\/ Tally of revenue from last full metric period (for UI)\r\n    uint256 [] public revenueArray; \/\/ Array of the last two metric periods (For UI)\r\n\r\n    \/\/ Restrict access\r\n    modifier onlyDAO() {\r\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\r\n        _;\r\n    }\r\n\r\n    constructor(address _base) {\r\n        BASE = _base;\r\n        DEPLOYER = msg.sender;\r\n        erasToEarn = 30;\r\n        minimumDepositTime = 3600; \/\/ 1 hour\r\n        vaultClaim = 1000;\r\n        genesis = block.timestamp;\r\n        lastMonth = 0;\r\n    }\r\n\r\n    function _DAO() internal view returns(iDAO) {\r\n        return iBASE(BASE).DAO();\r\n    }\r\n\r\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;\r\n    mapping(address => uint256) private mapMemberTotal_weight;\r\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;\r\n\r\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;\r\n    mapping(address => uint256) private mapMember_depositTime;\r\n    mapping(address => uint256) public lastBlock;\r\n    mapping(address => bool) private isStakedSynth;\r\n    mapping(address => mapping(address => bool)) private isSynthMember;\r\n\r\n    event MemberDeposits(\r\n        address indexed synth,\r\n        address indexed member,\r\n        uint256 newDeposit,\r\n        uint256 weight,\r\n        uint256 totalWeight\r\n    );\r\n    event MemberWithdraws(\r\n        address indexed synth,\r\n        address indexed member,\r\n        uint256 amount,\r\n        uint256 weight,\r\n        uint256 totalWeight\r\n    );\r\n    event MemberHarvests(\r\n        address indexed synth,\r\n        address indexed member,\r\n        uint256 amount,\r\n        uint256 weight,\r\n        uint256 totalWeight\r\n    );\r\n\r\n    function setParams(uint256 one, uint256 two, uint256 three) external onlyDAO {\r\n        erasToEarn = one;\r\n        minimumDepositTime = two;\r\n        vaultClaim = three;\r\n    }\r\n\r\n    \/\/====================================== DEPOSIT ========================================\/\/\r\n\r\n    \/\/ User deposits Synths in the SynthVault\r\n    function deposit(address synth, uint256 amount) external {\r\n        depositForMember(synth, msg.sender, amount);\r\n    }\r\n\r\n    \/\/ Contract deposits Synths in the SynthVault for user\r\n    function depositForMember(address synth, address member, uint256 amount) public {\r\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), \"!synth\"); \/\/ Must be a valid synth\r\n        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); \/\/ Must successfuly transfer in\r\n        _deposit(synth, member, amount); \/\/ Assess and record the deposit\r\n    }\r\n\r\n    \/\/ Check and record the deposit\r\n    function _deposit(address _synth, address _member, uint256 _amount) internal {\r\n        if(!isStakedSynth[_synth]){\r\n            isStakedSynth[_synth] = true; \/\/ Record as a staked synth\r\n            stakedSynthAssets.push(_synth); \/\/ Add to staked synth array\r\n        }\r\n        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; \/\/ Record deposit time (scope: member -> synth)\r\n        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; \/\/ Record deposit time (scope: member)\r\n        mapMemberSynth_deposit[_member][_synth] += _amount; \/\/ Record balance for member\r\n        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); \/\/ Get the SPARTA weight of the deposit\r\n        mapMemberSynth_weight[_member][_synth] += _weight; \/\/ Add the weight to the user (scope: member -> synth)\r\n        mapMemberTotal_weight[_member] += _weight; \/\/ Add to the user's total weight (scope: member)\r\n        totalWeight += _weight; \/\/ Add to the total weight (scope: vault)\r\n        isSynthMember[_member][_synth] = true; \/\/ Record user as a member\r\n        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);\r\n    }\r\n\r\n    \/\/====================================== HARVEST ========================================\/\/\r\n\r\n    \/\/ User harvests all of their available rewards\r\n    function harvestAll() external returns (bool) {\r\n        for(uint i = 0; i < stakedSynthAssets.length; i++){\r\n            if((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){\r\n                uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);\r\n                if(reward > 0){\r\n                    harvestSingle(stakedSynthAssets[i]);\r\n                }\r\n            }\r\n            \r\n        }\r\n        return true;\r\n    }\r\n\r\n    \/\/ User harvests available rewards of the chosen asset\r\n    function harvestSingle(address synth) public returns (bool) {\r\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), \"!synth\"); \/\/ Must be valid synth\r\n        require(iRESERVE(_DAO().RESERVE()).emissions(), \"!emissions\"); \/\/ RESERVE emissions must be on\r\n        uint256 _weight;\r\n        uint256 reward = calcCurrentReward(synth, msg.sender); \/\/ Calc user's current SPARTA reward\r\n        mapMemberSynth_lastTime[msg.sender][synth] = block.timestamp; \/\/ Set last harvest time as now\r\n        address _poolOUT = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(iSYNTH(synth).LayerONE()); \/\/ Get pool address\r\n        iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT); \/\/ Send the SPARTA from RESERVE to POOL\r\n        (uint synthReward,) = iPOOL(_poolOUT).mintSynth(synth, address(this)); \/\/ Mint synths & tsf to SynthVault\r\n        _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(synth).LayerONE(), synthReward); \/\/ Calc reward's SPARTA value\r\n        mapMemberSynth_deposit[msg.sender][synth] += synthReward; \/\/ Record deposit for the user (scope: member -> synth)\r\n        mapMemberSynth_weight[msg.sender][synth] += _weight; \/\/ Add the weight to the user (scope: member -> synth)\r\n        mapMemberTotal_weight[msg.sender] += _weight; \/\/ Add to the user's total weight (scope: member)\r\n        totalWeight += _weight; \/\/ Add to the total weight (scope: vault)\r\n        _addVaultMetrics(reward); \/\/ Add to the revenue metrics (for UI)\r\n        iSYNTH(synth).realise(_poolOUT); \/\/ Check synth-held LP value for premium; burn if so\r\n        emit MemberHarvests(synth, msg.sender, reward, _weight, totalWeight);\r\n        return true;\r\n    }\r\n\r\n    \/\/ Calculate the user's current incentive-claim per era based on selected asset\r\n    function calcCurrentReward(address synth, address member) public view returns (uint256 reward){\r\n        require((block.timestamp > mapMemberSynth_lastTime[member][synth]), \"!unlocked\"); \/\/ Must not harvest before lockup period passed\r\n        uint256 _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]; \/\/ Get seconds passed since last claim\r\n        uint256 _share = calcReward(synth, member); \/\/ Get member's share of RESERVE incentives\r\n        reward = (_share * _secondsSinceClaim) \/ iBASE(BASE).secondsPerEra(); \/\/ User's share times eras since they last claimed\r\n        return reward;\r\n    }\r\n\r\n    \/\/ Calculate the user's current total claimable incentive\r\n    function calcReward(address synth, address member) public view returns (uint256) {\r\n        uint256 _weight = mapMemberSynth_weight[member][synth]; \/\/ Get user's weight (scope: member -> synth)\r\n        uint256 _reserve = reserveBASE() \/ erasToEarn; \/\/ Aim to deplete reserve over a number of days\r\n        uint256 _vaultReward = (_reserve * vaultClaim) \/ 10000; \/\/ Get the SynthVault's share of that\r\n        return iUTILS(_DAO().UTILS()).calcShare(_weight, totalWeight, _vaultReward); \/\/ Get member's share of that\r\n    }\r\n\r\n    \/\/====================================== WITHDRAW ========================================\/\/\r\n\r\n    \/\/ User withdraws a percentage of their synths from the vault\r\n    function withdraw(address synth, uint256 basisPoints) external returns (uint256 redeemedAmount) {\r\n        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints); \/\/ Perform the withdrawal\r\n        require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); \/\/ Transfer from SynthVault to user\r\n        return redeemedAmount;\r\n    }\r\n\r\n    \/\/ Contract withdraws a percentage of user's synths from the vault\r\n    function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {\r\n        require((block.timestamp > mapMember_depositTime[_member]), \"lockout\"); \/\/ Must not withdraw before lockup period passed\r\n        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); \/\/ Calc amount to withdraw\r\n        mapMemberSynth_deposit[_member][_synth] -= _principle; \/\/ Remove from user's recorded vault holdings\r\n        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); \/\/ Calc SPARTA value of amount\r\n        mapMemberTotal_weight[_member] -= _weight; \/\/ Remove from member's total weight (scope: member)\r\n        mapMemberSynth_weight[_member][_synth] -= _weight; \/\/ Remove from member's synth weight (scope: member -> synth)\r\n        totalWeight -= _weight; \/\/ Remove from total weight (scope: vault)\r\n        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);\r\n        return (_principle + synthReward);\r\n    }\r\n\r\n    \/\/================================ Helper Functions ===============================\/\/\r\n\r\n    function reserveBASE() public view returns (uint256) {\r\n        return iBEP20(BASE).balanceOf(_DAO().RESERVE());\r\n    }\r\n\r\n    function getMemberDeposit(address synth, address member) external view returns (uint256){\r\n        return mapMemberSynth_deposit[member][synth];\r\n    }\r\n\r\n    function getMemberWeight(address member) external view returns (uint256) {\r\n        return mapMemberTotal_weight[member];\r\n    }\r\n\r\n    function getStakeSynthLength() external view returns (uint256) {\r\n        return stakedSynthAssets.length;\r\n    }\r\n\r\n    function getMemberLastTime(address member) external view returns (uint256) {\r\n        return mapMember_depositTime[member];\r\n    }\r\n\r\n    function getMemberLastSynthTime(address synth, address member) external view returns (uint256){\r\n        return mapMemberSynth_lastTime[member][synth];\r\n    }\r\n\r\n    function getMemberSynthWeight(address synth, address member) external view returns (uint256) {\r\n        return mapMemberSynth_weight[member][synth];\r\n    }\r\n\r\n    \/\/=============================== SynthVault Metrics =================================\/\/\r\n\r\n    function _addVaultMetrics(uint256 _fee) internal {\r\n        if(lastMonth == 0){\r\n            lastMonth = block.timestamp;\r\n        }\r\n        if(block.timestamp <= lastMonth + 2592000){ \/\/ 30 days\r\n            map30DVaultRevenue = map30DVaultRevenue + _fee;\r\n        } else {\r\n            lastMonth = block.timestamp;\r\n            mapPast30DVaultRevenue = map30DVaultRevenue;\r\n            addRevenue(mapPast30DVaultRevenue);\r\n            map30DVaultRevenue = 0;\r\n            map30DVaultRevenue = map30DVaultRevenue + _fee;\r\n        }\r\n    }\r\n\r\n    function addRevenue(uint _totalRev) internal {\r\n        if(!(revenueArray.length == 2)){\r\n            revenueArray.push(_totalRev);\r\n        } else {\r\n            addFee(_totalRev);\r\n        }\r\n    }\r\n\r\n    function addFee(uint _rev) internal {\r\n        uint _n = revenueArray.length; \/\/ 2\r\n        for (uint i = _n - 1; i > 0; i--) {\r\n            revenueArray[i] = revenueArray[i - 1];\r\n        }\r\n        revenueArray[0] = _rev;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-07-spartan#h-06-synthvault-rewards-can-be-gamed",
                "Location":"SynthVault._deposit",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.The SynthVault._deposit function adds weight for the user that depends on the spot value of the deposit synth amount in BASE. This spot price can be manipulated and the cost of manipulation is relative to the pool’s liquidity. However, the reward (see calcReward) is measured in BASE tokens unrelated to the pool. Therefore, if the pool’s liquidity is low and the reward reserve is high, the attack can be profitable: Manipulate the pool spot price of the iSYNTH(_synth).LayerONE() pool by dripping a lot of BASE into it repeatedly (sending lots of smaller trades is less costly due to the path-independence of the continuous liquidity model). This increases the BASE per token price. Call SynthVault.depositForMember and deposit a small amount of synth token. The iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount) will return an inflated weight due to the price. Optionally drip more BASE into the pool and repeat the deposits Drip back token to the pool to rebalance it The user’s weight is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool’s liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.",
                "Repair":"Recommend tracking a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.3;\r\nimport \".\/interfaces\/iBEP20.sol\";\r\nimport \".\/interfaces\/iUTILS.sol\";\r\nimport \".\/interfaces\/iDAO.sol\";\r\nimport \".\/interfaces\/iBASE.sol\";\r\nimport \".\/interfaces\/iDAOVAULT.sol\";\r\nimport \".\/interfaces\/iROUTER.sol\";\r\nimport \".\/interfaces\/iSYNTH.sol\"; \r\nimport \".\/interfaces\/iSYNTHFACTORY.sol\"; \r\nimport \".\/interfaces\/iBEP677.sol\"; \r\n\r\ncontract Pool is iBEP20 {  \r\n    address public BASE;\r\n    address public TOKEN;\r\n    address public DEPLOYER;\r\n\r\n    string _name; string _symbol;\r\n    uint8 public override decimals; uint256 public override totalSupply;\r\n    mapping(address => uint) private _balances;\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    uint256 public baseAmount; \/\/ SPARTA amount that should be in the pool\r\n    uint256 public tokenAmount; \/\/ TOKEN amount that should be in the pool\r\n\r\n    uint private lastMonth; \/\/ Timestamp of the start of current metric period (For UI)\r\n    uint public genesis; \/\/ Timestamp from when the pool was first deployed (For UI)\r\n\r\n    uint256 public map30DPoolRevenue; \/\/ Tally of revenue during current incomplete metric period (for UI)\r\n    uint256 public mapPast30DPoolRevenue; \/\/ Tally of revenue from last full metric period (for UI)\r\n    uint256 [] public revenueArray; \/\/ Array of the last two metric periods (For UI)\r\n\r\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\r\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\r\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\r\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\r\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\r\n\r\n    function _DAO() internal view returns(iDAO) {\r\n        return iBASE(BASE).DAO();\r\n    }\r\n\r\n    constructor (address _base, address _token) {\r\n        BASE = _base;\r\n        TOKEN = _token;\r\n        string memory poolName = \"-SpartanProtocolPool\";\r\n        string memory poolSymbol = \"-SPP\";\r\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\r\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\r\n        decimals = 18;\r\n        genesis = block.timestamp;\r\n        DEPLOYER = msg.sender;\r\n        lastMonth = 0;\r\n    }\r\n\r\n    \/\/========================================iBEP20=========================================\/\/\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"!approval\");\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"!owner\");\r\n        require(spender != address(0), \"!spender\");\r\n        if (_allowances[owner][spender] < type(uint256).max) { \/\/ No need to re-approve if already max\r\n            _allowances[owner][spender] = amount;\r\n            emit Approval(owner, spender, amount);\r\n        }\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        \/\/ Max approval (saves an SSTORE)\r\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\r\n            uint256 currentAllowance = _allowances[sender][msg.sender];\r\n            require(currentAllowance >= amount, \"!approval\");\r\n            _approve(sender, msg.sender, currentAllowance - amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    \/\/iBEP677 approveAndCall\r\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\r\n      _approve(msg.sender, recipient, type(uint256).max); \/\/ Give recipient max approval\r\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); \/\/ Amount is passed thru to recipient\r\n      return true;\r\n    }\r\n\r\n    \/\/iBEP677 transferAndCall\r\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\r\n      _transfer(msg.sender, recipient, amount);\r\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); \/\/ Amount is passed thru to recipient \r\n      return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"!sender\");\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"!balance\");\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"!account\");\r\n        totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external virtual override {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) external virtual {  \r\n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\r\n        _approve(account, msg.sender, decreasedAllowance); \r\n        _burn(account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"!account\");\r\n        require(_balances[account] >= amount, \"!balance\");\r\n        _balances[account] -= amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    \/\/====================================POOL FUNCTIONS =================================\/\/\r\n\r\n    \/\/ User adds liquidity to the pool\r\n    function add() external returns(uint liquidityUnits){\r\n        liquidityUnits = addForMember(msg.sender);\r\n        return liquidityUnits;\r\n    }\r\n\r\n    \/\/ Contract adds liquidity for user \r\n    function addForMember(address member) public returns(uint liquidityUnits){\r\n        uint256 _actualInputBase = _getAddedBaseAmount(); \/\/ Get the received SPARTA amount\r\n        uint256 _actualInputToken = _getAddedTokenAmount(); \/\/ Get the received TOKEN amount\r\n        if(baseAmount == 0 || tokenAmount == 0){\r\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\r\n        }\r\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); \/\/ Calculate LP tokens to mint\r\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); \/\/ Update recorded BASE and TOKEN amounts\r\n        _mint(member, liquidityUnits); \/\/ Mint the LP tokens directly to the user\r\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\r\n        return liquidityUnits;\r\n    }\r\n    \r\n    \/\/ User removes liquidity from the pool \r\n    function remove() external returns (uint outputBase, uint outputToken) {\r\n        return removeForMember(msg.sender);\r\n    } \r\n\r\n    \/\/ Contract removes liquidity for the user\r\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\r\n        uint256 _actualInputUnits = balanceOf(address(this)); \/\/ Get the received LP units amount\r\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); \/\/ Get the SPARTA value of LP units\r\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); \/\/ Get the TOKEN value of LP units\r\n        _decrementPoolBalances(outputBase, outputToken); \/\/ Update recorded BASE and TOKEN amounts\r\n        _burn(address(this), _actualInputUnits); \/\/ Burn the LP tokens\r\n        iBEP20(BASE).transfer(member, outputBase); \/\/ Transfer the SPARTA to user\r\n        iBEP20(TOKEN).transfer(member, outputToken); \/\/ Transfer the TOKENs to user\r\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\r\n        return (outputBase, outputToken);\r\n    }\r\n\r\n    \/\/ Caller swaps tokens\r\n    function swap(address token) external returns (uint outputAmount, uint fee){\r\n        (outputAmount, fee) = swapTo(token, msg.sender);\r\n        return (outputAmount, fee);\r\n    }\r\n\r\n    \/\/ Contract swaps tokens for the member\r\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\r\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); \/\/ Must be SPARTA or the pool's relevant TOKEN\r\n        address _fromToken; uint _amount;\r\n        if(token == BASE){\r\n            _fromToken = TOKEN; \/\/ If SPARTA is selected; swap from TOKEN\r\n            _amount = _getAddedTokenAmount(); \/\/ Get the received TOKEN amount\r\n            (outputAmount, fee) = _swapTokenToBase(_amount); \/\/ Calculate the SPARTA output from the swap\r\n        } else {\r\n            _fromToken = BASE; \/\/ If TOKEN is selected; swap from SPARTA\r\n            _amount = _getAddedBaseAmount(); \/\/ Get the received SPARTA amount\r\n            (outputAmount, fee) = _swapBaseToToken(_amount); \/\/ Calculate the TOKEN output from the swap\r\n        }\r\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\r\n        iBEP20(token).transfer(member, outputAmount); \/\/ Transfer the swap output to the selected user\r\n        return (outputAmount, fee);\r\n    }\r\n\r\n    \/\/ Swap SPARTA for Synths\r\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\r\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); \/\/ Must be a valid Synth\r\n        uint256 _actualInputBase = _getAddedBaseAmount(); \/\/ Get received SPARTA amount\r\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); \/\/ Calculate value of swapping SPARTA to the relevant underlying TOKEN\r\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); \/\/ Calculate LP tokens to be minted\r\n        _incrementPoolBalances(_actualInputBase, 0); \/\/ Update recorded SPARTA amount\r\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); \/\/ Calc slip fee in TOKEN\r\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); \/\/ Convert TOKEN fee to SPARTA\r\n        _mint(synthOut, _liquidityUnits); \/\/ Mint the LP tokens directly to the Synth contract to hold\r\n        iSYNTH(synthOut).mintSynth(member, output); \/\/ Mint the Synth tokens directly to the user\r\n        _addPoolMetrics(fee); \/\/ Add slip fee to the revenue metrics\r\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\r\n      return (output, fee);\r\n    }\r\n    \r\n    \/\/ Swap Synths for SPARTA\r\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\r\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); \/\/ Must be a valid Synth\r\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); \/\/ Get received SYNTH amount\r\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); \/\/ Calculate value of swapping relevant underlying TOKEN to SPARTA\r\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); \/\/ Calc slip fee in SPARTA\r\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); \/\/ Transfer SYNTH to relevant synth contract\r\n        iSYNTH(synthIN).burnSynth(); \/\/ Burn the SYNTH units\r\n        _decrementPoolBalances(outputBase, 0); \/\/ Update recorded SPARTA amount\r\n        iBEP20(BASE).transfer(member, outputBase); \/\/ Transfer SPARTA to user\r\n        _addPoolMetrics(fee); \/\/ Add slip fee to the revenue metrics\r\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\r\n      return (outputBase, fee);\r\n    }\r\n\r\n    \/\/=======================================INTERNAL MATHS======================================\/\/\r\n\r\n    \/\/ Check the SPARTA amount received by this Pool\r\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\r\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \r\n        if(_baseBalance > baseAmount){\r\n            _actual = _baseBalance-(baseAmount);\r\n        } else {\r\n            _actual = 0;\r\n        }\r\n        return _actual;\r\n    }\r\n  \r\n    \/\/ Check the TOKEN amount received by this Pool\r\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\r\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \r\n        if(_tokenBalance > tokenAmount){\r\n            _actual = _tokenBalance-(tokenAmount);\r\n        } else {\r\n            _actual = 0;\r\n        }\r\n        return _actual;\r\n    }\r\n\r\n    \/\/ Calculate output of swapping SPARTA for TOKEN & update recorded amounts\r\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\r\n        uint256 _X = baseAmount;\r\n        uint256 _Y = tokenAmount;\r\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); \/\/ Calc TOKEN output\r\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); \/\/ Calc TOKEN fee\r\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); \/\/ Convert TOKEN fee to SPARTA\r\n        _setPoolAmounts(_X + _x, _Y - _y); \/\/ Update recorded BASE and TOKEN amounts\r\n        _addPoolMetrics(_fee); \/\/ Add slip fee to the revenue metrics\r\n        return (_y, _fee);\r\n    }\r\n\r\n    \/\/ Calculate output of swapping TOKEN for SPARTA & update recorded amounts\r\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\r\n        uint256 _X = tokenAmount;\r\n        uint256 _Y = baseAmount;\r\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); \/\/ Calc SPARTA output\r\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); \/\/ Calc SPARTA fee\r\n        _setPoolAmounts(_Y - _y, _X + _x); \/\/ Update recorded BASE and TOKEN amounts\r\n        _addPoolMetrics(_fee); \/\/ Add slip fee to the revenue metrics\r\n        return (_y, _fee);\r\n    }\r\n\r\n    \/\/=======================================BALANCES=========================================\/\/\r\n\r\n    \/\/ Sync internal balances to actual\r\n    function sync() external {\r\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\r\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\r\n    }\r\n\r\n    \/\/ Increment internal balances\r\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\r\n        baseAmount += _baseAmount;\r\n        tokenAmount += _tokenAmount;\r\n    }\r\n\r\n    \/\/ Set internal balances\r\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\r\n        baseAmount = _baseAmount;\r\n        tokenAmount = _tokenAmount; \r\n    }\r\n\r\n    \/\/ Decrement internal balances\r\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\r\n        baseAmount -= _baseAmount;\r\n        tokenAmount -= _tokenAmount; \r\n    }\r\n\r\n    \/\/===========================================POOL FEE ROI=================================\/\/\r\n\r\n    function _addPoolMetrics(uint256 _fee) internal {\r\n        if(lastMonth == 0){\r\n            lastMonth = block.timestamp;\r\n        }\r\n        if(block.timestamp <= lastMonth + 2592000){ \/\/ 30Days\r\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\r\n        } else {\r\n            lastMonth = block.timestamp;\r\n            mapPast30DPoolRevenue = map30DPoolRevenue;\r\n            addRevenue(mapPast30DPoolRevenue);\r\n            map30DPoolRevenue = 0;\r\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\r\n        }\r\n    }\r\n\r\n    function addRevenue(uint _totalRev) internal {\r\n        if(!(revenueArray.length == 2)){\r\n            revenueArray.push(_totalRev);\r\n        } else {\r\n            addFee(_totalRev);\r\n        }\r\n    }\r\n\r\n    function addFee(uint _rev) internal {\r\n        uint _n = revenueArray.length; \/\/ 2\r\n        for (uint i = _n - 1; i > 0; i--) {\r\n            revenueArray[i] = revenueArray[i - 1];\r\n        }\r\n        revenueArray[0] = _rev;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-07-spartan#h-07-missing-slippage-checks",
                "Location":"Missing slippage checks",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.",
                "Repair":"Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn’t obtained."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.3;\r\nimport \".\/interfaces\/iBASE.sol\";\r\nimport \".\/interfaces\/iPOOLFACTORY.sol\";\r\nimport \".\/interfaces\/iPOOL.sol\";\r\nimport \".\/interfaces\/iSYNTH.sol\";\r\nimport \".\/interfaces\/iBEP20.sol\";\r\n\r\ncontract Utils {\r\n    address public BASE;\r\n    uint public one = 10**18;\r\n\r\n    constructor (address _base) {\r\n        BASE = _base;\r\n    }\r\n\r\n    struct PoolDataStruct {\r\n        address tokenAddress;\r\n        address poolAddress;\r\n        uint genesis;\r\n        uint baseAmount;\r\n        uint tokenAmount;\r\n        uint fees;\r\n        uint volume;\r\n        uint txCount;\r\n        uint poolUnits;\r\n    }\r\n\r\n    function _DAO() internal view returns(iDAO) {\r\n        return iBASE(BASE).DAO();\r\n    }\r\n\r\n    \/\/================================== HELPERS ================================\/\/\r\n\r\n    function getPoolData(address token) external view returns(PoolDataStruct memory poolData){\r\n        address pool = getPool(token);\r\n        poolData.poolAddress = pool;\r\n        poolData.tokenAddress = token;\r\n        poolData.genesis = iPOOL(pool).genesis();\r\n        poolData.baseAmount = iPOOL(pool).baseAmount();\r\n        poolData.tokenAmount = iPOOL(pool).tokenAmount();\r\n        poolData.poolUnits = iBEP20(pool).totalSupply();\r\n        return poolData;\r\n    }\r\n\r\n    function getPoolShareWeight(address token, uint units) external view returns(uint weight){\r\n        address pool = getPool(token);\r\n        weight = calcShare(units, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());\r\n        return (weight);\r\n    }\r\n\r\n    function getPool(address token) public view returns(address pool){\r\n        return iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);\r\n    }\r\n\r\n    \/\/================================== CORE-MATH ==================================\/\/\r\n    \r\n    \/\/ Calculate the feeBurn's feeOnTransfer based on total supply\r\n    function getFeeOnTransfer(uint256 totalSupply, uint256 maxSupply) external pure returns (uint256) {\r\n        return calcShare(totalSupply, maxSupply, 100); \/\/ 0 -> 100bp\r\n    }\r\n\r\n    \/\/ Calculate 'part' of a total using basis points | 10,000 basis points = 100.00%\r\n    function calcPart(uint256 bp, uint256 total) external pure returns (uint256) {\r\n        require(bp <= 10000, \"!bp\"); \/\/ basis points must be valid\r\n        return calcShare(bp, 10000, total);\r\n    }\r\n\r\n    \/\/ Calc share | share = amount * part \/ total\r\n    function calcShare(uint256 part, uint256 total, uint256 amount) public pure returns (uint256 share) {\r\n        if (part > total) {\r\n            part = total; \/\/ Part cant be greater than the total\r\n        }\r\n        if (total > 0) {\r\n            share = (amount * part) \/ total;\r\n        }\r\n    }\r\n\r\n    \/\/ Calculate liquidity units\r\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint units){\r\n        if(P == 0){\r\n            return b; \/\/ If pool is empty; use b as initial units\r\n        } else {\r\n            \/\/ units = ((P (t B + T b))\/(2 T B)) * slipAdjustment\r\n            \/\/ P * (part1 + part2) \/ (part3) * slipAdjustment\r\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\r\n            uint part1 = t*(B);\r\n            uint part2 = T*(b);\r\n            uint part3 = T*(B)*(2);\r\n            uint _units = (P * (part1 + (part2))) \/ (part3);\r\n            return _units * slipAdjustment \/ one;  \/\/ Divide by 10**18\r\n        }\r\n    }\r\n\r\n    \/\/ Get slip adjustment\r\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint slipAdjustment){\r\n        \/\/ slipAdjustment = (1 - ABS((B t - b T)\/((2 b + B) (t + T))))\r\n        \/\/ 1 - ABS(part1 - part2)\/(part3 * part4))\r\n        uint part1 = B * (t);\r\n        uint part2 = b * (T);\r\n        uint part3 = b * (2) + (B);\r\n        uint part4 = t + (T);\r\n        uint numerator;\r\n        if(part1 > part2){\r\n            numerator = part1 - (part2);\r\n        } else {\r\n            numerator = part2 - (part1);\r\n        }\r\n        uint denominator = part3 * (part4);\r\n        return one - ((numerator * (one)) \/ (denominator)); \/\/ Multiply by 10**18\r\n    }\r\n\r\n    \/\/ Calculate symmetrical redemption value of LP tokens (per side)\r\n    function calcLiquidityHoldings(uint units, address token, address pool) external view returns (uint share){\r\n        \/\/ share = amount * part \/ total\r\n        \/\/ address pool = getPool(token);\r\n        uint amount;\r\n        if(token == BASE){\r\n            amount = iPOOL(pool).baseAmount();\r\n        } else {\r\n            amount = iPOOL(pool).tokenAmount();\r\n        }\r\n        uint totalSupply = iBEP20(pool).totalSupply();\r\n        return(amount*(units))\/(totalSupply);\r\n    }\r\n\r\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint output){\r\n        \/\/ y = (x * X * Y )\/(x + X)^2\r\n        uint numerator = x * (X * (Y));\r\n        uint denominator = (x + (X)) * (x + (X));\r\n        return numerator \/ (denominator);\r\n    }\r\n\r\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint output){\r\n        \/\/ y = (x * x * Y) \/ (x + X)^2\r\n        uint numerator = x * (x * (Y));\r\n        uint denominator = (x + (X)) * (x + (X));\r\n        return numerator \/ (denominator);\r\n    }\r\n\r\n    \/\/ Calculate asymmetrical redemption value of LP tokens (remove all to TOKEN)\r\n    function calcAsymmetricValueToken(address pool, uint amount) external view returns (uint tokenValue){\r\n        uint baseAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());\r\n        uint tokenAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).tokenAmount());\r\n        uint baseSwapped = calcSwapValueInTokenWithPool(pool, baseAmount);\r\n        tokenValue = tokenAmount + baseSwapped;\r\n        return tokenValue;\r\n    }\r\n\r\n    function calcLiquidityUnitsAsym(uint amount, address pool) external view returns (uint units){\r\n        \/\/ synthUnits += (P b)\/(2 (b + B))\r\n        uint baseAmount = iPOOL(pool).baseAmount();\r\n        uint totalSupply = iBEP20(pool).totalSupply();\r\n        uint two = 2;\r\n        return (totalSupply * amount) \/ (two * (amount + baseAmount));\r\n    }\r\n\r\n    \/\/==================================== PRICING ====================================\/\/\r\n\r\n    function calcSpotValueInBase(address token, uint amount) external view returns (uint value){\r\n        address pool = getPool(token);\r\n        return calcSpotValueInBaseWithPool(pool, amount);\r\n    }\r\n\r\n    function calcSpotValueInToken(address token, uint amount) external view returns (uint value){\r\n        address pool = getPool(token);\r\n        return calcSpotValueInTokenWithPool(pool, amount);\r\n    }\r\n\r\n    function calcSwapValueInBase(address token, uint amount) external view returns (uint _output){\r\n        address pool = getPool(token);\r\n        return  calcSwapValueInBaseWithPool(pool, amount);\r\n    }\r\n\r\n    function calcSwapValueInBaseWithSYNTH(address synth, uint amount) external view returns (uint _output){\r\n        address token = iSYNTH(synth).LayerONE();\r\n        address pool = getPool(token);\r\n        return  calcSwapValueInBaseWithPool(pool, amount);\r\n    }\r\n\r\n    function calcSwapValueInToken(address token, uint amount) external view returns (uint _output){\r\n        address pool = getPool(token);\r\n        return  calcSwapValueInTokenWithPool(pool, amount);\r\n    }\r\n\r\n    function calcSpotValueInBaseWithPool(address pool, uint amount) public view returns (uint value){\r\n        uint _baseAmount = iPOOL(pool).baseAmount();\r\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\r\n        return (amount*(_baseAmount))\/(_tokenAmount);\r\n    }\r\n\r\n    function calcSpotValueInTokenWithPool(address pool, uint amount) public view returns (uint value){\r\n        uint _baseAmount = iPOOL(pool).baseAmount();\r\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\r\n        return (amount*(_tokenAmount))\/(_baseAmount);\r\n    }\r\n\r\n    function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){\r\n        uint _baseAmount = iPOOL(pool).baseAmount();\r\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\r\n        return  calcSwapOutput(amount, _tokenAmount, _baseAmount);\r\n    }\r\n\r\n    function calcSwapValueInTokenWithPool(address pool, uint amount) public view returns (uint _output){\r\n        uint _baseAmount = iPOOL(pool).baseAmount();\r\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\r\n        return  calcSwapOutput(amount, _baseAmount, _tokenAmount);\r\n    }\r\n\r\n    function calcActualSynthUnits(uint amount, address synth) external view returns (uint _output) {\r\n        address token = iSYNTH(synth).LayerONE();\r\n        address pool = getPool(token);\r\n        uint _baseAmount = iPOOL(pool).baseAmount();\r\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\r\n        return ((amount * _baseAmount) \/ (2 * _tokenAmount));\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-07-spartan#h-13-flash-loan-manipulation-on-getpoolshareweight-of-utils",
                "Location":"getPoolShareWeight function",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.The getPoolShareWeight function returns a user’s pool share weight by calculating how many SPARTAN the user’s LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight. According to the implementation of getPoolShareWeight, a user’s pool share weight is calculated by uints * baseAmount / totalSupply, where uints is the number of user’s LP tokens, totalSupply is the total supply of LP tokens, and baseAmount is the number of SPARTAN in the pool. Thus, a user’s pool share weight is proportional to the number of SPARTAN in the pool.",
                "Repair":"Recommended mitigation has been included in contributors ongoing discussions to make this more resistant to manipulation"
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"..\/..\/global\/Types.sol\";\r\nimport \"..\/..\/global\/Constants.sol\";\r\nimport \"..\/markets\/CashGroup.sol\";\r\nimport \"..\/markets\/AssetRate.sol\";\r\nimport \"..\/portfolio\/PortfolioHandler.sol\";\r\nimport \"..\/..\/math\/SafeInt256.sol\";\r\nimport \"..\/..\/math\/ABDKMath64x64.sol\";\r\nimport \"@openzeppelin\/contracts\/math\/SafeMath.sol\";\r\n\r\nlibrary AssetHandler {\r\n    using SafeMath for uint256;\r\n    using SafeInt256 for int256;\r\n    using CashGroup for CashGroupParameters;\r\n    using AssetRate for AssetRateParameters;\r\n\r\n    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\r\n        return\r\n            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\r\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\r\n    }\r\n\r\n    \/\/\/ @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method\r\n    \/\/\/ calculates the settlement date for any PortfolioAsset.\r\n    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\r\n        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); \/\/ dev: settlement date invalid asset type\r\n        \/\/ 3 month tokens and fCash tokens settle at maturity\r\n        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\r\n\r\n        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\r\n        \/\/ Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:\r\n        \/\/ maturity = tRef + marketLength\r\n        \/\/ Here we calculate:\r\n        \/\/ tRef = maturity - marketLength + 90 days\r\n        return asset.maturity.sub(marketLength).add(Constants.QUARTER);\r\n    }\r\n\r\n    \/\/\/ @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.\r\n    \/\/\/ The formula is: notional * e^(-rate * timeToMaturity).\r\n    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        int128 expValue =\r\n            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));\r\n        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\r\n        expValue = ABDKMath64x64.exp(expValue * -1);\r\n        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);\r\n        int256 discountFactor = ABDKMath64x64.toInt(expValue);\r\n\r\n        return discountFactor;\r\n    }\r\n\r\n    \/\/\/ @notice Present value of an fCash asset without any risk adjustments.\r\n    function getPresentValue(\r\n        int256 notional,\r\n        uint256 maturity,\r\n        uint256 blockTime,\r\n        uint256 oracleRate\r\n    ) internal pure returns (int256) {\r\n        if (notional == 0) return 0;\r\n\r\n        uint256 timeToMaturity = maturity.sub(blockTime);\r\n        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);\r\n\r\n        require(discountFactor <= Constants.RATE_PRECISION); \/\/ dev: get present value invalid discount factor\r\n        return notional.mulInRatePrecision(discountFactor);\r\n    }\r\n\r\n    \/\/\/ @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more\r\n    \/\/\/ heavily than the oracle rate given and vice versa for negative fCash.\r\n    function getRiskAdjustedPresentValue(\r\n        CashGroupParameters memory cashGroup,\r\n        int256 notional,\r\n        uint256 maturity,\r\n        uint256 blockTime,\r\n        uint256 oracleRate\r\n    ) internal pure returns (int256) {\r\n        if (notional == 0) return 0;\r\n        uint256 timeToMaturity = maturity.sub(blockTime);\r\n\r\n        int256 discountFactor;\r\n        if (notional > 0) {\r\n            discountFactor = getDiscountFactor(\r\n                timeToMaturity,\r\n                oracleRate.add(cashGroup.getfCashHaircut())\r\n            );\r\n        } else {\r\n            uint256 debtBuffer = cashGroup.getDebtBuffer();\r\n            \/\/ If the adjustment exceeds the oracle rate we floor the value of the fCash\r\n            \/\/ at the notional value. We don't want to require the account to hold more than\r\n            \/\/ absolutely required.\r\n            if (debtBuffer >= oracleRate) return notional;\r\n\r\n            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);\r\n        }\r\n\r\n        require(discountFactor <= Constants.RATE_PRECISION); \/\/ dev: get risk adjusted pv, invalid discount factor\r\n        return notional.mulInRatePrecision(discountFactor);\r\n    }\r\n\r\n    \/\/\/ @notice Returns the non haircut claims on cash and fCash by the liquidity token.\r\n    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\r\n        internal\r\n        pure\r\n        returns (int256 assetCash, int256 fCash)\r\n    {\r\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); \/\/ dev: invalid asset, get cash claims\r\n\r\n        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\r\n        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\r\n    }\r\n\r\n    \/\/\/ @notice Returns the haircut claims on cash and fCash\r\n    \/\/\/ @return (assetCash, fCash)\r\n    function getHaircutCashClaims(\r\n        PortfolioAsset memory token,\r\n        MarketParameters memory market,\r\n        CashGroupParameters memory cashGroup\r\n    ) internal pure returns (int256, int256) {\r\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); \/\/ dev: invalid asset get haircut cash claims\r\n\r\n        require(token.currencyId == cashGroup.currencyId); \/\/ dev: haircut cash claims, currency id mismatch\r\n        \/\/ This won't overflow, the liquidity token haircut is stored as an uint8\r\n        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\r\n\r\n        int256 assetCash =\r\n            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\r\n\r\n        int256 fCash =\r\n            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\r\n\r\n        return (assetCash, fCash);\r\n    }\r\n\r\n    \/\/\/ @dev This is here to clean up the stack in getHaircutCashClaims\r\n    function _calcToken(\r\n        int256 numerator,\r\n        int256 tokens,\r\n        int256 haircut,\r\n        int256 liquidity\r\n    ) private pure returns (int256) {\r\n        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);\r\n    }\r\n\r\n    \/\/\/ @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\r\n    function getLiquidityTokenValue(\r\n        uint256 index,\r\n        CashGroupParameters memory cashGroup,\r\n        MarketParameters memory market,\r\n        PortfolioAsset[] memory assets,\r\n        uint256 blockTime,\r\n        bool riskAdjusted\r\n    ) internal view returns (int256, int256) {\r\n        PortfolioAsset memory liquidityToken = assets[index];\r\n        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); \/\/ dev: get liquidity token value, not liquidity token\r\n\r\n        {\r\n            (uint256 marketIndex, bool idiosyncratic) =\r\n                DateTime.getMarketIndex(\r\n                    cashGroup.maxMarketIndex,\r\n                    liquidityToken.maturity,\r\n                    blockTime\r\n                );\r\n            \/\/ Liquidity tokens can never be idiosyncratic\r\n            require(!idiosyncratic); \/\/ dev: idiosyncratic liquidity token\r\n\r\n            \/\/ This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.\r\n            cashGroup.loadMarket(market, marketIndex, true, blockTime);\r\n        }\r\n\r\n        int256 assetCashClaim;\r\n        int256 fCashClaim;\r\n        if (riskAdjusted) {\r\n            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\r\n        } else {\r\n            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\r\n        }\r\n\r\n        \/\/ Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and\r\n        \/\/ in that case we know the previous asset will be the matching fCash asset\r\n        if (\r\n            index > 0 &&\r\n            assets[index - 1].currencyId == liquidityToken.currencyId &&\r\n            assets[index - 1].maturity == liquidityToken.maturity &&\r\n            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE\r\n        ) {\r\n            \/\/ Net off the fCashClaim here and we will discount it to present value in the second pass.\r\n            \/\/ WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!\r\n            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);\r\n            return (assetCashClaim, 0);\r\n        }\r\n\r\n        \/\/ If not matching fCash asset found then get the pv directly\r\n        if (riskAdjusted) {\r\n            int256 pv =\r\n                getRiskAdjustedPresentValue(\r\n                    cashGroup,\r\n                    fCashClaim,\r\n                    liquidityToken.maturity,\r\n                    blockTime,\r\n                    market.oracleRate\r\n                );\r\n\r\n            return (assetCashClaim, pv);\r\n        } else {\r\n            int256 pv =\r\n                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\r\n\r\n            return (assetCashClaim, pv);\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\r\n    function getNetCashGroupValue(\r\n        PortfolioAsset[] memory assets,\r\n        CashGroupParameters memory cashGroup,\r\n        MarketParameters memory market,\r\n        uint256 blockTime,\r\n        uint256 portfolioIndex\r\n    ) internal view returns (int256, uint256) {\r\n        int256 presentValueAsset;\r\n        int256 presentValueUnderlying;\r\n\r\n        \/\/ First calculate value of liquidity tokens because we need to net off fCash value\r\n        \/\/ before discounting to present value\r\n        for (uint256 i = portfolioIndex; i < assets.length; i++) {\r\n            if (!isLiquidityToken(assets[i].assetType)) continue;\r\n            if (assets[i].currencyId != cashGroup.currencyId) break;\r\n\r\n            (int256 assetCashClaim, int256 pv) =\r\n                getLiquidityTokenValue(\r\n                    i,\r\n                    cashGroup,\r\n                    market,\r\n                    assets,\r\n                    blockTime,\r\n                    true \/\/ risk adjusted\r\n                );\r\n\r\n            presentValueAsset = presentValueAsset.add(assetCashClaim);\r\n            presentValueUnderlying = presentValueUnderlying.add(pv);\r\n        }\r\n\r\n        uint256 j = portfolioIndex;\r\n        for (; j < assets.length; j++) {\r\n            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;\r\n            \/\/ If we hit a different currency id then we've accounted for all assets in this currency\r\n            if (assets[j].currencyId != cashGroup.currencyId) break;\r\n\r\n            uint256 maturity = assets[j].maturity;\r\n            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\r\n\r\n            int256 pv =\r\n                getRiskAdjustedPresentValue(\r\n                    cashGroup,\r\n                    assets[j].notional,\r\n                    maturity,\r\n                    blockTime,\r\n                    oracleRate\r\n                );\r\n            presentValueUnderlying = presentValueUnderlying.add(pv);\r\n        }\r\n\r\n        presentValueAsset = presentValueAsset.add(\r\n            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)\r\n        );\r\n\r\n        return (presentValueAsset, j);\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-08-notional#h-10-liquidity-token-value-can-be-manipulated",
                "Location":"\/\/ @audit token.notional are the LP tokens to redeem\r\nassetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\r\nfCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.The liquidity token value (AssetHandler.getLiquidityTokenValue) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see AssetHandler.getCashClaims / AssetHandler.getHaircutCashClaims.This means the value depends on the current market reserves which can be manipulated. You’re essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.",
                "Repair":"Recommend not using the current market reserves to determine the value of LP tokens. Also, think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@uniswap\/v2-periphery\/contracts\/interfaces\/IUniswapV2Router02.sol\";\r\nimport \"..\/interfaces\/IMochiEngine.sol\";\r\nimport \"..\/interfaces\/ICurveVotingEscrow.sol\";\r\n\r\ncontract MochiTreasuryV0 {\r\n    IMochiEngine public immutable engine;\r\n\r\n    IUniswapV2Router02 public immutable uniswapRouter;\r\n\r\n    IERC20 public immutable crv;\r\n    ICurveVotingEscrow public immutable veCrv;\r\n    bool public lockCrv;\r\n    uint256 public operationShare;\r\n    uint256 public veCRVShare;\r\n\r\n    constructor(\r\n        address _engine,\r\n        address _uniswap,\r\n        address _crv,\r\n        address _veCrv\r\n    ) {\r\n        engine = IMochiEngine(_engine);\r\n        uniswapRouter = IUniswapV2Router02(_uniswap);\r\n        crv = IERC20(_crv);\r\n        veCrv = ICurveVotingEscrow(_veCrv);\r\n        lockCrv = false;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function withdrawCRV() external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        crv.transfer(msg.sender, crv.balanceOf(address(this)));\r\n    }\r\n\r\n    function withdrawLock() external {\r\n        veCrv.withdraw();\r\n    }\r\n\r\n    function veCRVInitialize() external {\r\n        require(lockCrv, \"!lock\");\r\n        updateFee();\r\n        _buyCRV();\r\n        veCrv.create_lock(\r\n            crv.balanceOf(address(this)),\r\n            block.timestamp + 90 days\r\n        );\r\n    }\r\n\r\n    function toggleLocking() external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        lockCrv = !lockCrv;\r\n    }\r\n\r\n    function updateFee() public {\r\n        uint256 updatedFee = engine.usdm().balanceOf(address(this)) -\r\n            operationShare -\r\n            veCRVShare;\r\n        operationShare += updatedFee \/ 2;\r\n        veCRVShare += updatedFee \/ 2;\r\n    }\r\n\r\n    function claimOperationCost() external {\r\n        updateFee();\r\n        engine.usdm().transfer(engine.operationWallet(), operationShare);\r\n        operationShare = 0;\r\n    }\r\n\r\n    function veCRVlock() external {\r\n        require(lockCrv, \"!lock\");\r\n        updateFee();\r\n        _buyCRV();\r\n        _lockCRV();\r\n        veCRVShare = 0;\r\n    }\r\n\r\n    function _buyCRV() internal {\r\n        IUSDM usdm = engine.usdm();\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(usdm);\r\n        path[1] = address(crv);\r\n        usdm.approve(address(uniswapRouter), veCRVShare);\r\n        uniswapRouter.swapExactTokensForTokens(\r\n            veCRVShare,\r\n            1,\r\n            path,\r\n            address(this),\r\n            type(uint256).max\r\n        );\r\n    }\r\n\r\n    function _lockCRV() internal {\r\n        crv.approve(address(veCrv), crv.balanceOf(address(this)));\r\n        veCrv.increase_amount(crv.balanceOf(address(this)));\r\n        veCrv.increase_unlock_time(block.timestamp + 90 days);\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-10-mochi#h-09-treasury-is-vulnerable-to-sandwich-attack",
                "Location":"veCRVlock fuction",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.There’s a permissionless function veCRVlock in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds.",
                "Repair":"Recommend to add onlyOwner modifier."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@uniswap\/v2-periphery\/contracts\/interfaces\/IUniswapV2Router02.sol\";\r\nimport \"..\/interfaces\/IFeePool.sol\";\r\nimport \"..\/interfaces\/IUSDM.sol\";\r\nimport \"..\/interfaces\/IMochiEngine.sol\";\r\n\r\ncontract FeePoolV0 is IFeePool {\r\n    IMochiEngine public immutable engine;\r\n\r\n    IUniswapV2Router02 public immutable uniswapRouter;\r\n\r\n    address public crvVoterRewardPool;\r\n\r\n    uint256 public treasuryRatio;\r\n\r\n    uint256 public vMochiRatio;\r\n\r\n    uint256 public mochiShare;\r\n\r\n    uint256 public treasuryShare;\r\n\r\n    constructor(address _engine, address _uniswap) {\r\n        engine = IMochiEngine(_engine);\r\n        uniswapRouter = IUniswapV2Router02(_uniswap);\r\n        treasuryRatio = 20e16;\r\n        vMochiRatio = 80e16;\r\n    }\r\n\r\n    function updateReserve() external override {\r\n        uint256 newReserve = engine.usdm().balanceOf(address(this)) -\r\n            mochiShare -\r\n            treasuryShare;\r\n        treasuryShare += (newReserve * treasuryRatio) \/ 1e18;\r\n        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;\r\n    }\r\n\r\n    function changecrvVoterRewardPool(address _pool) external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        crvVoterRewardPool = _pool;\r\n    }\r\n\r\n    function changeTreasuryRatio(uint256 _ratio) external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        treasuryRatio = _ratio;\r\n    }\r\n\r\n    function changevMochiRatio(uint256 _ratio) external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        vMochiRatio = _ratio;\r\n    }\r\n\r\n    \/\/ this will open up arb oppertunity for Mochi\r\n    \/\/ so we will not reward the caller, caller can benefit from flashbot\r\n    \/\/ should decide which market we should use UniV2?V3? BalancerV2?\r\n    function distributeMochi() external {\r\n        \/\/ buy Mochi with mochiShare\r\n        _buyMochi();\r\n        _shareMochi();\r\n    }\r\n\r\n    function _buyMochi() internal {\r\n        IUSDM usdm = engine.usdm();\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(usdm);\r\n        path[1] = address(engine.mochi());\r\n        usdm.approve(address(uniswapRouter), mochiShare);\r\n        uniswapRouter.swapExactTokensForTokens(\r\n            mochiShare,\r\n            1,\r\n            path,\r\n            address(this),\r\n            type(uint256).max\r\n        );\r\n    }\r\n\r\n    function _shareMochi() internal {\r\n        IMochi mochi = engine.mochi();\r\n        uint256 mochiBalance = mochi.balanceOf(address(this));\r\n        \/\/ send Mochi to vMochi Vault\r\n        mochi.transfer(\r\n            address(engine.vMochi()),\r\n            (mochiBalance * vMochiRatio) \/ 1e18\r\n        );\r\n        \/\/ send Mochi to veCRV Holders\r\n        mochi.transfer(\r\n            crvVoterRewardPool,\r\n            (mochiBalance * (1e18 - vMochiRatio)) \/ 1e18\r\n        );\r\n        \/\/ flush mochiShare\r\n        mochiShare = 0;\r\n        treasuryShare = 0;\r\n    }\r\n\r\n    function sendToTreasury() external {\r\n        engine.usdm().transfer(engine.treasury(), treasuryShare);\r\n        treasuryShare = 0;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-10-mochi#h-12-feepool-is-vulnerable-to-sandwich-attack",
                "Location":"distributeMochi function",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.There’s a permissionless function distributeMochi in FeePoolV0.sol L55-L62. Since everyone can trigger this function, an attacker can launch a sandwich attack with flashloan to steal the funds. The devs have mentioned this concern in the comment. An attacker can steal the funds with a flash loan attack.",
                "Repair":"If the dev wants to make this a permissionless control, the contract should calculate a min return based on TWAP and check the slippage."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\n\r\nimport \".\/BasePoolV2.sol\";\r\n\r\nimport \"..\/..\/interfaces\/shared\/IERC20Extended.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/pool\/IVaderPoolV2.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/wrapper\/ILPWrapper.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/synth\/ISynthFactory.sol\";\r\n\r\n\/*\r\n * @dev Implementation of {VaderPoolV2} contract.\r\n *\r\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\r\n * queue system.\r\n *\r\n * Extends on the liquidity redeeming function by introducing the `burn` function\r\n * that internally calls the namesake on `BasePoolV2` contract and computes the\r\n * loss covered by the position being redeemed and returns it along with amounts\r\n * of native and foreign assets sent.\r\n **\/\r\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\r\n    \/* ========== LIBRARIES ========== *\/\r\n\r\n    \/\/ Used for safe token transfers\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/* ========== STATE VARIABLES ========== *\/\r\n\r\n    \/\/ The LP wrapper contract\r\n    ILPWrapper public wrapper;\r\n\r\n    \/\/ The Synth Factory\r\n    ISynthFactory public synthFactory;\r\n\r\n    \/\/ Denotes whether the queue system is active\r\n    bool public queueActive;\r\n\r\n    \/* ========== CONSTRUCTOR ========== *\/\r\n\r\n    \/*\r\n     * @dev Initialised the contract state by passing the native asset's address\r\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\r\n     * to the {queueActive} state variable.\r\n     **\/\r\n    constructor(bool _queueActive, IERC20 _nativeAsset)\r\n        BasePoolV2(_nativeAsset)\r\n    {\r\n        queueActive = _queueActive;\r\n    }\r\n\r\n    \/* ========== VIEWS ========== *\/\r\n\r\n    \/*\r\n     * @dev Returns cumulative prices and the timestamp the were last updated\r\n     * for both native and foreign assets against the pair specified by\r\n     * parameter {foreignAsset}.\r\n     **\/\r\n    function cumulativePrices(IERC20 foreignAsset)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 price0CumulativeLast,\r\n            uint256 price1CumulativeLast,\r\n            uint32 blockTimestampLast\r\n        )\r\n    {\r\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\r\n            .priceCumulative;\r\n        price0CumulativeLast = priceCumulative.nativeLast;\r\n        price1CumulativeLast = priceCumulative.foreignLast;\r\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\r\n    }\r\n\r\n    \/* ========== MUTATIVE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Initializes contract's state with LP wrapper, synth factory\r\n     * and router addresses.\r\n     *\r\n     * Requirements:\r\n     * - None of the parameters are zero addresses.\r\n     * - The parameters are not already set.\r\n     * - Only callable by contract owner.\r\n     **\/\r\n    function initialize(\r\n        ILPWrapper _wrapper,\r\n        ISynthFactory _synthFactory,\r\n        address _router\r\n    ) external onlyOwner {\r\n        require(\r\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Already initialized\"\r\n        );\r\n        require(\r\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\r\n        );\r\n        require(\r\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\r\n        );\r\n        require(\r\n            _router != _ZERO_ADDRESS,\r\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\r\n        );\r\n        wrapper = _wrapper;\r\n        synthFactory = _synthFactory;\r\n        router = _router;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\r\n     * on the native asset amount deposited and returns the minted synth asset amount.\r\n     *\r\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must be a supported token.\r\n     **\/\r\n    function mintSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        address from,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        supportedToken(foreignAsset)\r\n        returns (uint256 amountSynth)\r\n    {\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        if (synth == ISynth(_ZERO_ADDRESS))\r\n            synth = synthFactory.createSynth(\r\n                IERC20Extended(address(foreignAsset))\r\n            );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountSynth = VaderMath.calculateSwap(\r\n            nativeDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        synth.mint(to, amountSynth);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\r\n     * and returns the redeemed amount of native asset.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must have a valid synthetic asset against it.\r\n     * - {synthAmount} must be greater than zero.\r\n     **\/\r\n    function burnSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 synthAmount,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 amountNative) {\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        require(\r\n            synth != ISynth(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\r\n        );\r\n\r\n        require(\r\n            synthAmount > 0,\r\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\r\n        );\r\n\r\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\r\n        synth.burn(synthAmount);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountNative = VaderMath.calculateSwap(\r\n            synthAmount,\r\n            reserveForeign,\r\n            reserveNative\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\r\n     *\r\n     * Deletes the position in {positions} mapping against the burned NFT token.\r\n     *\r\n     * Internally calls `_burn` function on {BasePoolV2} contract.\r\n     *\r\n     * Calculates the impermanent loss incurred by the position.\r\n     *\r\n     * Returns the amounts for native and foreign assets sent to the {to} address\r\n     * along with the covered loss.\r\n     *\r\n     * Requirements:\r\n     * - Can only be called by the Router.\r\n     **\/\r\n    \/\/ NOTE: IL is only covered via router!\r\n    function burn(uint256 id, address to)\r\n        external\r\n        override\r\n        onlyRouter\r\n        returns (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        )\r\n    {\r\n        (amountNative, amountForeign) = _burn(id, to);\r\n\r\n        Position storage position = positions[id];\r\n\r\n        uint256 creation = position.creation;\r\n        uint256 originalNative = position.originalNative;\r\n        uint256 originalForeign = position.originalForeign;\r\n\r\n        delete positions[id];\r\n\r\n        \/\/ NOTE: Validate it behaves as expected for non-18 decimal tokens\r\n        uint256 loss = VaderMath.calculateLoss(\r\n            originalNative,\r\n            originalForeign,\r\n            amountNative,\r\n            amountForeign\r\n        );\r\n\r\n        \/\/ TODO: Original Implementation Applied 100 Days\r\n        coveredLoss =\r\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) \/\r\n            _ONE_YEAR;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\r\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\r\n     * tracked within this contract along with liquidity issued against non-fungible\r\n     * token.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'mint' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     **\/\r\n    function mintFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        uint256 foreignDeposit,\r\n        address from,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 liquidity) {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\r\n        );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 totalLiquidityUnits = pair.totalSupply;\r\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\r\n        else\r\n            liquidity = VaderMath.calculateLiquidityUnits(\r\n                nativeDeposit,\r\n                reserveNative,\r\n                foreignDeposit,\r\n                reserveForeign,\r\n                totalLiquidityUnits\r\n            );\r\n\r\n        require(\r\n            liquidity > 0,\r\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\r\n        );\r\n\r\n        pair.totalSupply = totalLiquidityUnits + liquidity;\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign + foreignDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        lp.mint(to, liquidity);\r\n\r\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of liquidity issued in fungible tokens.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'burn' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\r\n     **\/\r\n    function burnFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 liquidity,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        returns (uint256 amountNative, uint256 amountForeign)\r\n    {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\r\n        );\r\n\r\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\r\n        lp.burn(liquidity);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 _totalSupply = pair.totalSupply;\r\n        amountNative = (liquidity * reserveNative) \/ _totalSupply;\r\n        amountForeign = (liquidity * reserveForeign) \/ _totalSupply;\r\n\r\n        require(\r\n            amountNative > 0 && amountForeign > 0,\r\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\r\n        );\r\n\r\n        pair.totalSupply = _totalSupply - liquidity;\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n        foreignAsset.safeTransfer(to, amountForeign);\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign - amountForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        emit Burn(msg.sender, amountNative, amountForeign, to);\r\n    }\r\n\r\n    \/* ========== RESTRICTED FUNCTIONS ========== *\/\r\n\r\n    \/\/ TODO: Investigate Necessity\r\n    function toggleQueue() external override onlyOwner {\r\n        bool _queueActive = !queueActive;\r\n        queueActive = _queueActive;\r\n        emit QueueActive(_queueActive);\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setTokenSupport(IERC20 foreignAsset, bool support)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(\r\n            supported[foreignAsset] != support,\r\n            \"VaderPoolV2::supportToken: Already At Desired State\"\r\n        );\r\n        supported[foreignAsset] = support;\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setFungibleTokenSupport(IERC20 foreignAsset)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        wrapper.createWrapper(foreignAsset);\r\n    }\r\n\r\n    \/* ========== INTERNAL FUNCTIONS ========== *\/\r\n\r\n    \/* ========== PRIVATE FUNCTIONS ========== *\/\r\n\r\n    \/**\r\n     * @dev Calculates the minimum of the two values\r\n     *\/\r\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-01-minting-and-burning-synths-exposes-users-to-unlimited-slippage",
                "Location":"mintSynth function",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.Here a user sends nativeDeposit to the pool and the equivalent amount of foreignAsset is minted as a synth to be sent to the user. However the user can’t specify the minimum amount of synth that they would accept. A frontrunner can then manipulate the reserves of the pool in order to make foreignAsset appear more valuable than it really is so the user receives synths which are worth much less than what nativeDeposit is worth. This is equivalent to a swap without a slippage limit. Burning synths essentially runs the same process in behalf so manipulating the pool in the opposite direction will result in the user getting fewer of nativeAsset than they expect.",
                "Repair":"Add a argument for the minimum amount of synths to mint or nativeAsset to receive."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\n\r\nimport \".\/BasePoolV2.sol\";\r\n\r\nimport \"..\/..\/interfaces\/shared\/IERC20Extended.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/pool\/IVaderPoolV2.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/wrapper\/ILPWrapper.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/synth\/ISynthFactory.sol\";\r\n\r\n\/*\r\n * @dev Implementation of {VaderPoolV2} contract.\r\n *\r\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\r\n * queue system.\r\n *\r\n * Extends on the liquidity redeeming function by introducing the `burn` function\r\n * that internally calls the namesake on `BasePoolV2` contract and computes the\r\n * loss covered by the position being redeemed and returns it along with amounts\r\n * of native and foreign assets sent.\r\n **\/\r\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\r\n    \/* ========== LIBRARIES ========== *\/\r\n\r\n    \/\/ Used for safe token transfers\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/* ========== STATE VARIABLES ========== *\/\r\n\r\n    \/\/ The LP wrapper contract\r\n    ILPWrapper public wrapper;\r\n\r\n    \/\/ The Synth Factory\r\n    ISynthFactory public synthFactory;\r\n\r\n    \/\/ Denotes whether the queue system is active\r\n    bool public queueActive;\r\n\r\n    \/* ========== CONSTRUCTOR ========== *\/\r\n\r\n    \/*\r\n     * @dev Initialised the contract state by passing the native asset's address\r\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\r\n     * to the {queueActive} state variable.\r\n     **\/\r\n    constructor(bool _queueActive, IERC20 _nativeAsset)\r\n        BasePoolV2(_nativeAsset)\r\n    {\r\n        queueActive = _queueActive;\r\n    }\r\n\r\n    \/* ========== VIEWS ========== *\/\r\n\r\n    \/*\r\n     * @dev Returns cumulative prices and the timestamp the were last updated\r\n     * for both native and foreign assets against the pair specified by\r\n     * parameter {foreignAsset}.\r\n     **\/\r\n    function cumulativePrices(IERC20 foreignAsset)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 price0CumulativeLast,\r\n            uint256 price1CumulativeLast,\r\n            uint32 blockTimestampLast\r\n        )\r\n    {\r\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\r\n            .priceCumulative;\r\n        price0CumulativeLast = priceCumulative.nativeLast;\r\n        price1CumulativeLast = priceCumulative.foreignLast;\r\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\r\n    }\r\n\r\n    \/* ========== MUTATIVE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Initializes contract's state with LP wrapper, synth factory\r\n     * and router addresses.\r\n     *\r\n     * Requirements:\r\n     * - None of the parameters are zero addresses.\r\n     * - The parameters are not already set.\r\n     * - Only callable by contract owner.\r\n     **\/\r\n    function initialize(\r\n        ILPWrapper _wrapper,\r\n        ISynthFactory _synthFactory,\r\n        address _router\r\n    ) external onlyOwner {\r\n        require(\r\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Already initialized\"\r\n        );\r\n        require(\r\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\r\n        );\r\n        require(\r\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\r\n        );\r\n        require(\r\n            _router != _ZERO_ADDRESS,\r\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\r\n        );\r\n        wrapper = _wrapper;\r\n        synthFactory = _synthFactory;\r\n        router = _router;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\r\n     * on the native asset amount deposited and returns the minted synth asset amount.\r\n     *\r\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must be a supported token.\r\n     **\/\r\n    function mintSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        address from,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        supportedToken(foreignAsset)\r\n        returns (uint256 amountSynth)\r\n    {\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        if (synth == ISynth(_ZERO_ADDRESS))\r\n            synth = synthFactory.createSynth(\r\n                IERC20Extended(address(foreignAsset))\r\n            );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountSynth = VaderMath.calculateSwap(\r\n            nativeDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        synth.mint(to, amountSynth);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\r\n     * and returns the redeemed amount of native asset.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must have a valid synthetic asset against it.\r\n     * - {synthAmount} must be greater than zero.\r\n     **\/\r\n    function burnSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 synthAmount,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 amountNative) {\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        require(\r\n            synth != ISynth(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\r\n        );\r\n\r\n        require(\r\n            synthAmount > 0,\r\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\r\n        );\r\n\r\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\r\n        synth.burn(synthAmount);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountNative = VaderMath.calculateSwap(\r\n            synthAmount,\r\n            reserveForeign,\r\n            reserveNative\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\r\n     *\r\n     * Deletes the position in {positions} mapping against the burned NFT token.\r\n     *\r\n     * Internally calls `_burn` function on {BasePoolV2} contract.\r\n     *\r\n     * Calculates the impermanent loss incurred by the position.\r\n     *\r\n     * Returns the amounts for native and foreign assets sent to the {to} address\r\n     * along with the covered loss.\r\n     *\r\n     * Requirements:\r\n     * - Can only be called by the Router.\r\n     **\/\r\n    \/\/ NOTE: IL is only covered via router!\r\n    function burn(uint256 id, address to)\r\n        external\r\n        override\r\n        onlyRouter\r\n        returns (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        )\r\n    {\r\n        (amountNative, amountForeign) = _burn(id, to);\r\n\r\n        Position storage position = positions[id];\r\n\r\n        uint256 creation = position.creation;\r\n        uint256 originalNative = position.originalNative;\r\n        uint256 originalForeign = position.originalForeign;\r\n\r\n        delete positions[id];\r\n\r\n        \/\/ NOTE: Validate it behaves as expected for non-18 decimal tokens\r\n        uint256 loss = VaderMath.calculateLoss(\r\n            originalNative,\r\n            originalForeign,\r\n            amountNative,\r\n            amountForeign\r\n        );\r\n\r\n        \/\/ TODO: Original Implementation Applied 100 Days\r\n        coveredLoss =\r\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) \/\r\n            _ONE_YEAR;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\r\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\r\n     * tracked within this contract along with liquidity issued against non-fungible\r\n     * token.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'mint' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     **\/\r\n    function mintFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        uint256 foreignDeposit,\r\n        address from,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 liquidity) {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\r\n        );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 totalLiquidityUnits = pair.totalSupply;\r\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\r\n        else\r\n            liquidity = VaderMath.calculateLiquidityUnits(\r\n                nativeDeposit,\r\n                reserveNative,\r\n                foreignDeposit,\r\n                reserveForeign,\r\n                totalLiquidityUnits\r\n            );\r\n\r\n        require(\r\n            liquidity > 0,\r\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\r\n        );\r\n\r\n        pair.totalSupply = totalLiquidityUnits + liquidity;\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign + foreignDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        lp.mint(to, liquidity);\r\n\r\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of liquidity issued in fungible tokens.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'burn' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\r\n     **\/\r\n    function burnFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 liquidity,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        returns (uint256 amountNative, uint256 amountForeign)\r\n    {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\r\n        );\r\n\r\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\r\n        lp.burn(liquidity);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 _totalSupply = pair.totalSupply;\r\n        amountNative = (liquidity * reserveNative) \/ _totalSupply;\r\n        amountForeign = (liquidity * reserveForeign) \/ _totalSupply;\r\n\r\n        require(\r\n            amountNative > 0 && amountForeign > 0,\r\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\r\n        );\r\n\r\n        pair.totalSupply = _totalSupply - liquidity;\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n        foreignAsset.safeTransfer(to, amountForeign);\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign - amountForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        emit Burn(msg.sender, amountNative, amountForeign, to);\r\n    }\r\n\r\n    \/* ========== RESTRICTED FUNCTIONS ========== *\/\r\n\r\n    \/\/ TODO: Investigate Necessity\r\n    function toggleQueue() external override onlyOwner {\r\n        bool _queueActive = !queueActive;\r\n        queueActive = _queueActive;\r\n        emit QueueActive(_queueActive);\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setTokenSupport(IERC20 foreignAsset, bool support)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(\r\n            supported[foreignAsset] != support,\r\n            \"VaderPoolV2::supportToken: Already At Desired State\"\r\n        );\r\n        supported[foreignAsset] = support;\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setFungibleTokenSupport(IERC20 foreignAsset)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        wrapper.createWrapper(foreignAsset);\r\n    }\r\n\r\n    \/* ========== INTERNAL FUNCTIONS ========== *\/\r\n\r\n    \/* ========== PRIVATE FUNCTIONS ========== *\/\r\n\r\n    \/**\r\n     * @dev Calculates the minimum of the two values\r\n     *\/\r\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-02-redemption-value-of-synths-can-be-manipulated-to-drain-vaderpool-of-all-native-assets",
                "Location":"mintSynth function",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.As the pool’s reserves can be manipulated through flashloans similar to on UniswapV2, an attacker may set the exchange rate between nativeAsset and synths (calculated from the reserves). An attacker can exploit this to drain funds from the pool. The attacker first flashloans and sells a huge amount of foreignAsset to the pool. The pool now thinks nativeAsset is extremely valuable. The attacker now uses a relatively small amount of nativeAsset to mint synths using VaderPool.mintSynth. As the pool thinks nativeAsset is very valuable the attacker will receive a huge amount of synths. The attacker can now manipulate the pool in the opposite direction by buying up the foreignAsset they sold to the pool. nativeAsset is now back at its normal price, or perhaps artificially low if the attacker wishes. The attacker now burns all of their synths. As nativeAsset is considered much less valuable than at the point the synths were minted it takes a lot more of nativeAsset in order to pay out for the burned synths. For the price of a flashloan and some swap fees, the attacker has now managed to extract a large amount of nativeAsset from the pool. This process can be repeated as long as it is profitable.",
                "Repair":"Prevent minting of synths or at the very least tie the exchange rate to a manipulation resistant oracle."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\n\r\nimport \".\/BasePoolV2.sol\";\r\n\r\nimport \"..\/..\/interfaces\/shared\/IERC20Extended.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/pool\/IVaderPoolV2.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/wrapper\/ILPWrapper.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/synth\/ISynthFactory.sol\";\r\n\r\n\/*\r\n * @dev Implementation of {VaderPoolV2} contract.\r\n *\r\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\r\n * queue system.\r\n *\r\n * Extends on the liquidity redeeming function by introducing the `burn` function\r\n * that internally calls the namesake on `BasePoolV2` contract and computes the\r\n * loss covered by the position being redeemed and returns it along with amounts\r\n * of native and foreign assets sent.\r\n **\/\r\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\r\n    \/* ========== LIBRARIES ========== *\/\r\n\r\n    \/\/ Used for safe token transfers\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/* ========== STATE VARIABLES ========== *\/\r\n\r\n    \/\/ The LP wrapper contract\r\n    ILPWrapper public wrapper;\r\n\r\n    \/\/ The Synth Factory\r\n    ISynthFactory public synthFactory;\r\n\r\n    \/\/ Denotes whether the queue system is active\r\n    bool public queueActive;\r\n\r\n    \/* ========== CONSTRUCTOR ========== *\/\r\n\r\n    \/*\r\n     * @dev Initialised the contract state by passing the native asset's address\r\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\r\n     * to the {queueActive} state variable.\r\n     **\/\r\n    constructor(bool _queueActive, IERC20 _nativeAsset)\r\n        BasePoolV2(_nativeAsset)\r\n    {\r\n        queueActive = _queueActive;\r\n    }\r\n\r\n    \/* ========== VIEWS ========== *\/\r\n\r\n    \/*\r\n     * @dev Returns cumulative prices and the timestamp the were last updated\r\n     * for both native and foreign assets against the pair specified by\r\n     * parameter {foreignAsset}.\r\n     **\/\r\n    function cumulativePrices(IERC20 foreignAsset)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 price0CumulativeLast,\r\n            uint256 price1CumulativeLast,\r\n            uint32 blockTimestampLast\r\n        )\r\n    {\r\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\r\n            .priceCumulative;\r\n        price0CumulativeLast = priceCumulative.nativeLast;\r\n        price1CumulativeLast = priceCumulative.foreignLast;\r\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\r\n    }\r\n\r\n    \/* ========== MUTATIVE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Initializes contract's state with LP wrapper, synth factory\r\n     * and router addresses.\r\n     *\r\n     * Requirements:\r\n     * - None of the parameters are zero addresses.\r\n     * - The parameters are not already set.\r\n     * - Only callable by contract owner.\r\n     **\/\r\n    function initialize(\r\n        ILPWrapper _wrapper,\r\n        ISynthFactory _synthFactory,\r\n        address _router\r\n    ) external onlyOwner {\r\n        require(\r\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Already initialized\"\r\n        );\r\n        require(\r\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\r\n        );\r\n        require(\r\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\r\n        );\r\n        require(\r\n            _router != _ZERO_ADDRESS,\r\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\r\n        );\r\n        wrapper = _wrapper;\r\n        synthFactory = _synthFactory;\r\n        router = _router;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\r\n     * on the native asset amount deposited and returns the minted synth asset amount.\r\n     *\r\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must be a supported token.\r\n     **\/\r\n    function mintSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        address from,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        supportedToken(foreignAsset)\r\n        returns (uint256 amountSynth)\r\n    {\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        if (synth == ISynth(_ZERO_ADDRESS))\r\n            synth = synthFactory.createSynth(\r\n                IERC20Extended(address(foreignAsset))\r\n            );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountSynth = VaderMath.calculateSwap(\r\n            nativeDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        synth.mint(to, amountSynth);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\r\n     * and returns the redeemed amount of native asset.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must have a valid synthetic asset against it.\r\n     * - {synthAmount} must be greater than zero.\r\n     **\/\r\n    function burnSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 synthAmount,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 amountNative) {\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        require(\r\n            synth != ISynth(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\r\n        );\r\n\r\n        require(\r\n            synthAmount > 0,\r\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\r\n        );\r\n\r\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\r\n        synth.burn(synthAmount);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountNative = VaderMath.calculateSwap(\r\n            synthAmount,\r\n            reserveForeign,\r\n            reserveNative\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\r\n     *\r\n     * Deletes the position in {positions} mapping against the burned NFT token.\r\n     *\r\n     * Internally calls `_burn` function on {BasePoolV2} contract.\r\n     *\r\n     * Calculates the impermanent loss incurred by the position.\r\n     *\r\n     * Returns the amounts for native and foreign assets sent to the {to} address\r\n     * along with the covered loss.\r\n     *\r\n     * Requirements:\r\n     * - Can only be called by the Router.\r\n     **\/\r\n    \/\/ NOTE: IL is only covered via router!\r\n    function burn(uint256 id, address to)\r\n        external\r\n        override\r\n        onlyRouter\r\n        returns (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        )\r\n    {\r\n        (amountNative, amountForeign) = _burn(id, to);\r\n\r\n        Position storage position = positions[id];\r\n\r\n        uint256 creation = position.creation;\r\n        uint256 originalNative = position.originalNative;\r\n        uint256 originalForeign = position.originalForeign;\r\n\r\n        delete positions[id];\r\n\r\n        \/\/ NOTE: Validate it behaves as expected for non-18 decimal tokens\r\n        uint256 loss = VaderMath.calculateLoss(\r\n            originalNative,\r\n            originalForeign,\r\n            amountNative,\r\n            amountForeign\r\n        );\r\n\r\n        \/\/ TODO: Original Implementation Applied 100 Days\r\n        coveredLoss =\r\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) \/\r\n            _ONE_YEAR;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\r\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\r\n     * tracked within this contract along with liquidity issued against non-fungible\r\n     * token.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'mint' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     **\/\r\n    function mintFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        uint256 foreignDeposit,\r\n        address from,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 liquidity) {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\r\n        );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 totalLiquidityUnits = pair.totalSupply;\r\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\r\n        else\r\n            liquidity = VaderMath.calculateLiquidityUnits(\r\n                nativeDeposit,\r\n                reserveNative,\r\n                foreignDeposit,\r\n                reserveForeign,\r\n                totalLiquidityUnits\r\n            );\r\n\r\n        require(\r\n            liquidity > 0,\r\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\r\n        );\r\n\r\n        pair.totalSupply = totalLiquidityUnits + liquidity;\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign + foreignDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        lp.mint(to, liquidity);\r\n\r\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of liquidity issued in fungible tokens.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'burn' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\r\n     **\/\r\n    function burnFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 liquidity,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        returns (uint256 amountNative, uint256 amountForeign)\r\n    {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\r\n        );\r\n\r\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\r\n        lp.burn(liquidity);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 _totalSupply = pair.totalSupply;\r\n        amountNative = (liquidity * reserveNative) \/ _totalSupply;\r\n        amountForeign = (liquidity * reserveForeign) \/ _totalSupply;\r\n\r\n        require(\r\n            amountNative > 0 && amountForeign > 0,\r\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\r\n        );\r\n\r\n        pair.totalSupply = _totalSupply - liquidity;\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n        foreignAsset.safeTransfer(to, amountForeign);\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign - amountForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        emit Burn(msg.sender, amountNative, amountForeign, to);\r\n    }\r\n\r\n    \/* ========== RESTRICTED FUNCTIONS ========== *\/\r\n\r\n    \/\/ TODO: Investigate Necessity\r\n    function toggleQueue() external override onlyOwner {\r\n        bool _queueActive = !queueActive;\r\n        queueActive = _queueActive;\r\n        emit QueueActive(_queueActive);\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setTokenSupport(IERC20 foreignAsset, bool support)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(\r\n            supported[foreignAsset] != support,\r\n            \"VaderPoolV2::supportToken: Already At Desired State\"\r\n        );\r\n        supported[foreignAsset] = support;\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setFungibleTokenSupport(IERC20 foreignAsset)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        wrapper.createWrapper(foreignAsset);\r\n    }\r\n\r\n    \/* ========== INTERNAL FUNCTIONS ========== *\/\r\n\r\n    \/* ========== PRIVATE FUNCTIONS ========== *\/\r\n\r\n    \/**\r\n     * @dev Calculates the minimum of the two values\r\n     *\/\r\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-05-lps-of-vaderpoolv2-can-manipulate-pool-reserves-to-extract-funds-from-the-reserve",
                "Location":"burn function",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.we calculate the current losses that the LP has made to impermanent loss.These losses are then refunded to the LP in VADER tokens from the reserve.This loss is calculated by the current reserves of the pool so if an LP can manipulate the pool’s reserves they can artificially engineer a huge amount of IL in order to qualify for a payout up to the size of their LP position.",
                "Repair":"Use a manipulation resistant oracle for the relative prices of the pool’s assets (TWAP, etc.)"
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nlibrary VaderMath {\r\n    \/* ========== CONSTANTS ========== *\/\r\n\r\n    uint256 public constant ONE = 1 ether;\r\n\r\n    \/* ========== LIBRARY FUNCTIONS ========== *\/\r\n\r\n    \/**\r\n     * @dev Calculates the amount of liquidity units for the {vaderDeposited}\r\n     * and {assetDeposited} amounts across {totalPoolUnits}.\r\n     *\r\n     * The {vaderBalance} and {assetBalance} are taken into account in order to\r\n     * calculate any necessary slippage adjustment.\r\n     *\/\r\n    function calculateLiquidityUnits(\r\n        uint256 vaderDeposited,\r\n        uint256 vaderBalance,\r\n        uint256 assetDeposited,\r\n        uint256 assetBalance,\r\n        uint256 totalPoolUnits\r\n    ) public pure returns (uint256) {\r\n        \/\/ slipAdjustment\r\n        uint256 slip = calculateSlipAdjustment(\r\n            vaderDeposited,\r\n            vaderBalance,\r\n            assetDeposited,\r\n            assetBalance\r\n        );\r\n\r\n        \/\/ (Va + vA)\r\n        uint256 poolUnitFactor = (vaderBalance * assetDeposited) +\r\n            (vaderDeposited * assetBalance);\r\n\r\n        \/\/ 2VA\r\n        uint256 denominator = ONE * 2 * vaderBalance * assetBalance;\r\n\r\n        \/\/ P * [(Va + vA) \/ (2 * V * A)] * slipAdjustment\r\n        return ((totalPoolUnits * poolUnitFactor) \/ denominator) * slip;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the necessary slippage adjustment for the {vaderDeposited} and {assetDeposited}\r\n    * amounts across the total {vaderBalance} and {assetBalance} amounts.\r\n    *\/\r\n    function calculateSlipAdjustment(\r\n        uint256 vaderDeposited,\r\n        uint256 vaderBalance,\r\n        uint256 assetDeposited,\r\n        uint256 assetBalance\r\n    ) public pure returns (uint256) {\r\n        \/\/ Va\r\n        uint256 vaderAsset = vaderBalance * assetDeposited;\r\n\r\n        \/\/ aV\r\n        uint256 assetVader = assetBalance * vaderDeposited;\r\n\r\n        \/\/ (v + V) * (a + A)\r\n        uint256 denominator = (vaderDeposited + vaderBalance) *\r\n            (assetDeposited + assetBalance);\r\n\r\n        \/\/ 1 - [|Va - aV| \/ (v + V) * (a + A)]\r\n        return ONE - (delta(vaderAsset, assetVader) \/ denominator);\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the loss based on the supplied {releasedVader} and {releasedAsset}\r\n    * compared to the supplied {originalVader} and {originalAsset}.\r\n    *\/\r\n    function calculateLoss(\r\n        uint256 originalVader,\r\n        uint256 originalAsset,\r\n        uint256 releasedVader,\r\n        uint256 releasedAsset\r\n    ) public pure returns (uint256 loss) {\r\n        \/\/\r\n        \/\/ TODO: Vader Formula Differs https:\/\/github.com\/vetherasset\/vaderprotocol-contracts\/blob\/main\/contracts\/Utils.sol#L347-L356\r\n        \/\/\r\n\r\n        \/\/ [(A0 * P1) + V0]\r\n        uint256 originalValue = ((originalAsset * releasedVader) \/\r\n            releasedAsset) + originalVader;\r\n\r\n        \/\/ [(A1 * P1) + V1]\r\n        uint256 releasedValue = ((releasedAsset * releasedVader) \/\r\n            releasedAsset) + releasedVader;\r\n\r\n        \/\/ [(A0 * P1) + V0] - [(A1 * P1) + V1]\r\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the {amountOut} of the swap based on the supplied {amountIn}\r\n    * across the supplied {reserveIn} and {reserveOut} amounts.\r\n    *\/\r\n    function calculateSwap(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public pure returns (uint256 amountOut) {\r\n        \/\/ x * Y * X\r\n        uint256 numerator = amountIn * reserveIn * reserveOut;\r\n\r\n        \/\/ (x + X) ^ 2\r\n        uint256 denominator = pow(amountIn + reserveIn);\r\n\r\n        amountOut = numerator \/ denominator;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the {amountIn} of the swap based on the supplied {amountOut}\r\n    * across the supplied {reserveIn} and {reserveOut} amounts.\r\n    *\/\r\n    function calculateSwapReverse(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public pure returns (uint256 amountIn) {\r\n        \/\/ X * Y\r\n        uint256 XY = reserveIn * reserveOut;\r\n\r\n        \/\/ 2y\r\n        uint256 y2 = amountOut * 2;\r\n\r\n        \/\/ 4y\r\n        uint256 y4 = y2 * 2;\r\n\r\n        require(\r\n            y4 < reserveOut,\r\n            \"VaderMath::calculateSwapReverse: Desired Output Exceeds Maximum Output Possible (1\/4 of Liquidity Pool)\"\r\n        );\r\n\r\n        \/\/ root(-X^2 * Y * (4y - Y))    =>    root(X^2 * Y * (Y - 4y)) as Y - 4y >= 0    =>    Y >= 4y holds true\r\n        uint256 numeratorA = root(XY) * root(reserveIn * (reserveOut - y4));\r\n\r\n        \/\/ X * (2y - Y)    =>    2yX - XY\r\n        uint256 numeratorB = y2 * reserveIn;\r\n        uint256 numeratorC = XY;\r\n\r\n        \/\/ -1 * (root(-X^2 * Y * (4y - Y)) + (X * (2y - Y)))    =>    -1 * (root(X^2 * Y * (Y - 4y)) + 2yX - XY)    =>    XY - root(X^2 * Y * (Y - 4y) - 2yX\r\n        uint256 numerator = numeratorC - numeratorA - numeratorB;\r\n\r\n        \/\/ 2y\r\n        uint256 denominator = y2;\r\n\r\n        amountIn = numerator \/ denominator;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the difference between the supplied {a} and {b} values as a positive number.\r\n    *\/\r\n    function delta(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return a > b ? a - b : b - a;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the power of 2 of the supplied {a} value.\r\n    *\/\r\n    function pow(uint256 a) public pure returns (uint256) {\r\n        return a * a;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the square root {c} of the supplied {a} value utilizing the Babylonian method:\r\n    * https:\/\/en.wikipedia.org\/wiki\/Methods_of_computing_square_roots#Babylonian_method\r\n    *\/\r\n    function root(uint256 a) public pure returns (uint256 c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint256 x = a \/ 2 + 1;\r\n            while (x < c) {\r\n                c = x;\r\n                x = (a \/ x + x) \/ 2;\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-10--calculate-loss-is-vulnerable-to-flashloan-attack",
                "Location":"calculateLoss function",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.The lp value is calculated as [(A0 * P1) + V0] and // [(A1 * P1) + V1]. Assume that there’s an ETH pool and there’s 100 ETH and 100 Vader in the pool.",
                "Repair":"Please use the fair lp pricing formula from alpha finance instead."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\nimport \"@openzeppelin\/contracts\/token\/ERC20\/utils\/SafeERC20.sol\";\r\n\r\nimport \"..\/..\/shared\/ProtocolConstants.sol\";\r\n\r\nimport \"..\/..\/dex\/math\/VaderMath.sol\";\r\n\r\nimport \"..\/..\/interfaces\/reserve\/IVaderReserve.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/router\/IVaderRouterV2.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/pool\/IVaderPoolV2.sol\";\r\n\r\n\/*\r\n @dev Implementation of {VaderRouterV2} contract.\r\n *\r\n * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.\r\n *\r\n * It allows adding of liquidity to Vader pairs.\r\n *\r\n * Allows removing of liquidity by the users and claiming the underlying assets from\r\n * the Vader pairs\/pools.\r\n *\r\n * Allows swapping between native and foreign assets within a single Vader pair.\r\n *\r\n * Allows swapping of foreign assets across two different Vader pairs.\r\n **\/\r\ncontract VaderRouterV2 is IVaderRouterV2, ProtocolConstants, Ownable {\r\n    \/* ========== LIBRARIES ========== *\/\r\n\r\n    \/\/ Used for safe token transfers\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/* ========== STATE VARIABLES ========== *\/\r\n\r\n    \/\/ Address of the Vader pool contract.\r\n    IVaderPoolV2 public immutable pool;\r\n\r\n    \/\/ Address of native asset (USDV or Vader).\r\n    IERC20 public immutable nativeAsset;\r\n\r\n    \/\/ Address of reserve contract.\r\n    IVaderReserve public reserve;\r\n\r\n    \/* ========== CONSTRUCTOR ========== *\/\r\n\r\n    \/*\r\n     * @dev Initialises contract by setting pool and native asset addresses.\r\n     *\r\n     * Native assets address is taken from param {_pool} and native asset's address\r\n     * is retrieved from {VaderPoolV2} contract.\r\n     **\/\r\n    constructor(IVaderPoolV2 _pool) {\r\n        require(\r\n            _pool != IVaderPoolV2(_ZERO_ADDRESS),\r\n            \"VaderRouterV2::constructor: Incorrect Arguments\"\r\n        );\r\n\r\n        pool = _pool;\r\n        nativeAsset = pool.nativeAsset();\r\n    }\r\n\r\n    \/* ========== VIEWS ========== *\/\r\n\r\n    \/* ========== MUTATIVE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Allows adding of liquidity to the Vader pool.\r\n     *\r\n     * Internally calls {addLiquidity} function.\r\n     *\r\n     * Returns the amount of liquidity minted.\r\n     **\/\r\n    \/\/ NOTE: For Uniswap V2 compliancy, necessary due to stack too deep\r\n    function addLiquidity(\r\n        IERC20 tokenA,\r\n        IERC20 tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256, \/\/ amountAMin = unused\r\n        uint256, \/\/ amountBMin = unused\r\n        address to,\r\n        uint256 deadline\r\n    ) external override returns (uint256 liquidity) {\r\n        return\r\n            addLiquidity(\r\n                tokenA,\r\n                tokenB,\r\n                amountADesired,\r\n                amountBDesired,\r\n                to,\r\n                deadline\r\n            );\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows adding of liquidity to the Vader pool.\r\n     *\r\n     * Calls `mint` function on the {BasePoolV2} contract.\r\n     *\r\n     * Pair is determined based {tokenA} and {tokenB} where one of them represents\r\n     * native asset and the other one represents foreign asset.\r\n     *\r\n     * Returns the amount of liquidity units minted against a pair.\r\n     *\r\n     * Requirements:\r\n     * - The current timestamp has not exceeded the param {deadline}.\r\n     * - Amongst {tokenA} and {tokenB}, one should be the native asset and the other\r\n     *   one must be the foreign asset.\r\n     * - The foreign asset among {tokenA} and {tokenB} must be a supported token.\r\n     **\/\r\n    function addLiquidity(\r\n        IERC20 tokenA,\r\n        IERC20 tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        address to,\r\n        uint256 deadline\r\n    ) public override ensure(deadline) returns (uint256 liquidity) {\r\n        IERC20 foreignAsset;\r\n        uint256 nativeDeposit;\r\n        uint256 foreignDeposit;\r\n\r\n        if (tokenA == nativeAsset) {\r\n            require(\r\n                pool.supported(tokenB),\r\n                \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\r\n            );\r\n            foreignAsset = tokenB;\r\n            foreignDeposit = amountBDesired;\r\n            nativeDeposit = amountADesired;\r\n        } else {\r\n            require(\r\n                tokenB == nativeAsset && pool.supported(tokenA),\r\n                \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\r\n            );\r\n            foreignAsset = tokenA;\r\n            foreignDeposit = amountADesired;\r\n            nativeDeposit = amountBDesired;\r\n        }\r\n\r\n        liquidity = pool.mint(\r\n            foreignAsset,\r\n            nativeDeposit,\r\n            foreignDeposit,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows removing of liquidity by {msg.sender} and transfers the\r\n     * underlying assets to {to} address.\r\n     *\r\n     * The liquidity is removed from a pair represented by {tokenA} and {tokenB}.\r\n     *\r\n     * Transfers the NFT with Id {id} representing user's position, to the pool address,\r\n     * so the pool is able to burn it in the `burn` function call.\r\n     *\r\n     * Calls the `burn` function on the pool contract.\r\n     *\r\n     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss\r\n     * for the liquidity being removed.\r\n     *\r\n     * Requirements:\r\n     * - The underlying assets amounts of {amountA} and {amountB} must\r\n     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.\r\n     * - The current timestamp has not exceeded the param {deadline}.\r\n     * - Either of {tokenA} or {tokenB} should be a native asset and the other one\r\n     *   must be the foreign asset associated with the NFT representing liquidity.\r\n     **\/\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 id,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256 amountA, uint256 amountB)\r\n    {\r\n        IERC20 _foreignAsset = pool.positionForeignAsset(id);\r\n        IERC20 _nativeAsset = nativeAsset;\r\n\r\n        bool isNativeA = _nativeAsset == IERC20(tokenA);\r\n\r\n        if (isNativeA) {\r\n            require(\r\n                IERC20(tokenB) == _foreignAsset,\r\n                \"VaderRouterV2::removeLiquidity: Incorrect Addresses Specified\"\r\n            );\r\n        } else {\r\n            require(\r\n                IERC20(tokenA) == _foreignAsset &&\r\n                    IERC20(tokenB) == _nativeAsset,\r\n                \"VaderRouterV2::removeLiquidity: Incorrect Addresses Specified\"\r\n            );\r\n        }\r\n\r\n        pool.transferFrom(msg.sender, address(pool), id);\r\n\r\n        (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        ) = pool.burn(id, to);\r\n\r\n        (amountA, amountB) = isNativeA\r\n            ? (amountNative, amountForeign)\r\n            : (amountForeign, amountNative);\r\n\r\n        require(\r\n            amountA >= amountAMin,\r\n            \"VaderRouterV2: INSUFFICIENT_A_AMOUNT\"\r\n        );\r\n        require(\r\n            amountB >= amountBMin,\r\n            \"VaderRouterV2: INSUFFICIENT_B_AMOUNT\"\r\n        );\r\n\r\n        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows swapping of exact source token amount to destination\r\n     * token amount.\r\n     *\r\n     * Internally calls {_swap} function.\r\n     *\r\n     * Requirements:\r\n     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.\r\n     * - The current timestamp has not exceeded the param {deadline}.\r\n     **\/\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        IERC20[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\r\n        amountOut = _swap(amountIn, path, to);\r\n\r\n        require(\r\n            amountOut >= amountOutMin,\r\n            \"VaderRouterV2::swapExactTokensForTokens: Insufficient Trade Output\"\r\n        );\r\n    }\r\n\r\n    \/* ========== RESTRICTED FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n    * @dev Sets the reserve address and renounces contract's ownership.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     * - Param {_reserve} cannot be a zero address.\r\n     **\/\r\n    function initialize(IVaderReserve _reserve) external onlyOwner {\r\n        require(\r\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\r\n            \"VaderRouterV2::initialize: Incorrect Reserve Specified\"\r\n        );\r\n\r\n        reserve = _reserve;\r\n\r\n        renounceOwnership();\r\n    }\r\n\r\n    \/* ========== INTERNAL FUNCTIONS ========== *\/\r\n\r\n    \/* ========== PRIVATE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Allows swapping of assets from within a single Vader pool pair or\r\n     * across two different Vader pairs.\r\n     *\r\n     * In case of a single Vader pair, the native asset can be swapped for foreign\r\n     * asset and vice versa.\r\n     *\r\n     * In case of two Vader pairs, the foreign asset is swapped for native asset from\r\n     * the first Vader pool and the native asset retrieved from the first Vader pair is swapped\r\n     * for foreign asset from the second Vader pair.\r\n     *\r\n     * Requirements:\r\n     * - Param {path} length can be either 2 or 3.\r\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\r\n     *   and index 1 must contain native asset's address.\r\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\r\n     *   and the other one must contain native asset's address.\r\n     **\/\r\n    function _swap(\r\n        uint256 amountIn,\r\n        IERC20[] calldata path,\r\n        address to\r\n    ) private returns (uint256 amountOut) {\r\n        if (path.length == 3) {\r\n            require(\r\n                path[0] != path[1] &&\r\n                    path[1] == pool.nativeAsset() &&\r\n                    path[2] != path[1],\r\n                \"VaderRouterV2::_swap: Incorrect Path\"\r\n            );\r\n\r\n            path[0].safeTransferFrom(msg.sender, address(pool), amountIn);\r\n\r\n            return pool.doubleSwap(path[0], path[2], amountIn, to);\r\n        } else {\r\n            require(\r\n                path.length == 2,\r\n                \"VaderRouterV2::_swap: Incorrect Path Length\"\r\n            );\r\n            IERC20 _nativeAsset = nativeAsset;\r\n            require(path[0] != path[1], \"VaderRouterV2::_swap: Incorrect Path\");\r\n\r\n            path[0].safeTransferFrom(msg.sender, address(pool), amountIn);\r\n            if (path[0] == _nativeAsset) {\r\n                return pool.swap(path[1], amountIn, 0, to);\r\n            } else {\r\n                require(\r\n                    path[1] == _nativeAsset,\r\n                    \"VaderRouterV2::_swap: Incorrect Path\"\r\n                );\r\n                return pool.swap(path[0], 0, amountIn, to);\r\n            }\r\n        }\r\n    }\r\n\r\n    \/* ========== MODIFIERS ========== *\/\r\n\r\n    \/\/ Guard ensuring that the current timestamp has not exceeded the param {deadline}.\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, \"VaderRouterV2::ensure: Expired\");\r\n        _;\r\n    }\r\n} \/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nlibrary VaderMath {\r\n    \/* ========== CONSTANTS ========== *\/\r\n\r\n    uint256 public constant ONE = 1 ether;\r\n\r\n    \/* ========== LIBRARY FUNCTIONS ========== *\/\r\n\r\n    \/**\r\n     * @dev Calculates the amount of liquidity units for the {vaderDeposited}\r\n     * and {assetDeposited} amounts across {totalPoolUnits}.\r\n     *\r\n     * The {vaderBalance} and {assetBalance} are taken into account in order to\r\n     * calculate any necessary slippage adjustment.\r\n     *\/\r\n    function calculateLiquidityUnits(\r\n        uint256 vaderDeposited,\r\n        uint256 vaderBalance,\r\n        uint256 assetDeposited,\r\n        uint256 assetBalance,\r\n        uint256 totalPoolUnits\r\n    ) public pure returns (uint256) {\r\n        \/\/ slipAdjustment\r\n        uint256 slip = calculateSlipAdjustment(\r\n            vaderDeposited,\r\n            vaderBalance,\r\n            assetDeposited,\r\n            assetBalance\r\n        );\r\n\r\n        \/\/ (Va + vA)\r\n        uint256 poolUnitFactor = (vaderBalance * assetDeposited) +\r\n            (vaderDeposited * assetBalance);\r\n\r\n        \/\/ 2VA\r\n        uint256 denominator = ONE * 2 * vaderBalance * assetBalance;\r\n\r\n        \/\/ P * [(Va + vA) \/ (2 * V * A)] * slipAdjustment\r\n        return ((totalPoolUnits * poolUnitFactor) \/ denominator) * slip;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the necessary slippage adjustment for the {vaderDeposited} and {assetDeposited}\r\n    * amounts across the total {vaderBalance} and {assetBalance} amounts.\r\n    *\/\r\n    function calculateSlipAdjustment(\r\n        uint256 vaderDeposited,\r\n        uint256 vaderBalance,\r\n        uint256 assetDeposited,\r\n        uint256 assetBalance\r\n    ) public pure returns (uint256) {\r\n        \/\/ Va\r\n        uint256 vaderAsset = vaderBalance * assetDeposited;\r\n\r\n        \/\/ aV\r\n        uint256 assetVader = assetBalance * vaderDeposited;\r\n\r\n        \/\/ (v + V) * (a + A)\r\n        uint256 denominator = (vaderDeposited + vaderBalance) *\r\n            (assetDeposited + assetBalance);\r\n\r\n        \/\/ 1 - [|Va - aV| \/ (v + V) * (a + A)]\r\n        return ONE - (delta(vaderAsset, assetVader) \/ denominator);\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the loss based on the supplied {releasedVader} and {releasedAsset}\r\n    * compared to the supplied {originalVader} and {originalAsset}.\r\n    *\/\r\n    function calculateLoss(\r\n        uint256 originalVader,\r\n        uint256 originalAsset,\r\n        uint256 releasedVader,\r\n        uint256 releasedAsset\r\n    ) public pure returns (uint256 loss) {\r\n        \/\/\r\n        \/\/ TODO: Vader Formula Differs https:\/\/github.com\/vetherasset\/vaderprotocol-contracts\/blob\/main\/contracts\/Utils.sol#L347-L356\r\n        \/\/\r\n\r\n        \/\/ [(A0 * P1) + V0]\r\n        uint256 originalValue = ((originalAsset * releasedVader) \/\r\n            releasedAsset) + originalVader;\r\n\r\n        \/\/ [(A1 * P1) + V1]\r\n        uint256 releasedValue = ((releasedAsset * releasedVader) \/\r\n            releasedAsset) + releasedVader;\r\n\r\n        \/\/ [(A0 * P1) + V0] - [(A1 * P1) + V1]\r\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the {amountOut} of the swap based on the supplied {amountIn}\r\n    * across the supplied {reserveIn} and {reserveOut} amounts.\r\n    *\/\r\n    function calculateSwap(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public pure returns (uint256 amountOut) {\r\n        \/\/ x * Y * X\r\n        uint256 numerator = amountIn * reserveIn * reserveOut;\r\n\r\n        \/\/ (x + X) ^ 2\r\n        uint256 denominator = pow(amountIn + reserveIn);\r\n\r\n        amountOut = numerator \/ denominator;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the {amountIn} of the swap based on the supplied {amountOut}\r\n    * across the supplied {reserveIn} and {reserveOut} amounts.\r\n    *\/\r\n    function calculateSwapReverse(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public pure returns (uint256 amountIn) {\r\n        \/\/ X * Y\r\n        uint256 XY = reserveIn * reserveOut;\r\n\r\n        \/\/ 2y\r\n        uint256 y2 = amountOut * 2;\r\n\r\n        \/\/ 4y\r\n        uint256 y4 = y2 * 2;\r\n\r\n        require(\r\n            y4 < reserveOut,\r\n            \"VaderMath::calculateSwapReverse: Desired Output Exceeds Maximum Output Possible (1\/4 of Liquidity Pool)\"\r\n        );\r\n\r\n        \/\/ root(-X^2 * Y * (4y - Y))    =>    root(X^2 * Y * (Y - 4y)) as Y - 4y >= 0    =>    Y >= 4y holds true\r\n        uint256 numeratorA = root(XY) * root(reserveIn * (reserveOut - y4));\r\n\r\n        \/\/ X * (2y - Y)    =>    2yX - XY\r\n        uint256 numeratorB = y2 * reserveIn;\r\n        uint256 numeratorC = XY;\r\n\r\n        \/\/ -1 * (root(-X^2 * Y * (4y - Y)) + (X * (2y - Y)))    =>    -1 * (root(X^2 * Y * (Y - 4y)) + 2yX - XY)    =>    XY - root(X^2 * Y * (Y - 4y) - 2yX\r\n        uint256 numerator = numeratorC - numeratorA - numeratorB;\r\n\r\n        \/\/ 2y\r\n        uint256 denominator = y2;\r\n\r\n        amountIn = numerator \/ denominator;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the difference between the supplied {a} and {b} values as a positive number.\r\n    *\/\r\n    function delta(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return a > b ? a - b : b - a;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the power of 2 of the supplied {a} value.\r\n    *\/\r\n    function pow(uint256 a) public pure returns (uint256) {\r\n        return a * a;\r\n    }\r\n\r\n    \/**\r\n    * @dev Calculates the square root {c} of the supplied {a} value utilizing the Babylonian method:\r\n    * https:\/\/en.wikipedia.org\/wiki\/Methods_of_computing_square_roots#Babylonian_method\r\n    *\/\r\n    function root(uint256 a) public pure returns (uint256 c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint256 x = a \/ 2 + 1;\r\n            while (x < c) {\r\n                c = x;\r\n                x = (a \/ x + x) \/ 2;\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-18-attacker-can-claim-more-il-by-manipulating-pool-price-then-removeliquidity-",
                "Location":"VaderRouterV2 : reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\n VaderMath.sol： uint256 originalValue = ((originalAsset * releasedVader) / releasedAsset) + originalVader;",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.Vader reimburse user IL immediately when user withdraw from the pool (VaderRouterV2.sol:L227), an attacker can therefore manipulate the pool balance causing a high IL, remove liquidity and restore the pool balance such that he will receive a larger IL reimbursement.Let’s assume our attacker own 100% of FOO-VADER Attacker add 100 FOO and 100 VADER to the Pool wait some block, or 1 year for max IL protection In 1 transaction, attacker Swap 9900 FOO to 99 Vader Pool now have 10000 FOO and 1 VADER By VaderMath.sol:L84 the loss is 100*1/10000+100-2 = 98.01 VADER Remove liquidity and receive 10000 FOO and 99.01 VADER Restore the pool balance Such that the attacker will gain 98.01 VADER without risk The profit is constrained by gas cost, pool fee, % of pool controlled by the attacker and % of IL protection.",
                "Repair":"Use twap price to determine P1 in VaderMath.sol:L84 when calculating IL to reduce risk of manipulation"
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\n\r\nimport \".\/BasePoolV2.sol\";\r\n\r\nimport \"..\/..\/interfaces\/shared\/IERC20Extended.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/pool\/IVaderPoolV2.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/wrapper\/ILPWrapper.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/synth\/ISynthFactory.sol\";\r\n\r\n\/*\r\n * @dev Implementation of {VaderPoolV2} contract.\r\n *\r\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\r\n * queue system.\r\n *\r\n * Extends on the liquidity redeeming function by introducing the `burn` function\r\n * that internally calls the namesake on `BasePoolV2` contract and computes the\r\n * loss covered by the position being redeemed and returns it along with amounts\r\n * of native and foreign assets sent.\r\n **\/\r\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\r\n    \/* ========== LIBRARIES ========== *\/\r\n\r\n    \/\/ Used for safe token transfers\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/* ========== STATE VARIABLES ========== *\/\r\n\r\n    \/\/ The LP wrapper contract\r\n    ILPWrapper public wrapper;\r\n\r\n    \/\/ The Synth Factory\r\n    ISynthFactory public synthFactory;\r\n\r\n    \/\/ Denotes whether the queue system is active\r\n    bool public queueActive;\r\n\r\n    \/* ========== CONSTRUCTOR ========== *\/\r\n\r\n    \/*\r\n     * @dev Initialised the contract state by passing the native asset's address\r\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\r\n     * to the {queueActive} state variable.\r\n     **\/\r\n    constructor(bool _queueActive, IERC20 _nativeAsset)\r\n        BasePoolV2(_nativeAsset)\r\n    {\r\n        queueActive = _queueActive;\r\n    }\r\n\r\n    \/* ========== VIEWS ========== *\/\r\n\r\n    \/*\r\n     * @dev Returns cumulative prices and the timestamp the were last updated\r\n     * for both native and foreign assets against the pair specified by\r\n     * parameter {foreignAsset}.\r\n     **\/\r\n    function cumulativePrices(IERC20 foreignAsset)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 price0CumulativeLast,\r\n            uint256 price1CumulativeLast,\r\n            uint32 blockTimestampLast\r\n        )\r\n    {\r\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\r\n            .priceCumulative;\r\n        price0CumulativeLast = priceCumulative.nativeLast;\r\n        price1CumulativeLast = priceCumulative.foreignLast;\r\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\r\n    }\r\n\r\n    \/* ========== MUTATIVE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Initializes contract's state with LP wrapper, synth factory\r\n     * and router addresses.\r\n     *\r\n     * Requirements:\r\n     * - None of the parameters are zero addresses.\r\n     * - The parameters are not already set.\r\n     * - Only callable by contract owner.\r\n     **\/\r\n    function initialize(\r\n        ILPWrapper _wrapper,\r\n        ISynthFactory _synthFactory,\r\n        address _router\r\n    ) external onlyOwner {\r\n        require(\r\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Already initialized\"\r\n        );\r\n        require(\r\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\r\n        );\r\n        require(\r\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\r\n        );\r\n        require(\r\n            _router != _ZERO_ADDRESS,\r\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\r\n        );\r\n        wrapper = _wrapper;\r\n        synthFactory = _synthFactory;\r\n        router = _router;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\r\n     * on the native asset amount deposited and returns the minted synth asset amount.\r\n     *\r\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must be a supported token.\r\n     **\/\r\n    function mintSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        address from,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        supportedToken(foreignAsset)\r\n        returns (uint256 amountSynth)\r\n    {\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        if (synth == ISynth(_ZERO_ADDRESS))\r\n            synth = synthFactory.createSynth(\r\n                IERC20Extended(address(foreignAsset))\r\n            );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountSynth = VaderMath.calculateSwap(\r\n            nativeDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        synth.mint(to, amountSynth);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\r\n     * and returns the redeemed amount of native asset.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must have a valid synthetic asset against it.\r\n     * - {synthAmount} must be greater than zero.\r\n     **\/\r\n    function burnSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 synthAmount,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 amountNative) {\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        require(\r\n            synth != ISynth(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\r\n        );\r\n\r\n        require(\r\n            synthAmount > 0,\r\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\r\n        );\r\n\r\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\r\n        synth.burn(synthAmount);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountNative = VaderMath.calculateSwap(\r\n            synthAmount,\r\n            reserveForeign,\r\n            reserveNative\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\r\n     *\r\n     * Deletes the position in {positions} mapping against the burned NFT token.\r\n     *\r\n     * Internally calls `_burn` function on {BasePoolV2} contract.\r\n     *\r\n     * Calculates the impermanent loss incurred by the position.\r\n     *\r\n     * Returns the amounts for native and foreign assets sent to the {to} address\r\n     * along with the covered loss.\r\n     *\r\n     * Requirements:\r\n     * - Can only be called by the Router.\r\n     **\/\r\n    \/\/ NOTE: IL is only covered via router!\r\n    function burn(uint256 id, address to)\r\n        external\r\n        override\r\n        onlyRouter\r\n        returns (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        )\r\n    {\r\n        (amountNative, amountForeign) = _burn(id, to);\r\n\r\n        Position storage position = positions[id];\r\n\r\n        uint256 creation = position.creation;\r\n        uint256 originalNative = position.originalNative;\r\n        uint256 originalForeign = position.originalForeign;\r\n\r\n        delete positions[id];\r\n\r\n        \/\/ NOTE: Validate it behaves as expected for non-18 decimal tokens\r\n        uint256 loss = VaderMath.calculateLoss(\r\n            originalNative,\r\n            originalForeign,\r\n            amountNative,\r\n            amountForeign\r\n        );\r\n\r\n        \/\/ TODO: Original Implementation Applied 100 Days\r\n        coveredLoss =\r\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) \/\r\n            _ONE_YEAR;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\r\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\r\n     * tracked within this contract along with liquidity issued against non-fungible\r\n     * token.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'mint' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     **\/\r\n    function mintFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        uint256 foreignDeposit,\r\n        address from,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 liquidity) {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\r\n        );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 totalLiquidityUnits = pair.totalSupply;\r\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\r\n        else\r\n            liquidity = VaderMath.calculateLiquidityUnits(\r\n                nativeDeposit,\r\n                reserveNative,\r\n                foreignDeposit,\r\n                reserveForeign,\r\n                totalLiquidityUnits\r\n            );\r\n\r\n        require(\r\n            liquidity > 0,\r\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\r\n        );\r\n\r\n        pair.totalSupply = totalLiquidityUnits + liquidity;\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign + foreignDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        lp.mint(to, liquidity);\r\n\r\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of liquidity issued in fungible tokens.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'burn' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\r\n     **\/\r\n    function burnFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 liquidity,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        returns (uint256 amountNative, uint256 amountForeign)\r\n    {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\r\n        );\r\n\r\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\r\n        lp.burn(liquidity);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 _totalSupply = pair.totalSupply;\r\n        amountNative = (liquidity * reserveNative) \/ _totalSupply;\r\n        amountForeign = (liquidity * reserveForeign) \/ _totalSupply;\r\n\r\n        require(\r\n            amountNative > 0 && amountForeign > 0,\r\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\r\n        );\r\n\r\n        pair.totalSupply = _totalSupply - liquidity;\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n        foreignAsset.safeTransfer(to, amountForeign);\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign - amountForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        emit Burn(msg.sender, amountNative, amountForeign, to);\r\n    }\r\n\r\n    \/* ========== RESTRICTED FUNCTIONS ========== *\/\r\n\r\n    \/\/ TODO: Investigate Necessity\r\n    function toggleQueue() external override onlyOwner {\r\n        bool _queueActive = !queueActive;\r\n        queueActive = _queueActive;\r\n        emit QueueActive(_queueActive);\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setTokenSupport(IERC20 foreignAsset, bool support)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(\r\n            supported[foreignAsset] != support,\r\n            \"VaderPoolV2::supportToken: Already At Desired State\"\r\n        );\r\n        supported[foreignAsset] = support;\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setFungibleTokenSupport(IERC20 foreignAsset)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        wrapper.createWrapper(foreignAsset);\r\n    }\r\n\r\n    \/* ========== INTERNAL FUNCTIONS ========== *\/\r\n\r\n    \/* ========== PRIVATE FUNCTIONS ========== *\/\r\n\r\n    \/**\r\n     * @dev Calculates the minimum of the two values\r\n     *\/\r\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-22-mintsynth-and-burnsynth-can-be-front-run",
                "Location":"mintSynth function , burnSynth function",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.Given that mintSynth() and burnSynth() will issue and redeem assets based on the price of the pool (reserves), and they will create price impact based on the volume being minted and burnt. However, the current implementation provides no parameter for slippage control, making them vulnerable to front-run attacks. Especially for transactions with rather large volumes.",
                "Repair":"Consider adding a minAmountOut parameter."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\n\r\nimport \".\/BasePoolV2.sol\";\r\n\r\nimport \"..\/..\/interfaces\/shared\/IERC20Extended.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/pool\/IVaderPoolV2.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/wrapper\/ILPWrapper.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/synth\/ISynthFactory.sol\";\r\n\r\n\/*\r\n * @dev Implementation of {VaderPoolV2} contract.\r\n *\r\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\r\n * queue system.\r\n *\r\n * Extends on the liquidity redeeming function by introducing the `burn` function\r\n * that internally calls the namesake on `BasePoolV2` contract and computes the\r\n * loss covered by the position being redeemed and returns it along with amounts\r\n * of native and foreign assets sent.\r\n **\/\r\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\r\n    \/* ========== LIBRARIES ========== *\/\r\n\r\n    \/\/ Used for safe token transfers\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/* ========== STATE VARIABLES ========== *\/\r\n\r\n    \/\/ The LP wrapper contract\r\n    ILPWrapper public wrapper;\r\n\r\n    \/\/ The Synth Factory\r\n    ISynthFactory public synthFactory;\r\n\r\n    \/\/ Denotes whether the queue system is active\r\n    bool public queueActive;\r\n\r\n    \/* ========== CONSTRUCTOR ========== *\/\r\n\r\n    \/*\r\n     * @dev Initialised the contract state by passing the native asset's address\r\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\r\n     * to the {queueActive} state variable.\r\n     **\/\r\n    constructor(bool _queueActive, IERC20 _nativeAsset)\r\n        BasePoolV2(_nativeAsset)\r\n    {\r\n        queueActive = _queueActive;\r\n    }\r\n\r\n    \/* ========== VIEWS ========== *\/\r\n\r\n    \/*\r\n     * @dev Returns cumulative prices and the timestamp the were last updated\r\n     * for both native and foreign assets against the pair specified by\r\n     * parameter {foreignAsset}.\r\n     **\/\r\n    function cumulativePrices(IERC20 foreignAsset)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 price0CumulativeLast,\r\n            uint256 price1CumulativeLast,\r\n            uint32 blockTimestampLast\r\n        )\r\n    {\r\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\r\n            .priceCumulative;\r\n        price0CumulativeLast = priceCumulative.nativeLast;\r\n        price1CumulativeLast = priceCumulative.foreignLast;\r\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\r\n    }\r\n\r\n    \/* ========== MUTATIVE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Initializes contract's state with LP wrapper, synth factory\r\n     * and router addresses.\r\n     *\r\n     * Requirements:\r\n     * - None of the parameters are zero addresses.\r\n     * - The parameters are not already set.\r\n     * - Only callable by contract owner.\r\n     **\/\r\n    function initialize(\r\n        ILPWrapper _wrapper,\r\n        ISynthFactory _synthFactory,\r\n        address _router\r\n    ) external onlyOwner {\r\n        require(\r\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Already initialized\"\r\n        );\r\n        require(\r\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\r\n        );\r\n        require(\r\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\r\n        );\r\n        require(\r\n            _router != _ZERO_ADDRESS,\r\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\r\n        );\r\n        wrapper = _wrapper;\r\n        synthFactory = _synthFactory;\r\n        router = _router;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\r\n     * on the native asset amount deposited and returns the minted synth asset amount.\r\n     *\r\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must be a supported token.\r\n     **\/\r\n    function mintSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        address from,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        supportedToken(foreignAsset)\r\n        returns (uint256 amountSynth)\r\n    {\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        if (synth == ISynth(_ZERO_ADDRESS))\r\n            synth = synthFactory.createSynth(\r\n                IERC20Extended(address(foreignAsset))\r\n            );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountSynth = VaderMath.calculateSwap(\r\n            nativeDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        synth.mint(to, amountSynth);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\r\n     * and returns the redeemed amount of native asset.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must have a valid synthetic asset against it.\r\n     * - {synthAmount} must be greater than zero.\r\n     **\/\r\n    function burnSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 synthAmount,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 amountNative) {\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        require(\r\n            synth != ISynth(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\r\n        );\r\n\r\n        require(\r\n            synthAmount > 0,\r\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\r\n        );\r\n\r\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\r\n        synth.burn(synthAmount);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountNative = VaderMath.calculateSwap(\r\n            synthAmount,\r\n            reserveForeign,\r\n            reserveNative\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\r\n     *\r\n     * Deletes the position in {positions} mapping against the burned NFT token.\r\n     *\r\n     * Internally calls `_burn` function on {BasePoolV2} contract.\r\n     *\r\n     * Calculates the impermanent loss incurred by the position.\r\n     *\r\n     * Returns the amounts for native and foreign assets sent to the {to} address\r\n     * along with the covered loss.\r\n     *\r\n     * Requirements:\r\n     * - Can only be called by the Router.\r\n     **\/\r\n    \/\/ NOTE: IL is only covered via router!\r\n    function burn(uint256 id, address to)\r\n        external\r\n        override\r\n        onlyRouter\r\n        returns (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        )\r\n    {\r\n        (amountNative, amountForeign) = _burn(id, to);\r\n\r\n        Position storage position = positions[id];\r\n\r\n        uint256 creation = position.creation;\r\n        uint256 originalNative = position.originalNative;\r\n        uint256 originalForeign = position.originalForeign;\r\n\r\n        delete positions[id];\r\n\r\n        \/\/ NOTE: Validate it behaves as expected for non-18 decimal tokens\r\n        uint256 loss = VaderMath.calculateLoss(\r\n            originalNative,\r\n            originalForeign,\r\n            amountNative,\r\n            amountForeign\r\n        );\r\n\r\n        \/\/ TODO: Original Implementation Applied 100 Days\r\n        coveredLoss =\r\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) \/\r\n            _ONE_YEAR;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\r\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\r\n     * tracked within this contract along with liquidity issued against non-fungible\r\n     * token.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'mint' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     **\/\r\n    function mintFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        uint256 foreignDeposit,\r\n        address from,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 liquidity) {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\r\n        );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 totalLiquidityUnits = pair.totalSupply;\r\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\r\n        else\r\n            liquidity = VaderMath.calculateLiquidityUnits(\r\n                nativeDeposit,\r\n                reserveNative,\r\n                foreignDeposit,\r\n                reserveForeign,\r\n                totalLiquidityUnits\r\n            );\r\n\r\n        require(\r\n            liquidity > 0,\r\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\r\n        );\r\n\r\n        pair.totalSupply = totalLiquidityUnits + liquidity;\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign + foreignDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        lp.mint(to, liquidity);\r\n\r\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of liquidity issued in fungible tokens.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'burn' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\r\n     **\/\r\n    function burnFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 liquidity,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        returns (uint256 amountNative, uint256 amountForeign)\r\n    {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\r\n        );\r\n\r\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\r\n        lp.burn(liquidity);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 _totalSupply = pair.totalSupply;\r\n        amountNative = (liquidity * reserveNative) \/ _totalSupply;\r\n        amountForeign = (liquidity * reserveForeign) \/ _totalSupply;\r\n\r\n        require(\r\n            amountNative > 0 && amountForeign > 0,\r\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\r\n        );\r\n\r\n        pair.totalSupply = _totalSupply - liquidity;\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n        foreignAsset.safeTransfer(to, amountForeign);\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign - amountForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        emit Burn(msg.sender, amountNative, amountForeign, to);\r\n    }\r\n\r\n    \/* ========== RESTRICTED FUNCTIONS ========== *\/\r\n\r\n    \/\/ TODO: Investigate Necessity\r\n    function toggleQueue() external override onlyOwner {\r\n        bool _queueActive = !queueActive;\r\n        queueActive = _queueActive;\r\n        emit QueueActive(_queueActive);\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setTokenSupport(IERC20 foreignAsset, bool support)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(\r\n            supported[foreignAsset] != support,\r\n            \"VaderPoolV2::supportToken: Already At Desired State\"\r\n        );\r\n        supported[foreignAsset] = support;\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setFungibleTokenSupport(IERC20 foreignAsset)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        wrapper.createWrapper(foreignAsset);\r\n    }\r\n\r\n    \/* ========== INTERNAL FUNCTIONS ========== *\/\r\n\r\n    \/* ========== PRIVATE FUNCTIONS ========== *\/\r\n\r\n    \/**\r\n     * @dev Calculates the minimum of the two values\r\n     *\/\r\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-29-vaderpoolv2mintfungible-exposes-users-to-unlimited-slippage",
                "Location":"mintFungible function",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.Users can provide liquidity to VaderPoolV2 through the mintFungible function.This allows users to provide tokens in any ratio and the pool will calculate what fraction of the value in the pool this makes up and mint the corresponding amount of liquidity units as an ERC20. However there’s no way for users to specify the minimum number of liquidity units they will accept. As the number of liquidity units minted is calculated from the current reserves, this allows frontrunners to manipulate the pool’s reserves in such a way that the LP receives fewer liquidity units than they should. e.g. LP provides a lot of nativeAsset but very little foreignAsset, the frontrunner can then sell a lot of nativeAsset to the pool to devalue it. Once this is done the attacker returns the pool’s reserves back to normal and pockets a fraction of the value which the LP meant to provide as liqudity.",
                "Repair":"Add a user-specified minimum amount of LP tokens to mint."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity =0.8.9;\r\n\r\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\nimport \"@openzeppelin\/contracts\/token\/ERC20\/utils\/SafeERC20.sol\";\r\n\r\nimport \"..\/..\/shared\/ProtocolConstants.sol\";\r\n\r\nimport \"..\/..\/dex\/math\/VaderMath.sol\";\r\n\r\nimport \"..\/..\/interfaces\/reserve\/IVaderReserve.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/router\/IVaderRouterV2.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/pool\/IVaderPoolV2.sol\";\r\n\r\n\/*\r\n @dev Implementation of {VaderRouterV2} contract.\r\n *\r\n * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.\r\n *\r\n * It allows adding of liquidity to Vader pairs.\r\n *\r\n * Allows removing of liquidity by the users and claiming the underlying assets from\r\n * the Vader pairs\/pools.\r\n *\r\n * Allows swapping between native and foreign assets within a single Vader pair.\r\n *\r\n * Allows swapping of foreign assets across two different Vader pairs.\r\n **\/\r\ncontract VaderRouterV2 is IVaderRouterV2, ProtocolConstants, Ownable {\r\n    \/* ========== LIBRARIES ========== *\/\r\n\r\n    \/\/ Used for safe token transfers\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/* ========== STATE VARIABLES ========== *\/\r\n\r\n    \/\/ Address of the Vader pool contract.\r\n    IVaderPoolV2 public immutable pool;\r\n\r\n    \/\/ Address of native asset (USDV or Vader).\r\n    IERC20 public immutable nativeAsset;\r\n\r\n    \/\/ Address of reserve contract.\r\n    IVaderReserve public reserve;\r\n\r\n    \/* ========== CONSTRUCTOR ========== *\/\r\n\r\n    \/*\r\n     * @dev Initialises contract by setting pool and native asset addresses.\r\n     *\r\n     * Native assets address is taken from param {_pool} and native asset's address\r\n     * is retrieved from {VaderPoolV2} contract.\r\n     **\/\r\n    constructor(IVaderPoolV2 _pool) {\r\n        require(\r\n            _pool != IVaderPoolV2(_ZERO_ADDRESS),\r\n            \"VaderRouterV2::constructor: Incorrect Arguments\"\r\n        );\r\n\r\n        pool = _pool;\r\n        nativeAsset = pool.nativeAsset();\r\n    }\r\n\r\n    \/* ========== VIEWS ========== *\/\r\n\r\n    \/* ========== MUTATIVE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Allows adding of liquidity to the Vader pool.\r\n     *\r\n     * Internally calls {addLiquidity} function.\r\n     *\r\n     * Returns the amount of liquidity minted.\r\n     **\/\r\n    \/\/ NOTE: For Uniswap V2 compliancy, necessary due to stack too deep\r\n    function addLiquidity(\r\n        IERC20 tokenA,\r\n        IERC20 tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256, \/\/ amountAMin = unused\r\n        uint256, \/\/ amountBMin = unused\r\n        address to,\r\n        uint256 deadline\r\n    ) external override returns (uint256 liquidity) {\r\n        return\r\n            addLiquidity(\r\n                tokenA,\r\n                tokenB,\r\n                amountADesired,\r\n                amountBDesired,\r\n                to,\r\n                deadline\r\n            );\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows adding of liquidity to the Vader pool.\r\n     *\r\n     * Calls `mint` function on the {BasePoolV2} contract.\r\n     *\r\n     * Pair is determined based {tokenA} and {tokenB} where one of them represents\r\n     * native asset and the other one represents foreign asset.\r\n     *\r\n     * Returns the amount of liquidity units minted against a pair.\r\n     *\r\n     * Requirements:\r\n     * - The current timestamp has not exceeded the param {deadline}.\r\n     * - Amongst {tokenA} and {tokenB}, one should be the native asset and the other\r\n     *   one must be the foreign asset.\r\n     * - The foreign asset among {tokenA} and {tokenB} must be a supported token.\r\n     **\/\r\n    function addLiquidity(\r\n        IERC20 tokenA,\r\n        IERC20 tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        address to,\r\n        uint256 deadline\r\n    ) public override ensure(deadline) returns (uint256 liquidity) {\r\n        IERC20 foreignAsset;\r\n        uint256 nativeDeposit;\r\n        uint256 foreignDeposit;\r\n\r\n        if (tokenA == nativeAsset) {\r\n            require(\r\n                pool.supported(tokenB),\r\n                \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\r\n            );\r\n            foreignAsset = tokenB;\r\n            foreignDeposit = amountBDesired;\r\n            nativeDeposit = amountADesired;\r\n        } else {\r\n            require(\r\n                tokenB == nativeAsset && pool.supported(tokenA),\r\n                \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\r\n            );\r\n            foreignAsset = tokenA;\r\n            foreignDeposit = amountADesired;\r\n            nativeDeposit = amountBDesired;\r\n        }\r\n\r\n        liquidity = pool.mint(\r\n            foreignAsset,\r\n            nativeDeposit,\r\n            foreignDeposit,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows removing of liquidity by {msg.sender} and transfers the\r\n     * underlying assets to {to} address.\r\n     *\r\n     * The liquidity is removed from a pair represented by {tokenA} and {tokenB}.\r\n     *\r\n     * Transfers the NFT with Id {id} representing user's position, to the pool address,\r\n     * so the pool is able to burn it in the `burn` function call.\r\n     *\r\n     * Calls the `burn` function on the pool contract.\r\n     *\r\n     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss\r\n     * for the liquidity being removed.\r\n     *\r\n     * Requirements:\r\n     * - The underlying assets amounts of {amountA} and {amountB} must\r\n     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.\r\n     * - The current timestamp has not exceeded the param {deadline}.\r\n     * - Either of {tokenA} or {tokenB} should be a native asset and the other one\r\n     *   must be the foreign asset associated with the NFT representing liquidity.\r\n     **\/\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 id,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256 amountA, uint256 amountB)\r\n    {\r\n        IERC20 _foreignAsset = pool.positionForeignAsset(id);\r\n        IERC20 _nativeAsset = nativeAsset;\r\n\r\n        bool isNativeA = _nativeAsset == IERC20(tokenA);\r\n\r\n        if (isNativeA) {\r\n            require(\r\n                IERC20(tokenB) == _foreignAsset,\r\n                \"VaderRouterV2::removeLiquidity: Incorrect Addresses Specified\"\r\n            );\r\n        } else {\r\n            require(\r\n                IERC20(tokenA) == _foreignAsset &&\r\n                    IERC20(tokenB) == _nativeAsset,\r\n                \"VaderRouterV2::removeLiquidity: Incorrect Addresses Specified\"\r\n            );\r\n        }\r\n\r\n        pool.transferFrom(msg.sender, address(pool), id);\r\n\r\n        (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        ) = pool.burn(id, to);\r\n\r\n        (amountA, amountB) = isNativeA\r\n            ? (amountNative, amountForeign)\r\n            : (amountForeign, amountNative);\r\n\r\n        require(\r\n            amountA >= amountAMin,\r\n            \"VaderRouterV2: INSUFFICIENT_A_AMOUNT\"\r\n        );\r\n        require(\r\n            amountB >= amountBMin,\r\n            \"VaderRouterV2: INSUFFICIENT_B_AMOUNT\"\r\n        );\r\n\r\n        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows swapping of exact source token amount to destination\r\n     * token amount.\r\n     *\r\n     * Internally calls {_swap} function.\r\n     *\r\n     * Requirements:\r\n     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.\r\n     * - The current timestamp has not exceeded the param {deadline}.\r\n     **\/\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        IERC20[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\r\n        amountOut = _swap(amountIn, path, to);\r\n\r\n        require(\r\n            amountOut >= amountOutMin,\r\n            \"VaderRouterV2::swapExactTokensForTokens: Insufficient Trade Output\"\r\n        );\r\n    }\r\n\r\n    \/* ========== RESTRICTED FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n    * @dev Sets the reserve address and renounces contract's ownership.\r\n     *\r\n     * Requirements:\r\n     * - Only existing owner can call this function.\r\n     * - Param {_reserve} cannot be a zero address.\r\n     **\/\r\n    function initialize(IVaderReserve _reserve) external onlyOwner {\r\n        require(\r\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\r\n            \"VaderRouterV2::initialize: Incorrect Reserve Specified\"\r\n        );\r\n\r\n        reserve = _reserve;\r\n\r\n        renounceOwnership();\r\n    }\r\n\r\n    \/* ========== INTERNAL FUNCTIONS ========== *\/\r\n\r\n    \/* ========== PRIVATE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Allows swapping of assets from within a single Vader pool pair or\r\n     * across two different Vader pairs.\r\n     *\r\n     * In case of a single Vader pair, the native asset can be swapped for foreign\r\n     * asset and vice versa.\r\n     *\r\n     * In case of two Vader pairs, the foreign asset is swapped for native asset from\r\n     * the first Vader pool and the native asset retrieved from the first Vader pair is swapped\r\n     * for foreign asset from the second Vader pair.\r\n     *\r\n     * Requirements:\r\n     * - Param {path} length can be either 2 or 3.\r\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\r\n     *   and index 1 must contain native asset's address.\r\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\r\n     *   and the other one must contain native asset's address.\r\n     **\/\r\n    function _swap(\r\n        uint256 amountIn,\r\n        IERC20[] calldata path,\r\n        address to\r\n    ) private returns (uint256 amountOut) {\r\n        if (path.length == 3) {\r\n            require(\r\n                path[0] != path[1] &&\r\n                    path[1] == pool.nativeAsset() &&\r\n                    path[2] != path[1],\r\n                \"VaderRouterV2::_swap: Incorrect Path\"\r\n            );\r\n\r\n            path[0].safeTransferFrom(msg.sender, address(pool), amountIn);\r\n\r\n            return pool.doubleSwap(path[0], path[2], amountIn, to);\r\n        } else {\r\n            require(\r\n                path.length == 2,\r\n                \"VaderRouterV2::_swap: Incorrect Path Length\"\r\n            );\r\n            IERC20 _nativeAsset = nativeAsset;\r\n            require(path[0] != path[1], \"VaderRouterV2::_swap: Incorrect Path\");\r\n\r\n            path[0].safeTransferFrom(msg.sender, address(pool), amountIn);\r\n            if (path[0] == _nativeAsset) {\r\n                return pool.swap(path[1], amountIn, 0, to);\r\n            } else {\r\n                require(\r\n                    path[1] == _nativeAsset,\r\n                    \"VaderRouterV2::_swap: Incorrect Path\"\r\n                );\r\n                return pool.swap(path[0], 0, amountIn, to);\r\n            }\r\n        }\r\n    }\r\n\r\n    \/* ========== MODIFIERS ========== *\/\r\n\r\n    \/\/ Guard ensuring that the current timestamp has not exceeded the param {deadline}.\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, \"VaderRouterV2::ensure: Expired\");\r\n        _;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-31-unused-slippage-params",
                "Location":"function addLiquidity(\r\n        IERC20 tokenA,\r\n        IERC20 tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256, \/\/ amountAMin = unused\r\n        uint256, \/\/ amountBMin = unused\r\n        address to,\r\n        uint256 deadline\r\n    )",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.Unused slippage params. function addLiquidity in VaderRouter (both V1 and V2) do not use slippage parameters: uint256, // amountAMin = unused uint256, // amountBMin = unused,making it susceptible to sandwich attacks / MEV.",
                "Repair":"Consider paying some attention to the slippage to reduce possible manipulation attacks from mempool snipers."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.10;\r\n\r\nimport \".\/curve\/ICurve.sol\";\r\nimport \".\/BaseStrategy.sol\";\r\nimport {IERC20} from \"@openzeppelin\/contracts\/token\/ERC20\/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin\/contracts\/token\/ERC20\/utils\/SafeERC20.sol\";\r\n\r\n\/**\r\n * Strategy that handles non-UST tokens, by first converting them to UST via\r\n * Curve (https:\/\/curve.fi\/), and only then depositing into EthAnchor\r\n *\/\r\ncontract NonUSTStrategy is BaseStrategy {\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/\/ address of the Curve pool to use\r\n    ICurve public curvePool;\r\n\r\n    \/\/ index of the underlying token in the pool\r\n    int128 public underlyingI;\r\n\r\n    \/\/ index of the UST token in the pool\r\n    int128 public ustI;\r\n\r\n    constructor(\r\n        address _vault,\r\n        address _treasury,\r\n        address _ethAnchorRouter,\r\n        address _exchangeRateFeeder,\r\n        IERC20 _ustToken,\r\n        IERC20 _aUstToken,\r\n        uint16 _perfFeePct,\r\n        address _owner,\r\n        address _curvePool,\r\n        int128 _underlyingI,\r\n        int128 _ustI\r\n    )\r\n        BaseStrategy(\r\n            _vault,\r\n            _treasury,\r\n            _ethAnchorRouter,\r\n            _exchangeRateFeeder,\r\n            _ustToken,\r\n            _aUstToken,\r\n            _perfFeePct,\r\n            _owner\r\n        )\r\n    {\r\n        require(underlying != _ustToken, \"invalid underlying\");\r\n        require(_curvePool != address(0), \"0x addr\");\r\n        curvePool = ICurve(_curvePool);\r\n        underlyingI = _underlyingI;\r\n        ustI = _ustI;\r\n\r\n        ustToken.safeApprove(_curvePool, type(uint256).max);\r\n        underlying.safeApprove(_curvePool, type(uint256).max);\r\n    }\r\n\r\n    \/**\r\n     * Swaps the underlying currency for UST, and initiates a deposit of all\r\n     * the converted UST into EthAnchor\r\n     *\r\n     * @notice since EthAnchor uses an asynchronous model, this function\r\n     * only starts the deposit process, but does not finish it.\r\n     *\/\r\n    function doHardWork() external override(BaseStrategy) restricted {\r\n        _swapUnderlyingToUst();\r\n        _initDepositStable();\r\n    }\r\n\r\n    \/**\r\n     * Calls Curve to convert the existing underlying balance into UST\r\n     *\/\r\n    function _swapUnderlyingToUst() internal {\r\n        uint256 underlyingBalance = _getUnderlyingBalance();\r\n        if (underlyingBalance > 0) {\r\n            \/\/ slither-disable-next-line unused-return\r\n            curvePool.exchange_underlying(\r\n                underlyingI,\r\n                ustI,\r\n                underlyingBalance,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Calls Curve to convert the existing UST back into the underlying token\r\n     *\/\r\n    function _swapUstToUnderlying() internal {\r\n        uint256 ustBalance = _getUstBalance();\r\n        if (ustBalance > 0) {\r\n            \/\/ slither-disable-next-line unused-return\r\n            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\r\n     * Once UST is retrieved, convert it back to underlying via Curve\r\n     *\r\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\r\n     * the EthAnchor bridge has finished processing the deposit.\r\n     *\r\n     * @param idx Id of the pending redeem operation\r\n     *\/\r\n    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {\r\n        super.finishRedeemStable(idx);\r\n        _swapUstToUnderlying();\r\n    }\r\n\r\n    \/**\r\n     * Amount, expressed in the underlying currency, currently in the strategy\r\n     *\r\n     * @notice both held and invested amounts are included here, using the\r\n     * latest known exchange rates to the underlying currency\r\n     *\r\n     * @return The total amount of underlying\r\n     *\/\r\n    function investedAssets()\r\n        external\r\n        view\r\n        override(BaseStrategy)\r\n        returns (uint256)\r\n    {\r\n        uint256 underlyingBalance = _getUnderlyingBalance();\r\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\r\n\r\n        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\r\n            address(aUstToken),\r\n            true\r\n        ) * aUstBalance) \/ 1e18) + pendingDeposits;\r\n        return\r\n            underlyingBalance +\r\n            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-01-sandclock#h-03-vaults-with-non-ust-underlying-asset-vulnerable-to-flash-loan-attack-on-curve-pool",
                "Location":"curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.In short, the NonUSTStrategy is vulnerable to attacks by flash loans on curve pools. Here’s an outline of the attack: Assume there is a vault with DAI underlying and a NonUSTStrategy with a DAI / UST curve pool Take out a flash loan of DAI Exchange a ton of DAI for UST The exchange rate from DAI to UST has gone up (!!) Withdraw or deposit from vault with more favorable terms than market Transfer back UST to DAI Repay flash loan",
                "Repair":"Use an oracle"
            }
        ]
    },
    {
        "Code":"function burn(uint256 id, address to)\r\n        external\r\n        override\r\n        onlyRouter\r\n        returns (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        )\r\n    {\r\n        (amountNative, amountForeign) = _burn(id, to);\r\n\r\n        Position storage position = positions[id];\r\n\r\n        uint256 creation = position.creation;\r\n        uint256 originalNative = position.originalNative;\r\n        uint256 originalForeign = position.originalForeign;\r\n\r\n        delete positions[id];\r\n\r\n        uint256 loss = VaderMath.calculateLoss(\r\n            originalNative,\r\n            originalForeign,\r\n            amountNative,\r\n            amountForeign\r\n        );\r\n\r\n        \/\/ TODO: Original Implementation Applied 100 Days\r\n        coveredLoss =\r\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) \/\r\n            _ONE_YEAR;\r\n    }\r\n\r\n    function calculateLoss(\r\n        uint256 originalVader,\r\n        uint256 originalAsset,\r\n        uint256 releasedVader,\r\n        uint256 releasedAsset\r\n    ) internal pure returns (uint256 loss) {\r\n        \/\/\r\n        \/\/ TODO: Vader Formula Differs https:\/\/github.com\/vetherasset\/vaderprotocol-contracts\/blob\/main\/contracts\/Utils.sol#L347-L356\r\n        \/\/\r\n\r\n        \/\/ [(A0 * P1) + V0]\r\n        uint256 originalValue = ((originalAsset * releasedVader) \/\r\n            releasedAsset) + originalVader;\r\n\r\n        \/\/ [(A1 * P1) + V1]\r\n        uint256 releasedValue = ((releasedAsset * releasedVader) \/\r\n            releasedAsset) + releasedVader;\r\n\r\n        \/\/ [(A0 * P1) + V0] - [(A1 * P1) + V1]\r\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;\r\n    }",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-12-vader#h-06-lps-of-vaderpoolv2-can-manipulate-pool-reserves-to-extract-funds-from-the-reserve",
                "Location":"uint256 originalValue = ((originalAsset * releasedVader) \/\r\n            releasedAsset) + originalVader;\r\n\r\n        \/\/ [(A1 * P1) + V1]\r\n        uint256 releasedValue = ((releasedAsset * releasedVader) \/\r\n            releasedAsset) + releasedVader;\r\n\r\n        \/\/ [(A0 * P1) + V0] - [(A1 * P1) + V1]\r\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.In VaderPoolV2.burn we calculate the current losses that the LP has made to impermanent loss.These losses are then refunded to the LP in VADER tokens from the reserve.This loss is calculated by the current reserves of the pool so if an LP can manipulate the pool’s reserves they can artificially engineer a huge amount of IL in order to qualify for a payout up to the size of their LP position.",
                "Repair":"Use a manipulation resistant oracle for the relative prices of the pool’s assets (TWAP, etc.)"
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\r\npragma solidity =0.8.9;\r\n\r\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\n\r\nimport \".\/BasePoolV2.sol\";\r\n\r\nimport \"..\/..\/external\/libraries\/FixedPoint.sol\";\r\n\r\nimport \"..\/..\/interfaces\/shared\/IERC20Extended.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/pool\/IVaderPoolV2.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/wrapper\/ILPWrapper.sol\";\r\nimport \"..\/..\/interfaces\/dex-v2\/synth\/ISynthFactory.sol\";\r\n\r\n\/*\r\n * @dev Implementation of {VaderPoolV2} contract.\r\n *\r\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\r\n * queue system.\r\n *\r\n * Extends on the liquidity redeeming function by introducing the `burn` function\r\n * that internally calls the namesake on `BasePoolV2` contract and computes the\r\n * loss covered by the position being redeemed and returns it along with amounts\r\n * of native and foreign assets sent.\r\n **\/\r\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\r\n    \/* ========== LIBRARIES ========== *\/\r\n\r\n    \/\/ Used for safe token transfers\r\n    using SafeERC20 for IERC20;\r\n\r\n    \/* ========== STATE VARIABLES ========== *\/\r\n\r\n    \/\/ The LP wrapper contract\r\n    ILPWrapper public wrapper;\r\n\r\n    \/\/ The Synth Factory\r\n    ISynthFactory public synthFactory;\r\n\r\n    \/\/ Denotes whether the queue system is active\r\n    bool public queueActive;\r\n\r\n    \/* ========== CONSTRUCTOR ========== *\/\r\n\r\n    \/*\r\n     * @dev Initialised the contract state by passing the native asset's address\r\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\r\n     * to the {queueActive} state variable.\r\n     **\/\r\n    constructor(bool _queueActive, IERC20 _nativeAsset)\r\n        BasePoolV2(_nativeAsset)\r\n    {\r\n        queueActive = _queueActive;\r\n    }\r\n\r\n    \/* ========== VIEWS ========== *\/\r\n\r\n    \/*\r\n     * @dev Returns cumulative prices and the timestamp the were last updated\r\n     * for both native and foreign assets against the pair specified by\r\n     * parameter {foreignAsset}.\r\n     **\/\r\n    function cumulativePrices(IERC20 foreignAsset)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 price0CumulativeLast,\r\n            uint256 price1CumulativeLast,\r\n            uint32 blockTimestampLast\r\n        )\r\n    {\r\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\r\n            .priceCumulative;\r\n        price0CumulativeLast = priceCumulative.nativeLast;\r\n        price1CumulativeLast = priceCumulative.foreignLast;\r\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\r\n\r\n        if (blockTimestampLast < block.timestamp) {\r\n            uint256 timeElapsed = block.timestamp - blockTimestampLast;\r\n            unchecked {\r\n                price0CumulativeLast +=\r\n                    uint256(\r\n                        FixedPoint\r\n                            .fraction(\r\n                                pairInfo[foreignAsset].reserveForeign,\r\n                                pairInfo[foreignAsset].reserveNative\r\n                            )\r\n                            ._x\r\n                    ) *\r\n                    timeElapsed;\r\n                price1CumulativeLast +=\r\n                    uint256(\r\n                        FixedPoint\r\n                            .fraction(\r\n                                pairInfo[foreignAsset].reserveNative,\r\n                                pairInfo[foreignAsset].reserveForeign\r\n                            )\r\n                            ._x\r\n                    ) *\r\n                    timeElapsed;\r\n            }\r\n        }\r\n    }\r\n\r\n    \/* ========== MUTATIVE FUNCTIONS ========== *\/\r\n\r\n    \/*\r\n     * @dev Initializes contract's state with LP wrapper, synth factory\r\n     * and router addresses.\r\n     *\r\n     * Requirements:\r\n     * - None of the parameters are zero addresses.\r\n     * - The parameters are not already set.\r\n     * - Only callable by contract owner.\r\n     **\/\r\n    function initialize(\r\n        ILPWrapper _wrapper,\r\n        ISynthFactory _synthFactory,\r\n        address _router\r\n    ) external onlyOwner {\r\n        require(\r\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Already initialized\"\r\n        );\r\n        require(\r\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\r\n        );\r\n        require(\r\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\r\n        );\r\n        require(\r\n            _router != _ZERO_ADDRESS,\r\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\r\n        );\r\n        wrapper = _wrapper;\r\n        synthFactory = _synthFactory;\r\n        router = _router;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\r\n     * on the native asset amount deposited and returns the minted synth asset amount.\r\n     *\r\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must be a supported token.\r\n     **\/\r\n    function mintSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        address from,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        supportedToken(foreignAsset)\r\n        returns (uint256 amountSynth)\r\n    {\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        if (synth == ISynth(_ZERO_ADDRESS))\r\n            synth = synthFactory.createSynth(\r\n                IERC20Extended(address(foreignAsset))\r\n            );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountSynth = VaderMath.calculateSwap(\r\n            nativeDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        synth.mint(to, amountSynth);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\r\n     * and returns the redeemed amount of native asset.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Requirements:\r\n     * - {foreignAsset} must have a valid synthetic asset against it.\r\n     * - {synthAmount} must be greater than zero.\r\n     **\/\r\n    function burnSynth(\r\n        IERC20 foreignAsset,\r\n        uint256 synthAmount,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 amountNative) {\r\n        ISynth synth = synthFactory.synths(foreignAsset);\r\n\r\n        require(\r\n            synth != ISynth(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\r\n        );\r\n\r\n        require(\r\n            synthAmount > 0,\r\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\r\n        );\r\n\r\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\r\n        synth.burn(synthAmount);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        amountNative = VaderMath.calculateSwap(\r\n            synthAmount,\r\n            reserveForeign,\r\n            reserveNative\r\n        );\r\n\r\n        \/\/ TODO: Clarify\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\r\n     *\r\n     * Deletes the position in {positions} mapping against the burned NFT token.\r\n     *\r\n     * Internally calls `_burn` function on {BasePoolV2} contract.\r\n     *\r\n     * Calculates the impermanent loss incurred by the position.\r\n     *\r\n     * Returns the amounts for native and foreign assets sent to the {to} address\r\n     * along with the covered loss.\r\n     *\r\n     * Requirements:\r\n     * - Can only be called by the Router.\r\n     **\/\r\n    \/\/ NOTE: IL is only covered via router!\r\n    \/\/ NOTE: Loss is in terms of USDV\r\n    function burn(uint256 id, address to)\r\n        external\r\n        override\r\n        onlyRouter\r\n        returns (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        )\r\n    {\r\n        (amountNative, amountForeign) = _burn(id, to);\r\n\r\n        Position storage position = positions[id];\r\n\r\n        uint256 creation = position.creation;\r\n        uint256 originalNative = position.originalNative;\r\n        uint256 originalForeign = position.originalForeign;\r\n\r\n        delete positions[id];\r\n\r\n        uint256 loss = VaderMath.calculateLoss(\r\n            originalNative,\r\n            originalForeign,\r\n            amountNative,\r\n            amountForeign\r\n        );\r\n\r\n        \/\/ TODO: Original Implementation Applied 100 Days\r\n        coveredLoss =\r\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) \/\r\n            _ONE_YEAR;\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\r\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\r\n     * tracked within this contract along with liquidity issued against non-fungible\r\n     * token.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'mint' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     **\/\r\n    function mintFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 nativeDeposit,\r\n        uint256 foreignDeposit,\r\n        address from,\r\n        address to\r\n    ) external override nonReentrant returns (uint256 liquidity) {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\r\n        );\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\r\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 totalLiquidityUnits = pair.totalSupply;\r\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\r\n        else\r\n            liquidity = VaderMath.calculateLiquidityUnits(\r\n                nativeDeposit,\r\n                reserveNative,\r\n                foreignDeposit,\r\n                reserveForeign,\r\n                totalLiquidityUnits\r\n            );\r\n\r\n        require(\r\n            liquidity > 0,\r\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\r\n        );\r\n\r\n        pair.totalSupply = totalLiquidityUnits + liquidity;\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative + nativeDeposit,\r\n            reserveForeign + foreignDeposit,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        lp.mint(to, liquidity);\r\n\r\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows burning of liquidity issued in fungible tokens.\r\n     *\r\n     * Updates the cumulative prices for native and foreign assets.\r\n     *\r\n     * Calls 'burn' on the LP wrapper token contract.\r\n     *\r\n     * Requirements:\r\n     * - LP wrapper token must exist against {foreignAsset}.\r\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\r\n     **\/\r\n    function burnFungible(\r\n        IERC20 foreignAsset,\r\n        uint256 liquidity,\r\n        address to\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        returns (uint256 amountNative, uint256 amountForeign)\r\n    {\r\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\r\n\r\n        require(\r\n            lp != IERC20Extended(_ZERO_ADDRESS),\r\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\r\n        );\r\n\r\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\r\n        lp.burn(liquidity);\r\n\r\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\r\n            foreignAsset\r\n        ); \/\/ gas savings\r\n\r\n        PairInfo storage pair = pairInfo[foreignAsset];\r\n        uint256 _totalSupply = pair.totalSupply;\r\n        amountNative = (liquidity * reserveNative) \/ _totalSupply;\r\n        amountForeign = (liquidity * reserveForeign) \/ _totalSupply;\r\n\r\n        require(\r\n            amountNative > 0 && amountForeign > 0,\r\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\r\n        );\r\n\r\n        pair.totalSupply = _totalSupply - liquidity;\r\n\r\n        nativeAsset.safeTransfer(to, amountNative);\r\n        foreignAsset.safeTransfer(to, amountForeign);\r\n\r\n        _update(\r\n            foreignAsset,\r\n            reserveNative - amountNative,\r\n            reserveForeign - amountForeign,\r\n            reserveNative,\r\n            reserveForeign\r\n        );\r\n\r\n        emit Burn(msg.sender, amountNative, amountForeign, to);\r\n    }\r\n\r\n    \/* ========== RESTRICTED FUNCTIONS ========== *\/\r\n\r\n    function setQueue(bool _queueActive) external override onlyOwner {\r\n        require(\r\n            _queueActive != queueActive,\r\n            \"VaderPoolV2::setQueue: Already At Desired State\"\r\n        );\r\n        queueActive = _queueActive;\r\n        emit QueueActive(_queueActive);\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setTokenSupport(\r\n        IERC20 foreignAsset,\r\n        bool support,\r\n        uint256 nativeDeposit,\r\n        uint256 foreignDeposit,\r\n        address from,\r\n        address to\r\n    ) external override onlyOwner returns (uint256 liquidity) {\r\n        require(\r\n            supported[foreignAsset] != support,\r\n            \"VaderPoolV2::supportToken: Already At Desired State\"\r\n        );\r\n        supported[foreignAsset] = support;\r\n        if (!support) {\r\n            PairInfo storage pair = pairInfo[foreignAsset];\r\n            require(\r\n                pair.reserveNative == 0 && pair.reserveForeign == 0,\r\n                \"VaderPoolV2::supportToken: Cannot Unsupport Token w\/ Liquidity\"\r\n            );\r\n        } else {\r\n            require(\r\n                nativeDeposit != 0 && foreignDeposit != 0,\r\n                \"VaderPoolV2::supportToken: Improper First-Time Liquidity Provision\"\r\n            );\r\n            liquidity = _mint(\r\n                foreignAsset,\r\n                nativeDeposit,\r\n                foreignDeposit,\r\n                from,\r\n                to\r\n            );\r\n        }\r\n    }\r\n\r\n    \/*\r\n     * @dev Allows the gas throttle to be toggled on\/off in case of emergency\r\n     **\/\r\n    function setGasThrottle(bool _gasThrottleEnabled)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(\r\n            gasThrottleEnabled != _gasThrottleEnabled,\r\n            \"VaderPoolV2::setGasThrottle: Already At Desired State\"\r\n        );\r\n        gasThrottleEnabled = _gasThrottleEnabled;\r\n    }\r\n\r\n    \/*\r\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\r\n     *\r\n     * Requirements:\r\n     * - The param {foreignAsset} is not already a supported token.\r\n     **\/\r\n    function setFungibleTokenSupport(IERC20 foreignAsset)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        wrapper.createWrapper(foreignAsset);\r\n    }\r\n\r\n    \/* ========== INTERNAL FUNCTIONS ========== *\/\r\n\r\n    \/* ========== PRIVATE FUNCTIONS ========== *\/\r\n\r\n    \/**\r\n     * @dev Calculates the minimum of the two values\r\n     *\/\r\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-12-vader#h-07-redemption-value-of-synths-can-be-manipulated-to-drain-vaderpoolv2-of-all-native-assets-in-the-associated-pair",
                "Location":"mintSynth function",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.As the pool’s reserves can be manipulated through flashloans similar to on UniswapV2 (the slip mechanism can be mitigated by splitting the manipulation over a number of trades), an attacker may set the exchange rate between nativeAsset and synths (calculated from the reserves). An attacker can exploit this to drain funds from the pool.",
                "Repair":"Tie the exchange rate use for minting/burning synths to a manipulation resistant oracle."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \".\/facades\/FlanLike.sol\";\r\nimport \".\/facades\/PyroTokenLike.sol\";\r\nimport \".\/DAO\/Governable.sol\";\r\nimport \".\/ERC677\/ERC20Burnable.sol\";\r\nimport \".\/facades\/UniPairLike.sol\";\r\nimport \"hardhat\/console.sol\";\r\n\r\n\/\/\/@title FlanBackstop (placeholder name)\r\n\/\/\/@author Justin Goro\r\n\/**\r\n * @notice Initially Flan's liquidity may be fairly low, limiting Limbo's ability to reward souls. Flan backstop accepts stablecoins in return for minting Pyroflan.\r\n *Under the hood a smaller quantity of Flan is minted and paired with the stablecoin in Uniswap in order to tilt the price of Flan higher while incresaing liquidity.\r\n * The same operation is performed with PyroFlan\r\n * The calling user then receives PyroFlan equal in value to the intial amount sent in but at the new price. A small premium is added.\r\n * The incentives facing the user: mint $X of PyroFlan with <$X of stablecoin, stake PyroFlan in Limbo for high APY, do not immediately dump because PyroFlan increases in value and because of 2% exit fee.\r\n * The incentives should be enough to encourage a gradual increase in pooled Flan and stablecoins, creating some minting runway for Limbo to accelerate.\r\n * In the future when Flan and Limbo are thriving and Flan is listed on Curve, we can create a version of this for Curve and Uniswap V3 in order to concentrate Flan liquidity and further cement stablecoin status.\r\n * Note: in this version, LP tokens generated are cast into the void. The argument of keeping them for fee revenue is negated by the impact on Flan. It would just be taking from Peter to give to Paul. \r\n *\/\r\n\/\/\/@dev This contract uses Pyrotokens3. At the time of authoring, Pyrotokens3 implementation is incomplete and not fully tested but the interface (ABI) is locked.\r\ncontract FlanBackstop is Governable {\r\n  \/**\r\n   *@param dao LimboDAO\r\n   *@param flan Flan address\r\n   *@param pyroFlan PyroFlan address\r\n   *\/\r\n  constructor(\r\n    address dao,\r\n    address flan,\r\n    address pyroFlan\r\n  ) Governable(dao) {\r\n    config.pyroFlan = pyroFlan;\r\n    config.flan = flan;\r\n    IERC20(flan).approve(pyroFlan, 2**256 - 1);\r\n  }\r\n\r\n  struct ConfigVars {\r\n    address flan;\r\n    address pyroFlan;\r\n    mapping(address => address) flanLPs;\r\n    mapping(address => address) pyroFlanLPs;\r\n    mapping(address => uint256) acceptableHighestPrice; \/\/Highest tolerated Flan per stable\r\n    mapping(address => uint8) decimalPlaces; \/\/USDC and USDT have 6 decimal places because large stablecoin transfers are exactly where you'd like to find accidental bugs\r\n  }\r\n\r\n  ConfigVars public config;\r\n\r\n  \/**\r\n   *@param stablecoin One of the popular stablecoins such as USDC, USDT, MIM, OUSD etc.\r\n   *@param flanLP Uniswap V2 (or a fork such as Sushi) flan\/Stablecoin LP\r\n   *@param pyroFlanLP Uniswap V2 (or a fork such as Sushi) pyroFlan\/Stablecoin LP\r\n   *@param acceptableHighestPrice Since the prices are being read from balances, not oracles, the opportunity for price manipulation through flash loans exists. The community can put a circuit breaker in place to prevent such an exploit.\r\n   *@param decimalPlaces USDT and USDC do not conform to common ERC20 practice. \r\n   *\/\r\n  function setBacker(\r\n    address stablecoin,\r\n    address flanLP,\r\n    address pyroFlanLP,\r\n    uint256 acceptableHighestPrice,\r\n    uint8 decimalPlaces\r\n  ) external onlySuccessfulProposal {\r\n    config.flanLPs[stablecoin] = flanLP;\r\n    config.pyroFlanLPs[stablecoin] = pyroFlanLP;\r\n    config.acceptableHighestPrice[stablecoin] = acceptableHighestPrice;\r\n    config.decimalPlaces[stablecoin] = decimalPlaces;\r\n  }\r\n\r\n  \/**\r\n  *@notice takes in a stablecoin, mints flan and pyroFlan and pairs with stablecoin in a Uniswap Pair to generate liquidity\r\n   *@param stablecoin Stablecoin with which to purchase\r\n   *@param amount amount in stablecoin wei units.\r\n   *\/\r\n  function purchasePyroFlan(address stablecoin, uint256 amount) external {\r\n    uint normalizedAmount = normalize(stablecoin, amount);\r\n    address flanLP = config.flanLPs[stablecoin];\r\n    address pyroFlanLP = config.pyroFlanLPs[stablecoin];\r\n    require(flanLP != address(0) && pyroFlanLP != address(0), \"BACKSTOP: configure stablecoin\");\r\n\r\n    uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);\r\n    uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);\r\n    uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) \/ balanceOfStableBefore;\r\n\r\n    \/\/Price tilt pairs and mint liquidity\r\n    FlanLike(config.flan).mint(address(this), normalizedAmount \/ 2);\r\n    IERC20(config.flan).transfer(flanLP, normalizedAmount \/ 4);\r\n    IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount \/ 2);\r\n\r\n    UniPairLike(flanLP).mint(address(this));\r\n    uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\r\n    PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount \/ 4);\r\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\r\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\r\n    IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount \/ 2);\r\n    UniPairLike(pyroFlanLP).mint(address(this));\r\n\r\n    uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);\r\n    uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);\r\n\r\n    uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) \/ balanceOfStable;\r\n    require(tiltedPrice < config.acceptableHighestPrice[stablecoin], \"BACKSTOP: potential price manipulation\");\r\n    uint256 growth = ((priceBefore - tiltedPrice) * 100) \/ priceBefore;\r\n\r\n    uint256 flanToMint = (tiltedPrice * normalizedAmount) \/ (1 ether);\r\n\r\n    \/\/share some price tilting with the user to incentivize minting: The larger the purchase, the better the return\r\n    uint256 premium = (flanToMint * (growth \/ 2)) \/ 100;\r\n\r\n    FlanLike(config.flan).mint(address(this), flanToMint + premium);\r\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\r\n    PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);\r\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\r\n  }\r\n\r\n  function getMagnitude(address token) internal view returns (uint256) {\r\n    uint256 places = config.decimalPlaces[token];\r\n    return 10**places;\r\n  }\r\n\r\n  function normalize(address token, uint256 amount) internal view returns (uint256) {\r\n    uint256 places = config.decimalPlaces[token];\r\n    uint256 bump = 10**(18 - places);\r\n    return amount * bump;\r\n  }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-01-behodler#h-05-flash-loan-price-manipulation-in-purchasepyroflan",
                "Location":"uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) \/ balanceOfStableBefore;\r\nuint256 growth = ((priceBefore - tiltedPrice) * 100) \/ priceBefore;\r\nuint256 premium = (flanToMint * (growth \/ 2)) \/ 100;",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.Problems can occur when the volumes that the purchasePyroFlan() function sends to the Uniswap pool are large compared to the pool’s liquidity volume, or if the Uniswap pool price is temporarily tilted with a flashloan (or a whale). Because this function purposefully changes the exchange rate of the LP, by transferring tokens to the LP in a 2-to-1 ratio, a large volume could caught a large price impact in the LP. The code attempts to protect against this manipulation in line 102 with a require statement, but this can be worked around by reducing the volume per flashloan and repeating the attack multiple times. A user can manipulate the LP, especially when the LP is new with low liquidity, in order to achieve large amounts of flan and pyroflan.",
                "Repair":"Use a TWAP instead of the pool price at a single point in time to increase the cost of performing a flashloan sandwich attack. See the Uniswap v2 price oracle solution documentation for more explanations on how Uniswap designed an approach to providing asset prices while reducing the change of manipulation."
            }
        ]
    },
    {
        "Code":"\/\/\/@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.\r\n  \/\/\/@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question\r\n  \/\/\/@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half\r\n  \/\/\/@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm\r\n  \/\/\/@param asset the asset being staked\r\n  function setEYEBasedAssetStake(\r\n    uint256 finalAssetBalance,\r\n    uint256 finalEYEBalance,\r\n    uint256 rootEYE,\r\n    address asset\r\n  ) public isLive incrementFate {\r\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\r\n    address sender = _msgSender();\r\n    FateGrowthStrategy strategy = fateGrowthStrategy[asset];\r\n\r\n    \/\/verifying that rootEYE value is accurate within precision.\r\n    uint256 rootEYESquared = rootEYE * rootEYE;\r\n    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);\r\n    require(\r\n      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,\r\n      \"LimboDAO: Stake EYE invariant.\"\r\n    );\r\n    AssetClout storage clout = stakedUserAssetWeight[sender][asset];\r\n    fateState[sender].fatePerDay -= clout.fateWeight;\r\n    uint256 initialBalance = clout.balance;\r\n    \/\/EYE\r\n    if (strategy == FateGrowthStrategy.directRoot) {\r\n      require(finalAssetBalance == finalEYEBalance, \"LimboDAO: staking eye invariant.\");\r\n      require(asset == domainConfig.eye);\r\n\r\n      clout.fateWeight = rootEYE;\r\n      clout.balance = finalAssetBalance;\r\n      fateState[sender].fatePerDay += rootEYE;\r\n    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {\r\n      \/\/LP\r\n      clout.fateWeight = 2 * rootEYE;\r\n      fateState[sender].fatePerDay += clout.fateWeight;\r\n\r\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\r\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\r\n      uint256 totalSupply = IERC20(asset).totalSupply();\r\n      uint256 eyePerUnit = (actualEyeBalance * ONE) \/ totalSupply;\r\n      uint256 impliedEye = (eyePerUnit * finalAssetBalance) \/ (ONE * precision);\r\n      finalEYEBalance \/= precision;\r\n      require(\r\n        finalEYEBalance == impliedEye, \/\/precision cap\r\n        \"LimboDAO: stake invariant check 2.\"\r\n      );\r\n      clout.balance = finalAssetBalance;\r\n    } else {\r\n      revert(\"LimboDAO: asset growth strategy not accounted for\");\r\n    }\r\n    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);\r\n    asset.ERC20NetTransfer(sender, address(this), netBalance);\r\n  }\r\n \r\n\r\n\/**\r\n   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.\r\n   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset\r\n   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.\r\n   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent\r\n   * loss of EYE.\r\n   *@param asset the asset to burn and can be EYE or EYE based assets\r\n   *@param amount the amount of asset to burn\r\n   *\/\r\n  function burnAsset(address asset, uint256 amount) public isLive incrementFate {\r\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\r\n    address sender = _msgSender();\r\n    require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\");\r\n    uint256 fateCreated = fateState[_msgSender()].fateBalance;\r\n    if (asset == domainConfig.eye) {\r\n      fateCreated = amount * 10;\r\n      ERC677(domainConfig.eye).burn(amount);\r\n    } else {\r\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\r\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\r\n      uint256 totalSupply = IERC20(asset).totalSupply();\r\n      uint256 eyePerUnit = (actualEyeBalance * ONE) \/ totalSupply;\r\n      uint256 impliedEye = (eyePerUnit * amount) \/ ONE;\r\n      fateCreated = impliedEye * 20;\r\n    }\r\n    fateState[_msgSender()].fateBalance += fateCreated;\r\n    emit assetBurnt(_msgSender(), asset, fateCreated);\r\n  }",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-01-behodler#h-07-lp-pricing-formula-is-vulnerable-to-flashloan-manipulation",
                "Location":"uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.The LP pricing formula used in the burnAsset function of LimboDAO is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more fate than he is supposed to with a relatively low cost. With the large portion of fate he gets, he has more voting power to influence the system’s decisions, or even he can convert his fate to Flan tokens for a direct profit.",
                "Repair":"Use a fair pricing formula for the LP tokens, for example, the one proposed by Alpha Finance."
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport { SafeERC20 } from \"@openzeppelin\/contracts\/token\/ERC20\/utils\/SafeERC20.sol\";\r\nimport { IERC20 } from \"@openzeppelin\/contracts\/token\/ERC20\/IERC20.sol\";\r\nimport { Ownable } from \"@openzeppelin\/contracts\/access\/Ownable.sol\";\r\nimport { ICurveMetaPool } from \".\/external\/CurveInterfaces.sol\";\r\n\r\ncontract USDMPegRecovery is Ownable {\r\n\r\n    using SafeERC20 for IERC20; \r\n\r\n    IERC20 public immutable usdm;\r\n\r\n    IERC20 public immutable pool3;\r\n\r\n    ICurveMetaPool public immutable usdm3crv;\r\n\r\n    address public immutable kpiOracle;\r\n\r\n    uint256 public step;\r\n\r\n    uint256 public startLiquidity;\r\n\r\n    struct Liquidity {\r\n        uint128 usdm;\r\n        uint128 pool3;\r\n    }\r\n\r\n    event Deposit(address indexed depositor, Liquidity deposits);\r\n\r\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\r\n\r\n    Liquidity public totalLiquidity;\r\n\r\n    mapping(address => Liquidity) public userLiquidity;\r\n\r\n    mapping(address => bool) public isGuardian;\r\n\r\n    bool public unlockable;\r\n\r\n    modifier onlyGuardian() {\r\n        require(isGuardian[msg.sender], \"!guardian\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _startLiquidity,\r\n        address _kpiOracle\r\n    ) Ownable() {\r\n        startLiquidity = _startLiquidity;\r\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\r\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\r\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\r\n        step = 250000e18;\r\n        kpiOracle = _kpiOracle;\r\n    }\r\n\r\n    function addGuardian(address _guardian) external onlyOwner {\r\n        isGuardian[_guardian] = true;\r\n    }\r\n\r\n    function removeGuardian(address _guardian) external onlyOwner {\r\n        isGuardian[_guardian] = false;\r\n    }\r\n\r\n    function enableUnlock() external {\r\n        require(msg.sender == kpiOracle, \"!oracle\");\r\n        unlockable = true;\r\n    }\r\n\r\n    function provide(uint256 _minimumLP) external onlyGuardian {\r\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\r\n        \/\/ truncate amounts under step\r\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) \/ step) * step;\r\n        \/\/ match usdm : pool3 = 1 : 1\r\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\r\n        usdm.approve(address(usdm3crv), addingLiquidity);\r\n        pool3.approve(address(usdm3crv), addingLiquidity);\r\n        usdm3crv.add_liquidity(amounts, _minimumLP);\r\n    }\r\n\r\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\r\n        uint256 removingLiquidity = _steps * step;\r\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\r\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\r\n    }\r\n\r\n    function deposit(Liquidity calldata _deposits) external {\r\n        Liquidity memory total = totalLiquidity;\r\n        Liquidity memory user = userLiquidity[msg.sender];\r\n        if(_deposits.usdm > 0) {\r\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\r\n            total.usdm += _deposits.usdm;\r\n            user.usdm += _deposits.usdm;\r\n        }\r\n\r\n        if(_deposits.pool3 > 0) {\r\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\r\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\r\n            total.pool3 += _deposits.pool3;\r\n            user.pool3 += _deposits.pool3;\r\n        }\r\n        totalLiquidity = total;\r\n        userLiquidity[msg.sender] = user;\r\n        emit Deposit(msg.sender, _deposits);\r\n    }\r\n\r\n    function withdraw(Liquidity calldata _withdrawal) external {\r\n        Liquidity memory total = totalLiquidity;\r\n        Liquidity memory user = userLiquidity[msg.sender];\r\n        if(_withdrawal.usdm > 0) {\r\n            require(unlockable, \"!unlock usdm\");\r\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\r\n            total.usdm -= _withdrawal.usdm;\r\n            user.usdm -= _withdrawal.usdm;\r\n        }\r\n\r\n        if(_withdrawal.pool3 > 0) {\r\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\r\n            total.pool3 -= _withdrawal.pool3;\r\n            user.pool3 -= _withdrawal.pool3;\r\n        }\r\n        totalLiquidity = total;\r\n        userLiquidity[msg.sender] = user;\r\n        emit Withdraw(msg.sender, _withdrawal);\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-02-concur#h-05-usdmpegrecovery-risk-of-fund-locked-due-to-discrepancy-between-curvelp-token-value-against-internal-contract-math",
                "Location":"deposit function , withdraw function",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.In USDMPegRecovery deposit and withdraw allow for direct deposits of a specific token (3crv or usdm). The balances are directly changed and tracked in storage. provide seems to be using the real balances (not the ones store) to provide liquidity. Because of how curve works, you’ll be able (first deposit) to provide exactly matching liquidity. But after (even just 1 or) multiple swaps, the pool will be slightly imbalanced, adding or removing liquidity at that point will drastically change the balances in the contract from the ones tracked in storage. Eventually users won’t be able to withdraw the exact amounts they deposited. This will culminate with real balances not matching user deposits, sometimes to user advantage and other times to user disadvantage, ultimately to the protocol dismay.",
                "Repair":"Either find a way to price the user contribution based on the LP tokens (use virtual_price) Or simply have people deposit the LP token directly (avoiding the IL math which is a massive headache)"
            }
        ]
    },
    {
        "Code":"\/\/ SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"solmate\/tokens\/ERC20.sol\";\r\nimport \"solmate\/tokens\/ERC721.sol\";\r\nimport \"solmate\/utils\/MerkleProofLib.sol\";\r\nimport \"solmate\/utils\/SafeTransferLib.sol\";\r\nimport \"openzeppelin\/utils\/math\/Math.sol\";\r\n\r\nimport \".\/LpToken.sol\";\r\nimport \".\/Caviar.sol\";\r\n\r\n\/\/\/ @title Pair\r\n\/\/\/ @author out.eth (@outdoteth)\r\n\/\/\/ @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.\r\ncontract Pair is ERC20, ERC721TokenReceiver {\r\n    using SafeTransferLib for address;\r\n    using SafeTransferLib for ERC20;\r\n\r\n    uint256 public constant ONE = 1e18;\r\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\r\n\r\n    address public immutable nft;\r\n    address public immutable baseToken; \/\/ address(0) for ETH\r\n    bytes32 public immutable merkleRoot;\r\n    LpToken public immutable lpToken;\r\n    Caviar public immutable caviar;\r\n    uint256 public closeTimestamp;\r\n\r\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\r\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\r\n    event Buy(uint256 inputAmount, uint256 outputAmount);\r\n    event Sell(uint256 inputAmount, uint256 outputAmount);\r\n    event Wrap(uint256[] tokenIds);\r\n    event Unwrap(uint256[] tokenIds);\r\n    event Close(uint256 closeTimestamp);\r\n    event Withdraw(uint256 tokenId);\r\n\r\n    constructor(\r\n        address _nft,\r\n        address _baseToken,\r\n        bytes32 _merkleRoot,\r\n        string memory pairSymbol,\r\n        string memory nftName,\r\n        string memory nftSymbol\r\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\r\n        nft = _nft;\r\n        baseToken = _baseToken; \/\/ use address(0) for native ETH\r\n        merkleRoot = _merkleRoot;\r\n        lpToken = new LpToken(pairSymbol);\r\n        caviar = Caviar(msg.sender);\r\n    }\r\n\r\n    \/\/ ************************ \/\/\r\n    \/\/      Core AMM logic      \/\/\r\n    \/\/ ***********************  \/\/\r\n\r\n    \/\/\/ @notice Adds liquidity to the pair.\r\n    \/\/\/ @param baseTokenAmount The amount of base tokens to add.\r\n    \/\/\/ @param fractionalTokenAmount The amount of fractional tokens to add.\r\n    \/\/\/ @param minLpTokenAmount The minimum amount of LP tokens to mint.\r\n    \/\/\/ @return lpTokenAmount The amount of LP tokens minted.\r\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\r\n        public\r\n        payable\r\n        returns (uint256 lpTokenAmount)\r\n    {\r\n        \/\/ *** Checks *** \/\/\r\n\r\n        \/\/ check the token amount inputs are not zero\r\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\r\n\r\n        \/\/ check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\r\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\r\n\r\n        \/\/ calculate the lp token shares to mint\r\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\r\n\r\n        \/\/ check that the amount of lp tokens outputted is greater than the min amount\r\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\r\n\r\n        \/\/ *** Effects *** \/\/\r\n\r\n        \/\/ transfer fractional tokens in\r\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\r\n\r\n        \/\/ *** Interactions *** \/\/\r\n\r\n        \/\/ mint lp tokens to sender\r\n        lpToken.mint(msg.sender, lpTokenAmount);\r\n\r\n        \/\/ transfer base tokens in if the base token is not ETH\r\n        if (baseToken != address(0)) {\r\n            \/\/ transfer base tokens in\r\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\r\n        }\r\n\r\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\r\n    }\r\n\r\n    \/\/\/ @notice Removes liquidity from the pair.\r\n    \/\/\/ @param lpTokenAmount The amount of LP tokens to burn.\r\n    \/\/\/ @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\r\n    \/\/\/ @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.\r\n    \/\/\/ @return baseTokenOutputAmount The amount of base tokens received.\r\n    \/\/\/ @return fractionalTokenOutputAmount The amount of fractional tokens received.\r\n    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)\r\n        public\r\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\r\n    {\r\n        \/\/ *** Checks *** \/\/\r\n\r\n        \/\/ calculate the output amounts\r\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);\r\n\r\n        \/\/ check that the base token output amount is greater than the min amount\r\n        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");\r\n\r\n        \/\/ check that the fractional token output amount is greater than the min amount\r\n        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");\r\n\r\n        \/\/ *** Effects *** \/\/\r\n\r\n        \/\/ transfer fractional tokens to sender\r\n        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);\r\n\r\n        \/\/ *** Interactions *** \/\/\r\n\r\n        \/\/ burn lp tokens from sender\r\n        lpToken.burn(msg.sender, lpTokenAmount);\r\n\r\n        if (baseToken == address(0)) {\r\n            \/\/ if base token is native ETH then send ether to sender\r\n            msg.sender.safeTransferETH(baseTokenOutputAmount);\r\n        } else {\r\n            \/\/ transfer base tokens to sender\r\n            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);\r\n        }\r\n\r\n        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);\r\n    }\r\n\r\n    \/\/\/ @notice Buys fractional tokens from the pair.\r\n    \/\/\/ @param outputAmount The amount of fractional tokens to buy.\r\n    \/\/\/ @param maxInputAmount The maximum amount of base tokens to spend.\r\n    \/\/\/ @return inputAmount The amount of base tokens spent.\r\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\r\n        \/\/ *** Checks *** \/\/\r\n\r\n        \/\/ check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\r\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\r\n\r\n        \/\/ calculate required input amount using xyk invariant\r\n        inputAmount = buyQuote(outputAmount);\r\n\r\n        \/\/ check that the required amount of base tokens is less than the max amount\r\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\r\n\r\n        \/\/ *** Effects *** \/\/\r\n\r\n        \/\/ transfer fractional tokens to sender\r\n        _transferFrom(address(this), msg.sender, outputAmount);\r\n\r\n        \/\/ *** Interactions *** \/\/\r\n\r\n        if (baseToken == address(0)) {\r\n            \/\/ refund surplus eth\r\n            uint256 refundAmount = maxInputAmount - inputAmount;\r\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\r\n        } else {\r\n            \/\/ transfer base tokens in\r\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\r\n        }\r\n\r\n        emit Buy(inputAmount, outputAmount);\r\n    }\r\n\r\n    \/\/\/ @notice Sells fractional tokens to the pair.\r\n    \/\/\/ @param inputAmount The amount of fractional tokens to sell.\r\n    \/\/\/ @param minOutputAmount The minimum amount of base tokens to receive.\r\n    \/\/\/ @return outputAmount The amount of base tokens received.\r\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\r\n        \/\/ *** Checks *** \/\/\r\n\r\n        \/\/ calculate output amount using xyk invariant\r\n        outputAmount = sellQuote(inputAmount);\r\n\r\n        \/\/ check that the outputted amount of fractional tokens is greater than the min amount\r\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\r\n\r\n        \/\/ *** Effects *** \/\/\r\n\r\n        \/\/ transfer fractional tokens from sender\r\n        _transferFrom(msg.sender, address(this), inputAmount);\r\n\r\n        \/\/ *** Interactions *** \/\/\r\n\r\n        if (baseToken == address(0)) {\r\n            \/\/ transfer ether out\r\n            msg.sender.safeTransferETH(outputAmount);\r\n        } else {\r\n            \/\/ transfer base tokens out\r\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\r\n        }\r\n\r\n        emit Sell(inputAmount, outputAmount);\r\n    }\r\n\r\n    \/\/ ******************** \/\/\r\n    \/\/      Wrap logic      \/\/\r\n    \/\/ ******************** \/\/\r\n\r\n    \/\/\/ @notice Wraps NFTs into fractional tokens.\r\n    \/\/\/ @param tokenIds The ids of the NFTs to wrap.\r\n    \/\/\/ @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.\r\n    \/\/\/ @return fractionalTokenAmount The amount of fractional tokens minted.\r\n    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\r\n        public\r\n        returns (uint256 fractionalTokenAmount)\r\n    {\r\n        \/\/ *** Checks *** \/\/\r\n\r\n        \/\/ check that wrapping is not closed\r\n        require(closeTimestamp == 0, \"Wrap: closed\");\r\n\r\n        \/\/ check the tokens exist in the merkle root\r\n        _validateTokenIds(tokenIds, proofs);\r\n\r\n        \/\/ *** Effects *** \/\/\r\n\r\n        \/\/ mint fractional tokens to sender\r\n        fractionalTokenAmount = tokenIds.length * ONE;\r\n        _mint(msg.sender, fractionalTokenAmount);\r\n\r\n        \/\/ *** Interactions *** \/\/\r\n\r\n        \/\/ transfer nfts from sender\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\r\n        }\r\n\r\n        emit Wrap(tokenIds);\r\n    }\r\n\r\n    \/\/\/ @notice Unwraps fractional tokens into NFTs.\r\n    \/\/\/ @param tokenIds The ids of the NFTs to unwrap.\r\n    \/\/\/ @return fractionalTokenAmount The amount of fractional tokens burned.\r\n    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\r\n        \/\/ *** Effects *** \/\/\r\n\r\n        \/\/ burn fractional tokens from sender\r\n        fractionalTokenAmount = tokenIds.length * ONE;\r\n        _burn(msg.sender, fractionalTokenAmount);\r\n\r\n        \/\/ *** Interactions *** \/\/\r\n\r\n        \/\/ transfer nfts to sender\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\r\n        }\r\n\r\n        emit Unwrap(tokenIds);\r\n    }\r\n\r\n    \/\/ *********************** \/\/\r\n    \/\/      NFT AMM logic      \/\/\r\n    \/\/ *********************** \/\/\r\n\r\n    \/\/\/ @notice nftAdd Adds liquidity to the pair using NFTs.\r\n    \/\/\/ @param baseTokenAmount The amount of base tokens to add.\r\n    \/\/\/ @param tokenIds The ids of the NFTs to add.\r\n    \/\/\/ @param minLpTokenAmount The minimum amount of lp tokens to receive.\r\n    \/\/\/ @param proofs The merkle proofs for the NFTs.\r\n    \/\/\/ @return lpTokenAmount The amount of lp tokens minted.\r\n    function nftAdd(\r\n        uint256 baseTokenAmount,\r\n        uint256[] calldata tokenIds,\r\n        uint256 minLpTokenAmount,\r\n        bytes32[][] calldata proofs\r\n    ) public payable returns (uint256 lpTokenAmount) {\r\n        \/\/ wrap the incoming NFTs into fractional tokens\r\n        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);\r\n\r\n        \/\/ add liquidity using the fractional tokens and base tokens\r\n        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);\r\n    }\r\n\r\n    \/\/\/ @notice Removes liquidity from the pair using NFTs.\r\n    \/\/\/ @param lpTokenAmount The amount of lp tokens to remove.\r\n    \/\/\/ @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\r\n    \/\/\/ @param tokenIds The ids of the NFTs to remove.\r\n    \/\/\/ @return baseTokenOutputAmount The amount of base tokens received.\r\n    \/\/\/ @return fractionalTokenOutputAmount The amount of fractional tokens received.\r\n    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)\r\n        public\r\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\r\n    {\r\n        \/\/ remove liquidity and send fractional tokens and base tokens to sender\r\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) =\r\n            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);\r\n\r\n        \/\/ unwrap the fractional tokens into NFTs and send to sender\r\n        unwrap(tokenIds);\r\n    }\r\n\r\n    \/\/\/ @notice Buys NFTs from the pair using base tokens.\r\n    \/\/\/ @param tokenIds The ids of the NFTs to buy.\r\n    \/\/\/ @param maxInputAmount The maximum amount of base tokens to spend.\r\n    \/\/\/ @return inputAmount The amount of base tokens spent.\r\n    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\r\n        \/\/ buy fractional tokens using base tokens\r\n        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);\r\n\r\n        \/\/ unwrap the fractional tokens into NFTs and send to sender\r\n        unwrap(tokenIds);\r\n    }\r\n\r\n    \/\/\/ @notice Sells NFTs to the pair for base tokens.\r\n    \/\/\/ @param tokenIds The ids of the NFTs to sell.\r\n    \/\/\/ @param minOutputAmount The minimum amount of base tokens to receive.\r\n    \/\/\/ @param proofs The merkle proofs for the NFTs.\r\n    \/\/\/ @return outputAmount The amount of base tokens received.\r\n    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)\r\n        public\r\n        returns (uint256 outputAmount)\r\n    {\r\n        \/\/ wrap the incoming NFTs into fractional tokens\r\n        uint256 inputAmount = wrap(tokenIds, proofs);\r\n\r\n        \/\/ sell fractional tokens for base tokens\r\n        outputAmount = sell(inputAmount, minOutputAmount);\r\n    }\r\n\r\n    \/\/ ****************************** \/\/\r\n    \/\/      Emergency exit logic      \/\/\r\n    \/\/ ****************************** \/\/\r\n\r\n    \/\/\/ @notice Closes the pair to new wraps.\r\n    \/\/\/ @dev Can only be called by the caviar owner. This is used as an emergency exit in case\r\n    \/\/\/      the caviar owner suspects that the pair has been compromised.\r\n    function close() public {\r\n        \/\/ check that the sender is the caviar owner\r\n        require(caviar.owner() == msg.sender, \"Close: not owner\");\r\n\r\n        \/\/ set the close timestamp with a grace period\r\n        closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;\r\n\r\n        \/\/ remove the pair from the Caviar contract\r\n        caviar.destroy(nft, baseToken, merkleRoot);\r\n\r\n        emit Close(closeTimestamp);\r\n    }\r\n\r\n    \/\/\/ @notice Withdraws a particular NFT from the pair.\r\n    \/\/\/ @dev Can only be called by the caviar owner after the close grace period has passed. This\r\n    \/\/\/      is used to auction off the NFTs in the pair in case NFTs get stuck due to liquidity\r\n    \/\/\/      imbalances. Proceeds from the auction should be distributed pro rata to fractional\r\n    \/\/\/      token holders. See documentation for more details.\r\n    function withdraw(uint256 tokenId) public {\r\n        \/\/ check that the sender is the caviar owner\r\n        require(caviar.owner() == msg.sender, \"Withdraw: not owner\");\r\n\r\n        \/\/ check that the close period has been set\r\n        require(closeTimestamp != 0, \"Withdraw not initiated\");\r\n\r\n        \/\/ check that the close grace period has passed\r\n        require(block.timestamp >= closeTimestamp, \"Not withdrawable yet\");\r\n\r\n        \/\/ transfer the nft to the caviar owner\r\n        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\r\n\r\n        emit Withdraw(tokenId);\r\n    }\r\n\r\n    \/\/ ***************** \/\/\r\n    \/\/      Getters      \/\/\r\n    \/\/ ***************** \/\/\r\n\r\n    function baseTokenReserves() public view returns (uint256) {\r\n        return _baseTokenReserves();\r\n    }\r\n\r\n    function fractionalTokenReserves() public view returns (uint256) {\r\n        return balanceOf[address(this)];\r\n    }\r\n\r\n    \/\/\/ @notice The current price of one fractional token in base tokens with 18 decimals of precision.\r\n    \/\/\/ @dev Calculated by dividing the base token reserves by the fractional token reserves.\r\n    \/\/\/ @return price The price of one fractional token in base tokens * 1e18.\r\n    function price() public view returns (uint256) {\r\n        return (_baseTokenReserves() * ONE) \/ fractionalTokenReserves();\r\n    }\r\n\r\n    \/\/\/ @notice The amount of base tokens required to buy a given amount of fractional tokens.\r\n    \/\/\/ @dev Calculated using the xyk invariant and a 30bps fee.\r\n    \/\/\/ @param outputAmount The amount of fractional tokens to buy.\r\n    \/\/\/ @return inputAmount The amount of base tokens required.\r\n    function buyQuote(uint256 outputAmount) public view returns (uint256) {\r\n        return (outputAmount * 1000 * baseTokenReserves()) \/ ((fractionalTokenReserves() - outputAmount) * 997);\r\n    }\r\n\r\n    \/\/\/ @notice The amount of base tokens received for selling a given amount of fractional tokens.\r\n    \/\/\/ @dev Calculated using the xyk invariant and a 30bps fee.\r\n    \/\/\/ @param inputAmount The amount of fractional tokens to sell.\r\n    \/\/\/ @return outputAmount The amount of base tokens received.\r\n    function sellQuote(uint256 inputAmount) public view returns (uint256) {\r\n        uint256 inputAmountWithFee = inputAmount * 997;\r\n        return (inputAmountWithFee * baseTokenReserves()) \/ ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\r\n    }\r\n\r\n    \/\/\/ @notice The amount of lp tokens received for adding a given amount of base tokens and fractional tokens.\r\n    \/\/\/ @dev Calculated as a share of existing deposits. If there are no existing deposits, then initializes to\r\n    \/\/\/      sqrt(baseTokenAmount * fractionalTokenAmount).\r\n    \/\/\/ @param baseTokenAmount The amount of base tokens to add.\r\n    \/\/\/ @param fractionalTokenAmount The amount of fractional tokens to add.\r\n    \/\/\/ @return lpTokenAmount The amount of lp tokens received.\r\n    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\r\n        uint256 lpTokenSupply = lpToken.totalSupply();\r\n        if (lpTokenSupply > 0) {\r\n            \/\/ calculate amount of lp tokens as a fraction of existing reserves\r\n            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) \/ baseTokenReserves();\r\n            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) \/ fractionalTokenReserves();\r\n            return Math.min(baseTokenShare, fractionalTokenShare);\r\n        } else {\r\n            \/\/ if there is no liquidity then init\r\n            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice The amount of base tokens and fractional tokens received for burning a given amount of lp tokens.\r\n    \/\/\/ @dev Calculated as a share of existing deposits.\r\n    \/\/\/ @param lpTokenAmount The amount of lp tokens to burn.\r\n    \/\/\/ @return baseTokenAmount The amount of base tokens received.\r\n    \/\/\/ @return fractionalTokenAmount The amount of fractional tokens received.\r\n    function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\r\n        uint256 lpTokenSupply = lpToken.totalSupply();\r\n        uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) \/ lpTokenSupply;\r\n        uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) \/ lpTokenSupply;\r\n\r\n        return (baseTokenOutputAmount, fractionalTokenOutputAmount);\r\n    }\r\n\r\n    \/\/ ************************ \/\/\r\n    \/\/      Internal utils      \/\/\r\n    \/\/ ************************ \/\/\r\n\r\n    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {\r\n        balanceOf[from] -= amount;\r\n\r\n        \/\/ Cannot overflow because the sum of all user\r\n        \/\/ balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev Validates that the given tokenIds are valid for the contract's merkle root. Reverts\r\n    \/\/\/      if any of the tokenId proofs are invalid.\r\n    function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {\r\n        \/\/ if merkle root is not set then all tokens are valid\r\n        if (merkleRoot == bytes23(0)) return;\r\n\r\n        \/\/ validate merkle proofs against merkle root\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));\r\n            require(isValid, \"Invalid merkle proof\");\r\n        }\r\n    }\r\n\r\n    \/\/\/ @dev Returns the current base token reserves. If the base token is ETH then it ignores\r\n    \/\/\/      the msg.value that is being sent in the current call context - this is to ensure the\r\n    \/\/\/      xyk math is correct in the buy() and add() functions.\r\n    function _baseTokenReserves() internal view returns (uint256) {\r\n        return baseToken == address(0)\r\n            ? address(this).balance - msg.value \/\/ subtract the msg.value if the base token is ETH\r\n            : ERC20(baseToken).balanceOf(address(this));\r\n    }\r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-12-caviar#h-02-liquidity-providers-may-lose-funds-when-adding-liquidity",
                "Location":"\/\/ calculate amount of lp tokens as a fraction of existing reserves\r\nuint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) \/ baseTokenReserves();\r\nuint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) \/ fractionalTokenReserves();\r\nreturn Math.min(baseTokenShare, fractionalTokenShare);",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.Liquidity providers may lose a portion of provided liquidity in either of the pair tokens. While the minLpTokenAmount protects from slippage when adding liquidity, it doesn’t protect from providing liquidity at different K.",
                "Repair":"In the add function, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router"
            }
        ]
    },
    {
        "Code":"function buy(uint256 _id) external payable isValidPair(_id){\r\n    requlre(pairs[_id].owner 1-msg.sender,\"ouner can not buy\"); \r\n    Pair memory pair -pairs[_id];\r\n    uint256 totalAmount-pair.price; i\r\n    if(pair.currency --address(exe)){\r\n\t\trequire(msg.value>-totalAmount,\"insufficient eth amount\"): \r\n\t\t\/\/ refund extra eth\r\n\t\tpayable(msg.sender).transfer(msg.value.sub(totalAmount)); \r\n\t\t\/\/ transfer service fee\r\n\t\tpayable(feewallet).transfer(totalAmount,mul(serviceFee).div(PERCENT_DIVIDER));\r\n\t\t\/\/ transfer creator fee\r\n\t\tpayable(palr.creator).transfer(totalAmount,mul(pair,creatorFee).dlv(PERCENT_DIVIDER)); \r\n\t\t\/\/ transfer remain amount to owner\r\n\t\tuint256 ownerPercent-PERCENT_DIVIDER.sub(serviceFee).sub(pair,creatorFee); \r\n\t\tpayable(pair.owner).transfer(totalAnount.mul(ownerPercent).div(PERCENT_DIVIDER));\r\n\t}else {\r\n        IERC20 currency - IERC20(pair,currency):\r\n        uint256 tokenBalane= currency.balanceof(msg.sender);\r\n        require(tokenBalane>-totalAmount, \"insufficient token balance\"); \r\n        \/\/ transfer service fee\r\n        require(currency.transferFrom(msg,sender,feewallet,totalAmount.nul(serviceFee).div(PERCENT_DIVIDER)),\"failed to transfer Admin fee\"); \r\n        \/\/ transfer creator fee\r\n        require(currency.transferFrom(msg,sender,pair,creator,totalAmount.nul(pair,creatorFee).div(PERCENT_DIVIDER)),\"failed to transfer creator fee\");\r\n        \/\/ transfer remain amount to owner\r\n        uint256 ownerPercent-PERCENT_DIVIDER.sub(serviceFee).sub(pair,creatorFee);\r\n        require(currency.transferFrom(msg.sender,pair.owner,totalAmount,mul(ownerPercent).div(PERCENT_DIVIDER)),\"failed to transfer to owner\"); \r\n    }\r\n    \/\/ transfer NFT token to buyer\r\n    IERC721(pairs[_id].collection),safeTransferFrom(address(this),msg.sender,pair.tokenId);\r\n    pairs[_id].bvalid- false;\r\n    emit Suapped(msg.sender,pair); \r\n}",
        "VulnerabilityDesc":[
            {
                "Name":"Beosin/BOG_202204071430.pdf/[BOG-2]Transaction-Ordering Attacks",
                "Location":"buy function",
                "Type":"Price oracle manipulation",
                "Description":"Sandwich attack.The buy function in the BattleOfGuardiansMarket contract has a transaction-ordering dependency attack. During the transaction process, if the buyer decides to buy the NFT and initiates a transaction, the seller can preempt the transaction and change the currency address or price before the buyer's transaction is confirmed. This can lead to unexpected transactions.",
                "Repair":"It is recommended to specify currency and price by user input in the buy function. "
            }
        ]
    },
    {
        "Code":"function VSpecia12(uint256 amount) public returns (uint256 result){\r\n\tPRBMath.UD60x18 memory_a-PRBMathUD60x18.fromUint(a());\r\n    _a=PRBMathUD060x18.mul(_a,PRBMathUD60x18.fromUint(scaleFactor)); \r\n    PRBMath.UD60x18 memory _amount=PRBMathUD60x18.fromUint(amount); \r\n    PRBMath.UD60x18 memory _S1= PRBMathUD60x18.fromUint(starSupply);\r\n    PRBMath.UD60x18 memory_S0 =PRBMathUD60x18.sub(_amount,PRBMathUD60x18.fromUint(supplySold)); \r\n    _S0=PRBMathUD60x18.sub(_S1,_S0);\r\n    curve350 = PRBMathUD60x18.toUint(_S0);\r\n    _S0 = PRBMathUD60x18.mul(_SO,PRBMathUD60x18.fromUint(scaleFactor)); \r\n    _S1=PRBMathUD60x18.mul(_S1, PRBMathUD60x18.fromUint(scaleFactor)); \r\n    PRBMath.UD60x18 memory InNumerator =PRBMathU060x18.e();\r\n    PRBMath.UD60x18 memory powerNum-PRBMathUD60x18.mul(PRBMathUD60x18.fromUint(33),_S1); \r\n    powerNum = PRBMathUD60x18.div(powerNum,PRBMathUD60x18.fromUint(10));\r\n    powerNum=PRBMathUD60x18.div(powerNum,_a); \r\n    if (PRBMathUD60x18．toUint（powerNum）>14）｛}else{}\r\n}\r\n",
        "VulnerabilityDesc":[
            {
                "Name":"/Beosin/promfans_202109061825.pdf/The system variable curve3S0 can be modified by anyone",
                "Location":"curve350 = PRBMathUD60x18.toUint(_S0);",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.The visibility of the SSpecial and VSpecial2 functions in the contract is \"public\", which means \r\nthat they can be called by any user. But the function will internally modify curve3S0 according to the \r\nincoming value, which may cause the price of the contract's token transaction to be manipulated",
                "Repair":""
            }
        ]
    },
    {
        "Code":"function harvest() public override whenNotPaused {\\r\\n    if (balanceOfPool() > 0) {\\r\\n    \\/\\/ claim diff\\r\\n    miniChef.harvest(pid, address(this));\\r\\n \\r\\n    uint256 diffBal = diff.balanceOf(address(this));\\r\\n    if (diffBal > 0) {\\r\\n    \\/\\/ charge fees\\r\\n    uint256 harvestFee = diffBal.mul(harvestFeeRate).div(\\r\\n    FEE_PRECISION\\r\\n    );\\r\\n   diff.safeTransfer(feeRecipient, harvestFee);\\r\\n\\r\\n   \\/\\/ swap diff\\r\\n    uint256 diffBalHalf = diffBal.sub(harvestFee).div(2);\\r\\n    if (lpToken0 != diff) {\\r\\n    uniRouter.swapExactTokensForTokens(\\r\\n    diffBalHalf,\\r\\n    0,\\r\\n    diffToLpToken0,\\r\\n    address(this),\\r\\n    now\\r\\n    );\\r\\n \\r\\n    }\\r\\n    if (lpToken1 != diff) {\\r\\n    uniRouter.swapExactTokensForTokens(\\r\\n    diffBalHalf,\\r\\n    0,\\r\\n    diffToLpToken1,\\r\\n    address(this),\\r\\n    now\\r\\n    );\\r\\n    }\\r\\n \\r\\n    \\/\\/ Adds liquidity and gets more want tokens.\\r\\n    uniRouter.addLiquidity(\\r\\n    address(lpToken0),\\r\\n    address(lpToken1),\\r\\n    lpToken0.balanceOf(address(this)),\\r\\n    lpToken1.balanceOf(address(this)),\\r\\n    1,\\r\\n    1,\\r\\n    address(this),\\r\\n    now\\r\\n    );\\r\\n\\r\\n   \\/\\/ reinvest\\r\\n   deposit();\\r\\n\\r\\n   emit Harvested(diffBal, harvestFee);\\r\\n   }\\r\\n  }\\r\\n}",
        "VulnerabilityDesc":[
            {
                "Name":"/blocksec/1660885789323-2.pdf/Possible price manipulation attack",
                "Location":"if (lpToken0 != diff) ; if (lpToken1 != diff)",
                "Type":"AMM price oracle manipulation.Price oracle manipulation",
                "Description":"The function harvest of StratDiffusion swaps the DIFF token for the underlying tokens\n(line 155 and 164). It’s susceptible to the price manipulation attack.Specifically, the DIFF token will be transferred into the strategy contract, and then swapped to the\nunderlying tokens in the DEX pools. However, the price of the DIFF could be manipulated in the DEX pool\nso that it’s price is very low and the underlying token exchanged will be less than expected. Besides, there\nis no slippage protection when swapping the DIFF for the underlying token.",
                "Repair":"Ensure that only the EOA account can invoke the deposit function in the vault contract and\nthe harvest function in the strategy. A slippage protection could be leveraged in the function. Besides, the\nproject can monitor the accumulated DIFF token in the Chef contract and invoke the harvest function when\nthe accumulated DIFF token exceeds a threshold."
            }
        ]
    },
    {
        "Code":"function tradeCollaterals() public {\\r\\n    \\/\\/ for all lp tokens in the collateral array\\r\\n    uint256 len = allCollaterals.length;\\r\\n    for (uint256 i = 0; i < len; ++i) {\\r\\n        tradeCollateral(allCollaterals[i]);\\r\\n    }\\r\\n}\\r\\n   \\r\\nfunction getPathToStnd(address input) private view returns (address[] memory) {\\r\\n    address[] memory path = new address[](3);\\r\\n    path[0] = input;\\r\\n    path[1] = stablecoin;\\r\\n    path[2] = stnd;\\r\\n   \\r\\n    return path;\\r\\n}\\r\\n   \\r\\nfunction tradeCollateral (\\r\\n    address collateral\\r\\n    ) internal {\\r\\n    IUniswapV2Router01(router).swapExactTokensForTokens(\\r\\n    IERC20(collateral).balanceOf(address(this)),\\r\\n    0,\\r\\n    getPathToStnd(collateral),\\r\\n    dstnd,\\r\\n    block.timestamp + 20000000\\r\\n    );\\r\\n}",
        "VulnerabilityDesc":[
            {
                "Name":"/blocksec/1660886228484-2.pdf/Price manipulation attacks against FeeRoll contract",
                "Location":"tradeCollaterals function",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.The function tradeCollaterals in the following code snippets is used to trade fees distributed from vaults for\\r\\nSTND tokens, which can support the value of STND in DeFi market.\\r\\nThere are two price manipulation methods that can cause the FeeRoll contract to lose collaterals.\\r\\nFor example, the collateral token to be sold is WETH. The function tradeCollateralls will sell WETH for\\r\\nMTR and then for STND. The attack consists of three steps. The first step, an attacker borrows a huge amount\\r\\nof WETH via flashloan to swap for the MTR, then the WETH’s price in the pool is manipulated to be very low.\\r\\nSecond, the attacker invokes tradeCollaterals of the FeeRoll contract that cheaply sells WETH reserves\\r\\nfor little MTR and then for little STND. Third, the attacker swaps his MTR for WETH back, which can profit from\\r\\nthe trade that FeeRoll contract makes",
                "Repair":"Add a check require(msg.sender == tx.origin) in the function tradeCollateralls to ensure the caller\\r\\nis EOA.\\r\\nAdd a check to make sure the existence of the swap pool between input and stablecoin in the function\\r\\ngetPathToStnd\\r\\nLeverage the price oracle to implement a slippage check for swapExactTokensForTokens rather than filling\\r\\n0 (in line 843)"
            }
        ]
    },
    {
        "Code":"@internal\\r\\ndef _checkpoint(addr: address):\\r\\n    \\\"\\\"\\\"\\r\\n    @notice Checkpoint for a user\\r\\n    @param addr User address\\r\\n    \\\"\\\"\\\"\\r\\n    _point_period: int128 = self.point_period\\r\\n    _point_period_timestamp: uint256 = self.point_period_timestamp[_point_period]\\r\\n    _point_integrate_inv_supply: uint256 = self.point_integrate_inv_supply[_point_period]\\r\\n   \\r\\n    rate: uint256 = self.point_rate\\r\\n    prev_epoch: uint256 = self.point_current_epoch_time\\r\\n    new_rate: uint256 = rate\\r\\n    next_epoch: uint256 = prev_epoch + WEEK\\r\\n\\r\\n    if block.timestamp > next_epoch:\\r\\n        new_totalSupply: uint256 = ERC20(self.lp_token).totalSupply()\\r\\n        if new_totalSupply > 0:\\r\\n            new_rate = self.point_proportion * new_totalSupply \\/ WEEK\\r\\n        self.point_current_epoch_time = next_epoch\\r\\n        self.point_rate = new_rate\\r\\n   \\r\\n    # Update integral of 1\\/supply\\r\\n    if block.timestamp > _point_period_timestamp and not self.is_killed:\\r\\n        prev_week_time: uint256 = _point_period_timestamp\\r\\n        week_time: uint256 = min((_point_period_timestamp + WEEK) \\/ WEEK * WEEK, block.timestamp)\\r\\n        _totalSupply: uint256 = self.lpTotalSupply\\r\\n   \\r\\n        for i in range(500):\\r\\n            dt: uint256 = week_time - prev_week_time\\r\\n            if _totalSupply > 0:\\r\\n                if next_epoch >= prev_week_time and next_epoch < week_time:\\r\\n                    # If we went across epoch, apply the rate\\r\\n                    # of the first epoch until it ends, and then the rate of\\r\\n                    # the last epoch.\\r\\n                    _point_integrate_inv_supply += rate * (next_epoch - prev_week_time) \\/ _totalSupply\\r\\n                    rate = new_rate\\r\\n                    _point_integrate_inv_supply += rate * (week_time - next_epoch) \\/ _totalSupply\\r\\n\\r\\n\\r\\n@external\\r\\ndef user_checkpoint(addr: address) -> bool:\\r\\n    \\\"\\\"\\\"\\r\\n    @notice Record a checkpoint for ‘addr‘\\r\\n    @param addr User address\\r\\n    @return bool success\\r\\n    \\\"\\\"\\\"\\r\\n    assert (msg.sender == addr) or (msg.sender == self.minter) # dev: unauthorized\\r\\n    self._checkpoint(addr)\\r\\n    self._checkpoint_dao(addr)\\r\\n    self._checkpoint_rewards(addr, False, ZERO_ADDRESS)\\r\\n    self._update_liquidity_limit(addr, self._balance_of(addr), self.totalSupply)\\r\\n    return True",
        "VulnerabilityDesc":[
            {
                "Name":"/blocksec_filda_dao_v1.0_signed.pdf/Potential price manipulation on the reward allocation speed",
                "Location":"_checkpoint function",
                "Type":"Price oracle manipulation",
                "Description":"AMM price oracle manipulation.There exists a price manipulation problem in the _checkpoint function of the LiquidityGaugeV3 contract. The project provides incentives to the holders of fTokens (a series of Compound-CToken-like to\u0002kens) by adopting a mechanism similar to the Curve DAO project. Every time the function is invoked, a\\r\\ncheckpoint is recorded for allocating the rewards. Specifically, every balance change of fTokens would trigger a hook calling to the corresponding\\r\\nLiquidityGaugeV3 contract and accumulate the reward in FILDA tokens. This hook updates the reward\\r\\nallocation points (points for short) based on the following two-step calculation:\\r\\n1. The reward allocation speed for a certain time t is calculated as r(t) = p ∗ s(t)\\/W EEK, where p is a system parameter, s(t) is the total supply of fToken recorded in the first checkpoint of a week, W EEK is the total seconds in a week (604800).\\r\\n2. The points of a certain user is calculated as Iu =R r(t)bu(t)s(t), where bu(t) is the balance of the user at time t, and s(t) is the current total supply of fToken.\\r\\n",
                "Repair":"Check the rate updating mechanism"
            }
        ]
    },
    {
        "Code":"",
        "VulnerabilityDesc":[
            {
                "Name":"",
                "Location":"",
                "Type":"Price oracle manipulation",
                "Description":"",
                "Repair":""
            }
        ]
    }
]