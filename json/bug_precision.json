[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_1",
                "Location": "NFTLoanFacilitator.sol#L167-L179",
                "Type": "Precision loss",
                "Description": "When previousInterestRate is less than 10 and requiredImprovementRate is 100, due to precision loss, the new interestRate is allowed to be the same as the previous one.",
                "Repair": "Use OpenZeppelin/Math.sol#L39-L42 to avoid precision loss and change the check to previousInterestRate != 0 && previousInterestRate < Math.ceilDiv(previousInterestRate * requiredImprovementRate, SCALAR)."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../../lib/utils/Ownable.sol\";\nimport { EIP712 } from \"../../lib/utils/EIP712.sol\";\nimport { SafeCast } from \"../../lib/utils/SafeCast.sol\";\n\nimport { GovernorStorageV1 } from \"./storage/GovernorStorageV1.sol\";\nimport { Token } from \"../../token/Token.sol\";\nimport { Treasury } from \"../treasury/Treasury.sol\";\nimport { IManager } from \"../../manager/IManager.sol\";\nimport { IGovernor } from \"./IGovernor.sol\";\n\n/// @title Governor\n/// @author Rohan Kulkarni\n/// @notice A DAO's proposal manager and transaction scheduler\n/// Modified from:\n/// - OpenZeppelin Contracts v4.7.3 (governance/extensions/GovernorTimelockControl.sol)\n/// - NounsDAOLogicV1.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\ncontract Governor is IGovernor, UUPS, Ownable, EIP712, GovernorStorageV1 {\n    ///                                                          ///\n    ///                         CONSTANTS                        ///\n    ///                                                          ///\n\n    /// @notice The EIP-712 typehash to vote with a signature\n    bytes32 public constant VOTE_TYPEHASH = keccak256(\"Vote(address voter,uint256 proposalId,uint256 support,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's governor\n    /// @param _treasury The DAO's treasury address\n    /// @param _token The DAO's governance token address\n    /// @param _vetoer The address eligible to veto proposals\n    /// @param _votingDelay The voting delay\n    /// @param _votingPeriod The voting period\n    /// @param _proposalThresholdBps The proposal threshold basis points\n    /// @param _quorumThresholdBps The quorum threshold basis points\n    function initialize(\n        address _treasury,\n        address _token,\n        address _vetoer,\n        uint256 _votingDelay,\n        uint256 _votingPeriod,\n        uint256 _proposalThresholdBps,\n        uint256 _quorumThresholdBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure non-zero addresses are provided\n        if (_treasury == address(0)) revert ADDRESS_ZERO();\n        if (_token == address(0)) revert ADDRESS_ZERO();\n\n        // Store the governor settings\n        settings.treasury = Treasury(payable(_treasury));\n        settings.token = Token(_token);\n        settings.vetoer = _vetoer;\n        settings.votingDelay = SafeCast.toUint48(_votingDelay);\n        settings.votingPeriod = SafeCast.toUint48(_votingPeriod);\n        settings.proposalThresholdBps = SafeCast.toUint16(_proposalThresholdBps);\n        settings.quorumThresholdBps = SafeCast.toUint16(_quorumThresholdBps);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(settings.token.symbol(), \" GOV\"), \"1\");\n\n        // Grant ownership to the treasury\n        __Ownable_init(_treasury);\n    }\n\n    ///                                                          ///\n    ///                         HASH PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Hashes a proposal's details into a proposal id\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function hashProposal(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        bytes32 _descriptionHash\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_targets, _values, _calldatas, _descriptionHash));\n    }\n\n    ///                                                          ///\n    ///                        CREATE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Creates a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _description The proposal description\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (bytes32) {\n        // Get the current proposal threshold\n        uint256 currentProposalThreshold = proposalThreshold();\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller's voting weight is greater than or equal to the threshold\n            if (getVotes(msg.sender, block.timestamp - 1) < proposalThreshold()) revert BELOW_PROPOSAL_THRESHOLD();\n        }\n\n        // Cache the number of targets\n        uint256 numTargets = _targets.length;\n\n        // Ensure at least one target exists\n        if (numTargets == 0) revert PROPOSAL_TARGET_MISSING();\n\n        // Ensure the number of targets matches the number of values and calldata\n        if (numTargets != _values.length) revert PROPOSAL_LENGTH_MISMATCH();\n        if (numTargets != _calldatas.length) revert PROPOSAL_LENGTH_MISMATCH();\n\n        // Compute the description hash\n        bytes32 descriptionHash = keccak256(bytes(_description));\n\n        // Compute the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);\n\n        // Get the pointer to store the proposal\n        Proposal storage proposal = proposals[proposalId];\n\n        // Ensure the proposal doesn't already exist\n        if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId);\n\n        // Used to store the snapshot and deadline\n        uint256 snapshot;\n        uint256 deadline;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the snapshot and deadline\n            snapshot = block.timestamp + settings.votingDelay;\n            deadline = snapshot + settings.votingPeriod;\n        }\n\n        // Store the proposal data\n        proposal.voteStart = uint32(snapshot);\n        proposal.voteEnd = uint32(deadline);\n        proposal.proposalThreshold = uint32(currentProposalThreshold);\n        proposal.quorumVotes = uint32(quorum());\n        proposal.proposer = msg.sender;\n        proposal.timeCreated = uint32(block.timestamp);\n\n        emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                          CAST VOTE                       ///\n    ///                                                          ///\n\n    /// @notice Casts a vote\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    function castVote(bytes32 _proposalId, uint256 _support) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, \"\");\n    }\n\n    /// @notice Casts a vote with a reason\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _reason The vote reason\n    function castVoteWithReason(\n        bytes32 _proposalId,\n        uint256 _support,\n        string memory _reason\n    ) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, _reason);\n    }\n\n    /// @notice Casts a signed vote\n    /// @param _voter The voter address\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function castVoteBySig(\n        address _voter,\n        bytes32 _proposalId,\n        uint256 _support,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256) {\n        // Ensure the deadline has not passed\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the signed digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the message\n            digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(VOTE_TYPEHASH, _voter, _proposalId, _support, nonces[_voter]++, _deadline))\n                )\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the given voter\n        if (recoveredAddress == address(0) || recoveredAddress != _voter) revert INVALID_SIGNATURE();\n\n        return _castVote(_proposalId, _voter, _support, \"\");\n    }\n\n    /// @dev Stores a vote\n    /// @param _proposalId The proposal id\n    /// @param _voter The voter address\n    /// @param _support The vote choice\n    function _castVote(\n        bytes32 _proposalId,\n        address _voter,\n        uint256 _support,\n        string memory _reason\n    ) internal returns (uint256) {\n        // Ensure voting is active\n        if (state(_proposalId) != ProposalState.Active) revert VOTING_NOT_STARTED();\n\n        // Ensure the voter hasn't already voted\n        if (hasVoted[_proposalId][_voter]) revert ALREADY_VOTED();\n\n        // Ensure the vote is valid\n        if (_support > 2) revert INVALID_VOTE();\n\n        // Record the voter as having voted\n        hasVoted[_proposalId][_voter] = true;\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Used to store the voter's weight\n        uint256 weight;\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Get the voter's weight at the time the proposal was created\n            weight = getVotes(_voter, proposal.timeCreated);\n\n            // If the vote is against:\n            if (_support == 0) {\n                // Update the total number of votes against\n                proposal.againstVotes += uint32(weight);\n\n                // Else if the vote is for:\n            } else if (_support == 1) {\n                // Update the total number of votes for\n                proposal.forVotes += uint32(weight);\n\n                // Else if the vote is to abstain:\n            } else if (_support == 2) {\n                // Update the total number of votes abstaining\n                proposal.abstainVotes += uint32(weight);\n            }\n        }\n\n        emit VoteCast(_voter, _proposalId, _support, weight, _reason);\n\n        return weight;\n    }\n\n    ///                                                          ///\n    ///                        QUEUE PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Queues a proposal\n    /// @param _proposalId The proposal id\n    function queue(bytes32 _proposalId) external returns (uint256 eta) {\n        // Ensure the proposal has succeeded\n        if (state(_proposalId) != ProposalState.Succeeded) revert PROPOSAL_UNSUCCESSFUL();\n\n        // Schedule the proposal for execution\n        eta = settings.treasury.queue(_proposalId);\n\n        emit ProposalQueued(_proposalId, eta);\n    }\n\n    ///                                                          ///\n    ///                       EXECUTE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Executes a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function execute(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        bytes[] calldata _calldatas,\n        bytes32 _descriptionHash\n    ) external payable returns (bytes32) {\n        // Get the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, _descriptionHash);\n\n        // Ensure the proposal is queued\n        if (state(proposalId) != ProposalState.Queued) revert PROPOSAL_NOT_QUEUED(proposalId);\n\n        // Mark the proposal as executed\n        proposals[proposalId].executed = true;\n\n        // Execute the proposal\n        settings.treasury.execute{ value: msg.value }(_targets, _values, _calldatas, _descriptionHash);\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                        CANCEL PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Cancels a proposal\n    /// @param _proposalId The proposal id\n    function cancel(bytes32 _proposalId) external {\n        // Ensure the proposal hasn't been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold\n            if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)\n                revert INVALID_CANCEL();\n        }\n\n        // Update the proposal as canceled\n        proposals[_proposalId].canceled = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        VETO PROPOSAL                     ///\n    ///                                                          ///\n\n    /// @notice Vetoes a proposal\n    /// @param _proposalId The proposal id\n    function veto(bytes32 _proposalId) external {\n        // Ensure the caller is the vetoer\n        if (msg.sender != settings.vetoer) revert ONLY_VETOER();\n\n        // Ensure the proposal has not been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Update the proposal as vetoed\n        proposal.vetoed = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        PROPOSAL STATE                    ///\n    ///                                                          ///\n\n    /// @notice The state of a proposal\n    /// @param _proposalId The proposal id\n    function state(bytes32 _proposalId) public view returns (ProposalState) {\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Ensure the proposal exists\n        if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();\n\n        // If the proposal was executed:\n        if (proposal.executed) {\n            return ProposalState.Executed;\n\n            // Else if the proposal was canceled:\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n\n            // Else if the proposal was vetoed:\n        } else if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n\n            // Else if voting has not started:\n        } else if (block.timestamp < proposal.voteStart) {\n            return ProposalState.Pending;\n\n            // Else if voting has not ended:\n        } else if (block.timestamp < proposal.voteEnd) {\n            return ProposalState.Active;\n\n            // Else if the proposal failed (outvoted OR didn't reach quorum):\n        } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n\n            // Else if the proposal has not been queued:\n        } else if (settings.treasury.timestamp(_proposalId) == 0) {\n            return ProposalState.Succeeded;\n\n            // Else if the proposal can no longer be executed:\n        } else if (settings.treasury.isExpired(_proposalId)) {\n            return ProposalState.Expired;\n\n            // Else the proposal is queued\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice The voting weight of an account at a timestamp\n    /// @param _account The account address\n    /// @param _timestamp The specific timestamp\n    function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        return settings.token.getPastVotes(_account, _timestamp);\n    }\n\n    /// @notice The current number of votes required to submit a proposal\n    function proposalThreshold() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.proposalThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The current number of votes required to be in favor of a proposal in order to reach quorum\n    function quorum() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.quorumThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The data stored for a given proposal\n    /// @param _proposalId The proposal id\n    function getProposal(bytes32 _proposalId) external view returns (Proposal memory) {\n        return proposals[_proposalId];\n    }\n\n    /// @notice The timestamp when voting starts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalSnapshot(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteStart;\n    }\n\n    /// @notice The timestamp when voting ends for a proposal\n    /// @param _proposalId The proposal id\n    function proposalDeadline(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteEnd;\n    }\n\n    /// @notice The vote counts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalVotes(bytes32 _proposalId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Proposal memory proposal = proposals[_proposalId];\n\n        return (proposal.againstVotes, proposal.forVotes, proposal.abstainVotes);\n    }\n\n    /// @notice The timestamp valid to execute a proposal\n    /// @param _proposalId The proposal id\n    function proposalEta(bytes32 _proposalId) external view returns (uint256) {\n        return settings.treasury.timestamp(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                      GOVERNOR SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The basis points of the token supply required to create a proposal\n    function proposalThresholdBps() external view returns (uint256) {\n        return settings.proposalThresholdBps;\n    }\n\n    /// @notice The basis points of the token supply required to reach quorum\n    function quorumThresholdBps() external view returns (uint256) {\n        return settings.quorumThresholdBps;\n    }\n\n    /// @notice The amount of time until voting begins after a proposal is created\n    function votingDelay() external view returns (uint256) {\n        return settings.votingDelay;\n    }\n\n    /// @notice The amount of time to vote on a proposal\n    function votingPeriod() external view returns (uint256) {\n        return settings.votingPeriod;\n    }\n\n    /// @notice The address eligible to veto any proposal (address(0) if burned)\n    function vetoer() external view returns (address) {\n        return settings.vetoer;\n    }\n\n    /// @notice The address of the governance token\n    function token() external view returns (address) {\n        return address(settings.token);\n    }\n\n    /// @notice The address of the treasury\n    function treasury() external view returns (address) {\n        return address(settings.treasury);\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the voting delay\n    /// @param _newVotingDelay The new voting delay\n    function updateVotingDelay(uint256 _newVotingDelay) external onlyOwner {\n        emit VotingDelayUpdated(settings.votingDelay, _newVotingDelay);\n\n        settings.votingDelay = SafeCast.toUint48(_newVotingDelay);\n    }\n\n    /// @notice Updates the voting period\n    /// @param _newVotingPeriod The new voting period\n    function updateVotingPeriod(uint256 _newVotingPeriod) external onlyOwner {\n        emit VotingPeriodUpdated(settings.votingPeriod, _newVotingPeriod);\n\n        settings.votingPeriod = SafeCast.toUint48(_newVotingPeriod);\n    }\n\n    /// @notice Updates the minimum proposal threshold\n    /// @param _newProposalThresholdBps The new proposal threshold basis points\n    function updateProposalThresholdBps(uint256 _newProposalThresholdBps) external onlyOwner {\n        emit ProposalThresholdBpsUpdated(settings.proposalThresholdBps, _newProposalThresholdBps);\n\n        settings.proposalThresholdBps = SafeCast.toUint16(_newProposalThresholdBps);\n    }\n\n    /// @notice Updates the minimum quorum threshold\n    /// @param _newQuorumVotesBps The new quorum votes basis points\n    function updateQuorumThresholdBps(uint256 _newQuorumVotesBps) external onlyOwner {\n        emit QuorumVotesBpsUpdated(settings.quorumThresholdBps, _newQuorumVotesBps);\n\n        settings.quorumThresholdBps = SafeCast.toUint16(_newQuorumVotesBps);\n    }\n\n    /// @notice Updates the vetoer\n    /// @param _newVetoer The new vetoer address\n    function updateVetoer(address _newVetoer) external onlyOwner {\n        if (_newVetoer == address(0)) revert ADDRESS_ZERO();\n\n        emit VetoerUpdated(settings.vetoer, _newVetoer);\n\n        settings.vetoer = _newVetoer;\n    }\n\n    /// @notice Burns the vetoer\n    function burnVetoer() external onlyOwner {\n        emit VetoerUpdated(settings.vetoer, address(0));\n\n        delete settings.vetoer;\n    }\n\n    ///                                                          ///\n    ///                       GOVERNOR UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_2",
                "Location": "Governor contract",
                "Type": "Precision issue",
                "Description": "Precision is not enough for proposalThreshold and quorum. Collections with at least 20000 NFTs in total supply may have some trouble.",
                "Repair": "Increase division to a more precise value such as 1e18 to allow high total supply NFT to always set threshold as 1"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ImmutableState } from \"./ImmutableState.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport { IPair } from \"./interfaces/IPair.sol\";\nimport { IPairMintCallback } from \"./interfaces/callback/IPairMintCallback.sol\";\nimport { ISwapCallback } from \"./interfaces/callback/ISwapCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\nabstract contract Pair is ImmutableState, ReentrancyGuard, IPair {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(uint256 amount0In, uint256 amount1In, uint256 liquidity);\n\n  event Burn(uint256 amount0Out, uint256 amount1Out, uint256 liquidity, address indexed to);\n\n  event Swap(uint256 amount0Out, uint256 amount1Out, uint256 amount0In, uint256 amount1In, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvariantError();\n\n  error InsufficientOutputError();\n\n  /*//////////////////////////////////////////////////////////////\n                                 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  uint120 public override reserve0;\n\n  /// @inheritdoc IPair\n  uint120 public override reserve1;\n\n  /// @inheritdoc IPair\n  uint256 public override totalLiquidity;\n\n  /*//////////////////////////////////////////////////////////////\n                              PAIR LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function mint(uint256 liquidity, bytes calldata data) internal {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE\n    totalLiquidity = _totalLiquidity + liquidity; // SSTORE\n\n    emit Mint(amount0In, amount1In, liquidity);\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);\n    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);\n    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();\n\n    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);\n    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);\n\n    // Extra check of the invariant\n    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();\n\n    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n    totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n    emit Burn(amount0, amount1, liquidity, to);\n  }\n\n  /// @inheritdoc IPair\n  function swap(address to, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external override nonReentrant {\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputError();\n\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n\n    if (amount0Out > 0) SafeTransferLib.safeTransfer(token0, to, amount0Out);\n    if (amount1Out > 0) SafeTransferLib.safeTransfer(token1, to, amount1Out);\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    ISwapCallback(msg.sender).swapCallback(amount0Out, amount1Out, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In - amount0Out, _reserve1 + amount1In - amount1Out, totalLiquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n\n    emit Swap(amount0Out, amount1Out, amount0In, amount1In, to);\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_3",
                "Location": "Pair.invariant() function",
                "Type": "Precision loss",
                "Description": "There is a precision loss in the invariant function that can lead to loss of funds. The significant rounding before conversion to D18 can result in the wrong invariant check result. This can allow an attacker to steal funds without affecting the invariant.",
                "Repair": "Multiply first before division to prevent precision loss"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'hardhat/console.sol';\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport {FixedPointMath} from '../libraries/FixedPointMath.sol';\nimport {IDetailedERC20} from '../interfaces/IDetailedERC20.sol';\nimport {IVaultAdapter} from '../interfaces/IVaultAdapter.sol';\nimport {IVault} from '../../interfaces/IVault.sol';\n\n/// @title YaxisVaultAdapter\n///\n/// @dev A vault adapter implementation which wraps a yAxis vault.\ncontract YaxisVaultAdapter is IVaultAdapter {\n    using FixedPointMath for FixedPointMath.FixedDecimal;\n    using SafeERC20 for IDetailedERC20;\n    using SafeMath for uint256;\n\n    /// @dev The vault that the adapter is wrapping.\n    IVault public vault;\n\n    /// @dev The address which has admin control over this contract.\n    address public admin;\n\n    constructor(IVault _vault, address _admin) public {\n        vault = _vault;\n        admin = _admin;\n        updateApproval();\n    }\n\n    /// @dev A modifier which reverts if the caller is not the admin.\n    modifier onlyAdmin() {\n        require(admin == msg.sender, 'YaxisVaultAdapter: only admin');\n        _;\n    }\n\n    /// @dev Gets the token that the vault accepts.\n    ///\n    /// @return the accepted token.\n    function token() external view override returns (IDetailedERC20) {\n        return IDetailedERC20(vault.getToken());\n    }\n\n    /// @dev Gets the total value of the assets that the adapter holds in the vault.\n    ///\n    /// @return the total assets.\n    function totalValue() external view override returns (uint256) {\n        return _sharesToTokens(IDetailedERC20(vault.getLPToken()).balanceOf(address(this)));\n    }\n\n    /// @dev Deposits tokens into the vault.\n    ///\n    /// @param _amount the amount of tokens to deposit into the vault.\n    function deposit(uint256 _amount) external override {\n        vault.deposit(_amount);\n    }\n\n    /// @dev Withdraws tokens from the vault to the recipient.\n    ///\n    /// This function reverts if the caller is not the admin.\n    ///\n    /// @param _recipient the account to withdraw the tokes to.\n    /// @param _amount    the amount of tokens to withdraw.\n    function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {\n        vault.withdraw(_tokensToShares(_amount));\n        address _token = vault.getToken();\n        IDetailedERC20(_token).safeTransfer(_recipient, _amount);\n    }\n\n    /// @dev Updates the vaults approval of the token to be the maximum value.\n    function updateApproval() public {\n        address _token = vault.getToken();\n        IDetailedERC20(_token).safeApprove(address(vault), uint256(-1));\n    }\n\n    /// @dev Computes the number of tokens an amount of shares is worth.\n    ///\n    /// @param _sharesAmount the amount of shares.\n    ///\n    /// @return the number of tokens the shares are worth.\n\n    function _sharesToTokens(uint256 _sharesAmount) internal view returns (uint256) {\n        return _sharesAmount.mul(vault.getPricePerFullShare()).div(1e18);\n    }\n\n    /// @dev Computes the number of shares an amount of tokens is worth.\n    ///\n    /// @param _tokensAmount the amount of shares.\n    ///\n    /// @return the number of shares the tokens are worth.\n    function _tokensToShares(uint256 _tokensAmount) internal view returns (uint256) {\n        return _tokensAmount.mul(1e18).div(vault.getPricePerFullShare());\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_4",
                "Location": "YaxisVaultAdapter.sol#withdraw()",
                "Type": "Precision Loss",
                "Description": "The actual token withdrawn from 'vault.withdraw()' will most certainly be less than the '_amount', due to precision loss in '_tokensToShares()' and 'vault.withdraw()'. As a result, 'IDetailedERC20(_token).safeTransfer(_recipient, _amount)' will revert due to insufficient balance.",
                "Repair": "Change the code as described above to increment 'totalCredit' instead of overwrite it."
            }
        ]
    },
    {
        "Code": "function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        if(amount == 0) revert Errors.NullValue();\n\n        // Load Pledge parameters & check the Pledge is still active\n        Pledge memory pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // To join until the end of the pledge, user can input 0 as endTimestamp\n        // so it's override by the Pledge's endTimestamp\n        if(endTimestamp == 0) endTimestamp = pledgeParams.endTimestamp;\n        if(endTimestamp > pledgeParams.endTimestamp || endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        // Calculated the effective Pledge duration\n        uint256 boostDuration = endTimestamp - block.timestamp;\n\n        // Check that the user has enough boost delegation available & set the correct allowance to this contract\n        delegationBoost.checkpoint_user(user);\n        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n\n        // Check that this will not go over the Pledge target of votes\n        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n\n        // Creates the DelegationBoost\n        delegationBoost.boost(\n            pledgeParams.receiver,\n            amount,\n            endTimestamp,\n            user\n        );\n\n        // Re-calculate the new Boost bias & slope (using Boostv2 logic)\n        uint256 slope = amount / boostDuration;\n        uint256 bias = slope * boostDuration;\n\n        // Rewards are set in the Pledge as reward/veToken/sec\n        // To find the total amount of veToken delegated through the whole Boost duration\n        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases\n        // each second of the Boost duration\n        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n        // Then we can calculate the total amount of rewards for this Boost\n        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n\n        if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n\n        // Send the rewards to the user\n        IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);\n\n        emit Pledged(pledgeId, user, amount, endTimestamp);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "precision_5",
                "Location": "uint256 slope = amount / boostDuration;\n            uint256 bias = slope * boostDuration;",
                "Type": "Loss of Precision",
                "Description": "Due to loss of precision, targetVotes may not reach.",
                "Repair": "Use bias instead of amount in the check:\n\n            uint256 slope = amount / boostDuration;\n            uint256 bias = slope * boostDuration;\n            if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + bias > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n            delegationBoost.boost(\n                pledgeParams.receiver,\n                amount,\n                endTimestamp,\n                user\n            );"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n/**\n * @author InsureDAO\n * @title InsureDAO market template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\n/**\n * An index pool can index a certain number of pools with leverage.\n *\n * Index A\n * \u3000\u251c Pool A\n * \u3000\u251c Pool B\n * \u3000\u251c Pool C\n * \u3000...\n *\n */\n\ncontract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event Resumed();\n    event Locked();\n    event MetadataChanged(string metadata);\n    event LeverageSet(uint256 target);\n    event AllocationSet(\n        uint256 indexed _index,\n        address indexed pool,\n        uint256 allocPoint\n    );\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    bool public locked;\n    uint256 public pendingEnd;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IVault public vault;\n    IRegistry public registry;\n\n    /// @notice Market variables for margin account\n    uint256 public totalAllocatedCredit; //total allocated credit(liquidity)\n    mapping(address => uint256) public allocPoints; //allocation point for each pool\n    uint256 public totalAllocPoint; //total allocation point\n    address[] public poolList; //list of all pools\n    uint256 public targetLev; //1x = MAGIC_SCALE_1E6\n    //The allocated credits are deemed as liquidity in each underlying pool\n    //Credit amount(liquidity) will be determined by the following math\n    //credit for a pool = total liquidity of this pool * leverage rate * allocation point for a pool / total allocation point\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    struct PoolStatus {\n        uint256 current;\n        uint256 available;\n        uint256 allocation;\n        address addr;\n    }\n\n    ///@notice magic numbers\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-Index\";\n        string memory _symbol = \"iIndex\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collateral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     * @return _mintAmount the amount of iToken minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(locked == false && paused == false, \"ERROR: DEPOSIT_DISABLED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        uint256 _supply = totalSupply();\n        uint256 _totalLiquidity = totalLiquidity();\n        vault.addValue(_amount, msg.sender, address(this));\n\n        if (_supply > 0 && _totalLiquidity > 0) {\n            _mintAmount = (_amount * _supply) / _totalLiquidity;\n        } else if (_supply > 0 && _totalLiquidity == 0) {\n            //when\n            _mintAmount = _amount * _supply;\n        } else {\n            _mintAmount = _amount;\n        }\n        emit Deposit(msg.sender, _amount, _mintAmount);\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n        uint256 _liquidityAfter = _totalLiquidity + _amount;\n        uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n            _liquidityAfter;\n        //execut adjustAlloc only when the leverage became below target - lower-slack\n        if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {\n            _adjustAlloc(_liquidityAfter);\n        }\n    }\n\n    /**\n     * @notice A liquidity provider requests withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collateral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        //Calculate underlying value\n\n        uint256 _liquidty = totalLiquidity();\n        uint256 _lockup = parameters.getLockup(msg.sender);\n        uint256 _requestTime = withdrawalReq[msg.sender].timestamp;\n        _retVal = (_liquidty * _amount) / totalSupply();\n        require(locked == false, \"ERROR: WITHDRAWAL_PENDING\");\n        require(\n            _requestTime + _lockup < block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        require(\n            _retVal <= withdrawable(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Check current leverage rate and get updated target total credit allocation\n        uint256 _liquidityAfter = _liquidty - _retVal;\n\n        if (_liquidityAfter > 0) {\n            uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n                _liquidityAfter;\n            //execute adjustAlloc only when the leverage became above target + upper-slack\n            if (\n                targetLev + parameters.getUpperSlack(address(this)) < _leverage\n            ) {\n                _adjustAlloc(_liquidityAfter);\n            }\n        } else {\n            _adjustAlloc(0);\n        }\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Get how much can a user withdraw from this index\n     * Withdrawable amount = Index liquidity - necessary amount to support credit liquidity\n     * Necessary amoount Locked * totalAllocPoint / allocpoint of the lowest available liquidity market\n     * Otherwise, the allocation to a specific pool may take up the overall allocation, and may break the risk sharing.\n     * @return _retVal withdrawable amount\n     */\n    function withdrawable() public view returns (uint256 _retVal) {\n        uint256 _totalLiquidity = totalLiquidity();\n        if(_totalLiquidity > 0){\n            uint256 _length = poolList.length;\n            uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;\n            uint256 _targetAllocPoint;\n            uint256 _targetLockedCreditScore;\n            //Check which pool has the lowest available rate and keep stats\n            for (uint256 i = 0; i < _length; i++) {\n                address _poolAddress = poolList[i];\n                uint256 _allocPoint = allocPoints[_poolAddress];\n                if (_allocPoint > 0) {\n                    uint256 _allocated = IPoolTemplate(_poolAddress)\n                        .allocatedCredit(address(this));\n                    uint256 _availableBalance = IPoolTemplate(_poolAddress)\n                        .availableBalance();\n                    //check if some portion of credit is locked\n                    if (_allocated > _availableBalance) {\n                        uint256 _availableRate = (_availableBalance *\n                            MAGIC_SCALE_1E6) / _allocated;\n                        uint256 _lockedCredit = _allocated - _availableBalance;\n                        if (i == 0 || _availableRate < _lowestAvailableRate) {\n                            _lowestAvailableRate = _availableRate;\n                            _targetLockedCreditScore = _lockedCredit;\n                            _targetAllocPoint = _allocPoint;\n                        }\n                    }\n                }\n            }\n            //Calculate the return value\n            if (_lowestAvailableRate == MAGIC_SCALE_1E6) {\n                _retVal = _totalLiquidity;\n            } else {\n                uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;\n                _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev;\n                if(_necessaryAmount < _totalLiquidity){\n                    _retVal = _totalLiquidity - _necessaryAmount;\n                }else{\n                    _retVal = 0;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjust allocation of credit based on the target leverage rate\n     */\n    function adjustAlloc() public {\n        _adjustAlloc(totalLiquidity());\n    }\n\n    /**\n     * @notice Internal function to adjust allocation\n     * @param _liquidity available liquidity of the index\n     * Allocation adjustment of credit is done by the following steps\n     * 1)Check total allocatable balance of the index\n     * 2)Calculate ideal allocation for each pool\n     * 3)Check Current allocated balance for each pool\n     * 4)Adjust (withdraw/deposit) allocation for each Pool*\n     *\n     * Liquidity in pool may be locked and cannot withdraw. In that case, the index try to withdraw all available liquidity first,\n     * then recalculated available balance and iterate 1)~4) for the remaining.\n     *\n     * The index may allocate credit beyond the share settings to maintain the leverage rate not to surpass the leverage setting.\n     *\n     * Along with adjustment the index clears accrued premiums in underlying pools to this pool during allocation.\n     */\n    function _adjustAlloc(uint256 _liquidity) internal {\n        //Check current leverage rate and get target total credit allocation\n        uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;\n        uint256 _allocatable = _targetCredit;\n        uint256 _allocatablePoints = totalAllocPoint;\n        uint256 _length = poolList.length;\n        PoolStatus[] memory _poolList = new PoolStatus[](_length);\n\n        //Check each pool and if current credit allocation > target && it is impossible to adjust, then withdraw all availablle credit\n        for (uint256 i = 0; i < _length; i++) {\n            address _pool = poolList[i];\n            if (_pool != address(0)) {\n                uint256 _allocation = allocPoints[_pool];\n                //Target credit allocation for a pool\n                uint256 _target = (_targetCredit * _allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = IPoolTemplate(_pool).allocatedCredit(\n                    address(this)\n                );\n                //get how much liquidty is available to withdraw\n                uint256 _available = IPoolTemplate(_pool).availableBalance();\n                //if needed to withdraw credit but unable, then withdraw all available.\n                //Otherwise, skip.\n                if (\n                    (_current > _target && _current - _target > _available) ||\n                    IPoolTemplate(_pool).paused() == true\n                ) {\n                    IPoolTemplate(_pool).withdrawCredit(_available);\n                    totalAllocatedCredit -= _available;\n                    _poolList[i].addr = address(0);\n                    _allocatable -= _current - _available;\n                    _allocatablePoints -= _allocation;\n                } else {\n                    _poolList[i].addr = _pool;\n                    _poolList[i].current = _current;\n                    _poolList[i].available = _available;\n                    _poolList[i].allocation = _allocation;\n                }\n            }\n        }\n        //Check pools that was not falling under the previous criteria, then adjust to meet the target credit allocation.\n        for (uint256 i = 0; i < _length; i++) {\n            if (_poolList[i].addr != address(0)) {\n                //Target credit allocation for a pool\n                uint256 _target = (_allocatable * _poolList[i].allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = _poolList[i].current;\n                //get how much liquidty is available to withdraw\n                uint256 _available = _poolList[i].available;\n                //Withdraw or Deposit credit\n                if (_current > _target && _available != 0) {\n                    //if allocated credit is higher than the target, try to decrease\n                    uint256 _decrease = _current - _target;\n                    IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);\n                    totalAllocatedCredit -= _decrease;\n                }\n                if (_current < _target) {\n                    //Sometimes we need to allocate more\n                    uint256 _allocate = _target - _current;\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);\n                    totalAllocatedCredit += _allocate;\n                }\n                if (_current == _target) {\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Make a payout if an accident occured in a underlying pool\n     * @param _amount amount of liquidity to compensate for the called pool\n     * We compensate underlying pools by the following steps\n     * 1) Compensate underlying pools from the liquidity of this pool\n     * 2) If this pool is unable to cover a compensation, can get compensated from the CDS pool\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(\n            allocPoints[msg.sender] > 0,\n            \"ERROR_COMPENSATE_UNAUTHORIZED_CALLER\"\n        );\n        uint256 _value = vault.underlyingValue(address(this));\n        if (_value >= _amount) {\n            //When the deposited value without earned premium is enough to cover\n            vault.offsetDebt(_amount, msg.sender);\n            //vault.transferValue(_amount, msg.sender);\n            _compensated = _amount;\n        } else {\n            //Withdraw credit to cashout the earnings\n            uint256 _shortage;\n            if (totalLiquidity() < _amount) {\n                //Insolvency case\n                _shortage = _amount - _value;\n                uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n                    .compensate(_shortage);\n                _compensated = _value + _cds;\n            }\n            vault.offsetDebt(_compensated, msg.sender);\n        }\n        adjustAlloc();\n        emit Compensated(msg.sender, _compensated);\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Resume market\n     */\n    function resume() external override {\n        uint256 _poolLength = poolList.length;\n\n        for (uint256 i = 0; i < _poolLength; i++) {\n            require(\n                IPoolTemplate(poolList[i]).paused() == false,\n                \"ERROR: POOL_IS_PAUSED\"\n            );\n        }\n\n        locked = false;\n        emit Resumed();\n    }\n\n    /**\n     * @notice lock market withdrawal\n     */\n    function lock() external override {\n        require(allocPoints[msg.sender] > 0);\n\n        locked = true;\n        emit Locked();\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice get the current leverage rate 1e6x\n     * @return _rate leverage rate\n     */\n    function leverage() public view returns (uint256 _rate) {\n        //check current leverage rate\n        if (totalLiquidity() > 0) {\n            return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance total liquidity of the pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this)) + _accruedPremiums();\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * totalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get all underlying pools\n     * @return pool array\n     */\n    function getAllPools() external view returns (address[] memory) {\n        return poolList;\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Change target leverate rate for this index x 1e6\n     * @param _target new leverage rate\n     */\n    function setLeverage(uint256 _target) external override onlyOwner {\n        targetLev = _target;\n        adjustAlloc();\n        emit LeverageSet(_target);\n    }\n\n    /**\n     * @notice Change allocation point for each pool\n     * @param _index target id of the underlying pool\n     * @param _pool address of pool\n     * @param _allocPoint new allocation point\n     */\n    function set(\n        uint256 _index,\n        address _pool,\n        uint256 _allocPoint\n    ) public override onlyOwner {\n        require(registry.isListed(_pool), \"ERROR:UNREGISTERED_POOL\");\n        require(\n            _index <= parameters.getMaxList(address(this)),\n            \"ERROR: EXCEEEDED_MAX_INDEX\"\n        );\n        uint256 _length = poolList.length;\n\n        //create a new pool or replace existing\n        if (_length <= _index) {\n            require(_length == _index, \"ERROR: BAD_INDEX\");\n            poolList.push(_pool);\n        } else {\n            address _poolAddress = poolList[_index];\n            if (_poolAddress != address(0) && _poolAddress != _pool) {\n                uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(\n                    address(this)\n                );\n                IPoolTemplate(_poolAddress).withdrawCredit(_current);\n            }\n            poolList[_index] = _pool;\n        }\n        if (totalAllocPoint > 0) {\n            totalAllocPoint =\n                totalAllocPoint -\n                allocPoints[_pool] +\n                _allocPoint;\n        } else {\n            totalAllocPoint = _allocPoint;\n        }\n        allocPoints[_pool] = _allocPoint;\n        adjustAlloc();\n        emit AllocationSet(_index, _pool, _allocPoint);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total equivalent value of credit to token\n     * @return _totalValue accrued but yet claimed premium within underlying pools\n     */\n    function _accruedPremiums() internal view returns (uint256 _totalValue) {\n        for (uint256 i = 0; i < poolList.length; i++) {\n            if (allocPoints[poolList[i]] > 0) {\n                _totalValue =\n                    _totalValue +\n                    IPoolTemplate(poolList[i]).pendingPremium(address(this));\n            }\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_6",
                "Location": "IndexTemplate.sol",
                "Type": "Precision loss while converting between `the amount of shares` and `the amount of underlying tokens`",
                "Description": "IndexTemplate.sol#() will most certainly fail",

                "Repair": "Change the code to use vault.underlyingValue(address(this)) instead of _value + _cds to compensate for the precision loss"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../Controller.sol\";\nimport \"../interfaces/IMarketRegistry.sol\";\nimport \"../interfaces/IMoneyMarketAdapter.sol\";\nimport \"../interfaces/IAssetManager.sol\";\n\n/**\n *  @title AssetManager\n *  @dev Manage the token assets deposited by components and admins, and invest tokens to the integrated underlying lending protocols.\n */\ncontract AssetManager is Controller, ReentrancyGuardUpgradeable, IAssetManager {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    IMoneyMarketAdapter[] public moneyMarkets;\n    mapping(address => Market) public supportedMarkets;\n    address[] public supportedTokensList;\n    //record admin or userManager balance\n    mapping(address => mapping(address => uint256)) public balances; //1 user 2 token\n    mapping(address => uint256) public totalPrincipal; //total stake amount\n    address public marketRegistry;\n    // slither-disable-next-line uninitialized-state\n    uint256[] public withdrawSeq; // Priority sequence of money market indices for processing withdraws\n\n    struct Market {\n        bool isSupported;\n    }\n\n    modifier checkMarketSupported(address token) {\n        require(isMarketSupported(token), \"AssetManager: token not support\");\n        _;\n    }\n\n    modifier onlyAuth(address token) {\n        require(\n            _isUToken(msg.sender, token) || _isUserManager(msg.sender, token),\n            \"AssetManager: sender must uToken or userManager\"\n        );\n        _;\n    }\n\n    /**\n     *  @dev Emit when making a deposit\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Deposit amount, in wei\n     */\n    event LogDeposit(address indexed token, address indexed account, uint256 amount);\n    /**\n     *  @dev Emit when withdrawing from AssetManager\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Withdraw amount, in wei\n     *  @param remaining The amount cannot be withdrawn\n     */\n    event LogWithdraw(address indexed token, address indexed account, uint256 amount, uint256 remaining);\n    /**\n     *  @dev Emit when rebalancing among the integrated money markets\n     *  @param tokenAddress The address of the token to be rebalanced\n     *  @param percentages Array of the percentages of the tokens to deposit to the money markets\n     */\n    event LogRebalance(address tokenAddress, uint256[] percentages);\n\n    function __AssetManager_init(address _marketRegistry) public initializer {\n        Controller.__Controller_init(msg.sender);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        marketRegistry = _marketRegistry;\n    }\n\n    function setMarketRegistry(address _marketRegistry) external onlyAdmin {\n        marketRegistry = _marketRegistry;\n    }\n\n    /**\n     *  @dev Get the balance of asset manager, plus the total amount of tokens deposited to all the underlying lending protocols\n     *  @param tokenAddress ERC20 token address\n     *  @return Pool balance\n     */\n    function getPoolBalance(address tokenAddress) public view override returns (uint256) {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        uint256 balance = poolToken.balanceOf(address(this));\n        if (isMarketSupported(tokenAddress)) {\n            return totalSupplyView(tokenAddress) + balance;\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     *  @dev Returns the amount of the lending pool balance minus the amount of total staked.\n     *  @param tokenAddress ERC20 token address\n     *  @return Amount can be borrowed\n     */\n    function getLoanableAmount(address tokenAddress) public view override returns (uint256) {\n        uint256 poolBalance = getPoolBalance(tokenAddress);\n        if (poolBalance > totalPrincipal[tokenAddress]) return poolBalance - totalPrincipal[tokenAddress];\n        return 0;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols without side effects.\n     *  @param tokenAddress ERC20 token address\n     *  @return Total market balance\n     */\n    function totalSupply(address tokenAddress) public override returns (uint256) {\n        if (isMarketSupported(tokenAddress)) {\n            uint256 tokenSupply = 0;\n            for (uint256 i = 0; i < moneyMarkets.length; i++) {\n                if (!moneyMarkets[i].supportsToken(tokenAddress)) {\n                    continue;\n                }\n                tokenSupply += moneyMarkets[i].getSupply(tokenAddress);\n            }\n\n            return tokenSupply;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols, but without side effects. Safe to call anytime, but may not get the most updated number for the current block. Call totalSupply() for that purpose.\n     *  @param tokenAddress ERC20 token address\n     *  @return Total market balance\n     */\n    function totalSupplyView(address tokenAddress) public view override returns (uint256) {\n        if (isMarketSupported(tokenAddress)) {\n            uint256 tokenSupply = 0;\n            for (uint256 i = 0; i < moneyMarkets.length; i++) {\n                if (!moneyMarkets[i].supportsToken(tokenAddress)) {\n                    continue;\n                }\n                tokenSupply += moneyMarkets[i].getSupplyView(tokenAddress);\n            }\n\n            return tokenSupply;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev Check if there is an underlying protocol available for the given ERC20 token.\n     *  @param tokenAddress ERC20 token address\n     *  @return Whether is supported\n     */\n    function isMarketSupported(address tokenAddress) public view override returns (bool) {\n        return supportedMarkets[tokenAddress].isSupported;\n    }\n\n    /**\n     *  @dev Deposit tokens to AssetManager, and those tokens will be passed along to adapters to deposit to integrated asset protocols if any is available.\n     *  @param token ERC20 token address\n     *  @param amount ERC20 token address\n     *  @return Deposited amount\n     */\n    function deposit(address token, uint256 amount)\n        external\n        override\n        whenNotPaused\n        onlyAuth(token)\n        nonReentrant\n        returns (bool)\n    {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(token);\n        require(amount > 0, \"AssetManager: amount can not be zero\");\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] += amount;\n            totalPrincipal[token] += amount;\n        }\n\n        bool remaining = true;\n        if (isMarketSupported(token)) {\n            // assumption: markets are arranged in order of decreasing liquidity\n            // iterate markets till floors are filled\n            // floors define minimum amount to maintain confidence in liquidity\n            for (uint256 i = 0; i < moneyMarkets.length && remaining; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n\n                if (!moneyMarket.supportsToken(token)) continue;\n                if (moneyMarket.floorMap(token) <= moneyMarket.getSupply(token)) continue;\n\n                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);\n                moneyMarket.deposit(token);\n                remaining = false;\n            }\n\n            // assumption: less liquid markets provide more yield\n            // iterate markets in reverse to optimize for yield\n            // do this only if floors are filled i.e. min liquidity satisfied\n            // dposit in the market where ceiling is not being exceeded\n            for (uint256 j = moneyMarkets.length; j > 0 && remaining; j--) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[j - 1];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                uint256 ceiling = moneyMarket.ceilingMap(token);\n                if (ceiling <= supply) continue;\n                if (supply + amount > ceiling) continue;\n\n                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);\n                moneyMarket.deposit(token);\n                remaining = false;\n            }\n        }\n\n        if (remaining) {\n            poolToken.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit LogDeposit(token, msg.sender, amount);\n\n        return true;\n    }\n\n    /**\n     *  @dev Withdraw from AssetManager\n     *  @param token ERC20 token address\n     *  @param account User address\n     *  @param amount ERC20 token address\n     *  @return Withdraw amount\n     */\n    function withdraw(\n        address token,\n        address account,\n        uint256 amount\n    ) external override whenNotPaused nonReentrant onlyAuth(token) returns (bool) {\n        require(_checkSenderBalance(msg.sender, token, amount), \"AssetManager: balance not enough to withdraw\");\n\n        uint256 remaining = amount;\n\n        // If there are tokens in Asset Manager then transfer them on priority\n        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (selfBalance > 0) {\n            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;\n            remaining -= withdrawAmount;\n            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);\n        }\n\n        if (isMarketSupported(token)) {\n            // iterate markets according to defined sequence and withdraw\n            for (uint256 i = 0; i < withdrawSeq.length && remaining > 0; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                if (supply == 0) continue;\n\n                uint256 withdrawAmount = supply < remaining ? supply : remaining;\n                remaining -= withdrawAmount;\n                moneyMarket.withdraw(token, account, withdrawAmount);\n            }\n        }\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;\n            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;\n        }\n\n        emit LogWithdraw(token, account, amount, remaining);\n\n        return true;\n    }\n\n    function debtWriteOff(address token, uint256 amount) external override {\n        require(balances[msg.sender][token] >= amount, \"AssetManager: balance not enough\");\n        balances[msg.sender][token] -= amount;\n        totalPrincipal[token] -= amount;\n    }\n\n    /**\n     *  @dev Add a new ERC20 token to support in AssetManager\n     *  @param tokenAddress ERC20 token address\n     */\n    function addToken(address tokenAddress) external override onlyAdmin {\n        require(!supportedMarkets[tokenAddress].isSupported, \"AssetManager: token is exist\");\n        supportedTokensList.push(tokenAddress);\n        supportedMarkets[tokenAddress].isSupported = true;\n\n        approveAllMarketsMax(tokenAddress);\n    }\n\n    /**\n     *  @dev For a give token set allowance for all integrated money markets\n     *  @param tokenAddress ERC20 token address\n     */\n    function approveAllMarketsMax(address tokenAddress) public override onlyAdmin {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        for (uint256 i = 0; i < moneyMarkets.length; i++) {\n            poolToken.safeApprove(address(moneyMarkets[i]), 0);\n            poolToken.safeApprove(address(moneyMarkets[i]), type(uint256).max);\n        }\n    }\n\n    /**\n     *  @dev Add a new adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function addAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        for (uint256 i = 0; i < moneyMarkets.length; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) isExist = true;\n        }\n\n        if (!isExist) moneyMarkets.push(IMoneyMarketAdapter(adapterAddress));\n\n        approveAllTokensMax(adapterAddress);\n    }\n\n    function overwriteAdapters(address[] calldata adapters) external onlyAdmin {\n        moneyMarkets = new IMoneyMarketAdapter[](adapters.length);\n        for (uint256 i = 0; i < adapters.length; i++) {\n            moneyMarkets[i] = IMoneyMarketAdapter(adapters[i]);\n        }\n    }\n\n    /**\n     *  @dev For a give moeny market set allowance for all underlying tokens\n     *  @param adapterAddress Address of adaptor for money market\n     */\n    function approveAllTokensMax(address adapterAddress) public override onlyAdmin {\n        for (uint256 i = 0; i < supportedTokensList.length; i++) {\n            IERC20Upgradeable poolToken = IERC20Upgradeable(supportedTokensList[i]);\n            poolToken.safeApprove(adapterAddress, 0);\n            poolToken.safeApprove(adapterAddress, type(uint256).max);\n        }\n    }\n\n    /**\n     *  @dev Set withdraw sequence\n     *  @param newSeq priority sequence of money market indices to be used while withdrawing\n     */\n    function changeWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {\n        withdrawSeq = newSeq;\n    }\n\n    /**\n     * @dev Take all the supply of `tokenAddress` and redistribute it according to `percentages`.\n     *\n     * Rejects if the token is not supported.\n     *\n     * @param tokenAddress Address of the token that is going to be rebalanced\n     * @param percentages A list of percentages, expressed as units in 10000, indicating how to deposit the tokens in\n     * each underlying money market. The length of this array is one less than the amount of money markets: the last\n     * money market will receive the remaining tokens. For example, if there are 3 money markets, and you want to\n     * rebalance so that the first one has 10.5% of the tokens, the second one 55%, and the third one 34.5%, this param\n     * will be [1050, 5500].\n     */\n    function rebalance(address tokenAddress, uint256[] calldata percentages)\n        external\n        override\n        checkMarketSupported(tokenAddress)\n        onlyAdmin\n    {\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n        require(percentages.length + 1 == moneyMarkets.length, \"AssetManager: percentages error\");\n\n        for (uint256 i = 0; i < moneyMarkets.length; i++) {\n            if (!moneyMarkets[i].supportsToken(tokenAddress)) {\n                continue;\n            }\n            moneyMarkets[i].withdrawAll(tokenAddress, address(this));\n        }\n\n        uint256 tokenSupply = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < percentages.length; i++) {\n            if (!moneyMarkets[i].supportsToken(tokenAddress)) {\n                continue;\n            }\n            uint256 amountToDeposit = (tokenSupply * percentages[i]) / 10000;\n            if (amountToDeposit == 0) {\n                continue;\n            }\n            token.safeTransfer(address(moneyMarkets[i]), amountToDeposit);\n            moneyMarkets[i].deposit(tokenAddress);\n        }\n\n        uint256 remainingTokens = token.balanceOf(address(this));\n        if (moneyMarkets[moneyMarkets.length - 1].supportsToken(tokenAddress) && remainingTokens > 0) {\n            token.safeTransfer(address(moneyMarkets[moneyMarkets.length - 1]), remainingTokens);\n            moneyMarkets[moneyMarkets.length - 1].deposit(tokenAddress);\n        }\n\n        require(token.balanceOf(address(this)) == 0, \"AssetManager: there are remaining funds in the fund pool\");\n\n        emit LogRebalance(tokenAddress, percentages);\n    }\n\n    /**\n     *  @dev Claim the tokens left on AssetManager balance, in case there are tokens get stuck here.\n     *  @param tokenAddress ERC20 token address\n     *  @param recipient Recipient address\n     */\n    function claimTokens(address tokenAddress, address recipient) external override onlyAdmin {\n        require(recipient != address(0), \"AsstManager: recipient can not be zero\");\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n        uint256 balance = token.balanceOf(address(this));\n        token.safeTransfer(recipient, balance);\n    }\n\n    /**\n     *  @dev Claim the tokens stuck in the integrated adapters\n     *  @param index MoneyMarkets array index\n     *  @param tokenAddress ERC20 token address\n     *  @param recipient Recipient address\n     */\n    function claimTokensFromAdapter(\n        uint256 index,\n        address tokenAddress,\n        address recipient\n    ) external override onlyAdmin {\n        IMoneyMarketAdapter moneyMarket = moneyMarkets[index];\n        moneyMarket.claimTokens(tokenAddress, recipient);\n    }\n\n    /**\n     *  @dev Get the number of supported underlying protocols.\n     *  @return MoneyMarkets length\n     */\n    function moneyMarketsCount() external view override returns (uint256) {\n        return moneyMarkets.length;\n    }\n\n    /**\n     *  @dev Get the count of supported tokens\n     *  @return Number of supported tokens\n     */\n    function supportedTokensCount() external view override returns (uint256) {\n        return supportedTokensList.length;\n    }\n\n    /**\n     *  @dev Get the supported lending protocol\n     *  @param tokenAddress ERC20 token address\n     *  @param marketId MoneyMarkets array index\n     *  @return rate tokenSupply, rate(compound is supplyRatePerBlock 1e18, aave is supplyRatePerYear 1e27)\n     */\n    function getMoneyMarket(address tokenAddress, uint256 marketId)\n        external\n        view\n        override\n        returns (uint256 rate, uint256 tokenSupply)\n    {\n        rate = moneyMarkets[marketId].getRate(tokenAddress);\n        tokenSupply += moneyMarkets[marketId].getSupplyView(tokenAddress);\n    }\n\n    function _checkSenderBalance(\n        address sender,\n        address tokenAddress,\n        uint256 amount\n    ) private view returns (bool) {\n        if (_isUToken(sender, tokenAddress)) {\n            // For all the lending markets, which have no deposits, return the tokens from the pool\n            return getLoanableAmount(tokenAddress) >= amount;\n        } else {\n            return balances[sender][tokenAddress] >= amount;\n        }\n    }\n\n    function _isUToken(address sender, address token) private view returns (bool) {\n        (address uTokenAddress, ) = IMarketRegistry(marketRegistry).tokens(token);\n        return uTokenAddress == sender;\n    }\n\n    function _isUserManager(address sender, address token) private view returns (bool) {\n        (, address userManagerAddress) = IMarketRegistry(marketRegistry).tokens(token);\n        return userManagerAddress == sender;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_7",
                "Location": "AssetManager.rebalance function",
                "Type": "Low precision percentages",
                "Description": "The rebalance function will fail due to low precision of percentages as they are in base points, i.e, the lowest unit is 1 = 0.01%. This will leave dust in the contract in most cases as the tokens have much higher precision.",
                "Repair": "Remove the final zero balance check, or make sure that the last market that is actually deposited to receives all remaining tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/external/yearn/IYearnVault.sol\";\nimport \"./interfaces/IYearnVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Yearn protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Yearn since the\n/// last `deposit` / `withdraw`\n///\n/// ### yTokens\n/// yTokens are fixed at the token creation and addresses are taken from YearnVault governance and if missing there\n/// - in YearnVaultRegistry.\n/// So essentially each yToken is fixed for life of the YearnVault. If the yToken is missing for some vaultToken,\n/// the YearnVault cannot be created.\n///\n/// ### Push / Pull\n/// There are some deposit limits imposed by Yearn vaults.\n/// The contract's vaultTokens are fully allowed to corresponding yTokens.\n\ncontract YearnVault is Vault {\n    address[] private _yTokens;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _yTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            _yTokens[i] = IYearnVaultGovernance(address(vaultGovernance_)).yTokenForToken(_vaultTokens[i]);\n            require(_yTokens[i] != address(0), \"YV\");\n        }\n    }\n\n    /// @notice Yearn protocol vaults used by this contract\n    function yTokens() external view returns (address[] memory) {\n        return _yTokens;\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        tokenAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            tokenAmounts[i] = (yToken.balanceOf(address(this)) * yToken.pricePerShare()) / (10**yToken.decimals());\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n\n            address token = tokens[i];\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            _allowTokenIfNecessary(token, address(yToken));\n            yToken.deposit(tokenAmounts[i], address(this));\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        uint256 maxLoss = abi.decode(options, (uint256));\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());\n            uint256 balance = yToken.balanceOf(address(this));\n            if (yTokenAmount > balance) {\n                yTokenAmount = balance;\n            }\n            if (yTokenAmount == 0) {\n                continue;\n            }\n            yToken.withdraw(yTokenAmount, to, maxLoss);\n            (tokenAmounts[i], address(this));\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _allowTokenIfNecessary(address token, address yToken) internal {\n        if (IERC20(token).allowance(address(this), yToken) < type(uint256).max / 2) {\n            IERC20(token).approve(yToken, type(uint256).max);\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_8",
                "Location": "YearnVault.sol#pull()",
                "Type": "Precision Loss",
                "Description": "The actual token withdrew from yToken.withdraw() will most certainly be less than the tokenAmounts[i], due to precision loss in the calculation of yTokenAmount. As a result, IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]); in LpIssuer.sol#withdraw() will revert due to insufficient balance.",
                "Repair": "Change the code to withdraw the actual token amount from the YearnVault contract instead of relying on the calculated token amount."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ERC20 } from \"./ERC20.sol\";\nimport { JumpRate } from \"./JumpRate.sol\";\nimport { Pair } from \"./Pair.sol\";\n\nimport { ILendgine } from \"./interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"./interfaces/callback/IMintCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { Position } from \"./libraries/Position.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\n\ncontract Lendgine is ERC20, JumpRate, Pair, ILendgine {\n  using Position for mapping(address => Position.Info);\n  using Position for Position.Info;\n\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Burn(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Deposit(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event Withdraw(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event AccrueInterest(uint256 timeElapsed, uint256 collateral, uint256 liquidity);\n\n  event AccruePositionInterest(address indexed owner, uint256 rewardPerPosition);\n\n  event Collect(address indexed owner, address indexed to, uint256 amount);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InputError();\n\n  error CompleteUtilizationError();\n\n  error InsufficientInputError();\n\n  error InsufficientPositionError();\n\n  /*//////////////////////////////////////////////////////////////\n                          LENDGINE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  mapping(address => Position.Info) public override positions;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalPositionSize;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalLiquidityBorrowed;\n\n  /// @inheritdoc ILendgine\n  uint256 public override rewardPerPositionStored;\n\n  /// @inheritdoc ILendgine\n  uint256 public override lastUpdate;\n\n  /// @inheritdoc ILendgine\n  function mint(\n    address to,\n    uint256 collateral,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 shares)\n  {\n    _accrueInterest();\n\n    uint256 liquidity = convertCollateralToLiquidity(collateral);\n    shares = convertLiquidityToShare(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n    if (liquidity > totalLiquidity) revert CompleteUtilizationError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();\n\n    totalLiquidityBorrowed += liquidity;\n    (uint256 amount0, uint256 amount1) = burn(to, liquidity);\n    _mint(to, shares);\n\n    uint256 balanceBefore = Balance.balance(token1);\n    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);\n    uint256 balanceAfter = Balance.balance(token1);\n\n    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();\n\n    emit Mint(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function burn(address to, bytes calldata data) external override nonReentrant returns (uint256 collateral) {\n    _accrueInterest();\n\n    uint256 shares = balanceOf[address(this)];\n    uint256 liquidity = convertShareToLiquidity(shares);\n    collateral = convertLiquidityToCollateral(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n\n    totalLiquidityBorrowed -= liquidity;\n    _burn(address(this), shares);\n    SafeTransferLib.safeTransfer(token1, to, collateral); // optimistically transfer\n    mint(liquidity, data);\n\n    emit Burn(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function deposit(\n    address to,\n    uint256 liquidity,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 size)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + totalLiquidityBorrowed;\n\n    size = Position.convertLiquidityToPosition(liquidity, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalLiquiditySupplied == 0 && totalPositionSize > 0) revert CompleteUtilizationError();\n\n    positions.update(to, SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize = _totalPositionSize + size;\n    mint(liquidity, data);\n\n    emit Deposit(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function withdraw(\n    address to,\n    uint256 size\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 amount0, uint256 amount1, uint256 liquidity)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n    uint256 totalLiquiditySupplied = _totalLiquidity + totalLiquidityBorrowed;\n\n    Position.Info memory positionInfo = positions[msg.sender]; // SLOAD\n    liquidity = Position.convertPositionToLiquidity(size, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n\n    if (size > positionInfo.size) revert InsufficientPositionError();\n    if (liquidity > _totalLiquidity) revert CompleteUtilizationError();\n\n    positions.update(msg.sender, -SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize -= size;\n    (amount0, amount1) = burn(to, liquidity);\n\n    emit Withdraw(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function accrueInterest() external override nonReentrant {\n    _accrueInterest();\n  }\n\n  /// @inheritdoc ILendgine\n  function accruePositionInterest() external override nonReentrant {\n    _accrueInterest();\n    _accruePositionInterest(msg.sender);\n  }\n\n  /// @inheritdoc ILendgine\n  function collect(address to, uint256 collateralRequested) external override nonReentrant returns (uint256 collateral) {\n    Position.Info storage position = positions[msg.sender]; // SLOAD\n    uint256 tokensOwed = position.tokensOwed;\n\n    collateral = collateralRequested > tokensOwed ? tokensOwed : collateralRequested;\n\n    if (collateral > 0) {\n      position.tokensOwed = tokensOwed - collateral; // SSTORE\n      SafeTransferLib.safeTransfer(token1, to, collateral);\n    }\n\n    emit Collect(msg.sender, to, collateral);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToShare(uint256 liquidity) public view override returns (uint256) {\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    return _totalLiquidityBorrowed == 0 ? liquidity : FullMath.mulDiv(liquidity, totalSupply, _totalLiquidityBorrowed);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertShareToLiquidity(uint256 shares) public view override returns (uint256) {\n    return FullMath.mulDiv(totalLiquidityBorrowed, shares, totalSupply);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertCollateralToLiquidity(uint256 collateral) public view override returns (uint256) {\n    return FullMath.mulDiv(collateral * token1Scale, 1e18, 2 * upperBound);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToCollateral(uint256 liquidity) public view override returns (uint256) {\n    return FullMath.mulDiv(liquidity, 2 * upperBound, 1e18) / token1Scale;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         INTERNAL INTEREST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Helper function for accruing lendgine interest\n  function _accrueInterest() private {\n    if (totalSupply == 0 || totalLiquidityBorrowed == 0) {\n      lastUpdate = block.timestamp;\n      return;\n    }\n\n    uint256 timeElapsed = block.timestamp - lastUpdate;\n    if (timeElapsed == 0) return;\n\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD\n\n    uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);\n\n    uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n    uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;\n    uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);\n\n    totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;\n    rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);\n    lastUpdate = block.timestamp;\n\n    emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);\n  }\n\n  /// @notice Helper function for accruing interest to a position\n  /// @dev Assume the global interest is up to date\n  /// @param owner The address that this position belongs to\n  function _accruePositionInterest(address owner) private {\n    uint256 _rewardPerPositionStored = rewardPerPositionStored; // SLOAD\n\n    positions.update(owner, 0, _rewardPerPositionStored);\n\n    emit AccruePositionInterest(owner, _rewardPerPositionStored);\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ImmutableState } from \"./ImmutableState.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport { IPair } from \"./interfaces/IPair.sol\";\nimport { IPairMintCallback } from \"./interfaces/callback/IPairMintCallback.sol\";\nimport { ISwapCallback } from \"./interfaces/callback/ISwapCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\nabstract contract Pair is ImmutableState, ReentrancyGuard, IPair {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(uint256 amount0In, uint256 amount1In, uint256 liquidity);\n\n  event Burn(uint256 amount0Out, uint256 amount1Out, uint256 liquidity, address indexed to);\n\n  event Swap(uint256 amount0Out, uint256 amount1Out, uint256 amount0In, uint256 amount1In, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvariantError();\n\n  error InsufficientOutputError();\n\n  /*//////////////////////////////////////////////////////////////\n                                 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  uint120 public override reserve0;\n\n  /// @inheritdoc IPair\n  uint120 public override reserve1;\n\n  /// @inheritdoc IPair\n  uint256 public override totalLiquidity;\n\n  /*//////////////////////////////////////////////////////////////\n                              PAIR LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function mint(uint256 liquidity, bytes calldata data) internal {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE\n    totalLiquidity = _totalLiquidity + liquidity; // SSTORE\n\n    emit Mint(amount0In, amount1In, liquidity);\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);\n    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);\n    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();\n\n    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);\n    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);\n\n    // Extra check of the invariant\n    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();\n\n    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n    totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n    emit Burn(amount0, amount1, liquidity, to);\n  }\n\n  /// @inheritdoc IPair\n  function swap(address to, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external override nonReentrant {\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputError();\n\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n\n    if (amount0Out > 0) SafeTransferLib.safeTransfer(token0, to, amount0Out);\n    if (amount1Out > 0) SafeTransferLib.safeTransfer(token1, to, amount1Out);\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    ISwapCallback(msg.sender).swapCallback(amount0Out, amount1Out, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In - amount0Out, _reserve1 + amount1In - amount1Out, totalLiquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n\n    emit Swap(amount0Out, amount1Out, amount0In, amount1In, to);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable max-line-length\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of\n/// precision\n/// @author Muffin (https://github.com/muffinfi/muffin/blob/master/contracts/libraries/math/FullMath.sol)\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256\n/// bits\nlibrary FullMath {\n  /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or\n  /// denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = a * b\n      // Compute the product mod 2**256 and mod 2**256 - 1\n      // then use the Chinese Remainder Theorem to reconstruct\n      // the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2**256 + prod0\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(a, b, not(0))\n        prod0 := mul(a, b)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division\n      if (prod1 == 0) {\n        require(denominator > 0);\n        assembly {\n          result := div(prod0, denominator)\n        }\n        return result;\n      }\n\n      // Make sure the result is less than 2**256.\n      // Also prevents denominator == 0\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0]\n      // Compute remainder using mulmod\n      uint256 remainder;\n      assembly {\n        remainder := mulmod(a, b, denominator)\n      }\n      // Subtract 256 bit number from 512 bit number\n      assembly {\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator\n      // Compute largest power of two divisor of denominator.\n      // Always >= 1.\n\n      // [*] The next line is edited to be compatible with solidity 0.8\n      // ref: https://ethereum.stackexchange.com/a/96646\n      // original: uint256 twos = -denominator & denominator;\n      uint256 twos = denominator & (~denominator + 1);\n\n      // Divide denominator by power of two\n      assembly {\n        denominator := div(denominator, twos)\n      }\n\n      // Divide [prod1 prod0] by the factors of two\n      assembly {\n        prod0 := div(prod0, twos)\n      }\n      // Shift in bits from prod1 into prod0. For this we need\n      // to flip `twos` such that it is 2**256 / twos.\n      // If twos is zero, then it becomes one\n      assembly {\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2**256\n      // Now that denominator is an odd number, it has an inverse\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n      // Compute the inverse by starting with a seed that is correct\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\n      uint256 inv = (3 * denominator) ^ 2;\n      // Now use Newton-Raphson iteration to improve the precision.\n      // Thanks to Hensel's lifting lemma, this also works in modular\n      // arithmetic, doubling the correct bits in each step.\n      inv *= 2 - denominator * inv; // inverse mod 2**8\n      inv *= 2 - denominator * inv; // inverse mod 2**16\n      inv *= 2 - denominator * inv; // inverse mod 2**32\n      inv *= 2 - denominator * inv; // inverse mod 2**64\n      inv *= 2 - denominator * inv; // inverse mod 2**128\n      inv *= 2 - denominator * inv; // inverse mod 2**256\n\n      // Because the division is now exact we can divide by multiplying\n      // with the modular inverse of denominator. This will give us the\n      // correct result modulo 2**256. Since the precoditions guarantee\n      // that the outcome is less than 2**256, this is the final result.\n      // We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inv;\n      return result;\n    }\n  }\n\n  /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or\n  /// denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      result++;\n    }\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_9",
                "Location": "FullMath.mulDiv function in Pair.sol and Lendgine.sol",
                "Type": "Precision Loss",
                "Description": "Division before multiplication incurs unnecessary precision loss",
                "Repair": "Normalize and scale totalLiquidityBorrowed by token precision before multiplication instead of division by 1e18"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ITokenManager.sol\";\nimport \"./interfaces/IWhiteListPeriodManager.sol\";\nimport \"./interfaces/ILiquidityPool.sol\";\n\ncontract LiquidityProviders is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 public constant BASE_DIVISOR = 10**18;\n\n    ILPToken internal lpToken;\n    ILiquidityPool internal liquidityPool;\n    ITokenManager internal tokenManager;\n    IWhiteListPeriodManager internal whiteListPeriodManager;\n\n    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);\n    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);\n    event EthReceived(address indexed sender, uint256 value);\n    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);\n\n    // LP Fee Distribution\n    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated\n    mapping(address => uint256) public totalLiquidity; // Include Liquidity only\n    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer\n    mapping(address => uint256) public totalLPFees;\n    mapping(address => uint256) public totalSharesMinted;\n\n    /**\n     * @dev Modifier for checking to validate a NFTId and it's ownership\n     * @param _tokenId token id to validate\n     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId\n     */\n    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {\n        (address token, , ) = lpToken.tokenMetadata(_tokenId);\n        require(lpToken.exists(_tokenId), \"ERR__TOKEN_DOES_NOT_EXIST\");\n        require(lpToken.ownerOf(_tokenId) == _transactor, \"ERR__TRANSACTOR_DOES_NOT_OWN_NFT\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking if msg.sender in liquiditypool\n     */\n    modifier onlyLiquidityPool() {\n        require(_msgSender() == address(liquidityPool), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(_isSupportedToken(tokenAddress), \"Token not supported\");\n        _;\n    }\n\n    /**\n     * @dev initalizes the contract, acts as constructor\n     * @param _trustedForwarder address of trusted forwarder\n     */\n    function initialize(\n        address _trustedForwarder,\n        address _lpToken,\n        address _tokenManager,\n        address _pauser\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        _setLPToken(_lpToken);\n        _setTokenManager(_tokenManager);\n    }\n\n    function _isSupportedToken(address _token) internal view returns (bool) {\n        return tokenManager.getTokensInfo(_token).supportedToken;\n    }\n\n    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {\n        return totalReserve[tokenAddress];\n    }\n\n    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {\n        return totalLiquidity[tokenAddress];\n    }\n\n    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {\n        return totalLPFees[tokenAddress];\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {\n        return currentLiquidity[tokenAddress];\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of NFT Contract\n     * @param _lpToken address of lpToken\n     */\n    function setLpToken(address _lpToken) external onlyOwner {\n        _setLPToken(_lpToken);\n    }\n\n    /**\n     * Internal method to set LP token contract.\n     */\n    function _setLPToken(address _lpToken) internal {\n        lpToken = ILPToken(_lpToken);\n    }\n\n    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _increaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _decreaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] += amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);\n    }\n\n    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] -= amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);\n    }\n\n    /**\n     * Public method to set TokenManager contract.\n     */\n    function setTokenManager(address _tokenManager) external onlyOwner {\n        _setTokenManager(_tokenManager);\n    }\n\n    /**\n     * Internal method to set TokenManager contract.\n     */\n    function _setTokenManager(address _tokenManager) internal {\n        tokenManager = ITokenManager(_tokenManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract\n     * @param _whiteListPeriodManager address of WhiteListPeriodManager\n     */\n    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {\n        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of LiquidityPool Contract\n     * @param _liquidityPool address of LiquidityPool\n     */\n    function setLiquidityPool(address _liquidityPool) external onlyOwner {\n        liquidityPool = ILiquidityPool(_liquidityPool);\n    }\n\n    /**\n     * @dev Returns price of Base token in terms of LP Shares\n     * @param _baseToken address of baseToken\n     * @return Price of Base token in terms of LP Shares\n     */\n    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {\n        uint256 supply = totalSharesMinted[_baseToken];\n        if (supply > 0) {\n            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];\n        }\n        return BASE_DIVISOR;\n    }\n\n    /**\n     * @dev Converts shares to token amount\n     */\n\n    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {\n        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];\n    }\n\n    /**\n     * @dev Returns the fee accumulated on a given NFT\n     * @param _nftId Id of NFT\n     * @return accumulated fee\n     */\n    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {\n        require(lpToken.exists(_nftId), \"ERR__INVALID_NFT\");\n\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n\n        if (totalNFTShares == 0) {\n            return 0;\n        }\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        return lpFeeAccumulated;\n    }\n\n    /**\n     * @dev Records fee being added to total reserve\n     * @param _token Address of Token for which LP fee is being added\n     * @param _amount Amount being added\n     */\n    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {\n        totalReserve[_token] += _amount;\n        totalLPFees[_token] += _amount;\n        emit FeeAdded(_token, _amount);\n    }\n\n    /**\n     * @dev Internal function to add liquidity to a new NFT\n     */\n    function _addLiquidity(address _token, uint256 _amount) internal {\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        uint256 nftId = lpToken.mint(_msgSender());\n        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);\n        lpToken.updateTokenMetadata(nftId, data);\n        _increaseLiquidity(nftId, _amount);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add native liquidity and store the\n     *      record in the newly minted NFT\n     */\n    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _addLiquidity(NATIVE, msg.value);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add token liquidity and store the\n     *      record in the newly minted NFT\n     * @param _token Address of token for which liquidity is to be added\n     * @param _amount Amount of liquidity added\n     */\n    function addTokenLiquidity(address _token, uint256 _amount)\n        external\n        nonReentrant\n        tokenChecks(_token)\n        whenNotPaused\n    {\n        require(_token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);\n        _addLiquidity(_token, _amount);\n    }\n\n    /**\n     * @dev Internal helper function to increase liquidity in a given NFT\n     */\n    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {\n        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);\n\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);\n\n        uint256 mintedSharesAmount;\n        // Adding liquidity in the pool for the first time\n        if (totalReserve[token] == 0) {\n            mintedSharesAmount = BASE_DIVISOR * _amount;\n        } else {\n            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];\n        }\n\n        require(mintedSharesAmount >= BASE_DIVISOR, \"ERR__AMOUNT_BELOW_MIN_LIQUIDITY\");\n\n        totalLiquidity[token] += _amount;\n        totalReserve[token] += _amount;\n        totalSharesMinted[token] += mintedSharesAmount;\n\n        LpTokenMetadata memory data = LpTokenMetadata(\n            token,\n            totalSuppliedLiquidity + _amount,\n            totalShares + mintedSharesAmount\n        );\n        lpToken.updateTokenMetadata(_nftId, data);\n\n        // Increase the current liquidity\n        _increaseCurrentLiquidity(token, _amount);\n        emit LiquidityAdded(token, _amount, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT\n     * @param _nftId ID of NFT for updating the balances\n     * @param _amount Token amount to be added\n     */\n    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(token), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);\n        _increaseLiquidity(_nftId, _amount);\n    }\n\n    /**\n     * @dev Function to allow LPs to add native token liquidity to existing NFT\n     */\n    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(NATIVE), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token == NATIVE, \"ERR__WRONG_FUNCTION\");\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _increaseLiquidity(_nftId, msg.value);\n    }\n\n    /**\n     * @dev Function to allow LPs to remove their liquidity from an existing NFT\n     *      Also automatically redeems any earned fee\n     */\n    function removeLiquidity(uint256 _nftId, uint256 _amount)\n        external\n        nonReentrant\n        onlyValidLpToken(_nftId, _msgSender())\n        whenNotPaused\n    {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        require(_amount != 0, \"ERR__INVALID_AMOUNT\");\n        require(nftSuppliedLiquidity >= _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");\n        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);\n        // Claculate how much shares represent input amount\n        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        \n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        // Calculate amount of lp shares that represent accumulated Fee\n        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);\n\n        totalLPFees[_tokenAddress] -= lpFeeAccumulated;\n        uint256 amountToWithdraw = _amount + lpFeeAccumulated;\n        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;\n\n        // Handle round off errors to avoid dust lp token in contract\n        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {\n            lpSharesToBurn = totalNFTShares;\n        }\n        totalReserve[_tokenAddress] -= amountToWithdraw;\n        totalLiquidity[_tokenAddress] -= _amount;\n        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;\n\n        _decreaseCurrentLiquidity(_tokenAddress, _amount);\n\n        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);\n\n        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);\n\n        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to claim the fee earned on their NFT\n     * @param _nftId ID of NFT where liquidity is recorded\n     */\n    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n        require(lpFeeAccumulated > 0, \"ERR__NO_REWARDS_TO_CLAIM\");\n        // Calculate amount of lp shares that represent accumulated Fee\n        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;\n\n        totalReserve[_tokenAddress] -= lpFeeAccumulated;\n        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;\n        totalLPFees[_tokenAddress] -= lpFeeAccumulated;\n\n        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);\n        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);\n        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);\n    }\n\n    /**\n     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT\n     */\n    function _burnSharesFromNft(\n        uint256 _nftId,\n        uint256 _shares,\n        uint256 _tokenAmount,\n        address _tokenAddress\n    ) internal {\n        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);\n        nftShares -= _shares;\n        nftSuppliedLiquidity -= _tokenAmount;\n\n        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));\n    }\n\n    function _transferFromLiquidityPool(\n        address _tokenAddress,\n        address _receiver,\n        uint256 _tokenAmount\n    ) internal {\n        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);\n    }\n\n    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {\n        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);\n        return totalSuppliedLiquidity;\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\n\ncontract HyphenLiquidityFarming is\n    Initializable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    ILPToken public lpToken;\n    ILiquidityProviders public liquidityProviders;\n\n    struct NFTInfo {\n        address payable staker;\n        uint256 rewardDebt;\n        uint256 unpaidRewards;\n        bool isStaked;\n    }\n\n    struct PoolInfo {\n        uint256 accTokenPerShare;\n        uint256 lastRewardTime;\n    }\n\n    struct RewardsPerSecondEntry {\n        uint256 rewardsPerSecond;\n        uint256 timestamp;\n    }\n\n    /// @notice Mapping to track the rewarder pool.\n    mapping(address => PoolInfo) public poolInfo;\n\n    /// @notice Info of each NFT that is staked.\n    mapping(uint256 => NFTInfo) public nftInfo;\n\n    /// @notice Reward rate per base token\n    //mapping(address => uint256) public rewardPerSecond;\n\n    /// @notice Reward Token\n    mapping(address => address) public rewardTokens;\n\n    /// @notice Staker => NFTs staked\n    mapping(address => uint256[]) public nftIdsStaked;\n\n    /// @notice Token => Total Shares Staked\n    mapping(address => uint256) public totalSharesStaked;\n\n    /// @notice Token => Reward Rate Updation history\n    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;\n\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);\n    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);\n    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);\n    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);\n    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);\n    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);\n    event LogNativeReceived(address indexed sender, uint256 value);\n\n    function initialize(\n        address _trustedForwarder,\n        address _pauser,\n        ILiquidityProviders _liquidityProviders,\n        ILPToken _lpToken\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        liquidityProviders = _liquidityProviders;\n        lpToken = _lpToken;\n    }\n\n    /// @notice Initialize the rewarder pool.\n    /// @param _baseToken Base token to be used for the rewarder pool.\n    /// @param _rewardToken Reward token to be used for the rewarder pool.\n    /// @param _rewardPerSecond Reward rate per base token.\n    function initalizeRewardPool(\n        address _baseToken,\n        address _rewardToken,\n        uint256 _rewardPerSecond\n    ) external onlyOwner {\n        require(rewardTokens[_baseToken] == address(0), \"ERR__POOL_ALREADY_INITIALIZED\");\n        require(_baseToken != address(0), \"ERR__BASE_TOKEN_IS_ZERO\");\n        require(_rewardToken != address(0), \"ERR_REWARD_TOKEN_IS_ZERO\");\n        rewardTokens[_baseToken] = _rewardToken;\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);\n    }\n\n    function _sendErc20AndGetSentAmount(\n        IERC20Upgradeable _token,\n        uint256 _amount,\n        address _to\n    ) private returns (uint256) {\n        uint256 recepientBalance = _token.balanceOf(_to);\n        _token.safeTransfer(_to, _amount);\n        return _token.balanceOf(_to) - recepientBalance;\n    }\n\n    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.\n    /// @param _nftId NFT ID that is being locked\n    /// @param _to Address to which rewards will be credited.\n    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = updatePool(baseToken);\n        uint256 pending;\n        uint256 amountSent;\n        if (amount > 0) {\n            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n            if (rewardTokens[baseToken] == NATIVE) {\n                uint256 balance = address(this).balance;\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    (bool success, ) = _to.call{value: balance}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = balance;\n                } else {\n                    nft.unpaidRewards = 0;\n                    (bool success, ) = _to.call{value: pending}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = pending;\n                }\n            } else {\n                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);\n                uint256 balance = rewardToken.balanceOf(address(this));\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);\n                } else {\n                    nft.unpaidRewards = 0;\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);\n                }\n            }\n        }\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);\n    }\n\n    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.\n    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);\n    }\n\n    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract\n    /// @param _token Token to reclaim, use 0x00 for Ethereum\n    /// @param _amount Amount of tokens to reclaim\n    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,\n    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,\n    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.\n    function reclaimTokens(\n        address _token,\n        uint256 _amount,\n        address payable _to\n    ) external nonReentrant onlyOwner {\n        require(_to != address(0), \"ERR__TO_IS_ZERO\");\n        if (_token == NATIVE) {\n            (bool success, ) = payable(_to).call{value: _amount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Deposit LP tokens\n    /// @param _nftId LP token nftId to deposit.\n    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n\n        require(\n            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),\n            \"ERR__NOT_APPROVED\"\n        );\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        require(rewardTokens[baseToken] != address(0), \"ERR__POOL_NOT_INITIALIZED\");\n        require(rewardRateLog[baseToken].length != 0, \"ERR__POOL_NOT_INITIALIZED\");\n\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(!nft.isStaked, \"ERR__NFT_ALREADY_STAKED\");\n\n        lpToken.safeTransferFrom(msgSender, address(this), _nftId);\n\n        PoolInfo memory pool = updatePool(baseToken);\n        nft.isStaked = true;\n        nft.staker = _to;\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n\n        nftIdsStaked[_to].push(_nftId);\n        totalSharesStaked[baseToken] += amount;\n\n        emit LogDeposit(msgSender, baseToken, _nftId);\n    }\n\n    /// @notice Withdraw LP tokens\n    /// @param _nftId LP token nftId to withdraw.\n    /// @param _to The receiver of `amount` withdraw benefit.\n    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;\n        uint256 index;\n        for (index = 0; index < nftsStakedLength; ++index) {\n            if (nftIdsStaked[msgSender][index] == _nftId) {\n                break;\n            }\n        }\n\n        require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");\n        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];\n        nftIdsStaked[msgSender].pop();\n\n        _sendRewardsForNft(_nftId, _to);\n        delete nftInfo[_nftId];\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n        totalSharesStaked[baseToken] -= amount;\n\n        lpToken.safeTransferFrom(address(this), msgSender, _nftId);\n\n        emit LogWithdraw(msgSender, baseToken, _nftId, _to);\n    }\n\n    /// @notice Extract all rewards without withdrawing LP tokens\n    /// @param _nftId LP token nftId for which rewards are to be withdrawn\n    /// @param _to The receiver of withdraw benefit.\n    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        require(nftInfo[_nftId].staker == _msgSender(), \"ERR__NOT_OWNER\");\n        _sendRewardsForNft(_nftId, _to);\n    }\n\n    /// @notice Calculates an up to date value of accTokenPerShare\n    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted\n    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {\n        uint256 accumulator = 0;\n        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;\n        uint256 counter = block.timestamp;\n        uint256 i = rewardRateLog[_baseToken].length - 1;\n        while (true) {\n            if (lastUpdatedTime >= counter) {\n                break;\n            }\n            unchecked {\n                accumulator +=\n                    rewardRateLog[_baseToken][i].rewardsPerSecond *\n                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n            }\n            counter = rewardRateLog[_baseToken][i].timestamp;\n            if (i == 0) {\n                break;\n            }\n            --i;\n        }\n\n        // We know that during all the periods that were included in the current iterations,\n        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the\n        // updates to the pool that happened after the lastUpdatedTime.\n        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];\n        return accumulator + poolInfo[_baseToken].accTokenPerShare;\n    }\n\n    /// @notice View function to see pending Token\n    /// @param _nftId NFT for which pending tokens are to be viewed\n    /// @return pending reward for a given user.\n    function pendingToken(uint256 _nftId) external view returns (uint256) {\n        NFTInfo storage nft = nftInfo[_nftId];\n        if (!nft.isStaked) {\n            return 0;\n        }\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = poolInfo[baseToken];\n        uint256 accToken1PerShare = pool.accTokenPerShare;\n        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {\n            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);\n        }\n        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {\n        pool = poolInfo[_baseToken];\n        if (block.timestamp > pool.lastRewardTime) {\n            if (totalSharesStaked[_baseToken] > 0) {\n                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo[_baseToken] = pool;\n            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);\n        }\n    }\n\n    /// @notice View function to see the tokens staked by a given user.\n    /// @param _user Address of user.\n    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {\n        nftIds = nftIdsStaked[_user];\n    }\n\n    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {\n        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit LogNativeReceived(_msgSender(), msg.value);\n    }\n\n    function max(uint256 _a, uint256 _b) private pure returns (uint256) {\n        return _a >= _b ? _a : _b;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_10",
                "Location": "LiquidityFarming.sol#L265-L291, LiquidityProviders.sol#L286-L292",
                "Type": "Precision Loss",
                "Description": "Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss.",
                "Repair": "1. Consider lowering the BASE_DIVISOR so that the initial share price can be higher; 2. Consider making ACC_TOKEN_PRECISION larger to prevent precision loss;"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\n\ncontract PegOracle {\n    /***\n    @dev  for example: oracle1 would be stETH / USD, while oracle2 would be ETH / USD oracle\n    ***/\n    address public oracle1;\n    address public oracle2;\n\n    uint8 public decimals;\n\n    AggregatorV3Interface internal priceFeed1;\n    AggregatorV3Interface internal priceFeed2;\n\n    /** @notice Contract constructor\n      * @param _oracle1 First oracle address\n      * @param _oracle2 Second oracle address\n      */\n    constructor(address _oracle1, address _oracle2) {\n        require(_oracle1 != address(0), \"oracle1 cannot be the zero address\");\n        require(_oracle2 != address(0), \"oracle2 cannot be the zero address\");\n        require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n        priceFeed1 = AggregatorV3Interface(_oracle1);\n        priceFeed2 = AggregatorV3Interface(_oracle2);\n        require(\n            (priceFeed1.decimals() == priceFeed2.decimals()),\n            \"Decimals must be the same\"\n        );\n\n        oracle1 = _oracle1;\n        oracle2 = _oracle2;\n\n        decimals = priceFeed1.decimals();\n    }\n\n    /** @notice Returns oracle-fed data from the latest round\n      * @return roundID Current round id \n      * @return nowPrice Current price\n      * @return startedAt Starting timestamp\n      * @return timeStamp Current timestamp\n      * @return answeredInRound Round id for which answer was computed \n      */ \n    function latestRoundData()\n        public\n        view\n        returns (\n            uint80 roundID,\n            int256 nowPrice,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        )\n    {\n        (\n            uint80 roundID1,\n            int256 price1,\n            uint256 startedAt1,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        int256 price2 = getOracle2_Price();\n\n        if (price1 > price2) {\n            nowPrice = (price2 * 10000) / price1;\n        } else {\n            nowPrice = (price1 * 10000) / price2;\n        }\n\n        int256 decimals10 = int256(10**(18 - priceFeed1.decimals()));\n        nowPrice = nowPrice * decimals10;\n\n        return (\n            roundID1,\n            nowPrice / 1000000,\n            startedAt1,\n            timeStamp1,\n            answeredInRound1\n        );\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup first oracle price\n      * @return price Current first oracle price\n      */ \n    function getOracle1_Price() public view returns (int256 price) {\n        (\n            uint80 roundID1,\n            int256 price1,\n            ,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        require(price1 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound1 >= roundID1,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp1 != 0, \"Timestamp == 0 !\");\n\n        return price1;\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup second oracle price\n      * @return price Current second oracle price\n      */ \n    function getOracle2_Price() public view returns (int256 price) {\n        (\n            uint80 roundID2,\n            int256 price2,\n            ,\n            uint256 timeStamp2,\n            uint80 answeredInRound2\n        ) = priceFeed2.latestRoundData();\n\n        require(price2 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound2 >= roundID2,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp2 != 0, \"Timestamp == 0 !\");\n\n        return price2;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "precision_11",
                "Location": "PegOracle.sol and Controller.sol contracts",
                "Type": "Loss of precision",
                "Description": "The first multiplication is first divided by 1e6 and then re-multiplied by uint256 decimals = 10**(18-(priceFeed.decimals())); which leads to loss of precision. This behavior will make the relative price between the assets incorrect.",
                "Repair": "Use a formula that transforms the relative price to 1e18, and avoid dividing and multiplying by different values that lead to loss of precision"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract PrecisionLoss {\n    function divide(uint256 a, uint256 b) public pure returns (uint256) {\n        return a / b;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_12",
                "Location": "divide function",
                "Type": "Precision loss",
                "Description": "This function performs a division operation between two unsigned integers. In Solidity, the division of integers results in the truncation of decimals, causing a potential loss of precision. For example, if `a = 1` and `b = 2`, the result would be `0` instead of `0.5`.",
                "Repair": "To fix this issue, consider implementing a way to handle decimal values, such as using fixed-point libraries like ABDK Math 64.64 or adding a factor to scale up the result and manually handle precision. Be aware of potential overflow issues when scaling up."
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract PrecisionLoss {\n    function average(uint256 a, uint256 b) public pure returns (uint256) {\n        return (a + b) / 2;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_13",
                "Location": "average function",
                "Type": "Precision loss",
                "Description": "This function calculates the average of two numbers. When the sum of `a` and `b` is odd, the division by 2 results in truncation of decimals, causing a potential loss of precision. For example, if `a = 3` and `b = 2`, the result would be `2` instead of `2.5`.",
                "Repair": "Consider scaling up the result to maintain precision, or use libraries that can handle decimal values. Be aware of potential overflow issues when scaling up."
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract Token {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(balances[msg.sender] >= value, \"Insufficient balance.\");\n\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        return true;\n    }\n\n    function mint(uint256 value) public {\n        totalSupply += value;\n        balances[msg.sender] += value;\n    }\n\n    function burn(uint256 value) public {\n        require(balances[msg.sender] >= value, \"Insufficient balance.\");\n\n        totalSupply -= value;\n        balances[msg.sender] -= value;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_14",
                "Location": "burn function",
                "Type": "Precision loss",
                "Description": "This function decreases the `totalSupply` and `balances[msg.sender]` by `value`. However, there's no check if `totalSupply` or `balances[msg.sender]` becomes a negative number due to underflow which is a type of precision loss.",
                "Repair": "Use SafeMath library or Solidity 0.8.0 or later which has built-in overflow/underflow protection."
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract PrecisionLoss {\n    uint public value;\n\n    function divide(uint256 numerator, uint256 denominator) public {\n        value = numerator / denominator;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_15",
                "Location": "divide function",
                "Type": "Precision loss",
                "Description": "Due to the nature of integer division in Solidity, the fractional part is lost when dividing. This can lead to significant precision loss if not handled properly.",
                "Repair": "Consider using a fixed point math library to handle fractional numbers, or multiply the numerator by a significant figure before performing division to retain more precision."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\ncontract PrecisionLoss {\n    function calculatePercentage(uint256 _value, uint256 _total) public pure returns (uint256) {\n        return _value * 100 / _total;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_16",
                "Location": "calculatePercentage function",
                "Type": "Precision loss",
                "Description": "Due to the nature of integer division in Solidity, the fractional part is lost when calculating the percentage. This can lead to significant precision loss if not handled properly.",
                "Repair": "Consider performing the division first and then multiplying by 100, or use a fixed-point library to handle fractional numbers."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\ncontract InterestCalculation {\n    uint256 public constant INTEREST_RATE = 105;\n    uint256 public constant RATE_BASE = 100;\n\n    function calculateInterest(uint256 principal) public pure returns (uint256) {\n        return (principal * INTEREST_RATE) / RATE_BASE;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_17",
                "Location": "calculateInterest function",
                "Type": "Precision loss",
                "Description": "The integer division in the interest calculation can lead to precision loss for certain values of `principal`.",
                "Repair": "Consider using a fixed-point arithmetic library or multiplying the principal by a higher factor before dividing to maintain precision."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\ncontract MyToken {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balances;\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        uint256 fee = amount / 100;\n        balances[msg.sender] -= amount;\n        balances[to] += amount - fee;\n        totalSupply -= fee;\n        return true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_18",
                "Location": "transfer function",
                "Type": "Precision loss",
                "Description": "The integer division to calculate the fee can lead to precision loss when `amount` is less than 100.",
                "Repair": "Consider using a fixed-point arithmetic library or multiply the amount by a higher factor before dividing to maintain precision."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\ncontract InterestBearing {\n    uint256 public totalSupply;\n    uint256 public totalInterestEarned;\n\n    function calculateInterest(address account) public view returns (uint256) {\n        uint256 accountBalance = balances[account];\n        uint256 interestEarned = (accountBalance * totalInterestEarned) / totalSupply;\n        return interestEarned;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_19",
                "Location": "calculateInterest function",
                "Type": "Precision loss",
                "Description": "The calculation `(accountBalance * totalInterestEarned) / totalSupply` could lead to precision loss if `accountBalance * totalInterestEarned` is not an exact multiple of `totalSupply`.",
                "Repair": "Consider using a fixed-point arithmetic library or multiplying the numerator by a larger factor before dividing to maintain precision."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\ncontract FeeDistributor {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balances;\n    uint256 public totalFees;\n\n    function distributeFees() public {\n        uint256 feesPerToken = totalFees / totalSupply;\n        for (uint256 i = 0; i < totalSupply; i++) {\n            balances[addresses[i]] += feesPerToken;\n        }\n        totalFees = 0;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_20",
                "Location": "distributeFees function",
                "Type": "Precision loss",
                "Description": "The calculation `totalFees / totalSupply` could lead to precision loss if `totalFees` is not an exact multiple of `totalSupply`.",
                "Repair": "Consider using a fixed-point arithmetic library or multiplying the numerator by a larger factor before dividing to maintain precision."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\ncontract Staking {\n    uint256 public totalStakes;\n    mapping(address => uint256) public stakes;\n    uint256 public totalRewards;\n\n    function distributeRewards() public {\n        uint256 rewardsPerStake = totalRewards / totalStakes;\n        for (uint256 i = 0; i < totalStakes; i++) {\n            stakes[addresses[i]] += rewardsPerStake;\n        }\n        totalRewards = 0;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_21",
                "Location": "distributeRewards function",
                "Type": "Precision loss",
                "Description": "The calculation `totalRewards / totalStakes` could lead to precision loss if `totalRewards` is not an exact multiple of `totalStakes`.",
                "Repair": "Consider using a fixed-point arithmetic library or multiplying the numerator by a larger factor before dividing to maintain precision."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TokenExchange {\n    ERC20 public tokenA;\n    ERC20 public tokenB;\n    uint256 public rate;\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) public {\n        tokenA = ERC20(_tokenA);\n        tokenB = ERC20(_tokenB);\n        rate = _rate;\n    }\n\n    function exchange(uint256 amountA) public {\n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"transferFrom failed\");\n        uint256 amountB = amountA * rate;\n        tokenB.transfer(msg.sender, amountB);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_22",
                "Location": "exchange function",
                "Type": "Precision loss",
                "Description": "The calculation `amountA * rate` could lead to precision loss if `rate` is not an integer or if the multiplication result is larger than what can be represented in `uint256`.",
                "Repair": "Consider storing `rate` as a fixed-point number or using a library that supports fractional numbers."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract StakeContract {\n    ERC20 public token;\n\n    uint256 public totalStaked;\n    mapping(address => uint256) public stakedBalance;\n\n    constructor(address _token) public {\n        token = ERC20(_token);\n    }\n\n    function stake(uint256 amount) public {\n        require(token.transferFrom(msg.sender, address(this), amount), \"transfer failed\");\n        totalStaked += amount;\n        stakedBalance[msg.sender] += amount;\n    }\n\n    function claimReward() public {\n        uint256 reward = calculateReward(msg.sender);\n        token.transfer(msg.sender, reward);\n    }\n\n    function calculateReward(address staker) public view returns (uint256) {\n        uint256 stakerBalance = stakedBalance[staker];\n        uint256 reward = (stakerBalance / totalStaked) * token.balanceOf(address(this));\n        return reward;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "precision_23",
                "Location": "calculateReward function",
                "Type": "Precision loss",
                "Description": "The calculation `(stakerBalance / totalStaked) * token.balanceOf(address(this))` could lead to precision loss as the division operation is likely to result in a number less than 1 which will be rounded down to 0.",
                "Repair": "Consider multiplying before dividing to avoid precision loss, or use a library that supports fractional numbers."
            }
        ]
    },
    {
        "Code": "contract MyContract { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) public balances; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { uint256 oldBalance = balances[_from]; uint256 newBalance = oldBalance.sub(_value); balances[_from] = newBalance; balances[_to] = balances[_to].add(_value); return true; } function burn(uint256 _value) public { balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply = totalSupply.sub(_value); } }",
        "VulnerabilityDesc": [
            {
                "Name": "precision_24",
                "Location": "function burn(uint256 _value)",
                "Type": "Precision Loss",
                "Description": "The burn function reduces the balance of the sender and the total supply of tokens. However, this could potentially lead to precision loss if _value is not a multiple of 10.",
                "Repair": "To fix the precision loss issue, we need to ensure that the _value to be burned is a multiple of 10."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12; import \"@openzeppelin/contracts/math/SafeMath.sol\"; contract PrecisionLoss { using SafeMath for uint256; mapping(address => uint256) public tokenBalances; function tokenRatio(address tokenA, address tokenB) public view returns (uint256) { return tokenBalances[tokenA].div(tokenBalances[tokenB]); } }",
        "VulnerabilityDesc": [
            {
                "Name": "precision_25",
                "Location": "function tokenRatio(address tokenA, address tokenB)",
                "Type": "Precision Loss",
                "Description": "This contract is vulnerable to precision loss. If the balance of tokenB is larger than the balance of tokenA, the result will be 0 due to the way integer division works in Solidity.",
                "Repair": "To prevent this, we can return a fixed point number instead of an integer. We can multiply the numerator by a large number (like 1e18) before division and then handle the result as a fixed point number (with 18 decimal places)."
            }
        ]
    }
]