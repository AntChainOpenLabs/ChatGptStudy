[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract FixedStaking {\n    mapping(address => uint256) public balances;\n    uint256 public totalStaked;\n    uint256 public rewardRate = 5;  // Reward rate in percentage\n\n    event Staked(address indexed user, uint256 amount, uint256 reward);\n    event Unstaked(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        uint256 reward = (amount * rewardRate) / 100;\n\n        balances[msg.sender] += amount + reward;  // Fix: First, update user's balance with reward\n        totalStaked += amount;\n\n        emit Staked(msg.sender, amount, reward);\n    }\n\n    function unstake(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;  // Fix: First, reduce the user's balance\n        totalStaked -= amount;\n\n        emit Unstaked(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": {
            "Name": "ben_1",
            "Location": "",
            "Type": "Incorrect_calculating_order",
            "Description": "",
            "Repair": ""
        }
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract FixedTokenSale {\n    address public owner;\n    uint256 public pricePerToken = 1 ether;\n    uint256 public totalTokensSold;\n    mapping(address => uint256) public tokens;\n\n    event Purchased(address indexed user, uint256 amount);\n    event PriceUpdated(uint256 oldPrice, uint256 newPrice);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function purchase(uint256 tokenAmount) external payable {\n        uint256 totalCost = pricePerToken * tokenAmount;\n        require(msg.value >= totalCost, \"Insufficient funds sent\");\n\n        require(totalTokensSold + tokenAmount <= 1000, \"Not enough tokens left\");  // Fix: Check first before updating\n        \n        tokens[msg.sender] += tokenAmount;\n        totalTokensSold += tokenAmount; \n\n        emit Purchased(msg.sender, tokenAmount);\n    }\n\n    function setPrice(uint256 newPrice) external {\n        require(msg.sender == owner, \"Only owner can set price\");\n        \n        uint256 oldPrice = pricePerToken;\n        pricePerToken = newPrice;  // Fixed: Now the order of operations doesn't matter as there's no direct dependency\n\n        emit PriceUpdated(oldPrice, newPrice);\n    }\n}\n",
        "VulnerabilityDesc": {
            "Name": "ben_2",
            "Location": "",
            "Type": "Incorrect_calculating_order",
            "Description": "",
            "Repair": ""
        }
    },
    {
        "Code": NaN,
        "VulnerabilityDesc": {
            "Name": "ben_3",
            "Location": "",
            "Type": "Incorrect_calculating_order",
            "Description": "",
            "Repair": ""
        }
    }
]