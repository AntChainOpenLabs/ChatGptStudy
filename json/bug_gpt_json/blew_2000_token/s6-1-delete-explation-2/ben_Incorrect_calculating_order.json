[
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FeeContract {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 public feePercent = 2; // 2% fee on deposits\n\n    event Deposited(address indexed user, uint256 amount, uint256 fee);\n    event FeeUpdated(uint256 newFee);\n\n    function deposit(uint256 amount) public {\n        _adjustFee(); \n        \n        uint256 fee = _calculateFee(amount);\n\n        balances[msg.sender] += (amount - fee);\n        totalDeposits += amount;\n\n        emit Deposited(msg.sender, amount, fee);\n    }\n\n    function _adjustFee() internal {\n        if (totalDeposits > 1000 ether) {\n            feePercent = 1;  // Discounted fee\n        }\n    }\n\n    function _calculateFee(uint256 amount) internal view returns(uint256) {\n        return amount * feePercent / 100;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_1",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardPool {\n    mapping(address => uint256) public balances;\n    uint256 public totalPool;\n    uint256 public rewardMultiplier = 5; // 5% reward for users based on their balances\n\n    event Rewarded(address indexed user, uint256 rewardAmount);\n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n        totalPool += amount;\n    }\n\n    function claimReward() public {\n        _updateRewardMultiplier(); \n\n        uint256 reward = balances[msg.sender] * rewardMultiplier / 100;\n\n        balances[msg.sender] += reward;\n        emit Rewarded(msg.sender, reward);\n    }\n\n    function _updateRewardMultiplier() internal {\n        if (totalPool > 5000 ether) {\n            rewardMultiplier = 3;  // Reduce reward multiplier if pool is too large\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_2",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TaxContract {\n    mapping(address => uint256) public balances;\n    uint256 public taxRate = 10; // initial 10% tax on withdrawals\n    uint256 public totalCollectedTaxes;\n\n    event Withdrawn(address indexed user, uint256 netAmount);\n    event TaxCollected(uint256 taxAmount);\n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        _adjustTaxRate();\n\n        uint256 taxAmount = amount * taxRate / 100;\n\n        balances[msg.sender] -= (amount + taxAmount);\n        totalCollectedTaxes += taxAmount;\n\n        emit TaxCollected(taxAmount);\n        emit Withdrawn(msg.sender, amount - taxAmount);\n    }\n\n    function _adjustTaxRate() internal {\n        if (totalCollectedTaxes > 100 ether) {\n            taxRate = 5;  // Discounted tax rate after collecting 100 ether\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_3",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract BonusContract {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 public bonusRate = 3; // Initial 3% bonus on deposits\n\n    event Deposited(address indexed user, uint256 depositAmount, uint256 bonus);\n\n    function deposit(uint256 amount) public {\n        _adjustBonusRate();  \n\n        uint256 bonusAmount = amount * bonusRate / 100;\n\n        balances[msg.sender] += (amount + bonusAmount);\n        totalDeposits += amount;\n\n        emit Deposited(msg.sender, amount, bonusAmount);\n    }\n\n    function _adjustBonusRate() internal {\n        if (totalDeposits > 500 ether) {\n            bonusRate = 1;  // Reduced bonus rate if total deposits are high\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_4",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoanContract {\n    mapping(address => uint256) public loanAmount;\n    uint256 public totalLoansGiven;\n    uint256 public interestRate = 7; // Initial 7% interest on loans\n\n    event LoanProvided(address indexed user, uint256 loanAmount, uint256 interest);\n\n    function takeLoan(uint256 amount) public {\n        _adjustInterestRate();  \n\n        uint256 interestAmount = amount * interestRate / 100;\n\n        loanAmount[msg.sender] += (amount + interestAmount);\n        totalLoansGiven += amount;\n\n        emit LoanProvided(msg.sender, amount, interestAmount);\n    }\n\n    function _adjustInterestRate() internal {\n        if (totalLoansGiven > 1000 ether) {\n            interestRate = 5;  // Reduced interest rate if total loans given are high\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_5",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DividendContract {\n    mapping(address => uint256) public shares;\n    uint256 public totalShares;\n    uint256 public totalDividendPool;\n    \n    event DividendClaimed(address indexed user, uint256 amount);\n\n    function buyShares(uint256 amount) public payable {\n        require(msg.value == amount, \"Amount mismatch\");\n        shares[msg.sender] += amount;\n        totalShares += amount;\n        totalDividendPool += amount / 10; // 10% of each buy goes to dividend pool\n    }\n\n    function claimDividend() public {\n        _burnShares(msg.sender, shares[msg.sender] / 20);  // Burn 5% of user shares\n        \n        uint256 userDividend = totalDividendPool * shares[msg.sender] / totalShares;\n\n        shares[msg.sender] += userDividend;\n        totalDividendPool -= userDividend;\n\n        emit DividendClaimed(msg.sender, userDividend);\n    }\n\n    function _burnShares(address user, uint256 amount) internal {\n        shares[user] -= amount;\n        totalShares -= amount;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_6",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SalaryContract {\n    mapping(address => uint256) public employeeSalary;\n    mapping(address => uint256) public lastClaimDate;\n    uint256 public bonusPercent = 10; // 10% bonus for salary claims done after 6 months\n\n    event SalaryClaimed(address indexed employee, uint256 amount);\n\n    function setSalary(address employee, uint256 amount) public {\n        employeeSalary[employee] = amount;\n        lastClaimDate[employee] = block.timestamp;\n    }\n\n    function claimSalary(address employee) public {\n        require(employeeSalary[employee] > 0, \"No salary set for this employee\");\n        uint256 timeSinceLastClaim = block.timestamp - lastClaimDate[employee];\n\n        uint256 bonusAmount = 0;\n        if (timeSinceLastClaim > 180 days) {\n            bonusAmount = employeeSalary[employee] * bonusPercent / 100;\n        }\n\n        uint256 totalClaimable = employeeSalary[employee] + bonusAmount;\n\n        _resetClaimDate(employee);  \n        \n        emit SalaryClaimed(employee, totalClaimable);\n    }\n\n    function _resetClaimDate(address employee) internal {\n        lastClaimDate[employee] = block.timestamp;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_7",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract InvestmentContract {\n    mapping(address => uint256) public investments;\n    uint256 public totalInvestedCapital;\n    uint256 public profitRate = 5; // 5% profit rate for investments\n\n    event ProfitDistributed(address indexed investor, uint256 profit);\n\n    function invest(uint256 amount) public {\n        investments[msg.sender] += amount;\n        totalInvestedCapital += amount;\n    }\n\n    function distributeProfit() public {\n        _adjustProfitRate(); \n\n        uint256 profit = investments[msg.sender] * profitRate / 100;\n\n        investments[msg.sender] += profit;\n        emit ProfitDistributed(msg.sender, profit);\n    }\n\n    function _adjustProfitRate() internal {\n        if (totalInvestedCapital > 2000 ether) {\n            profitRate = 4;  // Reduce profit rate if the total invested capital is high\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_8",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPointsContract {\n    mapping(address => uint256) public userPoints;\n    uint256 public totalTransactions;\n    uint256 public bonusThreshold = 100;  // Every 100 transactions, users get double loyalty points\n\n    event PointsAwarded(address indexed user, uint256 points);\n\n    function purchaseItem(uint256 amount) public {\n        _updateTransactionCount(); \n        uint256 points = amount / 10;  // 10% of purchase amount as loyalty points\n       \n       if (totalTransactions % bonusThreshold == 0) {\n            points = points * 2;  // Double points if user hits the threshold\n        }\n\n        userPoints[msg.sender] += points;\n        emit PointsAwarded(msg.sender, points);\n    }\n\n    function _updateTransactionCount() internal {\n        totalTransactions += 1;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_9",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract ReferralBonusContract {\n    mapping(address => uint256) public userBalance;\n    mapping(address => uint256) public referralsCount;\n    uint256 public referralBonus = 50;  // Bonus for referring 5 users\n\n    event BonusReceived(address indexed referrer, uint256 bonus);\n\n    function deposit() public payable {\n        userBalance[msg.sender] += msg.value;\n    }\n\n    function referUser(address newUser) public {\n        require(userBalance[newUser] == 0, \"User already exists\");\n\n        userBalance[newUser] = 10;  // A small welcome balance\n        referralsCount[msg.sender] += 1;\n\n        if (referralsCount[msg.sender] % 5 == 0) {\n            userBalance[msg.sender] += referralBonus;\n            _giveReferralBonus(msg.sender);  \n        }\n    }\n\n    function _giveReferralBonus(address referrer) internal {\n        emit BonusReceived(referrer, referralBonus);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_10",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DiscountContract {\n    mapping(address => uint256) public userSpent;\n    uint256 public discountThreshold = 1000 ether;  // Once a user spends 1000 ether, they get a discount\n    uint256 public discountRate = 20; // 20% discount for eligible users\n\n    event PurchaseMade(address indexed user, uint256 amountSpent, uint256 discountApplied);\n\n    function purchaseItem(uint256 itemPrice) public {\n        userSpent[msg.sender] += itemPrice;  \n\n        uint256 discount = 0;\n        if (userSpent[msg.sender] >= discountThreshold) {\n            discount = itemPrice * discountRate / 100;\n        }\n\n        uint256 finalPrice = itemPrice - discount;\n        emit PurchaseMade(msg.sender, finalPrice, discount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_11",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SavingsContract {\n    mapping(address => uint256) public savings;\n    uint256 public interestRate = 5;  // Initial 5% interest for all users\n\n    event InterestApplied(address indexed user, uint256 interestAmount);\n\n    function depositFunds(uint256 amount) public {\n        savings[msg.sender] += amount;\n    }\n\n    function applyInterest() public {\n        _updateInterestRate(); \n\n        uint256 interest = savings[msg.sender] * interestRate / 100;\n        savings[msg.sender] += interest;\n        emit InterestApplied(msg.sender, interest);\n    }\n\n    function _updateInterestRate() internal {\n        if (address(this).balance > 5000 ether) {\n            interestRate = 3;  // Reduce interest rate if the contract holds more than 5000 ether\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_12",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenBonusContract {\n    mapping(address => uint256) public tokenBalance;\n    uint256 public bonusThreshold = 1000;  // Once a user holds 1000 tokens, they receive a bonus\n    uint256 public bonusAmount = 100;      // Bonus tokens added to user's balance\n\n    event BonusAdded(address indexed user, uint256 bonusAmount);\n\n    function buyTokens(uint256 amount) public {\n        tokenBalance[msg.sender] += amount;\n\n        if (tokenBalance[msg.sender] >= bonusThreshold) {\n            tokenBalance[msg.sender] += bonusAmount;\n            _applyBonusIfEligible(msg.sender);\n        }\n    }\n\n    function _applyBonusIfEligible(address user) internal {\n        emit BonusAdded(user, bonusAmount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_13",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LotteryContract {\n    mapping(address => uint256) public ticketsPurchased;\n    uint256 public totalTickets = 0;\n    uint256 public rewardMultiplier = 2; // Twice the amount spent is the reward for every 1000th ticket\n\n    event RewardGiven(address indexed user, uint256 reward);\n\n    function buyTicket(uint256 ticketCount) public payable {\n        require(msg.value == ticketCount * 1 ether, \"1 ticket costs 1 ether\");\n\n        ticketsPurchased[msg.sender] += ticketCount;\n        totalTickets += ticketCount;\n\n        _rewardForMilestone(msg.sender, ticketCount);\n    }\n\n    function _rewardForMilestone(address user, uint256 count) internal {\n        if (totalTickets % 1000 == 0) {\n            uint256 reward = count * 1 ether * rewardMultiplier;\n            payable(user).transfer(reward);\n            emit RewardGiven(user, reward);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_14",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CashbackContract {\n    mapping(address => uint256) public userExpenses;\n    uint256 public cashbackRate = 10;  // 10% cashback for expenses over 500 ether\n\n    event CashbackProcessed(address indexed user, uint256 cashbackAmount);\n\n    function addExpense(uint256 amount) public {\n        userExpenses[msg.sender] += amount;\n\n        if (userExpenses[msg.sender] > 500 ether) {\n            uint256 cashback = amount * cashbackRate / 100;\n            payable(msg.sender).transfer(cashback);\n            _processCashback(msg.sender, cashback);  \n        }\n    }\n\n    function _processCashback(address user, uint256 cashback) internal {\n        emit CashbackProcessed(user, cashback);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_15",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardPool {\n    mapping(address => uint256) public userDeposits;\n    uint256 public totalDeposits;\n    uint256 public rewardRate = 5;  // 5% reward for deposits over 1000 ether\n    uint256 public rewardThreshold = 1000 ether;\n\n    event RewardGranted(address indexed user, uint256 rewardAmount);\n\n    function depositFunds(uint256 amount) public {\n        totalDeposits += amount; \n        _distributeReward(msg.sender, amount);\n\n        userDeposits[msg.sender] += amount;\n    }\n\n    function _distributeReward(address user, uint256 depositAmount) internal {\n        if (totalDeposits > rewardThreshold) {\n            uint256 reward = depositAmount * rewardRate / 100;\n            userDeposits[msg.sender] += reward;\n            emit RewardGranted(user, reward);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_16",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SubscriptionContract {\n    mapping(address => uint256) public userSubscriptionEnd;\n    uint256 public subscriptionPrice = 1 ether;\n    uint256 public bonusDuration = 10 days;  // Bonus duration added for subscriptions over 365 days\n\n    event SubscriptionExtended(address indexed user, uint256 endTimestamp);\n\n    function purchaseSubscription(uint256 days) public payable {\n        require(msg.value == days * subscriptionPrice, \"Incorrect payment amount\");\n\n        uint256 totalDuration = days * 1 days;\n        userSubscriptionEnd[msg.sender] += totalDuration;\n\n        _addBonusDuration(msg.sender, days); \n\n        emit SubscriptionExtended(msg.sender, userSubscriptionEnd[msg.sender]);\n    }\n\n    function _addBonusDuration(address user, uint256 days) internal {\n        if (days > 365) {\n            userSubscriptionEnd[user] += bonusDuration;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_17",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CharityContract {\n    mapping(address => uint256) public donations;\n    uint256 public totalDonations;\n    uint256 public matchingRate = 10; // Donor's donation will be matched by 10% from the contract's balance\n\n    event DonationReceived(address indexed donor, uint256 donationAmount, uint256 matchedAmount);\n\n    function donate() public payable {\n        uint256 matchedAmount = msg.value * matchingRate / 100;\n\n        require(address(this).balance >= matchedAmount, \"Contract does not have enough funds to match\");\n\n        _matchDonation(msg.sender, matchedAmount); \n\n        donations[msg.sender] += msg.value + matchedAmount;\n        totalDonations += msg.value + matchedAmount;\n    }\n\n    function _matchDonation(address donor, uint256 amount) internal {\n        donations[donor] += amount;\n        emit DonationReceived(donor, msg.value, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_18",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract ReferralBonus {\n    mapping(address => uint256) public balances;\n    uint256 public referralBonus = 50 ether;  // Bonus amount for each referred user's deposit\n\n    event ReferralBonusAdded(address indexed referrer, address indexed referee, uint256 bonusAmount);\n\n    function depositWithReferral(address referrer) public payable {\n        require(msg.value > 0, \"Deposit amount should be more than 0\");\n\n        balances[msg.sender] += msg.value;\n\n\n        _addReferralBonus(referrer);\n    }\n\n    function _addReferralBonus(address referrer) internal {\n        require(referrer != msg.sender, \"You cannot refer yourself\");\n        balances[referrer] += referralBonus;\n        emit ReferralBonusAdded(referrer, msg.sender, referralBonus);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_19",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TieredRewards {\n    mapping(address => uint256) public userPoints;\n    uint256 public silverThreshold = 1000;  // Points needed for Silver status\n    uint256 public goldThreshold = 5000;    // Points needed for Gold status\n\n    event UpgradedToSilver(address indexed user);\n    event UpgradedToGold(address indexed user);\n\n    function earnPoints(uint256 points) public {\n        userPoints[msg.sender] += points;\n\n\n        _checkForSilverStatus(msg.sender);\n        _checkForGoldStatus(msg.sender);\n    }\n\n    function _checkForSilverStatus(address user) internal {\n        if (userPoints[user] >= silverThreshold && userPoints[user] < goldThreshold) {\n            emit UpgradedToSilver(user);\n        }\n    }\n\n    function _checkForGoldStatus(address user) internal {\n        if (userPoints[user] >= goldThreshold) {\n            emit UpgradedToGold(user);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_20",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract InvestmentContract {\n    mapping(address => uint256) public investments;\n    uint256 public totalInvested;\n    uint256 public bonusThreshold = 1000 ether;  \n    uint256 public bonusRate = 10;  \n\n    event BonusApplied(address indexed user, uint256 bonusAmount);\n\n    function invest() public payable {\n        require(msg.value > 0, \"Investment amount should be greater than 0\");\n\n        investments[msg.sender] += msg.value;\n        totalInvested += msg.value;\n\n\n        _applyInvestmentBonus(msg.sender);\n    }\n\n    function _applyInvestmentBonus(address investor) internal {\n        if (totalInvested > bonusThreshold) {\n            uint256 bonus = (msg.value * bonusRate) / 100;\n            investments[investor] += bonus;\n            emit BonusApplied(investor, bonus);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_21",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public purchaseThreshold = 10 ether;  \n    uint256 public pointsPerEther = 100;  \n\n    event PointsAwarded(address indexed user, uint256 points);\n\n    function makePurchase() public payable {\n        require(msg.value > 0, \"Purchase amount should be greater than 0\");\n        require(msg.value >= purchaseThreshold, \"Purchase amount does not meet the threshold\");\n\n\n        _awardLoyaltyPoints(msg.sender);\n    }\n\n    function _awardLoyaltyPoints(address buyer) internal {\n        uint256 points = (msg.value * pointsPerEther) / 1 ether;\n        loyaltyPoints[buyer] += points;\n        emit PointsAwarded(buyer, points);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_22",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoanContract {\n    mapping(address => uint256) public loanBalances;\n    uint256 public interestRate = 5;  // Interest rate of 5% for the loans\n    uint256 public maxLoanAmount = 50 ether;\n\n    event LoanTaken(address indexed user, uint256 amount, uint256 interest);\n\n    function takeLoan(uint256 amount) public {\n        require(amount <= maxLoanAmount, \"Loan amount exceeds the maximum limit\");\n\n        loanBalances[msg.sender] += amount;\n\n\n        uint256 interest = _calculateInterest(amount);\n        \n        emit LoanTaken(msg.sender, amount, interest);\n    }\n\n    function _calculateInterest(uint256 amount) internal view returns (uint256) {\n        return loanBalances[msg.sender] * interestRate / 100;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_23",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DividendContract {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    uint256 public totalDividends;\n\n    event DividendsPaid(address indexed user, uint256 amount);\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit amount should be more than 0\");\n\n        balances[msg.sender] += msg.value;\n        totalSupply += msg.value;\n        _distributeDividends(msg.sender);\n    }\n\n    function _distributeDividends(address depositor) internal {\n        uint256 userDividends = (balances[depositor] * totalDividends) / totalSupply;\n        payable(depositor).transfer(userDividends);\n        emit DividendsPaid(depositor, userDividends);\n    }\n\n    function distributeDividends() public payable {\n        totalDividends += msg.value;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_24",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DiscountStore {\n    mapping(address => uint256) public userSpending;\n    uint256 public discountThreshold = 10 ether;  \n    uint256 public discountRate = 20;  \n\n    event PurchaseMade(address indexed user, uint256 amountSpent, uint256 discountApplied);\n\n    function makePurchase(uint256 purchaseAmount) public {\n        require(purchaseAmount > 0, \"Purchase amount should be greater than 0\");\n\n        userSpending[msg.sender] += purchaseAmount;\n\n        uint256 discount = _calculateDiscount(purchaseAmount);\n        \n        emit PurchaseMade(msg.sender, purchaseAmount, discount);\n    }\n\n    function _calculateDiscount(uint256 amount) internal view returns (uint256) {\n        if (userSpending[msg.sender] > discountThreshold) {\n            return (amount * discountRate) / 100;\n        }\n        return 0;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_25",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SalaryContract {\n    mapping(address => uint256) public salaries;\n    uint256 public bonusPool = 100 ether;  \n    uint256 public totalEmployees;\n\n    event SalaryPaid(address indexed employee, uint256 amount);\n    event BonusDistributed(address indexed employee, uint256 bonusAmount);\n\n    function addEmployee(address employee, uint256 salaryAmount) public {\n        require(salaryAmount > 0, \"Salary amount should be greater than 0\");\n\n        salaries[employee] = salaryAmount;\n        totalEmployees++;\n\n        _distributeBonus(employee);\n        \n        emit SalaryPaid(employee, salaryAmount);\n    }\n\n    function _distributeBonus(address employee) internal {\n        uint256 bonusAmount = bonusPool / totalEmployees;\n        salaries[employee] += bonusAmount;\n        bonusPool -= bonusAmount;\n        emit BonusDistributed(employee, bonusAmount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_26",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CharityFund {\n    mapping(address => uint256) public donations;\n    uint256 public totalDonations;\n    uint256 public matchingFund = 500 ether;  // A matching fund that matches donations 1:1 up to 500 ether\n\n    event DonationReceived(address indexed donor, uint256 amount, uint256 matchedAmount);\n\n    function donate() public payable {\n        require(msg.value > 0, \"Donation amount should be greater than 0\");\n\n        donations[msg.sender] += msg.value;\n        totalDonations += msg.value;\n\n        uint256 matchAmount = _matchDonation(msg.value);\n        \n        emit DonationReceived(msg.sender, msg.value, matchAmount);\n    }\n\n    function _matchDonation(uint256 amount) internal returns (uint256) {\n        uint256 matchAmount = (amount <= matchingFund) ? amount : matchingFund;\n        totalDonations += matchAmount;\n        matchingFund -= matchAmount;\n        return matchAmount;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_27",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public bonusThreshold = 1000;\n    uint256 public bonusMultiplier = 2;\n\n    event PointsAwarded(address indexed user, uint256 points, uint256 bonusPoints);\n\n    function awardPoints(address user, uint256 points) public {\n        require(points > 0, \"Points awarded should be positive\");\n\n        loyaltyPoints[user] += points;\n\n        uint256 bonus = _calculateBonus(points, loyaltyPoints[user]);\n        \n        emit PointsAwarded(user, points, bonus);\n    }\n\n    function _calculateBonus(uint256 points, uint256 updatedPoints) internal returns (uint256) {\n        if (updatedPoints > bonusThreshold) {\n            return points * bonusMultiplier;\n        }\n        return 0;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_28",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Token {\n    mapping(address => uint256) public balances;\n    uint256 public taxRate = 5;  // 5% tax for each transfer\n\n    event Transfer(address indexed from, address indexed to, uint256 value, uint256 tax);\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        uint256 tax = (amount * taxRate) / 100;\n        uint256 netAmount = amount - tax;\n\n        require(balances[msg.sender] >= (amount + tax), \"Insufficient balance after tax deduction\");\n\n        balances[msg.sender] -= (amount + tax);  \n        balances[to] += netAmount;  \n\n        emit Transfer(msg.sender, to, amount, tax);\n        return true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_29",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LendingPlatform {\n    mapping(address => uint256) public deposits;\n    mapping(address => uint256) public lastDepositTime;\n    uint256 public interestRate = 10;  // 10% annual interest\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrew(address indexed user, uint256 amount);\n\n    function deposit() public payable {\n        deposits[msg.sender] += msg.value;\n        lastDepositTime[msg.sender] = block.timestamp;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        uint256 initialAmount = deposits[msg.sender];\n        uint256 duration = (block.timestamp - lastDepositTime[msg.sender]) / (365 days);\n        \n\n        uint256 amount = initialAmount;\n        for(uint256 i = 0; i < duration; i++) {\n            amount += (amount * interestRate) / 100;\n        }\n\n        require(address(this).balance >= amount, \"Contract balance insufficient\");\n\n        deposits[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n\n        emit Withdrew(msg.sender, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_30",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardSystem {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastRewardClaimTime;\n    uint256 public rewardRate = 5;  // 5% reward rate for holding tokens\n    uint256 public holdDuration = 30 days; \n\n    event Rewarded(address indexed user, uint256 amount);\n\n    function depositTokens(uint256 amount) public {\n        require(amount > 0, \"Invalid amount\");\n        balances[msg.sender] += amount;\n        if (lastRewardClaimTime[msg.sender] == 0) {\n            lastRewardClaimTime[msg.sender] = block.timestamp;\n        }\n    }\n\n    function claimReward() public {\n        require(block.timestamp - lastRewardClaimTime[msg.sender] >= holdDuration, \"Hold duration not met\");\n\n        uint256 initialBalance = balances[msg.sender];\n        uint256 reward = (initialBalance * rewardRate) / 100;\n        balances[msg.sender] += reward;\n\n        lastRewardClaimTime[msg.sender] = block.timestamp;\n\n        emit Rewarded(msg.sender, reward);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_31",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TimedVault {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public depositTimes;\n    uint256 public timeLock = 7 days;  // Users must wait 7 days before withdrawing\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        depositTimes[msg.sender] = block.timestamp;  // Sets the time of deposit\n\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        require(block.timestamp >= depositTimes[msg.sender] + timeLock, \"Funds are still locked\");\n\n        uint256 amount = balances[msg.sender];\n\n        balances[msg.sender] = 0;  \n        payable(msg.sender).transfer(amount);  \n        depositTimes[msg.sender] = block.timestamp;  \n        emit Withdrawn(msg.sender, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_32",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n    uint256 public redemptionThreshold = 1000;\n    uint256 public rewardAmount = 1 ether;\n\n    event PointsEarned(address indexed user, uint256 amount);\n    event RewardRedeemed(address indexed user);\n\n    function earnPoints(uint256 amount) public {\n        points[msg.sender] += amount;\n\n        emit PointsEarned(msg.sender, amount);\n    }\n\n    function redeemReward() public {\n        require(points[msg.sender] >= redemptionThreshold, \"Not enough points to redeem reward\");\n\n        payable(msg.sender).transfer(rewardAmount); \n        points[msg.sender] -= redemptionThreshold; \n\n        emit RewardRedeemed(msg.sender);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_33",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Staking {\n    mapping(address => uint256) public balances;\n    uint256 public totalStaked;\n    uint256 public rewardRate = 5;  // Reward rate in percentage\n\n    event Staked(address indexed user, uint256 amount, uint256 reward);\n    event Unstaked(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        uint256 reward = (amount * rewardRate) / 100;\n\n        balances[msg.sender] += amount + reward; \n        totalStaked += amount;\n\n        emit Staked(msg.sender, amount, reward);\n    }\n\n    function unstake(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= amount; \n        totalStaked -= amount;\n\n        emit Unstaked(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_34",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenSale {\n    address public owner;\n    uint256 public pricePerToken = 1 ether;\n    uint256 public totalTokensSold;\n    mapping(address => uint256) public tokens;\n\n    event Purchased(address indexed user, uint256 amount);\n    event PriceUpdated(uint256 oldPrice, uint256 newPrice);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function purchase(uint256 tokenAmount) external payable {\n        uint256 totalCost = pricePerToken * tokenAmount;\n        require(msg.value >= totalCost, \"Insufficient funds sent\");\n\n        require(totalTokensSold + tokenAmount <= 1000, \"Not enough tokens left\");\n        \n        tokens[msg.sender] += tokenAmount;\n        totalTokensSold += tokenAmount; \n\n        emit Purchased(msg.sender, tokenAmount);\n    }\n\n    function setPrice(uint256 newPrice) external {\n        require(msg.sender == owner, \"Only owner can set price\");\n        \n        uint256 oldPrice = pricePerToken;\n        pricePerToken = newPrice; \n        emit PriceUpdated(oldPrice, newPrice);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_35",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Bank {\n    address public owner;\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() external payable {\n        require(totalDeposits + msg.value <= 5000 ether, \"Bank full\"); \n        balances[msg.sender] += msg.value;\n        totalDeposits += msg.value; \n        \n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        \n        balances[msg.sender] -= amount; \n        payable(msg.sender).transfer(amount);\n        \n        totalDeposits -= amount;\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_36",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyProgram {\n    mapping(address => uint256) public points;\n    uint256 public totalRedeemed;\n\n    event PointsEarned(address indexed user, uint256 amount);\n    event PointsRedeemed(address indexed user, uint256 amount);\n\n    function earnPoints(uint256 amount) external {\n        points[msg.sender] += amount;\n        emit PointsEarned(msg.sender, amount);\n    }\n\n    function redeemPoints(uint256 amount) external {\n        require(points[msg.sender] >= amount, \"Insufficient points\");\n        require(totalRedeemed + amount <= 10000, \"Redemption limit reached\");  \n\n        points[msg.sender] -= amount;\n        totalRedeemed += amount;\n\n        emit PointsRedeemed(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_37",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastUpdated;\n\n    uint256 public interestRate = 10; // 10% annual interest\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrew(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        updateInterest(msg.sender);\n        balances[msg.sender] += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        updateInterest(msg.sender);\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n       \n        balances[msg.sender] -= amount;\n\n        payable(msg.sender).transfer(amount);\n        emit Withdrew(msg.sender, amount);\n    }\n\n    function updateInterest(address user) internal {\n        uint256 elapsed = block.timestamp - lastUpdated[user];\n        balances[user] += (balances[user] * interestRate / 100) * elapsed / 365 days;\n        lastUpdated[user] = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_38",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract RewardSystem {\n    mapping(address => uint256) public stakedTokens;\n    mapping(address => uint256) public rewardBalance;\n\n    uint256 public totalStakedTokens;\n    uint256 public rewardPool = 10000 ether; // initial reward pool\n\n    event Staked(address indexed user, uint256 amount);\n    event ClaimedRewards(address indexed user, uint256 reward);\n\n    function stake(uint256 amount) external {\n        stakedTokens[msg.sender] += amount;\n        totalStakedTokens += amount;\n        emit Staked(msg.sender, amount);\n    }\n\n    function claimRewards() external {\n        uint256 reward = computeReward(msg.sender);\n\n        require(rewardPool >= reward, \"Not enough rewards in the pool\");\n        \n      \n        rewardPool -= reward;\n        rewardBalance[msg.sender] += reward;\n\n        rewardBalance[msg.sender] = 0;\n        payable(msg.sender).transfer(reward);\n        emit ClaimedRewards(msg.sender, reward);\n    }\n\n    function computeReward(address user) public view returns (uint256) {\n        return (stakedTokens[user] * rewardPool) / totalStakedTokens;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_39",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LendingSystem {\n    mapping(address => uint256) public deposits;\n    uint256 public totalDeposits;\n    uint256 public interestRate = 5; // represented in percentage\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit(uint256 amount) external {\n        deposits[msg.sender] += amount;\n        totalDeposits += amount;\n        emit Deposited(msg.sender, amount);\n    }\n\n    function withdraw() external {\n        uint256 principalAmount = deposits[msg.sender];\n        uint256 interestAmount = principalAmount * interestRate / 100;\n        uint256 totalWithdrawalAmount = principalAmount + interestAmount;\n\n        require(totalDeposits >= totalWithdrawalAmount, \"Not enough funds in the system\");\n\n        totalDeposits -= principalAmount; \n        deposits[msg.sender] = 0;\n\n        payable(msg.sender).transfer(totalWithdrawalAmount);\n        emit Withdrawn(msg.sender, totalWithdrawalAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_40",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract StakingSystem {\n    mapping(address => uint256) public stakes;\n    uint256 public totalStakes;\n    uint256 public rewardRate = 10; // represented in percentage\n\n    event Staked(address indexed user, uint256 amount);\n    event Unstaked(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        stakes[msg.sender] += amount;\n        totalStakes += amount;\n        emit Staked(msg.sender, amount);\n    }\n\n    function unstake() external {\n        uint256 stakeAmount = stakes[msg.sender];\n        uint256 reward = stakeAmount * rewardRate / 100;\n        uint256 totalWithdrawalAmount = stakeAmount + reward;\n\n        require(totalStakes + reward >= totalWithdrawalAmount, \"Not enough funds in the system\");\n\n        totalStakes -= stakeAmount;  \n        stakes[msg.sender] = 0;\n\n        payable(msg.sender).transfer(totalWithdrawalAmount);\n        emit Unstaked(msg.sender, totalWithdrawalAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_41",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public redemptionRate = 5; // 5 ether for each loyalty point\n\n    event PointsAccrued(address indexed user, uint256 points);\n    event PointsRedeemed(address indexed user, uint256 amount);\n\n    function accruePoints(uint256 points) external {\n        loyaltyPoints[msg.sender] += points;\n        emit PointsAccrued(msg.sender, points);\n    }\n\n    function redeemPoints() external {\n        uint256 userPoints = loyaltyPoints[msg.sender];\n        \n        require(userPoints > 0, \"No loyalty points available\");\n\n       \n        loyaltyPoints[msg.sender] = 0;\n        \n        uint256 redemptionAmount = userPoints * redemptionRate;\n        require(address(this).balance >= redemptionAmount, \"Insufficient funds to redeem\");\n        \n        payable(msg.sender).transfer(redemptionAmount);\n        emit PointsRedeemed(msg.sender, redemptionAmount);\n    }\n\n    receive() external payable {} // to fund the contract\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_42",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Staking {\n    mapping(address => uint256) public stakedAmount;\n    mapping(address => uint256) public lastStakedTime;\n    uint256 public rewardRate = 1;  // 1 token reward for every block\n\n    event Staked(address indexed user, uint256 amount);\n    event Unstaked(address indexed user, uint256 amount, uint256 reward);\n\n    function stake(uint256 amount) external {\n        stakedAmount[msg.sender] += amount;\n        lastStakedTime[msg.sender] = block.number;\n\n        emit Staked(msg.sender, amount);\n    }\n\n    function unstake() external {\n        uint256 userStake = stakedAmount[msg.sender];\n        \n       \n        stakedAmount[msg.sender] = 0;\n        lastStakedTime[msg.sender] = block.number;\n\n        uint256 reward = (block.number - lastStakedTime[msg.sender]) * rewardRate;\n\n        emit Unstaked(msg.sender, userStake, reward);\n    }\n\n    // This function allows users to claim their rewards without unstaking.\n    function claimReward() external {\n        uint256 reward = (block.number - lastStakedTime[msg.sender]) * rewardRate;\n        lastStakedTime[msg.sender] = block.number;\n\n        // Logic to transfer reward tokens to user...\n\n        emit Unstaked(msg.sender, 0, reward);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_43",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Voting {\n    struct Proposal {\n        string description;\n        uint256 voteCount;\n    }\n\n    mapping(address => bool) public hasVoted;\n    Proposal[] public proposals;\n\n    event Voted(address indexed voter, uint256 proposalId);\n\n    function addProposal(string memory description) external {\n        proposals.push(Proposal({\n            description: description,\n            voteCount: 0\n        }));\n    }\n\n    function castVote(uint256 proposalId) external {\n        require(proposalId < proposals.length, \"Invalid proposal ID\");\n        require(!hasVoted[msg.sender], \"Already voted!\");\n\n       \n        hasVoted[msg.sender] = true;\n\n        proposals[proposalId].voteCount += 1;\n\n        emit Voted(msg.sender, proposalId);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_44",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract RewardDistributor {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public rewards;\n\n    uint256 public totalRewards;\n\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    constructor(uint256 _initialRewards) {\n        totalRewards = _initialRewards;\n    }\n\n    function deposit(uint256 amount) external {\n        balances[msg.sender] += amount;\n        distributeReward(msg.sender);\n    }\n\n    function claimReward() external {\n        distributeReward(msg.sender);\n\n        uint256 rewardToClaim = rewards[msg.sender];\n        require(rewardToClaim <= totalRewards, \"Not enough rewards left\");\n\n       \n        totalRewards -= rewardToClaim;\n        rewards[msg.sender] = 0;\n\n        emit RewardClaimed(msg.sender, rewardToClaim);\n    }\n\n    function distributeReward(address user) internal {\n        rewards[user] += balances[user];\n        totalRewards -= balances[user];\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_45",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Staking {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastStakedTimestamp;\n    uint256 public interestRate = 5;  // 5% interest per day\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        balances[msg.sender] += amount;\n        lastStakedTimestamp[msg.sender] = block.timestamp;\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw() external {\n        \n        uint256 principal = balances[msg.sender];\n        uint256 interest = (principal * ((block.timestamp - lastStakedTimestamp[msg.sender]) / 1 days) * interestRate) / 100;\n        uint256 total = principal + interest;\n        \n        balances[msg.sender] = 0;\n\n        msg.sender.transfer(total);\n\n        emit Withdrawn(msg.sender, total);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_46",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n    mapping(address => uint256) public lastPurchaseDate;\n    uint256 public bonusPoints = 1000;\n\n    event PointsEarned(address indexed user, uint256 amount);\n\n    function purchase(uint256 amount) external {\n        if(block.timestamp - lastPurchaseDate[msg.sender] > 365 days) {\n            points[msg.sender] += bonusPoints;  \n        }\n\n        points[msg.sender] += amount;\n        lastPurchaseDate[msg.sender] = block.timestamp;  \n\n        emit PointsEarned(msg.sender, amount + (block.timestamp - lastPurchaseDate[msg.sender] > 365 days ? bonusPoints : 0));\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_47",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract RewardPool {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastRewardClaim;\n    uint256 public rewardRate = 1e18;  // 1 ether reward for every day they've kept funds in the pool\n\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        if (balances[msg.sender] > 0) {\n            uint256 timeSinceLastClaim = block.timestamp - lastRewardClaim[msg.sender];\n            uint256 reward = (timeSinceLastClaim / 1 days) * rewardRate;\n            \n            balances[msg.sender] += msg.value; \n            lastRewardClaim[msg.sender] = block.timestamp;  \n            payable(msg.sender).transfer(reward);\n\n            emit RewardClaimed(msg.sender, reward);\n        } else {\n            balances[msg.sender] += msg.value;\n            lastRewardClaim[msg.sender] = block.timestamp;\n        }\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_48",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyRewards {\n    uint256 public rewardRate = 100;  // 100 points per interaction initially\n    uint256 public totalInteractions;\n    mapping(address => uint256) public pointsBalance;\n\n    function userInteraction() external {\n        totalInteractions += 1;\n        rewardRate = 1000 / (1 + totalInteractions); \n        \n        uint256 pointsEarned = rewardRate;\n        pointsBalance[msg.sender] += pointsEarned;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_49",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface ICustomToken {\n    function mint(address recipient, uint256 amount) external;\n}\n\ncontract TokenVault {\n    ICustomToken public token;\n    uint256 public interestRate = 10; // 10% annually for simplicity\n    mapping(address => uint256) public lastDepositTime;\n    mapping(address => uint256) public ethBalance;\n\n    constructor(address _token) {\n        token = ICustomToken(_token);\n    }\n\n    function depositETH() external payable {\n        uint256 currentDeposit = msg.value;\n        _creditInterest(msg.sender); \n        ethBalance[msg.sender] += currentDeposit;\n        lastDepositTime[msg.sender] = block.timestamp;\n    }\n\n    function _creditInterest(address user) internal {\n        uint256 timeElapsed = block.timestamp - lastDepositTime[user];\n        uint256 interest = (ethBalance[user] * interestRate * timeElapsed) / (365 days);\n        token.mint(user, interest);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_50",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyStore {\n    mapping(address => uint256) public points;\n    mapping(address => bool) public hasDiscount;\n    uint256 public itemCost = 1000;\n\n    function purchaseItem() external {\n        uint256 effectiveCost = itemCost;\n\n        if (hasDiscount[msg.sender]) {\n            effectiveCost -= effectiveCost / 10;  \n        }\n\n        require(points[msg.sender] >= effectiveCost, \"Not enough points\");\n        points[msg.sender] -= effectiveCost;\n\n        \n        hasDiscount[msg.sender] = true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_51",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract InvestmentPool {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposited;\n    uint256 public interestRate = 5;  // 5%\n\n    function deposit(uint256 amount) external {\n        accrueInterest();  \n        balances[msg.sender] += amount;\n        totalDeposited += amount;\n    }\n\n    function accrueInterest() internal {\n        uint256 interest = (totalDeposited * interestRate) / 100;\n        totalDeposited += interest;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_52",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TokenStaking {\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public dividends;\n    uint256 public totalStaked;\n    uint256 public poolDividend;\n\n    // Event to track dividends\n    event DividendPaid(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        distributeDividend(msg.sender); \n\n        stakes[msg.sender] += amount;\n        totalStaked += amount;\n    }\n\n    function distributeDividend(address user) internal {\n        uint256 userDividend = (poolDividend * stakes[user]) / totalStaked;\n        dividends[user] += userDividend;\n        emit DividendPaid(user, userDividend);\n    }\n\n    // Function to add funds to the dividend pool\n    function addFundsToPool(uint256 amount) external {\n        poolDividend += amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_53",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract FruitMarket {\n    mapping(string => uint256) public fruitStock;\n    mapping(string => uint256) public fruitPrice;\n\n    event FruitPurchased(address indexed buyer, string fruitName, uint256 quantity);\n\n    constructor() {\n        fruitStock[\"apple\"] = 1000;\n        fruitStock[\"banana\"] = 800;\n        fruitPrice[\"apple\"] = 1 ether;\n        fruitPrice[\"banana\"] = 0.5 ether;\n    }\n\n    function purchaseFruit(string memory fruitName, uint256 quantity) external payable {\n        require(fruitStock[fruitName] >= quantity, \"Not enough fruits in stock\");\n        uint256 totalCost = fruitPrice[fruitName] * quantity;\n        require(msg.value == totalCost, \"Incorrect ether sent\");\n\n       \n        payable(address(this)).transfer(totalCost);\n        \n        fruitStock[fruitName] -= quantity;\n\n        emit FruitPurchased(msg.sender, fruitName, quantity);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_54",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract RewardVault {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastUpdated;\n    uint256 public interestRate = 5; // Represents 5%\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        updateInterest(msg.sender);\n\n        balances[msg.sender] += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        updateInterest(msg.sender);\n\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n\n        payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function updateInterest(address user) internal {\n        uint256 elapsedTime = block.timestamp - lastUpdated[user];\n        uint256 interest = (balances[user] * interestRate * elapsedTime) / (365 days * 100);\n        balances[user] += interest;\n        lastUpdated[user] = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_55",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract TokenSwap {\n\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n    uint256 public rate;  // Rate of TokenA to TokenB (e.g. rate = 2 means 1 TokenA = 2 TokenB)\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        tokenA = IERC20(_tokenA);\n        tokenB = IERC20(_tokenB);\n        rate = _rate;\n    }\n\n    function swap(uint256 amountA) external {\n        uint256 amountB = amountA * rate;\n\n        require(tokenB.balanceOf(address(this)) >= amountB, \"Not enough TokenB in contract\");\n\n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of TokenA failed\");\n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of TokenB failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_56",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract LoyaltyReward {\n\n    IERC20 public rewardToken;\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public conversionRate;\n\n    constructor(address _rewardToken, uint256 _conversionRate) {\n        rewardToken = IERC20(_rewardToken);\n        conversionRate = _conversionRate;\n    }\n\n    function setLoyaltyPoints(address user, uint256 points) external {\n        require(msg.sender == address(this), \"Only contract owner can set loyalty points\");\n        loyaltyPoints[user] = points;\n    }\n\n    function claimReward() external {\n        uint256 rewardAmount = loyaltyPoints[msg.sender] * conversionRate;\n\n        require(rewardToken.balanceOf(address(this)) >= rewardAmount, \"Not enough reward tokens in contract\");\n\n        require(rewardToken.transfer(msg.sender, rewardAmount), \"Transfer of reward token failed\");\n\n        loyaltyPoints[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_57",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract DepositContract {\n\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n\n        balances[msg.sender] -= amount;\n        \n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_58",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public pointsToRedeem = 1000;\n    uint256 public rewardAmount = 0.1 ether;\n\n    function spendFunds(uint256 amount) external payable {\n        require(msg.value == amount, \"Incorrect Ether sent\");\n        \n        // Earn 1 point for every 1 ether spent.\n        loyaltyPoints[msg.sender] += amount;\n\n        if(loyaltyPoints[msg.sender] >= pointsToRedeem) {\n            loyaltyPoints[msg.sender] -= pointsToRedeem;\n            payable(msg.sender).transfer(rewardAmount);\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_59",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenVault {\n    IERC20 public token;\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lockTime;\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        balances[msg.sender] += amount;\n        lockTime[msg.sender] = block.timestamp + 1 days; // Lock for 1 day\n    }\n\n    function withdraw() external {\n        require(block.timestamp > lockTime[msg.sender], \"Tokens are still locked!\");\n\n        uint256 amountToWithdraw = balances[msg.sender];\n\n        balances[msg.sender] = 0;\n        require(token.transfer(msg.sender, amountToWithdraw), \"Withdrawal failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_60",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract RewardDistributor {\n    IERC20 public token;\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public lastClaimed;\n    uint256 public totalStaked;\n    uint256 public rewardRate = 1e18; // 1 token per block per staked token\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function stake(uint256 amount) external {\n        require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        stakes[msg.sender] += amount;\n        totalStaked += amount;\n        lastClaimed[msg.sender] = block.number;\n    }\n\n    function claimRewards() external {\n        uint256 blocksSinceLastClaim = block.number - lastClaimed[msg.sender];\n        uint256 reward = stakes[msg.sender] * blocksSinceLastClaim * rewardRate;\n\n        lastClaimed[msg.sender] = block.number;\n        require(token.transfer(msg.sender, reward), \"Reward transfer failed\");\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_61",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract ReferralBonus {\n    mapping(address => uint256) public balances;\n\n    function deposit(uint256 amount, address referrer) external payable {\n        require(msg.value == amount, \"Sent amount mismatched!\");\n\n        balances[msg.sender] += amount;\n\n        if (referrer != address(0)) {\n            uint256 bonus = amount / 20; // 5% bonus\n            balances[referrer] += bonus;\n        }\n    }\n    \n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_62",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoanRepayment {\n    mapping(address => uint256) public principal;\n    mapping(address => uint256) public interest;\n    mapping(address => uint256) public loanStartDate;\n\n    function takeLoan(uint256 amount) external {\n        principal[msg.sender] = amount;\n        interest[msg.sender] = amount / 10; // 10% interest\n        loanStartDate[msg.sender] = block.timestamp;\n    }\n\n    function repay() external payable {\n        require(principal[msg.sender] > 0, \"No loan taken\");\n\n        uint256 totalInterest = interest[msg.sender];\n\n        if (block.timestamp - loanStartDate[msg.sender] <= 10 days) {\n            totalInterest -= totalInterest / 10;  // 10% discount on interest only\n        }\n\n        uint256 totalAmount = principal[msg.sender] + totalInterest;\n\n        require(msg.value == totalAmount, \"Incorrect repayment amount\");\n\n        principal[msg.sender] = 0;\n        interest[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_63",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract VotingSystem {\n    struct Candidate {\n        uint256 voteCount;\n        string name;\n    }\n    \n    mapping(address => uint256) public voterTokens;\n    mapping(uint256 => Candidate) public candidates;\n    uint256 public totalCandidates = 0;\n\n    function addCandidate(string memory _name) public {\n        candidates[totalCandidates] = Candidate(0, _name);\n        totalCandidates++;\n    }\n\n    function allocateVoterTokens(address voter, uint256 tokens) public {\n        voterTokens[voter] += tokens;\n    }\n\n    function castVote(uint256 candidateId, uint256 tokens) public {\n        require(voterTokens[msg.sender] >= tokens, \"Not enough tokens to vote\");\n        require(candidateId < totalCandidates, \"Invalid candidateId\");\n        \n        voterTokens[msg.sender] -= tokens;\n        candidates[candidateId].voteCount += tokens;\n    }\n    \n    function getCandidate(uint256 candidateId) public view returns(string memory, uint256) {\n        return (candidates[candidateId].name, candidates[candidateId].voteCount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_64",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract SimpleAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public refunds;\n\n    function placeBid(uint256 amount) public payable {\n        require(msg.value == amount, \"Sent amount mismatch\");\n        require(amount > highestBid, \"There already is a higher bid\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 previousHighestBid = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = amount;\n\n        if (previousHighestBidder != address(0)) {\n            refunds[previousHighestBidder] += previousHighestBid; \n        }\n    }\n\n    function withdrawRefund() public {\n        uint256 refundAmount = refunds[msg.sender];\n        refunds[msg.sender] = 0;\n        payable(msg.sender).transfer(refundAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_65",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract SimpleToken {\n    mapping(address => uint256) public balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 initialSupply) {\n        balances[msg.sender] = initialSupply;\n    }\n\n    function transfer(address to, uint256 amount) public returns(bool) {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        require(to != address(0), \"Invalid address\");\n\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_66",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Crowdsale {\n    uint256 public rate = 100;  // 100 tokens per ether\n    uint256 public totalTokens = 1000000;\n    mapping(address => uint256) public balances;\n\n    event Purchased(address indexed buyer, uint256 amount);\n\n    function buyTokens() public payable {\n        uint256 tokensToBuy = msg.value * rate;\n\n        require(tokensToBuy <= totalTokens, \"Not enough tokens left\");\n\n        totalTokens -= tokensToBuy;\n        balances[msg.sender] += tokensToBuy;\n\n        emit Purchased(msg.sender, tokensToBuy);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_67",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract VotingSystem {\n    struct Candidate {\n        string name;\n        uint256 voteCount;\n    }\n\n    Candidate[] public candidates;\n    mapping(address => bool) public hasVoted;\n\n    event Voted(address indexed voter, uint256 candidateId);\n\n    function addCandidate(string memory _name) public {\n        candidates.push(Candidate(_name, 0));\n    }\n\n    function vote(uint256 _candidateId) public {\n\n        require(!hasVoted[msg.sender], \"You have already voted\");\n        require(_candidateId < candidates.length, \"Invalid candidate\");\n\n        hasVoted[msg.sender] = true;\n        candidates[_candidateId].voteCount++;\n\n        emit Voted(msg.sender, _candidateId);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_68",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyStore {\n    struct Item {\n        string name;\n        uint256 price;\n    }\n\n    Item[] public items;\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public loyaltyPoints;\n\n    event Purchased(address indexed buyer, uint256 itemId);\n\n    function addItem(string memory _name, uint256 _price) public {\n        items.push(Item(_name, _price));\n    }\n\n    function purchaseItem(uint256 _itemId) public {\n        require(_itemId < items.length, \"Invalid item\");\n\n        uint256 price = items[_itemId].price;\n        \n        require(balances[msg.sender] >= price, \"Insufficient funds\");\n        balances[msg.sender] -= price;\n        \n        loyaltyPoints[msg.sender] += price;\n\n        emit Purchased(msg.sender, _itemId);\n    }\n\n    function addBalance(uint256 _amount) public {\n        balances[msg.sender] += _amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_69",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TimeReleaseToken {\n    mapping(address => uint256) public balances;\n    uint256 public releaseTime;\n\n    constructor(uint256 _releaseTime) {\n        releaseTime = _releaseTime;\n    }\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Must deposit a positive amount\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function claimTokens() public {\n        require(block.timestamp >= releaseTime, \"Tokens are not yet released\");\n        payable(msg.sender).transfer(balances[msg.sender]);\n\n        balances[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_70",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract VotingSystem {\n    mapping(address => uint256) public votes;\n    uint256 public votingEndTime;\n\n    event Voted(address indexed voter, uint256 amount);\n\n    constructor(uint256 _votingDuration) {\n        votingEndTime = block.timestamp + _votingDuration;\n    }\n\n    function castVote() public payable {\n        require(block.timestamp < votingEndTime, \"Voting has ended\");\n        \n        votes[msg.sender] += msg.value;\n        emit Voted(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        uint256 amount = votes[msg.sender];\n        votes[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_71",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IToken {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract TokenSale {\n    IToken public token;\n    uint256 public tokensSold;\n    uint256 constant BASE_PRICE = 1 ether;\n\n    constructor(address _tokenAddress) {\n        token = IToken(_tokenAddress);\n    }\n\n    function buyTokens() public payable {\n        uint256 tokensToMint = calculateTokensToMint(msg.value);\n        tokensSold += tokensToMint;\n\n        token.mint(msg.sender, tokensToMint);\n    }\n\n    function calculateTokensToMint(uint256 etherSent) public view returns (uint256) {\n        uint256 price = BASE_PRICE - (tokensSold / 1000);  // Example dynamic price calculation\n        return etherSent / price;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_72",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TokenSale {\n    uint256 public tokenPrice = 1 ether;  // Price per token\n    uint256 public totalTokens = 1000;\n    mapping(address => uint256) public tokensPurchased;\n\n    // Simulated Token Contract interface\n    interface IToken {\n        function transfer(address recipient, uint256 amount) external returns (bool);\n    }\n    IToken public tokenContract;\n\n    constructor(address _tokenContract) {\n        tokenContract = IToken(_tokenContract);\n    }\n\n    function buyTokens(uint256 numOfTokens) public payable {\n        require(msg.value == numOfTokens * tokenPrice, \"Incorrect Ether sent\");\n        require(totalTokens >= numOfTokens, \"Not enough tokens left for sale\");\n        \n        totalTokens -= numOfTokens;\n        tokensPurchased[msg.sender] += numOfTokens;\n\n        bool success = tokenContract.transfer(msg.sender, numOfTokens);\n        require(success, \"Token transfer failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_73",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract InterestBearingAccount {\n\n    struct Account {\n        uint256 deposit;\n        uint256 lastDepositTime;\n    }\n\n    uint256 public interestRate = 10;  // 10% per year\n    mapping(address => Account) public accounts;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit must be positive\");\n        \n        // Calculate and add interest for previous deposits\n        if (accounts[msg.sender].deposit > 0) {\n            uint256 timeDiff = block.timestamp - accounts[msg.sender].lastDepositTime;\n            uint256 interest = accounts[msg.sender].deposit * interestRate / 100 * timeDiff / 365 days;\n            accounts[msg.sender].deposit += interest;\n        }\n\n        accounts[msg.sender].deposit += msg.value;\n        accounts[msg.sender].lastDepositTime = block.timestamp;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(accounts[msg.sender].deposit >= amount, \"Insufficient balance\");\n        \n        accounts[msg.sender].deposit -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_74",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract FeeCollector {\n\n    uint256 public collectedFees;\n    address public owner;\n    uint256 public serviceFee = 0.01 ether;\n    uint256 public discount = 10; // 10% discount for the service fee\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    function payForService() public payable {\n        require(msg.value >= serviceFee, \"Fee too low\");\n\n        uint256 discountedFee = serviceFee * (100 - discount) / 100;\n        require(msg.value == discountedFee, \"Incorrect fee amount\");\n\n        collectedFees += msg.value;\n    }\n\n    function withdrawFees() public onlyOwner {\n        payable(owner).transfer(collectedFees);\n        collectedFees = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_75",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TokenSwap {\n    IToken public tokenA;\n    IToken public tokenB;\n\n    uint256 public rate; // Number of TokenB a user receives for 1 TokenA.\n    uint256 public feePercentage = 5; // 5% fee\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        tokenA = IToken(_tokenA);\n        tokenB = IToken(_tokenB);\n        rate = _rate;\n    }\n\n    function swap(uint256 amountA) public {\n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of TokenA failed\");\n\n        uint256 amountB = amountA * rate;\n        uint256 fee = amountB * feePercentage / 100;\n        uint256 netAmountB = amountB - fee;\n\n        require(tokenB.balanceOf(address(this)) >= netAmountB, \"Insufficient TokenB in contract\");\n        tokenB.transfer(msg.sender, netAmountB);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_76",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract SimpleBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n        \n        balances[msg.sender] -= amount;\n        \n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_77",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyReward {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n\n    event RewardDistributed(address user, uint256 amount);\n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n        totalSupply += amount;\n    }\n\n    function distributeReward(address user, uint256 totalReward) public {\n        totalSupply += totalReward;\n\n        uint256 userBalance = balances[user];\n        uint256 reward = (userBalance / totalSupply) * totalReward;\n        \n        balances[user] += reward;\n        emit RewardDistributed(user, reward);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_78",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract AuctionHouse {\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public lastBidBlock;\n    uint256 public blockDelay = 10;\n    \n    mapping(address => uint256) public pendingReturns;\n\n    event NewBid(address bidder, uint256 amount);\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Bid must be higher than current highest bid\");\n        require(block.number > lastBidBlock + blockDelay, \"The previous bid is still valid\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 previousHighestBid = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        lastBidBlock = block.number;\n\n        if (previousHighestBidder != address(0)) {\n            pendingReturns[previousHighestBidder] += previousHighestBid;\n        }\n\n        emit NewBid(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        uint256 amount = pendingReturns[msg.sender];\n        require(amount > 0, \"No funds to withdraw\");\n\n        pendingReturns[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_79",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenSwap {\n\n    function swapTokens(\n        IERC20 tokenA,\n        address sender,\n        uint256 amountA,\n        IERC20 tokenB,\n        address recipient,\n        uint256 amountB\n    ) external {\n        require(tokenA.transferFrom(sender, address(this), amountA), \"Token A transfer failed\");\n\n        require(tokenB.transfer(recipient, amountB), \"Token B transfer failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_80",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract EtherVault {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_81",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Auction {\n    address public owner;\n    uint256 public endTime;\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public bids;\n    bool internal locked = false; \n\n    constructor(uint256 _durationMinutes) {\n        owner = msg.sender;\n        endTime = block.timestamp + _durationMinutes * 1 minutes;\n    }\n\n    modifier nonReentrant() {\n        require(!locked, \"Reentrant call detected!\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function bid() external payable nonReentrant {\n        require(block.timestamp < endTime, \"Auction has ended\");\n        require(msg.value > highestBid, \"Bid is not high enough\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 refundAmount = highestBid;\n\n        bids[msg.sender] = msg.value;\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        if (previousHighestBidder != address(0)) {\n            payable(previousHighestBidder).transfer(refundAmount);\n        }\n    }\n\n    function finalize() external nonReentrant {\n        require(block.timestamp >= endTime, \"Auction not yet ended\");\n        require(msg.sender == owner, \"Only owner can finalize\");\n\n        payable(owner).transfer(highestBid);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_82",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract ArtTrade {\n    struct Artwork {\n        address artist;\n        address owner;\n        uint256 price;\n    }\n    \n    mapping(uint256 => Artwork) public artworks;\n\n    function mint(uint256 artId, uint256 price) external {\n        artworks[artId] = Artwork({\n            artist: msg.sender,\n            owner: msg.sender,\n            price: price\n        });\n    }\n\n    function buy(uint256 artId) external payable {\n        Artwork storage art = artworks[artId];\n        \n        require(msg.value >= art.price, \"Insufficient funds sent\");\n        \n        uint256 royalty = art.price / 10;\n        \n        art.owner = msg.sender;\n        uint256 previousPrice = art.price;\n        art.price = msg.value;\n\n        payable(art.artist).transfer(royalty);\n        payable(art.owner).transfer(previousPrice - royalty);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_83",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Crowdfunding {\n    struct Project {\n        address payable creator;\n        uint256 targetAmount;\n        uint256 totalPledged;\n        uint256 endTime;\n        bool fundsWithdrawn;\n        mapping(address => uint256) pledges;\n    }\n    \n    mapping(uint256 => Project) public projects;\n\n    function createProject(uint256 projectId, uint256 amount, uint256 duration) external {\n        projects[projectId] = Project({\n            creator: payable(msg.sender),\n            targetAmount: amount,\n            totalPledged: 0,\n            endTime: block.timestamp + duration,\n            fundsWithdrawn: false\n        });\n    }\n\n    function pledge(uint256 projectId) external payable {\n        Project storage proj = projects[projectId];\n        \n        require(block.timestamp < proj.endTime, \"Project funding time has ended\");\n        proj.pledges[msg.sender] += msg.value;\n        proj.totalPledged += msg.value;\n    }\n\n    function withdraw(uint256 projectId) external {\n        Project storage proj = projects[projectId];\n        \n        require(msg.sender == proj.creator, \"Only project creator can withdraw\");\n        require(block.timestamp < proj.endTime, \"Project funding time has ended\");\n        require(proj.totalPledged >= proj.targetAmount, \"Funding target not reached\");\n        require(!proj.fundsWithdrawn, \"Funds have been withdrawn\");\n\n        proj.fundsWithdrawn = true;\n        proj.creator.transfer(proj.totalPledged);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_84",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public endTime;\n\n    mapping(address => uint256) public pendingReturns;\n\n    constructor(uint256 _duration) {\n        endTime = block.timestamp + _duration;\n    }\n\n    function bid() external payable {\n        require(block.timestamp < endTime, \"Auction already ended\");\n        require(msg.value > highestBid, \"There already is a higher bid\");\n        \n        address previousHighestBidder = highestBidder;\n        uint256 previousHighestBid = highestBid;\n        \n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        \n        if (previousHighestBidder != address(0)) {\n            pendingReturns[previousHighestBidder] += previousHighestBid;\n        }\n    }\n\n    function withdraw() external {\n        uint256 amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            pendingReturns[msg.sender] = 0;\n            payable(msg.sender).transfer(amount);\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_85",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lottery {\n    address[] public participants;\n    uint256 public constant TICKET_PRICE = 1 ether;\n    uint256 public constant MAX_PARTICIPANTS = 10;\n    \n    function buyTicket() external payable {\n        require(msg.value == TICKET_PRICE, \"Must send exactly 1 Ether\");\n        participants.push(msg.sender);\n        \n        if (participants.length == MAX_PARTICIPANTS) {\n            uint256 winnerIndex = uint256(blockhash(block.number - 1)) % MAX_PARTICIPANTS;\n            address winner = participants[winnerIndex];\n            \n            delete participants;\n            \n            payable(winner).transfer(address(this).balance);\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_86",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Store {\n    address public owner;\n    uint256 public dailyLimit = 10 ether;\n    uint256 public withdrawnToday;\n    uint256 public lastWithdrawal;\n\n    mapping(address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function buyItem(uint256 itemPrice) external payable {\n        require(msg.value == itemPrice, \"Must send the correct Ether amount\");\n        balances[owner] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external onlyOwner {\n        require(balances[owner] >= amount, \"Insufficient funds\");\n\n        if (block.timestamp > lastWithdrawal + 1 days) {\n            withdrawnToday = 0;\n        }\n\n        require(withdrawnToday + amount <= dailyLimit, \"Exceeds daily withdrawal limit\");\n\n        withdrawnToday += amount;\n        lastWithdrawal = block.timestamp;\n\n        payable(owner).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_87",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lottery {\n    address public owner;\n    uint256 public ticketPrice = 1 ether;\n    address[] public players;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function buyTicket() external payable {\n        require(msg.value == ticketPrice, \"Ticket price is incorrect\");\n        players.push(msg.sender);\n    }\n\n    function drawWinner() external onlyOwner {\n        require(players.length > 0, \"No players in the lottery\");\n\n        address[] memory currentPlayers = players;\n        delete players;\n\n        address winner = currentPlayers[random() % currentPlayers.length];\n        payable(winner).transfer(address(this).balance);\n    }\n\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players.length)));\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_88",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Voting {\n    address public owner;\n    mapping(address => bool) public hasVoted;\n    mapping(bytes32 => uint256) public votes;\n    bytes32[] public candidates;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor(bytes32[] memory _candidates) {\n        owner = msg.sender;\n        candidates = _candidates;\n    }\n\n    function vote(bytes32 candidate) external {\n        require(!hasVoted[msg.sender], \"You have already voted\");\n\n        hasVoted[msg.sender] = true;\n\n        votes[candidate] += 1;\n    }\n\n    function getWinner() external view onlyOwner returns (bytes32) {\n        bytes32 winner;\n        uint256 highestVotes = 0;\n\n        for (uint i = 0; i < candidates.length; i++) {\n            if (votes[candidates[i]] > highestVotes) {\n                highestVotes = votes[candidates[i]];\n                winner = candidates[i];\n            }\n        }\n\n        return winner;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_89",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Crowdfund {\n    address public owner;\n    uint256 public targetAmount;\n    uint256 public endTime;\n    bool public targetMet = false;\n\n    mapping(address => uint256) public contributions;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor(uint256 _targetAmount, uint256 _durationInMinutes) {\n        owner = msg.sender;\n        targetAmount = _targetAmount;\n        endTime = block.timestamp + (_durationInMinutes * 1 minutes);\n    }\n\n    function contribute() external payable {\n        require(block.timestamp < endTime, \"Funding period is over\");\n        contributions[msg.sender] += msg.value;\n    }\n\n    function checkTargetReached() external {\n        require(block.timestamp >= endTime, \"Funding period is not yet over\");\n        if (address(this).balance >= targetAmount) {\n            targetMet = true;\n        }\n    }\n\n    function withdraw() external {\n        require(block.timestamp >= endTime, \"Funding period is not yet over\");\n        uint256 amount = contributions[msg.sender];\n\n        if (!targetMet) {\n            require(amount > 0, \"No funds to withdraw\");\n            contributions[msg.sender] = 0; \n            payable(msg.sender).transfer(amount);\n        } else if (msg.sender == owner) {\n            payable(owner).transfer(address(this).balance);\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_90",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    address public owner;\n    struct Item {\n        uint256 id;\n        string name;\n        uint256 price;\n        address payable seller;\n        bool sold;\n    }\n\n    mapping(uint256 => Item) public items;\n    uint256 public itemCount;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function listItem(string memory _name, uint256 _price) external {\n        itemCount++;\n        items[itemCount] = Item(itemCount, _name, _price, payable(msg.sender), false);\n    }\n\n    function buyItem(uint256 _itemId) external payable {\n        require(items[_itemId].price == msg.value, \"Incorrect Ether sent\");\n        require(!items[_itemId].sold, \"Item already sold\");\n\n        items[_itemId].sold = true;\n        items[_itemId].seller.transfer(msg.value);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_91",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract SavingsAccount {\n    struct Account {\n        uint256 balance;\n        uint256 lastDepositTime;\n    }\n\n    mapping(address => Account) public accounts;\n    uint256 public constant INTEREST_RATE = 5; // Example interest rate: 5%\n\n    function deposit() external payable {\n        require(msg.value > 0, \"Deposit must be greater than 0\");\n\n        accounts[msg.sender].balance += msg.value;\n        accounts[msg.sender].lastDepositTime = block.timestamp;\n    }\n\n    function withdraw() external {\n        uint256 timeDiff = block.timestamp - accounts[msg.sender].lastDepositTime;\n        uint256 interest = (accounts[msg.sender].balance * INTEREST_RATE / 100) * timeDiff / (365 days);\n        uint256 totalWithdraw = accounts[msg.sender].balance + interest;\n\n        accounts[msg.sender].balance = 0; \n        accounts[msg.sender].lastDepositTime = block.timestamp; \n\n        payable(msg.sender).transfer(totalWithdraw);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_92",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    struct Item {\n        address payable seller;\n        uint256 price;\n        bool isSold;\n    }\n\n    mapping(uint256 => Item) public items;\n    uint256 public nextItemId = 1;\n\n    function listItem(uint256 price) external {\n        items[nextItemId] = Item({\n            seller: payable(msg.sender),\n            price: price,\n            isSold: false\n        });\n        nextItemId++;\n    }\n\n    function buyItem(uint256 itemId) external payable {\n        Item storage item = items[itemId];\n        require(!item.isSold, \"Item already sold.\");\n        require(msg.value == item.price, \"Incorrect amount sent.\");\n\n        item.isSold = true; \n        item.seller.transfer(msg.value);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_93",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lending {\n    address public owner = msg.sender;\n    uint256 public interestRate = 10; // in percentage\n\n    struct User {\n        uint256 deposit;\n        uint256 loan;\n    }\n\n    mapping(address => User) public users;\n\n    function depositFunds(uint256 amount) external payable {\n        require(msg.value == amount, \"Sent amount mismatch\");\n        users[msg.sender].deposit += amount;\n    }\n\n    function borrow(uint256 amount) external {\n        require(users[msg.sender].deposit >= amount, \"Insufficient deposit to borrow\");\n        users[msg.sender].loan += amount;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function repayLoan(uint256 amount) external payable {\n        uint256 interest = (users[msg.sender].loan * interestRate) / 100;\n        require(msg.value == users[msg.sender].loan + interest, \"Must repay loan with interest\");\n        \n        users[msg.sender].loan = 0; \n        payable(owner).transfer(interest);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_94",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TicketingSystem {\n    address public owner = msg.sender;\n    uint256 public ticketPrice = 1 ether;\n    uint256 public discountPercent = 10;\n\n    mapping(address => uint256) public ticketsBought;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can execute this\");\n        _;\n    }\n\n    function setDiscountPercent(uint256 _discount) external onlyOwner {\n        discountPercent = _discount;\n    }\n\n    function buyTickets(uint256 numTickets) external payable {\n        uint256 totalCostWithoutDiscount = ticketPrice * numTickets;\n        uint256 discountAmount = (totalCostWithoutDiscount * discountPercent) / 100;  \n        uint256 totalCost = totalCostWithoutDiscount - discountAmount;\n\n        require(msg.value >= totalCost, \"Insufficient Ether provided.\");\n        ticketsBought[msg.sender] += numTickets;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_95",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract CrowdFunding {\n    address public owner;\n    uint256 public fundingGoal;\n    uint256 public totalDonated;\n    bool public fundsWithdrawn = false; \n\n    constructor(uint256 _fundingGoal) {\n        owner = msg.sender;\n        fundingGoal = _fundingGoal;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can execute this\");\n        _;\n    }\n\n    function donate() external payable {\n        totalDonated += msg.value;\n    }\n\n    function withdraw() external onlyOwner {\n        require(!fundsWithdrawn, \"Funds have already been withdrawn.\"); \n        require(totalDonated >= fundingGoal, \"Funding goal not reached yet.\");\n        \n        fundsWithdrawn = true;\n        uint256 toTransfer = totalDonated;\n        totalDonated = 0;\n        payable(owner).transfer(toTransfer);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_96",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract VotingSystem {\n    struct Topic {\n        string description;\n        uint256 yesCount;\n        uint256 noCount;\n    }\n    \n    mapping(uint256 => Topic) public topics;\n    mapping(uint256 => mapping(address => bool)) public hasVoted;\n\n    function createTopic(string calldata description) external returns (uint256) {\n        uint256 topicId = block.timestamp;\n        topics[topicId] = Topic(description, 0, 0);\n        return topicId;\n    }\n\n    function vote(uint256 topicId, bool voteYes) external {\n        require(!hasVoted[topicId][msg.sender], \"You've already voted on this topic.\");\n        \n       \n        hasVoted[topicId][msg.sender] = true;\n        \n        if (voteYes) {\n            topics[topicId].yesCount++;\n        } else {\n            topics[topicId].noCount++;\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_97",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TicketSale {\n    uint256 public totalTickets = 1000;\n    uint256 public ticketsSold = 0;\n    uint256 public ticketPrice = 1 ether;\n    mapping(address => uint256) public ticketsBought;\n\n    function buyTickets(uint256 amount) external payable {\n        require(msg.value == ticketPrice * amount, \"Incorrect Ether sent.\");\n        \n        require(ticketsSold + amount <= totalTickets, \"Not enough tickets available.\");\n\n        ticketsSold += amount; \n        ticketsBought[msg.sender] += amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_98",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract CharityDonation {\n    uint256 public donationGoal = 50 ether;\n    uint256 public totalDonations = 0;\n    bool public goalMet = false;\n\n    function donate() external payable {\n        require(totalDonations + msg.value <= donationGoal, \"Donation exceeds goal amount.\");\n\n        totalDonations += msg.value; \n\n        if (totalDonations == donationGoal) {\n            goalMet = true;\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_99",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract CrowdfundProject {\n    uint256 public targetAmount = 100 ether;\n    uint256 public totalRaised = 0;\n    uint256 public deadline = block.timestamp + 7 days;\n    bool public fundingClosed = false;\n    mapping(address => uint256) public contributions;\n\n    function contribute() external payable {\n        require(block.timestamp < deadline, \"Contribution period has ended.\");\n        require(totalRaised + msg.value <= targetAmount, \"This contribution would exceed the target amount.\");\n\n        contributions[msg.sender] += msg.value;\n        totalRaised += msg.value;\n\n        if (totalRaised == targetAmount) {\n            fundingClosed = true;\n        }\n    }\n\n    function reclaimFunds() external {\n        require(block.timestamp > deadline && totalRaised < targetAmount, \"Cannot reclaim funds now.\");\n        uint256 amount = contributions[msg.sender];\n        contributions[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_100",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract AuctionHouse {\n    \n    struct Auction {\n        address payable seller;\n        uint256 startingPrice;\n        uint256 highestBid;\n        address payable highestBidder;\n        bool ended;\n    }\n    \n    mapping(uint256 => Auction) public auctions;\n    uint256 public auctionCount = 0;\n\n    function createAuction(uint256 _startingPrice) external {\n        auctions[auctionCount] = Auction({\n            seller: payable(msg.sender),\n            startingPrice: _startingPrice,\n            highestBid: 0,\n            highestBidder: payable(address(0)),\n            ended: false\n        });\n        auctionCount++;\n    }\n\n    function bid(uint256 auctionId) external payable {\n        Auction storage auction = auctions[auctionId];\n        require(!auction.ended, \"Auction already ended.\");\n        require(msg.value > auction.highestBid, \"There already is a higher bid.\");\n        \n        address payable previousHighestBidder = auction.highestBidder;\n        uint256 refundAmount = auction.highestBid;\n\n        auction.highestBid = msg.value;\n        auction.highestBidder = payable(msg.sender);\n\n        if (previousHighestBidder != address(0)) {\n            // Refund the previous highest bidder after updating state\n            previousHighestBidder.transfer(refundAmount); \n        }\n    }\n\n    function endAuction(uint256 auctionId) external {\n        Auction storage auction = auctions[auctionId];\n        require(msg.sender == auction.seller, \"Only the seller can end the auction.\");\n        require(!auction.ended, \"Auction already ended.\");\n\n        auction.ended = true;\n        auction.seller.transfer(auction.highestBid);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_101",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenSwap {\n\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n    uint256 public rate;\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        tokenA = IERC20(_tokenA);\n        tokenB = IERC20(_tokenB);\n        rate = _rate;\n    }\n\n    function swapAforB(uint256 amountA) external {\n        uint256 amountB = rate * amountA;\n\n        address tempSender = msg.sender;\n\n        require(tokenA.transferFrom(tempSender, address(this), amountA), \"Transfer of tokenA failed\");\n        require(tokenB.transfer(tempSender, amountB), \"Transfer of tokenB failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_102",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract TokenStaking {\n\n    IERC20 public token;\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public stakingTime;\n    uint256 public interestRate = 5;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function stakeTokens(uint256 amount) external {\n        require(amount > 0, \"Amount should be positive\");\n        require(token.transferFrom(msg.sender, address(this), amount), \"Token staking failed\");\n        \n        stakes[msg.sender] += amount;\n        stakingTime[msg.sender] = block.timestamp;\n    }\n\n    function withdrawStake() external {\n        require(stakes[msg.sender] > 0, \"No tokens staked\");\n\n        uint256 elapsedTime = block.timestamp - stakingTime[msg.sender];\n        uint256 interest = (stakes[msg.sender] * interestRate / 100) * (elapsedTime / 365 days);\n        \n        uint256 totalAmount = stakes[msg.sender] + interest;\n\n        stakes[msg.sender] = 0;\n        \n        require(token.transfer(msg.sender, totalAmount), \"Token withdrawal failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_103",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    struct Product {\n        uint256 id;\n        address payable owner;\n        uint256 price;\n        bool isListed;\n    }\n\n    mapping(uint256 => Product) public products;\n    uint256 public productCount = 0;\n\n    function listProduct(uint256 price) external {\n        productCount++;\n        products[productCount] = Product(productCount, payable(msg.sender), price, true);\n    }\n\n    function purchaseProduct(uint256 productId) external payable {\n        Product memory product = products[productId];\n\n        require(product.isListed, \"Product not listed\");\n        require(msg.value == product.price, \"Incorrect amount sent\");\n\n        products[productId].isListed = false;\n        \n        product.owner.transfer(msg.value);\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_104",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Voting {\n    struct Proposal {\n        uint256 id;\n        string name;\n        uint256 votes;\n        mapping(address => uint256) votesByAddress;\n    }\n\n    mapping(uint256 => Proposal) public proposals;\n    uint256 public proposalCount = 0;\n    mapping(address => uint256) public stakedEther;\n\n    function createProposal(string memory name) external {\n        proposalCount++;\n        proposals[proposalCount] = Proposal(proposalCount, name, 0);\n    }\n\n    function stakeAndVote(uint256 proposalId) external payable {\n        require(proposals[proposalId].id != 0, \"Proposal does not exist\");\n        \n        stakedEther[msg.sender] += msg.value;\n\n        proposals[proposalId].votes += msg.value;\n        proposals[proposalId].votesByAddress[msg.sender] += msg.value;\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_105",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Stake {\n    mapping(address => uint256) public userStakes;\n    mapping(address => uint256) public userInterest;\n\n    // Interest rate is 10%\n    uint256 constant INTEREST_RATE = 10;\n\n    function stake() external payable {\n        userInterest[msg.sender] += userStakes[msg.sender] * INTEREST_RATE / 100;\n        userStakes[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint256 totalAmount = userStakes[msg.sender] + userInterest[msg.sender];\n        require(totalAmount > 0, \"No funds to withdraw\");\n\n        payable(msg.sender).transfer(totalAmount);\n\n        userStakes[msg.sender] = 0;\n        userInterest[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_106",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Marketplace {\n    struct Product {\n        uint256 price;\n        address payable seller;\n        address payable buyer;\n        bool isSold;\n    }\n\n    mapping(uint256 => Product) public products; // productID => Product\n\n    function listProduct(uint256 _productID, uint256 _price) external {\n        require(products[_productID].price == 0, \"Product already listed.\");\n\n        products[_productID] = Product({\n            price: _price,\n            seller: payable(msg.sender),\n            buyer: payable(address(0)),\n            isSold: false\n        });\n    }\n\n    function purchaseProduct(uint256 _productID) external payable {\n        Product storage product = products[_productID];\n        require(msg.value == product.price, \"Incorrect payment.\");\n        require(!product.isSold, \"Product already sold.\");\n\n        address payable originalSeller = product.seller;\n        \n        product.buyer = payable(msg.sender);\n        product.isSold = true;\n\n        originalSeller.transfer(msg.value);\n    }\n\n    // Additional functions...\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_107",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Staking {\n    mapping(address => uint256) public balances; \n    mapping(address => uint256) public rewards; \n    \n    uint256 public totalStaked = 0;\n    uint256 constant REWARD_PER_ETHER = 100; // Suppose every Ether staked earns 100 tokens.\n\n    function stake() external payable {\n        balances[msg.sender] += msg.value;\n        rewards[msg.sender] += msg.value * REWARD_PER_ETHER;\n        totalStaked += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient staked balance.\");\n\n        balances[msg.sender] -= amount;\n        uint256 reward = rewards[msg.sender];\n        rewards[msg.sender] = 0;\n\n        uint256 totalAmount = amount + reward;\n        \n        payable(msg.sender).transfer(totalAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_108",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Lottery {\n    address payable public owner;\n    address payable[] public participants;\n    uint256 public ticketPrice = 1 ether;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function buyTicket() external payable {\n        require(msg.value == ticketPrice, \"Incorrect Ether sent.\");\n\n        participants.push(payable(msg.sender));\n    }\n\n    function distributeFunds() external {\n        require(msg.sender == owner, \"Only the owner can distribute funds.\");\n        require(participants.length > 0, \"No participants in the lottery.\");\n\n        uint256 prize = address(this).balance * 90 / 100;\n        uint256 ownerShare = address(this).balance - prize;\n\n        owner.transfer(ownerShare);\n\n        uint256 randomIndex = (block.timestamp + block.difficulty) % participants.length;\n        participants[randomIndex].transfer(prize);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_109",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Wallet {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient funds.\");\n\n        balances[msg.sender] -= _amount;\n\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_110",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Bank {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient funds!\");\n\n        balances[msg.sender] -= _amount;\n\n        payable(msg.sender).transfer(_amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_111",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Bank {\n    mapping(address => uint256) public balances;\n    uint256 public totalBalance;\n    bool public withdrawalsPaused;\n\n    uint256 public threshold = 1 ether;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        totalBalance += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!withdrawalsPaused, \"Withdrawals are currently paused.\");\n        require(balances[msg.sender] >= amount, \"Insufficient funds.\");\n\n        balances[msg.sender] -= amount;\n        totalBalance -= amount;\n\n        if (totalBalance < threshold) {\n            withdrawalsPaused = true;\n        }\n\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_112",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  TokenSale {\n    uint256 public tokensSold;\n    uint256 public constant RATE = 100;  // Number of tokens per ether\n    uint256 public constant START_BONUS = 50;  // Starting bonus for early adopters\n\n    mapping(address => uint256) public balances;\n\n    function buyTokens() external payable {\n        uint256 tokensWithoutBonus = msg.value * RATE;\n        uint256 bonus = (START_BONUS - tokensSold) > 0 ? (START_BONUS - tokensSold) : 0;\n\n        tokensSold += tokensWithoutBonus;\n        \n        uint256 totalTokens = tokensWithoutBonus + bonus;\n        balances[msg.sender] += totalTokens;\n    }\n\n    // ... rest of the contract\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_113",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Pledge {\n    address public owner;\n    uint256 public constant FEE_PERCENTAGE = 5;  // 5% fee on every withdrawal\n\n    mapping(address => uint256) public pledges;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function pledge() external payable {\n        pledges[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint256 fee = pledges[msg.sender] * FEE_PERCENTAGE / 100;\n        uint256 amountToWithdraw = pledges[msg.sender] - fee; \n        \n        payable(owner).transfer(fee);\n        payable(msg.sender).transfer(amountToWithdraw);\n        \n        pledges[msg.sender] = 0;\n    }\n\n    // ... rest of the contract\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_114",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  ArtAuction {\n    address public owner;\n\n    struct Artwork {\n        uint256 currentBid;\n        address highestBidder;\n        uint256 endTimestamp;\n    }\n\n    mapping(uint256 => Artwork) public artworks;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function listArtwork(uint256 _artworkId, uint256 _duration) external {\n        artworks[_artworkId] = Artwork({\n            currentBid: 0,\n            highestBidder: address(0),\n            endTimestamp: block.timestamp + _duration\n        });\n    }\n\n    function bid(uint256 _artworkId) external payable {\n        require(artworks[_artworkId].endTimestamp > block.timestamp, \"Auction ended\");\n        require(msg.value > artworks[_artworkId].currentBid, \"Bid too low\");\n        \n        address previousBidder = artworks[_artworkId].highestBidder;\n        uint256 previousBid = artworks[_artworkId].currentBid;\n\n        artworks[_artworkId].currentBid = msg.value;\n        artworks[_artworkId].highestBidder = msg.sender;\n\n        payable(previousBidder).transfer(previousBid);\n    }\n\n    // ... rest of the contract\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_115",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Bank {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint256 amountToWithdraw = balances[msg.sender];\n        require(amountToWithdraw > 0, \"Insufficient funds.\");\n        \n        balances[msg.sender] = 0; \n\n        (bool success, ) = msg.sender.call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_116",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Lottery {\n    mapping(address => uint256) public tickets;\n    uint256 public totalTickets = 0;\n    uint256 public prizePool = 0;\n\n    uint256 constant TICKET_PRICE = 1 ether;\n\n    function buyTickets(uint256 numTickets) external payable {\n        require(msg.value == numTickets * TICKET_PRICE, \"Incorrect payment.\");\n\n        tickets[msg.sender] += numTickets;\n        totalTickets += numTickets;\n        prizePool += msg.value;\n    }\n\n    function claimPrize() external {\n        require(totalTickets > 0, \"No tickets sold.\");\n\n        uint256 prizeAmount = (tickets[msg.sender] * prizePool) / totalTickets; \n        prizePool -= prizeAmount;\n        tickets[msg.sender] = 0;\n\n        payable(msg.sender).transfer(prizeAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_117",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public pendingReturns;\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"There already is a higher bid.\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 previousHighestBid = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        if (previousHighestBidder != address(0)) {\n            pendingReturns[previousHighestBidder] += previousHighestBid; \n        }\n    }\n\n    function withdraw() external {\n        uint256 amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            pendingReturns[msg.sender] = 0;\n\n            (bool success,) = msg.sender.call{value: amount}(\"\");\n            require(success, \"Transfer failed.\");\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_118",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Marketplace {\n    struct Product {\n        uint256 price;\n        uint256 stock;\n    }\n\n    mapping(uint256 => Product) public products;\n    mapping(address => uint256) public sellerBalances;\n\n    function addProduct(uint256 productId, uint256 price, uint256 stock) external {\n        products[productId] = Product({price: price, stock: stock});\n    }\n\n    function purchaseProduct(uint256 productId) external payable {\n        require(products[productId].stock > 0, \"Out of stock.\");\n        require(msg.value >= products[productId].price, \"Insufficient ether sent.\");\n\n        uint256 refund = msg.value - products[productId].price;\n        \n        products[productId].stock--; \n        sellerBalances[msg.sender] += products[productId].price; \n\n        if (refund > 0) {\n            (bool success,) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Refund failed.\");\n        }\n    }\n\n    function withdrawBalance() external {\n        uint256 amount = sellerBalances[msg.sender];\n        require(amount > 0, \"No balance available.\");\n        sellerBalances[msg.sender] = 0;\n        (bool success,) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Withdrawal failed.\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_119",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Lottery {\n    address[] public players;\n    address public owner;\n    uint256 public constant TICKET_PRICE = 1 ether;\n    uint256 public constant MAX_PLAYERS = 3;\n    bytes32 private lastBlockHash;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function buyTicket() external payable {\n        require(msg.value == TICKET_PRICE, \"Send exact ticket price.\");\n        require(players.length < MAX_PLAYERS, \"Maximum players reached.\");\n\n        players.push(msg.sender);\n\n        if (players.length == MAX_PLAYERS) {\n            _selectWinner();\n        }\n    }\n\n    function _selectWinner() private {\n     \n        lastBlockHash = blockhash(block.number - 1);\n        uint256 random = uint256(keccak256(abi.encodePacked(lastBlockHash))) % players.length;\n        address winner = players[random];\n        payable(winner).transfer(address(this).balance);\n        delete players;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_120",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IToken {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract  TokenSale {\n    IToken public token;\n    address public owner;\n    uint256 public constant TOKEN_PRICE = 1 ether;\n    uint256 public tokensSold;\n    uint256 public etherRaised;\n\n    constructor(address _token) {\n        owner = msg.sender;\n        token = IToken(_token);\n    }\n\n    function buyTokens(uint256 amount) external payable {\n        require(msg.value == TOKEN_PRICE * amount, \"Incorrect Ether sent.\");\n        require(etherRaised + msg.value > etherRaised, \"Overflow detected.\");  // Check for overflows\n\n        tokensSold += amount;\n        etherRaised += msg.value; \n\n        token.mint(msg.sender, amount);\n    }\n\n    function endSale() external {\n        require(msg.sender == owner, \"Only the owner can end the sale.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_121",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Donation {\n    address public owner;\n    uint256 public totalDonations;\n    uint256 public donationLimit = 100 ether;\n    bool internal locked = false;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function donate() public payable {\n        require(totalDonations + msg.value <= donationLimit, \"Donation limit reached.\");\n        totalDonations += msg.value;\n    }\n\n    function withdraw() public {\n        require(msg.sender == owner, \"Only owner can withdraw.\");\n        require(!locked, \"Reentrant call detected!\");\n\n        locked = true;\n        uint256 amount = address(this).balance;\n        payable(owner).transfer(amount);\n        locked = false;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_122",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Crowdfunding {\n    address public creator;\n    uint256 public goal;\n    uint256 public totalContributed;\n    bool public goalReached = false;\n\n    mapping(address => uint256) public contributions;\n\n    constructor(uint256 _goal) {\n        creator = msg.sender;\n        goal = _goal;\n    }\n\n    function contribute() public payable {\n        require(!goalReached, \"Goal has been reached. No more contributions allowed.\");\n        \n        contributions[msg.sender] += msg.value;\n        totalContributed += msg.value;\n\n        if(totalContributed >= goal) {\n            goalReached = true;\n        }\n    }\n\n    function withdraw() public {\n        require(msg.sender == creator, \"Only the creator can withdraw.\");\n        require(goalReached, \"Goal not reached yet.\");\n\n        payable(creator).transfer(address(this).balance);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_123",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Lottery {\n    address public manager;\n    address[] public players;\n    address public lastWinner;\n\n    constructor() {\n        manager = msg.sender;\n    }\n\n    function enter() public payable {\n        require(msg.value > 0.01 ether, \"Minimum ether not sent!\");\n\n        payable(address(this)).transfer(msg.value); \n        players.push(msg.sender); \n    }\n\n    function pickWinner() public restricted {\n        uint index = random() % players.length;\n        lastWinner = players[index];\n\n        payable(lastWinner).transfer(address(this).balance);  \n        players = new address[](0); \n\n    modifier restricted() {\n        require(msg.sender == manager, \"Only manager can call this.\");\n        _;\n    }\n\n    function random() private view returns(uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players)));\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_124",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Marketplace {\n    struct Item {\n        string name;\n        uint256 price;\n        address seller;\n    }\n    \n    mapping(uint256 => Item) public items;\n    uint256 public itemCount = 0;\n\n    function listNewItem(string memory _name, uint256 _price) public {\n        items[itemCount + 1] = Item(_name, _price, msg.sender)\n        itemCount++; \n    }\n\n    function purchaseItem(uint256 _itemId) public payable {\n        Item memory item = items[_itemId];\n        require(msg.sender != item.seller, \"Seller can't purchase their own item.\");\n        require(msg.value == item.price, \"Incorrect amount transferred.\");\n\n        payable(item.seller).transfer(item.price); \n        delete items[_itemId]; \n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_125",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function.\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"There already is a higher bid.\");\n\n        address previousHighestBidder = highestBidder;  \n        uint256 refundAmount = highestBid; \n\n        payable(previousHighestBidder).transfer(refundAmount);  \n\n        highestBidder = msg.sender;  \n        highestBid = msg.value;     \n    }\n\n    function endAuction() public onlyOwner {\n        uint256 finalBid = highestBid;  \n        highestBid = 0;  \n\n        payable(owner).transfer(finalBid);  \n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_126",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Token {\n    mapping(address => uint256) public balances;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function.\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transfer(address to, uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n        \n        balances[msg.sender] -= amount;        \n        balances[to] += amount;               \n    }\n\n    function mint(uint256 amount) public onlyOwner {\n        balances[owner] += amount;           \n        owner = msg.sender;                   \n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_127",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract  DEX {\n    IERC20 public token;\n    uint256 public tokenPrice;  // Price of the token in wei\n\n    constructor(address _token, uint256 _initialPrice) {\n        token = IERC20(_token);\n        tokenPrice = _initialPrice;\n    }\n\n    function buyTokens(uint256 tokenAmount) public payable {\n        uint256 cost = tokenAmount * tokenPrice;\n        require(msg.value >= cost, \"Insufficient ETH sent.\");\n        \n        token.transfer(msg.sender, tokenAmount);\n        \n        tokenPrice = adjustPrice(); \n    }\n\n    function adjustPrice() internal returns (uint256) {\n     \n        uint256 tokenBalance = token.balanceOf(address(this));\n        if(tokenBalance < 1000 * 10**18) {\n            return tokenPrice * 2; // Double the price if fewer tokens\n        } else {\n            return tokenPrice;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_128",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Lottery {\n    address[] public participants;\n    address public owner;\n    uint256 public ticketPrice = 1 ether;\n    uint256 public maxTickets = 10;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function buyTicket() public payable {\n        require(msg.value == ticketPrice, \"Incorrect ticket price.\");\n        require(participants.length < maxTickets, \"Max tickets reached.\");\n        \n        participants.push(msg.sender);\n\n        if(participants.length == maxTickets) {\n            address winner = participants[random() % participants.length];\n            payable(winner).transfer(address(this).balance);\n            \n            // Reset participants after transferring the balance.\n            delete participants;\n        }\n    }\n    \n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, participants)));\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_129",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Voting {\n    struct Voter {\n        uint256 tokensBought;\n        uint256 votesCast;\n    }\n    \n    mapping(address => Voter) public voters;\n    mapping(string => uint256) public candidates;\n    \n    uint256 public tokenPrice = 1 ether;\n    \n    function buyTokens(uint256 amount) public payable {\n        require(msg.value == amount * tokenPrice, \"Incorrect Ether sent.\");\n\n        voters[msg.sender].tokensBought += amount;\n    }\n\n    function voteForCandidate(string memory candidateName, uint256 votes) public {\n        Voter storage voter = voters[msg.sender];\n\n        require(voter.votesCast + votes <= voter.tokensBought, \"Not enough tokens to cast votes.\");\n\n        voter.votesCast += votes;\n\n        candidates[candidateName] += votes;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_130",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Bank {\n    struct Account {\n        uint256 depositAmount;\n        uint256 depositTime;\n    }\n\n    mapping(address => Account) public accounts;\n    uint256 public interestRate = 10; // 10%\n\n    function deposit() public payable {\n        Account storage userAccount = accounts[msg.sender];\n        \n        uint256 timeSinceLastDeposit = block.timestamp - userAccount.depositTime;\n        if (timeSinceLastDeposit > 1 weeks) {\n            uint256 interest = (userAccount.depositAmount * interestRate) / 100;\n            userAccount.depositAmount += interest;\n        }\n        \n        userAccount.depositAmount += msg.value;\n        userAccount.depositTime = block.timestamp;\n    }\n\n    function withdraw() public {\n        Account storage userAccount = accounts[msg.sender];\n        require(userAccount.depositAmount > 0, \"No funds to withdraw.\");\n        \n        uint256 amount = userAccount.depositAmount;\n        userAccount.depositAmount = 0;\n        \n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_131",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenExchange {\n    mapping(address => uint256) public balances;\n    uint256 public exchangeRate = 2; // 1 ETH = 2 Tokens\n\n    function deposit() public payable {\n        uint256 tokens = msg.value * exchangeRate;\n\n        if (msg.value > 1 ether) {\n            uint256 bonus = (msg.value * exchangeRate) / 10;  // 10% bonus for deposits over 1 ether\n            tokens += bonus;\n        }\n\n        balances[msg.sender] += tokens;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount / exchangeRate);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_132",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenSwap {\n    mapping(address => uint256) public tokenA;\n    mapping(address => uint256) public tokenB;\n\n    uint256 public rateTokenAToB = 100;  // 1 Token A = 100 Token B\n\n    function depositTokenA(uint256 amount) public {\n        tokenA[msg.sender] += amount;\n    }\n\n    function depositTokenB(uint256 amount) public {\n        tokenB[msg.sender] += amount;\n    }\n\n    function swapAToB(uint256 amountA) public {\n        require(tokenA[msg.sender] >= amountA, \"Insufficient Token A balance\");\n\n        uint256 amountB = amountA * rateTokenAToB;\n        .\n        require(amountB / rateTokenAToB == amountA, \"Swap calculation error\");\n\n        tokenA[msg.sender] -= amountA;\n        tokenB[msg.sender] += amountB;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_133",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  VotingSystem {\n\n    struct Candidate {\n        string name;\n        uint256 votes;\n    }\n\n    mapping(address => uint256) public tokenBalances;\n    mapping(address => bool) public hasVoted;\n    mapping(address => uint256) public lockedTokensOnVote;\n\n    Candidate[] public candidates;\n\n    interface IToken {\n        function transfer(address to, uint256 amount) external;\n        function balanceOf(address account) external view returns (uint256);\n    }\n\n    IToken public token;\n\n    constructor(address _tokenAddress) {\n        token = IToken(_tokenAddress);\n    }\n\n    function addCandidate(string memory name) public {\n        candidates.push(Candidate({name: name, votes: 0}));\n    }\n\n    function vote(uint256 candidateIndex) public {\n        require(!hasVoted[msg.sender], \"Already voted!\");\n        uint256 balance = token.balanceOf(msg.sender);\n        \n        token.transfer(address(this), balance);\n        \n        candidates[candidateIndex].votes += balance;\n        lockedTokensOnVote[msg.sender] = balance;\n        hasVoted[msg.sender] = true;\n    }\n\n    function withdraw() public {\n        require(hasVoted[msg.sender], \"You haven't voted yet!\");\n        token.transfer(msg.sender, lockedTokensOnVote[msg.sender]);\n        lockedTokensOnVote[msg.sender] = 0;\n        hasVoted[msg.sender] = false;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_134",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public auctionEndTime;\n\n    mapping(address => uint256) public pendingReturns;\n\n    event HighestBidIncreased(address bidder, uint256 amount);\n\n    constructor(uint256 _biddingTime) {\n        auctionEndTime = block.timestamp + _biddingTime;\n    }\n\n    function bid() public payable {\n        require(block.timestamp <= auctionEndTime, \"Auction has ended.\");\n\n        require(msg.value > highestBid, \"There is a higher bid already.\");\n\n        if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;  \n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        \n        emit HighestBidIncreased(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        uint256 amount = pendingReturns[msg.sender];\n        require(amount > 0, \"No amount to withdraw.\");\n\n        pendingReturns[msg.sender] = 0; \n\n        address payable recipient = payable(msg.sender);\n        recipient.transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_135",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Token {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n\n    event Minted(address indexed to, uint256 amount);\n    event Transferred(address indexed from, address indexed to, uint256 amount);\n\n    function mint(uint256 amount) public {\n        balances[msg.sender] += amount;\n        totalSupply += amount;\n        emit Minted(msg.sender, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n        require(to != msg.sender, \"Cannot transfer to self.\");\n\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n\n        emit Transferred(msg.sender, to, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_136",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n    mapping(address => uint256) public refunds;\n\n    event NewBid(address bidder, uint256 bid);\n    event Refunded(address bidder, uint256 amount);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Bid should be higher than current highest bid\");\n\n        if(highestBidder != address(0)) {\n            refunds[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        emit NewBid(msg.sender, msg.value);\n    }\n\n    function withdrawRefund() public {\n        uint256 refundAmount = refunds[msg.sender];\n        refunds[msg.sender] = 0;\n        payable(msg.sender).transfer(refundAmount);\n        emit Refunded(msg.sender, refundAmount);\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only owner can end the auction\");\n        payable(owner).transfer(highestBid);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_137",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Token {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    address public owner;\n    bool internal locked = false; \n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 _initialSupply) {\n        balances[msg.sender] = _initialSupply;\n        totalSupply = _initialSupply;\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        require(!locked, \"Reentrant call detected!\");\n        require(balances[msg.sender] >= _value, \"Insufficient balance\");\n\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value);\n\n        if (address(_to).isContract()) {\n            locked = true;  \n            _to.call(abi.encodeWithSignature(\"tokenFallback(address,uint256)\", msg.sender, _value));\n            locked = false; \n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_138",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenSale {\n    address payable public owner;\n    uint256 public tokensPerEther = 100;\n    uint256 public totalTokens = 10000;\n    bool internal locked = false;\n\n    mapping(address => uint256) public balanceOf;\n\n    constructor() {\n        owner = payable(msg.sender);\n        balanceOf[owner] = totalTokens;\n    }\n\n    modifier noReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function buyTokens() public payable noReentrant {\n        uint256 tokensToBuy = msg.value * tokensPerEther;\n        require(balanceOf[owner] >= tokensToBuy, \"Not enough tokens available.\");\n\n        balanceOf[msg.sender] += tokensToBuy;\n        balanceOf[owner] -= tokensToBuy;\n\n        owner.transfer(msg.value);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_139",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  LendingPlatform {\n    address public owner;\n    uint256 public totalLiquidity;\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public loanedAmounts;\n    bool internal inLoanFunction = false; \n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        totalLiquidity += msg.value; \n    }\n\n    function loanOut(address to, uint256 amount) public {\n        require(msg.sender == owner, \"Only owner can loan out.\");\n        require(totalLiquidity >= amount, \"Not enough liquidity.\");\n        require(!inLoanFunction, \"Reentrant call detected!\"); \n\n        inLoanFunction = true;\n        loanedAmounts[to] += amount;\n        totalLiquidity -= amount;\n        payable(to).transfer(amount); \n        inLoanFunction = false;\n    }\n\n    function repayLoan() public payable {\n        require(loanedAmounts[msg.sender] >= msg.value, \"Repaying more than loaned amount.\");\n        loanedAmounts[msg.sender] -= msg.value; \n        totalLiquidity += msg.value; \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_140",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract  TokenSwap {\n    address public owner;\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n    uint256 public rate; // Number of tokenB units a user gets for 1 unit of tokenA\n    bool private locked = false; \n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        owner = msg.sender;\n        tokenA = IERC20(_tokenA);\n        tokenB = IERC20(_tokenB);\n        rate = _rate;\n    }\n\n    modifier nonReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function swap(uint256 amount) public nonReentrant {\n        uint256 amountB = amount * rate;\n\n        require(tokenB.balanceOf(address(this)) >= amountB, \"Not enough tokenB in the contract.\");\n        require(tokenA.transferFrom(msg.sender, address(this), amount), \"Transfer of tokenA failed.\");\n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of tokenB failed.\");\n    }\n\n    function updateRate(uint256 _rate) public nonReentrant {\n        require(msg.sender == owner, \"Only owner can update the rate.\");\n        require(_rate != rate, \"New rate is the same as the old one.\");\n        rate = _rate;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_141",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract  LoanContract {\n    address public owner;\n    IERC20 public loanToken;\n    uint256 public rate;\n    bool private locked = false; \n\n    constructor(address _loanToken, uint256 _rate) {\n        owner = msg.sender;\n        loanToken = IERC20(_loanToken);\n        rate = _rate;\n    }\n\n    modifier nonReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function depositAndBorrow() public payable nonReentrant {\n        uint256 loanAmount = msg.value * rate;\n        require(loanToken.balanceOf(address(this)) >= loanAmount, \"Not enough tokens in the contract.\");\n        \n        (bool success, ) = owner.call{value: msg.value}(\"\");\n        require(success, \"Transfer to owner failed.\");\n\n        loanToken.transfer(msg.sender, loanAmount);\n    }\n\n    function changeRate(uint256 _rate) public nonReentrant {\n        require(msg.sender == owner, \"Only the owner can change the rate.\");\n        require(_rate != rate, \"The new rate is the same as the old one.\");\n        rate = _rate;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_142",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public owner;\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public refunds;\n\n    constructor() {\n        owner = msg.sender;\n        highestBid = 0;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Your bid should be higher than the current highest bid.\");\n\n        if(highestBidder != address(0)) {\n            refunds[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function withdrawRefund() public {\n        uint256 refundAmount = refunds[msg.sender];\n        refunds[msg.sender] = 0; \n        payable(msg.sender).transfer(refundAmount);\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only the owner can end the auction.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_143",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Bank {\n    address public owner;\n    mapping(address => uint256) public balances;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_144",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenSale {\n    address public owner;\n    uint256 public pricePerToken;\n    uint256 public totalTokens;\n\n    mapping(address => uint256) public tokenBalance;\n\n    constructor(uint256 _pricePerToken, uint256 _totalTokens) {\n        owner = msg.sender;\n        pricePerToken = _pricePerToken;\n        totalTokens = _totalTokens;\n    }\n\n    function buyTokens(uint256 numberOfTokens) public payable {\n        require(msg.value == numberOfTokens * pricePerToken, \"Incorrect Ether sent.\");\n        \n        require(totalTokens >= numberOfTokens, \"Not enough tokens left for sale.\");\n        \n        totalTokens -= numberOfTokens;\n        tokenBalance[msg.sender] += numberOfTokens;\n    }\n\n    function withdrawFunds() public {\n        require(msg.sender == owner, \"Only the owner can withdraw funds.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_145",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Your bid is too low.\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 previousHighestBid = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        if (previousHighestBidder != address(0)) {\n            payable(previousHighestBidder).transfer(previousHighestBid);\n        }\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only the owner can end the auction.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_146",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Bid should be higher than the current highest bid\");\n        \n        uint256 refundAmount = highestBid; \n        if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(refundAmount);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only owner can end the auction\");\n        owner.transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_147",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public bidIncrement = 0.01 ether;\n\n    function bid() public payable {\n        require(msg.value >= highestBid + bidIncrement, \"Bid is too low\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 refundAmount = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        if (previousHighestBidder != address(0)) {\n            (bool success, ) = previousHighestBidder.call{value: refundAmount}(\"\");\n            require(success, \"Refund failed.\");\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_148",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  LoyaltyPoints {\n    mapping(address => uint256) public points;\n    uint256 public rate = 100;  // 100 wei for 1 point\n\n    event Redeemed(address user, uint256 amount);\n\n    function topUp() public payable {\n        uint256 newPoints = msg.value / rate;\n        points[msg.sender] += newPoints;\n    }\n\n    function redeem(uint256 amount) public {\n        require(points[msg.sender] >= amount, \"Not enough points\");\n        \n        uint256 cost = amount * rate;\n        require(address(this).balance >= cost, \"Contract has insufficient funds\");\n        \n        points[msg.sender] -= amount;\n        \n        (bool success, ) = msg.sender.call{value: cost}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_149",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenSwap {\n    mapping(address => uint256) public etherBalance;\n    uint256 public tokenPrice = 1 ether; // 1 token = 1 ether\n\n    event TokenBought(address indexed buyer, uint256 amount);\n    event TokenSold(address indexed seller, uint256 amount);\n\n    function buyTokens(uint256 amount) public payable {\n        uint256 cost = amount * tokenPrice;\n        require(msg.value >= cost, \"Not enough Ether provided\");\n\n        etherBalance[msg.sender] += msg.value - cost; \n        emit TokenBought(msg.sender, amount);\n    }\n\n    function sellTokens(uint256 amount) public {\n        uint256 refund = amount * tokenPrice;\n        \n        require(etherBalance[msg.sender] >= refund, \"Insufficient balance\"); \n        etherBalance[msg.sender] -= refund; \n        \n        payable(msg.sender).transfer(refund);\n        emit TokenSold(msg.sender, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_150",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  LoyaltyPoints {\n    mapping(address => uint256) public loyaltyPoints;\n    mapping(address => uint256) public etherBalance;\n    uint256 public pointsPerEther = 100;  // 1 Ether = 100 loyalty points\n\n    event PointsEarned(address indexed user, uint256 points);\n    event PointsSpent(address indexed user, uint256 points);\n\n    function depositEtherAndEarnPoints() public payable {\n        uint256 points = msg.value * pointsPerEther;\n        \n        etherBalance[msg.sender] += msg.value;\n        loyaltyPoints[msg.sender] += points;\n\n        emit PointsEarned(msg.sender, points);\n    }\n\n    function spendPoints(uint256 points) public {\n        require(loyaltyPoints[msg.sender] >= points, \"Not enough loyalty points\");\n\n        uint256 etherRefund = points / pointsPerEther;\n        require(etherBalance[msg.sender] >= etherRefund, \"Insufficient Ether balance\");\n        \n        etherBalance[msg.sender] -= etherRefund;\n        loyaltyPoints[msg.sender] -= points;\n        \n        payable(msg.sender).transfer(etherRefund);\n\n        emit PointsSpent(msg.sender, points);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_151",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TimeLock {\n    struct Deposit {\n        uint256 amount;\n        uint256 endBlock;\n    }\n    \n    mapping(address => Deposit) public deposits;\n    uint256 public interestRate = 10;  // 10% per 1000 blocks\n\n    function depositForBlocks(uint256 blocks) public payable {\n        require(blocks >= 100, \"Minimum lock-up is 100 blocks\");\n        \n        deposits[msg.sender].endBlock = block.number + blocks;\n        uint256 interest = (msg.value * interestRate * blocks) / 1000;\n        deposits[msg.sender].amount = msg.value + interest;\n    }\n\n    function withdraw() public {\n        require(block.number >= deposits[msg.sender].endBlock, \"Funds are still locked\");\n        \n        uint256 amount = deposits[msg.sender].amount;\n        deposits[msg.sender].amount = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_152",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  EtherBet {\n    enum BetDirection { UP, DOWN }\n\n    struct Bet {\n        uint256 amount;\n        BetDirection direction;\n    }\n\n    mapping(address => Bet) public bets;\n    uint256 public totalUpBets;\n    uint256 public totalDownBets;\n    bool public gameEnded;\n    uint256 public totalReward;\n\n    function placeBet(BetDirection _direction) public payable {\n        require(!gameEnded, \"Game has already ended\");\n        require(bets[msg.sender].amount == 0, \"Already placed a bet\");\n\n        if(_direction == BetDirection.UP) {\n            totalUpBets += msg.value;\n        } else {\n            totalDownBets += msg.value;\n        }\n\n        bets[msg.sender] = Bet({\n            amount: msg.value,\n            direction: _direction\n        });\n    }\n\n    function endGame(bool priceWentUp) public {\n        // Only the contract owner can end the game for simplicity.\n        require(msg.sender == address(this), \"Only contract owner can end the game\");\n        require(!gameEnded, \"Game has already ended\");\n        \n        gameEnded = true;\n\n        if(priceWentUp) {\n            totalReward = address(this).balance / totalUpBets;\n        } else {\n            totalReward = address(this).balance / totalDownBets;\n        }\n    }\n\n    function claimReward() public {\n        require(gameEnded, \"Game hasn't ended yet\");\n        \n        uint256 reward = bets[msg.sender].amount * totalReward;\n        bets[msg.sender].amount = 0;\n        payable(msg.sender).transfer(reward);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_153",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenSale {\n    address public owner;\n    ERC20 public token;\n    uint256 public saleEnd;\n    uint256 public tokenPrice;\n    uint256 public tokensSold;\n\n    constructor(address _token, uint256 _tokenPrice, uint256 _duration) {\n        owner = msg.sender;\n        token = ERC20(_token);\n        tokenPrice = _tokenPrice;\n        saleEnd = block.timestamp + _duration;\n    }\n\n    function buyTokens(uint256 amount) public payable {\n        require(block.timestamp < saleEnd, \"Token sale ended.\");\n        require(msg.value == amount * tokenPrice, \"Incorrect Ether sent.\");\n\n        tokensSold += amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function retrieveUnsoldTokens() public {\n        require(msg.sender == owner, \"Only owner can retrieve unsold tokens.\");\n        require(block.timestamp > saleEnd, \"Sale is still ongoing.\");\n\n        uint256 unsold = token.balanceOf(address(this)) - tokensSold;\n        token.transfer(owner, unsold);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_154",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public owner;\n    address public highestBidder;\n    uint256 public highestBid;\n    bool public ended;\n\n    constructor() {\n        owner = msg.sender;\n        highestBidder = address(0);\n        highestBid = 0;\n        ended = false;\n    }\n\n    function bid() public payable {\n        require(!ended, \"Auction has already ended.\");\n        require(msg.sender != owner, \"Owner cannot place a bid.\");\n        require(msg.value > highestBid, \"There's already a higher bid.\");\n        \n        // Refund the previous highest bidder\n        if(highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only the owner can end the auction.\");\n        require(!ended, \"Auction has already been ended.\");\n        ended = true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_155",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  LoyaltyPoints {\n    mapping(address => uint256) public points;\n\n    uint256 public rewardCost = 100;\n\n    function earnPoints(uint256 _points) public {\n        points[msg.sender] += _points;\n    }\n\n    function redeemReward() public {\n        uint256 currentRewardCost = rewardCost;\n        rewardCost += 10; \n\n        require(points[msg.sender] >= currentRewardCost, \"Not enough points to redeem.\");\n        \n        points[msg.sender] -= currentRewardCost;\n\n        emit RewardRedeemed(msg.sender, currentRewardCost);\n    }\n\n    event RewardRedeemed(address indexed customer, uint256 rewardCost);\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_156",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenSale {\n    uint256 public tokensSold;\n    uint256 public tokenRate = 1000;\n    uint256 public discountRate = 10;\n\n    mapping(address => uint256) public tokenBalance;\n\n    function buyTokens() public payable {\n        uint256 tokensToBuy = msg.value * tokenRate;\n\n        uint256 discount = tokensToBuy * discountRate / 100;\n        tokensToBuy -= discount;\n\n        tokensSold += tokensToBuy;\n\n        tokenBalance[msg.sender] += tokensToBuy;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_157",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  LoyaltyPoints {\n    uint256 public threshold = 1 ether;\n    uint256 public bonusPoints = 500;\n    uint256 public rate = 100; \n\n    mapping(address => uint256) public loyaltyBalance;\n\n    function purchase() public payable {\n        uint256 loyaltyEarned = msg.value * rate;\n\n        uint256 fee = loyaltyEarned / 10;\n        loyaltyEarned -= fee;\n\n        if (msg.value >= threshold) {\n            loyaltyEarned += bonusPoints;\n        }\n\n        loyaltyBalance[msg.sender] += loyaltyEarned;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_158",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Bank {\n    mapping(address => uint256) public balances;\n    uint256 public bankRevenue;\n    uint256 constant FEE_PERCENT = 2;  // 2% deposit fee\n\n    function deposit() public payable {\n        uint256 fee = msg.value * FEE_PERCENT / 100;\n        uint256 afterFee = msg.value - fee;\n\n        bankRevenue += fee;\n\n        balances[msg.sender] += afterFee;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n        payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_159",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  LoyaltyPoints {\n    mapping(address => uint256) public points;\n    uint256 public totalPointsIssued;\n\n    function earnPoints(uint256 purchaseAmount) public {\n        // Assume 1 Ether purchase earns 10 points\n        uint256 newPoints = purchaseAmount / 1 ether * 10;\n\n        uint256 newTotalPoints = totalPointsIssued + newPoints;\n        require(newTotalPoints <= 1000000, \"Points cap reached\");\n\n        totalPointsIssued = newTotalPoints;\n        points[msg.sender] += newPoints;\n    }\n\n    function spendPoints(uint256 amount) public {\n        require(points[msg.sender] >= amount, \"Not enough points\");\n        points[msg.sender] -= amount;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_160",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    \n    function placeBid(uint256 bidAmount) public payable {\n        require(msg.value == bidAmount, \"Sent value doesn't match bid amount\");\n\n        require(bidAmount > highestBid, \"There already exists a higher or equal bid\");\n\n        address previousBidder = highestBidder;\n        uint256 refundAmount = highestBid;\n\n        highestBid = bidAmount;\n        highestBidder = msg.sender;\n\n        // Refund to the previous highest bidder\n        if(previousBidder != address(0)) {\n            payable(previousBidder).transfer(refundAmount);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_161",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenSale {\n    uint256 public tokensPerEther = 100;\n    uint256 public totalTokensSold;\n    \n    mapping(address => uint256) public tokenBalance;\n    \n    function buyTokens() public payable {\n        uint256 tokensToBuy = msg.value * tokensPerEther;\n\n        require(totalTokensSold + tokensToBuy <= 1e6 * tokensPerEther, \"Sale cap reached or exceeded\");\n\n        totalTokensSold += tokensToBuy;\n        tokenBalance[msg.sender] += tokensToBuy;\n    }\n    \n    function claimRefund() public {\n        require(totalTokensSold > 1e6 * tokensPerEther, \"Sale cap not breached\");\n        uint256 refundAmount = tokenBalance[msg.sender] / tokensPerEther;\n        tokenBalance[msg.sender] = 0;\n        payable(msg.sender).transfer(refundAmount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_162",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  DividendToken {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastDividends;\n    uint256 public totalSupply;\n    uint256 public totalDividend;\n    uint256 public totalDividendPerToken;\n\n    function deposit() public payable {\n        totalDividend += msg.value;\n    }\n\n    function distributeDividends() public {\n        uint256 dividendPerToken = totalDividend / totalSupply;\n        totalDividendPerToken += dividendPerToken;\n        totalDividend = 0;\n    }\n\n    function claimDividend() public {\n        uint256 owedPerToken = totalDividendPerToken - lastDividends[msg.sender];\n        uint256 amountOwed = balances[msg.sender] * owedPerToken;\n        lastDividends[msg.sender] = totalDividendPerToken;\n        payable(msg.sender).transfer(amountOwed);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_163",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    struct Auction {\n        address payable creator;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 startPrice;\n        address payable highestBidder;\n        uint256 highestBid;\n    }\n    mapping(uint256 => Auction) public auctions;\n    uint256 public auctionCount = 0;\n\n    function createAuction(uint256 duration, uint256 startPrice) public {\n        auctionCount += 1;\n        auctions[auctionCount] = Auction({\n            creator: payable(msg.sender),\n            startBlock: block.number,\n            endBlock: block.number + duration,\n            startPrice: startPrice,\n            highestBidder: payable(address(0)),\n            highestBid: 0\n        });\n    }\n\n    function bid(uint256 auctionId) public payable {\n        require(block.number <= auctions[auctionId].endBlock, \"Auction ended\");\n        require(msg.value > auctions[auctionId].highestBid, \"Bid too low\");\n\n        address payable previousBidder = auctions[auctionId].highestBidder;\n        uint256 previousBid = auctions[auctionId].highestBid;\n\n        auctions[auctionId].highestBidder = payable(msg.sender);\n        auctions[auctionId].highestBid = msg.value;\n\n        previousBidder.transfer(previousBid); d\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_164",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Fundraiser {\n    address public owner;\n    uint256 public goal;\n    uint256 public fundsRaised;\n    mapping(address => uint256) public donations;\n\n    constructor(uint256 _goal) {\n        owner = msg.sender;\n        goal = _goal;\n    }\n\n    function donate() public payable {\n        require(fundsRaised + msg.value <= goal, \"Fundraising goal exceeded\");\n        \n        donations[msg.sender] += msg.value;  \n        fundsRaised += msg.value;  \n\n    }\n\n    function withdraw() public {\n        require(msg.sender == owner, \"Only the owner can withdraw\");\n        require(fundsRaised >= goal, \"Goal not reached yet\");\n        \n        payable(owner).transfer(fundsRaised);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_165",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  Auction {\n    address public owner;\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public auctionEnd;\n    mapping(address => uint256) public pendingReturns;\n\n    event HighestBidIncreased(address bidder, uint256 amount);\n    event AuctionEnded(address winner, uint256 amount);\n\n    constructor(uint256 _biddingTime) {\n        owner = msg.sender;\n        auctionEnd = block.timestamp + _biddingTime;\n    }\n\n    function bid() public payable {\n        require(block.timestamp <= auctionEnd, \"Auction already ended.\");\n        require(msg.value > highestBid, \"There already is a higher bid.\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 previousHighestBid = highestBid;\n\n        highestBidder = msg.sender;  \n        highestBid = msg.value;      \n\n        pendingReturns[previousHighestBidder] += previousHighestBid; \n\n        emit HighestBidIncreased(msg.sender, msg.value);\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only the owner can end the auction\");\n        require(block.timestamp >= auctionEnd, \"Auction has not yet ended.\");\n\n        emit AuctionEnded(highestBidder, highestBid);\n\n        payable(owner).transfer(highestBid);\n    }\n\n    function withdraw() public {\n        uint256 amount = pendingReturns[msg.sender];\n        pendingReturns[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_166",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IToken {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract  TokenSale {\n    IToken public token;\n    address public owner;\n    uint256 public rate = 100;  // 1 ether = 100 tokens\n    uint256 public totalCollected;\n\n    constructor(address _token) {\n        owner = msg.sender;\n        token = IToken(_token);\n    }\n\n    function buyTokens() public payable {\n        uint256 tokensToBuy = rate * msg.value;\n        totalCollected += msg.value; \n\n        require(token.transfer(msg.sender, tokensToBuy), \"Token transfer failed\");\n    }\n\n    function ownerWithdraw() public {\n        require(msg.sender == owner, \"Only the owner can withdraw\");\n        uint256 amount = totalCollected; \n        totalCollected = 0; \n        payable(owner).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_167",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  LoyaltyRewards {\n    mapping(address => uint256) public points;\n    address public owner;\n    uint256 public redeemThreshold = 1000;\n    uint256 public rewardAmount = 0.1 ether;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function distributeBonusPoints(address _to, uint256 _amount) public {\n        require(msg.sender == owner, \"Only owner can distribute bonus points\");\n        points[_to] += _amount;\n    }\n\n    function redeemReward() public {\n        require(points[msg.sender] >= redeemThreshold, \"Not enough points to redeem\");\n        \n        points[msg.sender] -= redeemThreshold; \n        payable(msg.sender).transfer(rewardAmount); \n    }\n\n\n    function fundContract() public payable {}\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_168",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  CryptoAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n\n    event RefundFailed(address recipient, uint256 amount);\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"Bid amount too low.\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 previousHighestBid = highestBid;\n\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n   \n        if (previousHighestBidder != address(0)) {\n            bool success = payable(previousHighestBidder).send(previousHighestBid);\n            if (!success) {\n                emit RefundFailed(previousHighestBidder, previousHighestBid);\n            }\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_169",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  CryptoBank {\n    mapping(address => uint256) public balances;\n\n    uint256 constant BONUS = 0.1 ether;\n\n    function deposit() external payable {\n        require(msg.value >= 1 ether, \"Minimum deposit is 1 Ether.\");\n\n        uint256 amount = msg.value;\n\n     \n        amount += BONUS;\n\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_170",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  CryptoLoyalty {\n    mapping(address => uint256) public tokenBalances;\n    uint256 public pricePerToken = 1 ether;\n\n    // Buy tokens and get 10% extra if you buy more than 100 tokens\n    function buyTokens(uint256 numberOfTokens) external payable {\n        require(numberOfTokens > 0, \"Number of tokens should be greater than 0.\");\n\n        uint256 bonusTokens = 0;\n\n        if(numberOfTokens > 100) {\n            bonusTokens = numberOfTokens / 10; // 10% bonus\n        }\n\n        uint256 totalTokens = numberOfTokens + bonusTokens;\n\n        uint256 cost = totalTokens * pricePerToken;\n        require(msg.value == cost, \"Ether sent is not correct.\");\n\n        tokenBalances[msg.sender] += totalTokens;\n    }\n\n    function balanceOf(address user) external view returns (uint256) {\n        return tokenBalances[user];\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_171",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  CryptoBank {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public depositTimestamp;\n\n    uint256 constant ONE_DAY = 86400; // seconds in a day\n\n    function deposit() external payable {\n        if(depositTimestamp[msg.sender] == 0 || block.timestamp - depositTimestamp[msg.sender] > ONE_DAY * 30) {\n            uint256 interest = calculateInterest(msg.sender);\n            balances[msg.sender] += interest;\n        }\n        \n        depositTimestamp[msg.sender] = block.timestamp;\n        balances[msg.sender] += msg.value;\n    }\n\n    function calculateInterest(address user) public view returns(uint256) {\n        uint256 depositDuration = block.timestamp - depositTimestamp[user];\n        if(depositDuration > ONE_DAY * 30) {\n            return balances[user] / 10; // 10% interest for deposits older than a month\n        }\n        return 0;\n    }\n\n    function withdraw() external {\n        uint256 amount = balances[msg.sender];\n        require(amount > 0, \"Nothing to withdraw\");\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_172",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenVault {\n    struct Deposit {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    mapping(address => Deposit) public deposits;\n\n    function depositTokens(address tokenAddress, uint256 amount, uint256 lockDays) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        deposits[msg.sender].amount += amount; \n        deposits[msg.sender].unlockTime = block.timestamp + lockDays * 1 days;\n    }\n\n    function withdrawTokens(address tokenAddress) external {\n        require(block.timestamp >= deposits[msg.sender].unlockTime, \"Tokens are locked\");\n        \n        uint256 amountToWithdraw = deposits[msg.sender].amount;\n        deposits[msg.sender].amount = 0;\n        \n        IERC20(tokenAddress).transfer(msg.sender, amountToWithdraw);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_173",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n\n    mapping(address => uint256) public points;\n    mapping(address => bool) public specialUsers;\n\n    // 1 Ether = 100 points\n    uint256 public constant POINTS_PER_ETHER = 100;\n    uint256 public constant SPECIAL_USER_MULTIPLIER = 2;\n\n    function deposit() external payable {\n        require(msg.value > 0, \"Must send Ether\");\n        \n        uint256 newPoints = msg.value / 1 ether * POINTS_PER_ETHER;\n\n        if (specialUsers[msg.sender]) {\n            newPoints *= SPECIAL_USER_MULTIPLIER;\n        }\n\n        points[msg.sender] += newPoints;\n    }\n\n    function setSpecialUser(address user) external {\n        // Only for demonstration purposes; in a real contract, you would want more security around this function.\n        specialUsers[user] = true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_174",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleLending {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public loans;\n\n    uint256 public constant INTEREST_RATE = 5; // 5% interest rate for simplicity\n\n    function deposit(uint256 amount) external {\n        balances[msg.sender] += amount;\n        // Assuming the ERC20 transferFrom function is properly integrated\n        // ERC20Token.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function lend(address borrower, uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Not enough balance\");\n\n        uint256 interest = (amount * INTEREST_RATE) / 100;\n\n        loans[borrower] += amount;\n        balances[msg.sender] -= (amount - interest);\n    }\n\n    function repay(address lender) external payable {\n        require(loans[msg.sender] > 0, \"No loan to repay\");\n\n        uint256 repaymentAmount = loans[msg.sender];\n        loans[msg.sender] = 0;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_175",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract StakingToken {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastStakedTime;\n    mapping(address => uint256) public rewards;\n\n    uint256 public rewardRate = 1e18; // 1 token per second\n\n    function deposit(uint256 amount) external {\n        updateReward(msg.sender);\n        \n        lastStakedTime[msg.sender] = block.timestamp; \n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        updateReward(msg.sender);\n\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n    }\n\n    function updateReward(address user) public {\n        uint256 stakingDuration = block.timestamp - lastStakedTime[user];\n        rewards[user] += balances[user] * stakingDuration * rewardRate;\n        lastStakedTime[user] = block.timestamp;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_176",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract PoolShare {\n    mapping(address => uint256) public deposits;\n    uint256 public totalPool;\n\n    function depositFunds(uint256 amount) external {\n        deposits[msg.sender] += amount;\n        totalPool += amount;\n    }\n\n    function withdrawFunds() external {\n        uint256 userDeposit = deposits[msg.sender];\n        totalPool -= userDeposit; \n        uint256 userShare = userDeposit * address(this).balance / totalPool;\n        deposits[msg.sender] = 0;\n        payable(msg.sender).transfer(userShare);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_177",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n    mapping(address => bool) public receivedBonus;\n    uint256 constant BONUS_THRESHOLD = 5 ether;\n    uint256 constant BONUS_POINTS = 1000;\n\n    function makeTransaction(uint256 amount) external {\n        if (amount > BONUS_THRESHOLD && !receivedBonus[msg.sender]) {\n            receivedBonus[msg.sender] = true; \n            points[msg.sender] += BONUS_POINTS;\n        }\n        points[msg.sender] += amount / 1 ether; // Earn 1 point for every ether spent\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_178",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenStaking {\n    mapping(address => uint256) public stakedAmount;\n    mapping(address => uint256) public rewards;\n    uint256 constant PREMIUM_THRESHOLD = 1000;\n    uint256 constant REGULAR_REWARD = 10;\n    uint256 constant PREMIUM_REWARD = 50;\n\n    function stakeTokens(uint256 amount) external {\n        stakedAmount[msg.sender] += amount; \n        if (stakedAmount[msg.sender] > PREMIUM_THRESHOLD) {\n            rewards[msg.sender] += PREMIUM_REWARD;\n        } else {\n            rewards[msg.sender] += REGULAR_REWARD;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_179",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DecentralizedLottery {\n    address[] public participants;\n    address public currentWinner;\n    uint256 public ticketPrice = 1 ether;\n    uint256 constant MAX_PARTICIPANTS = 10;\n\n    function buyTicket() external payable {\n        require(msg.value == ticketPrice, \"Incorrect Ether sent\");\n        \n        participants.push(msg.sender);\n\n        if (participants.length == MAX_PARTICIPANTS) {\n            uint256 winnerIndex = uint256(blockhash(block.number - 1)) % MAX_PARTICIPANTS;\n            currentWinner = participants[winnerIndex];\n            \n            participants = new address[](0); \n\n            payable(currentWinner).transfer(address(this).balance); // Now transfer the reward\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_180",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DecentralizedAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"Bid should be higher than the current highest bid\");\n\n        address previousBidder = highestBidder;\n        uint256 previousBid = highestBid;\n\n        highestBidder = msg.sender;   \n        highestBid = msg.value;\n\n        if (previousBidder != address(0)) {\n            payable(previousBidder).transfer(previousBid); \n        }\n    }\n\n    function endAuction() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_181",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleInsurance {\n    address public owner;\n    mapping(address => uint256) public insuranceAmount;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function buyInsurance() external payable {\n        require(msg.value > 0, \"Must send ether to buy insurance.\");\n        insuranceAmount[msg.sender] += msg.value;\n    }\n\n    function approveClaim(address beneficiary) external onlyOwner {\n        require(insuranceAmount[beneficiary] > 0, \"Beneficiary has no insurance.\");\n\n        uint256 payoutAmount = insuranceAmount[beneficiary];\n        insuranceAmount[beneficiary] = 0; \n        payable(beneficiary).transfer(payoutAmount);\n    }\n\n    function withdraw() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_182",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenRewards {\n    address public owner;\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public rewards;\n\n    uint256 public totalSupply = 10000;\n    uint256 public totalRewards = 1000; // total rewards to distribute\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        balances[owner] = totalSupply;  \n    }\n\n    function transfer(address to, uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        updateRewards(msg.sender);\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n\n    function claimRewards() public {\n        updateRewards(msg.sender);\n        uint256 reward = rewards[msg.sender];\n        require(reward > 0, \"No rewards to claim\");\n        rewards[msg.sender] = 0; \n        payable(msg.sender).transfer(reward);\n        totalRewards -= reward; \n    }\n\n    function updateRewards(address user) internal {\n        uint256 userBalance = balances[user];\n        uint256 reward = (userBalance * totalRewards) / totalSupply; // rewards proportional to holdings\n        rewards[user] += reward;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_183",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleLottery {\n    address public owner;\n    address[] public participants;\n    uint256 public participationAmount = 1 ether; \n    uint256 public maxParticipants = 10;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function participate() external payable {\n        require(msg.value == participationAmount, \"Incorrect amount sent\");\n        participants.push(msg.sender);\n        \n        if(participants.length == maxParticipants) {\n            uint256 winnerIndex = block.timestamp % maxParticipants;\n            address winner = participants[winnerIndex];\n            \n           \n            participants = new address[](0); \n            \n            payable(winner).transfer(address(this).balance);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_184",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DecentralizedAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) pendingReturns;\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"There already is a higher bid.\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 previousHighestBid = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        if (previousHighestBidder != address(0)) {\n            pendingReturns[previousHighestBidder] += previousHighestBid;\n        }\n    }\n\n    function withdraw() external returns (bool) {\n        uint256 amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            pendingReturns[msg.sender] = 0;\n            (bool success, ) = msg.sender.call{value: amount}(\"\");\n            if (!success) {\n                pendingReturns[msg.sender] = amount; \n            }\n            return success;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_185",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract VotingSystem {\n\n    struct Proposal {\n        uint256 voteCount;\n        bool executed;\n    }\n\n    mapping(address => Proposal) public proposals;\n    mapping(address => bool) public hasVoted;\n    address public winningProposal;\n    uint256 public highestVoteCount;\n\n    function vote(address proposal) external {\n        require(!hasVoted[msg.sender], \"You have already voted.\");\n        require(!proposals[proposal].executed, \"Proposal already executed.\");\n\n        proposals[proposal].voteCount += 1;\n        hasVoted[msg.sender] = true;\n\n       \n        if (proposals[proposal].voteCount > highestVoteCount) {\n            highestVoteCount = proposals[proposal].voteCount;\n            winningProposal = proposal;\n        }\n    }\n\n    function executeProposal() external {\n        require(proposals[winningProposal].voteCount > highestVoteCount / 2, \"Not enough votes.\");\n        proposals[winningProposal].executed = true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_186",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AuctionHouse {\n    \n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n    bool public auctionEnded = false;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() external payable {\n        require(!auctionEnded, \"Auction has ended.\");\n        require(msg.value > highestBid, \"Bid is not high enough.\");\n\n        address previousBidder = highestBidder;\n        uint256 refundAmount = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n       \n        if(previousBidder != address(0)) {\n            previousBidder.transfer(refundAmount); \n        }\n    }\n\n    function endAuction() external {\n        require(msg.sender == owner, \"Only the owner can end the auction.\");\n        require(!auctionEnded, \"Auction has already ended.\");\n\n        auctionEnded = true;\n        owner.transfer(highestBid);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_187",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        \n        balances[msg.sender] -= amount;\n        msg.sender.transfer(amount);\n    }\n\n    function getBalance() public view returns(uint256) {\n        return balances[msg.sender];\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_188",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  Bank {\n    address public owner;\n    bool public isShutdown = false;\n    mapping(address => uint256) public balances;\n\n    modifier notShutdown() {\n        require(!isShutdown, \"The bank is shut down.\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() public payable notShutdown {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public notShutdown {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function shutdown() public {\n        require(msg.sender == owner, \"Only the owner can shut down the bank.\");\n        isShutdown = true;\n    }\n\n    function refund() public {\n        require(isShutdown, \"The bank is still operational.\");\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_189",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  SimpleBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        uint256 amountToWithdraw = balances[msg.sender];\n        balances[msg.sender] = 0; \n        (bool success, ) = msg.sender.call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_190",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardDistributor {\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastRewardBlock;\n    uint256 public rewardPerBlock = 1 ether;\n\n    function stake(uint256 amount) public {\n        distributeReward(msg.sender);\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) public {\n        distributeReward(msg.sender);\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n    }\n\n    function distributeReward(address user) public {\n        uint256 blocksPassed = block.number - lastRewardBlock[user];\n        \n        \n        lastRewardBlock[user] = block.number;\n        \n        uint256 reward = blocksPassed * rewardPerBlock;\n        balances[user] += reward;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_191",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LiquidityPool {\n\n    mapping(address => uint256) public balances;\n    uint256 public totalLiquidity;\n    uint256 public feeRate = 5; \n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n        totalLiquidity += amount;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n    \n        balances[msg.sender] -= amount;\n        totalLiquidity -= amount;\n        \n        uint256 fee = (amount * feeRate) / 100;\n        \n        payable(msg.sender).transfer(amount - fee);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_192",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardPool {\n\n    mapping(address => uint256) public balances;\n    uint256 public totalStaked;\n    uint256 public rewardPool;\n\n    event RewardDistributed(address user, uint256 amount);\n\n    function stake(uint256 amount) public {\n        require(amount > 0, \"Amount should be greater than 0\");\n\n       \n        balances[msg.sender] += amount;\n        totalStaked += amount;\n\n       \n        uint256 reward = (balances[msg.sender] * rewardPool) / totalStaked;\n        balances[msg.sender] += reward;\n        rewardPool -= reward;\n        emit RewardDistributed(msg.sender, reward);\n    }\n\n    function unstake(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Not enough balance\");\n        balances[msg.sender] -= amount;\n        totalStaked -= amount;\n    }\n\n    function depositReward(uint256 amount) public {\n        rewardPool += amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_193",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    event NewBid(address indexed bidder, uint256 amount);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Bid not high enough\");\n\n        address prevBidder = highestBidder;\n        uint256 refundAmount = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        emit NewBid(msg.sender, msg.value);\n\n        if (prevBidder != address(0)) {\n            payable(prevBidder).transfer(refundAmount);\n        }\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only owner can end the auction\");\n        payable(owner).transfer(highestBid);\n        highestBid = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_194",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint value) external returns(bool);\n    function transfer(address to, uint value) external returns(bool);\n}\n\ncontract TokenSwap {\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n    uint256 public rate; // How many B tokens you get for 1 A token\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        tokenA = IERC20(_tokenA);\n        tokenB = IERC20(_tokenB);\n        rate = _rate;\n    }\n\n    function swapAforB(uint256 amountA) external {\n        uint256 amountB = amountA * rate;\n\n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of token A failed\");\n\n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of token B failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_195",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract Staking {\n    IERC20 public token;\n    uint256 public totalStaked;\n    uint256 public rewardRate;\n    uint256 public lastRewardUpdateTime;\n\n    struct User {\n        uint256 balance;\n        uint256 rewardDebt;\n    }\n    mapping(address => User) public users;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function deposit(uint256 amount) external {\n        updateRewards();\n        \n        User storage user = users[msg.sender];\n        user.balance += amount;\n        \n        uint256 pendingReward = user.balance * rewardRate - user.rewardDebt;\n        token.transfer(msg.sender, pendingReward);\n\n        user.rewardDebt = user.balance * rewardRate;\n        \n        require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n    }\n\n    function updateRewards() public {\n        uint256 timeElapsed = block.timestamp - lastRewardUpdateTime;\n        rewardRate += timeElapsed * 1e18 / totalStaked;\n\n        lastRewardUpdateTime = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_196",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SavingsAccount {\n    mapping(address => uint256) public balances;\n    uint256 public interestRate = 5; // Represents 5%\n    mapping(address => uint256) public lastInterestCreditTime;\n\n    function deposit(uint256 amount) external {\n        balances[msg.sender] += amount;\n        creditInterest(msg.sender);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n        creditInterest(msg.sender);\n        balances[msg.sender] -= amount;\n    }\n\n    function creditInterest(address account) internal {\n        uint256 timeDifference = block.timestamp - lastInterestCreditTime[account];\n        uint256 interest = balances[account] * interestRate / 100 * timeDifference / (365 days);\n        balances[account] += interest;\n        lastInterestCreditTime[account] = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_197",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract StakeAndRewards {\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public lastClaimed;\n    uint256 public rewardRate = 1e18;  // reward rate per block, for simplicity's sake\n\n    function deposit() external payable {\n        stakes[msg.sender] += msg.value;\n    }\n\n    function claimRewards() external {\n        uint256 pendingRewards = (block.number - lastClaimed[msg.sender]) * rewardRate;\n        require(stakes[msg.sender] >= pendingRewards, \"Reward exceeds staked amount\");\n\n        lastClaimed[msg.sender] = block.number;\n\n        payable(msg.sender).transfer(pendingRewards);\n    }\n\n    function setRewardRate(uint256 newRate) external {\n        rewardRate = newRate;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_198",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LendingPlatform {\n    mapping(address => uint256) public deposits;\n    mapping(address => uint256) public loans;\n    mapping(address => uint256) public lastBorrowedBlock;\n    \n    uint256 public borrowRate = 5;  // Interest rate of 5% per block for simplicity\n\n    event Deposited(address indexed user, uint256 amount);\n    event Borrowed(address indexed user, uint256 amount);\n    event Repaid(address indexed user, uint256 amount);\n\n    function deposit(uint256 amount) external {\n        deposits[msg.sender] += amount;\n        emit Deposited(msg.sender, amount);\n    }\n\n    function borrow(uint256 amount) external {\n        require(deposits[msg.sender] > amount, \"Insufficient deposit\");\n        uint256 interest = amount * borrowRate / 100;\n        loans[msg.sender] += amount + interest;\n        lastBorrowedBlock[msg.sender] = block.number;\n        emit Borrowed(msg.sender, amount);\n    }\n\n    function repayLoan(uint256 amount) external {\n        uint256 interest = (block.number - lastBorrowedBlock[msg.sender]) * borrowRate / 100;\n\n        require(amount >= interest, \"Amount is less than owed interest\");\n        \n        loans[msg.sender] -= amount;\n        emit Repaid(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_199",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IPriceOracle {\n    function getPrice(address token) external view returns (uint256);\n}\n\ncontract DexLiquidityPool {\n    IPriceOracle public oracle;\n    mapping(address => uint256) public tokenBalances;\n\n    event LiquidityAdded(address indexed user, address indexed token, uint256 amount);\n\n    constructor(IPriceOracle _oracle) {\n        oracle = _oracle;\n    }\n\n    function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external {\n        uint256 priceA = oracle.getPrice(tokenA);  // Get price from oracle\n        uint256 priceB = oracle.getPrice(tokenB);\n\n        require(priceA * amountA == priceB * amountB, \"Provided tokens are not equivalent in value.\");\n\n        tokenBalances[tokenA] += amountA;\n        tokenBalances[tokenB] += amountB;\n\n        emit LiquidityAdded(msg.sender, tokenA, amountA);\n        emit LiquidityAdded(msg.sender, tokenB, amountB);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_200",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EthLoan {\n    struct Loan {\n        uint256 amount;\n        uint256 startBlock;\n    }\n\n    uint256 public interestRatePerBlock = 1;  // 0.01% per block as an example\n    mapping(address => Loan) public loans;\n\n    event LoanTaken(address indexed user, uint256 amount);\n\n    function takeLoan(uint256 amount) external payable {\n        require(msg.value == amount, \"Amount mismatch!\");\n\n        uint256 oldStartBlock = loans[msg.sender].startBlock;\n        loans[msg.sender].startBlock = block.number;\n\n        if (loans[msg.sender].amount != 0) {\n            uint256 interest = (block.number - oldStartBlock) * interestRatePerBlock * loans[msg.sender].amount / 10000;\n            loans[msg.sender].amount += interest;\n        }\n        \n        loans[msg.sender].amount += amount;\n\n        emit LoanTaken(msg.sender, amount);\n    }\n\n    function repayLoan() external payable {\n        require(loans[msg.sender].amount > 0, \"No loan taken.\");\n        uint256 totalDue = loans[msg.sender].amount + (block.number - loans[msg.sender].startBlock) * interestRatePerBlock * loans[msg.sender].amount / 10000;\n        require(msg.value >= totalDue, \"Not enough to cover the loan and interest.\");\n\n        payable(msg.sender).transfer(msg.value - totalDue);  \n        delete loans[msg.sender];  \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_201",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EthDepositReward {\n    uint256 public totalDeposits;\n    uint256 public tokenPrice = 1 ether;  // Starting token price as 1 ETH for simplicity.\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public rewards;\n\n    event Deposited(address indexed user, uint256 amount, uint256 rewardAmount);\n\n    function deposit() external payable {\n        require(msg.value > 0, \"Deposit value should be greater than 0\");\n\n        totalDeposits += msg.value;\n        tokenPrice = totalDeposits / 1000;  \n        uint256 rewardAmount = msg.value / tokenPrice;\n\n        balances[msg.sender] += msg.value;\n        rewards[msg.sender] += rewardAmount;\n\n        emit Deposited(msg.sender, msg.value, rewardAmount);\n    }\n    \n    // Additional functions would be here...\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_202",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleStaking {\n    uint256 public rewardRate = 1e18;  // For simplicity, let's say 1 token reward per second.\n\n    struct User {\n        uint256 balance;\n        uint256 lastClaimTime;\n    }\n\n    mapping(address => User) public users;\n\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        // Assume a transfer function exists that moves tokens into the contract\n        // For simplicity, it's omitted here.\n        \n        User storage user = users[msg.sender];\n        user.balance += amount;\n        user.lastClaimTime = block.timestamp;\n    }\n\n    function claimReward() external {\n        User storage user = users[msg.sender];\n        \n        uint256 timeElapsed = block.timestamp - user.lastClaimTime;\n        uint256 reward = timeElapsed * rewardRate;\n        user.lastClaimTime = block.timestamp;\n\n        require(reward <= user.balance, \"Not enough tokens to give as reward\");\n        user.balance -= reward;\n\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    // Additional functions would be here...\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_203",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleSavings {\n    uint256 public interestRate = 1e15;  // Representing 0.1% interest per second for simplicity.\n\n    struct Account {\n        uint256 balance;\n        uint256 lastDepositTime;\n    }\n\n    mapping(address => Account) public accounts;\n\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit(uint256 amount) external {\n        // Assume a function that transfers tokens into the contract exists.\n        // Omitted for brevity.\n\n        Account storage userAccount = accounts[msg.sender];\n        userAccount.balance += amount;\n        userAccount.lastDepositTime = block.timestamp;\n    }\n\n    function withdraw(uint256 amount) external {\n        Account storage userAccount = accounts[msg.sender];\n        \n        uint256 timeElapsed = block.timestamp - userAccount.lastDepositTime;\n        userAccount.lastDepositTime = block.timestamp;\n        uint256 interest = userAccount.balance * interestRate * timeElapsed;\n        \n        uint256 totalWithdrawal = amount + interest;\n        require(totalWithdrawal <= userAccount.balance, \"Insufficient balance\");\n        userAccount.balance -= totalWithdrawal;\n\n        emit Withdrawn(msg.sender, totalWithdrawal);\n    }\n\n    // ... other functions.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_204",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EventTickets {\n    struct Event {\n        string name;\n        uint256 ticketPrice;\n        uint256 totalTickets;\n        uint256 ticketsSold;\n    }\n\n    mapping(uint256 => Event) public events;\n    uint256 public nextEventId = 0;\n\n    event TicketPurchased(uint256 eventId, address buyer, uint256 amount);\n\n    function createEvent(string calldata _name, uint256 _ticketPrice, uint256 _totalTickets) external {\n        events[nextEventId] = Event({\n            name: _name,\n            ticketPrice: _ticketPrice,\n            totalTickets: _totalTickets,\n            ticketsSold: 0\n        });\n\n        nextEventId++;\n    }\n\n    function buyTicket(uint256 _eventId, uint256 _amount) external payable {\n        Event storage chosenEvent = events[_eventId];\n        \n        require(msg.value == chosenEvent.ticketPrice * _amount, \"Incorrect Ether sent\");\n\n        require(chosenEvent.ticketsSold + _amount <= chosenEvent.totalTickets, \"Not enough tickets available\");\n\n        chosenEvent.ticketsSold += _amount;\n\n        emit TicketPurchased(_eventId, msg.sender, _amount);\n    }\n\n    // ... other functions for refunding, event management etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_205",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Wallet {\n    mapping(address => uint256) public balances;\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance!\");\n\n        balances[msg.sender] -= _amount;\n\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed!\");\n\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    // ... other potential functions\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_206",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n\n    event HighestBidIncreased(address indexed bidder, uint256 amount);\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"There's already a higher bid.\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 refundAmount = highestBid;\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        emit HighestBidIncreased(msg.sender, msg.value);\n\n        if (previousHighestBidder != address(0)) {\n            (bool success, ) = previousHighestBidder.call{value: refundAmount}(\"\");\n            require(success, \"Failed to send back the ether!\");\n        }\n\n        // ... other functions like auction end, withdrawal, etc.\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_207",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract RewardPool {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    uint256 public globalInterestRate = 1e18;\n\n    function deposit(uint256 amount) external {\n        updateGlobalInterestRate();\n        balances[msg.sender] += amount;\n        \n        totalSupply += amount;\n    }\n\n    function claimRewards() external {\n        updateGlobalInterestRate();\n\n        uint256 reward = balances[msg.sender] * globalInterestRate;\n        balances[msg.sender] += reward;\n    }\n\n    function updateGlobalInterestRate() internal {\n        // Assume some logic to increase global interest rate, e.g., 1% increment\n        globalInterestRate += globalInterestRate / 100;\n    }\n\n    // ... other functions\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_208",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Lottery {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 constant interestRate = 105; // 5% interest\n\n    function deposit(uint256 amount) external {\n        applyInterest(msg.sender);\n        balances[msg.sender] += amount;\n        \n        totalDeposits += amount;\n    }\n\n    function applyInterest(address user) internal {\n        balances[user] = (balances[user] * interestRate) / 100;\n    }\n\n    // ... other functions like drawing a winner, etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_209",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 constant loyaltyBonus = 10;  // 10 tokens bonus for each deposit\n\n    function deposit(uint256 amount) external {\n        giveLoyaltyBonus(msg.sender);  \n        balances[msg.sender] += amount;\n        totalDeposits += (amount + loyaltyBonus); \n    }\n\n    function giveLoyaltyBonus(address user) internal {\n        balances[user] += loyaltyBonus;\n    }\n\n    // ... other functions like withdrawals, etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_210",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    }
]