[
    {
        "Code": "    function belowMaintenanceThreshold(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account, true);\n        uint256 holdings = holdingsInPeg(account, true);\n        // The following should hold:\n        // holdings / loan >= 1.1\n        // => holdings >= loan * 1.1\n        return 100 * holdings >= liquidationThresholdPercent * loan;\n    }// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Fund.sol\";\nimport \"./Lending.sol\";\nimport \"./RoleAware.sol\";\nimport \"./MarginRouter.sol\";\nimport \"./PriceAware.sol\";\n\n// Goal: all external functions only accessible to margintrader role\n// except for view functions of course\n\nstruct CrossMarginAccount {\n    uint256 lastDepositBlock;\n    address[] borrowTokens;\n    // borrowed token address => amount\n    mapping(address => uint256) borrowed;\n    // borrowed token => yield quotient\n    mapping(address => uint256) borrowedYieldQuotientsFP;\n    address[] holdingTokens;\n    // token held in portfolio => amount\n    mapping(address => uint256) holdings;\n    // boolean value of whether an account holds a token\n    mapping(address => bool) holdsToken;\n}\n\nabstract contract CrossMarginAccounts is RoleAware, PriceAware {\n    /// @dev gets used in calculating how much accounts can borrow\n    uint256 public leveragePercent;\n\n    /// @dev percentage of assets held per assets borrowed at which to liquidate\n    uint256 public liquidationThresholdPercent;\n\n    /// @dev record of all cross margin accounts\n    mapping(address => CrossMarginAccount) internal marginAccounts;\n    /// @dev total token caps\n    mapping(address => uint256) public tokenCaps;\n    /// @dev tracks total of short positions per token\n    mapping(address => uint256) public totalShort;\n    /// @dev tracks total of long positions per token\n    mapping(address => uint256) public totalLong;\n    uint256 public coolingOffPeriod;\n\n    /// @dev last time this account deposited\n    /// relevant for withdrawal window\n    function getLastDepositBlock(address trader)\n        external\n        view\n        returns (uint256)\n    {\n        return marginAccounts[trader].lastDepositBlock;\n    }\n\n    /// @dev add an asset to be held by account\n    function addHolding(\n        CrossMarginAccount storage account,\n        address token,\n        uint256 depositAmount\n    ) internal {\n        if (!hasHoldingToken(account, token)) {\n            account.holdingTokens.push(token);\n        }\n\n        account.holdings[token] += depositAmount;\n    }\n\n    /// @dev adjust account to reflect borrowing of token amount\n    function borrow(\n        CrossMarginAccount storage account,\n        address borrowToken,\n        uint256 borrowAmount\n    ) internal {\n        if (!hasBorrowedToken(account, borrowToken)) {\n            account.borrowTokens.push(borrowToken);\n        } else {\n            account.borrowed[borrowToken] = Lending(lending())\n                .applyBorrowInterest(\n                account.borrowed[borrowToken],\n                borrowToken,\n                account.borrowedYieldQuotientsFP[borrowToken]\n            );\n        }\n        account.borrowedYieldQuotientsFP[borrowToken] = Lending(lending())\n            .viewBorrowingYieldFP(borrowToken);\n\n        account.borrowed[borrowToken] += borrowAmount;\n        addHolding(account, borrowToken, borrowAmount);\n\n        require(positiveBalance(account), \"Can't borrow: insufficient balance\");\n    }\n\n    /// @dev checks whether account is in the black, deposit + earnings relative to borrowed\n    function positiveBalance(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account, false);\n        uint256 holdings = holdingsInPeg(account, false);\n        // The following condition should hold:\n        // holdings / loan >= leveragePercent / (leveragePercent - 100)\n        // =>\n        return holdings * (leveragePercent - 100) >= loan * leveragePercent;\n    }\n\n    /// @dev internal function adjusting holding and borrow balances when debt extinguished\n    function extinguishDebt(\n        CrossMarginAccount storage account,\n        address debtToken,\n        uint256 extinguishAmount\n    ) internal {\n        // will throw if insufficient funds\n        account.borrowed[debtToken] = Lending(lending()).applyBorrowInterest(\n            account.borrowed[debtToken],\n            debtToken,\n            account.borrowedYieldQuotientsFP[debtToken]\n        );\n\n        account.borrowed[debtToken] =\n            account.borrowed[debtToken] -\n            extinguishAmount;\n        account.holdings[debtToken] =\n            account.holdings[debtToken] -\n            extinguishAmount;\n\n        if (account.borrowed[debtToken] > 0) {\n            account.borrowedYieldQuotientsFP[debtToken] = Lending(lending())\n                .viewBorrowingYieldFP(debtToken);\n        } else {\n            delete account.borrowedYieldQuotientsFP[debtToken];\n\n            bool decrement = false;\n            uint256 len = account.borrowTokens.length;\n            for (uint256 i; len > i; i++) {\n                address currToken = account.borrowTokens[i];\n                if (currToken == debtToken) {\n                    decrement = true;\n                } else if (decrement) {\n                    account.borrowTokens[i - 1] = currToken;\n                }\n            }\n            account.borrowTokens.pop();\n        }\n    }\n\n    /// @dev checks whether an account holds a token\n    function hasHoldingToken(CrossMarginAccount storage account, address token)\n        internal\n        view\n        returns (bool)\n    {\n        return account.holdsToken[token];\n    }\n\n    /// @dev checks whether an account has borrowed a token\n    function hasBorrowedToken(CrossMarginAccount storage account, address token)\n        internal\n        view\n        returns (bool)\n    {\n        return account.borrowedYieldQuotientsFP[token] > 0;\n    }\n\n    /// @dev calculate total loan in reference currency, including compound interest\n    function loanInPeg(CrossMarginAccount storage account, bool forceCurBlock)\n        internal\n        returns (uint256)\n    {\n        return\n            sumTokensInPegWithYield(\n                account.borrowTokens,\n                account.borrowed,\n                account.borrowedYieldQuotientsFP,\n                forceCurBlock\n            );\n    }\n\n    /// @dev total of assets of account, expressed in reference currency\n    function holdingsInPeg(\n        CrossMarginAccount storage account,\n        bool forceCurBlock\n    ) internal returns (uint256) {\n        return\n            sumTokensInPeg(\n                account.holdingTokens,\n                account.holdings,\n                forceCurBlock\n            );\n    }\n\n    /// @dev check whether an account can/should be liquidated\n    function belowMaintenanceThreshold(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account, true);\n        uint256 holdings = holdingsInPeg(account, true);\n        // The following should hold:\n        // holdings / loan >= 1.1\n        // => holdings >= loan * 1.1\n        return 100 * holdings >= liquidationThresholdPercent * loan;\n    }\n\n    /// @dev go through list of tokens and their amounts, summing up\n    function sumTokensInPeg(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        bool forceCurBlock\n    ) internal returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += PriceAware.getCurrentPriceInPeg(\n                token,\n                amounts[token],\n                forceCurBlock\n            );\n        }\n    }\n\n    /// @dev go through list of tokens and their amounts, summing up\n    function viewTokensInPeg(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts\n    ) internal view returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += PriceAware.viewCurrentPriceInPeg(token, amounts[token]);\n        }\n    }\n\n    /// @dev go through list of tokens and ammounts, summing up with interest\n    function sumTokensInPegWithYield(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        mapping(address => uint256) storage yieldQuotientsFP,\n        bool forceCurBlock\n    ) internal returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += yieldTokenInPeg(\n                token,\n                amounts[token],\n                yieldQuotientsFP,\n                forceCurBlock\n            );\n        }\n    }\n\n    /// @dev go through list of tokens and ammounts, summing up with interest\n    function viewTokensInPegWithYield(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal view returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += viewYieldTokenInPeg(\n                token,\n                amounts[token],\n                yieldQuotientsFP\n            );\n        }\n    }\n\n    /// @dev calculate yield for token amount and convert to reference currency\n    function yieldTokenInPeg(\n        address token,\n        uint256 amount,\n        mapping(address => uint256) storage yieldQuotientsFP,\n        bool forceCurBlock\n    ) internal returns (uint256) {\n        uint256 yieldFP = Lending(lending()).viewBorrowingYieldFP(token);\n        // 1 * FP / FP = 1\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\n        return\n            PriceAware.getCurrentPriceInPeg(\n                token,\n                amountInToken,\n                forceCurBlock\n            );\n    }\n\n    /// @dev calculate yield for token amount and convert to reference currency\n    function viewYieldTokenInPeg(\n        address token,\n        uint256 amount,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal view returns (uint256) {\n        uint256 yieldFP = Lending(lending()).viewBorrowingYieldFP(token);\n        // 1 * FP / FP = 1\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\n        return PriceAware.viewCurrentPriceInPeg(token, amountInToken);\n    }\n\n    /// @dev move tokens from one holding to another\n    function adjustAmounts(\n        CrossMarginAccount storage account,\n        address fromToken,\n        address toToken,\n        uint256 soldAmount,\n        uint256 boughtAmount\n    ) internal {\n        account.holdings[fromToken] = account.holdings[fromToken] - soldAmount;\n        addHolding(account, toToken, boughtAmount);\n    }\n\n    /// sets borrow and holding to zero\n    function deleteAccount(CrossMarginAccount storage account) internal {\n        uint256 len = account.borrowTokens.length;\n        for (uint256 borrowIdx; len > borrowIdx; borrowIdx++) {\n            address borrowToken = account.borrowTokens[borrowIdx];\n            totalShort[borrowToken] -= account.borrowed[borrowToken];\n            account.borrowed[borrowToken] = 0;\n            account.borrowedYieldQuotientsFP[borrowToken] = 0;\n        }\n        len = account.holdingTokens.length;\n        for (uint256 holdingIdx; len > holdingIdx; holdingIdx++) {\n            address holdingToken = account.holdingTokens[holdingIdx];\n            totalLong[holdingToken] -= account.holdings[holdingToken];\n            account.holdings[holdingToken] = 0;\n            account.holdsToken[holdingToken] = false;\n        }\n        delete account.borrowTokens;\n        delete account.holdingTokens;\n    }\n\n    /// @dev minimum\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return b;\n        } else {\n            return a;\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-04-marginswap#h-05-wrong-liquidation-logic",
                "Location": "    function belowMaintenanceThreshold(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account, true);\n        uint256 holdings = holdingsInPeg(account, true);\n        // The following should hold:\n        // holdings / loan >= 1.1\n        // => holdings >= loan * 1.1\n        return 100 * holdings >= liquidationThresholdPercent * loan;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated. The inverse equality was probably intended return 100 * holdings <= liquidationThresholdPercent * loan;. Users that shouldn\ufffd\ufffdt be liquidated can be liquidated, and users that should be liquidated cannot get liquidated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    //====================================PRICING====================================//\n\n    function calcValueInBase(address token, uint amount) public view returns (uint value){\n       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n       if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _baseAmt) / _tokenAmt;\n       }\n    }\n\n    function calcValueInToken(address token, uint amount) public view returns (uint value){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _tokenAmt) / _baseAmt;\n       }\n    }\n    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){\n            return calcValueInToken(token2, calcValueInBase(token1, amount));\n    }\n\n    function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n    }\n    function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n    }\n\n    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {\n        uint _testingPrice = calcValueInBase(token, one);\n        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price\n        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price\n        if(inside){\n            require((_testingPrice >= _lower && _testingPrice <= _upper), \"Not inside\");\n        } else {\n            require((_testingPrice <= _lower || _testingPrice >= _upper), \"Not outside\");\n        }\n    }\n\n    //====================================INCENTIVES========================================//\n\n    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {\n        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){\n            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);\n            if (iPOOLS(POOLS).isAsset(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            } else if(iPOOLS(POOLS).isAnchor(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            }\n        }\n    }\n\n    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {\n        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n\n    // Actual protection with 100 day rule and Reserve balance\n    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {\n        uint _coverage = getCoverage(member, token);\n        if(iROUTER(ROUTER).isCurated(token)){\n            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);\n            if(_duration <= timeForFullProtection) {\n                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule\n            } else {\n                protection = _coverage;\n            }\n        }\n        return calcPart(basisPoints, protection);\n    }\n    // Theoretical coverage based on deposit/redemption values\n    function getCoverage(address member, address token) public view returns (uint) {\n        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);\n        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);\n        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));\n        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));\n        return calcCoverage(_B0, _T0, _B1, _T1);\n    }\n\n    //==================================== LENDING ====================================//\n\n    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n        if(isBase(collateralAsset)){\n            baseValue = _collateralAdjusted;\n        }else if(isPool(collateralAsset)){\n            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\n            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n        }\n        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output\n        return (debt, baseValue);\n    }\n\n    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {\n        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt\n        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral\n        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);\n        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);\n        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral\n        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); \n        return (_collateralUnlocked, _memberInterestShare);\n    }\n\n    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {\n        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year\n        if(isBase(collateralAsset)){\n            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base\n        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {\n            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)\n        }\n    }\n    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);\n        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; \n    }\n    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);\n        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);\n        return (_debtIssued * 10000) / _debtDepth; \n    }\n\n    //====================================CORE-MATH====================================//\n\n    function calcPart(uint bp, uint total) public pure returns (uint){\n        // 10,000 basis points = 100.00%\n        require((bp <= 10000) && (bp >= 0), \"Must be correct BP\");\n        return calcShare(bp, 10000, total);\n    }\n\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n        // share = amount * part/total\n        if(part > total){\n            part = total;\n        }\n        if(total > 0){\n            share = (amount * part) / total;\n        }\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = (x * X * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){\n        // fee = (x * x * Y) / (x + X)^2\n        uint numerator = (x * x * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n    function calcSwapSlip(uint x, uint X) external pure returns (uint){\n        // slip = (x) / (x + X)\n        return (x*10000) / (x + X);\n    }\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){\n        // (P * b)/(2*(b + B))\n        return (P * b) / (2 * (b + B));\n    }\n\n    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }\n    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n        if(B0 > 0 && T1 > 0){\n            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\n            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\n            if(_redemptionValue <= _depositValue){\n                coverage = (_depositValue - _redemptionValue);\n            }\n        }\n    }\n\n    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)\n    function sortArray(uint[] memory array) external pure returns (uint[] memory) {\n        uint l = array.length;\n        for(uint i = 0; i < l; i++){\n            for(uint j = i+1; j < l; j++){\n                if(array[i] > array[j]){\n                    uint temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        return array;\n    }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-04-vader#h-07-wrong-calcasymmetricshare-calculation",
                "Location": "    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The inline-comment defines the number of asymmetric shares as (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3 but the Utils.calcAsymmetricShare function computes (uA * 2U^2 - 2uU + u^2) / U^3 which is not equivalent as can be seen from the A^2 term in the first term which does not occur in the second one. The associativity on P * part1 is wrong, and part2 is not multiplied by P. The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up. Recommend clarifying if the comment or the code is correct and fix them if not.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    //====================================PRICING====================================//\n\n    function calcValueInBase(address token, uint amount) public view returns (uint value){\n       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n       if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _baseAmt) / _tokenAmt;\n       }\n    }\n\n    function calcValueInToken(address token, uint amount) public view returns (uint value){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _tokenAmt) / _baseAmt;\n       }\n    }\n    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){\n            return calcValueInToken(token2, calcValueInBase(token1, amount));\n    }\n\n    function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n    }\n    function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n    }\n\n    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {\n        uint _testingPrice = calcValueInBase(token, one);\n        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price\n        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price\n        if(inside){\n            require((_testingPrice >= _lower && _testingPrice <= _upper), \"Not inside\");\n        } else {\n            require((_testingPrice <= _lower || _testingPrice >= _upper), \"Not outside\");\n        }\n    }\n\n    //====================================INCENTIVES========================================//\n\n    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {\n        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){\n            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);\n            if (iPOOLS(POOLS).isAsset(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            } else if(iPOOLS(POOLS).isAnchor(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            }\n        }\n    }\n\n    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {\n        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n\n    // Actual protection with 100 day rule and Reserve balance\n    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {\n        uint _coverage = getCoverage(member, token);\n        if(iROUTER(ROUTER).isCurated(token)){\n            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);\n            if(_duration <= timeForFullProtection) {\n                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule\n            } else {\n                protection = _coverage;\n            }\n        }\n        return calcPart(basisPoints, protection);\n    }\n    // Theoretical coverage based on deposit/redemption values\n    function getCoverage(address member, address token) public view returns (uint) {\n        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);\n        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);\n        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));\n        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));\n        return calcCoverage(_B0, _T0, _B1, _T1);\n    }\n\n    //==================================== LENDING ====================================//\n\n    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n        if(isBase(collateralAsset)){\n            baseValue = _collateralAdjusted;\n        }else if(isPool(collateralAsset)){\n            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\n            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n        }\n        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output\n        return (debt, baseValue);\n    }\n\n    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {\n        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt\n        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral\n        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);\n        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);\n        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral\n        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); \n        return (_collateralUnlocked, _memberInterestShare);\n    }\n\n    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {\n        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year\n        if(isBase(collateralAsset)){\n            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base\n        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {\n            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)\n        }\n    }\n    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);\n        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; \n    }\n    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);\n        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);\n        return (_debtIssued * 10000) / _debtDepth; \n    }\n\n    //====================================CORE-MATH====================================//\n\n    function calcPart(uint bp, uint total) public pure returns (uint){\n        // 10,000 basis points = 100.00%\n        require((bp <= 10000) && (bp >= 0), \"Must be correct BP\");\n        return calcShare(bp, 10000, total);\n    }\n\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n        // share = amount * part/total\n        if(part > total){\n            part = total;\n        }\n        if(total > 0){\n            share = (amount * part) / total;\n        }\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = (x * X * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){\n        // fee = (x * x * Y) / (x + X)^2\n        uint numerator = (x * x * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n    function calcSwapSlip(uint x, uint X) external pure returns (uint){\n        // slip = (x) / (x + X)\n        return (x*10000) / (x + X);\n    }\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){\n        // (P * b)/(2*(b + B))\n        return (P * b) / (2 * (b + B));\n    }\n\n    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }\n    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n        if(B0 > 0 && T1 > 0){\n            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\n            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\n            if(_redemptionValue <= _depositValue){\n                coverage = (_depositValue - _redemptionValue);\n            }\n        }\n    }\n\n    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)\n    function sortArray(uint[] memory array) external pure returns (uint[] memory) {\n        uint l = array.length;\n        for(uint i = 0; i < l; i++){\n            for(uint j = i+1; j < l; j++){\n                if(array[i] > array[j]){\n                    uint temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        return array;\n    }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-04-vader#h-08-wrong-liquidity-units-calculation",
                "Location": "    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The spec defines the number of LP units to be minted as units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments but the Utils.calcLiquidityUnits function computes ((P * part1) + part2) / part3 * slipAdjustments. The associativity on P * part1 is wrong, and part2 is not multiplied by P. The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-04-vader#h-12-getaddedamount-can-return-wrong-results",
                "Location": "The spec defines the number of LP units to be minted as units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments but the Utils.calcLiquidityUnits function computes ((P * part1) + part2) / part3 * slipAdjustments.\n\nThe associativity on P * part1 is wrong, and part2 is not multiplied by P.\n\nThe math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The getAddedAmount function only works correctly when called with (VADER/USDV, pool) or (pool, pool). However, when called with (token, pool) where token is neither VADER/USDV/pool, it returns the wrong results:\n\nIt gets the token balance\nAnd subtracts it from the stored mapToken_tokenAmount[_pool] amount which can be that of a completely different token\nAnyone can break individual pairs by calling sync(token1, token2) where the token1 balance is less than mapToken_tokenAmount[token2]. This will add the difference to mapToken_tokenAmount[token2] and break the accounting and result in a wrong swap logic.\n\nFurthermore, this can also be used to swap tokens without having to pay anthing with swap(token1, token2, member, toBase=false).\n\nRecommend adding a require statement in the else branch that checks that _token == _pool.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-04-vader#h-15-wrong-slippage-protection-on-token---token-trades",
                "Location": "require(iUTILS(UTILS()).calcSwapSlip(\n    inputAmount, // should use outToken here from prev trade\n    iPOOLS(POOLS).getBaseAmount(outputToken)\n  ) <= slipLimit\n);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The Router.swapWithSynthsWithLimit allows trading token to token and specifying slippage protection. A token to token trade consists of two trades: token to base base to token The slippage protection of the second trade (base to token) is computed wrong. It compares the token input amount (of the first trade) to the base reserve of the second pair. Slippage protection fails and either the trade is cancelled when it shouldn\ufffd\ufffdt be or it is accepted even though the user suffered more losses than expected. Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\n\n\npragma solidity 0.6.8;\n\n\n\nimport \"./interface/INFTXVaultFactory.sol\";\n\nimport \"./interface/INFTXEligibility.sol\";\n\nimport \"./interface/INFTXEligibilityManager.sol\";\n\nimport \"./interface/INFTXLPStaking.sol\";\n\nimport \"./interface/INFTXFeeDistributor.sol\";\n\nimport \"./interface/IPrevNftxContract.sol\";\n\nimport \"./interface/IRewardDistributionToken.sol\";\n\nimport \"./token/ERC20BurnableUpgradeable.sol\";\n\nimport \"./token/ERC20FlashMintUpgradeable.sol\";\n\nimport \"./token/ERC721HolderUpgradeable.sol\";\n\nimport \"./token/ERC1155HolderUpgradeable.sol\";\n\nimport \"./token/IERC721Upgradeable.sol\";\n\nimport \"./token/IERC1155Upgradeable.sol\";\n\nimport \"./util/PausableUpgradeable.sol\";\n\nimport \"./util/SafeMathUpgradeable.sol\";\n\nimport \"./util/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./util/EnumerableSetUpgradeable.sol\";\n\n\n\nimport \"hardhat/console.sol\";\n\n\n\ncontract NFTXVaultUpgradeable is\n\n    PausableUpgradeable,\n\n    ERC20BurnableUpgradeable,\n\n    ERC20FlashMintUpgradeable,\n\n    ReentrancyGuardUpgradeable,\n\n    ERC721HolderUpgradeable,\n\n    ERC1155HolderUpgradeable\n\n{\n\n    using SafeMathUpgradeable for uint256;\n\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n\n\n    uint256 constant base = 10**18;\n\n\n\n    uint256 public vaultId;\n\n    address public manager;\n\n    address public assetAddress;\n\n    INFTXVaultFactory public vaultFactory;\n\n    INFTXEligibility public eligibilityStorage;\n\n\n\n    uint256 randNonce;\n\n    uint256 public mintFee;\n\n    uint256 public redeemFee;\n\n    uint256 public directRedeemFee;\n\n    uint256 public swapFee;\n\n\n\n    // Purposely putting these on a new slot to make sure they're together.\n\n    bool public is1155;\n\n    bool public allowAllItems;\n\n    bool public enableMint;\n\n    bool public enableRedeem;\n\n    bool public enableDirectRedeem;\n\n    bool public enableSwap;\n\n    bool[20] _bool_gap;\n\n\n\n    string public description;\n\n\n\n    EnumerableSetUpgradeable.UintSet holdings;\n\n    mapping(uint256 => uint256) quantity1155;\n\n\n\n    event VaultInit(\n\n        uint256 indexed vaultId,\n\n        address assetAddress,\n\n        bool is1155,\n\n        bool allowAllItems\n\n    );\n\n\n\n    event ManagerSet(address manager);\n\n    event EligibilityDeployed(address eligibilityAddr);\n\n\n\n    event EnableMintUpdated(bool enabled);\n\n    event EnableRedeemUpdated(bool enabled);\n\n    event EnableDirectRedeemUpdated(bool enabled);\n\n    event EnableSwapUpdated(bool enabled);\n\n\n\n    event MintFeeUpdated(uint256 mintFee);\n\n    event RedeemFeeUpdated(uint256 redeemFee);\n\n    event DirectRedeemFeeUpdated(uint256 directRedeemFee);\n\n    event SwapFeeUpdated(uint256 swapFee);\n\n\n\n    event Minted(uint256[] nftIds, uint256[] amounts, address sender);\n\n    event Redeemed(uint256[] nftIds, address sender);\n\n    event Swapped(\n\n        uint256[] nftIds,\n\n        uint256[] amounts,\n\n        uint256[] specificIds,\n\n        address sender\n\n    );\n\n\n\n    constructor() public {\n\n        __Pausable_init();\n\n        __ERC20_init(\"\", \"\");\n\n        __ERC20Burnable_init_unchained();\n\n        __ERC20FlashMint_init();\n\n    }\n\n\n\n    function __NFTXVault_init(\n\n        string memory _name,\n\n        string memory _symbol,\n\n        address _assetAddress,\n\n        bool _is1155,\n\n        bool _allowAllItems\n\n    ) public initializer {\n\n        __Pausable_init();\n\n        __ERC20_init(_name, _symbol);\n\n        __ERC20Burnable_init_unchained();\n\n        __ERC20FlashMint_init();\n\n        assetAddress = _assetAddress;\n\n        vaultFactory = INFTXVaultFactory(msg.sender);\n\n        vaultId = vaultFactory.numVaults();\n\n        is1155 = _is1155;\n\n        allowAllItems = _allowAllItems;\n\n        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);\n\n    }\n\n\n\n    function finalizeFund() external virtual {\n\n        setManager(address(0));\n\n    }\n\n\n\n    function setVaultFeatures(\n\n        bool _enableMint,\n\n        bool _enableRedeem,\n\n        bool _enableDirectRedeem,\n\n        bool _enableSwap\n\n    ) external virtual {\n\n        onlyPrivileged();\n\n        enableMint = _enableMint;\n\n        enableRedeem = _enableRedeem;\n\n        enableDirectRedeem = _enableDirectRedeem;\n\n        enableSwap = _enableSwap;\n\n\n\n        emit EnableMintUpdated(enableMint);\n\n        emit EnableRedeemUpdated(enableRedeem);\n\n        emit EnableDirectRedeemUpdated(enableDirectRedeem);\n\n        emit EnableSwapUpdated(enableSwap);\n\n    }\n\n\n\n    // Should we do defaults?\n\n    function setFees(\n\n        uint256 _mintFee,\n\n        uint256 _redeemFee,\n\n        uint256 _directRedeemFee,\n\n        uint256 _swapFee\n\n    ) external virtual {\n\n        onlyPrivileged();\n\n        mintFee = _mintFee;\n\n        redeemFee = _redeemFee;\n\n        directRedeemFee = _directRedeemFee;\n\n        swapFee = _swapFee;\n\n\n\n        emit MintFeeUpdated(_mintFee);\n\n        emit RedeemFeeUpdated(_redeemFee);\n\n        emit DirectRedeemFeeUpdated(_directRedeemFee);\n\n        emit SwapFeeUpdated(_swapFee);\n\n    }\n\n\n\n    // This function alls for an easy setup of any eligibility module contract from the EligibilityManager.\n\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow \n\n    // a similar interface.\n\n    function deployEligibilityStorage(\n\n        uint256 moduleIndex,\n\n        bytes calldata initData\n\n    ) external virtual returns (address) {\n\n        onlyPrivileged();\n\n        INFTXEligibilityManager eligManager = INFTXEligibilityManager(\n\n            vaultFactory.eligibilityManager()\n\n        );\n\n        address _eligibility = eligManager.deployEligibility(\n\n            moduleIndex,\n\n            initData\n\n        );\n\n        setEligibilityStorage(_eligibility);\n\n        return _eligibility;\n\n    }\n\n\n\n    // This function allows for the manager to set their own arbitrary eligibility contract.\n\n    // Once eligiblity is set, it cannot be unset or changed.\n\n    function setEligibilityStorage(address _newEligibility) public virtual {\n\n        onlyPrivileged();\n\n        require(\n\n            address(eligibilityStorage) == address(0),\n\n            \"NFTXVault: eligibility already set\"\n\n        );\n\n        eligibilityStorage = INFTXEligibility(_newEligibility);\n\n        // Toggle this to let the contract know to check eligibility now.\n\n        allowAllItems = false;\n\n        emit EligibilityDeployed(address(_newEligibility));\n\n    }\n\n\n\n    // The manager has control over options like fees and features\n\n    function setManager(address _manager) public virtual {\n\n        onlyPrivileged();\n\n        manager = _manager;\n\n        emit ManagerSet(_manager);\n\n    }\n\n\n\n    function mint(\n\n        uint256[] calldata tokenIds,\n\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n\n    ) external virtual returns (uint256) {\n\n        return mintTo(tokenIds, amounts, msg.sender);\n\n    }\n\n\n\n    function mintTo(\n\n        uint256[] memory tokenIds,\n\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n\n        address to\n\n    ) public virtual nonReentrant returns (uint256) {\n\n        onlyOwnerIfPaused(1);\n\n        require(enableMint, \"Minting not enabled\");\n\n        require(allValidNFTs(tokenIds), \"NFTXVault: not eligible\");\n\n        uint256 count = receiveNFTs(tokenIds, amounts);\n\n\n\n        uint256 fee = mintFee.mul(count);\n\n        _mint(to, base.mul(count).sub(fee));\n\n        _distributeFees(fee);\n\n\n\n        emit Minted(tokenIds, amounts, to);\n\n        return count;\n\n    }\n\n\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n\n        external\n\n        virtual\n\n        returns (uint256[] memory)\n\n    {\n\n        return redeemTo(amount, specificIds, msg.sender);\n\n    }\n\n\n\n    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n\n        public\n\n        virtual\n\n        nonReentrant\n\n        returns (uint256[] memory)\n\n    {\n\n        onlyOwnerIfPaused(2);\n\n        require(enableRedeem, \"Redeeming not enabled\");\n\n        require(\n\n            specificIds.length == 0 || enableDirectRedeem,\n\n            \"Direct redeem not enabled\"\n\n        );\n\n        uint256 fee = directRedeemFee.mul(specificIds.length).add(\n\n            redeemFee.mul(amount.sub(specificIds.length))\n\n        );\n\n        // We burn all from sender and mint to fee receiver to reduce costs.\n\n        _burnFrom(msg.sender, base.mul(amount).add(fee));\n\n        _distributeFees(fee);\n\n\n\n        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);\n\n        afterRedeemHook(redeemedIds);\n\n\n\n        emit Redeemed(redeemedIds, to);\n\n        return redeemedIds;\n\n    }\n\n\n\n    function swap(\n\n        uint256[] calldata tokenIds,\n\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n\n        uint256[] calldata specificIds\n\n    ) external virtual nonReentrant returns (uint256[] memory) {\n\n        return swapTo(tokenIds, amounts, specificIds, msg.sender);\n\n    }\n\n\n\n    function swapTo(\n\n        uint256[] memory tokenIds,\n\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n\n        uint256[] memory specificIds,\n\n        address to\n\n    ) public virtual returns (uint256[] memory) {\n\n        onlyOwnerIfPaused(3);\n\n        require(enableSwap, \"Swapping not enabled\");\n\n        require(\n\n            specificIds.length == 0 || enableDirectRedeem,\n\n            \"Direct redeem not enabled\"\n\n        );\n\n        uint256 count = receiveNFTs(tokenIds, amounts);\n\n        uint256 fee = directRedeemFee.mul(specificIds.length).add(\n\n            swapFee.mul(count.sub(specificIds.length))\n\n        );\n\n        // We burn all from sender and mint to fee receiver to reduce costs.\n\n        _burnFrom(msg.sender, fee);\n\n        _distributeFees(fee);\n\n        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);\n\n        emit Swapped(tokenIds, amounts, specificIds, to);\n\n        return ids;\n\n    }\n\n\n\n    function flashLoan(\n\n        IERC3156FlashBorrowerUpgradeable receiver,\n\n        address token,\n\n        uint256 amount,\n\n        bytes memory data\n\n    ) public virtual override returns (bool) {\n\n        onlyOwnerIfPaused(4);\n\n        super.flashLoan(receiver, token, amount, data);\n\n    }\n\n\n\n    function allValidNFTs(uint256[] memory tokenIds)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        // add allow all check here\n\n        if (allowAllItems) {\n\n            return true;\n\n        }\n\n\n\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n\n        if (address(_eligibilityStorage) == address(0)) {\n\n            return false;\n\n        }\n\n        return _eligibilityStorage.checkAllEligible(tokenIds);\n\n    }\n\n\n\n    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.\n\n    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {\n\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n\n        if (address(_eligibilityStorage) == address(0)) {\n\n            return;\n\n        }\n\n        _eligibilityStorage.afterRedeemHook(tokenIds);\n\n    }\n\n\n\n    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)\n\n        internal\n\n        virtual\n\n        returns (uint256)\n\n    {\n\n        if (is1155) {\n\n            // This is technically a check, so placing it before the effect.\n\n            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n\n                msg.sender,\n\n                address(this),\n\n                tokenIds,\n\n                amounts,\n\n                \"\"\n\n            );\n\n\n\n            uint256 count;\n\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n\n                uint256 tokenId = tokenIds[i];\n\n                uint256 amount = amounts[i];\n\n                if (quantity1155[tokenId] == 0) {\n\n                    holdings.add(tokenId);\n\n                }\n\n                quantity1155[tokenId] = quantity1155[tokenId].add(amount);\n\n                count = count.add(amount);\n\n            }\n\n            return count;\n\n        } else {\n\n            IERC721Upgradeable erc721 = IERC721Upgradeable(assetAddress);\n\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n\n                uint256 tokenId = tokenIds[i];\n\n                erc721.safeTransferFrom(msg.sender, address(this), tokenId);\n\n                holdings.add(tokenId);\n\n            }\n\n            return tokenIds.length;\n\n        }\n\n    }\n\n\n\n    function withdrawNFTsTo(\n\n        uint256 amount,\n\n        uint256[] memory specificIds,\n\n        address to\n\n    ) internal virtual returns (uint256[] memory) {\n\n        bool _is1155 = is1155;\n\n        address _assetAddress = assetAddress;\n\n        uint256[] memory redeemedIds = new uint256[](amount);\n\n\n\n        for (uint256 i = 0; i < amount; i++) {\n\n            uint256 tokenId = i < specificIds.length\n\n                ? specificIds[i]\n\n                : getRandomTokenIdFromFund();\n\n            redeemedIds[i] = tokenId;\n\n\n\n            if (_is1155) {\n\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n\n                    address(this),\n\n                    to,\n\n                    tokenId,\n\n                    1,\n\n                    \"\"\n\n                );\n\n\n\n                quantity1155[tokenId] = quantity1155[tokenId].sub(1);\n\n                if (quantity1155[tokenId] == 0) {\n\n                    holdings.remove(tokenId);\n\n                }\n\n            } else {\n\n                IERC721Upgradeable(_assetAddress).safeTransferFrom(\n\n                    address(this),\n\n                    to,\n\n                    tokenId\n\n                );\n\n                holdings.remove(tokenId);\n\n            }\n\n        }\n\n        return redeemedIds;\n\n    }\n\n\n\n    function _distributeFees(uint256 amount) internal virtual {\n\n        // Mint fees directly to the distributor and distribute.\n\n        if (amount > 0) {\n\n            address feeReceiver = vaultFactory.feeReceiver();\n\n            _mint(feeReceiver, amount);\n\n            INFTXFeeDistributor(feeReceiver).distribute(vaultId);\n\n        }\n\n    }\n\n\n\n    function getRandomTokenIdFromFund() internal virtual returns (uint256) {\n\n        uint256 randomIndex = getPseudoRand(holdings.length());\n\n        return holdings.at(randomIndex);\n\n    }\n\n\n\n    function getPseudoRand(uint256 modulus) internal virtual returns (uint256) {\n\n        randNonce += 1;\n\n        return\n\n            uint256(\n\n                keccak256(\n\n                    abi.encodePacked(blockhash(block.number - 1), randNonce)\n\n                )\n\n            ) %\n\n            modulus;\n\n    }\n\n\n\n    function onlyPrivileged() internal view {\n\n        if (manager == address(0)) {\n\n            require(msg.sender == owner(), \"Not owner\");\n\n        } else {\n\n            require(msg.sender == manager, \"Not manager\");\n\n        }\n\n    }\n\n\n\n    // TODO: recount this.\n\n    uint256[25] ___gap;\n\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-05-nftx#h-03-getrandomtokenidfromfund-yields-wrong-probabilities-for-erc1155",
                "Location": "    function getRandomTokenIdFromFund() internal virtual returns (uint256) {\n        uint256 randomIndex = getPseudoRand(holdings.length());\n        return holdings.at(randomIndex);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. NFTXVaultUpgradeable.getRandomTokenIdFromFund does not work with ERC1155 as it does not take the deposited quantity1155 into account. Assume tokenId0 has a count of 100, and tokenId1 has a count of 1. Then getRandomId would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1. This might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off. Recommend taking the quantities of each token into account (quantity1155) which probably requires a design change as it is currently hard to do without iterating over all tokens.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >= 0.8.0;\n\nimport \"./Math64x64.sol\";\n\nlibrary Exp64x64 {\n  /**\n   * Raise given number x into power specified as a simple fraction y/z and then\n   * multiply the result by the normalization factor 2^(128 * (1 - y/z)).\n   * Revert if z is zero, or if both x and y are zeros.\n   *\n   * @param x number to raise into given power y/z\n   * @param y numerator of the power to raise x into\n   * @param z denominator of the power to raise x into\n   * @return x raised into power y/z and then multiplied by 2^(128 * (1 - y/z))\n   */\n  function pow(uint128 x, uint128 y, uint128 z)\n  internal pure returns(uint128) {\n    unchecked {\n      require(z != 0);\n\n      if(x == 0) {\n        require(y != 0);\n        return 0;\n      } else {\n        uint256 l =\n          uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - log_2(x)) * y / z;\n        if(l > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return 0;\n        else return pow_2(uint128(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - l));\n      }\n    }\n  }\n\n  /**\n   * Calculate base 2 logarithm of an unsigned 128-bit integer number.  Revert\n   * in case x is zero.\n   *\n   * @param x number to calculate base 2 logarithm of\n   * @return base 2 logarithm of x, multiplied by 2^121\n   */\n  function log_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      require(x != 0);\n\n      uint b = x;\n\n      uint l = 0xFE000000000000000000000000000000;\n\n      if(b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\n      if(b < 0x1000000000000000000000000) {l -= 0x40000000000000000000000000000000; b <<= 32;}\n      if(b < 0x10000000000000000000000000000) {l -= 0x20000000000000000000000000000000; b <<= 16;}\n      if(b < 0x1000000000000000000000000000000) {l -= 0x10000000000000000000000000000000; b <<= 8;}\n      if(b < 0x10000000000000000000000000000000) {l -= 0x8000000000000000000000000000000; b <<= 4;}\n      if(b < 0x40000000000000000000000000000000) {l -= 0x4000000000000000000000000000000; b <<= 2;}\n      if(b < 0x80000000000000000000000000000000) {l -= 0x2000000000000000000000000000000; b <<= 1;}\n\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000;} /*\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) l |= 0x1; */\n\n      return uint128(l);\n    }\n  }\n\n  /**\n   * Calculate 2 raised into given power.\n   *\n   * @param x power to raise 2 into, multiplied by 2^121\n   * @return 2 raised into given power\n   */\n  function pow_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      uint r = 0x80000000000000000000000000000000;\n      if(x & 0x1000000000000000000000000000000 > 0) r = r * 0xb504f333f9de6484597d89b3754abe9f >> 127;\n      if(x & 0x800000000000000000000000000000 > 0) r = r * 0x9837f0518db8a96f46ad23182e42f6f6 >> 127;\n      if(x & 0x400000000000000000000000000000 > 0) r = r * 0x8b95c1e3ea8bd6e6fbe4628758a53c90 >> 127;\n      if(x & 0x200000000000000000000000000000 > 0) r = r * 0x85aac367cc487b14c5c95b8c2154c1b2 >> 127;\n      if(x & 0x100000000000000000000000000000 > 0) r = r * 0x82cd8698ac2ba1d73e2a475b46520bff >> 127;\n      if(x & 0x80000000000000000000000000000 > 0) r = r * 0x8164d1f3bc0307737be56527bd14def4 >> 127;\n      if(x & 0x40000000000000000000000000000 > 0) r = r * 0x80b1ed4fd999ab6c25335719b6e6fd20 >> 127;\n      if(x & 0x20000000000000000000000000000 > 0) r = r * 0x8058d7d2d5e5f6b094d589f608ee4aa2 >> 127;\n      if(x & 0x10000000000000000000000000000 > 0) r = r * 0x802c6436d0e04f50ff8ce94a6797b3ce >> 127;\n      if(x & 0x8000000000000000000000000000 > 0) r = r * 0x8016302f174676283690dfe44d11d008 >> 127;\n      if(x & 0x4000000000000000000000000000 > 0) r = r * 0x800b179c82028fd0945e54e2ae18f2f0 >> 127;\n      if(x & 0x2000000000000000000000000000 > 0) r = r * 0x80058baf7fee3b5d1c718b38e549cb93 >> 127;\n      if(x & 0x1000000000000000000000000000 > 0) r = r * 0x8002c5d00fdcfcb6b6566a58c048be1f >> 127;\n      if(x & 0x800000000000000000000000000 > 0) r = r * 0x800162e61bed4a48e84c2e1a463473d9 >> 127;\n      if(x & 0x400000000000000000000000000 > 0) r = r * 0x8000b17292f702a3aa22beacca949013 >> 127;\n      if(x & 0x200000000000000000000000000 > 0) r = r * 0x800058b92abbae02030c5fa5256f41fe >> 127;\n      if(x & 0x100000000000000000000000000 > 0) r = r * 0x80002c5c8dade4d71776c0f4dbea67d6 >> 127;\n      if(x & 0x80000000000000000000000000 > 0) r = r * 0x8000162e44eaf636526be456600bdbe4 >> 127;\n      if(x & 0x40000000000000000000000000 > 0) r = r * 0x80000b1721fa7c188307016c1cd4e8b6 >> 127;\n      if(x & 0x20000000000000000000000000 > 0) r = r * 0x8000058b90de7e4cecfc487503488bb1 >> 127;\n      if(x & 0x10000000000000000000000000 > 0) r = r * 0x800002c5c8678f36cbfce50a6de60b14 >> 127;\n      if(x & 0x8000000000000000000000000 > 0) r = r * 0x80000162e431db9f80b2347b5d62e516 >> 127;\n      if(x & 0x4000000000000000000000000 > 0) r = r * 0x800000b1721872d0c7b08cf1e0114152 >> 127;\n      if(x & 0x2000000000000000000000000 > 0) r = r * 0x80000058b90c1aa8a5c3736cb77e8dff >> 127;\n      if(x & 0x1000000000000000000000000 > 0) r = r * 0x8000002c5c8605a4635f2efc2362d978 >> 127;\n      if(x & 0x800000000000000000000000 > 0) r = r * 0x800000162e4300e635cf4a109e3939bd >> 127;\n      if(x & 0x400000000000000000000000 > 0) r = r * 0x8000000b17217ff81bef9c551590cf83 >> 127;\n      if(x & 0x200000000000000000000000 > 0) r = r * 0x800000058b90bfdd4e39cd52c0cfa27c >> 127;\n      if(x & 0x100000000000000000000000 > 0) r = r * 0x80000002c5c85fe6f72d669e0e76e411 >> 127;\n      if(x & 0x80000000000000000000000 > 0) r = r * 0x8000000162e42ff18f9ad35186d0df28 >> 127;\n      if(x & 0x40000000000000000000000 > 0) r = r * 0x80000000b17217f84cce71aa0dcfffe7 >> 127;\n      if(x & 0x20000000000000000000000 > 0) r = r * 0x8000000058b90bfc07a77ad56ed22aaa >> 127;\n      if(x & 0x10000000000000000000000 > 0) r = r * 0x800000002c5c85fdfc23cdead40da8d6 >> 127;\n      if(x & 0x8000000000000000000000 > 0) r = r * 0x80000000162e42fefc25eb1571853a66 >> 127;\n      if(x & 0x4000000000000000000000 > 0) r = r * 0x800000000b17217f7d97f692baacded5 >> 127;\n      if(x & 0x2000000000000000000000 > 0) r = r * 0x80000000058b90bfbead3b8b5dd254d7 >> 127;\n      if(x & 0x1000000000000000000000 > 0) r = r * 0x8000000002c5c85fdf4eedd62f084e67 >> 127;\n      if(x & 0x800000000000000000000 > 0) r = r * 0x800000000162e42fefa58aef378bf586 >> 127;\n      if(x & 0x400000000000000000000 > 0) r = r * 0x8000000000b17217f7d24a78a3c7ef02 >> 127;\n      if(x & 0x200000000000000000000 > 0) r = r * 0x800000000058b90bfbe9067c93e474a6 >> 127;\n      if(x & 0x100000000000000000000 > 0) r = r * 0x80000000002c5c85fdf47b8e5a72599f >> 127;\n      if(x & 0x80000000000000000000 > 0) r = r * 0x8000000000162e42fefa3bdb315934a2 >> 127;\n      if(x & 0x40000000000000000000 > 0) r = r * 0x80000000000b17217f7d1d7299b49c46 >> 127;\n      if(x & 0x20000000000000000000 > 0) r = r * 0x8000000000058b90bfbe8e9a8d1c4ea0 >> 127;\n      if(x & 0x10000000000000000000 > 0) r = r * 0x800000000002c5c85fdf4745969ea76f >> 127;\n      if(x & 0x8000000000000000000 > 0) r = r * 0x80000000000162e42fefa3a0df5373bf >> 127;\n      if(x & 0x4000000000000000000 > 0) r = r * 0x800000000000b17217f7d1cff4aac1e1 >> 127;\n      if(x & 0x2000000000000000000 > 0) r = r * 0x80000000000058b90bfbe8e7db95a2f1 >> 127;\n      if(x & 0x1000000000000000000 > 0) r = r * 0x8000000000002c5c85fdf473e61ae1f8 >> 127;\n      if(x & 0x800000000000000000 > 0) r = r * 0x800000000000162e42fefa39f121751c >> 127;\n      if(x & 0x400000000000000000 > 0) r = r * 0x8000000000000b17217f7d1cf815bb96 >> 127;\n      if(x & 0x200000000000000000 > 0) r = r * 0x800000000000058b90bfbe8e7bec1e0d >> 127;\n      if(x & 0x100000000000000000 > 0) r = r * 0x80000000000002c5c85fdf473dee5f17 >> 127;\n      if(x & 0x80000000000000000 > 0) r = r * 0x8000000000000162e42fefa39ef5438f >> 127;\n      if(x & 0x40000000000000000 > 0) r = r * 0x80000000000000b17217f7d1cf7a26c8 >> 127;\n      if(x & 0x20000000000000000 > 0) r = r * 0x8000000000000058b90bfbe8e7bcf4a4 >> 127;\n      if(x & 0x10000000000000000 > 0) r = r * 0x800000000000002c5c85fdf473de72a2 >> 127; /*\n      if(x & 0x8000000000000000 > 0) r = r * 0x80000000000000162e42fefa39ef3765 >> 127;\n      if(x & 0x4000000000000000 > 0) r = r * 0x800000000000000b17217f7d1cf79b37 >> 127;\n      if(x & 0x2000000000000000 > 0) r = r * 0x80000000000000058b90bfbe8e7bcd7d >> 127;\n      if(x & 0x1000000000000000 > 0) r = r * 0x8000000000000002c5c85fdf473de6b6 >> 127;\n      if(x & 0x800000000000000 > 0) r = r * 0x800000000000000162e42fefa39ef359 >> 127;\n      if(x & 0x400000000000000 > 0) r = r * 0x8000000000000000b17217f7d1cf79ac >> 127;\n      if(x & 0x200000000000000 > 0) r = r * 0x800000000000000058b90bfbe8e7bcd6 >> 127;\n      if(x & 0x100000000000000 > 0) r = r * 0x80000000000000002c5c85fdf473de6a >> 127;\n      if(x & 0x80000000000000 > 0) r = r * 0x8000000000000000162e42fefa39ef35 >> 127;\n      if(x & 0x40000000000000 > 0) r = r * 0x80000000000000000b17217f7d1cf79a >> 127;\n      if(x & 0x20000000000000 > 0) r = r * 0x8000000000000000058b90bfbe8e7bcd >> 127;\n      if(x & 0x10000000000000 > 0) r = r * 0x800000000000000002c5c85fdf473de6 >> 127;\n      if(x & 0x8000000000000 > 0) r = r * 0x80000000000000000162e42fefa39ef3 >> 127;\n      if(x & 0x4000000000000 > 0) r = r * 0x800000000000000000b17217f7d1cf79 >> 127;\n      if(x & 0x2000000000000 > 0) r = r * 0x80000000000000000058b90bfbe8e7bc >> 127;\n      if(x & 0x1000000000000 > 0) r = r * 0x8000000000000000002c5c85fdf473de >> 127;\n      if(x & 0x800000000000 > 0) r = r * 0x800000000000000000162e42fefa39ef >> 127;\n      if(x & 0x400000000000 > 0) r = r * 0x8000000000000000000b17217f7d1cf7 >> 127;\n      if(x & 0x200000000000 > 0) r = r * 0x800000000000000000058b90bfbe8e7b >> 127;\n      if(x & 0x100000000000 > 0) r = r * 0x80000000000000000002c5c85fdf473d >> 127;\n      if(x & 0x80000000000 > 0) r = r * 0x8000000000000000000162e42fefa39e >> 127;\n      if(x & 0x40000000000 > 0) r = r * 0x80000000000000000000b17217f7d1cf >> 127;\n      if(x & 0x20000000000 > 0) r = r * 0x8000000000000000000058b90bfbe8e7 >> 127;\n      if(x & 0x10000000000 > 0) r = r * 0x800000000000000000002c5c85fdf473 >> 127;\n      if(x & 0x8000000000 > 0) r = r * 0x80000000000000000000162e42fefa39 >> 127;\n      if(x & 0x4000000000 > 0) r = r * 0x800000000000000000000b17217f7d1c >> 127;\n      if(x & 0x2000000000 > 0) r = r * 0x80000000000000000000058b90bfbe8e >> 127;\n      if(x & 0x1000000000 > 0) r = r * 0x8000000000000000000002c5c85fdf47 >> 127;\n      if(x & 0x800000000 > 0) r = r * 0x800000000000000000000162e42fefa3 >> 127;\n      if(x & 0x400000000 > 0) r = r * 0x8000000000000000000000b17217f7d1 >> 127;\n      if(x & 0x200000000 > 0) r = r * 0x800000000000000000000058b90bfbe8 >> 127;\n      if(x & 0x100000000 > 0) r = r * 0x80000000000000000000002c5c85fdf4 >> 127;\n      if(x & 0x80000000 > 0) r = r * 0x8000000000000000000000162e42fefa >> 127;\n      if(x & 0x40000000 > 0) r = r * 0x80000000000000000000000b17217f7d >> 127;\n      if(x & 0x20000000 > 0) r = r * 0x8000000000000000000000058b90bfbe >> 127;\n      if(x & 0x10000000 > 0) r = r * 0x800000000000000000000002c5c85fdf >> 127;\n      if(x & 0x8000000 > 0) r = r * 0x80000000000000000000000162e42fef >> 127;\n      if(x & 0x4000000 > 0) r = r * 0x800000000000000000000000b17217f7 >> 127;\n      if(x & 0x2000000 > 0) r = r * 0x80000000000000000000000058b90bfb >> 127;\n      if(x & 0x1000000 > 0) r = r * 0x8000000000000000000000002c5c85fd >> 127;\n      if(x & 0x800000 > 0) r = r * 0x800000000000000000000000162e42fe >> 127;\n      if(x & 0x400000 > 0) r = r * 0x8000000000000000000000000b17217f >> 127;\n      if(x & 0x200000 > 0) r = r * 0x800000000000000000000000058b90bf >> 127;\n      if(x & 0x100000 > 0) r = r * 0x80000000000000000000000002c5c85f >> 127;\n      if(x & 0x80000 > 0) r = r * 0x8000000000000000000000000162e42f >> 127;\n      if(x & 0x40000 > 0) r = r * 0x80000000000000000000000000b17217 >> 127;\n      if(x & 0x20000 > 0) r = r * 0x8000000000000000000000000058b90b >> 127;\n      if(x & 0x10000 > 0) r = r * 0x800000000000000000000000002c5c85 >> 127;\n      if(x & 0x8000 > 0) r = r * 0x80000000000000000000000000162e42 >> 127;\n      if(x & 0x4000 > 0) r = r * 0x800000000000000000000000000b1721 >> 127;\n      if(x & 0x2000 > 0) r = r * 0x80000000000000000000000000058b90 >> 127;\n      if(x & 0x1000 > 0) r = r * 0x8000000000000000000000000002c5c8 >> 127;\n      if(x & 0x800 > 0) r = r * 0x800000000000000000000000000162e4 >> 127;\n      if(x & 0x400 > 0) r = r * 0x8000000000000000000000000000b172 >> 127;\n      if(x & 0x200 > 0) r = r * 0x800000000000000000000000000058b9 >> 127;\n      if(x & 0x100 > 0) r = r * 0x80000000000000000000000000002c5c >> 127;\n      if(x & 0x80 > 0) r = r * 0x8000000000000000000000000000162e >> 127;\n      if(x & 0x40 > 0) r = r * 0x80000000000000000000000000000b17 >> 127;\n      if(x & 0x20 > 0) r = r * 0x8000000000000000000000000000058b >> 127;\n      if(x & 0x10 > 0) r = r * 0x800000000000000000000000000002c5 >> 127;\n      if(x & 0x8 > 0) r = r * 0x80000000000000000000000000000162 >> 127;\n      if(x & 0x4 > 0) r = r * 0x800000000000000000000000000000b1 >> 127;\n      if(x & 0x2 > 0) r = r * 0x80000000000000000000000000000058 >> 127;\n      if(x & 0x1 > 0) r = r * 0x8000000000000000000000000000002c >> 127; */\n\n      r >>= 127 -(x >> 121);\n\n      return uint128(r);\n    }\n  }\n}\n\n/**\n * Ethereum smart contract library implementing Yield Math model.\n */\nlibrary YieldMath {\n  using Math64x64 for int128;\n  using Math64x64 for uint128;\n  using Math64x64 for int256;\n  using Math64x64 for uint256;\n  using Exp64x64 for uint128;\n\n  uint128 public constant ONE = 0x10000000000000000; // In 64.64\n  uint256 public constant MAX = type(uint128).max;   // Used for overflow checks\n\n  /**\n   * Calculate the amount of fyToken a user would get for given amount of Base.\n   * https://www.desmos.com/calculator/5nf2xuy6yb\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param baseAmount base amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of fyToken a user would get for given amount of Base\n   */\n  function fyTokenOutForBaseIn(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 baseAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // zx = baseReserves + baseAmount\n      uint256 zx = uint256(baseReserves) + uint256(baseAmount);\n      require(zx <= MAX, \"YieldMath: Too much base in\");\n\n      // zxa = zx ** a\n      uint256 zxa = uint128(zx).pow(a, ONE);\n\n      // sum = za + ya - zxa\n      uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Insufficient fyToken reserves\");\n\n      // result = fyTokenReserves - (sum ** (1/a))\n      uint256 result = uint256(fyTokenReserves) - uint256(uint128(sum).pow(ONE, a));\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of base a user would get for certain amount of fyToken.\n   * https://www.desmos.com/calculator/6jlrre7ybt\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param fyTokenAmount fyToken amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of Base a user would get for given amount of fyToken\n   */\n  function baseOutForFYTokenIn(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 fyTokenAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // yx = fyDayReserves + fyTokenAmount\n      uint256 yx = uint256(fyTokenReserves) + uint256(fyTokenAmount);\n      require(yx <= MAX, \"YieldMath: Too much fyToken in\");\n\n      // yxa = yx ** a\n      uint256 yxa = uint128(yx).pow(a, ONE);\n\n      // sum = za + ya - yxa\n      uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Insufficient base reserves\");\n\n      // result = baseReserves - (sum ** (1/a))\n      uint256 result = uint256(baseReserves) - uint256(uint128(sum).pow(ONE, a));\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of fyToken a user could sell for given amount of Base.\n   * https://www.desmos.com/calculator/0rgnmtckvy\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param baseAmount Base amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of fyToken a user could sell for given amount of Base\n   */\n  function fyTokenInForBaseOut(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 baseAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // zx = baseReserves - baseAmount\n      uint256 zx = uint256(baseReserves) - uint256(baseAmount);\n      require(zx <= MAX, \"YieldMath: Too much base out\");\n\n      // zxa = zx ** a\n      uint256 zxa = uint128(zx).pow(a, ONE);\n\n      // sum = za + ya - zxa\n      uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Resulting fyToken reserves too high\");\n\n      // result = (sum ** (1/a)) - fyTokenReserves\n      uint256 result = uint256(uint128(sum).pow(ONE, a)) - uint256(fyTokenReserves);\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of base a user would have to pay for certain amount of fyToken.\n   * https://www.desmos.com/calculator/ws5oqj8x5i\n   * @param baseReserves Base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param fyTokenAmount fyToken amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of base a user would have to pay for given amount of\n   *         fyToken\n   */\n  function baseInForFYTokenOut(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 fyTokenAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // yx = baseReserves - baseAmount\n      uint256 yx = uint256(fyTokenReserves) - uint256(fyTokenAmount);\n      require(yx <= MAX, \"YieldMath: Too much fyToken out\");\n\n      // yxa = yx ** a\n      uint256 yxa = uint128(yx).pow(a, ONE);\n\n      // sum = za + ya - yxa\n      uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Resulting base reserves too high\");\n\n      // result = (sum ** (1/a)) - baseReserves\n      uint256 result = uint256(uint128(sum).pow(ONE, a)) - uint256(baseReserves);\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max\n\n      return uint128(result);\n    }\n  }\n\n  function _computeA(uint128 timeTillMaturity, int128 k, int128 g) private pure returns (uint128) {\n    unchecked {\n      // t = k * timeTillMaturity\n      int128 t = k.mul(timeTillMaturity.fromUInt());\n      require(t >= 0, \"YieldMath: t must be positive\"); // Meaning neither T or k can be negative\n\n      // a = (1 - gt)\n      int128 a = int128(ONE).sub(g.mul(t));\n      require(a > 0, \"YieldMath: Too far from maturity\");\n      require(a <= int128(ONE), \"YieldMath: g must be positive\");\n\n      return uint128(a);\n    }\n  }\n\n  /**\n   * Estimate in Base the value of reserves at protocol initialization time.\n   *\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param c0 price of base in terms of Base, multiplied by 2^64\n   * @return estimated value of reserves\n   */\n  function initialReservesValue(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 timeTillMaturity,\n    int128 k, int128 c0)\n  external pure returns(uint128) {\n    unchecked {\n      uint256 normalizedBaseReserves = c0.mulu(baseReserves);\n      require(normalizedBaseReserves <= MAX);\n\n      // a = (1 - k * timeTillMaturity)\n      int128 a = int128(ONE).sub(k.mul(timeTillMaturity.fromUInt()));\n      require(a > 0);\n\n      uint256 sum =\n        uint256(uint128(normalizedBaseReserves).pow(uint128(a), ONE)) +\n        uint256(fyTokenReserves.pow(uint128(a), ONE)) >> 1;\n      require(sum <= MAX);\n\n      uint256 result = uint256(uint128(sum).pow(ONE, uint128(a))) << 1;\n      require(result <= MAX);\n\n      return uint128(result);\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-05-yield#h-03-yieldmathsol--log2--or--",
                "Location": "  function log_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      require(x != 0);\n\n      uint b = x;\n\n      uint l = 0xFE000000000000000000000000000000;\n\n      if(b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) l |= 0x1; */\n\n      return uint128(l);\n    }\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. b > 0x100000000000000000000000000000000 may lead to compute error",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/pooltogether/IProtocolYieldSource.sol\";\nimport \"./interfaces/idle/IIdleToken.sol\";\nimport \"./access/AssetManager.sol\";\n\n/// @title An pooltogether yield source for Idle token\n/// @author Sunny Radadiya\ncontract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public idleToken;\n    address public underlyingAsset;\n    uint256 public constant ONE_IDLE_TOKEN = 10**18;\n\n    /// @notice Emitted when the yield source is initialized\n    event IdleYieldSourceInitialized(address indexed idleToken);\n\n    /// @notice Emitted when asset tokens are redeemed from the yield source\n    event RedeemedToken(\n        address indexed from,\n        uint256 shares,\n        uint256 amount\n    );\n\n    /// @notice Emitted when asset tokens are supplied to the yield source\n    event SuppliedTokenTo(\n        address indexed from,\n        uint256 shares,\n        uint256 amount,\n        address indexed to\n    );\n\n    /// @notice Emitted when asset tokens are supplied to sponsor the yield source\n    event Sponsored(\n        address indexed from,\n        uint256 amount\n    );\n\n    /// @notice Emitted when ERC20 tokens other than yield source's idleToken are withdrawn from the yield source\n    event TransferredERC20(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        address indexed token\n    );\n\n    /// @notice Initializes the yield source with Idle Token\n    /// @param _idleToken Idle Token address\n    function initialize(\n        address _idleToken\n    ) public initializer {\n\n        __Ownable_init();\n\n        idleToken = _idleToken;\n        underlyingAsset = IIdleToken(idleToken).token();\n\n        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);\n        emit IdleYieldSourceInitialized(idleToken);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() external view override returns (address) {\n        return underlyingAsset;\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) external view override returns (uint256) {\n        return _sharesToToken(balanceOf(addr));\n    }\n\n    /// @notice Calculates the balance of Total idle Tokens Contract hasv\n    /// @return balance of Idle Tokens\n    function _totalShare() internal view returns(uint256) {\n        return IIdleToken(idleToken).balanceOf(address(this));\n    }\n\n    /// @notice Calculates the number of shares that should be mint or burned when a user deposit or withdraw\n    /// @param tokens Amount of tokens\n    /// return Number of shares\n    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {\n        shares = (tokens * ONE_IDLE_TOKEN) / _price();\n    }\n\n    /// @notice Calculates the number of tokens a user has in the yield source\n    /// @param shares Amount of shares\n    /// return Number of tokens\n    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { \n        tokens = (shares * _price()) / ONE_IDLE_TOKEN;\n    }\n\n    /// @notice Calculates the current price per share\n    /// @return avg idleToken price for this contract\n    function _price() internal view returns (uint256) {\n      return IIdleToken(idleToken).tokenPriceWithFee(address(this));\n    }\n\n    /// @notice Deposit asset tokens to Idle\n    /// @param mintAmount The amount of asset tokens to be deposited\n    /// @return number of minted tokens\n    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {\n        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);\n        return IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));\n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param mintAmount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 mintAmount, address to) external nonReentrant override {\n        uint256 mintedTokenShares = _tokenToShares(mintAmount);\n        _depositToIdle(mintAmount);\n        _mint(to, mintedTokenShares);\n        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);\n    }\n\n    /// @notice Redeems tokens from the yield source from the msg.sender, it burn yield bearing tokens and return token to the sender.\n    /// @param redeemAmount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @return redeemedUnderlyingAsset The actual amount of tokens that were redeemed.\n    function redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256 redeemedUnderlyingAsset) {\n        uint256 redeemedShare = _tokenToShares(redeemAmount);\n        _burn(msg.sender, redeemedShare);\n        redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(redeemedShare);        \n        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);\n        emit RedeemedToken(msg.sender, redeemedShare, redeemAmount);\n    }\n\n    /// @notice Transfer ERC20 tokens other than the idleTokens held by this contract to the recipient address\n    /// @dev This function is only callable by the owner or asset manager\n    /// @param erc20Token The ERC20 token to transfer\n    /// @param to The recipient of the tokens\n    /// @param amount The amount of tokens to transfer\n    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {\n        require(erc20Token != idleToken, \"IdleYieldSource/idleDai-transfer-not-allowed\");\n        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);\n        emit TransferredERC20(msg.sender, to, amount, erc20Token);\n    }\n\n    /// @notice Allows someone to deposit into the yield source without receiving any shares\n    /// @dev This allows anyone to distribute tokens among the share holders\n    /// @param amount The amount of tokens to deposit\n    function sponsor(uint256 amount) external override {\n        _depositToIdle(amount);\n        emit Sponsored(msg.sender, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-06-pooltogether#h-01-user-could-lose-underlying-tokens-when-redeeming-from-the-idleyieldsource",
                "Location": "    function redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256 redeemedUnderlyingAsset) {\n        uint256 redeemedShare = _tokenToShares(redeemAmount);\n        _burn(msg.sender, redeemedShare);\n        redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(redeemedShare);        \n        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);\n        emit RedeemedToken(msg.sender, redeemedShare, redeemAmount);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. ",
                "Repair": "The redeemToken function in IdleYieldSource uses redeemedShare instead of redeemAmount as the input parameter when calling redeemIdleToken of the Idle yield source. As a result, users could get fewer underlying tokens than they should. When burning users\ufffd\ufffd shares, it is correct to use redeemedShare (line 130). However, when redeeming underlying tokens from Idle Finance, redeemAmount should be used instead of redeemedShare (line 131). Usually, the tokenPriceWithFee() is greater than ONE_IDLE_TOKEN, and thus redeemedShare is less than redeemAmount, causing users to get fewer underlying tokens than expected."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./LibMath.sol\";\nimport \"../Interfaces/Types.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport \"./LibPerpetuals.sol\";\n\nlibrary Balances {\n    using LibMath for int256;\n    using LibMath for uint256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant MAX_DECIMALS = 18;\n\n    // Size of a position\n    struct Position {\n        int256 quote;\n        int256 base;\n    }\n\n    // Information about a trade\n    struct Trade {\n        uint256 price;\n        uint256 amount;\n        Perpetuals.Side side;\n    }\n\n    // Contains information about the balance of an account in a Tracer market\n    struct Account {\n        Position position;\n        uint256 totalLeveragedValue;\n        uint256 lastUpdatedIndex;\n        uint256 lastUpdatedGasPrice;\n    }\n\n    /**\n     * @notice Calculates the notional value of a position as base * price\n     * @param position the position the account is currently in\n     * @param price The (fair) price of the base asset\n     * @return Notional value of a position given the price\n     */\n    function notionalValue(Position memory position, uint256 price) internal pure returns (uint256) {\n        /* cast is safe due to semantics of `abs` */\n        return PRBMathUD60x18.mul(uint256(PRBMathSD59x18.abs(position.base)), price);\n    }\n\n    /**\n     * @notice Calculates the margin as quote + base * base_price\n     * @param position The position the account is currently in\n     * @param price The price of the base asset\n     * @return Margin of the position\n     */\n    function margin(Position memory position, uint256 price) internal pure returns (int256) {\n        /*\n         * A cast *must* occur somewhere here in order for this to type check.\n         *\n         * After you've convinced yourself of this, the next intellectual jump\n         * that needs to be made is *what* to cast. We can't cast `quote` as it's\n         * allowed to be negative. We can't cast `base` as it's allowed to be\n         * negative. Thus, by elimination, the only thing we're left with is\n         * `price`.\n         *\n         * `price` has type `uint256` (i.e., it's unsigned). Thus, our below\n         * cast **will** throw iff. `price >= type(int256).max()`.\n         */\n        int256 signedPrice = LibMath.toInt256(price);\n        return position.quote + PRBMathSD59x18.mul(position.base, signedPrice);\n    }\n\n    /**\n     * @notice Calculates the notional value. i.e. the absolute value of a position\n     * @param position The position the account is currently in\n     * @param price The price of the base asset\n     */\n    function leveragedNotionalValue(Position memory position, uint256 price) internal pure returns (uint256) {\n        uint256 _notionalValue = notionalValue(position, price);\n        int256 marginValue = margin(position, price);\n\n        int256 signedNotionalValue = LibMath.toInt256(_notionalValue);\n\n        if (signedNotionalValue - marginValue < 0) {\n            return 0;\n        } else {\n            return uint256(signedNotionalValue - marginValue);\n        }\n    }\n\n    /**\n     * @notice Calculates the minimum margin needed for an account.\n     * Calculated as minMargin = notionalValue / maxLev + 6 * liquidationGasCost\n     *                         = (base * price) / maxLev + 6 * liquidationGasCost\n     * @param position Position to calculate the minimum margin for\n     * @param price Price by which to evaluate the minimum margin\n     * @param liquidationGasCost Cost for liquidation denominated in quote tokens\n     * @param maximumLeverage (True) maximum leverage of a market.\n     *   May be less than the set max leverage of the market because\n     *   of deleveraging\n     * @return Minimum margin of the position given the parameters\n     */\n    function minimumMargin(\n        Position memory position,\n        uint256 price,\n        uint256 liquidationGasCost,\n        uint256 maximumLeverage\n    ) internal pure returns (uint256) {\n        // There should be no Minimum margin when user has no position\n        if (position.base == 0) {\n            return 0;\n        }\n\n        uint256 _notionalValue = notionalValue(position, price);\n\n        uint256 adjustedLiquidationGasCost = liquidationGasCost * 6;\n\n        uint256 minimumMarginWithoutGasCost = PRBMathUD60x18.div(_notionalValue, maximumLeverage);\n\n        return adjustedLiquidationGasCost + minimumMarginWithoutGasCost;\n    }\n\n    /**\n     * @notice Checks the validity of a potential margin given the necessary parameters\n     * @param position The position\n     * @param liquidationGasCost The cost of calling liquidate\n     * @return a bool representing the validity of a margin\n     */\n    function marginIsValid(\n        Balances.Position memory position,\n        uint256 liquidationGasCost,\n        uint256 price,\n        uint256 trueMaxLeverage\n    ) internal pure returns (bool) {\n        uint256 minMargin = minimumMargin(position, price, liquidationGasCost, trueMaxLeverage);\n        int256 _margin = margin(position, price);\n\n        if (_margin < 0) {\n            /* Margin being less than 0 is always invalid, even if position is 0.\n               This could happen if user attempts to over-withdraw */\n            return false;\n        }\n\n        return (uint256(_margin) >= minMargin);\n    }\n\n    /**\n     * @notice Gets the amount that can be matched between two orders\n     *         Calculated as min(amountRemaining)\n     * @param orderA First order\n     * @param fillA Amount of the first order that has been filled\n     * @param orderB Second order\n     * @param fillB Amount of the second order that has been filled\n     * @return Amount matched between two orders\n     */\n    function fillAmount(\n        Perpetuals.Order memory orderA,\n        uint256 fillA,\n        Perpetuals.Order memory orderB,\n        uint256 fillB\n    ) internal pure returns (uint256) {\n        return LibMath.min(orderA.amount - fillA, orderB.amount - fillB);\n    }\n\n    /**\n     * @notice Applies changes to a position given a trade\n     * @param position Position of the people giving the trade\n     * @param trade Amount of the first order that has been filled\n     * @param feeRate Fee rate being applied to the trade\n     * @return New position\n     */\n    function applyTrade(\n        Position memory position,\n        Trade memory trade,\n        uint256 feeRate\n    ) internal pure returns (Position memory) {\n        int256 signedAmount = LibMath.toInt256(trade.amount);\n        int256 signedPrice = LibMath.toInt256(trade.price);\n        int256 quoteChange = PRBMathSD59x18.mul(signedAmount, signedPrice);\n        int256 fee = getFee(trade.amount, trade.price, feeRate);\n\n        int256 newQuote = 0;\n        int256 newBase = 0;\n\n        if (trade.side == Perpetuals.Side.Long) {\n            newBase = position.base + signedAmount;\n            newQuote = position.quote - quoteChange + fee;\n        } else if (trade.side == Perpetuals.Side.Short) {\n            newBase = position.base - signedAmount;\n            newQuote = position.quote + quoteChange - fee;\n        }\n\n        Position memory newPosition = Position(newQuote, newBase);\n\n        return newPosition;\n    }\n\n    /**\n     * @notice Calculates the fee (in quote tokens)\n     * @param amount The position (in base tokens)\n     * @param executionPrice The execution price (denominated in quote/base)\n     * @param feeRate Fee rate being applied to the trade (a %, in WAD)\n     * @return Value of the fee being applied to the trade\n     */\n    function getFee(\n        uint256 amount,\n        uint256 executionPrice,\n        uint256 feeRate\n    ) internal pure returns (int256) {\n        uint256 quoteChange = PRBMathUD60x18.mul(amount, executionPrice);\n\n        int256 fee = PRBMathUD60x18.mul(quoteChange, feeRate).toInt256();\n        return fee;\n    }\n\n    /**\n     * @notice converts a raw token amount to its WAD representation. Used for tokens\n     * that don't have 18 decimal places\n     */\n    function tokenToWad(uint256 tokenDecimals, uint256 amount) internal pure returns (int256) {\n        uint256 scaler = 10**(MAX_DECIMALS - tokenDecimals);\n        return amount.toInt256() * scaler.toInt256();\n    }\n\n    /**\n     * @notice converts a wad token amount to its raw representation.\n     */\n    function wadToToken(uint256 tokenDecimals, uint256 wadAmount) internal pure returns (uint256) {\n        uint256 scaler = uint256(10**(MAX_DECIMALS - tokenDecimals));\n        return uint256(wadAmount / scaler);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-06-tracer#h-04-logic-error-in-fee-subtraction",
                "Location": "    function applyTrade(\n        Position memory position,\n        Trade memory trade,\n        uint256 feeRate\n    ) internal pure returns (Position memory) {\n        int256 signedAmount = LibMath.toInt256(trade.amount);\n        int256 signedPrice = LibMath.toInt256(trade.price);\n        int256 quoteChange = PRBMathSD59x18.mul(signedAmount, signedPrice);\n        int256 fee = getFee(trade.amount, trade.price, feeRate);\n\n        int256 newQuote = 0;\n        int256 newBase = 0;\n\n        if (trade.side == Perpetuals.Side.Long) {\n            newBase = position.base + signedAmount;\n            newQuote = position.quote - quoteChange + fee;\n        } else if (trade.side == Perpetuals.Side.Short) {\n            newBase = position.base - signedAmount;\n            newQuote = position.quote + quoteChange - fee;\n        }\n\n        Position memory newPosition = Position(newQuote, newBase);\n\n        return newPosition;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. In LibBalances.applyTrade(), we need to collect a fee from the trade. However, the current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see TracerPerpetualSwaps.sol L272). This issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../Interfaces/IOracle.sol\";\nimport \"../Interfaces/IChainlinkOracle.sol\";\nimport \"../lib/LibMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\n/**\n * @dev The following is a sample Gas Price Oracle Implementation for a Tracer Oracle.\n *      It references the Chainlink fast gas price and ETH/USD price to get a gas cost\n *      estimate in USD.\n */\ncontract GasOracle is IOracle, Ownable {\n    using LibMath for uint256;\n    IChainlinkOracle public gasOracle;\n    IChainlinkOracle public priceOracle;\n    uint8 public override decimals = 18;\n    uint256 private constant MAX_DECIMALS = 18;\n\n    constructor(address _priceOracle, address _gasOracle) {\n        gasOracle = IChainlinkOracle(_gasOracle); /* Gas cost oracle */\n        priceOracle = IChainlinkOracle(_priceOracle); /* Quote/ETH oracle */\n    }\n\n    /**\n     * @notice Calculates the latest USD/Gas price\n     * @dev Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\n     */\n    function latestAnswer() external view override returns (uint256) {\n        uint256 gasPrice = uint256(gasOracle.latestAnswer());\n        uint256 ethPrice = uint256(priceOracle.latestAnswer());\n\n        uint256 result = PRBMathUD60x18.mul(gasPrice, ethPrice);\n        return result;\n    }\n\n    /**\n     * @notice converts a raw value to a WAD value.\n     * @dev this allows consistency for oracles used throughout the protocol\n     *      and allows oracles to have their decimals changed withou affecting\n     *      the market itself\n     */\n    function toWad(uint256 raw, IChainlinkOracle _oracle) internal view returns (uint256) {\n        IChainlinkOracle oracle = IChainlinkOracle(_oracle);\n        // reset the scaler for consistency\n        uint8 _decimals = oracle.decimals(); // 9\n        require(_decimals <= MAX_DECIMALS, \"GAS: too many decimals\");\n        uint256 scaler = uint256(10**(MAX_DECIMALS - _decimals));\n        return raw * scaler;\n    }\n\n    function setGasOracle(address _gasOracle) public onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasOracle = IChainlinkOracle(_gasOracle);\n    }\n\n    function setPriceOracle(address _priceOracle) public onlyOwner {\n        require(_priceOracle != address(0), \"address(0) given\");\n        priceOracle = IChainlinkOracle(_priceOracle);\n    }\n\n    function setDecimals(uint8 _decimals) external {\n        decimals = _decimals;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-06-tracer#h-06-wrong-price-scale-for-gasoracle",
                "Location": "    constructor(address _priceOracle, address _gasOracle) {\n        gasOracle = IChainlinkOracle(_gasOracle); /* Gas cost oracle */\n        priceOracle = IChainlinkOracle(_priceOracle); /* Quote/ETH oracle */\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The GasOracle uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD. However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it\ufffd\ufffds in 18 decimals. \ufffd\ufffdReturned value is USD/Gas * 10^18 for compatibility with rest of calculations\ufffd\ufffd There is a toWad function that seems to involve scaling but it is never used. The impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported. Recommend checking chainlink.decimals() to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the latestAnswer function always returns the answer in 18 decimals.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {FixedStablecoins} from \"contracts/common/FixedContracts.sol\";\nimport {ICurve3Pool} from \"contracts/interfaces/ICurve.sol\";\n\nimport \"contracts/common/Controllable.sol\";\n\nimport \"contracts/interfaces/IBuoy.sol\";\nimport \"contracts/interfaces/IChainPrice.sol\";\nimport \"contracts/interfaces/IChainlinkAggregator.sol\";\nimport \"contracts/interfaces/IERC20Detailed.sol\";\n\n/// @notice Contract for calculating prices of underlying assets and LP tokens in Curve pool. Also\n///     used to sanity check pool against external oracle, to ensure that pools underlying coin ratios\n///     are within a specific range (measued in BP) of the external oracles coin price ratios.\n///     Sanity check:\n///         The Buoy checks previously recorded (cached) curve coin dy, which it compares against current curve dy,\n///         blocking any interaction that is outside a certain tolerance (BASIS_POINTS). When updting the cached\n///         value, the buoy uses chainlink to ensure that curves prices arent off peg.\ncontract Buoy3Pool is FixedStablecoins, Controllable, IBuoy, IChainPrice {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 TIME_LIMIT = 3000;\n    uint256 public BASIS_POINTS = 20;\n    uint256 constant CHAIN_FACTOR = 100;\n\n    ICurve3Pool public immutable override curvePool;\n    IERC20 public immutable lpToken;\n\n    mapping(uint256 => uint256) lastRatio;\n\n    // Chianlink price feed\n    address public immutable daiUsdAgg;\n    address public immutable usdcUsdAgg;\n    address public immutable usdtUsdAgg;\n\n    mapping(address => mapping(address => uint256)) public tokenRatios;\n\n    event LogNewBasisPointLimit(uint256 oldLimit, uint256 newLimit);\n\n    constructor(\n        address _crv3pool,\n        address poolToken,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals,\n        address[N_COINS] memory aggregators\n    ) public FixedStablecoins(_tokens, _decimals) {\n        curvePool = ICurve3Pool(_crv3pool);\n        lpToken = IERC20(poolToken);\n        daiUsdAgg = aggregators[0];\n        usdcUsdAgg = aggregators[1];\n        usdtUsdAgg = aggregators[2];\n    }\n\n    /// @notice Set limit for how much Curve pool and external oracle is allowed\n    ///     to deviate before failing transactions\n    /// @param newLimit New limit in BP\n    function setBasisPointsLmit(uint256 newLimit) external onlyOwner {\n        uint256 oldLimit = BASIS_POINTS;\n        BASIS_POINTS = newLimit;\n        emit LogNewBasisPointLimit(oldLimit, newLimit);\n    }\n\n    /// @notice Check the health of the Curve pool:\n    ///     Ratios are checked by the following heuristic:\n    ///     Orcale A - Curve\n    ///     Oracle B - External oracle\n    ///     Both oracles establish ratios for a set of stable coins\n    ///         (a, b, c)\n    ///     and product the following set of ratios:\n    ///         (a/a, a/b, a/c), (b/b, b/a, b/c), (c/c, c/a, c/b)\n    ///     It's simply to reduce the number of comparisons to be made\n    ///     in order to have complete coverage of the system ratios:\n    ///         1) ratios between a stable coin and itself can be discarded\n    ///         2) inverted ratios, a/b bs b/a, while producing different results\n    ///             should both reflect the same change in any one of the two\n    ///             underlying assets, but in opposite directions\n    ///     This mean that the following set should provide the necessary coverage checks\n    ///     to establish that the coins pricing is healthy:\n    ///         (a/b, a/c)\n    function safetyCheck() external view override returns (bool) {\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            _ratio = abs(int256(_ratio - lastRatio[i]));\n            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Updated cached curve value with a custom tolerance towards chainlink\n    /// @param tolerance How much difference between curve and chainlink can be tolerated\n    function updateRatiosWithTolerance(uint256 tolerance) external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatiosWithTolerance: !authorized\");\n        return _updateRatios(tolerance);\n    }\n\n    /// @notice Updated cached curve values\n    function updateRatios() external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatios: !authorized\");\n        return _updateRatios(BASIS_POINTS);\n    }\n\n    /// @notice Get USD value for a specific input amount of tokens, slippage included\n    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToUsd(inAmounts, deposit);\n    }\n\n    /// @notice Get estimate USD price of a stablecoin amount\n    /// @param inAmount Token amount\n    /// @param i Index of token\n    function singleStableToUsd(uint256 inAmount, uint256 i) external view override returns (uint256) {\n        uint256[N_COINS] memory inAmounts;\n        inAmounts[i] = inAmount;\n        return _stableToUsd(inAmounts, true);\n    }\n\n    /// @notice Get LP token value of input amount of tokens\n    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToLp(tokenAmounts, deposit);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromUsd(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(_usdToLp(inAmount), i);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromLp(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(inAmount, i);\n    }\n\n    /// @notice Get USD price of LP tokens you receive for a specific input amount of tokens, slippage included\n    function lpToUsd(uint256 inAmount) external view override returns (uint256) {\n        return _lpToUsd(inAmount);\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function usdToLp(uint256 inAmount) external view override returns (uint256) {\n        return _usdToLp(inAmount);\n    }\n\n    /// @notice Split LP token amount to balance of pool tokens\n    /// @param inAmount Amount of LP tokens\n    /// @param totalBalance Total balance of pool\n    function poolBalances(uint256 inAmount, uint256 totalBalance)\n        internal\n        view\n        returns (uint256[N_COINS] memory balances)\n    {\n        uint256[N_COINS] memory _balances;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _balances[i] = (IERC20(getToken(i)).balanceOf(address(curvePool)).mul(inAmount)).div(totalBalance);\n        }\n        balances = _balances;\n    }\n\n    function getVirtualPrice() external view override returns (uint256) {\n        return curvePool.get_virtual_price();\n    }\n\n    // Internal functions\n    function _lpToUsd(uint256 inAmount) internal view returns (uint256) {\n        return inAmount.mul(curvePool.get_virtual_price()).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {\n        require(tokenAmounts.length == N_COINS, \"deposit: !length\");\n        uint256[N_COINS] memory _tokenAmounts;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _tokenAmounts[i] = tokenAmounts[i];\n        }\n        uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);\n        return _lpToUsd(lpAmount);\n    }\n\n    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {\n        require(tokenAmounts.length == N_COINS, \"deposit: !length\");\n        uint256[N_COINS] memory _tokenAmounts;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _tokenAmounts[i] = tokenAmounts[i];\n        }\n        return curvePool.calc_token_amount(_tokenAmounts, deposit);\n    }\n\n    function _singleStableFromLp(uint256 inAmount, int128 i) internal view returns (uint256) {\n        uint256 result = curvePool.calc_withdraw_one_coin(inAmount, i);\n        return result;\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function _usdToLp(uint256 inAmount) internal view returns (uint256) {\n        return inAmount.mul(DEFAULT_DECIMALS_FACTOR).div(curvePool.get_virtual_price());\n    }\n\n    /// @notice Calculate price ratios for stablecoins\n    ///     Get USD price data for stablecoin\n    /// @param i Stablecoin to get USD price for\n    function getPriceFeed(uint256 i) external view override returns (uint256 _price) {\n        _price = uint256(IChainlinkAggregator(getAggregator(i)).latestAnswer());\n    }\n\n    /// @notice Fetch chainlink token ratios\n    /// @param i Token in\n    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) {\n        uint256[3] memory _prices;\n        _prices[0] = uint256(IChainlinkAggregator(getAggregator(0)).latestAnswer());\n        _prices[1] = uint256(IChainlinkAggregator(getAggregator(1)).latestAnswer());\n        _prices[2] = uint256(IChainlinkAggregator(getAggregator(2)).latestAnswer());\n        for (uint256 j = 0; j < 3; j++) {\n            if (i == j) {\n                _ratios[i] = CHAINLINK_PRICE_DECIMAL_FACTOR;\n            } else {\n                _ratios[j] = _prices[i].mul(CHAINLINK_PRICE_DECIMAL_FACTOR).div(_prices[j]);\n            }\n        }\n        return _ratios;\n    }\n\n    function getAggregator(uint256 index) private view returns (address) {\n        if (index == 0) {\n            return daiUsdAgg;\n        } else if (index == 1) {\n            return usdcUsdAgg;\n        } else {\n            return usdtUsdAgg;\n        }\n    }\n\n    /// @notice Get absolute value\n    function abs(int256 x) private pure returns (uint256) {\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n\n    function _updateRatios(uint256 tolerance) private returns (bool) {\n        uint256[N_COINS] memory chainRatios = getTokenRatios(0);\n        uint256[N_COINS] memory newRatios;\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            uint256 check = abs(int256(_ratio) - int256(chainRatios[i].div(CHAIN_FACTOR)));\n            if (check.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > tolerance) {\n                return false;\n            } else {\n                newRatios[i] = _ratio;\n            }\n        }\n        for (uint256 i = 1; i < N_COINS; i++) {\n            lastRatio[i] = newRatios[i];\n        }\n        return true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-06-gro#h-02-buoy3poolsafetycheck-is-not-precise-and-has-some-assumptions",
                "Location": "    function safetyCheck() external view override returns (bool) {\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            _ratio = abs(int256(_ratio - lastRatio[i]));\n            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {\n                return false;\n            }\n        }\n        return true;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The safetyCheck function has several issues that impact how precise the checks are: Only checks if the a/b and a/c ratios are within BASIS_POINTS. By transitivity, b/c is only within 2 * BASIS_POINTS if a/b and a/c are in range. For a more precise check whether both USDC and USDT are within range, b/c must be checked as well. If a/b is within range, this does not imply that b/a is within range. \ufffd\ufffdinverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions\ufffd\ufffd Example: lastRatio = 1.0 ratio: a = 1.0, b = 0.8 => a/b = 1.25, b/a = 0.8 If a/b was used with a 20% range, it\ufffd\ufffdd be out of range, but b/a is in range. The NatSpec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both _ratio and lastRatio are only from Curve. Only _updateRatios checks the oracle. To address this issue, it is recommended to check if b/c is within BASIS_POINTS .",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity ^0.8.0;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/ILPTokenMaster.sol';\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/IController.sol';\nimport './interfaces/IRewardDistribution.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Ownable.sol';\nimport './external/Address.sol';\nimport './external/Clones.sol';\nimport './external/ERC20.sol';\n\nimport './TransferHelper.sol';\n\ncontract LendingPair is TransferHelper {\n\n  // Prevents division by zero and other undesirable behaviour\n  uint public constant MIN_RESERVE = 1000;\n\n  using Address for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public debtOf;\n  mapping (address => mapping (address => uint)) public accountInterestSnapshot;\n  mapping (address => uint) public cumulativeInterestRate; // 100e18 = 100%\n  mapping (address => uint) public totalDebt;\n  mapping (address => IERC20) public lpToken;\n\n  IController public controller;\n  address public tokenA;\n  address public tokenB;\n  uint public lastBlockAccrued;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed token, uint amount);\n  event Borrow(address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n\n  receive() external payable {}\n\n  function initialize(\n    address _lpTokenMaster,\n    address _controller,\n    IERC20 _tokenA,\n    IERC20 _tokenB\n  ) external {\n    require(address(tokenA) == address(0), \"LendingPair: already initialized\");\n    require(address(_tokenA) != address(0) && address(_tokenB) != address(0), \"LendingPair: cannot be ZERO address\");\n\n    controller = IController(_controller);\n    tokenA = address(_tokenA);\n    tokenB = address(_tokenB);\n    lastBlockAccrued = block.number;\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster);\n  }\n\n  function depositRepay(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _depositRepay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function depositRepayETH(address _account) external payable {\n    accrueAccount(_account);\n\n    _depositRepay(_account, address(WETH), msg.value);\n    _depositWeth();\n  }\n\n  function deposit(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _deposit(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrow(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _withdrawBorrow(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function withdrawBorrowETH(uint _amount) external {\n    accrueAccount(msg.sender);\n\n    _withdrawBorrow(address(WETH), _amount);\n    _wethWithdrawTo(msg.sender, _amount);\n    _checkMinReserve(address(WETH));\n  }\n\n  function withdraw(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _withdraw(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function withdrawAll(address _token) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    uint amount = lpToken[address(_token)].balanceOf(msg.sender);\n    _withdraw(_token, amount);\n    _safeTransfer(IERC20(_token), msg.sender, amount);\n  }\n\n  function withdrawAllETH() external {\n    accrueAccount(msg.sender);\n\n    uint amount = lpToken[address(WETH)].balanceOf(msg.sender);\n    _withdraw(address(WETH), amount);\n    _wethWithdrawTo(msg.sender, amount);\n  }\n\n  function borrow(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _borrow(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function repayAll(address _account, address _token) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    uint amount = debtOf[_token][_account];\n    _repay(_account, _token, amount);\n    _safeTransferFrom(_token, msg.sender, amount);\n  }\n\n  function repayAllETH(address _account) external payable {\n    accrueAccount(_account);\n\n    uint amount = debtOf[address(WETH)][_account];\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\n\n    _depositWeth();\n    _repay(_account, address(WETH), amount);\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\n\n    if (refundAmount > 0) {\n      _wethWithdrawTo(msg.sender, refundAmount);\n    }\n  }\n\n  function repay(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _repay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function accrue() public {\n    if (lastBlockAccrued < block.number) {\n      _accrueInterest(tokenA);\n      _accrueInterest(tokenB);\n      lastBlockAccrued = block.number;\n    }\n  }\n\n  function accrueAccount(address _account) public {\n    _distributeReward(_account);\n    accrue();\n    _accrueAccountInterest(_account);\n\n    if (_account != feeRecipient()) {\n      _accrueAccountInterest(feeRecipient());\n    }\n  }\n\n  function accountHealth(address _account) public view returns(uint) {\n\n    if (debtOf[tokenA][_account] == 0 && debtOf[tokenB][_account] == 0) {\n      return controller.LIQ_MIN_HEALTH();\n    }\n\n    uint totalAccountSupply  = _supplyCredit(_account, tokenA, tokenA)  + _supplyCredit(_account, tokenB, tokenA);\n    uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrrow;\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalance(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    return _borrowBalance(_account, _borrowedToken, _returnToken);\n  }\n\n  function supplyBalance(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    return _supplyBalance(_account, _suppliedToken, _returnToken);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return controller.interestRateModel().supplyRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _borrowRatePerBlock(_token);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to uint(-1) to repay all debt, inc. pending interest\n  function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    _accrueAccountInterest(_account);\n    _accrueAccountInterest(feeRecipient());\n    uint health = accountHealth(_account);\n    require(health < controller.LIQ_MIN_HEALTH(), \"LendingPair: account health > LIQ_MIN_HEALTH\");\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);\n    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupply(supplyToken, _account, supplyBurn);\n    _mintSupply(supplyToken, feeRecipient(), systemFee);\n    _burnDebt(_repayToken, _account, _repayAmount);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  function pendingSupplyInterest(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    uint newInterest = _newInterest(lpToken[_token].balanceOf(_account), _token, _account);\n    return newInterest * _lpRate(_token) / 100e18;\n  }\n\n  function pendingBorrowInterest(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _pendingBorrowInterest(_token, _account);\n  }\n\n  function feeRecipient() public view returns(address) {\n    return controller.feeRecipient();\n  }\n\n  function checkAccountHealth(address _account) public view  {\n    uint health = accountHealth(_account);\n    require(health >= controller.LIQ_MIN_HEALTH(), \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount);\n  }\n\n  function _depositRepay(address _account, address _token, uint _amount) internal {\n\n    uint debt = debtOf[_token][_account];\n    uint repayAmount = debt > _amount ? _amount : debt;\n\n    if (repayAmount > 0) {\n      _repay(_account, _token, repayAmount);\n    }\n\n    uint depositAmount = _amount - repayAmount;\n\n    if (depositAmount > 0) {\n      _deposit(_account, _token, depositAmount);\n    }\n  }\n\n  function _withdrawBorrow(address _token, uint _amount) internal {\n\n    uint supplyAmount = lpToken[_token].balanceOf(msg.sender);\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\n\n    if (withdrawAmount > 0) {\n      _withdraw(_token, withdrawAmount);\n    }\n\n    uint borrowAmount = _amount - withdrawAmount;\n\n    if (borrowAmount > 0) {\n      _borrow(_token, borrowAmount);\n    }\n  }\n\n  function _distributeReward(address _account) internal {\n    IRewardDistribution rewardDistribution = controller.rewardDistribution();\n\n    if (address(rewardDistribution) != address(0)) {\n      rewardDistribution.distributeReward(_account, tokenA);\n      rewardDistribution.distributeReward(_account, tokenB);\n    }\n  }\n\n  function _mintSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].mint(_account, _amount);\n    }\n  }\n\n  function _burnSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].burn(_account, _amount);\n    }\n  }\n\n  function _mintDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] += _amount;\n    totalDebt[_token] += _amount;\n  }\n\n  function _burnDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] -= _amount;\n    totalDebt[_token] -= _amount;\n  }\n\n  function _accrueAccountInterest(address _account) internal {\n    uint lpBalanceA = lpToken[tokenA].balanceOf(_account);\n    uint lpBalanceB = lpToken[tokenB].balanceOf(_account);\n\n    _accrueAccountSupply(tokenA, lpBalanceA, _account);\n    _accrueAccountSupply(tokenB, lpBalanceB, _account);\n    _accrueAccountDebt(tokenA, _account);\n    _accrueAccountDebt(tokenB, _account);\n\n    accountInterestSnapshot[tokenA][_account] = cumulativeInterestRate[tokenA];\n    accountInterestSnapshot[tokenB][_account] = cumulativeInterestRate[tokenB];\n  }\n\n  function _accrueAccountSupply(address _token, uint _amount, address _account) internal {\n    if (_amount > 0) {\n      uint supplyInterest   = _newInterest(_amount, _token, _account);\n      uint newSupplyAccount = supplyInterest * _lpRate(_token) / 100e18;\n      uint newSupplySystem  = supplyInterest * _systemRate(_token) / 100e18;\n\n      _mintSupply(_token, _account, newSupplyAccount);\n      _mintSupply(_token, feeRecipient(), newSupplySystem);\n    }\n  }\n\n  function _accrueAccountDebt(address _token, address _account) internal {\n    if (debtOf[_token][_account] > 0) {\n      uint newDebt = _pendingBorrowInterest(_token, _account);\n      _mintDebt(_token, _account, newDebt);\n    }\n  }\n\n  function _withdraw(address _token, uint _amount) internal {\n\n    lpToken[address(_token)].burn(msg.sender, _amount);\n\n    checkAccountHealth(msg.sender);\n\n    emit Withdraw(_token, _amount);\n  }\n\n  function _borrow(address _token, uint _amount) internal {\n\n    require(lpToken[address(_token)].balanceOf(msg.sender) == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _mintDebt(_token, msg.sender, _amount);\n\n    _checkBorrowLimits(_token, msg.sender);\n    checkAccountHealth(msg.sender);\n\n    emit Borrow(_token, _amount);\n  }\n\n  function _repay(address _account, address _token, uint _amount) internal {\n    _burnDebt(_token, _account, _amount);\n    emit Repay(_account, _token, _amount);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n\n    _checkOracleSupport(tokenA);\n    _checkOracleSupport(tokenB);\n\n    require(debtOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _mintSupply(_token, _account, _amount);\n    _checkDepositLimit(_token);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _accrueInterest(address _token) internal {\n    uint blocksElapsed = block.number - lastBlockAccrued;\n    uint newInterest = _borrowRatePerBlock(_token) * blocksElapsed;\n    cumulativeInterestRate[_token] += newInterest;\n  }\n\n  function _createLpToken(address _lpTokenMaster) internal returns(IERC20) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize();\n    return IERC20(newLPToken);\n  }\n\n  function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {\n    if (_amount > 0) {\n      bool success = _token.transfer(_recipient, _amount);\n      require(success, \"LendingPair: transfer failed\");\n      _checkMinReserve(address(_token));\n    }\n  }\n\n  function _wethWithdrawTo(address _to, uint _amount) internal override {\n    if (_amount > 0) {\n      TransferHelper._wethWithdrawTo(_to, _amount);\n      _checkMinReserve(address(WETH));\n    }\n  }\n\n  function _borrowRatePerBlock(address _token) internal view returns(uint) {\n    return controller.interestRateModel().borrowRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n  function _pendingBorrowInterest(address _token, address _account) internal view returns(uint) {\n    return _newInterest(debtOf[_token][_account], _token, _account);\n  }\n\n  function _borrowBalance(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(_borrowedToken, _returnToken, debtOf[_borrowedToken][_account]);\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalance(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(_suppliedToken, _returnToken, lpToken[_suppliedToken].balanceOf(_account));\n  }\n\n  function _supplyCredit(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _supplyBalance(_account, _suppliedToken, _returnToken) * controller.colFactor(_suppliedToken) / 100e18;\n  }\n\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) internal view returns(uint) {\n\n    uint priceFrom = controller.tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();\n    uint priceTo   = controller.tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();\n\n    return _inputAmount * priceFrom / priceTo;\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _checkOracleSupport(address _token) internal view {\n    require(controller.tokenSupported(_token), \"LendingPair: token not supported\");\n  }\n\n  function _checkMinReserve(address _token) internal view {\n    require(IERC20(_token).balanceOf(address(this)) >= MIN_RESERVE, \"LendingPair: below MIN_RESERVE\");\n  }\n\n  function _checkDepositLimit(address _token) internal view {\n    require(controller.depositsEnabled(), \"LendingPair: deposits disabled\");\n\n    uint depositLimit = controller.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require((lpToken[_token].totalSupply()) <= depositLimit, \"LendingPair: deposit limit reached\");\n    }\n  }\n\n  function _checkBorrowLimits(address _token, address _account) internal view {\n    require(controller.borrowingEnabled(), \"LendingPair: borrowing disabled\");\n\n    uint accountBorrowUSD = debtOf[_token][_account] * controller.tokenPrice(_token) / 1e18;\n    require(accountBorrowUSD >= controller.minBorrowUSD(), \"LendingPair: borrow amount below minimum\");\n\n    uint borrowLimit = controller.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebt[_token] <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _systemRate(address _token) internal view returns(uint) {\n    return controller.interestRateModel().systemRate(ILendingPair(address(this)), _token);\n  }\n\n  function _lpRate(address _token) internal view returns(uint) {\n    return 100e18 - _systemRate(_token);\n  }\n\n  function _newInterest(uint _balance, address _token, address _account) internal view returns(uint) {\n    return _balance * (cumulativeInterestRate[_token] - accountInterestSnapshot[_token][_account]) / 100e18;\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-07-wildcredit#h-01-reward-computation-is-wrong",
                "Location": "  function accrueAccount(address _account) public {\n    _distributeReward(_account);\n    accrue();\n    _accrueAccountInterest(_account);\n\n    if (_account != feeRecipient()) {\n      _accrueAccountInterest(feeRecipient());\n    }\n  }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. The LendingPair.accrueAccount function distributes rewards before updating the cumulative supply / borrow indexes as well as the index + balance for the user (by minting supply tokens / debt). This means the percentage of the user\ufffd\ufffds balance to the total is not correct as the total can be updated several times in between.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"../../utils/access/AccessControl.sol\";\nimport \"../../interfaces/vault/IOracle.sol\";\nimport \"../../math/CastBytes32Bytes6.sol\";\n\n\n/**\n * @title CompositeMultiOracle\n */\ncontract CompositeMultiOracle is IOracle, AccessControl {\n    using CastBytes32Bytes6 for bytes32;\n\n    uint8 public constant override decimals = 18;   // All prices are converted to 18 decimals\n\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);\n    event PathSet(bytes6 indexed baseId, bytes6 indexed quoteId, bytes6[] indexed path);\n\n    struct Source {\n        address source;\n        uint8 decimals;\n    }\n\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n    mapping(bytes6 => mapping(bytes6 => bytes6[])) public paths;\n\n    /**\n     * @notice Set or reset an oracle source\n     */\n    function setSource(bytes6 base, bytes6 quote, address source) external auth {\n        _setSource(base, quote, source);\n    }\n\n    /**\n     * @notice Set or reset a number of oracle sources\n     */\n    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) external auth {\n        require(\n            bases.length == quotes.length && \n            bases.length == sources_.length,\n            \"Mismatched inputs\"\n        );\n        for (uint256 i = 0; i < bases.length; i++) {\n            _setSource(bases[i], quotes[i], sources_[i]);\n        }\n    }\n\n    /**\n     * @notice Set or reset an price path\n     */\n    function setPath(bytes6 base, bytes6 quote, bytes6[] memory path) external auth {\n        _setPath(base, quote, path);\n    }\n\n    /**\n     * @notice Set or reset a number of price paths\n     */\n    function setPaths(bytes6[] memory bases, bytes6[] memory quotes, bytes6[][] memory paths_) external auth {\n        require(\n            bases.length == quotes.length && \n            bases.length == paths_.length,\n            \"Mismatched inputs\"\n        );\n        for (uint256 i = 0; i < bases.length; i++) {\n            _setPath(bases[i], quotes[i], paths_[i]);\n        }\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount)\n        external view virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price = 1e18;\n        bytes6 base_ = base.b6();\n        bytes6 quote_ = quote.b6();\n        bytes6[] memory path = paths[base_][quote_];\n        for (uint256 p = 0; p < path.length; p++) {\n            (price, updateTime) = _peek(base_, path[p], price, updateTime);\n            base_ = path[p];\n        }\n        (price, updateTime) = _peek(base_, quote_, price, updateTime);\n        value = price * amount / 1e18;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.. Same as `peek` for this oracle.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount)\n        external virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price = 1e18;\n        bytes6 base_ = base.b6();\n        bytes6 quote_ = quote.b6();\n        bytes6[] memory path = paths[base_][quote_];\n        for (uint256 p = 0; p < path.length; p++) {\n            (price, updateTime) = _get(base_, path[p], price, updateTime);\n            base_ = path[p];\n        }\n        (price, updateTime) = _get(base_, quote_, price, updateTime);\n        value = price * amount / 1e18;\n    }\n\n    function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n        private view returns (uint priceOut, uint updateTimeOut)\n    {\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n        (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);   // Get price for one unit\n        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       // Fixed point according to decimals\n        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time\n    }\n\n    function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n        private returns (uint priceOut, uint updateTimeOut)\n    {\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n        (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit\n        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       // Fixed point according to decimals\n        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time\n    }\n\n    function _setSource(bytes6 base, bytes6 quote, address source) internal {\n        uint8 decimals_ = IOracle(source).decimals();\n        require (decimals_ <= 18, \"Unsupported decimals\");\n        sources[base][quote] = Source({\n            source: source,\n            decimals: decimals_\n        });\n        emit SourceSet(base, quote, source);\n    }\n\n    function _setPath(bytes6 base, bytes6 quote, bytes6[] memory path) internal {\n        bytes6 base_ = base;\n        for (uint256 p = 0; p < path.length; p++) {\n            require (sources[base_][path[p]].source != address(0), \"Source not found\");\n            base_ = path[p];\n        }\n        paths[base][quote] = path;\n        emit PathSet(base, quote, path);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-08-yield#h-01-compositemultioracle-returns-wrong-decimals-for-prices",
                "Location": "    function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n        private view returns (uint priceOut, uint updateTimeOut)\n    {\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n        (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);   // Get price for one unit\n        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       // Fixed point according to decimals\n        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The CompositeMultiOracle.peek/get functions seem to return wrong prices. It\ufffd\ufffds unclear what decimals source.decimals refers to in this case.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IMasterDeployer.sol\";\nimport \"../workInProgress/IMigrator.sol\";\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/ITridentCallee.sol\";\nimport \"../libraries/TridentMath.sol\";\nimport \"./TridentERC20.sol\";\n\n/// @notice Trident exchange pool template with constant product formula for swapping between an ERC-20 token pair.\n/// @dev The reserves are stored as bento shares.\n///      The curve is applied to shares as well. This pool does not care about the underlying amounts.\ncontract ConstantProductPool is IPool, TridentERC20 {\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 1000;\n\n    uint8 internal constant PRECISION = 112;\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\n    uint256 internal constant MAX_FEE_SQUARE = 100000000;\n    uint256 internal constant E18 = uint256(10)**18;\n    uint256 public immutable swapFee;\n    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;\n\n    address public immutable barFeeTo;\n    address public immutable bento;\n    address public immutable masterDeployer;\n    address public immutable token0;\n    address public immutable token1;\n\n    uint256 public barFee;\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast;\n\n    uint112 internal reserve0;\n    uint112 internal reserve1;\n    uint32 internal blockTimestampLast;\n\n    bytes32 public constant override poolIdentifier = \"Trident:ConstantProduct\";\n\n    uint256 internal unlocked;\n    modifier lock() {\n        require(unlocked == 1, \"LOCKED\");\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n    constructor(bytes memory _deployData, address _masterDeployer) {\n        (address _token0, address _token1, uint256 _swapFee, bool _twapSupport) = abi.decode(_deployData, (address, address, uint256, bool));\n\n        // NB Factory ensures that the tokens are sorted\n        require(_token0 != address(0), \"ZERO_ADDRESS\");\n        require(_token0 != _token1, \"IDENTICAL_ADDRESSES\");\n        require(_token0 != address(this), \"INVALID_TOKEN\");\n        require(_token1 != address(this), \"INVALID_TOKEN\");\n        require(_swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");\n\n        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));\n        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));\n        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));\n\n        token0 = _token0;\n        token1 = _token1;\n        swapFee = _swapFee;\n        // @dev This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.\n        unchecked {\n            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;\n        }\n        barFee = abi.decode(_barFee, (uint256));\n        barFeeTo = abi.decode(_barFeeTo, (address));\n        bento = abi.decode(_bento, (address));\n        masterDeployer = _masterDeployer;\n        unlocked = 1;\n        if (_twapSupport) blockTimestampLast = 1;\n    }\n\n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {\n        address recipient = abi.decode(data, (address));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 _totalSupply = totalSupply;\n\n        unchecked {\n            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);\n        }\n\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\n        uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1));\n\n        if (_totalSupply == 0) {\n            require(amount0 > 0 && amount1 > 0, \"INVALID_AMOUNTS\");\n            _mint(address(0), MINIMUM_LIQUIDITY);\n            address migrator = IMasterDeployer(masterDeployer).migrator();\n            if (msg.sender == migrator) {\n                liquidity = IMigrator(migrator).desiredLiquidity();\n                require(liquidity != 0 && liquidity != type(uint256).max, \"BAD_DESIRED_LIQUIDITY\");\n            } else {\n                require(migrator == address(0), \"ONLY_MIGRATOR\");\n                liquidity = computed - MINIMUM_LIQUIDITY;\n            }\n        } else {\n            uint256 k = TridentMath.sqrt(uint256(_reserve0) * _reserve1);\n            liquidity = ((computed - k) * _totalSupply) / k;\n        }\n        require(liquidity != 0, \"INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(recipient, liquidity);\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = TridentMath.sqrt(balance0 * balance1);\n        emit Mint(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 _totalSupply = totalSupply;\n        uint256 liquidity = balanceOf[address(this)];\n\n        unchecked {\n            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);\n        }\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        _transfer(token0, amount0, recipient, unwrapBento);\n        _transfer(token1, amount1, recipient, unwrapBento);\n        // @dev This is safe from underflow - amounts are lesser figures derived from balances.\n        unchecked {\n            balance0 -= amount0;\n            balance1 -= amount1;\n        }\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = TridentMath.sqrt(balance0 * balance1);\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\n    /// - i.e., the user gets a single token out by burning LP tokens.\n    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 _totalSupply = totalSupply;\n        uint256 liquidity = balanceOf[address(this)];\n\n        unchecked {\n            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);\n        }\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        unchecked {\n            if (tokenOut == token1) {\n                // @dev Swap `token0` for `token1`\n                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.\n                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);\n                _transfer(token1, amount1, recipient, unwrapBento);\n                balance1 -= amount1;\n                amountOut = amount1;\n                amount0 = 0;\n            } else {\n                // @dev Swap `token1` for `token0`.\n                require(tokenOut == token0, \"INVALID_OUTPUT_TOKEN\");\n                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);\n                _transfer(token0, amount0, recipient, unwrapBento);\n                balance0 -= amount0;\n                amountOut = amount0;\n                amount1 = 0;\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = TridentMath.sqrt(balance0 * balance1);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        require(_reserve0 > 0, \"POOL_UNINITIALIZED\");\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 amountIn;\n        address tokenOut;\n        unchecked {\n            if (tokenIn == token0) {\n                tokenOut = token1;\n                amountIn = balance0 - _reserve0;\n                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n                balance1 -= amountOut;\n            } else {\n                require(tokenIn == token1, \"INVALID_INPUT_TOKEN\");\n                tokenOut = token0;\n                amountIn = balance1 - reserve1;\n                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n                balance0 -= amountOut;\n            }\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.\n    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(\n            data,\n            (address, address, bool, uint256, bytes)\n        );\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        require(_reserve0 > 0, \"POOL_UNINITIALIZED\");\n        unchecked {\n            if (tokenIn == token0) {\n                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n                _transfer(token1, amountOut, recipient, unwrapBento);\n                ITridentCallee(msg.sender).tridentSwapCallback(context);\n                (uint256 balance0, uint256 balance1) = _balance();\n                require(balance0 - _reserve0 >= amountIn, \"INSUFFICIENT_AMOUNT_IN\");\n                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n                emit Swap(recipient, tokenIn, token1, amountIn, amountOut);\n            } else {\n                require(tokenIn == token1, \"INVALID_INPUT_TOKEN\");\n                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n                _transfer(token0, amountOut, recipient, unwrapBento);\n                ITridentCallee(msg.sender).tridentSwapCallback(context);\n                (uint256 balance0, uint256 balance1) = _balance();\n                require(balance1 - _reserve1 >= amountIn, \"INSUFFICIENT_AMOUNT_IN\");\n                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n                emit Swap(recipient, tokenIn, token0, amountIn, amountOut);\n            }\n        }\n    }\n\n    /// @dev Updates `barFee` for Trident protocol.\n    function updateBarFee() public {\n        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));\n        barFee = abi.decode(_barFee, (uint256));\n    }\n\n    function _getReserves()\n        internal\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _balance() internal view returns (uint256 balance0, uint256 balance1) {\n        // @dev balanceOf(address,address).\n        (, bytes memory _balance0) = bento.staticcall(abi.encodeWithSelector(0xf7888aec, token0, address(this)));\n        balance0 = abi.decode(_balance0, (uint256));\n        // @dev balanceOf(address,address).\n        (, bytes memory _balance1) = bento.staticcall(abi.encodeWithSelector(0xf7888aec, token1, address(this)));\n        balance1 = abi.decode(_balance1, (uint256));\n    }\n\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1,\n        uint32 _blockTimestampLast\n    ) internal {\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, \"OVERFLOW\");\n        if (blockTimestampLast == 0) {\n            // @dev TWAP support is disabled for gas efficiency.\n            reserve0 = uint112(balance0);\n            reserve1 = uint112(balance1);\n        } else {\n            uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n            if (blockTimestamp != _blockTimestampLast && _reserve0 != 0 && _reserve1 != 0) {\n                unchecked {\n                    uint32 timeElapsed = blockTimestamp - _blockTimestampLast;\n                    uint256 price0 = (uint256(_reserve1) << PRECISION) / _reserve0;\n                    price0CumulativeLast += price0 * timeElapsed;\n                    uint256 price1 = (uint256(_reserve0) << PRECISION) / _reserve1;\n                    price1CumulativeLast += price1 * timeElapsed;\n                }\n            }\n            reserve0 = uint112(balance0);\n            reserve1 = uint112(balance1);\n            blockTimestampLast = blockTimestamp;\n        }\n        emit Sync(balance0, balance1);\n    }\n\n    function _mintFee(\n        uint112 _reserve0,\n        uint112 _reserve1,\n        uint256 _totalSupply\n    ) internal returns (uint256 liquidity) {\n        uint256 _kLast = kLast;\n        if (_kLast != 0) {\n            uint256 computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);\n            if (computed > _kLast) {\n                // @dev `barFee` % of increase in liquidity.\n                // It's going to be slightly less than `barFee` % in reality due to the math.\n                liquidity = (_totalSupply * (computed - _kLast) * barFee) / computed / MAX_FEE;\n                if (liquidity != 0) {\n                    _mint(barFeeTo, liquidity);\n                }\n            }\n        }\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveAmountIn,\n        uint256 reserveAmountOut\n    ) internal view returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;\n        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);\n    }\n\n    function _transfer(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            // @dev withdraw(address,address,address,uint256,uint256).\n            (bool success, ) = bento.call(abi.encodeWithSelector(0x97da6d30, token, address(this), to, 0, shares));\n            require(success, \"WITHDRAW_FAILED\");\n        } else {\n            // @dev transfer(address,address,address,uint256).\n            (bool success, ) = bento.call(abi.encodeWithSelector(0xf18d03cc, token, address(this), to, shares));\n            require(success, \"TRANSFER_FAILED\");\n        }\n    }\n\n    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.\n    function _nonOptimalMintFee(\n        uint256 _amount0,\n        uint256 _amount1,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {\n        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);\n        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;\n        if (amount1Optimal <= _amount1) {\n            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);\n        } else {\n            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;\n            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);\n        }\n    }\n\n    function getAssets() public view override returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = token0;\n        assets[1] = token1;\n    }\n\n    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {\n        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();\n        if (tokenIn == token0) {\n            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n        } else {\n            finalAmountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n        }\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        return _getReserves();\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident#h-11-constantproductpoolburnsingle-swap-amount-computations-should-use-balance",
                "Location": "    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 _totalSupply = totalSupply;\n        uint256 liquidity = balanceOf[address(this)];\n\n        unchecked {\n            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);\n        }\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        unchecked {\n            if (tokenOut == token1) {\n                // @dev Swap `token0` for `token1`\n                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.\n                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);\n                _transfer(token1, amount1, recipient, unwrapBento);\n                balance1 -= amount1;\n                amountOut = amount1;\n                amount0 = 0;\n            } else {\n                // @dev Swap `token1` for `token0`.\n                require(tokenOut == token0, \"INVALID_OUTPUT_TOKEN\");\n                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);\n                _transfer(token0, amount0, recipient, unwrapBento);\n                balance0 -= amount0;\n                amountOut = amount0;\n                amount1 = 0;\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = TridentMath.sqrt(balance0 * balance1);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The ConstantProductPool.burnSingle function is basically a burn followed by a swap and must therefore act the same way as calling these two functions sequentially. The token amounts to redeem (amount0, amount1) are computed on the balance (not the reserve). However, the swap amount is then computed on the reserves and not the balance. The burn function would have updated the reserve to the balances and therefore balance should be used here:",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IBentoBoxMinimal.sol\";\nimport \"../interfaces/IMasterDeployer.sol\";\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/ITridentCallee.sol\";\nimport \"./TridentERC20.sol\";\n\n/// @notice Trident exchange pool template with constant mean formula for swapping among an array of ERC-20 tokens.\n/// @dev The reserves are stored as bento shares.\n///      The curve is applied to shares as well. This pool does not care about the underlying amounts.\ncontract IndexPool is IPool, TridentERC20 {\n    event Mint(address indexed sender, address tokenIn, uint256 amountIn, address indexed recipient);\n    event Burn(address indexed sender, address tokenOut, uint256 amountOut, address indexed recipient);\n\n    uint256 public immutable swapFee;\n\n    address public immutable barFeeTo;\n    address public immutable bento;\n    address public immutable masterDeployer;\n\n    uint256 internal constant BASE = 10**18;\n    uint256 internal constant MIN_TOKENS = 2;\n    uint256 internal constant MAX_TOKENS = 8;\n    uint256 internal constant MIN_FEE = BASE / 10**6;\n    uint256 internal constant MAX_FEE = BASE / 10;\n    uint256 internal constant MIN_WEIGHT = BASE;\n    uint256 internal constant MAX_WEIGHT = BASE * 50;\n    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;\n    uint256 internal constant MIN_BALANCE = BASE / 10**12;\n    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;\n    uint256 internal constant MIN_POW_BASE = 1;\n    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;\n    uint256 internal constant POW_PRECISION = BASE / 10**10;\n    uint256 internal constant MAX_IN_RATIO = BASE / 2;\n    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;\n    \n    uint136 internal totalWeight;\n    address[] internal tokens;\n    \n    uint256 public barFee;\n    \n    bytes32 public constant override poolIdentifier = \"Trident:Index\";\n\n    uint256 internal unlocked;\n    modifier lock() {\n        require(unlocked == 1, \"LOCKED\");\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n    mapping(address => Record) public records;\n    struct Record {\n        uint120 reserve;\n        uint136 weight;\n    }\n\n    constructor(bytes memory _deployData, address _masterDeployer) {\n        (address[] memory _tokens, uint136[] memory _weights, uint256 _swapFee) = abi.decode(\n            _deployData,\n            (address[], uint136[], uint256)\n        );\n        // @dev Factory ensures that the tokens are sorted.\n        require(_tokens.length == _weights.length, \"INVALID_ARRAYS\");\n        require(MIN_FEE <= _swapFee && _swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");\n        require(MIN_TOKENS <= _tokens.length && _tokens.length <= MAX_TOKENS, \"INVALID_TOKENS_LENGTH\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(_tokens[i] != address(0), \"ZERO_ADDRESS\");\n            require(MIN_WEIGHT <= _weights[i] && _weights[i] <= MAX_WEIGHT, \"INVALID_WEIGHT\");\n            records[_tokens[i]] = Record({reserve: 0, weight: _weights[i]});\n            tokens.push(_tokens[i]);\n            totalWeight += _weights[i];\n        }\n        \n        require(totalWeight <= MAX_TOTAL_WEIGHT, \"MAX_TOTAL_WEIGHT\");\n        // @dev This burns initial LP supply.\n        _mint(address(0), INIT_POOL_SUPPLY); \n\n        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));\n        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));\n        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));\n        \n        swapFee = _swapFee;\n        barFee = abi.decode(_barFee, (uint256));\n        barFeeTo = abi.decode(_barFeeTo, (address));\n        bento = abi.decode(_bento, (address));\n        masterDeployer = _masterDeployer;\n        unlocked = 1;\n    }\n    \n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {\n        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));\n        \n        uint120 ratio = uint120(_div(toMint, totalSupply));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address tokenIn = tokens[i];\n            uint120 reserve = records[tokenIn].reserve;\n            // @dev If token balance is '0', initialize with `ratio`.\n            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;\n            require(amountIn >= MIN_BALANCE, \"MIN_BALANCE\");\n            // @dev Check Trident router has sent `amountIn` for skim into pool.\n            unchecked { // @dev This is safe from overflow - only logged amounts handled.\n                require(_balance(tokenIn) >= amountIn + reserve, \"NOT_RECEIVED\");\n                records[tokenIn].reserve += amountIn;\n            }\n            emit Mint(msg.sender, tokenIn, amountIn, recipient);\n        }\n        _mint(recipient, toMint);\n        liquidity = toMint;\n    }\n    \n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));\n        \n        uint256 ratio = _div(toBurn, totalSupply);\n        \n        withdrawnAmounts = new TokenAmount[](tokens.length);\n        \n        _burn(address(this), toBurn);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address tokenOut = tokens[i];\n            uint256 balance = records[tokenOut].reserve;\n            uint120 amountOut = uint120(_mul(ratio, balance));\n            require(amountOut != 0, \"ZERO_OUT\");\n            // @dev This is safe from underflow - only logged amounts handled.\n            unchecked {\n                records[tokenOut].reserve -= amountOut;\n            }\n            _transfer(tokenOut, amountOut, recipient, unwrapBento);\n            withdrawnAmounts[i] = TokenAmount({token: tokenOut, amount: amountOut});\n            emit Burn(msg.sender, tokenOut, amountOut, recipient);\n        }\n    }\n    \n    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\n    /// - i.e., the user gets a single token out by burning LP tokens.\n    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(\n            data,\n            (address, address, bool, uint256)\n        );\n\n        Record storage outRecord = records[tokenOut];\n\n        amountOut = _computeSingleOutGivenPoolIn(\n            outRecord.reserve,\n            outRecord.weight,\n            totalSupply,\n            totalWeight,\n            toBurn,\n            swapFee\n        );\n\n        require(amountOut <= _mul(outRecord.reserve, MAX_OUT_RATIO), \"MAX_OUT_RATIO\");\n        // @dev This is safe from underflow - only logged amounts handled.\n        unchecked {\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _burn(address(this), toBurn);\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Burn(msg.sender, tokenOut, amountOut, recipient);\n    }\n    \n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn) = abi.decode(\n            data,\n            (address, address, address, bool, uint256)\n        );\n\n        Record storage inRecord = records[tokenIn];\n        Record storage outRecord = records[tokenOut];\n\n        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);\n        // @dev Check Trident router has sent `amountIn` for skim into pool.\n        unchecked { // @dev This is safe from under/overflow - only logged amounts handled.\n            require(_balance(tokenIn) >= amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n            inRecord.reserve += uint120(amountIn);\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n    \n    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.\n    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (\n            address tokenIn,\n            address tokenOut,\n            address recipient,\n            bool unwrapBento,\n            uint256 amountIn,\n            bytes memory context\n        ) = abi.decode(data, (address, address, address, bool, uint256, bytes));\n\n        Record storage inRecord = records[tokenIn];\n        Record storage outRecord = records[tokenOut];\n\n        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);\n\n        ITridentCallee(msg.sender).tridentSwapCallback(context);\n        // @dev Check Trident router has sent `amountIn` for skim into pool.\n        unchecked { // @dev This is safe from under/overflow - only logged amounts handled.\n            require(_balance(tokenIn) >= amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n            inRecord.reserve += uint120(amountIn);\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n    \n    /// @dev Updates `barFee` for Trident protocol.\n    function updateBarFee() public {\n        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));\n        barFee = abi.decode(_barFee, (uint256));\n    }\n    \n    function _balance(address token) internal view returns (uint256 balance) {\n        (, bytes memory data) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, \n            token, address(this)));\n        balance = abi.decode(data, (uint256));\n    }\n\n    function _getAmountOut(\n        uint256 tokenInAmount,\n        uint256 tokenInBalance,\n        uint256 tokenInWeight,\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight\n    ) internal view returns (uint256 amountOut) {\n        uint256 weightRatio = _div(tokenInWeight, tokenOutWeight);\n        // @dev This is safe from under/overflow - only logged amounts handled.\n        unchecked {\n            uint256 adjustedIn = _mul(tokenInAmount, (BASE - swapFee));\n            uint256 a = _div(tokenInBalance, tokenInBalance + adjustedIn);\n            uint256 b = _compute(a, weightRatio);\n            uint256 c = BASE - b;\n            amountOut = _mul(tokenOutBalance, c);\n        }\n    }\n\n    function _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {\n        require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, \"INVALID_BASE\");\n        \n        uint256 whole = (exp / BASE) * BASE;   \n        uint256 remain = exp - whole;\n        uint256 wholePow = _pow(base, whole / BASE);\n        \n        if (remain == 0) output = wholePow;\n        \n        uint256 partialResult = _powApprox(base, remain, POW_PRECISION);\n        output = _mul(wholePow, partialResult);\n    }\n\n    function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }\n    \n    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n        output = n % 2 != 0 ? a : BASE;\n        for (n /= 2; n != 0; n /= 2) \n            a = a * a;\n            if (n % 2 != 0) output = output * a;\n    }\n    \n    function _powApprox(uint256 base, uint256 exp, uint256 precision) internal pure returns (uint256 sum) {\n        uint256 a = exp;\n        (uint256 x, bool xneg) = _subFlag(base, BASE);\n        uint256 term = BASE;\n        sum = term;\n        bool negative;\n\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BASE;\n            (uint256 c, bool cneg) = _subFlag(a, (bigK - BASE));\n            term = _mul(term, _mul(c, x));\n            term = _div(term, bigK);\n            if (term == 0) break;\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = sum - term;\n            } else {\n                sum = sum + term;\n            }\n        }\n    }\n    \n    function _subFlag(uint256 a, uint256 b) internal pure returns (uint256 difference, bool flag) {\n        // @dev This is safe from underflow - if/else flow performs checks. \n        unchecked {\n            if (a >= b) {\n                (difference, flag) = (a - b, false);\n            } else {\n                (difference, flag) = (b - a, true);\n            }\n        }\n    }\n    \n    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * b;\n        uint256 c1 = c0 + (BASE / 2);\n        c2 = c1 / BASE;\n    }\n    \n    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * BASE;\n        uint256 c1 = c0 + (b / 2);\n        c2 = c1 / b;\n    }\n    \n    function _transfer(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, \n                token, address(this), to, 0, shares));\n            require(success, \"WITHDRAW_FAILED\");\n        } else {\n            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, \n                token, address(this), to, shares));\n            require(success, \"TRANSFER_FAILED\");\n        }\n    }\n    \n    function getAssets() public view override returns (address[] memory assets) {\n        assets = tokens;\n    }\n    \n    function getAmountOut(bytes calldata data) public view override returns (uint256 amountOut) {\n        (\n            uint256 tokenInAmount,\n            uint256 tokenInBalance,\n            uint256 tokenInWeight,\n            uint256 tokenOutBalance,\n            uint256 tokenOutWeight\n        ) = abi.decode(data, (uint256, uint256, uint256, uint256, uint256));\n        amountOut = _getAmountOut(tokenInAmount, tokenInBalance, tokenInWeight, tokenOutBalance, tokenOutWeight);\n    }\n    \n    function getReservesAndWeights() public view returns (uint256[] memory reserves, uint136[] memory weights) {\n        uint256 length = tokens.length;\n        reserves = new uint256[](length);\n        weights = new uint136[](length);\n        // @dev This is safe from overflow - `tokens` `length` is bound to '8'.\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                reserves[i] = records[tokens[i]].reserve;\n                weights[i] = records[tokens[i]].weight;\n            }\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident#h-14-incorrect-usage-of-_pow-in-_computesingleoutgivenpoolin-of-indexpool",
                "Location": "   function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The _computeSingleOutGivenPoolIn function of IndexPool uses the _pow function to calculate tokenOutRatio with the exponent in WAD (i.e., in 18 decimals of precision). However, the _pow function assumes that the given exponent n is not in WAD. (for example, _pow(5, BASE) returns 5 ** (10 ** 18) instead of 5 ** 1). The misuse of the _pow function could causes an integer overflow in the _computeSingleOutGivenPoolIn function and thus prevent any function from calling it.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IBentoBoxMinimal.sol\";\nimport \"../interfaces/IMasterDeployer.sol\";\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/ITridentCallee.sol\";\nimport \"./TridentERC20.sol\";\n\n/// @notice Trident exchange pool template with constant mean formula for swapping among an array of ERC-20 tokens.\n/// @dev The reserves are stored as bento shares.\n///      The curve is applied to shares as well. This pool does not care about the underlying amounts.\ncontract IndexPool is IPool, TridentERC20 {\n    event Mint(address indexed sender, address tokenIn, uint256 amountIn, address indexed recipient);\n    event Burn(address indexed sender, address tokenOut, uint256 amountOut, address indexed recipient);\n\n    uint256 public immutable swapFee;\n\n    address public immutable barFeeTo;\n    address public immutable bento;\n    address public immutable masterDeployer;\n\n    uint256 internal constant BASE = 10**18;\n    uint256 internal constant MIN_TOKENS = 2;\n    uint256 internal constant MAX_TOKENS = 8;\n    uint256 internal constant MIN_FEE = BASE / 10**6;\n    uint256 internal constant MAX_FEE = BASE / 10;\n    uint256 internal constant MIN_WEIGHT = BASE;\n    uint256 internal constant MAX_WEIGHT = BASE * 50;\n    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;\n    uint256 internal constant MIN_BALANCE = BASE / 10**12;\n    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;\n    uint256 internal constant MIN_POW_BASE = 1;\n    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;\n    uint256 internal constant POW_PRECISION = BASE / 10**10;\n    uint256 internal constant MAX_IN_RATIO = BASE / 2;\n    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;\n    \n    uint136 internal totalWeight;\n    address[] internal tokens;\n    \n    uint256 public barFee;\n    \n    bytes32 public constant override poolIdentifier = \"Trident:Index\";\n\n    uint256 internal unlocked;\n    modifier lock() {\n        require(unlocked == 1, \"LOCKED\");\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n    mapping(address => Record) public records;\n    struct Record {\n        uint120 reserve;\n        uint136 weight;\n    }\n\n    constructor(bytes memory _deployData, address _masterDeployer) {\n        (address[] memory _tokens, uint136[] memory _weights, uint256 _swapFee) = abi.decode(\n            _deployData,\n            (address[], uint136[], uint256)\n        );\n        // @dev Factory ensures that the tokens are sorted.\n        require(_tokens.length == _weights.length, \"INVALID_ARRAYS\");\n        require(MIN_FEE <= _swapFee && _swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");\n        require(MIN_TOKENS <= _tokens.length && _tokens.length <= MAX_TOKENS, \"INVALID_TOKENS_LENGTH\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(_tokens[i] != address(0), \"ZERO_ADDRESS\");\n            require(MIN_WEIGHT <= _weights[i] && _weights[i] <= MAX_WEIGHT, \"INVALID_WEIGHT\");\n            records[_tokens[i]] = Record({reserve: 0, weight: _weights[i]});\n            tokens.push(_tokens[i]);\n            totalWeight += _weights[i];\n        }\n        \n        require(totalWeight <= MAX_TOTAL_WEIGHT, \"MAX_TOTAL_WEIGHT\");\n        // @dev This burns initial LP supply.\n        _mint(address(0), INIT_POOL_SUPPLY); \n\n        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));\n        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));\n        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));\n        \n        swapFee = _swapFee;\n        barFee = abi.decode(_barFee, (uint256));\n        barFeeTo = abi.decode(_barFeeTo, (address));\n        bento = abi.decode(_bento, (address));\n        masterDeployer = _masterDeployer;\n        unlocked = 1;\n    }\n    \n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {\n        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));\n        \n        uint120 ratio = uint120(_div(toMint, totalSupply));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address tokenIn = tokens[i];\n            uint120 reserve = records[tokenIn].reserve;\n            // @dev If token balance is '0', initialize with `ratio`.\n            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;\n            require(amountIn >= MIN_BALANCE, \"MIN_BALANCE\");\n            // @dev Check Trident router has sent `amountIn` for skim into pool.\n            unchecked { // @dev This is safe from overflow - only logged amounts handled.\n                require(_balance(tokenIn) >= amountIn + reserve, \"NOT_RECEIVED\");\n                records[tokenIn].reserve += amountIn;\n            }\n            emit Mint(msg.sender, tokenIn, amountIn, recipient);\n        }\n        _mint(recipient, toMint);\n        liquidity = toMint;\n    }\n    \n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));\n        \n        uint256 ratio = _div(toBurn, totalSupply);\n        \n        withdrawnAmounts = new TokenAmount[](tokens.length);\n        \n        _burn(address(this), toBurn);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address tokenOut = tokens[i];\n            uint256 balance = records[tokenOut].reserve;\n            uint120 amountOut = uint120(_mul(ratio, balance));\n            require(amountOut != 0, \"ZERO_OUT\");\n            // @dev This is safe from underflow - only logged amounts handled.\n            unchecked {\n                records[tokenOut].reserve -= amountOut;\n            }\n            _transfer(tokenOut, amountOut, recipient, unwrapBento);\n            withdrawnAmounts[i] = TokenAmount({token: tokenOut, amount: amountOut});\n            emit Burn(msg.sender, tokenOut, amountOut, recipient);\n        }\n    }\n    \n    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\n    /// - i.e., the user gets a single token out by burning LP tokens.\n    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(\n            data,\n            (address, address, bool, uint256)\n        );\n\n        Record storage outRecord = records[tokenOut];\n\n        amountOut = _computeSingleOutGivenPoolIn(\n            outRecord.reserve,\n            outRecord.weight,\n            totalSupply,\n            totalWeight,\n            toBurn,\n            swapFee\n        );\n\n        require(amountOut <= _mul(outRecord.reserve, MAX_OUT_RATIO), \"MAX_OUT_RATIO\");\n        // @dev This is safe from underflow - only logged amounts handled.\n        unchecked {\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _burn(address(this), toBurn);\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Burn(msg.sender, tokenOut, amountOut, recipient);\n    }\n    \n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn) = abi.decode(\n            data,\n            (address, address, address, bool, uint256)\n        );\n\n        Record storage inRecord = records[tokenIn];\n        Record storage outRecord = records[tokenOut];\n\n        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);\n        // @dev Check Trident router has sent `amountIn` for skim into pool.\n        unchecked { // @dev This is safe from under/overflow - only logged amounts handled.\n            require(_balance(tokenIn) >= amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n            inRecord.reserve += uint120(amountIn);\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n    \n    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.\n    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (\n            address tokenIn,\n            address tokenOut,\n            address recipient,\n            bool unwrapBento,\n            uint256 amountIn,\n            bytes memory context\n        ) = abi.decode(data, (address, address, address, bool, uint256, bytes));\n\n        Record storage inRecord = records[tokenIn];\n        Record storage outRecord = records[tokenOut];\n\n        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);\n\n        ITridentCallee(msg.sender).tridentSwapCallback(context);\n        // @dev Check Trident router has sent `amountIn` for skim into pool.\n        unchecked { // @dev This is safe from under/overflow - only logged amounts handled.\n            require(_balance(tokenIn) >= amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n            inRecord.reserve += uint120(amountIn);\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n    \n    /// @dev Updates `barFee` for Trident protocol.\n    function updateBarFee() public {\n        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));\n        barFee = abi.decode(_barFee, (uint256));\n    }\n    \n    function _balance(address token) internal view returns (uint256 balance) {\n        (, bytes memory data) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, \n            token, address(this)));\n        balance = abi.decode(data, (uint256));\n    }\n\n    function _getAmountOut(\n        uint256 tokenInAmount,\n        uint256 tokenInBalance,\n        uint256 tokenInWeight,\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight\n    ) internal view returns (uint256 amountOut) {\n        uint256 weightRatio = _div(tokenInWeight, tokenOutWeight);\n        // @dev This is safe from under/overflow - only logged amounts handled.\n        unchecked {\n            uint256 adjustedIn = _mul(tokenInAmount, (BASE - swapFee));\n            uint256 a = _div(tokenInBalance, tokenInBalance + adjustedIn);\n            uint256 b = _compute(a, weightRatio);\n            uint256 c = BASE - b;\n            amountOut = _mul(tokenOutBalance, c);\n        }\n    }\n\n    function _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {\n        require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, \"INVALID_BASE\");\n        \n        uint256 whole = (exp / BASE) * BASE;   \n        uint256 remain = exp - whole;\n        uint256 wholePow = _pow(base, whole / BASE);\n        \n        if (remain == 0) output = wholePow;\n        \n        uint256 partialResult = _powApprox(base, remain, POW_PRECISION);\n        output = _mul(wholePow, partialResult);\n    }\n\n    function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }\n    \n    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n        output = n % 2 != 0 ? a : BASE;\n        for (n /= 2; n != 0; n /= 2) \n            a = a * a;\n            if (n % 2 != 0) output = output * a;\n    }\n    \n    function _powApprox(uint256 base, uint256 exp, uint256 precision) internal pure returns (uint256 sum) {\n        uint256 a = exp;\n        (uint256 x, bool xneg) = _subFlag(base, BASE);\n        uint256 term = BASE;\n        sum = term;\n        bool negative;\n\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BASE;\n            (uint256 c, bool cneg) = _subFlag(a, (bigK - BASE));\n            term = _mul(term, _mul(c, x));\n            term = _div(term, bigK);\n            if (term == 0) break;\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = sum - term;\n            } else {\n                sum = sum + term;\n            }\n        }\n    }\n    \n    function _subFlag(uint256 a, uint256 b) internal pure returns (uint256 difference, bool flag) {\n        // @dev This is safe from underflow - if/else flow performs checks. \n        unchecked {\n            if (a >= b) {\n                (difference, flag) = (a - b, false);\n            } else {\n                (difference, flag) = (b - a, true);\n            }\n        }\n    }\n    \n    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * b;\n        uint256 c1 = c0 + (BASE / 2);\n        c2 = c1 / BASE;\n    }\n    \n    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * BASE;\n        uint256 c1 = c0 + (b / 2);\n        c2 = c1 / b;\n    }\n    \n    function _transfer(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, \n                token, address(this), to, 0, shares));\n            require(success, \"WITHDRAW_FAILED\");\n        } else {\n            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, \n                token, address(this), to, shares));\n            require(success, \"TRANSFER_FAILED\");\n        }\n    }\n    \n    function getAssets() public view override returns (address[] memory assets) {\n        assets = tokens;\n    }\n    \n    function getAmountOut(bytes calldata data) public view override returns (uint256 amountOut) {\n        (\n            uint256 tokenInAmount,\n            uint256 tokenInBalance,\n            uint256 tokenInWeight,\n            uint256 tokenOutBalance,\n            uint256 tokenOutWeight\n        ) = abi.decode(data, (uint256, uint256, uint256, uint256, uint256));\n        amountOut = _getAmountOut(tokenInAmount, tokenInBalance, tokenInWeight, tokenOutBalance, tokenOutWeight);\n    }\n    \n    function getReservesAndWeights() public view returns (uint256[] memory reserves, uint136[] memory weights) {\n        uint256 length = tokens.length;\n        reserves = new uint256[](length);\n        weights = new uint136[](length);\n        // @dev This is safe from overflow - `tokens` `length` is bound to '8'.\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                reserves[i] = records[tokens[i]].reserve;\n                weights[i] = records[tokens[i]].weight;\n            }\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident#h-15-incorrect-multiplication-in-_computesingleoutgivenpoolin-of-indexpool",
                "Location": "    function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The _computeSingleOutGivenPoolIn function of IndexPool uses the raw multiplication (i.e., *) to calculate the zaz variable. However, since both (BASE - normalizedWeight) and _swapFee are in WAD, the _mul function should be used instead to calculate the correct value of zaz. Otherwise, zaz would be 10 ** 18 times larger than the expected value and causes an integer underflow when calculating amountOut. The incorrect usage of multiplication prevents anyone from calling the function successfully.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-01-controllersetcap-sets-wrong-vault-balance",
                "Location": "_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The Controller.setCap function sets a cap for a strategy and withdraws any excess amounts (_diff). The vault balance is decreased by the entire strategy balance instead of by this _diff",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-07-vaultbalance-mixes-normalized-and-standard-amounts",
                "Location": "for (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The Vault.balance function uses the balanceOfThis function which scales (\ufffd\ufffdnormalizes\ufffd\ufffd) all balances to 18 decimals. Note that balance()\ufffd\ufffds second term IController(manager.controllers(address(this))).balanceOf() is not normalized. The code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-08-vaultwithdraw-mixes-normalized-and-standard-amounts",
                "Location": "// @audit compares unnormalzied output to normalized output\nif (_balance < _amount) {\n    IController _controller = IController(manager.controllers(address(this)));\n    // @audit cannot directly subtract unnormalized\n    uint256 _toWithdraw = _amount.sub(_balance);\n    if (_controller.strategies() > 0) {\n        _controller.withdraw(_output, _toWithdraw);\n    }\n    uint256 _after = IERC20(_output).balanceOf(address(this));\n    uint256 _diff = _after.sub(_balance);\n    if (_diff < _toWithdraw) {\n        _amount = _balance.add(_diff);\n    }\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Note that balance()\ufffd\ufffds second term IController(manager.controllers(address(this))).balanceOf() is not normalized, but it must be. This leads to many issues through the contracts that use balance but don\ufffd\ufffdt treat these values as normalized values. For example, in Vault.withdraw, the computed _amount value is normalized (in 18 decimals). But the uint256 _balance = IERC20(_output).balanceOf(address(this)); value is not normalized but compared to the normalized _amount and even subtracted",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function manualRebalance(uint256 toLock) external whenNotPaused {\n        _onlyGovernance();\n        require(toLock <= MAX_BPS, \"Max is 100%\");\n\n        if (processLocksOnRebalance) {\n            // manualRebalance will revert if you have no expired locks\n            LOCKER.processExpiredLocks(false);\n        }\n\n        if (harvestOnRebalance) {\n            harvest();\n        }\n\n        // Token that is highly liquid\n        uint256 balanceOfWant =\n            IERC20Upgradeable(want).balanceOf(address(this));\n        // CVX uninvested we got from harvest and unlocks\n        uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));\n        // Locked CVX in the locker\n        uint256 balanceInLock = LOCKER.balanceOf(address(this));\n        uint256 totalCVXBalance =\n            balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));\n\n        //Ratios\n        uint256 currentLockRatio =\n            balanceInLock.mul(10**18).div(totalCVXBalance);\n        // Amount we want to have in lock\n        uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);\n        // Amount we want to have in bCVX\n        uint256 toWantRatio =\n            totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);\n\n        // We can't unlock enough, just deposit rest into bCVX\n        if (newLockRatio <= currentLockRatio) {\n            // Deposit into vault\n            uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n            if (toDeposit > 0) {\n                CVX_VAULT.deposit(toDeposit);\n            }\n\n            return;\n        }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-bvecvx#h-01-vecvxstrategymanualrebalance-has-wrong-logic",
                "Location": "if (newLockRatio <= currentLockRatio) {// ...}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The veCVXStrategy.manualRebalance function computes two ratios currentLockRatio and newLockRatio and compares them.\n\nHowever, these ratios compute different things and are not comparable:\n\ncurrentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance) is a percentage value with 18 decimals (i.e. 1e18 = 100%). Its max value can at most be 1e18.\nnewLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS) is a CVX token amount. It\ufffd\ufffds unbounded and just depends on the totalCVXBalance amount.\nThe comparison that follows does not make sense",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@pooltogether/owner-manager-contracts/contracts/Ownable.sol\";\n\nimport \"./PrizeDistributor.sol\";\n\nimport \"./interfaces/IDrawCalculator.sol\";\nimport \"./interfaces/ITicket.sol\";\nimport \"./interfaces/IDrawBuffer.sol\";\nimport \"./interfaces/IPrizeDistributionBuffer.sol\";\nimport \"./interfaces/IDrawBeacon.sol\";\nimport \"./libraries/DrawRingBufferLib.sol\";\n\n/**\n  * @title  PoolTogether V4 DrawCalculator\n  * @author PoolTogether Inc Team\n  * @notice The DrawCalculator calculates a user's prize by matching a winning random number against\n            their picks. A users picks are generated deterministically based on their address and balance\n            of tickets held. Prize payouts are divided into multiple tiers: grand prize, second place, etc...\n            A user with a higher average weighted balance (during each draw period) will be given a large number of\n            picks to choose from, and thus a higher chance to match the winning numbers.\n*/\ncontract DrawCalculator is IDrawCalculator, Ownable {\n\n    /// @notice DrawBuffer address\n    IDrawBuffer public immutable drawBuffer;\n\n    /// @notice Ticket associated with DrawCalculator\n    ITicket public immutable ticket;\n\n    /// @notice The stored history of draw settings.  Stored as ring buffer.\n    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;\n\n    /// @notice The tiers array length\n    uint8 public constant TIERS_LENGTH = 16;\n\n    /* ============ Constructor ============ */\n\n    /// @notice Constructor for DrawCalculator\n    /// @param _owner Address of the DrawCalculator owner\n    /// @param _ticket Ticket associated with this DrawCalculator\n    /// @param _drawBuffer The address of the draw buffer to push draws to\n    /// @param _prizeDistributionBuffer PrizeDistributionBuffer address\n    constructor(\n        address _owner,\n        ITicket _ticket,\n        IDrawBuffer _drawBuffer,\n        IPrizeDistributionBuffer _prizeDistributionBuffer\n    ) Ownable(_owner) {\n        require(address(_ticket) != address(0), \"DrawCalc/ticket-not-zero\");\n        require(address(_prizeDistributionBuffer) != address(0), \"DrawCalc/pdb-not-zero\");\n        require(address(_drawBuffer) != address(0), \"DrawCalc/dh-not-zero\");\n\n        ticket = _ticket;\n        drawBuffer = _drawBuffer;\n        prizeDistributionBuffer = _prizeDistributionBuffer;\n\n        emit Deployed(_ticket, _drawBuffer, _prizeDistributionBuffer);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IDrawCalculator\n    function calculate(\n        address _user,\n        uint32[] calldata _drawIds,\n        bytes calldata _pickIndicesForDraws\n    ) external view override returns (uint256[] memory, bytes memory) {\n        uint64[][] memory pickIndices = abi.decode(_pickIndicesForDraws, (uint64 [][]));\n        require(pickIndices.length == _drawIds.length, \"DrawCalc/invalid-pick-indices-length\");\n\n        // READ list of IDrawBeacon.Draw using the drawIds from drawBuffer\n        IDrawBeacon.Draw[] memory draws = drawBuffer.getDraws(_drawIds);\n\n        // READ list of IPrizeDistributionBuffer.PrizeDistribution using the drawIds\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer\n            .getPrizeDistributions(_drawIds);\n\n        // The userBalances are fractions representing their portion of the liquidity for a draw.\n        uint256[] memory userBalances = _getNormalizedBalancesAt(_user, draws, _prizeDistributions);\n\n        // The users address is hashed once.\n        bytes32 _userRandomNumber = keccak256(abi.encodePacked(_user));\n\n        return _calculatePrizesAwardable(\n                userBalances,\n                _userRandomNumber,\n                draws,\n                pickIndices,\n                _prizeDistributions\n            );\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getDrawBuffer() external view override returns (IDrawBuffer) {\n        return drawBuffer;\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getPrizeDistributionBuffer()\n        external\n        view\n        override\n        returns (IPrizeDistributionBuffer)\n    {\n        return prizeDistributionBuffer;\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getNormalizedBalancesForDrawIds(address _user, uint32[] calldata _drawIds)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        IDrawBeacon.Draw[] memory _draws = drawBuffer.getDraws(_drawIds);\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer\n            .getPrizeDistributions(_drawIds);\n\n        return _getNormalizedBalancesAt(_user, _draws, _prizeDistributions);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Calculates the prizes awardable for each Draw passed.\n     * @param _normalizedUserBalances Fractions representing the user's portion of the liquidity for each draw.\n     * @param _userRandomNumber       Random number of the user to consider over draws\n     * @param _draws                  List of Draws\n     * @param _pickIndicesForDraws    Pick indices for each Draw\n     * @param _prizeDistributions     PrizeDistribution for each Draw\n\n     */\n    function _calculatePrizesAwardable(\n        uint256[] memory _normalizedUserBalances,\n        bytes32 _userRandomNumber,\n        IDrawBeacon.Draw[] memory _draws,\n        uint64[][] memory _pickIndicesForDraws,\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions\n    ) internal pure returns (uint256[] memory prizesAwardable, bytes memory prizeCounts) {\n        \n        uint256[] memory _prizesAwardable = new uint256[](_normalizedUserBalances.length);\n        uint256[][] memory _prizeCounts = new uint256[][](_normalizedUserBalances.length);\n\n        // calculate prizes awardable for each Draw passed\n        for (uint32 drawIndex = 0; drawIndex < _draws.length; drawIndex++) {\n            uint64 totalUserPicks = _calculateNumberOfUserPicks(\n                _prizeDistributions[drawIndex],\n                _normalizedUserBalances[drawIndex]\n            );\n\n            (_prizesAwardable[drawIndex], _prizeCounts[drawIndex]) = _calculate(\n                _draws[drawIndex].winningRandomNumber,\n                totalUserPicks,\n                _userRandomNumber,\n                _pickIndicesForDraws[drawIndex],\n                _prizeDistributions[drawIndex]\n            );\n        }\n        prizeCounts = abi.encode(_prizeCounts);\n        prizesAwardable = _prizesAwardable;\n    }\n\n    /**\n     * @notice Calculates the number of picks a user gets for a Draw, considering the normalized user balance and the PrizeDistribution.\n     * @dev Divided by 1e18 since the normalized user balance is stored as a fixed point 18 number\n     * @param _prizeDistribution The PrizeDistribution to consider\n     * @param _normalizedUserBalance The normalized user balances to consider\n     * @return The number of picks a user gets for a Draw\n     */\n    function _calculateNumberOfUserPicks(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint256 _normalizedUserBalance\n    ) internal pure returns (uint64) {\n        return uint64((_normalizedUserBalance * _prizeDistribution.numberOfPicks) / 1 ether);\n    }\n\n    /**\n     * @notice Calculates the normalized balance of a user against the total supply for timestamps\n     * @param _user The user to consider\n     * @param _draws The draws we are looking at\n     * @param _prizeDistributions The prize tiers to consider (needed for draw timestamp offsets)\n     * @return An array of normalized balances\n     */\n    function _getNormalizedBalancesAt(\n        address _user,\n        IDrawBeacon.Draw[] memory _draws,\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions\n    ) internal view returns (uint256[] memory) {\n        uint64[] memory _timestampsWithStartCutoffTimes = new uint64[](_draws.length);\n        uint64[] memory _timestampsWithEndCutoffTimes = new uint64[](_draws.length);\n\n        // generate timestamps with draw cutoff offsets included\n        for (uint32 i = 0; i < _draws.length; i++) {\n            unchecked {\n                _timestampsWithStartCutoffTimes[i] =\n                    _draws[i].timestamp - _prizeDistributions[i].startTimestampOffset;\n                _timestampsWithEndCutoffTimes[i] =\n                    _draws[i].timestamp - _prizeDistributions[i].endTimestampOffset;\n            }\n        }\n\n        uint256[] memory balances = ticket.getAverageBalancesBetween(\n            _user,\n            _timestampsWithStartCutoffTimes,\n            _timestampsWithEndCutoffTimes\n        );\n\n        uint256[] memory totalSupplies = ticket.getAverageTotalSuppliesBetween(\n            _timestampsWithStartCutoffTimes,\n            _timestampsWithEndCutoffTimes\n        );\n\n        uint256[] memory normalizedBalances = new uint256[](_draws.length);\n\n        // divide balances by total supplies (normalize)\n        for (uint256 i = 0; i < _draws.length; i++) {\n            require(totalSupplies[i] > 0, \"DrawCalc/total-supply-zero\");\n            normalizedBalances[i] = (balances[i] * 1 ether) / totalSupplies[i];\n        }\n\n        return normalizedBalances;\n    }\n\n    /**\n     * @notice Calculates the prize amount for a PrizeDistribution over given picks\n     * @param _winningRandomNumber Draw's winningRandomNumber\n     * @param _totalUserPicks      number of picks the user gets for the Draw\n     * @param _userRandomNumber    users randomNumber for that draw\n     * @param _picks               users picks for that draw\n     * @param _prizeDistribution   PrizeDistribution for that draw\n     * @return prize (if any), prizeCounts (if any)\n     */\n    function _calculate(\n        uint256 _winningRandomNumber,\n        uint256 _totalUserPicks,\n        bytes32 _userRandomNumber,\n        uint64[] memory _picks,\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution\n    ) internal pure returns (uint256 prize, uint256[] memory prizeCounts) {\n        \n        // create bitmasks for the PrizeDistribution\n        uint256[] memory masks = _createBitMasks(_prizeDistribution);\n        uint32 picksLength = uint32(_picks.length);\n        uint256[] memory _prizeCounts = new uint256[](_prizeDistribution.tiers.length);\n\n        uint8 maxWinningTierIndex = 0;\n\n        require(\n            picksLength <= _prizeDistribution.maxPicksPerUser,\n            \"DrawCalc/exceeds-max-user-picks\"\n        );\n\n        // for each pick, find number of matching numbers and calculate prize distributions index\n        for (uint32 index = 0; index < picksLength; index++) {\n            require(_picks[index] < _totalUserPicks, \"DrawCalc/insufficient-user-picks\");\n\n            if (index > 0) {\n                require(_picks[index] > _picks[index - 1], \"DrawCalc/picks-ascending\");\n            }\n\n            // hash the user random number with the pick value\n            uint256 randomNumberThisPick = uint256(\n                keccak256(abi.encode(_userRandomNumber, _picks[index]))\n            );\n\n            uint8 tiersIndex = _calculateTierIndex(\n                randomNumberThisPick,\n                _winningRandomNumber,\n                masks\n            );\n\n            // there is prize for this tier index\n            if (tiersIndex < TIERS_LENGTH) {\n                if (tiersIndex > maxWinningTierIndex) {\n                    maxWinningTierIndex = tiersIndex;\n                }\n                _prizeCounts[tiersIndex]++;\n            }\n        }\n\n        // now calculate prizeFraction given prizeCounts\n        uint256 prizeFraction = 0;\n        uint256[] memory prizeTiersFractions = _calculatePrizeTierFractions(\n            _prizeDistribution,\n            maxWinningTierIndex\n        );\n\n        // multiple the fractions by the prizeCounts and add them up\n        for (\n            uint256 prizeCountIndex = 0;\n            prizeCountIndex <= maxWinningTierIndex;\n            prizeCountIndex++\n        ) {\n            if (_prizeCounts[prizeCountIndex] > 0) {\n                prizeFraction +=\n                    prizeTiersFractions[prizeCountIndex] *\n                    _prizeCounts[prizeCountIndex];\n            }\n        }\n\n        // return the absolute amount of prize awardable\n        // div by 1e9 as prize tiers are base 1e9\n        prize = (prizeFraction * _prizeDistribution.prize) / 1e9; \n        prizeCounts = _prizeCounts;\n    }\n\n    ///@notice Calculates the tier index given the random numbers and masks\n    ///@param _randomNumberThisPick users random number for this Pick\n    ///@param _winningRandomNumber The winning number for this draw\n    ///@param _masks The pre-calculate bitmasks for the prizeDistributions\n    ///@return The position within the prize tier array (0 = top prize, 1 = runner-up prize, etc)\n    function _calculateTierIndex(\n        uint256 _randomNumberThisPick,\n        uint256 _winningRandomNumber,\n        uint256[] memory _masks\n    ) internal pure returns (uint8) {\n        uint8 numberOfMatches = 0;\n        uint8 masksLength = uint8(_masks.length);\n\n        // main number matching loop\n        for (uint8 matchIndex = 0; matchIndex < masksLength; matchIndex++) {\n            uint256 mask = _masks[matchIndex];\n\n            if ((_randomNumberThisPick & mask) != (_winningRandomNumber & mask)) {\n                // there are no more sequential matches since this comparison is not a match\n                return masksLength - numberOfMatches;\n            }\n\n            // else there was a match\n            numberOfMatches++;\n        }\n\n        return masksLength - numberOfMatches;\n    }\n\n    /**\n     * @notice Create an array of bitmasks equal to the PrizeDistribution.matchCardinality length\n     * @param _prizeDistribution The PrizeDistribution to use to calculate the masks\n     * @return An array of bitmasks\n     */\n    function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);\n        uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize\n\n        for (uint8 maskIndex = 0; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {\n            // create mask of width bitRangeSize bits at index\n            uint256 _matchIndexOffset = uint256(maskIndex) * uint256(_prizeDistribution.bitRangeSize);\n            // shift mask bits to correct position and insert in result mask array\n            masks[maskIndex] = _bitRangeMaskValue << _matchIndexOffset;\n        }\n\n        return masks;\n    }\n\n    /**\n     * @notice Calculates the expected prize fraction per PrizeDistributions and distributionIndex\n     * @param _prizeDistribution prizeDistribution struct for Draw\n     * @param _prizeTierIndex Index of the prize tiers array to calculate\n     * @return returns the fraction of the total prize (base 1e18)\n     */\n    function _calculatePrizeTierFraction(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint256 _prizeTierIndex\n    ) internal pure returns (uint256) {\n         // get the prize fraction at that index\n        uint256 prizeFraction = _prizeDistribution.tiers[_prizeTierIndex];\n\n        // calculate number of prizes for that index\n        uint256 numberOfPrizesForIndex = _numberOfPrizesForIndex(\n            _prizeDistribution.bitRangeSize,\n            _prizeTierIndex\n        );\n\n        return prizeFraction / numberOfPrizesForIndex;\n    }\n\n    /**\n     * @notice Generates an array of prize tiers fractions\n     * @param _prizeDistribution prizeDistribution struct for Draw\n     * @param maxWinningTierIndex Max length of the prize tiers array\n     * @return returns an array of prize tiers fractions\n     */\n    function _calculatePrizeTierFractions(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint8 maxWinningTierIndex\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory prizeDistributionFractions = new uint256[](\n            maxWinningTierIndex + 1\n        );\n\n        for (uint8 i = 0; i <= maxWinningTierIndex; i++) {\n            prizeDistributionFractions[i] = _calculatePrizeTierFraction(\n                _prizeDistribution,\n                i\n            );\n        }\n\n        return prizeDistributionFractions;\n    }\n\n    /**\n     * @notice Calculates the number of prizes for a given prizeDistributionIndex\n     * @param _bitRangeSize Bit range size for Draw\n     * @param _prizeTierIndex Index of the prize tier array to calculate\n     * @return returns the fraction of the total prize (base 1e18)\n     */\n    function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);\n        uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;\n\n        while (_prizeTierIndex > 0) {\n            numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);\n            _prizeTierIndex--;\n        }\n\n        return numberOfPrizesForIndex;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-pooltogether#h-01-the-formula-of-number-of-prizes-for-a-degree-is-wrong",
                "Location": "function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)\n    internal\n    pure\n    returns (uint256)\n{\n    uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);\n    uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;\n    while (_prizeTierIndex > 0) {\n        numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);\n        _prizeTierIndex--;\n    }\n    return numberOfPrizesForIndex;\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Due to the miscalculation of number of prizes for a degree, it will be smaller than expected, as a result, prize for a degree will be larger than expected. Making the protocol giving out more prizes than designed.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n            data,\n            (int24, int24, uint128, address, bool)\n        );\n\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n        uint160 currentPrice = price;\n\n        unchecked {\n            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n        }\n\n        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n            uint256(priceLower),\n            uint256(priceUpper),\n            uint256(currentPrice),\n            uint256(amount)\n        );\n\n        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n        unchecked {\n            amount0 += amount0fees;\n            amount1 += amount1fees;\n        }\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }\n\n        _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n\n        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-08-wrong-inequality-when-addingremoving-liquidity-in-current-price-range",
                "Location": "unchecked { if (priceLower < currentPrice && currentPrice < priceUpper) liquidity += uint128(_liquidity);}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The ConcentratedLiquidityPool.mint/burn functions add/remove liquidity when (priceLower < currentPrice && currentPrice < priceUpper). it should  also be changed if priceLower == currentPrice",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n            data,\n            (int24, int24, uint128, address, bool)\n        );\n\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n        uint160 currentPrice = price;\n\n        unchecked {\n            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n        }\n\n        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n            uint256(priceLower),\n            uint256(priceUpper),\n            uint256(currentPrice),\n            uint256(amount)\n        );\n\n        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n        unchecked {\n            amount0 += amount0fees;\n            amount1 += amount1fees;\n        }\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }\n\n        _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n\n        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-10-concentratedliquiditypoolburn-wrong-implementation",
                "Location": "        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers.The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool. However, the current implementation only updated reserves with the fees subtracted. Makes the reserve0 and reserve1 smaller than the current balance0 and balance1.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function cross(\n        mapping(int24 => Tick) storage ticks,\n        int24 nextTickToCross,\n        uint160 secondsPerLiquidity,\n        uint256 currentLiquidity,\n        uint256 feeGrowthGlobal,\n        bool zeroForOne\n    ) internal returns (uint256, int24) {\n        ticks[nextTickToCross].secondsPerLiquidityOutside = secondsPerLiquidity - ticks[nextTickToCross].secondsPerLiquidityOutside;\n        if (zeroForOne) {\n            // Moving forward through the linked list\n            if (nextTickToCross % 2 == 0) {\n                currentLiquidity -= ticks[nextTickToCross].liquidity;\n            } else {\n                currentLiquidity += ticks[nextTickToCross].liquidity;\n            }\n            nextTickToCross = ticks[nextTickToCross].previousTick;\n            ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0;\n        } else {\n            // Moving backwards through the linked list\n            if (nextTickToCross % 2 == 0) {\n                currentLiquidity += ticks[nextTickToCross].liquidity;\n            } else {\n                currentLiquidity -= ticks[nextTickToCross].liquidity;\n            }\n            nextTickToCross = ticks[nextTickToCross].nextTick;\n            ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1;\n        }\n\n        return (currentLiquidity, nextTickToCross);\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-11-concentratedliquiditypool-incorrect-feegrowthglobal-accounting-when-crossing-ticks",
                "Location": "if (zeroForOne) {\n...\nticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0;\n} else {\n...\nticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1;\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Swap fees are taken from the output. Hence, if swapping token0 for token1 (zeroForOne is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0; and in _updateFees(). However, looking at Ticks.cross(), the logic is the reverse, which causes wrong fee accounting.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport './Abstracts.sol';\nimport './Hash.sol';\nimport './Sig.sol';\n\ncontract Swivel {\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\n  mapping (bytes32 => bool) public cancelled;\n  /// @dev maps the key of an order to an amount representing its taken volume\n  mapping (bytes32 => uint256) public filled;\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\n  mapping (address => uint256) public withdrawals;\n\n  string constant public NAME = 'Swivel Finance';\n  string constant public VERSION = '2.0.0';\n  uint256 constant public HOLD = 259200; // obvs could be a smaller uint but packing?\n  bytes32 public immutable domain;\n  address public immutable marketPlace;\n  address public immutable admin;\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\n  uint16[] public fenominator;\n\n  /// @notice Emitted on order cancellation\n  event Cancel (bytes32 indexed key, bytes32 hash);\n  /// @notice Emitted on any initiate*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on any exit*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on token withdrawal scheduling\n  /// @dev token is the address of the token scheduled for withdrawal\n  /// @dev withdrawalTime is the timestamp at which the queued withdrawal will be possible\n  event WithdrawalScheduled (address indexed token, uint256 hold);\n\n  /// @param m deployed MarketPlace contract address\n  constructor(address m) {\n    admin = msg.sender;\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\n    marketPlace = m;\n    fenominator = [200, 600, 400, 200];\n  }\n\n  // ********* INITIATING *************\n\n  /// @notice Allows a user to initiate a position\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Array of Components from valid ECDSA signatures\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i=0; i < o.length; i++) {\n      // If the order filled is NOT an exit\n      if (!o[i].exit) {\n        // if the order filled does NOT involve a vault (nTokens)\n        if (!o[i].vault) {\n          // then the user has called `initiate` against a zcToken initiate and msg.sender is initiating a vault (purchasing nTokens, payingPremium)\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\n        } else {\n          // then the user has called `initiate` against a vault initiate and msg.sender is initiating a zcToken position (splitting and selling nTokens, receivingPremium)\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\n        }\n      } else {\n        if (!o[i].vault) {\n          // then the user has called `initiate` against a zcToken exit and msg.sender is initiating a zcToken position (splitting and selling nTokens, receivingPremium)\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          // then the user has called `initiate` against a vault exit (selling nTokens) and msg.sender is initiating a vault (purchasing nTokens, payingPremium)\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (premium) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    // checks order signature, order cancellation and order expiry\n    bytes32 hash = validOrderHash(o, c);\n\n    // checks the taker amount passed to amount available in the order\n    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');\n    \n    // adds the taker amount to the order's filled amount\n    filled[hash] += a;\n\n    // calculate principal filled and fee\n    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;\n    uint256 fee = ((principalFilled * 1e18) / fenominator[2]) / 1e18;\n\n    // transfer underlying tokens\n    Erc20 uToken = Erc20(o.underlying);\n    uToken.transferFrom(msg.sender, o.maker, a);\n    uToken.transferFrom(o.maker, address(this), principalFilled);\n\n    // deposit underlying to Compound and mint cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    uToken.approve(cTokenAddr, principalFilled); \n    require(CErc20(cTokenAddr).mint(principalFilled) == 0, 'minting CToken failed');\n\n    // mint <principalFilled> zcTokens + nTokens and allocate appropriately in marketplace\n    require(mPlace.custodialInitiate(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'custodial initiate failed');\n\n    // transfer fee in vault notional to swivel (from msg.sender)\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), \"notional fee transfer failed\");\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param o Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require((a <= o.principal - filled[hash]), 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n    uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;\n\n    Erc20 uToken = Erc20(o.underlying);\n    uToken.transferFrom(o.maker, msg.sender, premiumFilled);\n    // transfer principal + fee in underlying to swivel (from sender)\n    uToken.transferFrom(msg.sender, address(this), (a + fee));\n\n    // deposit underlying to Compound and mint cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    uToken.approve(cTokenAddr, a);\n    require(CErc20(cTokenAddr).mint(a) == 0, 'minting CToken Failed');\n    \n    // mint <a> zcTokens + nTokens and allocate appropriately in marketplace\n    require(mPlace.custodialInitiate(o.underlying, o.maturity, msg.sender, o.maker, a), 'custodial initiate failed');\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= ((o.principal - filled[hash])), 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n    uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;\n\n    // transfer underlying tokens - the premium paid + fee in underlying to swivel (from sender)\n    Erc20(o.underlying).transferFrom(msg.sender, o.maker, ((a - premiumFilled) + fee));\n    // transfer <a> zcTokens between users in marketplace\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');\n            \n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;\n    uint256 fee = ((principalFilled * 1e18) / fenominator[2]) / 1e18;\n\n    Erc20(o.underlying).transferFrom(msg.sender, o.maker, a);\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // transfer <principalFilled> vault.notional (nTokens) between users in marketplace\n    require(mPlace.p2pVaultExchange(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'vault exchange failed');\n\n    // transfer fee (in nTokens) to swivel\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), \"notional fee transfer failed\");\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  // ********* EXITING ***************\n\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Components of a valid ECDSA signature\n  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i=0; i < o.length; i++) {\n      // if the order is NOT an exit\n      if (!o[i].exit) {\n        // if the order filled does NOT involve a vault (nTokens)\n          if (!o[i].vault) {\n            // then the user has called `exit` against a zcToken initiate and msg.sender is exiting zcTokens (buying nTokens + redeeming, payingPremium)\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\n          } else {\n            // then the user has called `exit` against a vault initiate and msg.sender is exiting nTokens (selling nTokens, receivingPremium)\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\n          }\n      } else {\n        if (!o[i].vault) {\n           // then the user has called `exit` against a zcToken exit and msg.sender is exiting nTokens (selling nTokens, receivingPremium)\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n           // then the user has called `exit` against a vault exit and msg.sender is exiting zcTokens (buying nTokens + redeeming, payingPremium)\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\n        }   \n      }   \n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');\n\n    filled[hash] += a;       \n\n    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;\n    uint256 fee = ((principalFilled * 1e18) / fenominator[1]) / 1e18;\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.\n    uToken.transferFrom(o.maker, msg.sender, principalFilled - a - fee);\n    // transfer fee in underlying to swivel\n    uToken.transferFrom(o.maker, address(this), fee);\n\n    // transfer <principalFilled> zcTokens from msg.sender to o.maker\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'zcToken exchange failed');\n    \n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n  \n  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');\n    \n    filled[hash] += a;\n        \n    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer premium minus fee from maker to sender\n    uToken.transferFrom(o.maker, msg.sender, premiumFilled - fee);\n\n    // transfer fee in underlying to swivel from sender\n    uToken.transferFrom(msg.sender, address(this), fee);\n\n    // transfer <a> vault.notional (nTokens) from sender to maker\n    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');\n    \n    filled[hash] += a;\n\n    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;\n    \n    // redeem underlying on Compound and burn cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \"compound redemption error\");\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uToken.transfer(o.maker, a - premiumFilled);\n    // transfer premium-fee to floating exit party\n    uToken.transfer(msg.sender, premiumFilled - fee);\n\n    // burn zcTokens + nTokens from o.maker and msg.sender respectively\n    require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed');\n\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');\n    \n    filled[hash] += a;\n\n    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;\n    uint256 fee = ((principalFilled * 1e18) / fenominator[1]) / 1e18;\n\n    // redeem underlying on Compound and burn cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    require((CErc20(cTokenAddr).redeemUnderlying(principalFilled) == 0), \"compound redemption error\");\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uToken.transfer(msg.sender, principalFilled - a - fee);\n    uToken.transfer(o.maker, a);\n\n    // burn <principalFilled> zcTokens + nTokens from msg.sender and o.maker respectively\n    require(mPlace.custodialExit(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'custodial exit failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to cancel an order, preventing it from being filled in the future\n  /// @param o Order being cancelled\n  /// @param c Components of a valid ECDSA signature\n  function cancel(Hash.Order calldata o, Sig.Components calldata c) external returns (bool) {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(msg.sender == o.maker, 'sender must be maker');\n\n    cancelled[hash] = true;\n\n    emit Cancel(o.key, hash);\n\n    return true;\n  }\n\n  // ********* ADMINISTRATIVE ***************\n\n  /// @notice Allows the admin to schedule the withdrawal of tokens\n  /// @param e Address of token to withdraw\n  function scheduleWithdrawal(address e) external onlyAdmin(admin) {\n    uint256 when = block.timestamp + HOLD;\n    withdrawals[e] = when;\n    emit WithdrawalScheduled(e, when);\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token withdrawal to block\n  function blockWithdrawal(address e) external onlyAdmin(admin) {\n      withdrawals[e] = 0;\n  }\n\n  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed\n  /// @param e Address of token to withdraw\n  function withdraw(address e) external onlyAdmin(admin) {\n    uint256 when = withdrawals[e];\n    require (when != 0, 'no withdrawal scheduled');\n    require (block.timestamp >= when, 'withdrawal still on hold');\n\n    withdrawals[e] = 0;\n\n    Erc20 token = Erc20(e);\n    token.transfer(admin, token.balanceOf(address(this)));\n  }\n\n  /// @notice Allows the admin to set a new fee denominator\n  /// @param t The index of the new fee denominator\n  /// @param d The new fee denominator\n  function setFee(uint16 t, uint16 d) external onlyAdmin(admin) returns (bool) {\n    fenominator[t] = d;\n    return true;\n  }\n\n  // ********* PROTOCOL UTILITY ***************\n\n  /// @notice Allows users to deposit underlying and in the process split it into/mint \n  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of underlying being deposited\n  function splitUnderlying(address u, uint256 m, uint256 a) external returns (bool) {\n    Erc20 uToken = Erc20(u);\n    uToken.transferFrom(msg.sender, address(this), a);\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(u, m);\n    uToken.approve(cTokenAddr, a);\n    require(CErc20(cTokenAddr).mint(a) == 0, 'minting CToken Failed');\n    require(mPlace.mintZcTokenAddingNotional(u, m, msg.sender, a), 'mint ZcToken adding Notional failed');\n\n    return true;\n  }\n\n  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,\n  /// in the process \"combining\" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function combineTokens(address u, uint256 m, uint256 a) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    require(mPlace.burnZcTokenRemovingNotional(u, m, msg.sender, a), 'burn ZcToken removing Notional failed');\n    address cTokenAddr = mPlace.cTokenAddress(u, m);\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \"compound redemption error\");\n    Erc20(u).transfer(msg.sender, a);\n\n    return true;\n  }\n\n  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(address u, uint256 m, uint256 a) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemZcToken(u, m, msg.sender, a);\n    // redeem underlying from compound\n    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');\n    // transfer underlying back to msg.sender\n    Erc20(u).transfer(msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemVaultInterest(address u, uint256 m) external returns (bool) {\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(u, m, msg.sender);\n    // redeem underlying from compound\n    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');\n    // transfer underlying back to msg.sender\n    Erc20(u).transfer(msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Varifies the validity of an order and it's signature.\n  /// @param o An offline Swivel.Order\n  /// @param c Components of a valid ECDSA signature\n  /// @return the hashed order.\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\n    bytes32 hash = Hash.order(o);\n\n    require(!cancelled[hash], 'order cancelled');\n    require(o.expiry >= block.timestamp, 'order expired');\n    require(o.maker == Sig.recover(Hash.message(domain, hash), c), 'invalid signature');\n\n    return hash;\n  }\n\n  modifier onlyAdmin(address a) {\n    require(msg.sender == a, 'sender must be admin');\n    _;\n  }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-swivel#h-02-swivel-taker-is-charged-fees-twice-in-exitvaultfillingvaultinitiate",
                "Location": "  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');\n    \n    filled[hash] += a;\n        \n    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer premium minus fee from maker to sender\n    uToken.transferFrom(o.maker, msg.sender, premiumFilled - fee);\n\n    // transfer fee in underlying to swivel from sender\n    uToken.transferFrom(msg.sender, address(this), fee);\n\n    // transfer <a> vault.notional (nTokens) from sender to maker\n    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Taker is charged fees twice in exitVaultFillingVaultInitiate() . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker\ufffd\ufffds net balance is premiumFilled - 2*fee",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-mochi#h-01-vault-fails-to-track-debt-correctly-that-leads-to-bad-debt",
                "Location": "    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The contract\ufffd\ufffds debt is inconsistent with the total sum of all users\ufffd\ufffd debt. The bias increases overtime and would break the vault at the end. For simplicity, we assume there\ufffd\ufffds only one user in the vault. Example: User deposits 1.2 M worth of BTC and borrows 1M USDM. The user\ufffd\ufffds debt (details[_id].debt) would be 1.005 M as there\ufffd\ufffds a .5 percent fee. The contract\ufffd\ufffds debt is 1M. BTC price decrease by 20 percent The liquidator tries to liquidate the position. The liquidator repays 1.005 M and the contract tries to sub the debt by 1.005 M The transaction is reverted as details[_id].debt -= _usdm; would raise exception. inaccurate accounting would lead to serious issues. I consider this a high-risk issue.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\ncontract DelegatedStaking is OwnableUpgradeable{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    uint256 constant divider = 10**18; // 18 decimals used for scaling the rates\n    uint128 validatorCoolDown; // how many epochs until validator unstaking is unlocked\n    uint128 delegatorCoolDown; // how many epochs until delegator unstaking is unlocked\n    uint128 maxCapMultiplier;\n    uint128 validatorMinStakedRequired; // minimum # of tokens validator is required to have staked\n    uint128 allocatedTokensPerEpoch; // # of tokens per epoch to be distributed\n    uint128 rewardsLocked; // # of tokens the owner sent to the contract\n    uint128 endEpoch; // the epoch when the contract will be out of allocated reward tokens\n    uint128 totalGlobalShares; // global shares\n    uint128 lastUpdateEpoch; // block # when the global exchange rate was updated last\n    uint128 globalExchangeRate;\n    uint128 validatorsN; // number of validators, used to get validator ids\n    mapping(uint128 => Validator) validators; // id -> validator instance\n    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);\n\n    struct Staking {\n        uint128 staked; // initial CQT amount staked\n        uint128 shares; // # of validator shares that delegate owns\n    }\n    struct Unstaking {\n        uint128 coolDownEnd; // epoch when unstaking can be redeemed\n        uint128 amount;\n    }\n    struct Validator {\n        address _address;\n        address operator;\n        uint128 commissionRate; // validator commission rate\n        uint128 disabledEpoch; // epoch when validator got disabled, if set to 0, validator is enabled\n        uint128 globalShares; // total number of global shares under a validator\n        uint128 lastUpdateGlobalRate; // global exchange rate when the validator was updated the last time\n        uint128 totalShares; // total number of validator shares\n        uint128 delegated; // total number of tokens originally staked/delegated to the validator, this does not include interest\n        uint128 exchangeRate; // validator exchange rate\n        uint128 commissionAvailableToRedeem; // # of CQTs paid to the validator\n        mapping(address => Staking) stakings;\n        mapping(address => Unstaking[]) unstakings;\n    }\n    event RewardTokensDeposited(uint128 amount);\n    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);\n    event ValidatorDisabled(uint128 indexed id);\n    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);\n    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);\n    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);\n    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n    event AllocatedTokensTaken(uint128 amount);\n    event MaxCapMultiplierChanged(uint128 amount);\n    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n    event EmissionRateChanged(uint128 newRate);\n    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);\n    event ValidatorMinStakedRequiredChanged(uint128 amount);\n    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);\n\n    // this is used to have the contract upgradeable\n    function initialize(uint128 minStakedRequired) public initializer {\n        __Ownable_init();\n        validatorMinStakedRequired = minStakedRequired;\n        validatorCoolDown = 180*6646; // ~ 6 months\n        delegatorCoolDown = 28*6646; // ~ 28 days\n        maxCapMultiplier = 10;\n        allocatedTokensPerEpoch = 1*10**18; // should never be 0\n        globalExchangeRate = 10**18; // 1 to 1\n        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);\n    }\n\n    // used to transfer CQT from delegators, validators and the owner to the contract\n    function _transferToContract(address from, uint128 amount) internal {\n        CQT.safeTransferFrom(from, address(this), amount);\n    }\n\n    // used to transfer CQT from contract, for rewards redemption or transferring out unstaked\n    function _transferFromContract(address to, uint128 amount) internal {\n        CQT.safeTransfer(to, amount);\n    }\n\n    // transfer CQT from the owner to the contract for rewards allocation, must change end epoch\n    function depositRewardTokens(uint128 amount) public onlyOwner {\n        require(amount >= allocatedTokensPerEpoch, \"Does not cover least 1 epoch\");\n        require(amount % allocatedTokensPerEpoch == 0, \"Not multiple\");\n        if (endEpoch != 0) {\n            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }\n        }\n        else{\n            unchecked { rewardsLocked += amount; }\n        }\n        _transferToContract(msg.sender, amount);\n        emit RewardTokensDeposited(amount);\n    }\n\n    // transfer reward CQT from the contract to the owner, must change end epoch and not allow transfer from the past\n    function takeOutRewardTokens(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        require(amount % allocatedTokensPerEpoch == 0, \"Not multiple\");\n        if (endEpoch != 0){\n            uint128 currentEpoch = uint128(block.number);\n            uint128 epochs = amount / allocatedTokensPerEpoch;\n            require(endEpoch - epochs > currentEpoch, \"Cannot takeout rewards from past\");\n            unchecked { endEpoch = endEpoch - epochs; }\n        }\n        else{\n            require(rewardsLocked >= amount, \"Amount is greater than available\");\n            unchecked { rewardsLocked -= amount; }\n        }\n        _transferFromContract(msg.sender, amount);\n        emit AllocatedTokensTaken(amount);\n    }\n\n    // update global exchange rate\n    function _updateGlobalExchangeRate() internal {\n        uint128 currentBlock = uint128(block.number);\n        // if the program ended, set update epoch to the end epoch\n        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;\n        if (currentEpoch != lastUpdateEpoch){\n            // when no one has staked anything, do not update the rate\n            if(totalGlobalShares > 0)\n            {\n                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }\n            }\n            lastUpdateEpoch = currentEpoch;\n        }\n    }\n\n    // update validator exchange rate\n    function _updateValidator(Validator storage v) internal {\n        // if validator is disabled, we do not update it since it was updated during disabling transaction\n        if(v.disabledEpoch == 0){\n            if (v.totalShares == 0){\n                // when validator stakes the first time, the exchange rate must be equal to the current global exchange rate\n                v.exchangeRate = globalExchangeRate;\n            }\n            else {\n                // the growth of global exchange rate since the validator was updated the last time\n                uint128 rateDifference;\n                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }\n                // tokens given to the validator and its delegators since last update\n                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);\n                // commission paid out of the tokens\n                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);\n                // increase validator exchange rate by distributing the leftover tokens through the validator shares\n                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);\n                // give commission tokens to the validator\n                unchecked { v.commissionAvailableToRedeem += commissionPaid; }\n            }\n            // set the last update global rate to the current one\n            v.lastUpdateGlobalRate = globalExchangeRate;\n        }\n    }\n    // used to convert global shares or validator shares to CQT\n    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){\n        return uint128(uint256(sharesN) * uint256(rate) / divider);\n    }\n    // used to convert CQT to global shares or validator shares\n    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){\n        return uint128(uint256(amount) * divider / uint256(rate));\n    }\n\n    function stake(uint128 validatorId, uint128 amount) public {\n        _stake(validatorId, amount, true);\n    }\n    // need to update global exchange rate, validator data and then delegator instance\n    // withTransfer set to false when delegators recover unstake, because the tokens are already in the contract\n    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {\n        require(amount >= divider, \"Amount must be at least 1 token\");\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        require(v.disabledEpoch == 0, \"Validator is disabled\");\n        // if this is the first stake, then set the end epoch\n        if (endEpoch == 0){\n            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }\n            rewardsLocked = 0; // no longer used and saves a bit of gas\n        }\n        require(endEpoch > block.number, \"Program ended\");\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        // if staker is validator who self delegates\n        if (msg.sender == v._address){\n            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, \"Amount < min staked required\");\n        }\n        else {\n            // otherwise need to check for max cap\n            uint128 validatorStaked = v.stakings[v._address].staked;\n            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;\n            uint128 newDelegated = v.delegated - validatorStaked + amount;\n            require(newDelegated <= validatorMaxCap, \"Validator max capacity exceeded\");\n        }\n        // it is set to true when there is a stake\n        // it is set to false when we recover delegation from unstaking\n        if (withTransfer)\n            _transferToContract(msg.sender, amount);\n        Staking storage s = v.stakings[msg.sender];\n\n        // update global shares #\n        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);\n        unchecked { totalGlobalShares += globalSharesToAdd; }\n        unchecked { v.globalShares += globalSharesToAdd; }\n\n        // update validator shares #\n        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);\n        unchecked { v.totalShares += newDelegatorSharesN; }\n        unchecked { s.shares += newDelegatorSharesN; }\n        unchecked { v.delegated += amount; }\n        unchecked { s.staked += amount; }\n        emit Staked(validatorId, msg.sender, amount);\n    }\n\n    // need to update global exchange rate, validator data and then delegator instance\n    function unstake(uint128 validatorId, uint128 amount) public {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n        require(s.staked >= amount, \"Staked < amount provided\");\n        bool isValidator = msg.sender == v._address;\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore\n        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n        require(validatorSharesRemove > 0, \"Unstake amount is too small\");\n        if (v.disabledEpoch == 0){\n            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required\n            if (isValidator && endEpoch > block.number){\n                uint128 newValidatorStaked = s.staked - amount;\n                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;\n                uint128 delegated = v.delegated - s.staked;\n                require(delegated <= newValidatorMaxCap, \"Cannot unstake beyond max cap\");\n                require(newValidatorStaked >= validatorMinStakedRequired, \"Unstake > min staked required\");\n            }\n\n            // update global shares #\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            require(globalSharesRemove > 0, \"Unstake amount is too small\");\n            unchecked { totalGlobalShares -= globalSharesRemove;}\n            unchecked { v.globalShares -= globalSharesRemove; }\n\n            // update validator shares #\n            unchecked { v.totalShares -= validatorSharesRemove; }\n            unchecked { v.delegated -= amount; }\n        }\n        unchecked { s.shares -= validatorSharesRemove; }\n        unchecked { s.staked -= amount; }\n\n        // create unstaking instance\n        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);\n        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }\n        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));\n        emit Unstaked(validatorId, msg.sender, amount);\n    }\n\n    // restake unstaked tokens\n    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{\n        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        _stake(validatorId, amount, false);\n        us.amount -= amount;\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if(us.amount == 0)\n            us.coolDownEnd = 0;\n        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);\n    }\n\n    // if amount is 0 then redeem all\n    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {\n        require(beneficiary!=address(0x0), \"Invalid beneficiary\");\n        _updateGlobalExchangeRate();\n        Validator storage v = validators[validatorId];\n        _updateValidator(v);\n        Staking storage s = v.stakings[msg.sender];\n\n        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;\n        if(msg.sender == v._address){\n            if(amount == 0){\n                unchecked { amount = rewards + v.commissionAvailableToRedeem; }\n            }\n            require(rewards + v.commissionAvailableToRedeem >= amount, \"Redeem amount > available\");\n            // first redeem rewards from commission\n            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;\n            // if there is more, redeem  it from regular rewards\n            if (commissionLeftOver == 0){\n                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);\n                unchecked { s.shares -= validatorSharesRemove; }\n                unchecked { v.totalShares -= validatorSharesRemove; }\n            }\n            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);\n            v.commissionAvailableToRedeem = commissionLeftOver;\n        }\n        else {\n            if(amount == 0){\n                amount = rewards;\n            }\n            require(rewards >= amount, \"Redeem amount > available\");\n            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n            unchecked { s.shares -= validatorSharesRemove; }\n            unchecked { v.totalShares -= validatorSharesRemove; }\n        }\n        _transferFromContract(beneficiary, amount);\n\n        // update global shares #\n        // this includes commission and rewards earned\n        // only update if the validator is enabled, otherwise the shares were already excluded during disableValidator call\n        if (v.disabledEpoch == 0){\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            unchecked { totalGlobalShares -= globalSharesRemove; }\n            unchecked { v.globalShares -= globalSharesRemove; }\n        }\n        emit RewardRedeemed(validatorId, beneficiary, amount);\n    }\n\n    // redeem all available rewards\n    function redeemAllRewards( uint128 validatorId, address beneficiary) external {\n        _redeemRewards(validatorId, beneficiary, 0);\n    }\n\n    // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards\n    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {\n        require(amount > 0, \"Amount is 0\");\n        _redeemRewards(validatorId, beneficiary, amount);\n    }\n\n    // add new validator instance\n    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {\n        require(commissionRate < divider, \"Rate must be less than 100%\");\n        uint128 N = validatorsN;\n        validators[N]._address = validator;\n        validators[N].operator = operator;\n        validators[N].commissionRate = commissionRate;\n        emit ValidatorAdded(N, validator, operator);\n        unchecked { validatorsN += 1; }\n    }\n\n    // can only be called by the owner or the validator, disabling will allow validator to fully unstake\n    // validator instance can only be disabled once and can never be reenabled\n    function disableValidator(uint128 validatorId) public {\n        Validator storage v = validators[validatorId];\n        require(v.disabledEpoch == 0, \"Validator is already disabled\");\n        require(v._address == msg.sender || msg.sender == owner(), \"Caller is not owner or validator\");\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;\n        unchecked { totalGlobalShares -= v.globalShares; }\n        emit ValidatorDisabled(validatorId);\n    }\n\n    // change emission rate, should reset end epoch\n    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        uint128 toTransfer;\n        if (endEpoch != 0){\n            _updateGlobalExchangeRate();\n            // get number of epochs from now to the end epoch\n            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;\n            // calculate how much rewards would be distributed with the old emission rate\n            uint128 futureRewards = allocatedTokensPerEpoch * epochs;\n            // calculate how many epochs will be covered\n            uint128 addEpochs = futureRewards / amount;\n            toTransfer = futureRewards % amount;\n            require(addEpochs != 0, \"This amount will end the program\");\n            unchecked { endEpoch = uint128(block.number) + addEpochs; }\n        }\n        else {\n          toTransfer = rewardsLocked % amount;\n        }\n        allocatedTokensPerEpoch = amount;\n        emit EmissionRateChanged(amount);\n        if(toTransfer > 0)\n            _transferFromContract(msg.sender, toTransfer);\n\n    }\n\n    // we assume that we will never set it to less than what is staked already\n    function setMaxCapMultiplier(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Must be greater than 0\");\n        maxCapMultiplier = amount;\n        emit MaxCapMultiplierChanged(amount);\n    }\n\n    // only owner can change commission rate\n    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {\n        require(amount < divider, \"Rate must be less than 100%\");\n        _updateGlobalExchangeRate();\n        _updateValidator(validators[validatorId]);\n        validators[validatorId].commissionRate = amount;\n        emit ValidatorCommissionRateChanged(validatorId, amount);\n    }\n\n    // we are assuming there will never be a case when the owner sets the value to something extremely big and if that happens accidentally, we will just recall the function\n    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {\n        validatorMinStakedRequired = amount;\n        emit ValidatorMinStakedRequiredChanged(amount);\n    }\n\n    // if a validator gets disabled, delegators can redelegate their tokens to another validator\n    // first they need to unstake\n    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {\n        require(validators[oldValidatorId].disabledEpoch != 0, \"Validator is not disabled\");\n        require(validators[oldValidatorId]._address != msg.sender, \"Validator cannot redelegate\");\n        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        _stake(newValidatorId, amount, false);\n        unchecked { us.amount -= amount; }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if(us.amount == 0)\n            us.coolDownEnd = 0;\n        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);\n    }\n\n    // transfer out unlocked unstaked tokens back to the delegator\n    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {\n        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];\n        require( uint128(block.number) > us.coolDownEnd, \"Cooldown period has not ended\" );\n        require(us.amount >= amount, \"Amount is too high\");\n        _transferFromContract(msg.sender, amount);\n        unchecked { us.amount -= amount; }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0)\n            us.coolDownEnd = 0;\n        emit UnstakeRedeemed(validatorId, msg.sender, amount);\n    }\n\n    // returns details of each validator\n    // array index is id\n    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {\n        commissionRates = new uint128[](validatorsN);\n        delegated = new uint128[](validatorsN);\n        for (uint128 i = 0; i < validatorsN; ++i){\n            Validator storage v = validators[i];\n            commissionRates[i] = v.commissionRate;\n            delegated[i] = v.delegated - v.stakings[v._address].staked;\n        }\n        return (commissionRates, delegated);\n    }\n\n    // this follows the same logic as _updateGlobalExchangeRate and _updateValidator\n    // array index is id of validator\n    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {\n       delegated = new uint128[](validatorsN);\n       rewardsAvailable = new uint128[](validatorsN);\n       commissionRewards = new uint128[](validatorsN);\n       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;\n       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;\n       Validator storage v;\n       Staking storage s;\n        for (uint128 i = 0; i < validatorsN; ++i){\n            v = validators[i];\n            s = v.stakings[delegator];\n            delegated[i] = s.staked;\n            if (v.disabledEpoch == 0){\n                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);\n                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);\n                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);\n                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;\n                if(delegator == v._address)\n                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;\n            }\n            else {\n                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;\n                if(delegator == v._address)\n                    commissionRewards[i] = v.commissionAvailableToRedeem;\n            }\n        }\n        return (delegated, rewardsAvailable, commissionRewards);\n    }\n\n    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){\n        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);\n        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-covalent#h-02-unstake-should-update-exchange-rates-first",
                "Location": "    function unstake(uint128 validatorId, uint128 amount) public {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n        require(s.staked >= amount, \"Staked < amount provided\");\n        bool isValidator = msg.sender == v._address;\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore\n        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n        require(validatorSharesRemove > 0, \"Unstake amount is too small\");\n        if (v.disabledEpoch == 0){\n            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required\n            if (isValidator && endEpoch > block.number){\n                uint128 newValidatorStaked = s.staked - amount;\n                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;\n                uint128 delegated = v.delegated - s.staked;\n                require(delegated <= newValidatorMaxCap, \"Cannot unstake beyond max cap\");\n                require(newValidatorStaked >= validatorMinStakedRequired, \"Unstake > min staked required\");\n            }\n\n            // update global shares #\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            require(globalSharesRemove > 0, \"Unstake amount is too small\");\n            unchecked { totalGlobalShares -= globalSharesRemove;}\n            unchecked { v.globalShares -= globalSharesRemove; }\n\n            // update validator shares #\n            unchecked { v.totalShares -= validatorSharesRemove; }\n            unchecked { v.delegated -= amount; }\n        }\n        unchecked { s.shares -= validatorSharesRemove; }\n        unchecked { s.staked -= amount; }\n\n        // create unstaking instance\n        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);\n        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }\n        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));\n        emit Unstaked(validatorId, msg.sender, amount);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. The unstake function does not immediately update the exchange rates. It first computes the validatorSharesRemove = tokensToShares(amount, v.exchangeRate) with the old exchange rate.\n\nOnly afterwards, it updates the exchange rates (if the validator is not disabled)",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport \"../governance/EmergencyPausable.sol\";\nimport \"../utils/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Swap is EmergencyPausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    /// @notice An address to receive swap fees. The 0 address prevents fee\n    ///         withdrawal.\n    address payable public feeRecipient;\n    /// @notice divide by the SWAP_FEE_DIVISOR to get the fee ratio, deducted\n    ///         from the proceeds of each swap.\n    uint256 public swapFee;\n    uint256 public constant SWAP_FEE_DIVISOR = 100_000;\n\n    event SwappedTokens(\n        address tokenSold,\n        address tokenBought,\n        uint256 amountSold,\n        uint256 amountBought,\n        uint256 amountBoughtFee\n    );\n\n    event NewSwapFee(\n        uint256 newSwapFee\n    );\n\n    event NewFeeRecipient(\n        address newFeeRecipient\n    );\n\n    event FeesSwept(\n        address token,\n        uint256 amount,\n        address recipient\n    );\n\n    /// @param owner_ A new contract owner, expected to implement\n    ///               TimelockGovernorWithEmergencyGovernance.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal, and can be set later by\n    ///        governance.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee\n    ///                 ratio charged for each swap.\n    constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {\n        require(owner_ != address(0), \"Swap::constructor: Owner must not be 0\");\n        transferOwnership(owner_);\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the fee taken from each swap's proceeds.\n    /// @dev Only timelocked governance can set the swap fee.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee ratio.\n    function setSwapFee(uint256 swapFee_) external onlyTimelock {\n        require(swapFee_ < SWAP_FEE_DIVISOR, \"Swap::setSwapFee: Swap fee must not exceed 100%\");\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the address permitted to receive swap fees.\n    /// @dev Only timelocked governance can set the fee recipient.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal.\n    function setFeeRecipient(address payable feeRecipient_) external onlyTimelock {\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n    }\n\n    /// @notice Swap by filling a 0x quote.\n    /// @dev Execute a swap by filling a 0x quote, as provided by the 0x API.\n    ///      Charges a governable swap fee that comes out of the bought asset,\n    ///      be it token or ETH. Unfortunately, the fee is also charged on any\n    ///      refunded ETH from 0x protocol fees due to an implementation oddity.\n    ///      This behavior shouldn't impact most users.\n    ///\n    ///      Learn more about the 0x API and quotes at https://0x.org/docs/api\n    /// @param zrxSellTokenAddress The contract address of the token to be sold,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. If selling\n    ///        unwrapped ETH included via msg.value, this should be address(0)\n    /// @param amountToSell Amount of token to sell, with the same precision as\n    ///        zrxSellTokenAddress. This information is also encoded in zrxData.\n    ///        If selling unwrapped ETH via msg.value, this should be 0.\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. To buy\n    ///        unwrapped ETH, use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    /// @param minimumAmountReceived The minimum amount expected to be received\n    ///        from filling the quote, before the swap fee is deducted, in\n    ///        zrxBuyTokenAddress. Reverts if not met\n    /// @param zrxAllowanceTarget Contract address that needs to be approved for\n    ///        zrxSellTokenAddress, as returned by the 0x `/swap/v1/quote` API\n    ///        endpoint. Should be address(0) for purchases uses unwrapped ETH\n    /// @param zrxTo Contract to fill the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param zrxData Data encoding the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param deadline Timestamp after which the swap will be reverted.\n    function swapByQuote(\n        address zrxSellTokenAddress,\n        uint256 amountToSell,\n        address zrxBuyTokenAddress,\n        uint256 minimumAmountReceived,\n        address zrxAllowanceTarget,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 deadline\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            block.timestamp <= deadline,\n            \"Swap::swapByQuote: Deadline exceeded\"\n        );\n        require(\n            !signifiesETHOrZero(zrxSellTokenAddress) || msg.value > 0,\n            \"Swap::swapByQuote: Unwrapped ETH must be swapped via msg.value\"\n        );\n\n        // if zrxAllowanceTarget is 0, this is an ETH sale\n        if (zrxAllowanceTarget != address(0)) {\n            // transfer tokens to this contract\n            IERC20(zrxSellTokenAddress).safeTransferFrom(msg.sender, address(this), amountToSell);\n            // approve token transfer to 0x contracts\n            // TODO (handle approval special cases like USDT, KNC, etc)\n            IERC20(zrxSellTokenAddress).safeIncreaseAllowance(zrxAllowanceTarget, amountToSell);\n        }\n\n        // execute 0x quote\n        (uint256 boughtERC20Amount, uint256 boughtETHAmount) = fillZrxQuote(\n            IERC20(zrxBuyTokenAddress),\n            zrxTo,\n            zrxData,\n            msg.value\n        );\n\n        require(\n            (\n                !signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtERC20Amount >= minimumAmountReceived\n            ) ||\n            (\n                signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtETHAmount >= minimumAmountReceived\n            ),\n            \"Swap::swapByQuote: Minimum swap proceeds requirement not met\"\n        );\n        if (boughtERC20Amount > 0) {\n            // take the swap fee from the ERC20 proceeds and return the rest\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n            IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n            // return any refunded ETH\n            payable(msg.sender).transfer(boughtETHAmount);\n\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtERC20Amount,\n                boughtERC20Amount.sub(toTransfer)\n            );\n        } else {\n\n            // take the swap fee from the ETH proceeds and return the rest. Note\n            // that if any 0x protocol fee is refunded in ETH, it also suffers\n            // the swap fee tax\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n            payable(msg.sender).transfer(toTransfer);\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtETHAmount,\n                boughtETHAmount.sub(toTransfer)\n            );\n        }\n        if (zrxAllowanceTarget != address(0)) {\n            // remove any dangling token allowance\n            IERC20(zrxSellTokenAddress).safeApprove(zrxAllowanceTarget, 0);\n        }\n    }\n\n    /// @notice Fill a 0x quote as provided by the API, and return any ETH or\n    ///         ERC20 proceeds.\n    /// @dev Learn more at https://0x.org/docs/api\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as provided by the 0x API. `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    ///        signifies the user is buying unwrapped ETH.\n    /// @param zrxTo Contract to fill the 0x quote, as provided by the 0x API\n    /// @param zrxData Data encoding the 0x quote, as provided by the 0x API\n    /// @param ethAmount The amount of ETH required to fill the quote, including\n    ///        any ETH being traded as well as protocol fees\n    /// @return any positive `zrxBuyTokenAddress` ERC20 balance change, as well\n    ///         as any positive ETH balance change\n    function fillZrxQuote(\n        IERC20 zrxBuyTokenAddress,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 ethAmount\n    ) internal returns (uint256, uint256) {\n        uint256 originalERC20Balance = 0;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n        }\n        uint256 originalETHBalance = address(this).balance;\n\n        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n        require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n        uint256 erc20Delta;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n            require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n        } else {\n            require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n        }\n\n        return (erc20Delta, ethDelta);\n    }\n\n    /// @notice Test whether an address is zero, or the magic address the 0x\n    ///         platform uses to signify \"unwrapped ETH\" rather than an ERC20.\n    /// @param tokenAddress An address that might point toward an ERC-20.\n    function signifiesETHOrZero(address tokenAddress) internal pure returns (bool) {\n        return (\n            tokenAddress == address(0) ||\n            tokenAddress == address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)\n        );\n    }\n\n    /// @notice Sweeps accrued ETH and ERC20 swap fees to the pre-established\n    ///         fee recipient address.\n    /// @dev Fees are tracked based on the contract's balances, rather than\n    ///      using any additional bookkeeping. If there are bugs in swap\n    ///      accounting, this function could jeopardize funds.\n    /// @param tokens An array of ERC20 contracts to withdraw token fees\n    function sweepFees(\n        address[] calldata tokens\n    ) external nonReentrant {\n        require(\n            feeRecipient != address(0),\n            \"Swap::withdrawAccruedFees: feeRecipient is not initialized\"\n        );\n        for (uint8 i = 0; i<tokens.length; i++) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(tokens[i]).safeTransfer(feeRecipient, balance);\n                emit FeesSwept(tokens[i], balance, feeRecipient);\n            }\n        }\n        feeRecipient.transfer(address(this).balance);\n        emit FeesSwept(address(0), address(this).balance, feeRecipient);\n    }\n\n    fallback() external payable {}\n    receive() external payable {}\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-tally#h-02-wrong-calculation-of-erc20delta-and-ethdelta",
                "Location": "    function fillZrxQuote(\n        IERC20 zrxBuyTokenAddress,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 ethAmount\n    ) internal returns (uint256, uint256) {\n        uint256 originalERC20Balance = 0;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n        }\n        uint256 originalETHBalance = address(this).balance;\n\n        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n        require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n        uint256 erc20Delta;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n            require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n        } else {\n            require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n        }\n\n        return (erc20Delta, ethDelta);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, ethDelta will always be 0.\n\nThat\ufffd\ufffds because originalETHBalance already includes the msg.value sent by the caller.\n\nLet\ufffd\ufffds say the ETH balance of the contract is 1 ETH before the swap.\n\nA user swaps 10 ETH to USDC;\noriginalETHBalance will be 11 ETH;\nIf there is 1 ETH of refund;\nethDelta will be 0 as the new balance is 2 ETH and subOrZero(2, 11) is 0.\nSimilarly, erc20Delta is also computed wrong.\n\nConsider a special case of a user trying to arbitrage from WBTC to WBTC, the originalERC20Balance already includes the input amount, erc20Delta will always be much lower than the actual delta amount.\n\nFor example, for an arb swap from 1 WBTC to 1.1 WBTC, the ethDelta will be 0.1 WBTC while it should be 1.1 WBTC.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../interfaces/IUserManager.sol\";\nimport \"../interfaces/IAssetManager.sol\";\nimport \"../interfaces/IUErc20.sol\";\nimport \"../interfaces/IInterestRateModel.sol\";\n\n/**\n *  @title UToken Contract\n *  @dev Union accountBorrows can borrow and repay thru this component.\n */\ncontract UToken is Controller, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IUErc20;\n\n    bool public constant IS_UTOKEN = true;\n    uint256 public constant WAD = 1e18;\n    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16; //Maximum borrow rate that can ever be applied (.0005% / block)\n    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18; //Maximum fraction of interest that can be set aside for reserves\n\n    address public underlying;\n    IInterestRateModel public interestRateModel;\n    uint256 internal initialExchangeRateMantissa; //Initial exchange rate used when minting the first UTokens (used when totalSupply = 0)\n    uint256 public reserveFactorMantissa; //Fraction of interest currently set aside for reserves\n    uint256 public accrualBlockNumber; //Block number that interest was last accrued at\n    uint256 public borrowIndex; //Accumulator of the total earned interest rate since the opening of the market\n    uint256 public totalBorrows; //Total amount of outstanding borrows of the underlying in this market\n    uint256 public totalReserves; //Total amount of reserves of the underlying held in this marke\n    uint256 public totalRedeemable; //Calculates the exchange rate from the underlying to the uToken\n    uint256 public overdueBlocks; //overdue duration, based on the number of blocks\n    uint256 public originationFee;\n    uint256 public debtCeiling; //The debt limit for the whole system\n    uint256 public maxBorrow;\n    uint256 public minBorrow;\n    address public assetManager;\n    address public userManager;\n    IUErc20 public uErc20;\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interest;\n        uint256 interestIndex;\n        uint256 lastRepay; //Calculate if it is overdue\n    }\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     *  @dev Change of the interest rate model\n     *  @param oldInterestRateModel Old interest rate model address\n     *  @param newInterestRateModel New interest rate model address\n     */\n    event LogNewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);\n\n    event LogMint(address minter, uint256 underlyingAmount, uint256 uTokenAmount);\n\n    event LogRedeem(address redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn, uint256 redeemAmount);\n\n    event LogReservesAdded(address reserver, uint256 actualAddAmount, uint256 totalReservesNew);\n\n    event LogReservesReduced(address receiver, uint256 reduceAmount, uint256 totalReservesNew);\n\n    /**\n     *  @dev Event borrow\n     *  @param account Member address\n     *  @param amount Borrow amount\n     *  @param fee Origination fee\n     */\n    event LogBorrow(address indexed account, uint256 amount, uint256 fee);\n\n    /**\n     *  @dev Event repay\n     *  @param account Member address\n     *  @param amount Repay amount\n     */\n    event LogRepay(address indexed account, uint256 amount);\n\n    /**\n     *  @dev modifier limit member\n     */\n    modifier onlyMember(address account) {\n        require(IUserManager(userManager).checkIsMember(account), \"UToken: caller is not a member\");\n        _;\n    }\n\n    modifier onlyAssetManager() {\n        require(msg.sender == assetManager, \"UToken: caller is not assetManager\");\n        _;\n    }\n\n    modifier onlyUserManager() {\n        require(msg.sender == userManager, \"UToken: caller is not userManager\");\n        _;\n    }\n\n    function __UToken_init(\n        IUErc20 uErc20_,\n        address underlying_,\n        uint256 initialExchangeRateMantissa_,\n        uint256 reserveFactorMantissa_,\n        uint256 originationFee_,\n        uint256 debtCeiling_,\n        uint256 maxBorrow_,\n        uint256 minBorrow_,\n        uint256 overdueBlocks_,\n        address admin_\n    ) public initializer {\n        require(initialExchangeRateMantissa_ > 0, \"initial exchange rate must be greater than zero.\");\n        require(address(underlying_) != address(0), \"underlying token is zero\");\n        require(\n            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,\n            \"reserveFactorMantissa error\"\n        );\n        uErc20 = uErc20_;\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        underlying = underlying_;\n        originationFee = originationFee_;\n        debtCeiling = debtCeiling_;\n        maxBorrow = maxBorrow_;\n        minBorrow = minBorrow_;\n        overdueBlocks = overdueBlocks_;\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        reserveFactorMantissa = reserveFactorMantissa_;\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = WAD;\n    }\n\n    function setAssetManager(address assetManager_) external onlyAdmin {\n        assetManager = assetManager_;\n    }\n\n    function setUserManager(address userManager_) external onlyAdmin {\n        userManager = userManager_;\n    }\n\n    /**\n     *  @dev Change loan origination fee value\n     *  Accept claims only from the admin\n     *  @param originationFee_ Fees deducted for each loan transaction\n     */\n    function setOriginationFee(uint256 originationFee_) external onlyAdmin {\n        originationFee = originationFee_;\n    }\n\n    /**\n     *  @dev Update the market debt ceiling to a fixed amount, for example, 1 billion DAI etc.\n     *  Accept claims only from the admin\n     *  @param debtCeiling_ The debt limit for the whole system\n     */\n    function setDebtCeiling(uint256 debtCeiling_) external onlyAdmin {\n        debtCeiling = debtCeiling_;\n    }\n\n    /**\n     *  @dev Update the minimum loan size\n     *  Accept claims only from the admin\n     *  @param minBorrow_ Minimum loan amount per user\n     */\n    function setMinBorrow(uint256 minBorrow_) external onlyAdmin {\n        minBorrow = minBorrow_;\n    }\n\n    /**\n     *  @dev Update the max loan size\n     *  Accept claims only from the admin\n     *  @param maxBorrow_ Max loan amount per user\n     */\n    function setMaxBorrow(uint256 maxBorrow_) external onlyAdmin {\n        maxBorrow = maxBorrow_;\n    }\n\n    /**\n     *  @dev Change loan overdue duration, based on the number of blocks\n     *  Accept claims only from the admin\n     *  @param overdueBlocks_ Maximum late repayment block. The number of arrivals is a default\n     */\n    function setOverdueBlocks(uint256 overdueBlocks_) external onlyAdmin {\n        overdueBlocks = overdueBlocks_;\n    }\n\n    /**\n     *  @dev Change to a different interest rate model\n     *  Accept claims only from the admin\n     *  @param newInterestRateModel New interest rate model address\n     */\n    function setInterestRateModel(address newInterestRateModel) external onlyAdmin {\n        _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function setReserveFactor(uint256 reserveFactorMantissa_) external onlyAdmin {\n        require(\n            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,\n            \"reserveFactorMantissa error\"\n        );\n        reserveFactorMantissa = reserveFactorMantissa_;\n    }\n\n    /**\n     *  @dev Returns the remaining amount that can be borrowed from the market.\n     *  @return Remaining total amount\n     */\n    function getRemainingLoanSize() public view returns (uint256) {\n        if (debtCeiling >= totalBorrows) {\n            return debtCeiling - totalBorrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev Get the last repay block\n     *  @param account Member address\n     *  @return lastRepay\n     */\n    function getLastRepay(address account) public view returns (uint256 lastRepay) {\n        lastRepay = accountBorrows[account].lastRepay;\n    }\n\n    /**\n     *  @dev Get member interest index\n     *  @param account Member address\n     *  @return interestIndex\n     */\n    function getInterestIndex(address account) public view returns (uint256 interestIndex) {\n        interestIndex = accountBorrows[account].interestIndex;\n    }\n\n    /**\n     *  @dev Check if the member's loan is overdue\n     *  @param account Member address\n     *  @return isOverdue\n     */\n    function checkIsOverdue(address account) public view returns (bool isOverdue) {\n        if (getBorrowed(account) == 0) {\n            isOverdue = false;\n        } else {\n            uint256 lastRepay = getLastRepay(account);\n            uint256 diff = getBlockNumber() - lastRepay;\n            isOverdue = (overdueBlocks < diff);\n        }\n    }\n\n    /**\n     *  @dev Get the origination fee\n     *  @param amount Amount to be calculated\n     *  @return Handling fee\n     */\n    function calculatingFee(uint256 amount) public view returns (uint256) {\n        return (originationFee * amount) / WAD;\n    }\n\n    /**\n     *  @dev Get member loan data\n     *  @param member Member address\n     *  @return principal totalBorrowed asset apr limit isOverdue lastRepay\n     */\n    function getLoan(address member)\n        public\n        view\n        returns (\n            uint256 principal,\n            uint256 totalBorrowed,\n            address asset,\n            uint256 apr,\n            int256 limit,\n            bool isOverdue,\n            uint256 lastRepay\n        )\n    {\n        principal = accountBorrows[msg.sender].principal;\n        totalBorrowed = borrowBalanceStoredInternal(member);\n        asset = underlying;\n        apr = borrowRatePerBlock();\n        lastRepay = getLastRepay(member);\n        limit = _getCreditLimit(member);\n        isOverdue = checkIsOverdue(member);\n    }\n\n    /**\n     *  @dev Get the borrowed principle\n     *  @param account Member address\n     *  @return borrowed\n     */\n    function getBorrowed(address account) public view returns (uint256 borrowed) {\n        borrowed = accountBorrows[account].principal;\n    }\n\n    /**\n     *  @dev Get a member's current owed balance, including the principle and interest but without updating the user's states.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceView(address account) public view returns (uint256) {\n        return accountBorrows[account].principal + calculatingInterest(account);\n    }\n\n    /**\n     *  @dev Get a member's total owed, including the principle and the interest calculated based on the interest index.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndex;\n        return principalTimesIndex / loan.interestIndex;\n    }\n\n    /**\n     *  @dev Get the borrowing interest rate per block\n     *  @return Borrow rate\n     */\n    function borrowRatePerBlock() public view returns (uint256) {\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate();\n        require(borrowRateMantissa <= BORROW_RATE_MAX_MANTISSA, \"borrow rate is absurdly high\");\n        return borrowRateMantissa;\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this UToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() public view returns (uint256) {\n        return interestRateModel.getSupplyRate(reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint256) {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the UToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        uint256 totalSupply_ = uErc20.totalSupply();\n        if (totalSupply_ == 0) {\n            return initialExchangeRateMantissa;\n        } else {\n            return (totalRedeemable * WAD) / totalSupply_;\n        }\n    }\n\n    /**\n     *  @dev Calculating member's borrowed interest\n     *  @param account Member address\n     *  @return Interest amount\n     */\n    function calculatingInterest(address account) public view returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndexNew;\n        uint256 balance = principalTimesIndex / loan.interestIndex;\n\n        return balance - accountBorrows[account].principal;\n    }\n\n    /**\n     *  @dev Borrowing from the market\n     *  Accept claims only from the member\n     *  Borrow amount must in the range of creditLimit, minBorrow, maxBorrow, debtCeiling and not overdue\n     *  @param amount Borrow amount\n     */\n    function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        require(amount >= minBorrow, \"UToken: amount less than loan size min\");\n\n        require(amount <= getRemainingLoanSize(), \"UToken: amount more than loan global size max\");\n\n        uint256 fee = calculatingFee(amount);\n        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");\n\n        require(!checkIsOverdue(msg.sender), \"UToken: Member has loans overdue\");\n\n        require(amount <= assetManagerContract.getLoanableAmount(underlying), \"UToken: Not enough to lend out\");\n        require(\n            uint256(_getCreditLimit(msg.sender)) >= amount + fee,\n            \"UToken: The loan amount plus fee is greater than credit limit\"\n        );\n\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        //Set lastRepay init data\n        if (accountBorrows[msg.sender].lastRepay == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n        uint256 oldPrincipal = accountBorrows[msg.sender].principal;\n\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = accountBorrows[msg.sender].principal;\n        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n        // The origination fees contribute to the reserve\n        totalReserves += fee;\n\n        require(assetManagerContract.withdraw(underlying, msg.sender, amount), \"UToken: Failed to withdraw\");\n\n        emit LogBorrow(msg.sender, amount, fee);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-union#h-01-borrow-must-accrueinterest-first",
                "Location": "   function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        require(amount >= minBorrow, \"UToken: amount less than loan size min\");\n\n        require(amount <= getRemainingLoanSize(), \"UToken: amount more than loan global size max\");\n\n        uint256 fee = calculatingFee(amount);\n        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");\n\n        require(!checkIsOverdue(msg.sender), \"UToken: Member has loans overdue\");\n\n        require(amount <= assetManagerContract.getLoanableAmount(underlying), \"UToken: Not enough to lend out\");\n        require(\n            uint256(_getCreditLimit(msg.sender)) >= amount + fee,\n            \"UToken: The loan amount plus fee is greater than credit limit\"\n        );\n\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        //Set lastRepay init data\n        if (accountBorrows[msg.sender].lastRepay == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n        uint256 oldPrincipal = accountBorrows[msg.sender].principal;\n\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = accountBorrows[msg.sender].principal;\n        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n        // The origination fees contribute to the reserve\n        totalReserves += fee;\n\n        require(assetManagerContract.withdraw(underlying, msg.sender, amount), \"UToken: Failed to withdraw\");\n\n        emit LogBorrow(msg.sender, amount, fee);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. The UToken.borrow function first checks the borrowed balance and the old credit limit before accruing the actual interest on the market. Thus the borrowed balance of the user does not include the latest interest as it uses the old global borrowIndex but the new borrowIndex is only set in accrueInterest.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ICreditLimitModel.sol\";\n\ncontract CreditLimitByMedian is Ownable, ICreditLimitModel {\n    using Math for uint256;\n\n    bool public constant override isCreditLimitModel = true;\n    uint256 public override effectiveNumber;\n\n    constructor(uint256 effectiveNumber_) {\n        effectiveNumber = effectiveNumber_;\n    }\n\n    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {\n        if (vouchs.length >= effectiveNumber) {\n            return _findMedian(vouchs);\n        } else {\n            return 0;\n        }\n    }\n\n    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    function setEffectNumber(uint256 number) external onlyOwner {\n        effectiveNumber = number;\n    }\n\n    /**\n     *  @dev Find median from uint array\n     *  @param array array\n     *  @return uint256\n     */\n    function _findMedian(uint256[] memory array) private pure returns (uint256) {\n        uint256[] memory arr = _sortArray(array);\n        if (arr.length == 0) return 0;\n\n        if (arr.length % 2 == 0) {\n            uint256 num1 = arr[arr.length >> 1];\n            uint256 num2 = arr[(arr.length >> 1) - 1];\n            return num1.average(num2);\n        } else {\n            return arr[arr.length >> 1];\n        }\n    }\n\n    /**\n     *  @dev Sort uint array\n     *  @param arr array\n     *  @return uint256 array\n     */\n    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {\n        uint256 length = arr.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            for (uint256 j = i + 1; j < length; j++) {\n                if (arr[i] < arr[j]) {\n                    uint256 temp = arr[j];\n                    arr[j] = arr[i];\n                    arr[i] = temp;\n                }\n            }\n        }\n\n        return arr;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-union#h-02-wrong-implementation-of-creditlimitbymediansolgetlockedamount-makes-it-unable-to-unlock-lockedamount-in-creditlimitbymedian-model",
                "Location": "    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. getLockedAmount() is used by UserManager.sol#updateLockedData() to update locked amounts. Based on the context, at L66, newLockedAmount = array[i].lockedAmount - 1; should be newLockedAmount = array[i].lockedAmount - amount;. The current implementation is wrong and makes it impossible to unlock lockedAmount in CreditLimitByMedian model.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./libraries/FixedPoint.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol\";\nimport \"./interfaces/IUniswapV3Pool.sol\";\nimport \"./market/OverlayV1Market.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/TickMath.sol\";\n\ncontract OverlayV1UniswapV3Market is OverlayV1Market {\n\n    using FixedPoint for uint256;\n\n    uint256 internal X96 = 0x1000000000000000000000000;\n\n    uint256 public immutable macroWindow; // window size for main TWAP\n    uint256 public immutable microWindow; // window size for bid/ask TWAP\n\n    address public immutable marketFeed;\n    address public immutable ovlFeed;\n    address public immutable base;\n    address public immutable quote;\n    uint128 internal immutable baseAmount;\n\n    address internal immutable eth;\n    bool internal immutable ethIs0;\n\n    constructor(\n        address _mothership,\n        address _ovlFeed,\n        address _marketFeed,\n        address _quote,\n        address _eth,\n        uint128 _baseAmount,\n        uint256 _macroWindow,\n        uint256 _microWindow,\n        uint256 _priceFrameCap\n    ) OverlayV1Market (\n        _mothership\n    ) OverlayV1Comptroller (\n        _microWindow\n    ) OverlayV1OI (\n        _microWindow\n    ) OverlayV1PricePoint (\n        _priceFrameCap\n    ) {\n\n        // immutables\n        eth = _eth;\n        ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\n        ovlFeed = _ovlFeed;\n        marketFeed = _marketFeed;\n        baseAmount = _baseAmount;\n        macroWindow = _macroWindow;\n        microWindow = _microWindow;\n\n        address _token0 = IUniswapV3Pool(_marketFeed).token0();\n        address _token1 = IUniswapV3Pool(_marketFeed).token1();\n\n        base = _token0 != _quote ? _token0 : _token1;\n        quote = _token0 == _quote ? _token0 : _token1;\n\n        int24 _tick = OracleLibraryV2.consult(\n            _marketFeed,\n            uint32(_macroWindow),\n            uint32(0)\n        );\n\n        _pricePoints.push(PricePoint(\n            _tick, \n            _tick, \n            0\n        ));\n\n        uint _price = OracleLibraryV2.getQuoteAtTick(\n            _tick,\n            uint128(_baseAmount),\n            _token0 != _quote ? _token0 : _token1,\n            _token0 == _quote ? _token0 : _token1\n        );\n\n        emit NewPricePoint(_price, _price, 0);\n\n    }\n\n\n    /// @notice Reads the current price and depth information\n    /// @dev Reads price and depth of market feed\n    /// @return price_ Price point\n    function fetchPricePoint () public view override returns (\n        PricePoint memory price_\n    ) {\n\n        int56[] memory _ticks;\n        uint160[] memory _liqs;\n\n        uint _ovlPrice;\n        uint _marketLiquidity;\n\n        int24 _microTick;\n        int24 _macroTick;\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](3);\n            _secondsAgo[2] = uint32(macroWindow);\n            _secondsAgo[1] = uint32(microWindow);\n\n            ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n\n            _macroTick = int24(( _ticks[0] - _ticks[2]) / int56(int32(int(macroWindow))));\n\n            _microTick = int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))));\n\n            uint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);\n\n            uint _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );\n\n            _marketLiquidity = ethIs0\n                ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n                : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n\n        }\n\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](2);\n\n            _secondsAgo[1] = uint32(macroWindow);\n\n            ( _ticks, ) = IUniswapV3Pool(ovlFeed).observe(_secondsAgo);\n\n            _ovlPrice = OracleLibraryV2.getQuoteAtTick(\n                int24((_ticks[0] - _ticks[1]) / int56(int32(int(macroWindow)))),\n                1e18,\n                ovl,\n                eth\n            );\n\n        }\n\n        price_ = PricePoint(\n            _microTick, \n            _macroTick, \n            computeDepth(_marketLiquidity, _ovlPrice)\n        );\n\n    }\n\n\n    /// @notice Arithmetic to get depth\n    /// @dev Derived from cnstant product formula X*Y=K and tailored \n    /// to Uniswap V3 selective liquidity provision.\n    /// @param _marketLiquidity Amount of liquidity in market in ETH terms.\n    /// @param _ovlPrice Price of OVL against ETH.\n    /// @return depth_ Depth criteria for market in OVL terms.\n    function computeDepth (\n        uint _marketLiquidity,\n        uint _ovlPrice\n    ) public override view returns (\n        uint depth_\n    ) {\n\n        depth_ = ((_marketLiquidity * 1e18) / _ovlPrice)\n            .mulUp(lmbda)    \n            .divDown(2e18);\n\n    }\n\n    function _tickToPrice (\n        int24 _tick\n    ) public override view returns (\n        uint quote_\n    ) {\n\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(_tick);\n\n        // better precision if no overflow when squared\n        if (sqrtRatioX96 <= type(uint128).max) {\n\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n\n            quote_ = base < quote\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n\n        } else {\n\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n\n            quote_ = base < quote\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n\n        }\n\n    }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-overlay#h-01-overlayv1uniswapv3market-computes-wrong-market-liquidity",
                "Location": "    function fetchPricePoint () public view override returns (\n        PricePoint memory price_\n    ) {\n\n        int56[] memory _ticks;\n        uint160[] memory _liqs;\n\n        uint _ovlPrice;\n        uint _marketLiquidity;\n\n        int24 _microTick;\n        int24 _macroTick;\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](3);\n            _secondsAgo[2] = uint32(macroWindow);\n            _secondsAgo[1] = uint32(microWindow);\n\n            ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n\n            _macroTick = int24(( _ticks[0] - _ticks[2]) / int56(int32(int(macroWindow))));\n\n            _microTick = int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))));\n\n            uint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);\n\n            uint _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );\n\n            _marketLiquidity = ethIs0\n                ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n                : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n\n        }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The OverlayV1UniswapV3Market.fetchPricePoint tries to compute the market depth in OVL terms as marketLiquidity (in ETH) / ovlPrice (in ETH per OVL). To get the market liquidity in ETH (and not the other token pair), it uses the ethIs0 boolean. However, ethIs0 boolean refers to the ovlFeed, whereas the _liquidity refers to the marketFeed, and therefore the ethIs0 boolean has nothing to do with the market feed where the liquidity is taken from",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function rampTargetPrice(\n        TargetPrice storage self,\n        uint256 futureTargetPrice_,\n        uint256 futureTime_\n    ) external returns (uint256) {\n        require(\n            block.timestamp >= self.initialTargetPriceTime.add(1 days),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureTargetPrice_ >= 0,\n            \"futureTargetPrice_ must be >= 0\"\n        );\n\n        uint256 initialTargetPricePrecise = _getTargetPricePrecise(self);\n        uint256 futureTargetPricePrecise = futureTargetPrice_.mul(TARGET_PRICE_PRECISION);\n\n        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }\n\n        self.initialTargetPrice = initialTargetPricePrecise;\n        self.futureTargetPrice = futureTargetPricePrecise;\n        self.initialTargetPriceTime = block.timestamp;\n        self.futureTargetPriceTime = futureTime_;\n        \n        // console.log(\"executing rampTargetPrice() initalTargetPrice: %s\", self.initialTargetPrice);\n        // console.log(\"futureTargetPrice: %s\", self.futureTargetPrice);\n\n        emit RampTargetPrice(\n            initialTargetPricePrecise,\n            futureTargetPricePrecise,\n            block.timestamp,\n            futureTime_\n        );\n\n        // change token multiplier to reflect new target price\n        return self.originalPrecisionMultipliers[0].mul(initialTargetPricePrecise).div(WEI_UNIT);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-bootfinance#h-02-can-not-update-target-price",
                "Location": "        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The sanity checks in rampTargetPrice are broken. If futureTargetPricePrecise is smaller than initialTargetPricePrecise 0.01 of futureTargetPricePrecise would never larger than initialTargetPricePrecise.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function determineA(\n        Swap storage self, \n        uint256[] memory xp)\n        internal\n        view\n        returns(uint256)\n    {\n        // Determine the correct A by comparing xp[0] and xp[1].\n        // determine if currently in the A region or in the A2 region.\n        if( xp[0] < xp[1] ) {\n            return _getAPrecise(self);\n        } else {\n            return _getA2Precise(self);        \n        }\n    }     function getYC(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        // 1. Determine the correct A by comparing xp[0] and xp[1].\n        uint256 a = determineA(self, xp);\n\n        // 2. Calculate D of the initial position\n        uint256 d = getD(xp, a);\n\n        // 3. calculate y\n        uint256 y = getY(self, tokenIndexFrom, tokenIndexTo, x, xp, a, d);\n\n        // 4. Calculate A at the resulting position\n        uint256 aNew = _xpCalc(self, tokenIndexFrom, tokenIndexTo, x, y);\n\n        // 5. Check if we switched A's during the swap\n        if (aNew == a){     // We have used the correct A\n            return y;\n        } else {    // We have switched A's, do it again with the new A\n            return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d);\n        }\n\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-bootfinance#h-04-swaps-are-not-split-when-trade-crosses-target-price",
                "Location": "// 5. Check if we switched A's during the swap\nif (aNew == a){     // We have used the correct A\n    return y;\n} else {    // We have switched A's, do it again with the new A\n    return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d);\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see SwapUtils.determineA. The swap curve is therefore a join of two different curves at the target price. When doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2. However, the SwapUtils.swap / _calculateSwap function does not do this, it only uses the \ufffd\ufffdnew A\ufffd\ufffd, see getYC step 5.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function consult(address token) public view returns (uint256 result) {\n        uint256 pairCount = _pairs.length;\n        uint256 sumNative = 0;\n        uint256 sumUSD = 0;\n\n        for (uint256 i = 0; i < pairCount; i++) {\n            PairData memory pairData = _pairs[i];\n\n            if (token == pairData.token0) {\n                //\n                // TODO - Review:\n                //   Verify price1Average is amount of USDV against 1 unit of token1\n                //\n\n                sumNative += pairData.price1Average.mul(1).decode144(); // native asset amount\n                if (pairData.price1Average._x != 0) {\n                    require(sumNative != 0);\n                }\n\n                (\n                    uint80 roundID,\n                    int256 price,\n                    ,\n                    ,\n                    uint80 answeredInRound\n                ) = AggregatorV3Interface(_aggregators[pairData.token1])\n                        .latestRoundData();\n\n                require(\n                    answeredInRound >= roundID,\n                    \"TwapOracle::consult: stale chainlink price\"\n                );\n                require(\n                    price != 0,\n                    \"TwapOracle::consult: chainlink malfunction\"\n                );\n\n                sumUSD += uint256(price) * (10**10);\n            }\n        }\n        require(sumNative != 0, \"TwapOracle::consult: Sum of native is zero\");\n        result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-vader#h-04-twaporacle-doesnt-calculate-vaderusdv-exchange-rate-correctly",
                "Location": "result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative); result = ((sumUSD * 18) / sumNative);",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../math/VaderMath.sol\";\n\nimport \"../../interfaces/reserve/IVaderReserve.sol\";\nimport \"../../interfaces/dex/router/IVaderRouter.sol\";\nimport \"../../interfaces/dex/pool/IVaderPoolFactory.sol\";\n\n/*\n @dev Implementation of {VaderRouter} contract.\n *\n * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.\n *\n * It allows adding of liquidity to Vader pools and facilitate creation of Vader pools if\n * it does not already exist when depositing liquidity.\n *\n * Allows removing of liquidity by the users and claiming the underlying assets from\n * the Vader pools.\n *\n * Allows swapping between native and foreign assets within a single Vader pool.\n *\n * Allows swapping of foreign assets across two different Vader pools.\n *\n * Contains helper functions to compute the destination asset amount given the exact source\n * asset amount and vice versa.\n **/\ncontract VaderRouter is IVaderRouter, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The address of Vader pool factory contract.\n    IVaderPoolFactory public immutable factory;\n\n    // The address of Reserve contract.\n    IVaderReserve public reserve;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes contract's state by setting the vader pool factory address.\n     *\n     * Requirements:\n     * - Vader pool factory address must not be zero.\n     **/\n    constructor(IVaderPoolFactory _factory) {\n        require(\n            _factory != IVaderPoolFactory(_ZERO_ADDRESS),\n            \"VaderRouter::constructor: Incorrect Arguments\"\n        );\n\n        factory = _factory;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {addLiquidity} function.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     **/\n    // NOTE: For Uniswap V2 compliancy, necessary due to stack too deep\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256, // amountAMin = unused\n        uint256, // amountBMin = unused\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        return\n            addLiquidity(\n                tokenA,\n                tokenB,\n                amountADesired,\n                amountBDesired,\n                to,\n                deadline\n            );\n    }\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {_addLiquidity} function.\n     *\n     * Transfers the amounts of tokenA and tokenB from {msg.sender} to the pool.\n     *\n     * Calls the {mint} function on the pool to deposit liquidity on the behalf of\n     * {to} address.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     *\n     * Requirements:\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        IVaderPool pool;\n        (pool, amountA, amountB) = _addLiquidity(\n            address(tokenA),\n            address(tokenB),\n            amountADesired,\n            amountBDesired\n        );\n        tokenA.safeTransferFrom(msg.sender, address(pool), amountA);\n        tokenB.safeTransferFrom(msg.sender, address(pool), amountB);\n        liquidity = pool.mint(to);\n    }\n\n    /*\n     * @dev Allows removing of liquidity by {msg.sender} and transfers the\n     * underlying assets to {to} address.\n     *\n     * Transfers the NFT with Id {id} representing user's position, to the pool address,\n     * so the pool is able to burn it in the `burn` function call.\n     *\n     * Calls the `burn` function on the pool contract.\n     *\n     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss\n     * for the liquidity being removed.\n     *\n     * Requirements:\n     * - The underlying assets amounts of {amountA} and {amountB} must\n     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 id,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        IVaderPool pool = factory.getPool(tokenA, tokenB);\n\n        pool.transferFrom(msg.sender, address(pool), id);\n\n        (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        ) = pool.burn(id, to);\n\n        (amountA, amountB) = tokenA == factory.nativeAsset()\n            ? (amountNative, amountForeign)\n            : (amountForeign, amountNative);\n\n        require(\n            amountA >= amountAMin,\n            \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\n        );\n        require(\n            amountB >= amountBMin,\n            \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\n        );\n\n        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\n    }\n\n    /*\n     * @dev Allows swapping of exact source token amount to destination\n     * token amount.\n     *\n     * Internally calls {_swap} function.\n     *\n     * Requirements:\n     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\n        amountOut = _swap(amountIn, path, to);\n\n        require(\n            amountOut >= amountOutMin,\n            \"VaderRouter::swapExactTokensForTokens: Insufficient Trade Output\"\n        );\n    }\n\n    /*\n     * @dev Allows swapping of source token amount to exact destination token\n     * amount.\n     *\n     * Internally calls {calculateInGivenOut} and {_swap} functions.\n     *\n     * Requirements:\n     * - Param {amountInMax} must be greater than or equal to the source amount computed {amountIn}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256 amountIn) {\n        amountIn = calculateInGivenOut(amountOut, path);\n\n        require(\n            amountInMax >= amountIn,\n            \"VaderRouter::swapTokensForExactTokens: Large Trade Input\"\n        );\n\n        _swap(amountIn, path, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /*\n     * @dev Sets the reserve address and renounces contract's ownership.\n     *\n     * Requirements:\n     * - Only existing owner can call this function.\n     * - Param {_reserve} cannot be a zero address.\n     **/\n    function initialize(IVaderReserve _reserve) external onlyOwner {\n        require(\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\n            \"VaderRouter::initialize: Incorrect Reserve Specified\"\n        );\n\n        reserve = _reserve;\n\n        renounceOwnership();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows swapping of assets from within a single Vader pool or\n     * across two different Vader pools.\n     *\n     * In case of a single Vader pool, the native asset can be swapped for foreign\n     * asset and vice versa.\n     *\n     * In case of two Vader pools, the foreign asset is swapped for native asset from\n     * the first Vader pool and the native asset retrieved from the first Vader pool is swapped\n     * for foreign asset from the second Vader pool.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    // TODO: Refactor with central pool, perhaps diminishes security? would need directSwap & bridgeSwap\n    function _swap(\n        uint256 amountIn,\n        address[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == factory.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouter::_swap: Incorrect Path\"\n            );\n\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool0),\n                amountIn\n            );\n\n            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouter::_swap: Incorrect Path Length\"\n            );\n            address nativeAsset = factory.nativeAsset();\n            require(path[0] != path[1], \"VaderRouter::_swap: Incorrect Path\");\n\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool),\n                amountIn\n            );\n            if (path[0] == nativeAsset) {\n                return pool.swap(amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == nativeAsset,\n                    \"VaderRouter::_swap: Incorrect Path\"\n                );\n                return pool.swap(0, amountIn, to);\n            }\n        }\n    }\n\n    /*\n     * @dev An internal function that returns Vader pool's address against\n     * the provided assets of {tokenA} and {tokenB} if it exists, otherwise\n     * a new Vader pool created against the provided assets.\n     **/\n    // NOTE: DEX allows asymmetric deposits\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    )\n        private\n        returns (\n            IVaderPool pool,\n            uint256 amountA,\n            uint256 amountB\n        )\n    {\n        // create the pair if it doesn't exist yet\n        pool = factory.getPool(tokenA, tokenB);\n        if (pool == IVaderPool(_ZERO_ADDRESS)) {\n            pool = factory.createPool(tokenA, tokenB);\n        }\n\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    }\n\n    /*\n     * @dev Returns the amount of source asset given the amount of destination asset.\n     *\n     * Calls the {calculateSwapReverse} on VaderMath library to compute the source\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateInGivenOut(uint256 amountOut, address[] calldata path)\n        public\n        view\n        returns (uint256 amountIn)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwapReverse(\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /*\n     * @dev Returns the amount of destination asset given the amount of source asset.\n     *\n     * Calls the {calculateSwap} on VaderMath library to compute the destination\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwap(\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    // Guard ensuring that the current timestamp has not exceeded the param {deadline}.\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"VaderRouter::ensure: Expired\");\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-vader#h-15-vaderrouter_swap-performs-wrong-swap",
                "Location": "  function _swap(\n        uint256 amountIn,\n        address[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == factory.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouter::_swap: Incorrect Path\"\n            );\n\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool0),\n                amountIn\n            );\n\n            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouter::_swap: Incorrect Path Length\"\n            );\n            address nativeAsset = factory.nativeAsset();\n            require(path[0] != path[1], \"VaderRouter::_swap: Incorrect Path\");\n\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool),\n                amountIn\n            );\n            if (path[0] == nativeAsset) {\n                return pool.swap(amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == nativeAsset,\n                    \"VaderRouter::_swap: Incorrect Path\"\n                );\n                return pool.swap(0, amountIn, to);\n            }\n        }\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The 3-path hop in VaderRouter._swap is supposed to first swap foreign assets to native assets, and then the received native assets to different foreign assets again.\n\nThe pool.swap(nativeAmountIn, foreignAmountIn) accepts the foreign amount as the second argument. The code however mixes these positional arguments up and tries to perform a pool0 foreign -> native swap by using the foreign amount as the native amount:",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../math/VaderMath.sol\";\n\nimport \"../../interfaces/reserve/IVaderReserve.sol\";\nimport \"../../interfaces/dex/router/IVaderRouter.sol\";\nimport \"../../interfaces/dex/pool/IVaderPoolFactory.sol\";\n\n/*\n @dev Implementation of {VaderRouter} contract.\n *\n * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.\n *\n * It allows adding of liquidity to Vader pools and facilitate creation of Vader pools if\n * it does not already exist when depositing liquidity.\n *\n * Allows removing of liquidity by the users and claiming the underlying assets from\n * the Vader pools.\n *\n * Allows swapping between native and foreign assets within a single Vader pool.\n *\n * Allows swapping of foreign assets across two different Vader pools.\n *\n * Contains helper functions to compute the destination asset amount given the exact source\n * asset amount and vice versa.\n **/\ncontract VaderRouter is IVaderRouter, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The address of Vader pool factory contract.\n    IVaderPoolFactory public immutable factory;\n\n    // The address of Reserve contract.\n    IVaderReserve public reserve;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes contract's state by setting the vader pool factory address.\n     *\n     * Requirements:\n     * - Vader pool factory address must not be zero.\n     **/\n    constructor(IVaderPoolFactory _factory) {\n        require(\n            _factory != IVaderPoolFactory(_ZERO_ADDRESS),\n            \"VaderRouter::constructor: Incorrect Arguments\"\n        );\n\n        factory = _factory;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {addLiquidity} function.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     **/\n    // NOTE: For Uniswap V2 compliancy, necessary due to stack too deep\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256, // amountAMin = unused\n        uint256, // amountBMin = unused\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        return\n            addLiquidity(\n                tokenA,\n                tokenB,\n                amountADesired,\n                amountBDesired,\n                to,\n                deadline\n            );\n    }\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {_addLiquidity} function.\n     *\n     * Transfers the amounts of tokenA and tokenB from {msg.sender} to the pool.\n     *\n     * Calls the {mint} function on the pool to deposit liquidity on the behalf of\n     * {to} address.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     *\n     * Requirements:\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        IVaderPool pool;\n        (pool, amountA, amountB) = _addLiquidity(\n            address(tokenA),\n            address(tokenB),\n            amountADesired,\n            amountBDesired\n        );\n        tokenA.safeTransferFrom(msg.sender, address(pool), amountA);\n        tokenB.safeTransferFrom(msg.sender, address(pool), amountB);\n        liquidity = pool.mint(to);\n    }\n\n    /*\n     * @dev Allows removing of liquidity by {msg.sender} and transfers the\n     * underlying assets to {to} address.\n     *\n     * Transfers the NFT with Id {id} representing user's position, to the pool address,\n     * so the pool is able to burn it in the `burn` function call.\n     *\n     * Calls the `burn` function on the pool contract.\n     *\n     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss\n     * for the liquidity being removed.\n     *\n     * Requirements:\n     * - The underlying assets amounts of {amountA} and {amountB} must\n     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 id,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        IVaderPool pool = factory.getPool(tokenA, tokenB);\n\n        pool.transferFrom(msg.sender, address(pool), id);\n\n        (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        ) = pool.burn(id, to);\n\n        (amountA, amountB) = tokenA == factory.nativeAsset()\n            ? (amountNative, amountForeign)\n            : (amountForeign, amountNative);\n\n        require(\n            amountA >= amountAMin,\n            \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\n        );\n        require(\n            amountB >= amountBMin,\n            \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\n        );\n\n        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\n    }\n\n    /*\n     * @dev Allows swapping of exact source token amount to destination\n     * token amount.\n     *\n     * Internally calls {_swap} function.\n     *\n     * Requirements:\n     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\n        amountOut = _swap(amountIn, path, to);\n\n        require(\n            amountOut >= amountOutMin,\n            \"VaderRouter::swapExactTokensForTokens: Insufficient Trade Output\"\n        );\n    }\n\n    /*\n     * @dev Allows swapping of source token amount to exact destination token\n     * amount.\n     *\n     * Internally calls {calculateInGivenOut} and {_swap} functions.\n     *\n     * Requirements:\n     * - Param {amountInMax} must be greater than or equal to the source amount computed {amountIn}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256 amountIn) {\n        amountIn = calculateInGivenOut(amountOut, path);\n\n        require(\n            amountInMax >= amountIn,\n            \"VaderRouter::swapTokensForExactTokens: Large Trade Input\"\n        );\n\n        _swap(amountIn, path, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /*\n     * @dev Sets the reserve address and renounces contract's ownership.\n     *\n     * Requirements:\n     * - Only existing owner can call this function.\n     * - Param {_reserve} cannot be a zero address.\n     **/\n    function initialize(IVaderReserve _reserve) external onlyOwner {\n        require(\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\n            \"VaderRouter::initialize: Incorrect Reserve Specified\"\n        );\n\n        reserve = _reserve;\n\n        renounceOwnership();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows swapping of assets from within a single Vader pool or\n     * across two different Vader pools.\n     *\n     * In case of a single Vader pool, the native asset can be swapped for foreign\n     * asset and vice versa.\n     *\n     * In case of two Vader pools, the foreign asset is swapped for native asset from\n     * the first Vader pool and the native asset retrieved from the first Vader pool is swapped\n     * for foreign asset from the second Vader pool.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    // TODO: Refactor with central pool, perhaps diminishes security? would need directSwap & bridgeSwap\n    function _swap(\n        uint256 amountIn,\n        address[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == factory.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouter::_swap: Incorrect Path\"\n            );\n\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool0),\n                amountIn\n            );\n\n            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouter::_swap: Incorrect Path Length\"\n            );\n            address nativeAsset = factory.nativeAsset();\n            require(path[0] != path[1], \"VaderRouter::_swap: Incorrect Path\");\n\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool),\n                amountIn\n            );\n            if (path[0] == nativeAsset) {\n                return pool.swap(amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == nativeAsset,\n                    \"VaderRouter::_swap: Incorrect Path\"\n                );\n                return pool.swap(0, amountIn, to);\n            }\n        }\n    }\n\n    /*\n     * @dev An internal function that returns Vader pool's address against\n     * the provided assets of {tokenA} and {tokenB} if it exists, otherwise\n     * a new Vader pool created against the provided assets.\n     **/\n    // NOTE: DEX allows asymmetric deposits\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    )\n        private\n        returns (\n            IVaderPool pool,\n            uint256 amountA,\n            uint256 amountB\n        )\n    {\n        // create the pair if it doesn't exist yet\n        pool = factory.getPool(tokenA, tokenB);\n        if (pool == IVaderPool(_ZERO_ADDRESS)) {\n            pool = factory.createPool(tokenA, tokenB);\n        }\n\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    }\n\n    /*\n     * @dev Returns the amount of source asset given the amount of destination asset.\n     *\n     * Calls the {calculateSwapReverse} on VaderMath library to compute the source\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateInGivenOut(uint256 amountOut, address[] calldata path)\n        public\n        view\n        returns (uint256 amountIn)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwapReverse(\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /*\n     * @dev Returns the amount of destination asset given the amount of source asset.\n     *\n     * Calls the {calculateSwap} on VaderMath library to compute the destination\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwap(\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    // Guard ensuring that the current timestamp has not exceeded the param {deadline}.\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"VaderRouter::ensure: Expired\");\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-vader#h-16-vaderroutercalculateoutgivenin-calculates-wrong-swap",
                "Location": "    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwap(\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The 3-path hop in VaderRouter.calculateOutGivenIn is supposed to first swap foreign assets to native assets in pool0, and then the received native assets to different foreign assets again in pool1. The first argument of VaderMath.calculateSwap(amountIn, reserveIn, reserveOut) must refer to the same token as the second argument reserveIn. The code however mixes these positions up and first performs a swap in pool1 instead of pool0",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../math/VaderMath.sol\";\n\nimport \"../../interfaces/reserve/IVaderReserve.sol\";\nimport \"../../interfaces/dex/router/IVaderRouter.sol\";\nimport \"../../interfaces/dex/pool/IVaderPoolFactory.sol\";\n\n/*\n @dev Implementation of {VaderRouter} contract.\n *\n * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.\n *\n * It allows adding of liquidity to Vader pools and facilitate creation of Vader pools if\n * it does not already exist when depositing liquidity.\n *\n * Allows removing of liquidity by the users and claiming the underlying assets from\n * the Vader pools.\n *\n * Allows swapping between native and foreign assets within a single Vader pool.\n *\n * Allows swapping of foreign assets across two different Vader pools.\n *\n * Contains helper functions to compute the destination asset amount given the exact source\n * asset amount and vice versa.\n **/\ncontract VaderRouter is IVaderRouter, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The address of Vader pool factory contract.\n    IVaderPoolFactory public immutable factory;\n\n    // The address of Reserve contract.\n    IVaderReserve public reserve;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes contract's state by setting the vader pool factory address.\n     *\n     * Requirements:\n     * - Vader pool factory address must not be zero.\n     **/\n    constructor(IVaderPoolFactory _factory) {\n        require(\n            _factory != IVaderPoolFactory(_ZERO_ADDRESS),\n            \"VaderRouter::constructor: Incorrect Arguments\"\n        );\n\n        factory = _factory;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {addLiquidity} function.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     **/\n    // NOTE: For Uniswap V2 compliancy, necessary due to stack too deep\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256, // amountAMin = unused\n        uint256, // amountBMin = unused\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        return\n            addLiquidity(\n                tokenA,\n                tokenB,\n                amountADesired,\n                amountBDesired,\n                to,\n                deadline\n            );\n    }\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {_addLiquidity} function.\n     *\n     * Transfers the amounts of tokenA and tokenB from {msg.sender} to the pool.\n     *\n     * Calls the {mint} function on the pool to deposit liquidity on the behalf of\n     * {to} address.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     *\n     * Requirements:\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        IVaderPool pool;\n        (pool, amountA, amountB) = _addLiquidity(\n            address(tokenA),\n            address(tokenB),\n            amountADesired,\n            amountBDesired\n        );\n        tokenA.safeTransferFrom(msg.sender, address(pool), amountA);\n        tokenB.safeTransferFrom(msg.sender, address(pool), amountB);\n        liquidity = pool.mint(to);\n    }\n\n    /*\n     * @dev Allows removing of liquidity by {msg.sender} and transfers the\n     * underlying assets to {to} address.\n     *\n     * Transfers the NFT with Id {id} representing user's position, to the pool address,\n     * so the pool is able to burn it in the `burn` function call.\n     *\n     * Calls the `burn` function on the pool contract.\n     *\n     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss\n     * for the liquidity being removed.\n     *\n     * Requirements:\n     * - The underlying assets amounts of {amountA} and {amountB} must\n     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 id,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        IVaderPool pool = factory.getPool(tokenA, tokenB);\n\n        pool.transferFrom(msg.sender, address(pool), id);\n\n        (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        ) = pool.burn(id, to);\n\n        (amountA, amountB) = tokenA == factory.nativeAsset()\n            ? (amountNative, amountForeign)\n            : (amountForeign, amountNative);\n\n        require(\n            amountA >= amountAMin,\n            \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\n        );\n        require(\n            amountB >= amountBMin,\n            \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\n        );\n\n        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\n    }\n\n    /*\n     * @dev Allows swapping of exact source token amount to destination\n     * token amount.\n     *\n     * Internally calls {_swap} function.\n     *\n     * Requirements:\n     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\n        amountOut = _swap(amountIn, path, to);\n\n        require(\n            amountOut >= amountOutMin,\n            \"VaderRouter::swapExactTokensForTokens: Insufficient Trade Output\"\n        );\n    }\n\n    /*\n     * @dev Allows swapping of source token amount to exact destination token\n     * amount.\n     *\n     * Internally calls {calculateInGivenOut} and {_swap} functions.\n     *\n     * Requirements:\n     * - Param {amountInMax} must be greater than or equal to the source amount computed {amountIn}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256 amountIn) {\n        amountIn = calculateInGivenOut(amountOut, path);\n\n        require(\n            amountInMax >= amountIn,\n            \"VaderRouter::swapTokensForExactTokens: Large Trade Input\"\n        );\n\n        _swap(amountIn, path, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /*\n     * @dev Sets the reserve address and renounces contract's ownership.\n     *\n     * Requirements:\n     * - Only existing owner can call this function.\n     * - Param {_reserve} cannot be a zero address.\n     **/\n    function initialize(IVaderReserve _reserve) external onlyOwner {\n        require(\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\n            \"VaderRouter::initialize: Incorrect Reserve Specified\"\n        );\n\n        reserve = _reserve;\n\n        renounceOwnership();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows swapping of assets from within a single Vader pool or\n     * across two different Vader pools.\n     *\n     * In case of a single Vader pool, the native asset can be swapped for foreign\n     * asset and vice versa.\n     *\n     * In case of two Vader pools, the foreign asset is swapped for native asset from\n     * the first Vader pool and the native asset retrieved from the first Vader pool is swapped\n     * for foreign asset from the second Vader pool.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    // TODO: Refactor with central pool, perhaps diminishes security? would need directSwap & bridgeSwap\n    function _swap(\n        uint256 amountIn,\n        address[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == factory.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouter::_swap: Incorrect Path\"\n            );\n\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool0),\n                amountIn\n            );\n\n            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouter::_swap: Incorrect Path Length\"\n            );\n            address nativeAsset = factory.nativeAsset();\n            require(path[0] != path[1], \"VaderRouter::_swap: Incorrect Path\");\n\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool),\n                amountIn\n            );\n            if (path[0] == nativeAsset) {\n                return pool.swap(amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == nativeAsset,\n                    \"VaderRouter::_swap: Incorrect Path\"\n                );\n                return pool.swap(0, amountIn, to);\n            }\n        }\n    }\n\n    /*\n     * @dev An internal function that returns Vader pool's address against\n     * the provided assets of {tokenA} and {tokenB} if it exists, otherwise\n     * a new Vader pool created against the provided assets.\n     **/\n    // NOTE: DEX allows asymmetric deposits\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    )\n        private\n        returns (\n            IVaderPool pool,\n            uint256 amountA,\n            uint256 amountB\n        )\n    {\n        // create the pair if it doesn't exist yet\n        pool = factory.getPool(tokenA, tokenB);\n        if (pool == IVaderPool(_ZERO_ADDRESS)) {\n            pool = factory.createPool(tokenA, tokenB);\n        }\n\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    }\n\n    /*\n     * @dev Returns the amount of source asset given the amount of destination asset.\n     *\n     * Calls the {calculateSwapReverse} on VaderMath library to compute the source\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateInGivenOut(uint256 amountOut, address[] calldata path)\n        public\n        view\n        returns (uint256 amountIn)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwapReverse(\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /*\n     * @dev Returns the amount of destination asset given the amount of source asset.\n     *\n     * Calls the {calculateSwap} on VaderMath library to compute the destination\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwap(\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    // Guard ensuring that the current timestamp has not exceeded the param {deadline}.\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"VaderRouter::ensure: Expired\");\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-vader#h-25-wrong-design-of-swap-results-in-unexpected-and-unfavorable-outputs",
                "Location": "    function calculateSwap(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256 amountOut) {\n        // x * Y * X\n        uint256 numerator = amountIn * reserveIn * reserveOut;\n\n        // (x + X) ^ 2\n        uint256 denominator = pow(amountIn + reserveIn);\n\n        amountOut = numerator / denominator;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. We believe the design (the formula) is wrong and it will result in unexpected and unfavorable outputs. Specifically, if the amountIn is larger than the reserveIn, the amountOut starts to decrease.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {FixedPointMath} from \"../FixedPointMath.sol\";\nimport {IDetailedERC20} from \"../../interfaces/IDetailedERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title CDP\n///\n/// @dev A library which provides the CDP data struct and associated functions.\nlibrary CDP {\n  using CDP for Data;\n  using FixedPointMath for FixedPointMath.FixedDecimal;\n  using SafeERC20 for IDetailedERC20;\n  using SafeMath for uint256;\n\n  struct Context {\n    FixedPointMath.FixedDecimal collateralizationLimit;\n    FixedPointMath.FixedDecimal accumulatedYieldWeight;\n  }\n\n  struct Data {\n    uint256 totalDeposited;\n    uint256 totalDebt;\n    uint256 totalCredit;\n    uint256 lastDeposit;\n    FixedPointMath.FixedDecimal lastAccumulatedYieldWeight;\n  }\n\n  function update(Data storage _self, Context storage _ctx) internal {\n    uint256 _earnedYield = _self.getEarnedYield(_ctx);\n    if (_earnedYield > _self.totalDebt) {\n      uint256 _currentTotalDebt = _self.totalDebt;\n      _self.totalDebt = 0;\n      _self.totalCredit = _earnedYield.sub(_currentTotalDebt);\n    } else {\n      _self.totalDebt = _self.totalDebt.sub(_earnedYield);\n    }\n    _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n  }\n\n  /// @dev Assures that the CDP is healthy.\n  ///\n  /// This function will revert if the CDP is unhealthy.\n  function checkHealth(Data storage _self, Context storage _ctx, string memory _msg) internal view {\n    require(_self.isHealthy(_ctx), _msg);\n  }\n\n  /// @dev Gets if the CDP is considered healthy.\n  ///\n  /// A CDP is healthy if its collateralization ratio is greater than the global collateralization limit.\n  ///\n  /// @return if the CDP is healthy.\n  function isHealthy(Data storage _self, Context storage _ctx) internal view returns (bool) {\n    return _ctx.collateralizationLimit.cmp(_self.getCollateralizationRatio(_ctx)) <= 0;\n  }\n\n  function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\n    if (_unclaimedYield == 0) {\n      return _self.totalDebt;\n    }\n\n    uint256 _currentTotalDebt = _self.totalDebt;\n    if (_unclaimedYield >= _currentTotalDebt) {\n      return 0;\n    }\n\n    return _currentTotalDebt - _unclaimedYield;\n  }\n\n  function getUpdatedTotalCredit(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\n    if (_unclaimedYield == 0) {\n      return _self.totalCredit;\n    }\n\n    uint256 _currentTotalDebt = _self.totalDebt;\n    if (_unclaimedYield <= _currentTotalDebt) {\n      return 0;\n    }\n\n    return _self.totalCredit + (_unclaimedYield - _currentTotalDebt);\n  }\n\n  /// @dev Gets the amount of yield that a CDP has earned since the last time it was updated.\n  ///\n  /// @param _self the CDP to query.\n  /// @param _ctx  the CDP context.\n  ///\n  /// @return the amount of earned yield.\n  function getEarnedYield(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    FixedPointMath.FixedDecimal memory _currentAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n    FixedPointMath.FixedDecimal memory _lastAccumulatedYieldWeight = _self.lastAccumulatedYieldWeight;\n\n    if (_currentAccumulatedYieldWeight.cmp(_lastAccumulatedYieldWeight) == 0) {\n      return 0;\n    }\n\n    return _currentAccumulatedYieldWeight\n      .sub(_lastAccumulatedYieldWeight)\n      .mul(_self.totalDeposited)\n      .decode();\n  }\n\n  /// @dev Gets a CDPs collateralization ratio.\n  ///\n  /// The collateralization ratio is defined as the ratio of collateral to debt. If the CDP has zero debt then this\n  /// will return the maximum value of a fixed point integer.\n  ///\n  /// This function will use the updated total debt so an update before calling this function is not required.\n  ///\n  /// @param _self the CDP to query.\n  ///\n  /// @return a fixed point integer representing the collateralization ratio.\n  function getCollateralizationRatio(Data storage _self, Context storage _ctx)\n    internal view\n    returns (FixedPointMath.FixedDecimal memory)\n  {\n    uint256 _totalDebt = _self.getUpdatedTotalDebt(_ctx);\n    if (_totalDebt == 0) {\n      return FixedPointMath.maximumValue();\n    }\n    return FixedPointMath.fromU256(_self.totalDeposited).div(_totalDebt);\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-yaxis#h-02-cdpsol-update-overwrites-users-credit-on-every-positive-increment",
                "Location": "  function update(Data storage _self, Context storage _ctx) internal {\n    uint256 _earnedYield = _self.getEarnedYield(_ctx);\n    if (_earnedYield > _self.totalDebt) {\n      uint256 _currentTotalDebt = _self.totalDebt;\n      _self.totalDebt = 0;\n      _self.totalCredit = _earnedYield.sub(_currentTotalDebt);\n    } else {\n      _self.totalDebt = _self.totalDebt.sub(_earnedYield);\n    }\n    _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. there is a function called update. This function slowly decreases the debt of a position as yield is earned, until the debt is fully paid off, and the idea is then that the credit should begin incrementing as more yield is accumulated. However, the current logic to increment the totalCredit is this line of code",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./libraries/CommonLibrary.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IProtocolGovernance.sol\";\nimport \"./interfaces/ILpIssuer.sol\";\nimport \"./DefaultAccessControl.sol\";\nimport \"./LpIssuerGovernance.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.\ncontract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    uint256 private _subvaultNft;\n    IVaultGovernance internal _vaultGovernance;\n    address[] internal _vaultTokens;\n    mapping(address => bool) internal _vaultTokensIndex;\n    uint256 private _nft;\n    uint256[] private _lpPriceHighWaterMarks;\n    uint256[] private _existentials;\n\n    uint256 public lastFeeCharge;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param name_ Name of the ERC-721 token\n    /// @param symbol_ Symbol of the ERC-721 token\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) {\n        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);\n        _vaultGovernance = vaultGovernance_;\n        _vaultTokens = vaultTokens_;\n        for (uint256 i = 0; i < vaultTokens_.length; i++) {\n            address token = vaultTokens_[i];\n            _vaultTokensIndex[token] = true;\n            _lpPriceHighWaterMarks.push(0);\n            _existentials.push(10**(ERC20(token).decimals() / 2));\n        }\n        lastFeeCharge = block.timestamp;\n    }\n\n    function vaultGovernance() external view returns (IVaultGovernance) {\n        return _vaultGovernance;\n    }\n\n    function vaultTokens() external view returns (address[] memory) {\n        return _vaultTokens;\n    }\n\n    function existentials() external view returns (uint256[] memory) {\n        return _existentials;\n    }\n\n    /// @inheritdoc ILpIssuer\n    function subvaultNft() external view returns (uint256) {\n        return _subvaultNft;\n    }\n\n    function nft() external view returns (uint256) {\n        return _nft;\n    }\n\n    function initialize(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);\n        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);\n        _nft = nft_;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        registry.setApprovalForAll(address(registry), true);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 thisNft = _nft;\n        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);\n        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);\n        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);\n        IVault subvault = _subvault();\n        uint256[] memory existentials_ = _existentials;\n        uint256[] memory tvl = subvault.tvl(); //pre-money\n        uint256 supply = totalSupply();\n        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;\n        if (supply > 0) {\n            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR\n            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);\n        }\n\n        // If with that big supply we don't reveive any lps then it doesn't make sense to continue\n        require(balanceFactor > 0, \"BF\");\n        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);\n\n        // Making sure the proportion between tokenAmounts and tvl are the same\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);\n            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));\n            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);\n        }\n\n        uint256[] memory actualTokenAmounts = subvault.transferAndPush(\n            address(this),\n            _vaultTokens,\n            balancedAmounts,\n            options\n        );\n        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);\n\n        require(amountToMint > 0, \"ZLP\");\n\n        require(\n            amountToMint + balanceOf(msg.sender) <=\n                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,\n            ExceptionsLibrary.LIMIT_PER_ADDRESS\n        );\n\n        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);\n        _mint(msg.sender, amountToMint);\n\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (balancedAmounts[i] > actualTokenAmounts[i]) {\n                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);\n            }\n        }\n\n        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function withdraw(\n        address to,\n        uint256 lpTokenAmount,\n        bytes memory options\n    ) external nonReentrant {\n        uint256 supply = totalSupply();\n        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);\n        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);\n        uint256[] memory tvl = _subvault().tvl();\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;\n        }\n        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (actualTokenAmounts[i] == 0) {\n                continue;\n            }\n            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);\n        }\n        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);\n        _burn(msg.sender, lpTokenAmount);\n        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function addSubvault(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n        _subvaultNft = nft_;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _subvault() internal view returns (IVault) {\n        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));\n    }\n\n    /// @dev We don't charge on any deposit / withdraw to save gas.\n    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)\n    /// So the error results in slightly lower management fees than in exact case\n    function _chargeFees(\n        uint256 thisNft,\n        uint256[] memory tvls,\n        uint256 supply,\n        uint256[] memory deltaTvls,\n        uint256 deltaSupply,\n        bool isWithdraw\n    ) internal {\n        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));\n        uint256 elapsed = block.timestamp - lastFeeCharge;\n        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n            return;\n        }\n        lastFeeCharge = block.timestamp;\n        uint256 baseSupply = supply;\n        if (isWithdraw) {\n            baseSupply = 0;\n            if (supply > deltaSupply) {\n                baseSupply = supply - deltaSupply;\n            }\n        }\n\n        if (baseSupply == 0) {\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;\n            }\n            return;\n        }\n\n        uint256[] memory baseTvls = new uint256[](tvls.length);\n        for (uint256 i = 0; i < baseTvls.length; i++) {\n            if (isWithdraw) {\n                baseTvls[i] = tvls[i] - deltaTvls[i];\n            } else {\n                baseTvls[i] = tvls[i];\n            }\n        }\n\n        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);\n        if (strategyParams.managementFee > 0) {\n            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /\n                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(strategyParams.strategyTreasury, toMint);\n            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);\n        }\n        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;\n        if (protocolFee > 0) {\n            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();\n            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(treasury, toMint);\n            emit ProtocolFeesCharged(treasury, protocolFee, toMint);\n        }\n        uint256 performanceFee = strategyParams.performanceFee;\n        uint256[] memory hwms = _lpPriceHighWaterMarks;\n        if (performanceFee > 0) {\n            uint256 minLpPriceFactor = type(uint256).max;\n            for (uint256 i = 0; i < baseTvls.length; i++) {\n                uint256 hwm = hwms[i];\n                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;\n                if (lpPrice > hwm) {\n                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;\n                    if (delta < minLpPriceFactor) {\n                        minLpPriceFactor = delta;\n                    }\n                } else {\n                    // not eligible for performance fees\n                    return;\n                }\n            }\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            }\n            address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);\n            emit PerformanceFeesCharged(treasury, performanceFee, toMint);\n        }\n    }\n\n    function _getLpAmount(\n        uint256[] memory tvl,\n        uint256[] memory amounts,\n        uint256[] memory existentials_,\n        uint256 supply\n    ) internal pure returns (uint256 lpAmount) {\n        lpAmount = 0;\n        if (supply == 0) {\n            // On init lpToken = max(tokenAmounts)\n            for (uint256 i = 0; i < tvl.length; i++) {\n                if (amounts[i] > lpAmount) {\n                    lpAmount = amounts[i];\n                }\n            }\n            return lpAmount;\n        }\n        for (uint256 i = 0; i < tvl.length; i++) {\n            if (amounts[i] <= existentials_[i]) {\n                // skip existential deposits for lp share calculation\n                continue;\n            }\n            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];\n            // take min of meaningful tokenLp amounts\n            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {\n                lpAmount = tokenLpAmount;\n            }\n        }\n    }\n\n    function _getBalancedAmount(\n        uint256 tvl,\n        uint256 amount,\n        uint256 existential,\n        uint256 balanceFactor,\n        uint256 supply\n    ) internal pure returns (uint256) {\n        if (supply == 0) {\n            // skip normalization on init\n            return amount;\n        }\n        if (amount < existential) {\n            // avoid putting small amounts as it can introduce unnecessary harsh errors\n            // one should provide amount > existential deposit each time tvl is not 0\n            require(tvl == 0, \"PN\");\n            return 0;\n        }\n        // normalize amount\n        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;\n        if (res > amount) {\n            res = amount;\n        }\n        return res;\n    }\n\n    /// @notice Emitted when management fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when protocol fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when performance fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when liquidity is deposited\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens deposited\n    /// @param actualTokenAmounts Token amounts deposited\n    /// @param lpTokenMinted LP tokens received by the liquidity provider\n    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);\n\n    /// @notice Emitted when liquidity is withdrawn\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens withdrawn\n    /// @param actualTokenAmounts Token amounts withdrawn\n    /// @param lpTokenBurned LP tokens burned from the liquidity provider\n    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-mellow#h-02-wrong-implementation-of-performancefee-can-cause-users-to-lose-50-to-100-of-their-funds",
                "Location": "   function _chargeFees(\n        uint256 thisNft,\n        uint256[] memory tvls,\n        uint256 supply,\n        uint256[] memory deltaTvls,\n        uint256 deltaSupply,\n        bool isWithdraw\n    ) internal {\n        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));\n        uint256 elapsed = block.timestamp - lastFeeCharge;\n        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n            return;\n        }\n        lastFeeCharge = block.timestamp;\n        uint256 baseSupply = supply;\n        if (isWithdraw) {\n            baseSupply = 0;\n            if (supply > deltaSupply) {\n                baseSupply = supply - deltaSupply;\n            }\n        }\n\n        if (baseSupply == 0) {\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;\n            }\n            return;\n        }\n\n        uint256[] memory baseTvls = new uint256[](tvls.length);\n        for (uint256 i = 0; i < baseTvls.length; i++) {\n            if (isWithdraw) {\n                baseTvls[i] = tvls[i] - deltaTvls[i];\n            } else {\n                baseTvls[i] = tvls[i];\n            }\n        }\n\n        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);\n        if (strategyParams.managementFee > 0) {\n            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /\n                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(strategyParams.strategyTreasury, toMint);\n            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);\n        }\n        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;\n        if (protocolFee > 0) {\n            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();\n            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(treasury, toMint);\n            emit ProtocolFeesCharged(treasury, protocolFee, toMint);\n        }\n        uint256 performanceFee = strategyParams.performanceFee;\n        uint256[] memory hwms = _lpPriceHighWaterMarks;\n        if (performanceFee > 0) {\n            uint256 minLpPriceFactor = type(uint256).max;\n            for (uint256 i = 0; i < baseTvls.length; i++) {\n                uint256 hwm = hwms[i];\n                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;\n                if (lpPrice > hwm) {\n                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;\n                    if (delta < minLpPriceFactor) {\n                        minLpPriceFactor = delta;\n                    }\n                } else {\n                    // not eligible for performance fees\n                    return;\n                }\n            }\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            }\n            address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);\n            emit PerformanceFeesCharged(treasury, performanceFee, toMint);\n        }\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. A certain amount of lp tokens (shares of the vault) will be minted to the strategyPerformanceTreasury as performanceFee, the amount is calculated based on the minLpPriceFactor. However, the current formula for toMint is wrong, which issues more than 100% of the current totalSupply of the lp token to the strategyPerformanceTreasury each time. Causing users to lose 50% to 100% of their funds after a few times.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/IStabilizerNode.sol\";\nimport \"./Auction.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Auction Burn Reserve Skew\n/// @author 0xScotch <scotch@malt.money>\n/// @notice This contract makes decisions about what do to with excess Liquidity Extension balance at the end of an auction. Burn additional Malt or retain capital in LE\ncontract AuctionBurnReserveSkew is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  // An array of 0s or 1s that track if active stabilization was \n  // needed above or below peg.\n  // 0 = below peg\n  // 1 = above peg\n  //\n  // By doing this we can average the array to get a value that\n  // indicates if we are more frequently over or under peg.\n  uint256[] public pegObservations;\n  uint256 public auctionAverageLookback = 10;\n\n  IStabilizerNode public stabilizerNode;\n  IAuction public auction;\n\n  // This is the total number of stabilization observation we have seen\n  uint256 public count;\n\n  event SetAuctionAverageLookback(uint256 lookback);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetAuction(address auction);\n  event AbovePegObservation(uint256 amount);\n  event BelowPegObservation(uint256 amount);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _stabilizerNode,\n    address _auction,\n    uint256 _period\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    stabilizerNode = IStabilizerNode(_stabilizerNode);\n    auction = IAuction(_auction);\n    auctionAverageLookback = _period;\n\n    for (uint i = 0; i < _period; i++) {\n      pegObservations.push(0);\n    }\n  }\n\n  function consult(uint256 excess) public view returns (uint256) {\n    uint256 frequency = getPegDeltaFrequency();\n    uint256 participation = getAverageParticipation();\n\n    // Weight participation higher than frequency\n    uint256 skew = (frequency + (participation * 2)) / 3;\n\n    return excess.mul(skew).div(10000);\n  }\n\n  function getRealBurnBudget(\n    uint256 maxBurnSpend,\n    uint256 premiumExcess\n  ) public view returns(uint256) {\n    // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement\n    // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn\n\n    if (premiumExcess > maxBurnSpend) {\n      return premiumExcess;\n    }\n\n    uint256 usableExcess = maxBurnSpend.sub(premiumExcess);\n\n    if (usableExcess == 0) {\n      return premiumExcess;\n    }\n\n    uint256 burnable = consult(usableExcess);\n\n    return premiumExcess + burnable;\n  }\n\n  function getAverageParticipation() public view returns (uint256) {\n    uint256 initialAuction = 0;\n    uint256 currentAuctionId = auction.currentAuctionId();\n\n    if (currentAuctionId > auctionAverageLookback) {\n      initialAuction = currentAuctionId - auctionAverageLookback;\n    }\n\n    // Use the existing struct to avoid filling the stack with temp vars\n    AuctionData memory aggregate;\n\n    for (uint256 i = initialAuction; i < currentAuctionId; ++i) {\n      (uint256 commitments, uint256 maxCommitments) = auction.getAuctionCommitments(i);\n      aggregate.maxCommitments = aggregate.maxCommitments + maxCommitments;\n      aggregate.commitments = aggregate.commitments + commitments;\n    }\n\n    uint256 participation = 0;\n    if (aggregate.maxCommitments > 0) {\n      participation = aggregate.commitments.mul(10000).div(aggregate.maxCommitments);\n    }\n\n    return participation;\n  }\n\n  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count > auctionAverageLookback) {\n      initialIndex = count - auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }\n\n  function _getIndexOfObservation(uint _index) internal view returns (uint index) {\n    return _index % auctionAverageLookback;\n  }\n\n  /*\n   * The arguments passed into these observation functions are not currently used but they are added\n   * incase future versions to this contract want to use them. In that case the stabilizernode\n   * won't have to be changed as it is already passing in this argument.\n   */\n  function addAbovePegObservation(uint256 amount)\n    public\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be a stabilizer node to call this method\")\n  {\n    uint256 index = _getIndexOfObservation(count);\n    // above peg\n    pegObservations[index] = 1;\n\n    count = count + 1;\n    emit AbovePegObservation(amount);\n  }\n\n  function addBelowPegObservation(uint256 amount)\n    public\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be a stabilizer node to call this method\")\n  {\n    uint256 index = _getIndexOfObservation(count);\n    // below peg\n    pegObservations[index] = 0;\n\n    count = count + 1;\n    emit BelowPegObservation(amount);\n  }\n\n  function setNewStabilizerNode(address _node)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_node != address(0), \"Cannot set 0 address\");\n    _swapRole(_node, address(stabilizerNode), STABILIZER_NODE_ROLE);\n    stabilizerNode = IStabilizerNode(_node);\n    emit SetStabilizerNode(_node);\n  }\n\n  function setNewAuction(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auction != address(0), \"Cannot set 0 address\");\n    auction = IAuction(_auction);\n    emit SetAuction(_auction);\n  }\n\n  function setAuctionAverageLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have zero lookback period\");\n\n    if (_lookback > auctionAverageLookback) {\n      for (uint i = auctionAverageLookback; i < _lookback; i++) {\n        pegObservations.push(0);\n      }\n    }\n\n    auctionAverageLookback = _lookback;\n    emit SetAuctionAverageLookback(_lookback);\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-malt#h-04-auctionburnreserveskewgetpegdeltafrequency-wrong-implementation-can-result-in-an-improper-amount-of-excess-liquidity-extension-balance-to-be-used-at-the-end-of-an-auction-",
                "Location": "  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count > auctionAverageLookback) {\n      initialIndex = count - auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. When count < auctionAverageLookback, at L131, it should be return total * 10000 / count;. The current implementation will return a smaller value than expected. The result of getPegDeltaFrequency() will be used for calculating realBurnBudget for auctions. With the result of getPegDeltaFrequency() being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../utils/types/UFixed18.sol\";\n\n/// @dev OptimisticLedger type\nstruct OptimisticLedger {\n    /// @dev Individual account collateral balances\n    mapping(address => UFixed18) balances;\n\n    /// @dev Total ledger collateral balance\n    UFixed18 total;\n\n    /// @dev Total ledger collateral shortfall\n    UFixed18 shortfall;\n}\n\n/**\n * @title OptimisticLedgerLib\n * @notice Library that manages a global vs account ledger where the global ledger is settled separately,\n *         and ahead of, the user-level accounts.\n * @dev    Ensures that no more collateral leaves the ledger than goes it, while allowing user-level accounts\n *         to settle as a follow up step. Overdrafts on the user-level are accounted as \"shortall\". Shortfall\n *         in the system is the quantity of insolvency that can be optionally resolved by the ledger owner.\n *         Until the shortfall is resolved, collateral may be withdrawn from the ledger on a FCFS basis. However\n *         once the ledger total has been depleted, users will not be able to withdraw even if they have non-zero\n *         user level balances until the shortfall is resolved, recapitalizing the ledger.\n */\nlibrary OptimisticLedgerLib {\n    using UFixed18Lib for UFixed18;\n    using Fixed18Lib for Fixed18;\n\n    /**\n     * @notice Credits `account` with `amount` collateral\n     * @param self The struct to operate on\n     * @param account Account to credit collateral to\n     * @param amount Amount of collateral to credit\n     */\n    function creditAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {\n        self.balances[account] = self.balances[account].add(amount);\n        self.total = self.total.add(amount);\n    }\n\n    /**\n     * @notice Debits `account` `amount` collateral\n     * @param self The struct to operate on\n     * @param account Account to debit collateral from\n     * @param amount Amount of collateral to debit\n     */\n    function debitAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {\n        self.balances[account] = self.balances[account].sub(amount);\n        self.total = self.total.sub(amount);\n    }\n\n    /**\n     * @notice Credits `account` with `amount` collateral\n     * @dev Funds come from inside the product, not totals are updated\n     *      Shortfall is created if more funds are debited from an account than exist\n     * @param self The struct to operate on\n     * @param account Account to credit collateral to\n     * @param amount Amount of collateral to credit\n     */\n    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\n    internal returns (UFixed18 shortfall) {\n        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n        if (newBalance.sign() == -1) {\n            shortfall = self.shortfall.add(newBalance.abs());\n            newBalance = Fixed18Lib.ZERO;\n        }\n\n        self.balances[account] = newBalance.abs();\n        self.shortfall = self.shortfall.add(shortfall);\n    }\n\n    /**\n     * @notice Debits ledger globally `amount` collateral\n     * @dev Removes balance from total that is accounted for elsewhere (e.g. product-level accumulators)\n     * @param self The struct to operate on\n     * @param amount Amount of collateral to debit\n     */\n    function debit(OptimisticLedger storage self, UFixed18 amount) internal {\n        self.total = self.total.sub(amount);\n    }\n\n    /**\n     * @notice Reduces the amount of collateral shortfall in the ledger\n     * @param self The struct to operate on\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolve(OptimisticLedger storage self, UFixed18 amount) internal {\n        self.shortfall = self.shortfall.sub(amount);\n        self.total = self.total.add(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-perennial#h-01-wrong-shortfall-calculation",
                "Location": "    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\n    internal returns (UFixed18 shortfall) {\n        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n        if (newBalance.sign() == -1) {\n            shortfall = self.shortfall.add(newBalance.abs());\n            newBalance = Fixed18Lib.ZERO;\n        }\n\n        self.balances[account] = newBalance.abs();\n        self.shortfall = self.shortfall.add(shortfall);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-sublime#h-02-wrong-returns-of-savingsaccountutildepositfromsavingsaccount-can-cause-fund-loss",
                "Location": "_sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),",
                "Type": "Erroneous state updates",
                "Description": "Returning an unexpected value that deviates from the expected semantics specified for the contract. The function SavingsAccountUtil.depositFromSavingsAccount() is expected to return the number of equivalent shares for given _asset.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-streaming#h-03-reward-token-not-correctly-recovered",
                "Location": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The Streaming contract allows recovering the reward token by calling recoverTokens(rewardToken, recipient). However, the excess amount is computed incorrectly as ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount). Note that rewardTokenAmount only ever increases (when calling fundStream) but it never decreases when claiming the rewards through claimReward. However, claimReward transfers out the reward token. Therefore, the rewardTokenAmount never tracks the contract\ufffd\ufffds reward balance and the excess cannot be computed that way.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-streaming#h-10-recovertokens-doesnt-work-when-issale-is-true",
                "Location": "uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. This breaks in the case where isSale is true and the deposit tokens have already been claimed through the use of creatorClaimSoldTokens. In this case, redemeedDepositTokens will be zero, and depositTokenAmount will still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./BoringCrypto/BoringMath.sol\";\nimport \"./BoringCrypto/BoringERC20.sol\";\nimport \"./BoringCrypto/Domain.sol\";\nimport \"./BoringCrypto/ERC20.sol\";\nimport \"./BoringCrypto/IERC20.sol\";\nimport \"./BoringCrypto/BoringOwnable.sol\";\nimport \"./IsYETIRouter.sol\";\n\n\ninterface IYETIToken is IERC20 {\n    function sendToSYETI(address _sender, uint256 _amount) external;\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)\n// modified by BoringCrypto for DictatorDAO\n\n\n// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 \n// Each rebase increases the effective yetibalance by a certain amount of the total value\n// of the contract, which is equal to the yusd balance + the last price which the buyback \n// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200\n// of the total value of the contract is added to the effective yetibalance. Also updated on \n// mint and withdraw, because that is actual value that is added to the contract. \n\ncontract sYETIToken is IERC20, Domain, BoringOwnable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n\n    string public constant symbol = \"sYETI\";\n    string public constant name = \"Staked YETI Tokens\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 private constant LOCK_TIME = 69 hours;\n    uint256 public effectiveYetiTokenBalance;\n    uint256 public lastBuybackTime;\n    uint256 public lastBuybackPrice;\n    uint256 public lastRebaseTime;\n    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. \n    IYETIToken public yetiToken;\n    IERC20 public yusdToken;\n    bool private addressesSet;\n\n\n    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain\n    // and do that one. \n    mapping(address => bool) public validRouters;\n\n    struct User {\n        uint128 balance;\n        uint128 lockedUntil;\n    }\n\n    /// @notice owner > balance mapping.\n    mapping(address => User) public users;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);\n    event Rebase(uint additionalYetiTokenBalance);\n\n    function balanceOf(address user) public view override returns (uint256) {\n        return users[user].balance;\n    }\n\n    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        yetiToken = _yeti;\n        yusdToken = _yusd;\n        addressesSet = true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        User memory fromUser = users[from];\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n        if (shares != 0) {\n            require(fromUser.balance >= shares, \"Low balance\");\n            if (from != to) {\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n                User memory toUser = users[to];\n                uint128 shares128 = shares.to128();\n                users[from].balance = fromUser.balance - shares128; // Underflow is checked\n                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;\n            }\n        }\n        emit Transfer(from, to, shares);\n    }\n\n    function _useAllowance(address from, uint256 shares) internal {\n        if (msg.sender == from) {\n            return;\n        }\n        uint256 spenderAllowance = allowance[from][msg.sender];\n        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n        if (spenderAllowance != type(uint256).max) {\n            require(spenderAllowance >= shares, \"Low allowance\");\n            uint256 newAllowance = spenderAllowance - shares;\n            allowance[from][msg.sender] = newAllowance; // Underflow is checked\n            emit Approval(from, msg.sender, newAllowance);\n        }\n    }\n\n    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param shares of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 shares) public returns (bool) {\n        _transfer(msg.sender, to, shares);\n        return true;\n    }\n\n    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param shares The token shares to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _transfer(from, to, shares);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] += amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    \n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"Zero owner\");\n        require(block.timestamp < deadline, \"Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n            owner_,\n            \"Invalid Sig\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n\n    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18\n    /// theoretically you can grow the amount/share ratio, but it's not practical and useless\n    function mint(uint256 amount) public returns (bool) {\n        User memory user = users[msg.sender];\n\n        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;\n        user.balance += shares.to128();\n        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n        users[msg.sender] = user;\n        totalSupply += shares;\n\n        yetiToken.sendToSYETI(msg.sender, amount);\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);\n\n        emit Transfer(address(0), msg.sender, shares);\n        return true;\n    }\n\n    function _burn(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        require(to != address(0), \"Zero address\");\n        User memory user = users[from];\n        require(block.timestamp >= user.lockedUntil, \"Locked\");\n        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;\n        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n        totalSupply -= shares;\n\n        yetiToken.transfer(to, amount);\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);\n\n        emit Transfer(from, address(0), shares);\n    }\n\n    function burn(address to, uint256 shares) public returns (bool) {\n        _burn(msg.sender, to, shares);\n        return true;\n    }\n\n    function burnFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _burn(from, to, shares);\n        return true;\n    }\n\n    /** \n     * Buyback function called by owner of function. Keeps track of the \n     */\n    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {\n        require(_YUSDToSell != 0, \"Zero amount\");\n        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, \"Not enough YUSD in contract\");\n        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);\n    }\n\n    /** \n     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.\n     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock \n     * in order to activate. \n     * No YUSDToSell param since this just does 5% of the YUSD in the contract.\n     */\n    function publicBuyBack(address _routerAddress) external {\n        uint256 YUSDBalance = yusdToken.balanceOf(address(this));\n        require(YUSDBalance != 0, \"No YUSD in contract\");\n        require(lastBuybackTime + 169 hours < block.timestamp, \"Can only publicly buy back every 169 hours\");\n        // Get 5% of the YUSD in the contract\n        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract\n        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);\n        _buyBack(_routerAddress, YUSDToSell, 0);\n    }\n\n    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. \n    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {\n        // Checks internal mapping to see if router is valid\n        require(validRouters[_routerAddress] == true, \"Invalid router passed in\");\n        require(yusdToken.approve(_routerAddress, 0));\n        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));\n        lastBuybackTime = block.timestamp;\n        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));\n        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]\n        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);\n        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);\n    }\n\n    // Rebase function for adding new value to the sYETI - YETI ratio. \n    function rebase() external {\n        require(block.timestamp >= lastRebaseTime + 8 hours, \"Can only rebase every 8 hours\");\n        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns \n        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance\n\n        // raw balance of the contract\n        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  \n        // amount of YETI free / available to give out\n        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); \n        // in YETI, amount that should be eligible to give out.\n        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); \n        // in YETI, amount to rebase\n        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); \n        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. \n        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase\n        if (amountYetiToRebase > adjustedYetiTokenBalance) {\n            amountYetiToRebase = adjustedYetiTokenBalance;\n        }\n        // rebase amount joins the effective supply. \n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);\n        // update rebase time\n        lastRebaseTime = block.timestamp;\n        emit Rebase(amountYetiToRebase);\n    }\n\n    // Sums YUSD balance + old price. \n    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI \n    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.\n    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {\n        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\n        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);\n    }\n\n    // Sets new transfer ratio for rebasing\n    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {\n        require(newTransferRatio != 0, \"Zero transfer ratio\");\n        require(newTransferRatio <= 1e18, \"Transfer ratio too high\");\n        transferRatio = newTransferRatio;\n    }\n    \n    // TODO - add time delay for setting new valid router. \n    function addValidRouter(address _routerAddress) external onlyOwner {\n        require(_routerAddress != address(0), \"Invalid router address\");\n        validRouters[_routerAddress] = true;\n    }\n\n    // TODO - add time delay for invalidating router. \n    function removeValidRouter(address _routerAddress) external onlyOwner {\n        validRouters[_routerAddress] = false;\n    }\n\n    // Safe divide\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b != 0, \"BoringMath: Div By 0\");\n        return a / b;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-yetifinance#h-02-yeti-token-rebase-checks-the-additional-token-amount-incorrectly",
                "Location": "    function rebase() external {\n        require(block.timestamp >= lastRebaseTime + 8 hours, \"Can only rebase every 8 hours\");\n        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns \n        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance\n\n        // raw balance of the contract\n        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  \n        // amount of YETI free / available to give out\n        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); \n        // in YETI, amount that should be eligible to give out.\n        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); \n        // in YETI, amount to rebase\n        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); \n        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. \n        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase\n        if (amountYetiToRebase > adjustedYetiTokenBalance) {\n            amountYetiToRebase = adjustedYetiTokenBalance;\n        }\n        // rebase amount joins the effective supply. \n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);\n        // update rebase time\n        lastRebaseTime = block.timestamp;\n        emit Rebase(amountYetiToRebase);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The condition isn\ufffd\ufffdt checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it\ufffd\ufffds not checked, the amount added to effectiveYetiTokenBalance during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case. The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users\ufffd\ufffd claims. In other words, the contract will be in default if enough users claim after that.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getStaleVaderPrice() external view returns (uint256) {\n        uint256 totalPairs = vaderPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.VADER)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function getStaleUSDVPrice() external view returns (uint256) {\n        uint256 totalPairs = usdvPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.USDV)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function getChainlinkPrice(address asset) public view returns (uint256) {\n        IAggregatorV3 oracle = oracles[asset];\n\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle\n            .latestRoundData();\n\n        require(\n            answeredInRound >= roundID,\n            \"LBTWAP::getChainlinkPrice: Stale Chainlink Price\"\n        );\n\n        require(price > 0, \"LBTWAP::getChainlinkPrice: Chainlink Malfunction\");\n\n        return uint256(price);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function getVaderPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncVaderPrice();\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n    function _calculateVaderPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalVaderLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalVader;\n        uint256 totalPairs = vaderPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n\n            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n\n            totalVader +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalVader;\n    }\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] != 0,\n            \"LBTWAP::addVaderPair: Vader Uninitialized\"\n        );\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n    function getUSDVPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncUSDVPrice();\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function syncUSDVPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = usdvPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateUSDVPrice(\n                foreignAsset,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;\n    }\n\n    function _updateUSDVPrice(\n        IERC20 foreignAsset,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        (\n            uint256 nativeTokenPriceCumulative,\n            ,\n            uint256 currentMeasurement\n        ) = vaderPool.cumulativePrices(foreignAsset);\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n    }\n\n    function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }\n\n    function setupUSDV(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 usdvPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] == 0,\n            \"LBTWAP::setupUSDV: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.USDV)] = usdvPrice;\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] != 0,\n            \"LBTWAP::addUSDVPair: USDV Uninitialized\"\n        );\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    function _addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addUSDVPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addUSDVPair: Non-USD Oracle\");\n\n        oracles[address(foreignAsset)] = oracle;\n\n        ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n        // NOTE: Redundant\n        // pairData.foreignAsset = foreignAsset;\n\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(\n            foreignAsset\n        );\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;\n\n        usdvPairs.push(foreignAsset);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-vader#h-04-vader-twap-averages-wrong",
                "Location": "    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The vader price in LiquidityBasedTWAP.getVaderPrice is computed using the pastLiquidityWeights and pastTotalLiquidityWeight return values of the syncVaderPrice. The syncVaderPrice function does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-vader#h-05-oracle-returns-an-improperly-scaled-usdvvader-price",
                "Location": "        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The LBT oracle does not properly scale values when calculating prices for VADER or USDV. ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\ncontract VaderReserve is IVaderReserve, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe VADER transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The Vader token the reserve is handling\n    IERC20 public immutable vader;\n\n    // Router address for IL awards\n    address public router;\n\n    // Tracks last grant time for throttling\n    uint256 public lastGrant;\n\n    // LBT used for loss reimbursement\n    ILiquidityBasedTWAP public lbt;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20 _vader) {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS),\n            \"VaderReserve::constructor: Incorrect Arguments\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function reserve() public view override returns (uint256) {\n        return vader.balanceOf(address(this));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function grant(address recipient, uint256 amount)\n        external\n        override\n        onlyOwner\n        throttle\n    {\n        amount = _min(\n            (reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS,\n            amount\n        );\n        vader.safeTransfer(recipient, amount);\n\n        emit GrantDistributed(recipient, amount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function initialize(\n        ILiquidityBasedTWAP _lbt,\n        address _router,\n        address _dao\n    ) external onlyOwner {\n        require(\n            _router != _ZERO_ADDRESS &&\n                _dao != _ZERO_ADDRESS &&\n                _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"VaderReserve::initialize: Incorrect Arguments\"\n        );\n        router = _router;\n        lbt = _lbt;\n        transferOwnership(_dao);\n    }\n\n    function reimburseImpermanentLoss(address recipient, uint256 amount)\n        external\n        override\n    {\n        require(\n            msg.sender == router,\n            \"VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges\"\n        );\n\n        // NOTE: Loss is in USDV, reimbursed in VADER\n        // NOTE: If USDV LBT is working, prefer it otherwise use VADER price\n        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }\n\n        uint256 actualAmount = _min(reserve(), amount);\n\n        vader.safeTransfer(recipient, actualAmount);\n\n        emit LossCovered(recipient, amount, actualAmount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier throttle() {\n        require(\n            lastGrant + _GRANT_DELAY <= block.timestamp,\n            \"VaderReserve::throttle: Grant Too Fast\"\n        );\n        lastGrant = block.timestamp;\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-vader#h-08-reserve-does-not-properly-apply-prices-of-vader-and-usdv-tokens",
                "Location": "        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Here we multiply the IL experienced by the LP by a price for USDV or VADER as returned by the LBT. However the price from the oracle is a fixed point number (scaled up by 1e8 or 1e18 depending on the resolution of finding \ufffd\ufffdOracle returns an improperly scaled USDV/VADER price\ufffd\ufffd) and so a fixed scaling factor should be applied to convert back from a fixed point number to a standard integer. As it stands depending on the branch which is executed, the amount to be reimbursed will be 1e18 times too large or too small. Should the \ufffd\ufffdelse\ufffd\ufffd branch be executed the reserve will pay out much in terms of IL protection resulting in severe loss of funds. High severity.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/shared/IERC20Extended.sol\";\nimport \"../interfaces/tokens/IUSDV.sol\";\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\n// TBD\ncontract USDV is IUSDV, ProtocolConstants, ERC20, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20Extended;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The VADER token used for burns and mints\n    IERC20Extended public immutable vader;\n\n    // The LBT pricing mechanism for the conversion\n    ILiquidityBasedTWAP public lbt;\n\n    // The exchange fee if any applied to burns and mints\n    uint256 public exchangeFee;\n\n    // The 24 hour limit on USDV mints\n    uint256 public dailyLimit = type(uint256).max;\n\n    // The current cycle end timestamp\n    uint256 public cycleTimestamp;\n\n    // The current cycle cumulative mints\n    uint256 public cycleMints;\n\n    // All mint/burn locks\n    mapping(address => Lock[]) public locks;\n\n    // Guardian Account\n    address public guardian;\n\n    // Lock system\n    bool private isLocked;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20Extended _vader) ERC20(\"Vader USD\", \"USDV\") {\n        require(\n            _vader != IERC20Extended(_ZERO_ADDRESS),\n            \"USDV::constructor: Improper Configuration\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function mint(uint256 vAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 uAmount)\n    {\n        uint256 vPrice = lbt.getVaderPrice();\n\n        vader.transferFrom(msg.sender, address(this), vAmount);\n        vader.burn(vAmount);\n\n        uAmount = (vPrice * vAmount) / 1e18;\n\n        if (cycleTimestamp <= block.timestamp) {\n            cycleTimestamp = block.timestamp + 24 hours;\n            cycleMints = uAmount;\n        } else {\n            cycleMints += uAmount;\n            require(\n                cycleMints <= dailyLimit,\n                \"USDV::mint: 24 Hour Limit Reached\"\n            );\n        }\n\n        if (exchangeFee != 0) {\n            uint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            uAmount = uAmount - fee;\n            _mint(owner(), fee);\n        }\n\n        _mint(address(this), uAmount);\n\n        _createLock(LockTypes.USDV, uAmount);\n    }\n\n    function burn(uint256 uAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 vAmount)\n    {\n        uint256 uPrice = lbt.getUSDVPrice();\n\n        _burn(msg.sender, uAmount);\n\n        vAmount = (uPrice * uAmount) / 1e18;\n\n        if (exchangeFee != 0) {\n            uint256 fee = (vAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            vAmount = vAmount - fee;\n            vader.mint(owner(), fee);\n        }\n\n        vader.mint(address(this), vAmount);\n\n        _createLock(LockTypes.VADER, vAmount);\n    }\n\n    function claim(uint256 i) external onlyWhenNotLocked returns (uint256) {\n        Lock[] storage userLocks = locks[msg.sender];\n        Lock memory lock = userLocks[i];\n\n        require(lock.release <= block.timestamp, \"USDV::claim: Vesting\");\n\n        uint256 last = userLocks.length - 1;\n        if (i != last) {\n            userLocks[i] = userLocks[last];\n        }\n\n        userLocks.pop();\n\n        if (lock.token == LockTypes.USDV)\n            _transfer(address(this), msg.sender, lock.amount);\n        else vader.transfer(msg.sender, lock.amount);\n\n        emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n\n        return lock.amount;\n    }\n\n    function claimAll()\n        external\n        onlyWhenNotLocked\n        returns (uint256 usdvAmount, uint256 vaderAmount)\n    {\n        Lock[] memory userLocks = locks[msg.sender];\n        delete locks[msg.sender];\n\n        for (uint256 i = 0; i < userLocks.length; i++) {\n            Lock memory lock = userLocks[i];\n\n            require(lock.release <= block.timestamp, \"USDV::claimAll: Vesting\");\n\n            if (lock.token == LockTypes.USDV) {\n                _transfer(address(this), msg.sender, lock.amount);\n                usdvAmount += lock.amount;\n            } else {\n                vader.transfer(msg.sender, lock.amount);\n                vaderAmount += lock.amount;\n            }\n\n            emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n        }\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setLBTwap(ILiquidityBasedTWAP _lbt) external onlyOwner {\n        require(\n            _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"USDV::initialize: Improper Configuration\"\n        );\n        lbt = _lbt;\n    }\n\n    function setFee(uint256 _exchangeFee) external onlyOwner {\n        require(\n            _exchangeFee <= _MAX_BASIS_POINTS,\n            \"USDV::setFee: Fee Out of Bounds\"\n        );\n        emit ExchangeFeeChanged(exchangeFee, _exchangeFee);\n        exchangeFee = _exchangeFee;\n    }\n\n    function setDailyLimit(uint256 _dailyLimit) external onlyOwner {\n        emit DailyLimitChanged(dailyLimit, _dailyLimit);\n        dailyLimit = _dailyLimit;\n    }\n\n    function setGuardian(address _guardian) external onlyOwner {\n        require(_guardian != address(0), \"USDV::setGuardian: Zero address\");\n        guardian = _guardian;\n    }\n\n    function setLock(bool _lock) external {\n        require(\n            msg.sender == owner() || msg.sender == guardian,\n            \"USDV::setLock: Insufficient Privileges\"\n        );\n        isLocked = _lock;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    function _createLock(LockTypes lockType, uint256 amount) private {\n        uint256 release = block.timestamp + lbt.maxUpdateWindow();\n\n        locks[msg.sender].push(Lock(lockType, amount, release));\n\n        emit LockCreated(msg.sender, lockType, amount, release);\n    }\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyWhenNotLocked() {\n        require(!isLocked);\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-vader#h-09-usdvsol-mint-and-burn-amounts-are-incorrect",
                "Location": "    function mint(uint256 vAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 uAmount)\n    {\n        uint256 vPrice = lbt.getVaderPrice();\n\n        vader.transferFrom(msg.sender, address(this), vAmount);\n        vader.burn(vAmount);\n\n        uAmount = (vPrice * vAmount) / 1e18;\n\n        if (cycleTimestamp <= block.timestamp) {\n            cycleTimestamp = block.timestamp + 24 hours;\n            cycleMints = uAmount;\n        } else {\n            cycleMints += uAmount;\n            require(\n                cycleMints <= dailyLimit,\n                \"USDV::mint: 24 Hour Limit Reached\"\n            );\n        }\n\n        if (exchangeFee != 0) {\n            uint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            uAmount = uAmount - fee;\n            _mint(owner(), fee);\n        }\n\n        _mint(address(this), uAmount);\n\n        _createLock(LockTypes.USDV, uAmount);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The USDV.mint function queries the price of Vader from the LiquidityBasedTwap contract. The calculation to determine uAmount in mint is actually performed incorrectly. uAmount = (vPrice * vAmount) / 1e18; will return the USD amount for the provided Vader as vPrice is denominated in USD/Vader. This uAmount is subsequently used when minting tokens for the user (locked for a period of time) and fee to the contract owner.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../facades/TokenProxyLike.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n///@title Rebase Proxy\n///@author Justin Goro\n/**@notice expresses the balance changes of a rebase token as a fluctuating redeem rate, allowing for balanceOf stability. Useful for dapps which maintain their own balance values\n* Very large rebase down movement tokens are still discouraged as this could cause threshold instability.\n*/\n///@dev TokenProxyRegistry contract maps this token to a base token.\ncontract RebaseProxy is ERC20, TokenProxyLike {\n    constructor(\n        address _baseToken,\n        string memory name_,\n        string memory symbol_\n    ) TokenProxyLike(_baseToken) ERC20(name_, symbol_) {}\n\n    function redeemRate() public view returns (uint256) {\n        uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));\n        if (totalSupply() == 0 || balanceOfBase == 0) return ONE;\n\n        return (balanceOfBase * ONE) / totalSupply();\n    }\n\n    function mint(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        require(\n            IERC20(baseToken).transferFrom(msg.sender, address(this), amount)\n        );\n        uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));\n        uint256 proxy = (baseBalance * ONE) / _redeemRate;\n        _mint(to, proxy);\n    }\n\n    function redeem(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        uint256 baseTokens = (_redeemRate * amount) / ONE;\n        _burn(msg.sender, amount);\n        IERC20(baseToken).transfer(to, baseTokens);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-01-behodler#h-02-wrong-minting-amount",
                "Location": "    function mint(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        require(\n            IERC20(baseToken).transferFrom(msg.sender, address(this), amount)\n        );\n        uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));\n        uint256 proxy = (baseBalance * ONE) / _redeemRate;\n        _mint(to, proxy);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. wrong minting amount",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        require(\n            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||\n                IJoePair(\n                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)\n                ).totalSupply() ==\n                0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(wavaxReserve > 0, \"LaunchEvent: no wavax balance\");\n\n        uint256 tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (\n            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated\n        ) {\n            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        WAVAX.approve(address(router), wavaxReserve);\n        token.approve(address(router), tokenAllocated);\n\n        /// We can't trust the output cause of reflect tokens\n        (, , lpSupply) = router.addLiquidity(\n            wavaxAddress, // tokenA\n            tokenAddress, // tokenB\n            wavaxReserve, // amountADesired\n            tokenAllocated, // amountBDesired\n            wavaxReserve, // amountAMin\n            tokenAllocated, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));\n        wavaxAllocated = wavaxReserve;\n        wavaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            wavaxAllocated\n        );\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-01-trader-joe#h-02-wrong-token-allocation-computation-for-token-decimals--18-if-floor-price-not-reached",
                "Location": "tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. In LaunchEvent.createPair, when the floor price is not reached (floorPrice > wavaxReserve * 1e18 / tokenAllocated), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price. Note that the floorPrice is supposed to have a precision of 18: /// @param _floorPrice Price of each token in AVAX, scaled to 1e18 The floorPrice > (wavaxReserve * 1e18) / tokenAllocated check is correct but the tokenAllocated computation involves the token decimals",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount; // How many tokens the user has provided.\n        uint128 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of RADSs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.\n        uint lastRewardBlock; // Last block number that distribution occurs.\n        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.\n        uint16 depositFeeBP; // Deposit fee in basis points\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid; // pid mapped to token\n    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block\n    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint public startBlock;\n    uint public endBlock; // The block number when mining starts.\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function addDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = true;\n    }\n\n    function removeDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = false;\n    }\n\n    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {\n        require(_token != address(0), \"zero address\");\n        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocationPoints);\n        require(pid[_token] == 0, \"already registered\"); // pid starts from 0\n        poolInfo.push(\n            PoolInfo({\n                depositToken: IERC20(_token),\n                allocPoint: _allocationPoints,\n                lastRewardBlock: lastRewardBlock,\n                accConcurPerShare: 0,\n                depositFeeBP: _depositFee\n            })\n        );\n        pid[_token] = poolInfo.length - 1;\n    }\n\n    function poolLength() external view returns (uint) {\n        return poolInfo.length;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    // View function to see pending [concur] on frontend.\n    function pendingConcur(uint _pid, address _user) external view returns (uint) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint accConcurPerShare = pool.accConcurPerShare;\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        }\n        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint length = poolInfo.length;\n        for (uint _pid = 0; _pid < length; ++_pid) {\n            updatePool(_pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit tokens for [concur] allocation.  \n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    // Withdraw tokens\n    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        require(user.amount > 0, \"MasterChef: nothing to withdraw\");\n        require(user.amount >= _amount, \"MasterChef: withdraw not allowed\");\n        updatePool(_pid);\n\n        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n        if(pending > 0) {\n            safeConcurTransfer(_recipient, pending);\n        }\n        if (_amount > 0) {\n            user.amount = SafeCast.toUint128(user.amount - _amount);\n        }\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Withdraw(_recipient, _pid, _amount);\n    }\n\n    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-02-concur#h-02-masterchef-improper-handling-of-deposit-fee",
                "Location": "            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. If a pool\ufffd\ufffds deposit fee is non-zero, it is subtracted from the amount to be credited to the user. However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4646 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @dev Do not use in production! ERC-4626 is still in the review stage and is subject to change.\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed from, address indexed to, uint256 amount, uint256 shares);\n\n    event Withdraw(address indexed from, address indexed to, uint256 amount, uint256 shares);\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    uint256 internal immutable ONE;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n\n        unchecked {\n            ONE = 10**decimals; // >77 decimals is unlikely.\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 amount, address to) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(amount)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        _mint(to, shares);\n\n        emit Deposit(msg.sender, to, amount, shares);\n\n        afterDeposit(amount, shares);\n    }\n\n    function mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n        amount = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        _mint(to, amount);\n\n        emit Deposit(msg.sender, to, amount, shares);\n\n        afterDeposit(amount, shares);\n    }\n\n    function withdraw(\n        uint256 amount,\n        address to,\n        address from\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(amount); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != from) {\n            uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(amount, shares);\n\n        _burn(from, shares);\n\n        emit Withdraw(from, to, amount, shares);\n\n        asset.safeTransfer(to, amount);\n    }\n\n    function redeem(\n        uint256 shares,\n        address to,\n        address from\n    ) public virtual returns (uint256 amount) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (msg.sender != from && allowed != type(uint256).max) allowance[from][msg.sender] = allowed - shares;\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((amount = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(amount, shares);\n\n        _burn(from, shares);\n\n        emit Withdraw(from, to, amount, shares);\n\n        asset.safeTransfer(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function assetsOf(address user) public view virtual returns (uint256) {\n        return previewRedeem(balanceOf[user]);\n    }\n\n    function assetsPerShare() public view virtual returns (uint256) {\n        return previewRedeem(ONE);\n    }\n\n    function previewDeposit(uint256 amount) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? amount : amount.mulDivDown(supply, totalAssets());\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 amount) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? amount : amount.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address user) public virtual returns (uint256) {\n        return assetsOf(user);\n    }\n\n    function maxRedeem(address user) public virtual returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 amount, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 amount, uint256 shares) internal virtual {}\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-02-tribe-turbo#h-01-erc4626-mint-uses-wrong-amount",
                "Location": "function mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n    amount = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    _mint(to, amount);\n    emit Deposit(msg.sender, to, amount, shares);\n    afterDeposit(amount, shares);\n}",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The ERC4626.mint function mints amount instead of shares. This will lead to issues when the asset <> shares are not 1-to-1 as will be the case for most vaults over time. Usually, the asset amount is larger than the share amount as vaults receive asset yield. Therefore, when minting, shares should be less than amount. Users receive a larger share amount here which can be exploited to drain the vault assets.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-03-biconomy#h-03-wrong-formula-when-add-fee-incentivepool-can-lead-to-loss-of-funds",
                "Location": "            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The getAmountToTransfer function of LiquidityPool updates incentivePool[tokenAddress] by adding some fee to it but the formula is wrong and the value of incentivePool[tokenAddress] will be divided by BASE_DIVISOR (10000000000) each time. After just a few time, the value of incentivePool[tokenAddress] will become zero and that amount of tokenAddress token will be locked in contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-03-sublime#h-01-lenderpool-principal-withdrawable-is-incorrectly-calculated-if-start-is-invoked-with-non-zero-start-fee",
                "Location": "function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}",
                "Type": "Erroneous state updates",
                "Description": "Returning an unexpected value that deviates from the expected semantics specified for the contract. The _principalWithdrawable calculated will be more than expected if _start() is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in totalSupply[id] not being 1:1 with the borrow limit.",
                "Repair": ""
            }
        ]
    }
]