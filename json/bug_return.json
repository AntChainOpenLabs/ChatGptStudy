[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./IBadgerSett.sol\";\nimport \"./IBadger.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title A pooltogether yield source for badger sett\n/// @author Steffel Fenix, 0xkarl\ncontract BadgerYieldSource is IYieldSource {\n    using SafeMath for uint256;\n    IBadgerSett private immutable badgerSett;\n    IBadger private immutable badger;\n    mapping(address => uint256) private balances;\n\n    constructor(address badgerSettAddr, address badgerAddr) public {\n        badgerSett = IBadgerSett(badgerSettAddr);\n        badger = IBadger(badgerAddr);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return (address(badger));\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = badgerSett.totalSupply();\n        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));\n        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));\n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        badger.transferFrom(msg.sender, address(this), amount);\n        badger.approve(address(badgerSett), amount);\n\n        uint256 beforeBalance = badgerSett.balanceOf(address(this));\n        badgerSett.deposit(amount);\n        uint256 afterBalance = badgerSett.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @return The actual amount of tokens that were redeemed.\n    function redeemToken(uint256 amount) public override returns (uint256) {\n        uint256 totalShares = badgerSett.totalSupply();\n        if (totalShares == 0) return 0;\n\n        uint256 badgerSettBadgerBalance = badgerSett.balance();\n        if (badgerSettBadgerBalance == 0) return 0;\n\n        uint256 badgerBeforeBalance = badger.balanceOf(address(this));\n\n        uint256 requiredShares =\n            ((amount.mul(totalShares) + totalShares)).div(\n                badgerSettBadgerBalance\n            );\n        if (requiredShares == 0) return 0;\n\n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        badgerSett.withdraw(requiredSharesBalance);\n\n        uint256 badgerAfterBalance = badger.balanceOf(address(this));\n        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        badger.transfer(msg.sender, badgerBalanceDiff);\n        return (badgerBalanceDiff);\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ISushiBar.sol\";\nimport \"./ISushi.sol\";\n\n/// @title A pooltogether yield source for sushi token\n/// @author Steffel Fenix\ncontract SushiYieldSource is IYieldSource {\n    \n    using SafeMath for uint256;\n    \n    ISushiBar public immutable sushiBar;\n    ISushi public immutable sushiAddr;\n    \n    mapping(address => uint256) public balances;\n\n    constructor(ISushiBar _sushiBar, ISushi _sushiAddr) public {\n        sushiBar = _sushiBar;\n        sushiAddr = _sushiAddr;\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return address(sushiAddr);\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = sushiBar.totalSupply();\n        uint256 barSushiBalance = sushiAddr.balanceOf(address(sushiBar));\n\n        return balances[addr].mul(barSushiBalance).div(totalShares);       \n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        sushiAddr.transferFrom(msg.sender, address(this), amount);\n        sushiAddr.approve(address(sushiBar), amount);\n\n        ISushiBar bar = sushiBar;\n        uint256 beforeBalance = bar.balanceOf(address(this));\n        \n        bar.enter(amount);\n        \n        uint256 afterBalance = bar.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        \n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @dev The maxiumum that can be called for token() is calculated by balanceOfToken() above.\n    /// @return The actual amount of tokens that were redeemed. This may be different from the amount passed due to the fractional math involved. \n    function redeemToken(uint256 amount) public override returns (uint256) {\n        ISushiBar bar = sushiBar;\n        ISushi sushi = sushiAddr;\n\n        uint256 totalShares = bar.totalSupply();\n        if(totalShares == 0) return 0; \n\n        uint256 barSushiBalance = sushi.balanceOf(address(bar));\n        if(barSushiBalance == 0) return 0;\n\n        uint256 sushiBeforeBalance = sushi.balanceOf(address(this));\n\n        uint256 requiredShares = ((amount.mul(totalShares) + totalShares)).div(barSushiBalance);\n        if(requiredShares == 0) return 0;\n        \n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        bar.leave(requiredSharesBalance);\n\n        uint256 sushiAfterBalance = sushi.balanceOf(address(this));\n        \n        uint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        sushi.transfer(msg.sender, sushiBalanceDiff);\n        \n        return (sushiBalanceDiff);\n    }\n\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "ERC20 transfer and transferFrom in BadgerYieldSource and SushiYieldSource contracts",
                "Type": "Unchecked return values",
                "Description": "The return values of ERC20 transfer and transferFrom are not checked to be true, which could be false if the transferred tokens are not ERC20-compliant.",
                "Repair": "Use SafeERC20 library implementation and call safeTransfer or safeTransferFrom when transferring ERC20 tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\ninterface CErc20 {\n    function underlying() external view returns (address);\n}\n\ncontract UniswapConfig is Ownable {\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n    enum PriceSource {\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n        REPORTER   /// implies the price is set by the reporter\n    }\n\n    /// @dev Describe how the USD price should be determined for an asset.\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\n    struct TokenConfig {\n        address cToken;\n        address underlying;\n        bytes32 symbolHash;\n        uint256 baseUnit;\n        PriceSource priceSource;\n        uint256 fixedPrice;\n        address uniswapMarket;\n        bool isUniswapReversed;\n    }\n\n    mapping(uint => TokenConfig) public tokens;\n    mapping(address => uint) public cTokenIndex;\n    mapping(address => uint) public underlyingIndex;\n    mapping(bytes32 => uint) public symbolHashIndex;\n\n    /// @notice The number of tokens this contract actually supports\n    uint public numTokens;\n\n    function _addTokensInternal(TokenConfig[] memory configs) internal {\n        for (uint i = 0; i < configs.length; i++) {\n            uint index = i + numTokens;\n            tokens[index] = configs[i];\n            cTokenIndex[configs[i].cToken] = index;\n            underlyingIndex[configs[i].underlying] = index;\n            symbolHashIndex[configs[i].symbolHash] = index;\n        }\n\n        numTokens = numTokens + configs.length;\n    }\n\n    function getCTokenIndex(address cToken) internal view returns (uint) {\n        return cTokenIndex[cToken];\n    }\n\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\n        return underlyingIndex[underlying];\n    }\n\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n        return symbolHashIndex[symbolHash];\n    }\n\n    /**\n     * @notice Get the i-th config, according to the order they were passed in originally\n     * @param i The index of the config to get\n     * @return The config object\n     */\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\n        require(i < numTokens, \"token config not found\");\n\n        return tokens[i];\n    }\n\n    /**\n     * @notice Get the config for symbol\n     * @param symbol The symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n    }\n\n    /**\n     * @notice Get the config for the symbolHash\n     * @param symbolHash The keccack256 of the symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n        uint index = getSymbolHashIndex(symbolHash);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        revert(\"token config not found\");\n    }\n\n    /**\n     * @notice Get the config for the cToken\n     * @dev If a config for the cToken is not found, falls back to searching for the underlying.\n     * @param cToken The address of the cToken of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\n        uint index = getCTokenIndex(cToken);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        return getTokenConfigByUnderlying(CErc20(cToken).underlying());\n    }\n\n    /**\n     * @notice Get the config for an underlying asset\n     * @param underlying The address of the underlying asset of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n        uint index = getUnderlyingIndex(underlying);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        revert(\"token config not found\");\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "UniswapConfig.getTokenConfigBySymbolHash, getTokenConfigByCToken, getTokenConfigByUnderlying functions",
                "Type": "UniswapConfig getters return wrong token config",
                "Description": "The functions return wrong token config if token config does not exist.",
                "Repair": "Fix the non-existence check"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\nimport \"./interfaces/INFTOracle.sol\";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // \"Shares\" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 => TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // `calculateIntest`.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns \"second-order\" interest-on-interest, which\n    // itself earns \"third-order\" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \\           x^k                \\              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why \"at least\"? There are also rounding errors. See\n    // `calculateInterest` for more detail.\n    // The factorial in the denominator \"wins\"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the \"true\" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in \"total\"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address => uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"NFTPair: already initialized\");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), \"NFTPair: bad pair\");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, \"NFTPair: not the lender\");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration >= cur.duration &&\n                    params.valuation <= cur.valuation &&\n                    params.annualInterestBPS <= cur.annualInterestBPS &&\n                    params.ltvBPS <= cur.ltvBPS,\n                \"NFTPair: worse params\"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert(\"NFTPair: no collateral\");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function _requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes `tokenId` as collateral and transfers it to `to`.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, \"NFTPair: not the lender\");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS < amount, \"NFT is still valued\");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS &&\n                params.ltvBPS >= accepted.ltvBPS,\n            \"NFTPair: bad params\"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, \"Oracle: price too low.\");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256(\"Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256(\"Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");\n        } else {\n            require(block.timestamp <= signature.deadline, \"NFTPair: signature expired\");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, \"NFTPair: signature invalid\");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp <= signature.deadline, \"NFTPair: signature expired\");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, \"NFTPair: signature invalid\");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner's method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n > 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \\           principal * (t * aprBPS)^k        \\\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the \"theoretical\" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term_{k-1} * ------------                          (*)\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From (*) we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M >= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // <- Only overflow check we need\n        }\n\n        if (interest >= 2**128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, \"NFTPair: no loan\");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration > block.timestamp,\n            \"NFTPair: loan expired\"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), \"NFTPair: skim too much\");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), \"NFTPair: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"NFTPair: call failed\");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share > 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "NFTPairWithOracle contract",
                "Type": "Unchecked return value",
                "Description": "The success value returned by the get function of the INFTOracle interface is not checked in the NFTPairWithOracle contract, which may result in stale data being used and assets being lost. The vulnerability has been confirmed and upgraded to High severity.",
                "Repair": "Check the success value returned by the get function of the INFTOracle interface before using the rate value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./lib/ReentrancyGuarded.sol\";\nimport \"./lib/EIP712.sol\";\nimport \"./lib/MerkleVerifier.sol\";\nimport \"./interfaces/IExchange.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IExecutionDelegate.sol\";\nimport \"./interfaces/IPolicyManager.sol\";\nimport \"./interfaces/IMatchingPolicy.sol\";\nimport {\n  Side,\n  SignatureVersion,\n  AssetType,\n  Fee,\n  Order,\n  Input,\n  Execution\n} from \"./lib/OrderStructs.sol\";\n\n/**\n * @title Exchange\n * @dev Core exchange contract\n */\ncontract Exchange is IExchange, ReentrancyGuarded, EIP712, OwnableUpgradeable, UUPSUpgradeable {\n\n    /* Auth */\n    uint256 public isOpen;\n\n    modifier whenOpen() {\n        require(isOpen == 1, \"Closed\");\n        _;\n    }\n\n    modifier setupExecution() {\n        remainingETH = msg.value;\n        isInternal = true;\n        _;\n        remainingETH = 0;\n        isInternal = false;\n    }\n\n    modifier internalCall() {\n        require(isInternal, \"This function should not be called directly\");\n        _;\n    }\n\n    event Opened();\n    event Closed();\n\n    function open() external onlyOwner {\n        isOpen = 1;\n        emit Opened();\n    }\n    function close() external onlyOwner {\n        isOpen = 0;\n        emit Closed();\n    }\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n\n    /* Constants */\n    string public constant NAME = \"Exchange\";\n    string public constant VERSION = \"1.0\";\n    uint256 public constant INVERSE_BASIS_POINT = 10_000;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant POOL = 0xF66CfDf074D2FFD6A4037be3A669Ed04380Aef2B;\n\n\n    /* Variables */\n    IExecutionDelegate public executionDelegate;\n    IPolicyManager public policyManager;\n    address public oracle;\n    uint256 public blockRange;\n\n\n    /* Storage */\n    mapping(bytes32 => bool) public cancelledOrFilled;\n    mapping(address => uint256) public nonces;\n\n\n    /* Events */\n    event OrdersMatched(\n        address indexed maker,\n        address indexed taker,\n        Order sell,\n        bytes32 sellHash,\n        Order buy,\n        bytes32 buyHash\n    );\n\n    event OrderCancelled(bytes32 hash);\n    event NonceIncremented(address indexed trader, uint256 newNonce);\n\n    event NewExecutionDelegate(IExecutionDelegate indexed executionDelegate);\n    event NewPolicyManager(IPolicyManager indexed policyManager);\n    event NewOracle(address indexed oracle);\n    event NewBlockRange(uint256 blockRange);\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /* Constructor (for ERC1967) */\n    function initialize(\n        IExecutionDelegate _executionDelegate,\n        IPolicyManager _policyManager,\n        address _oracle,\n        uint _blockRange\n    ) external initializer {\n        __Ownable_init();\n        isOpen = 1;\n\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : NAME,\n            version           : VERSION,\n            chainId           : block.chainid,\n            verifyingContract : address(this)\n        }));\n\n        executionDelegate = _executionDelegate;\n        policyManager = _policyManager;\n        oracle = _oracle;\n        blockRange = _blockRange;\n    }\n\n    // temporary function for testing\n    function updateDomainSeparator() external {\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : NAME,\n            version           : VERSION,\n            chainId           : block.chainid,\n            verifyingContract : address(this)\n        }));\n    }\n\n\n    /* External Functions */\n    bool public isInternal = false;\n    uint256 public remainingETH = 0;\n\n    /**\n     * @dev _execute wrapper \n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function execute(Input calldata sell, Input calldata buy)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        _execute(sell, buy);\n        _returnDust();\n    }\n\n    /**\n     * @dev Bulk execute multiple matches\n     * @param executions Potential buy/sell matches\n     */\n    function bulkExecute(Execution[] calldata executions)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        /*\n        REFERENCE\n        uint256 executionsLength = executions.length;\n        for (uint8 i=0; i < executionsLength; i++) {\n            bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);\n            (bool success,) = address(this).delegatecall(data);\n        }\n        _returnDust(remainingETH);\n        */\n        uint256 executionsLength = executions.length;\n        for (uint8 i = 0; i < executionsLength; i++) {\n            assembly {\n                let memPointer := mload(0x40)\n\n                let order_location := calldataload(add(executions.offset, mul(i, 0x20)))\n                let order_pointer := add(executions.offset, order_location)\n\n                let size\n                switch eq(add(i, 0x01), executionsLength)\n                case 1 {\n                    size := sub(calldatasize(), order_pointer)\n                }\n                default {\n                    let next_order_location := calldataload(add(executions.offset, mul(add(i, 0x01), 0x20)))\n                    let next_order_pointer := add(executions.offset, next_order_location)\n                    size := sub(next_order_pointer, order_pointer)\n                }\n\n                mstore(memPointer, 0xe04d94ae00000000000000000000000000000000000000000000000000000000) // _execute\n                calldatacopy(add(0x04, memPointer), order_pointer, size)\n                // must be put in separate transaction to bypass failed executions\n                // must be put in delegatecall to maintain the authorization from the caller\n                let result := delegatecall(gas(), address(), memPointer, add(size, 0x04), 0, 0)\n            }\n        }\n        _returnDust();\n    }\n\n    function _returnDust() private {\n        uint256 _remainingETH = remainingETH;\n        assembly {\n            if gt(_remainingETH, 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n    }\n\n    /**\n     * @dev Match two orders, ensuring validity of the match, and execute all associated state transitions. Protected against reentrancy by a contract-global lock. Must be called internally.\n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function _execute(Input calldata sell, Input calldata buy)\n        public\n        payable\n        reentrancyGuard\n        internalCall\n    {\n        require(sell.order.side == Side.Sell);\n\n        bytes32 sellHash = _hashOrder(sell.order, nonces[sell.order.trader]);\n        bytes32 buyHash = _hashOrder(buy.order, nonces[buy.order.trader]);\n\n        require(_validateSignatures(sell, sellHash), \"Sell failed authorization\");\n        require(_validateSignatures(buy, buyHash), \"Buy failed authorization\");\n\n        require(_validateOrderParameters(sell.order, sellHash), \"Sell has invalid parameters\");\n        require(_validateOrderParameters(buy.order, buyHash), \"Buy has invalid parameters\");\n\n        (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType) = _canMatchOrders(sell.order, buy.order);\n\n        /* Mark orders as filled. */\n        cancelledOrFilled[sellHash] = true;\n        cancelledOrFilled[buyHash] = true;\n\n        _executeFundsTransfer(\n            sell.order.trader,\n            buy.order.trader,\n            sell.order.paymentToken,\n            sell.order.fees,\n            price\n        );\n        _executeTokenTransfer(\n            sell.order.collection,\n            sell.order.trader,\n            buy.order.trader,\n            tokenId,\n            amount,\n            assetType\n        );\n\n        emit OrdersMatched(\n            sell.order.listingTime <= buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order.listingTime > buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order,\n            sellHash,\n            buy.order,\n            buyHash\n        );\n\n        // return (price);\n    }\n\n    /**\n     * @dev Cancel an order, preventing it from being matched. Must be called by the trader of the order\n     * @param order Order to cancel\n     */\n    function cancelOrder(Order calldata order) public {\n        /* Assert sender is authorized to cancel order. */\n        require(msg.sender == order.trader);\n\n        bytes32 hash = _hashOrder(order, nonces[order.trader]);\n\n        require(!cancelledOrFilled[hash], \"Order already cancelled or filled\");\n\n        /* Mark order as cancelled, preventing it from being matched. */\n        cancelledOrFilled[hash] = true;\n        emit OrderCancelled(hash);\n    }\n\n    /**\n     * @dev Cancel multiple orders\n     * @param orders Orders to cancel\n     */\n    function cancelOrders(Order[] calldata orders) external {\n        for (uint8 i = 0; i < orders.length; i++) {\n            cancelOrder(orders[i]);\n        }\n    }\n\n    /**\n     * @dev Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order\n     */\n    function incrementNonce() external {\n        nonces[msg.sender] += 1;\n        emit NonceIncremented(msg.sender, nonces[msg.sender]);\n    }\n\n\n    /* Setters */\n\n    function setExecutionDelegate(IExecutionDelegate _executionDelegate)\n        external\n        onlyOwner\n    {\n        require(address(_executionDelegate) != address(0), \"Address cannot be zero\");\n        executionDelegate = _executionDelegate;\n        emit NewExecutionDelegate(executionDelegate);\n    }\n\n    function setPolicyManager(IPolicyManager _policyManager)\n        external\n        onlyOwner\n    {\n        require(address(_policyManager) != address(0), \"Address cannot be zero\");\n        policyManager = _policyManager;\n        emit NewPolicyManager(policyManager);\n    }\n\n    function setOracle(address _oracle)\n        external\n        onlyOwner\n    {\n        require(_oracle != address(0), \"Address cannot be zero\");\n        oracle = _oracle;\n        emit NewOracle(oracle);\n    }\n\n    function setBlockRange(uint256 _blockRange)\n        external\n        onlyOwner\n    {\n        blockRange = _blockRange;\n        emit NewBlockRange(blockRange);\n    }\n\n\n    /* Internal Functions */\n\n    /**\n     * @dev Verify the validity of the order parameters\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateOrderParameters(Order calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n        return (\n            /* Order must have a trader. */\n            (order.trader != address(0)) &&\n            /* Order must not be cancelled or filled. */\n            (!cancelledOrFilled[orderHash]) &&\n            /* Order must be settleable. */\n            (order.listingTime < block.timestamp) &&\n            (block.timestamp < order.expirationTime)\n        );\n    }\n\n    /**\n     * @dev Verify the validity of the signatures\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateSignatures(Input calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n\n        if (order.order.trader == msg.sender) {\n          return true;\n        }\n\n        /* Check user authorization. */\n        if (\n            !_validateUserAuthorization(\n                orderHash,\n                order.order.trader,\n                order.v,\n                order.r,\n                order.s,\n                order.signatureVersion,\n                order.extraSignature\n            )\n        ) {\n            return false;\n        }\n\n        if (order.order.extraParams.length > 0 && order.order.extraParams[0] == 0x01) {\n            /* Check oracle authorization. */\n            require(block.number - order.blockNumber < blockRange, \"Signed block number out of range\");\n            if (\n                !_validateOracleAuthorization(\n                    orderHash,\n                    order.signatureVersion,\n                    order.extraSignature,\n                    order.blockNumber\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify the validity of the user signature\n     * @param orderHash hash of the order\n     * @param trader order trader who should be the signer\n     * @param v v\n     * @param r r\n     * @param s s\n     * @param signatureVersion signature version\n     * @param extraSignature packed merkle path\n     */\n    function _validateUserAuthorization(\n        bytes32 orderHash,\n        address trader,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature\n    ) internal view returns (bool) {\n        bytes32 hashToSign;\n        if (signatureVersion == SignatureVersion.Single) {\n            /* Single-listing authentication: Order signed by trader */\n            hashToSign = _hashToSign(orderHash);\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* Bulk-listing authentication: Merkle root of orders signed by trader */\n            (bytes32[] memory merklePath) = abi.decode(extraSignature, (bytes32[]));\n\n            bytes32 computedRoot = MerkleVerifier._computeRoot(orderHash, merklePath);\n            hashToSign = _hashToSignRoot(computedRoot);\n        }\n\n        return _verify(trader, hashToSign, v, r, s);\n    }\n\n    /**\n     * @dev Verify the validity of oracle signature\n     * @param orderHash hash of the order\n     * @param signatureVersion signature version\n     * @param extraSignature packed oracle signature\n     * @param blockNumber block number used in oracle signature\n     */\n    function _validateOracleAuthorization(\n        bytes32 orderHash,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature,\n        uint256 blockNumber\n    ) internal view returns (bool) {\n        bytes32 oracleHash = _hashToSignOracle(orderHash, blockNumber);\n\n        uint8 v; bytes32 r; bytes32 s;\n        if (signatureVersion == SignatureVersion.Single) {\n            assembly {\n                v := calldataload(extraSignature.offset)\n                r := calldataload(add(extraSignature.offset, 0x20))\n                s := calldataload(add(extraSignature.offset, 0x40))\n            }\n            /*\n            REFERENCE\n            (v, r, s) = abi.decode(extraSignature, (uint8, bytes32, bytes32));\n            */\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* If the signature was a bulk listing the merkle path must be unpacked before the oracle signature. */\n            assembly {\n                v := calldataload(add(extraSignature.offset, 0x20))\n                r := calldataload(add(extraSignature.offset, 0x40))\n                s := calldataload(add(extraSignature.offset, 0x60))\n            }\n            /*\n            REFERENCE\n            uint8 _v, bytes32 _r, bytes32 _s;\n            (bytes32[] memory merklePath, uint8 _v, bytes32 _r, bytes32 _s) = abi.decode(extraSignature, (bytes32[], uint8, bytes32, bytes32));\n            v = _v; r = _r; s = _s;\n            */\n        }\n\n        return _verify(oracle, oracleHash, v, r, s);\n    }\n\n    /**\n     * @dev Verify ECDSA signature\n     * @param signer Expected signer\n     * @param digest Signature preimage\n     * @param v v\n     * @param r r\n     * @param s s\n     */\n    function _verify(\n        address signer,\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (bool) {\n        require(v == 27 || v == 28, \"Invalid v parameter\");\n        address recoveredSigner = ecrecover(digest, v, r, s);\n        if (recoveredSigner == address(0)) {\n          return false;\n        } else {\n          return signer == recoveredSigner;\n        }\n    }\n\n    /**\n     * @dev Call the matching policy to check orders can be matched and get execution parameters\n     * @param sell sell order\n     * @param buy buy order\n     */\n    function _canMatchOrders(Order calldata sell, Order calldata buy)\n        internal\n        view\n        returns (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType)\n    {\n        bool canMatch;\n        if (sell.listingTime <= buy.listingTime) {\n            /* Seller is maker. */\n            require(policyManager.isPolicyWhitelisted(sell.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(sell.matchingPolicy).canMatchMakerAsk(sell, buy);\n        } else {\n            /* Buyer is maker. */\n            require(policyManager.isPolicyWhitelisted(buy.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(buy.matchingPolicy).canMatchMakerBid(buy, sell);\n        }\n        require(canMatch, \"Orders cannot be matched\");\n\n        return (price, tokenId, amount, assetType);\n    }\n\n    /**\n     * @dev Execute all ERC20 token / ETH transfers associated with an order match (fees and buyer => seller transfer)\n     * @param seller seller\n     * @param buyer buyer\n     * @param paymentToken payment token\n     * @param fees fees\n     * @param price price\n     */\n    function _executeFundsTransfer(\n        address seller,\n        address buyer,\n        address paymentToken,\n        Fee[] calldata fees,\n        uint256 price\n    ) internal {\n        if (msg.sender == buyer && paymentToken == address(0)) {\n            require(remainingETH >= price);\n            remainingETH -= price;\n        }\n\n        /* Take fee. */\n        uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);\n\n        /* Transfer remainder to seller. */\n        _transferTo(paymentToken, buyer, seller, receiveAmount);\n    }\n\n    /**\n     * @dev Charge a fee in ETH or WETH\n     * @param fees fees to distribute\n     * @param paymentToken address of token to pay in\n     * @param from address to charge fees\n     * @param price price of token\n     */\n    function _transferFees(\n        Fee[] calldata fees,\n        address paymentToken,\n        address from,\n        uint256 price\n    ) internal returns (uint256) {\n        uint256 totalFee = 0;\n        for (uint8 i = 0; i < fees.length; i++) {\n            uint256 fee = (price * fees[i].rate) / INVERSE_BASIS_POINT;\n            _transferTo(paymentToken, from, fees[i].recipient, fee);\n            totalFee += fee;\n        }\n\n        require(totalFee <= price, \"Total amount of fees are more than the price\");\n\n        /* Amount that will be received by seller. */\n        uint256 receiveAmount = price - totalFee;\n        return (receiveAmount);\n    }\n\n    /**\n     * @dev Transfer amount in ETH or WETH\n     * @param paymentToken address of token to pay in\n     * @param from token sender\n     * @param to token recipient\n     * @param amount amount to transfer\n     */\n    function _transferTo(\n        address paymentToken,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (paymentToken == address(0)) {\n            /* Transfer funds in ETH. */\n            require(to != address(0), \"Transfer to zero address\");\n            (bool success,) = payable(to).call{value: amount}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else if (paymentToken == POOL) {\n            /* Transfer Pool funds. */\n            bool success = IPool(POOL).transferFrom(from, to, amount);\n            require(success, \"Pool transfer failed\");\n        } else if (paymentToken == WETH) {\n            /* Transfer funds in WETH. */\n            executionDelegate.transferERC20(WETH, from, to, amount);\n        } else {\n            revert(\"Invalid payment token\");\n        }\n    }\n\n    /**\n     * @dev Execute call through delegate proxy\n     * @param collection collection contract address\n     * @param from seller address\n     * @param to buyer address\n     * @param tokenId tokenId\n     * @param assetType asset type of the token\n     */\n    function _executeTokenTransfer(\n        address collection,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        AssetType assetType\n    ) internal {\n        /* Call execution delegate. */\n        if (assetType == AssetType.ERC721) {\n            executionDelegate.transferERC721(collection, from, to, tokenId);\n        } else if (assetType == AssetType.ERC1155) {\n            executionDelegate.transferERC1155(collection, from, to, tokenId, amount);\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "Exchange.sol#L212-L227",
                "Type": "Unchecked Yul call return value",
                "Description": "The Yul call return value on function _returnDust is not checked, which could lead to the sender losing funds.",
                "Repair": "Check the return value of the Yul call and revert if unsuccessful"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/lib/contracts/libraries/FullMath.sol';\n\nimport \"../Permissions.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\n\n/// @title Uniswap Interaction Handler\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A simple contract to make interacting with UniswapV2 pools easier.\n/// @notice The buyMalt method is locked down to avoid circumventing recovery mode\n/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct\ncontract UniswapHandler is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant BUYER_ROLE = keccak256(\"BUYER_ROLE\");\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public lpToken;\n  IUniswapV2Router02 public router;\n  address public uniswapV2Factory;\n\n  address[] public buyers;\n  mapping(address => bool) public buyersActive;\n\n  event AddMaltBuyer(address buyer);\n  event RemoveMaltBuyer(address buyer);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _lpToken,\n    address _router,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    router = IUniswapV2Router02(_router);\n\n    lpToken = ERC20(_lpToken);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);\n  }\n\n  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);\n  }\n\n  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n  }\n\n  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n\n    if (maltReserves == 0 || rewardReserves == 0) {\n      price = 0;\n      decimals = 18;\n      return (price, decimals);\n    }\n\n    uint256 rewardDecimals = rewardToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));\n      decimals = rewardDecimals;\n    } else if (rewardDecimals < maltDecimals) {\n      uint256 diff = maltDecimals - rewardDecimals;\n      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n      decimals = maltDecimals;\n    } else {\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);\n      decimals = rewardDecimals;\n    }\n  }\n\n  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)\n    external view returns (uint256 liquidityA)\n  {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      tokenA,\n      tokenB\n    );\n\n    liquidityA = UniswapV2Library.quote(\n      liquidityB,\n      reservesB,\n      reservesA\n    );\n  }\n\n  /*\n   * MUTATION FUNCTIONS\n   */\n  function buyMalt()\n    external\n    onlyRole(BUYER_ROLE, \"Must have buyer privs\")\n    returns (uint256 purchased)\n  {\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (rewardBalance == 0) {\n      return 0;\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(rewardToken);\n    path[1] = address(malt);\n\n    router.swapExactTokensForTokens(\n      rewardBalance,\n      0, // amountOutMin\n      path,\n      address(this),\n      now\n    );\n\n    purchased = malt.balanceOf(address(this));\n    malt.safeTransfer(msg.sender, purchased);\n  }\n\n  function sellMalt() external returns (uint256 rewards) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (maltBalance == 0) {\n      return 0;\n    }\n\n    malt.approve(address(router), maltBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(malt);\n    path[1] = address(rewardToken);\n\n    router.swapExactTokensForTokens(\n      maltBalance,\n      0,\n      path,\n      address(this),\n      now\n    );\n\n    rewards = rewardToken.balanceOf(address(this));\n    rewardToken.safeTransfer(msg.sender, rewards);\n  }\n\n  function addLiquidity() external returns (\n    uint256 maltUsed,\n    uint256 rewardUsed,\n    uint256 liquidityCreated\n  ) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance == 0 || rewardBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n    malt.approve(address(router), maltBalance);\n\n    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT\n    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n      address(malt),\n      address(rewardToken),\n      maltBalance,\n      rewardBalance,\n      maltBalance.mul(95).div(100),\n      rewardBalance.mul(95).div(100),\n      msg.sender, // transfer LP tokens to sender\n      now\n    );\n\n    if (maltUsed < maltBalance) {\n      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));\n    }\n\n    if (rewardUsed < rewardBalance) {\n      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));\n    }\n  }\n\n  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {\n    uint256 liquidityBalance = lpToken.balanceOf(address(this));\n\n    if (liquidityBalance == 0) {\n      return (0, 0);\n    }\n\n    lpToken.approve(address(router), liquidityBalance);\n\n    (amountMalt, amountReward) = router.removeLiquidity(\n      address(malt),\n      address(rewardToken),\n      liquidityBalance,\n      0,\n      0,\n      msg.sender, // transfer broken LP tokens to sender\n      now\n    );\n\n    if (amountMalt == 0 || amountReward == 0) {\n      liquidityBalance = lpToken.balanceOf(address(this));\n      lpToken.safeTransfer(msg.sender, liquidityBalance);\n      return (amountMalt, amountReward);\n    }\n  }\n\n  /*\n   * PRIVATE METHODS\n   */\n  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {\n    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST\n    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      sellToken,\n      buyToken\n    );\n\n    uint256 invariant = sellReserves.mul(buyReserves);\n\n    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        priceTarget,\n        buyBase.div(priceTarget).mul(buyBase).mul(997)\n      )\n    );\n\n    uint256 rightSide = sellReserves.mul(1000).div(997);\n\n    if (leftSide < rightSide) return 0;\n\n    return leftSide.sub(rightSide);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function addNewBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    require(_buyer != address(0), \"Cannot use address 0\");\n\n    if (buyersActive[_buyer]) {\n      return;\n    }\n\n    buyersActive[_buyer] = true;\n    buyers.push(_buyer);\n\n    _setupRole(BUYER_ROLE, _buyer);\n\n    emit AddMaltBuyer(_buyer);\n  }\n\n  function removeBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    if (buyers.length == 0 || !buyersActive[_buyer]) {\n      return;\n    }\n\n    address buyer;\n    buyersActive[_buyer] = false;\n\n    emit RemoveMaltBuyer(_buyer);\n    revokeRole(BUYER_ROLE, _buyer);\n\n    // Loop until the second last element\n    for (uint i = 0; i < buyers.length - 1; i = i + 1) {\n      if (buyers[i] == _buyer) {\n        // Replace the current item with the last and pop the last away.\n        buyers[i] = buyers[buyers.length - 1];\n        buyers.pop();\n        return;\n      }\n    }\n\n    // If we made it here then the buyers being removed is the last item\n    buyers.pop();\n  }\n\n  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "UniswapHandler.maltMarketPrice function",
                "Type": "Incorrect return value",
                "Description": "The returned decimals do not match the computed price for the rewardDecimals < maltDecimals branch, resulting in callers receiving a price in unexpected decimals and potentially inflating or deflating the actual amount.",
                "Repair": "Return rewardDecimals instead of maltDecimals in the rewardDecimals < maltDecimals branch"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.transferFrom(msg.sender, recipient, _amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "CoreCollection.sol and ERC721Payable.sol",
                "Type": "Not handling return value",
                "Description": "Not handling return value of transferFrom command can create inconsistency",
                "Repair": "Add a require statement to check the return value of transferFrom command"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol'; // library of market place specific constructs\nimport './Swivel.sol'; // library of swivel specific constructs\nimport './Element.sol'; // library of element specific constructs\nimport './Safe.sol';\nimport './Cast.sol';\n\n/// @title Lender.sol\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users. \n/// @notice The contract holds the principal tokens for each market and mints an ERC-5095 position to users to represent their lent positions.\ncontract Lender {\n    error Unauthorized();\n    error NotEqual(string);\n    error Exists(address);\n    error Invalid(string);\n\n    /// @notice minimum amount of time the admin must wait before executing a withdrawl\n    uint256 constant public HOLD = 3 days;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace.sol contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal may be used by a lender\n    mapping(uint8 => bool) public paused;\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping (address => uint256) public withdrawals;\n\n    /// @notice emitted upon executed lend\n    event Lend(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 returned);\n    /// @notice emitted upon minted ERC5095 to user\n    event Mint(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n    /// @notice emitted on token withdrawal scheduling\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted on token withdrawal blocking\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted on a change to the feenominators array\n\n    /// @notice initializes the Lender contract\n    /// @param s the swivel contract\n    /// @param p the pendle contract\n    /// @param t the tempus contract\n    constructor(\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u underlying token's address, used to define the market being approved\n    /// @param m maturity of the underlying token, used to define the market being approved\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful, false otherwise\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // max is the maximum integer value for a 256 unsighed integer\n        uint256 max = 2**256 - 1;\n\n        // approve the underlying for max per given principal\n        for (uint8 i; i < 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses. \n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {\n        uint256 len = u.length;\n        if (len != a.length) {\n            revert NotEqual('array length');\n        }\n        uint256 max = 2**256 - 1;\n\n        for (uint256 i; i < len; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        feenominator = f;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists(marketPlace);\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on illuminate\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful, false otherwise\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public returns (bool) {\n        //use market interface to fetch the market for the given market pair\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        //use safe transfer lib and ERC interface...\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n        //use ERC5095 interface...\n        IERC5095(principalToken(u, m)).mint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method signature for both illuminate and yield\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y yieldspace pool that will execute the swap for the principal token\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y\n    ) public unpaused(p) returns (uint256) {\n        // check the principal is illuminate or yield\n        if (p != uint8(MarketPlace.Principals.Illuminate) && p != uint8(MarketPlace.Principals.Yield)) {\n            revert Invalid('principal');\n        }\n\n        // uses yield token interface...\n        IYield pool = IYield(y);\n\n        // the yield token must match the market pair\n        if (address(pool.base()) != u) {\n            revert NotEqual('underlying');\n        } else if (pool.maturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // transfer from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Purchase yield PTs to lender.sol (address(this))\n            uint256 returned = yield(u, y, a - calculateFee(a), address(this));\n            // Mint and distribute equivalent illuminate PTs\n            IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n            \n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n        else {\n            // Purchase illuminate PTs directly to msg.sender\n            uint256 returned = yield(u, y, a - calculateFee(a), msg.sender);\n\n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n    }\n\n    /// @notice lend method signature for swivel\n    /// @dev lends to yield pool. remaining balance is sent to the yield pool\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y yield pool\n    /// @param o array of swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        {\n            // returned represents the number of underlying tokens to lend to yield\n            uint256 returned;\n\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {\n                    revert NotEqual('maturity');\n                }\n\n                {\n                    uint256 amount = a[i];\n                    // Determine the fee\n                    uint256 fee = calculateFee(amount);\n                    // Track accumulated fees\n                    totalFee += fee;\n                    // Amount lent for this order\n                    uint256 amountLent = amount - fee;\n                    // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                    lent += amountLent;\n                    // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                    returned += amountLent * order.premium / order.principal;\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n      \n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n\n    /// @notice lend method signature for element\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed deadline is a timestamp by which the swap must be executed\n    /// @param e element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) public unpaused(p) returns (uint256) {\n        // Get the principal token for this market for element\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // the element token must match the market pair\n        if (IElementToken(principal).underlying() != u) {\n            revert NotEqual('underlying');\n        } else if (IElementToken(principal).unlockTimestamp() > m) {\n            revert NotEqual('maturity');\n        }\n        // Transfer underlying token from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] += calculateFee(a);\n\n        uint256 purchased;\n        {\n            // Create the variables needed to execute an element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000',\n                poolId: i,\n                amount: a - calculateFee(a),\n                kind: Element.SwapKind.In,\n                assetIn: Any(u),\n                assetOut: Any(principal)\n            });\n\n            // Conduct the swap on element\n            purchased = IElement(e).swap(swap, fund, r, d);\n        }\n\n        emit Lend(p, u, m, purchased);\n        return purchased;\n    }\n\n    /// @notice lend method signature for pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        IPendleToken token = IPendleToken(principal);\n\n        // confirm that we are in the correct market\n        if (token.yieldToken() != u) {\n            revert NotEqual('underlying');\n        } else if (token.expiry() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = calculateFee(a);\n            fees[u] += fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0];\n\n        }\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for tempus\n    /// @dev This method can be called before maturity to lend to Tempus while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param t tempus pool that houses the underlying principal tokens\n    /// @param x tempus amm that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n        {\n            // Instantiate market and tokens\n            address principal = IMarketPlace(marketPlace).markets(u, m, p);\n            if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n                revert NotEqual('underlying');\n            } else if (ITempus(principal).maturityTime() > m) {\n                revert NotEqual('maturity');\n            }\n\n            // Get the underlying token\n            IERC20 underlyingToken = IERC20(u);\n\n            // Transfer funds from user to Illuminate, Scope to avoid stack limit\n            Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n        }\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r minimum number of tokens to lend (sets a limit on the order)\n    /// @param x amm that is used to conduct the swap\n    /// @param s contract that holds the principal token for this market\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        address s\n    ) public unpaused(p) returns (uint256) {\n\n        // Get the principal token for this market for this market\n        ISenseToken token = ISenseToken(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Verify that the underlying and maturity match up\n        if (token.underlying() != u) { // gauruntee the input token is the right token\n            revert NotEqual('underlying'); \n        } else if (ISense(s).pt() != address(token)) {\n            revert NotEqual('principal token'); \n        } else if (ISense(x).maturity() > m) { // gauruntee the input amm has the correct maturity\n            revert NotEqual('maturity');\n        }\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine lent amount after fees\n            lent = a - fee;\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Swap those tokens for the principal tokens\n        uint256 returned = ISense(x).swapUnderlyingForPTs(s, m, lent, r);\n\n        // Get the address of the ERC5095 token for this market\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n\n        // Mint the illuminate tokens based on the returned amount\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice this method can be called before maturity to lend to APWine while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the minimum amount of zero-coupon tokens to return accounting for slippage\n    /// @param pool the address of a given APWine pool\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        address pool,\n        address aave,\n        uint256 i\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        if (IAPWineToken(principal).getUnderlyingOfIBTAddress() != u) {\n            revert NotEqual('underlying');\n        }\n        // Dont necessarily need to validate APWINE maturity (They have 1 maturity per underlying)\n        // Potentially add redundant implied maturity calculation\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine the amount lent after fees\n            lent = a - fee;\n        }\n\n        // Deposit into aave\n        IAave(aave).deposit(u, lent, address(this), 0);\n\n        // Swap on the APWine Pool using the provided market and params\n        uint256 returned = IAPWineRouter(pool).swapExactAmountIn(i, 1, lent, 0, r, address(this));\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @dev lend method signature for Notional\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        INotional token = INotional(principal);\n\n        // Verify that the underlying and maturity match up\n        (IERC20 underlying, ) = token.getUnderlyingToken();\n        if (address(underlying) != u) {\n            revert NotEqual('underlying');\n        } else if (token.getMaturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Notional Token wrapper\n        uint256 returned = token.deposit(a - fee, address(this));\n\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice transfers excess funds to yield pool after principal tokens have been lent out\n    /// @dev this method is only used by the yield, illuminate and swivel protocols\n    /// @param u address of an underlying asset\n    /// @param y the yield pool to lend to\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the receiving address for PTs\n    /// @return uint256 the amount of tokens sent to the yield pool\n    function yield(\n        address u,\n        address y,\n        uint256 a,\n        address r\n    ) internal returns (uint256) {\n        // preview exact swap slippage on yield\n        uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));\n\n        // send the remaing amount to the given yield pool\n        Safe.transfer(IERC20(u), y, a);\n\n        // lend out the remaining tokens in the yield pool\n        IYield(y).sellBase(r, returned);\n\n        return returned;\n    }\n\n    /// @notice withdraws accumulated lending fees of the underlying token\n    /// @param e address of the underlying token to withdraw\n    /// @return bool true if successful\n    function withdrawFee(address e) external authorized(admin) returns (bool) {\n        // Get the token to be withdrawn\n        IERC20 token = IERC20(e);\n\n        // Get the balance to be transferred\n        uint256 balance = fees[e];\n\n        // Reset accumulated fees of the token to 0\n        fees[e] = 0;\n\n        // Transfer the accumulated fees to the admin\n        Safe.transfer(token, admin, balance);\n        return true;\n    }\n\n    /// @notice this method returns the fee based on the amount passed to it. If the feenominator is 0, then there is no fee.\n    /// @param a amount of underlying tokens to calculate the fee for\n    /// @return uint256 The total for for the given amount\n    function calculateFee(uint256 a) internal view returns (uint256) {\n        return feenominator > 0 ? a / feenominator : 0;\n    }\n\n    /// @notice allows the admin to schedule the withdrawal of tokens\n    /// @param e address of (erc20) token to withdraw\n    /// @return bool true if successful\n    function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n        uint256 when = block.timestamp + HOLD;\n        withdrawals[e] = when;\n\n        emit ScheduleWithdrawal(e, when);\n        return true;\n    }\n\n    /// @notice emergency function to block unplanned withdrawals\n    /// @param e address of token withdrawal to block\n    /// @return bool true if successful\n    function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n        withdrawals[e] = 0;\n\n        emit BlockWithdrawal(e);\n        return true;\n    }\n\n    /// @notice allows the admin to withdraw the given token, provided the holding period has been observed\n    /// @param e Address of token to withdraw\n    /// @return bool true if successful\n    function withdraw(address e) external authorized(admin) returns (bool) {\n        uint256 when = withdrawals[e];\n        require (when != 0, 'no withdrawal scheduled');\n  \n        require (block.timestamp >= when, 'withdrawal still on hold');\n  \n        withdrawals[e] = 0;\n  \n        IERC20 token = IERC20(e);\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\n  \n        return true;\n    }\n\n    /// @notice retrieves the ERC5095 token for the given market\n    /// @param u address of the underlying\n    /// @param m uint256 representing the maturity of the market\n    /// @return address of the ERC5095 token for the market\n    function principalToken(address u, uint256 m) internal returns (address) {\n        return IMarketPlace(marketPlace).markets(u, m, 0);\n    }\n\n    /// @notice pauses a market and prevents execution of all lending for that market\n    /// @param p principal enum value\n    /// @param b bool representing whether to pause or unpause\n    /// @return bool true if successful\n    function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n        paused[p] = b;\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param p principal enum value\n    modifier unpaused(uint8 p) {\n        if (paused[p]) {\n            revert Invalid('paused');\n        }\n        _;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "Lender.sol#L452-L453",
                "Type": "The lend function for tempus uses the wrong return value of depositAndFix",
                "Description": "The depositAndFix function of the TempusController contract returns two uint256 data, the first is the number of shares exchanged for the underlying token, the second is the number of principalToken exchanged for the shares, the second return value should be used in the lend function for tempus.",
                "Repair": "Use the second return value of depositAndFix function for the lend function for tempus."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "CoreCollection.sol",
                "Type": "ERC20 transferFrom return values not checked",
                "Description": "ERC20 transferFrom return values not checked",
                "Repair": "Check the success boolean of all transferFrom calls or use OZ\u2019s SafeERC20\u2019s safeTransferFrom() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"./FiRMTest.sol\";\nimport \"../BorrowController.sol\";\nimport \"../DBR.sol\";\nimport \"../Fed.sol\";\nimport {SimpleERC20Escrow} from \"../escrows/SimpleERC20Escrow.sol\";\nimport \"../Market.sol\";\nimport \"../Oracle.sol\";\n\nimport \"./mocks/ERC20.sol\";\nimport \"./mocks/WETH9.sol\";\nimport \"./mocks/BorrowContract.sol\";\nimport {EthFeed} from \"./mocks/EthFeed.sol\";\n\ncontract MarketTest is FiRMTest {\n    bytes onlyGovUnpause = \"Only governance can unpause\";\n    bytes onlyPauseGuardianOrGov = \"Only pause guardian or governance can pause\";\n\n    BorrowContract borrowContract;\n\n    function setUp() public {\n        initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), 1_000_000e18);\n        vm.stopPrank();\n\n        borrowContract = new BorrowContract(address(market), payable(address(WETH)));\n    }\n\n    function testDeposit() public {\n        gibWeth(user, wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), wethTestAmount, \"Escrow balance did not increase\");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n    }\n\n    function testDeposit2() public {\n        gibWeth(user, wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n\n        vm.startPrank(user);\n        WETH.approve(address(market), wethTestAmount);\n        market.deposit(user2, wethTestAmount);\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), 0, \"User balance not 0\");\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user2))), wethTestAmount, \"User2 escrow balance did not increase \");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n        assertEq(WETH.balanceOf(user2), 0, \"User2 not 0\");\n    }\n\n    function testBorrow() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n        uint initialDolaBalance = DOLA.balanceOf(user);\n        deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        assertEq(DOLA.balanceOf(user), initialDolaBalance + borrowAmount, \"User balance did not increase by borrowAmount\");\n    }\n\n    function testDepositAndBorrow() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        uint initialDolaBalance = DOLA.balanceOf(user);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n        WETH.approve(address(market), wethTestAmount);\n        market.depositAndBorrow(wethTestAmount, borrowAmount);\n\n        assertEq(DOLA.balanceOf(user), initialDolaBalance + borrowAmount, \"User balance did not increase by borrowAmount\");\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), wethTestAmount, \"Escrow balance did not increase\");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n    }\n\n    function testBorrowOnBehalf() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        vm.stopPrank();\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(userPk), 0, \"failed to deposit WETH\");\n\n        vm.startPrank(user2);\n        market.borrowOnBehalf(userPk, maxBorrowAmount, block.timestamp, v, r, s);\n\n        assertEq(DOLA.balanceOf(userPk), 0, \"borrowed DOLA went to the wrong user\");\n        assertEq(DOLA.balanceOf(user2), maxBorrowAmount, \"failed to borrow DOLA\");\n    }\n\n    function testBorrowOnBehalf_Fails_When_InvalidateNonceCalledPrior() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.expectRevert(\"INVALID_SIGNER\");\n        market.borrowOnBehalf(userPk, maxBorrowAmount, block.timestamp, v, r, s);\n    }\n\n    function testBorrowOnBehalf_Fails_When_DeadlineHasPassed() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n\n        uint timestamp = block.timestamp;\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.warp(block.timestamp + 1);\n        vm.expectRevert(\"DEADLINE_EXPIRED\");\n        market.borrowOnBehalf(userPk, maxBorrowAmount, timestamp, v, r, s);\n    }\n\n    function testBorrow_Fails_When_BorrowingPaused() public {\n        vm.startPrank(gov);\n        market.pauseBorrows(true);\n        vm.stopPrank();\n\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        vm.expectRevert(\"Borrowing is paused\");\n        market.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_DeniedByBorrowController() public {\n        vm.startPrank(gov);\n        market.setBorrowController(IBorrowController(address(borrowController)));\n        vm.stopPrank();\n\n        gibWeth(address(borrowContract), wethTestAmount);\n        gibDBR(address(borrowContract), wethTestAmount);\n        vm.startPrank(user);\n\n        borrowContract.deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        vm.expectRevert(\"Denied by borrow controller\");\n        borrowContract.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_AmountGTCreditLimit() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        uint borrowAmount = convertWethToDola(wethTestAmount);\n        vm.expectRevert(\"Exceeded credit limit\");\n        market.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_NotEnoughDolaInMarket() public {\n        vm.startPrank(market.lender());\n        market.recall(DOLA.balanceOf(address(market)));\n        vm.stopPrank();\n\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        \n        deposit(wethTestAmount);\n\n        vm.expectRevert(\"SafeMath: subtraction underflow\");\n        market.borrow(1 ether);\n    }\n\n    function testLiquidate_NoLiquidationFee(uint depositAmount, uint liqAmount, uint16 borrowMulti_) public {\n        depositAmount = bound(depositAmount, 1e18, 100_000e18);\n        liqAmount = bound(liqAmount, 500e18, 200_000_000e18);\n        uint borrowMulti = bound(borrowMulti_, 0, 100);\n\n        uint maxBorrowAmount = convertWethToDola(depositAmount) * market.collateralFactorBps() / 10_000;\n        uint borrowAmount = maxBorrowAmount * borrowMulti / 100;\n\n        gibWeth(user, depositAmount);\n        gibDBR(user, depositAmount);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), convertWethToDola(depositAmount));\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        deposit(depositAmount);\n        market.borrow(borrowAmount);\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, liqAmount);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint marketDolaBal = DOLA.balanceOf(address(market));\n        uint govDolaBal = DOLA.balanceOf(gov);\n        uint repayAmount = market.debts(user) * market.liquidationFactorBps() / 10_000;\n\n        if (market.debts(user) <= market.getCreditLimit(user)) {\n            vm.expectRevert(\"User debt is healthy\");\n            market.liquidate(user, liqAmount);\n        } else if (repayAmount < liqAmount) {\n            vm.expectRevert(\"Exceeded liquidation factor\");\n            market.liquidate(user, liqAmount);\n        } else {\n            //Successful liquidation\n            market.liquidate(user, liqAmount);\n\n            uint expectedReward = convertDolaToWeth(liqAmount);\n            expectedReward += expectedReward * market.liquidationIncentiveBps() / 10_000;\n            assertEq(expectedReward, WETH.balanceOf(user2), \"user2 didn't receive proper liquidation reward\");\n            assertEq(DOLA.balanceOf(address(market)), marketDolaBal + liqAmount, \"market didn't receive repaid DOLA\");\n            assertEq(DOLA.balanceOf(gov), govDolaBal, \"gov should not receive liquidation fee when it's set to 0\");\n        }\n    }\n\n    function testLiquidate_WithLiquidationFee(uint depositAmount, uint liqAmount, uint256 liquidationFeeBps, uint16 borrowMulti_) public {\n        depositAmount = bound(depositAmount, 1e18, 100_000e18);\n        liqAmount = bound(liqAmount, 500e18, 200_000_000e18);\n        uint borrowMulti = bound(borrowMulti_, 0, 100);\n\n        gibWeth(user, depositAmount);\n        gibDBR(user, depositAmount);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), convertWethToDola(depositAmount));\n        vm.stopPrank();\n\n        vm.startPrank(gov);\n        liquidationFeeBps = bound(liquidationFeeBps, 1, 10_000);\n        vm.assume(liquidationFeeBps > 0 && liquidationFeeBps + market.liquidationIncentiveBps() < 10000);\n        market.setLiquidationFeeBps(liquidationFeeBps);\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        deposit(depositAmount);\n        uint maxBorrowAmount = convertWethToDola(depositAmount) * market.collateralFactorBps() / 10_000;\n        uint borrowAmount = maxBorrowAmount * borrowMulti / 100;\n        market.borrow(borrowAmount);\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, liqAmount);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint marketDolaBal = DOLA.balanceOf(address(market));\n        uint govWethBal = WETH.balanceOf(gov);\n        uint repayAmount = market.debts(user) * market.liquidationFactorBps() / 10_000;\n\n        if (market.debts(user) <= market.getCreditLimit(user)) {\n            vm.expectRevert(\"User debt is healthy\");\n            market.liquidate(user, liqAmount);\n        } else if (repayAmount < liqAmount) {\n            vm.expectRevert(\"Exceeded liquidation factor\");\n            market.liquidate(user, liqAmount);\n        } else {\n            //Successful liquidation\n            market.liquidate(user, liqAmount);\n\n            uint expectedReward = convertDolaToWeth(liqAmount);\n            expectedReward += expectedReward * market.liquidationIncentiveBps() / 10_000;\n            uint expectedLiquidationFee = convertDolaToWeth(liqAmount) * market.liquidationFeeBps() / 10_000;\n            assertEq(expectedReward, WETH.balanceOf(user2), \"user2 didn't receive proper liquidation reward\");\n            assertEq(DOLA.balanceOf(address(market)), marketDolaBal + liqAmount, \"market didn't receive repaid DOLA\");\n            assertEq(WETH.balanceOf(gov), govWethBal + expectedLiquidationFee, \"gov didn't receive proper liquidation fee\");\n        }\n    }\n\n    function testLiquidate_Fails_When_repaidDebtIs0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n        vm.expectRevert(\"Must repay positive debt\");\n        market.liquidate(user, 0);\n    }\n\n    function testLiquidate_Fails_When_repaidDebtGtLiquidatableDebt() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint liquidationAmount = (market.debts(user) * market.liquidationFactorBps() / 10_000) + 1;\n        vm.expectRevert(\"Exceeded liquidation factor\");\n        market.liquidate(user, liquidationAmount);\n    }\n\n    function testLiquidate_Fails_When_UserDebtIsHealthy() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint liquidationAmount = market.debts(user);\n        vm.expectRevert(\"User debt is healthy\");\n        market.liquidate(user, liquidationAmount);\n    }\n\n    function testRepay_Successful_OwnBorrow_FullAmount() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        \n        uint initialMarketBal = DOLA.balanceOf(address(market));\n        uint initialUserDebt = market.debts(user);\n        uint initialDolaBal = DOLA.balanceOf(user);\n\n        market.repay(user, market.debts(user));\n\n        assertEq(market.debts(user), 0, \"user's debt was not paid\");\n        assertEq(initialDolaBal - initialUserDebt, DOLA.balanceOf(user), \"DOLA was not subtracted from user\");\n        assertEq(initialMarketBal + initialUserDebt, DOLA.balanceOf(address(market)), \"Market DOLA balance did not increase\");\n    }\n\n    function testRepay_Successful_OtherUserBorrow_FullAmount() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n        vm.startPrank(user2);\n\n        uint initialUserDebt = market.debts(user);\n        uint initialDolaBal = initialUserDebt * 2;\n        gibDOLA(user2, initialDolaBal);\n\n        market.repay(user, market.debts(user));\n\n        assertEq(market.debts(user), 0, \"user's debt was not paid\");\n        assertEq(initialDolaBal - initialUserDebt, DOLA.balanceOf(user2), \"DOLA was not subtracted from user2\");\n    }\n\n    function testRepay_Fails_WhenAmountGtDebt() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        gibDOLA(user, 500e18);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.expectRevert(\"Insufficient debt\");\n        market.repay(user, borrowAmount + 1);\n    }\n\n    function testForceReplenish() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n        uint initialReplenisherDola = DOLA.balanceOf(replenisher);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint initialUserDebt = market.debts(user);\n        uint initialMarketDola = DOLA.balanceOf(address(market));\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + 5 days);\n        uint deficitBefore = dbr.deficitOf(user);\n        vm.startPrank(replenisher);\n\n        market.forceReplenish(user, deficitBefore);\n        assertGt(DOLA.balanceOf(replenisher), initialReplenisherDola, \"DOLA balance of replenisher did not increase\");\n        assertLt(DOLA.balanceOf(address(market)), initialMarketDola, \"DOLA balance of market did not decrease\");\n        assertEq(DOLA.balanceOf(replenisher) - initialReplenisherDola, initialMarketDola - DOLA.balanceOf(address(market)), \"DOLA balance of market did not decrease by amount paid to replenisher\");\n        assertEq(dbr.deficitOf(user), 0, \"Deficit of borrower was not fully replenished\");\n        assertEq(market.debts(user) - initialUserDebt, deficitBefore * replenishmentPriceBps / 10000, \"Debt of borrower did not increase by replenishment price\");\n    }\n\n    function testForceReplenish_Fails_When_UserHasNoDbrDeficit() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount * 100);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint deficit = dbr.deficitOf(user);\n\n        vm.stopPrank();\n        vm.startPrank(user2);\n\n        vm.expectRevert(\"No DBR deficit\");\n        market.forceReplenish(user, deficit);\n    }\n\n    function testForceReplenish_Fails_When_NotEnoughDolaInMarket() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.warp(block.timestamp + 5 days);\n        vm.stopPrank();\n        vm.startPrank(market.lender());\n        market.recall(DOLA.balanceOf(address(market)));\n        uint deficit = dbr.deficitOf(user);\n        vm.stopPrank();\n        vm.startPrank(replenisher);   \n        vm.expectRevert(\"SafeMath: subtraction underflow\");\n        market.forceReplenish(user, deficit);   \n    }\n\n    function testForceReplenish_Fails_When_DebtWouldExceedCollateralValue() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.warp(block.timestamp + 10000 days);\n        uint deficit = dbr.deficitOf(user);\n        vm.stopPrank();\n\n        vm.startPrank(replenisher);   \n        vm.expectRevert(\"Exceeded collateral value\");\n        market.forceReplenish(user, deficit);   \n    }\n\n    function testGetWithdrawalLimit_Returns_CollateralBalance() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n        assertEq(market.getWithdrawalLimit(user), collateralBalance, \"Should return collateralBalance when user's escrow balance > 0 & debts = 0\");\n    }\n\n    function testGetWithdrawalLimit_Returns_CollateralBalanceAdjustedForDebts() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint collateralBalance = market.escrows(user).balance();\n        uint collateralFactor = market.collateralFactorBps();\n        uint minimumCollateral = borrowAmount * 1 ether / oracle.viewPrice(address(WETH), collateralFactor) * 10000 / collateralFactor;\n        assertEq(market.getWithdrawalLimit(user), collateralBalance - minimumCollateral, \"Should return collateral balance adjusted for debt\");\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenEscrowBalanceIs0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n\n        market.withdraw(wethTestAmount);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user's escrow balance is 0\");\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenCollateralValueLtDebts() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n        market.withdraw(wethTestAmount);\n\n        uint ethPrice = ethFeed.latestAnswer();\n        ethFeed.changeAnswer(ethPrice * 6 / 10);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user's collateral value is less than debts\");\n        ethFeed.changeAnswer(ethPrice);\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenMarketCollateralFactoris0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(1);\n        vm.stopPrank();\n\n        vm.startPrank(gov);\n        market.setCollateralFactorBps(0);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user has non-zero debt & collateralFactorBps = 0\");\n    }\n\n    function testGetLiquidatableDebt_Returns_0_WhenUserHasNoDebt() public {\n        assertEq(market.getLiquidatableDebt(user), 0, \"Should return 0 when user has no debt\");\n    }\n\n    function testGetLiquidatableDebt_Returns_0_WhenUserCreditEqualsDebt() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        assertEq(market.getLiquidatableDebt(user), 0, \"Should return 0 when user credit = debt\");\n    }\n\n    function testGetLiquidatableDebt_Returns_LiquidatableDebt_WhenUserDebtGtCredit() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 5 / 10);\n\n        assertGt(market.getLiquidatableDebt(user), 0, \"Should return liquidatable debt when user debt > credit\");\n    }\n\n    function testPauseBorrows() public {\n        vm.startPrank(gov);\n\n        market.pauseBorrows(true);\n        assertEq(market.borrowPaused(), true, \"Market wasn't paused\");\n        market.pauseBorrows(false);\n        assertEq(market.borrowPaused(), false, \"Market wasn't unpaused\");\n\n        vm.stopPrank();\n        vm.startPrank(pauseGuardian);\n        market.pauseBorrows(true);\n        assertEq(market.borrowPaused(), true, \"Market wasn't paused\");\n        vm.expectRevert(onlyGovUnpause);\n        market.pauseBorrows(false);\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        vm.expectRevert(onlyPauseGuardianOrGov);\n        market.pauseBorrows(true);\n\n        vm.expectRevert(onlyGovUnpause);\n        market.pauseBorrows(false);\n    }\n\n    function testWithdraw() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"failed to deposit WETH\");\n\n        market.withdraw(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), 0, \"failed to withdraw WETH\");\n        assertEq(WETH.balanceOf(user), wethTestAmount, \"failed to withdraw WETH\");\n    }\n\n    function testWithdraw_Fail_When_WithdrawingCollateralBelowCF() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"failed to deposit WETH\");\n\n        market.borrow(1 ether);\n\n        vm.expectRevert(\"Insufficient withdrawal limit\");\n        market.withdraw(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"successfully withdrew WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"successfully withdrew WETH\");\n    }\n\n    function testWithdrawOnBehalf() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        vm.stopPrank();\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(userPk), 0, \"failed to deposit WETH\");\n\n        vm.startPrank(user2);\n        market.withdrawOnBehalf(userPk, wethTestAmount, block.timestamp, v, r, s);\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), 0, \"failed to withdraw WETH\");\n        assertEq(WETH.balanceOf(user2), wethTestAmount, \"failed to withdraw WETH\");\n    }\n\n    function testWithdrawOnBehalf_When_InvalidateNonceCalledPrior() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.expectRevert(\"INVALID_SIGNER\");\n        market.withdrawOnBehalf(userPk, wethTestAmount, block.timestamp, v, r, s);\n    }\n\n    function testWithdrawOnBehalf_When_DeadlineHasPassed() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n\n        uint timestamp = block.timestamp;\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.warp(block.timestamp + 1);\n        vm.expectRevert(\"DEADLINE_EXPIRED\");\n        market.withdrawOnBehalf(userPk, wethTestAmount, timestamp, v, r, s);\n    }\n\n    //Access Control Tests\n\n    function test_accessControl_setOracle() public {\n        vm.startPrank(gov);\n        market.setOracle(IOracle(address(0)));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setOracle(IOracle(address(0)));\n    }\n\n    function test_accessControl_setBorrowController() public {\n        vm.startPrank(gov);\n        market.setBorrowController(IBorrowController(address(0)));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setBorrowController(IBorrowController(address(0)));\n    }\n\n    function test_accessControl_setGov() public {\n        vm.startPrank(gov);\n        market.setGov(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setGov(address(0));\n    }\n\n    function test_accessControl_setLender() public {\n        vm.startPrank(gov);\n        market.setLender(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLender(address(0));\n    }\n\n    function test_accessControl_setPauseGuardian() public {\n        vm.startPrank(gov);\n        market.setPauseGuardian(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setPauseGuardian(address(0));\n    }\n\n    function test_accessControl_setCollateralFactorBps() public {\n        vm.startPrank(gov);\n        market.setCollateralFactorBps(100);\n\n        vm.expectRevert(\"Invalid collateral factor\");\n        market.setCollateralFactorBps(10001);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setCollateralFactorBps(100);\n    }\n\n    function test_accessControl_setReplenismentIncentiveBps() public {\n        vm.startPrank(gov);\n        market.setReplenismentIncentiveBps(100);\n\n        vm.expectRevert(\"Invalid replenishment incentive\");\n        market.setReplenismentIncentiveBps(10001);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setReplenismentIncentiveBps(100);\n    }\n\n    function test_accessControl_setLiquidationIncentiveBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationIncentiveBps(100);\n\n        vm.expectRevert(\"Invalid liquidation incentive\");\n        market.setLiquidationIncentiveBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationIncentiveBps(100);\n    }\n\n    function test_accessControl_setLiquidationFactorBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationFactorBps(100);\n\n        vm.expectRevert(\"Invalid liquidation factor\");\n        market.setLiquidationFactorBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationFactorBps(100);\n    }\n\n    function test_accessControl_setLiquidationFeeBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationFeeBps(100);\n\n        vm.expectRevert(\"Invalid liquidation fee\");\n        market.setLiquidationFeeBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationFeeBps(100);\n    }\n\n    function test_accessControl_recall() public {\n        vm.startPrank(address(fed));\n        market.recall(100e18);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyLender);\n        market.recall(100e18);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "transfer and transferFrom functions in Market.sol",
                "Type": "Unhandled return values",
                "Description": "Some implementations of transfer and transferFrom could return \u2018false\u2019 on failure instead of reverting.",
                "Repair": "Wrap calls into require() statements to check for failures or use OpenZeppelin\u2019s SafeERC20 wrapper functions"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\n/// @title Permissions\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Inherited by almost all Malt contracts to provide access control\ncontract Permissions is AccessControl {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n  // Can mint/burn Malt\n  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(\"MONETARY_BURNER_ROLE\");\n  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(\"MONETARY_MINTER_ROLE\");\n\n  // Contract types\n  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(\"STABILIZER_NODE_ROLE\");\n  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(\"LIQUIDITY_MINE_ROLE\");\n  bytes32 public constant AUCTION_ROLE = keccak256(\"AUCTION_ROLE\");\n  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(\"REWARD_THROTTLE_ROLE\");\n\n  address internal globalAdmin;\n\n  mapping(address => uint256) public lastBlock; // protect against reentrancy\n\n  function _adminSetup(address _timelock) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(GOVERNOR_ROLE, _timelock);\n    _roleSetup(MONETARY_BURNER_ROLE, _timelock);\n    _roleSetup(MONETARY_MINTER_ROLE, _timelock);\n    _roleSetup(STABILIZER_NODE_ROLE, _timelock);\n    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);\n    _roleSetup(AUCTION_ROLE, _timelock);\n    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);\n\n    globalAdmin = _timelock;\n  }\n\n  function assignRole(bytes32 role, address _assignee)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _setupRole(role, _assignee);\n  }\n\n  function removeRole(bytes32 role, address _entity)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can revoke roles\")\n  {\n    revokeRole(role, _entity);\n  }\n\n  function reassignGlobalAdmin(address _admin)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);\n    _swapRole(_admin, globalAdmin, ADMIN_ROLE);\n    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);\n    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);\n    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);\n    _swapRole(_admin, globalAdmin, AUCTION_ROLE);\n    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);\n\n    globalAdmin = _admin;\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    // Transfers the entire balance of the Gas token to destination\n    destination.call{value: address(this).balance}('');\n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    destination.call{value: amount}('');\n  }\n\n  function partialWithdraw(address _token, address destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {\n    revokeRole(role, oldAccount);\n    _setupRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _setupRole(role, account);\n    _setRoleAdmin(role, ADMIN_ROLE);\n  }\n\n  function _onlyRole(bytes32 role, string memory reason) internal view {\n    require(\n      hasRole(\n        role,\n        _msgSender()\n      ),\n      reason\n    );\n  }\n\n  function _notSameBlock() internal {\n    require(\n      block.number > lastBlock[_msgSender()],\n      \"Can't carry out actions in the same block\"\n    );\n    lastBlock[_msgSender()] = block.number;\n  }\n\n  // Using internal function calls here reduces compiled bytecode size\n  modifier onlyRole(bytes32 role, string memory reason) {\n    _onlyRole(role, reason);\n    _;\n  }\n\n  modifier notSameBlock() {\n    _notSameBlock();\n    _;\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "Permissions contract, lines 85 and 101",
                "Type": "Unchecked return value",
                "Description": "ETH transfer using .call function in Permissions contract can appear successful even if it failed due to lack of verification of the return value.",
                "Repair": "Check the return value of the .call function to ensure that the transfer succeeded."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "Pools.sol#L211",
                "Type": "unhandled return value",
                "Description": "The transfer call of transferOut() could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.",
                "Repair": "Check the return value and revert on 0/false or use OpenZeppelin\u2019s SafeERC20 wrapper functions"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "RoyaltyVault.sol",
                "Type": "ERC20 tokens with no return value will fail to transfer",
                "Description": "ERC20 tokens with no return value will fail to transfer",
                "Repair": "Consider using OpenZeppelin\u2019s SafeERC20"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Auction.sol\";\n\n\nstruct EarlyExitData {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n}\n\nstruct AuctionExits {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n  mapping(address => EarlyExitData) accountExits;\n}\n\n\n/// @title Auction Escape Hatch\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Functionality to reduce risk profile of holding arbitrage tokens by allowing early exit\ncontract AuctionEscapeHatch is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  uint256 public maxEarlyExitBps = 200; // 20%\n  uint256 public cooloffPeriod = 60 * 60 * 24; // 24 hours\n\n  mapping(uint256 => AuctionExits) internal auctionEarlyExits;\n\n  event EarlyExit(address account, uint256 amount, uint256 received);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    address _auction,\n    address _handler\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function exitEarly(uint256 _auctionId, uint256 amount, uint256 minOut) external notSameBlock {\n    uint256 maltQuantity = _calculateMaltRequiredForExit(_auctionId, amount);\n\n    // TODO ensure this contract is added as a mint requester Sat 06 Nov 2021 20:13:49 GMT\n    malt.mint(address(dexHandler), maltQuantity);\n    uint256 amountOut = dexHandler.sellMalt();\n\n    require(amountOut > minOut, \"EarlyExit: Insufficient output\");\n\n    AuctionExits storage auctionExits = auctionEarlyExits[_auctionId];\n\n    auctionExits.exitedEarly = auctionExits.exitedEarly + amount;\n    auctionExits.earlyExitReturn = auctionExits.earlyExitReturn + amountOut;\n    auctionExits.maltUsed = auctionExits.maltUsed + maltQuantity;\n    auctionExits.accountExits[msg.sender].exitedEarly = auctionExits.accountExits[msg.sender].exitedEarly + amount; \n    auctionExits.accountExits[msg.sender].earlyExitReturn = auctionExits.accountExits[msg.sender].earlyExitReturn + amountOut; \n    auctionExits.accountExits[msg.sender].maltUsed = auctionExits.accountExits[msg.sender].maltUsed + maltQuantity; \n\n    auction.amendAccountParticipation(\n      msg.sender,\n      _auctionId,\n      amount,\n      maltQuantity\n    );\n\n    collateralToken.safeTransfer(msg.sender, amountOut);\n    emit EarlyExit(msg.sender, amount, amountOut);\n  }\n\n  function earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    if(active || block.timestamp < auctionEndTime) {\n      return 0;\n    }\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(account, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    uint256 userOutstanding = userCommitment - userRedeemed;\n\n    if (amount > userOutstanding) {\n      amount = userOutstanding;\n    }\n\n    if (amount == 0) {\n      return 0;\n    }\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      return amount + maxProfit;\n    } \n\n    return fullReturn;\n  }\n\n  function accountAuctionExits(address account, uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    EarlyExitData storage accountExits = auctionEarlyExits[auctionId].accountExits[account];\n\n    return (accountExits.exitedEarly, accountExits.earlyExitReturn, accountExits.maltUsed);\n  }\n\n  function globalAuctionExits(uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    AuctionExits storage auctionExits = auctionEarlyExits[auctionId];\n\n    return (auctionExits.exitedEarly, auctionExits.earlyExitReturn, auctionExits.maltUsed);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    require(!active, \"Cannot exit early on an active auction\");\n    require(block.timestamp > auctionEndTime, \"Auction not over\");\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(msg.sender, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    if (amount > (userCommitment - userRedeemed)) {\n      amount = userCommitment - userRedeemed;\n    }\n\n    require(amount > 0, \"Nothing to claim\");\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      uint256 desiredReturn = amount + maxProfit;\n      maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;\n    } \n\n    return maltQuantity;\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setEarlyExitBps(uint256 _earlyExitBps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, \"Must be between 0-100%\");\n    maxEarlyExitBps = _earlyExitBps;\n  }\n\n  function setCooloffPeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_period > 0, \"Cannot have 0 lookback period\");\n    cooloffPeriod = _period;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "AuctionEscapeHatch.sol",
                "Type": "Wrong return values",
                "Description": "The getAuctionCore() function returns wrong values out of order, leading to potential loss of user funds.",
                "Repair": "Add a missing comma in the function calls to getAuctionCore() to ensure the correct return values are used"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        // borrow on notional via special flash loan facility\n        //  - borrow repayment amount\n        //  - withdraw to wallet, redeem to underlying\n        // receive callback (tokens transferred to borrowing account)\n        //   -> inside callback\n        //   -> repayBorrowBehalf(account, repayAmount)\n        //   -> deposit cToken to notional (account needs to have set approvals)\n        //   -> exit callback\n        // inside original borrow, check FC\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }\n\n    receive() external payable {\n        // This contract cannot migrate ETH loans because there is no way\n        // to do transferFrom on ETH\n        revert(\"Cannot transfer ETH\");\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "CompoundToNotionalV2.enableToken",
                "Type": "ERC20 missing return value check",
                "Description": "The enableToken function performs an ERC20.approve() call but does not check the success return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        // borrow on notional via special flash loan facility\n        //  - borrow repayment amount\n        //  - withdraw to wallet, redeem to underlying\n        // receive callback (tokens transferred to borrowing account)\n        //   -> inside callback\n        //   -> repayBorrowBehalf(account, repayAmount)\n        //   -> deposit cToken to notional (account needs to have set approvals)\n        //   -> exit callback\n        // inside original borrow, check FC\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }\n\n    receive() external payable {\n        // This contract cannot migrate ETH loans because there is no way\n        // to do transferFrom on ETH\n        revert(\"Cannot transfer ETH\");\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "CompoundToNotionalV2.notionalCallback",
                "Type": "ERC20 return values not checked",
                "Description": "Some tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a success boolean.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 HOLOGRAPH \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                             \u2551\n\u2551                            / ^ \\                            \u2551\n\u2551                            ~~*~~            \u00b8               \u2551\n\u2551                         [ '<>:<>' ]         \u2502\u2591\u2591\u2591            \u2551\n\u2551               \u2554\u2557           _/\"\\_           \u2554\u2563               \u2551\n\u2551             \u250c\u2500\u256c\u256c\u2500\u2510          \"\"\"          \u250c\u2500\u256c\u256c\u2500\u2510             \u2551\n\u2551          \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510       \\_/       \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510          \u2551\n\u2551       \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510           \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510       \u2551\n\u2551    \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510     \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510    \u2551\n\u2551 \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2510 \u250c\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2500\u2510 \u2551\n\u2560\u252c\u2518 \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502\u2514\u00a4\u2518\u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502 \u2514\u252c\u2563\n\u2551\u2502  \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502   \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502  \u2502\u2551\n\u2560\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2563\n\u2560\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2563\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551    ,          \u2560\u2563     ,        ,'      *    \u2560\u2563               \u2551\n\u2551~~~~~^~~~~~~~~\u250c\u256c\u256c\u2510~~~^~~~~~~~~^^~~~~~~~~^~~\u250c\u256c\u256c\u2510~~~~~~~^~~~~~~\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor\u2019s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors\u2019 name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed \u201cas-is.\u201d You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/PA1DInterface.sol\";\n\nimport \"../struct/ZoraBidShares.sol\";\n\n/**\n * @title PA1D (CXIP)\n * @author CXIP-Labs\n * @notice A smart contract for providing royalty info, collecting royalties, and distributing it to configured payout wallets.\n * @dev This smart contract is not intended to be used directly. Apply it to any of your ERC721 or ERC1155 smart contracts through a delegatecall fallback.\n */\ncontract PA1D is Admin, Owner, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.defaultBp')) - 1)\n   */\n  bytes32 constant _defaultBpSlot = 0x3ab91e3c2ba71a57537d782545f8feb1d402b604f5e070fa6c3b911fc2f18f75;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.defaultReceiver')) - 1)\n   */\n  bytes32 constant _defaultReceiverSlot = 0xfd430e1c7265cc31dbd9a10ce657e68878a41cfe179c80cd68c5edf961516848;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.initialized')) - 1)\n   */\n  bytes32 constant _initializedPaidSlot = 0x33a44e907d5bf333e203bebc20bb8c91c00375213b80f466a908f3d50b337c6c;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.payout.addresses')) - 1)\n   */\n  bytes32 constant _payoutAddressesSlot = 0x700a541bc37f227b0d36d34e7b77cc0108bde768297c6f80f448f380387371df;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.payout.bps')) - 1)\n   */\n  bytes32 constant _payoutBpsSlot = 0x7a62e8104cd2cc2ef6bd3a26bcb71428108fbe0e0ead6a5bfb8676781e2ed28d;\n\n  string constant _bpString = \"eip1967.Holograph.PA1D.bp\";\n  string constant _receiverString = \"eip1967.Holograph.PA1D.receiver\";\n  string constant _tokenAddressString = \"eip1967.Holograph.PA1D.tokenAddress\";\n\n  /**\n   * @notice Event emitted when setting/updating royalty info/fees. This is used by Rarible V1.\n   * @dev Emits event in order to comply with Rarible V1 royalty spec.\n   * @param tokenId Specific token id for which royalty info is being set, set as 0 for all tokens inside of the smart contract.\n   * @param recipients Address array of wallets that will receive tha royalties.\n   * @param bps Uint256 array of base points(percentages) that each wallet(specified in recipients) will receive from the royalty payouts. Make sure that all the base points add up to a total of 10000.\n   */\n  event SecondarySaleFees(uint256 tokenId, address[] recipients, uint256[] bps);\n\n  /**\n   * @dev Use this modifier to lock public functions that should not be accesible to non-owners.\n   */\n  modifier onlyOwner() override {\n    require(isOwner(), \"PA1D: caller not an owner\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"PA1D: already initialized\");\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_ownerSlot, caller())\n    }\n    (address receiver, uint256 bp) = abi.decode(initPayload, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function initPA1D(bytes memory initPayload) external returns (bytes4) {\n    uint256 initialized;\n    assembly {\n      initialized := sload(_initializedPaidSlot)\n    }\n    require(initialized == 0, \"PA1D: already initialized\");\n    (address receiver, uint256 bp) = abi.decode(initPayload, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    initialized = 1;\n    assembly {\n      sstore(_initializedPaidSlot, initialized)\n    }\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Check if message sender is a legitimate owner of the smart contract\n   * @dev We check owner, admin, and identity for a more comprehensive coverage.\n   * @return Returns true is message sender is an owner.\n   */\n  function isOwner() private view returns (bool) {\n    return (msg.sender == getOwner() ||\n      msg.sender == getAdmin() ||\n      msg.sender == Owner(address(this)).getOwner() ||\n      msg.sender == Admin(address(this)).getAdmin());\n  }\n\n  /**\n   * @dev Gets the default royalty payment receiver address from storage slot.\n   * @return receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _getDefaultReceiver() private view returns (address payable receiver) {\n    assembly {\n      receiver := sload(_defaultReceiverSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty payment receiver address to storage slot.\n   * @param receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _setDefaultReceiver(address receiver) private {\n    assembly {\n      sstore(_defaultReceiverSlot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the default royalty base points(percentage) from storage slot.\n   * @return bp Royalty base points(percentage) for royalty payouts.\n   */\n  function _getDefaultBp() private view returns (uint256 bp) {\n    assembly {\n      bp := sload(_defaultBpSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty base points(percentage) to storage slot.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function _setDefaultBp(uint256 bp) private {\n    assembly {\n      sstore(_defaultBpSlot, bp)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty payment receiver address, for a particular token id, from storage slot.\n   * @return receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _getReceiver(uint256 tokenId) private view returns (address payable receiver) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      receiver := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty payment receiver address, for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the receiver for.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _setReceiver(uint256 tokenId, address receiver) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      sstore(slot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty base points(percentage), for a particular token id, from storage slot.\n   * @return bp Royalty base points(percentage) for the royalty payouts of a specific token id.\n   */\n  function _getBp(uint256 tokenId) private view returns (uint256 bp) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      bp := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty base points(percentage), for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the base points for.\n   * @param bp Uint256 of royalty percentage, provided in base points format, for a particular token id.\n   */\n  function _setBp(uint256 tokenId, uint256 bp) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      sstore(slot, bp)\n    }\n  }\n\n  function _getPayoutAddresses() private view returns (address payable[] memory addresses) {\n    // The slot hash has been precomputed for gas optimizaion\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    addresses = new address payable[](length);\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      addresses[i] = value;\n    }\n  }\n\n  function _setPayoutAddresses(address payable[] memory addresses) private {\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length = addresses.length;\n    assembly {\n      sstore(slot, length)\n    }\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = addresses[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getPayoutBps() private view returns (uint256[] memory bps) {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    bps = new uint256[](length);\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      bps[i] = value;\n    }\n  }\n\n  function _setPayoutBps(uint256[] memory bps) private {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length = bps.length;\n    assembly {\n      sstore(slot, length)\n    }\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = bps[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getTokenAddress(string memory tokenName) private view returns (address tokenAddress) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      tokenAddress := sload(slot)\n    }\n  }\n\n  function _setTokenAddress(string memory tokenName, address tokenAddress) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      sstore(slot, tokenAddress)\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers ETH to all payout recipients.\n   */\n  function _payoutEth() private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    // accommodating the 2300 gas stipend\n    // adding 1x for each item in array to accomodate rounding errors\n    uint256 gasCost = (23300 * length) + length;\n    uint256 balance = address(this).balance;\n    require(balance - gasCost > 10000, \"PA1D: Not enough ETH to transfer\");\n    balance = balance - gasCost;\n    uint256 sending;\n    // uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      addresses[i].transfer(sending);\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers tokens to all payout recipients.\n   * @param tokenAddress Smart contract address of ERC20 token.\n   */\n  function _payoutToken(address tokenAddress) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    ERC20 erc20 = ERC20(tokenAddress);\n    uint256 balance = erc20.balanceOf(address(this));\n    require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n    uint256 sending;\n    //uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers multiple tokens to all payout recipients.\n   * @dev Try to use _payoutToken and handle each token individually.\n   * @param tokenAddresses Array of smart contract addresses of ERC20 tokens.\n   */\n  function _payoutTokens(address[] memory tokenAddresses) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    ERC20 erc20;\n    uint256 balance;\n    uint256 sending;\n    for (uint256 t = 0; t < tokenAddresses.length; t++) {\n      erc20 = ERC20(tokenAddresses[t]);\n      balance = erc20.balanceOf(address(this));\n      require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n      // uint256 sent;\n      for (uint256 i = 0; i < addresses.length; i++) {\n        sending = ((bps[i] * balance) / 10000);\n        require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n        // sent = sent + sending;\n      }\n    }\n  }\n\n  /**\n   * @dev This function validates that the call is being made by an authorised wallet.\n   * @dev Will revert entire tranaction if it fails.\n   */\n  function _validatePayoutRequestor() private view {\n    if (!isOwner()) {\n      bool matched;\n      address payable[] memory addresses = _getPayoutAddresses();\n      address payable sender = payable(msg.sender);\n      for (uint256 i = 0; i < addresses.length; i++) {\n        if (addresses[i] == sender) {\n          matched = true;\n          break;\n        }\n      }\n      require(matched, \"PA1D: sender not authorized\");\n    }\n  }\n\n  /**\n   * @notice Set the wallets and percentages for royalty payouts.\n   * @dev Function can only we called by owner, admin, or identity wallet.\n   * @dev Addresses and bps arrays must be equal length. Bps values added together must equal 10000 exactly.\n   * @param addresses An array of all the addresses that will be receiving royalty payouts.\n   * @param bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function configurePayouts(address payable[] memory addresses, uint256[] memory bps) public onlyOwner {\n    require(addresses.length == bps.length, \"PA1D: missmatched array lenghts\");\n    uint256 totalBp;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      totalBp = totalBp + bps[i];\n    }\n    require(totalBp == 10000, \"PA1D: bps down't equal 10000\");\n    _setPayoutAddresses(addresses);\n    _setPayoutBps(bps);\n  }\n\n  /**\n   * @notice Show the wallets and percentages of payout recipients.\n   * @dev These are the recipients that will be getting royalty payouts.\n   * @return addresses An array of all the addresses that will be receiving royalty payouts.\n   * @return bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function getPayoutInfo() public view returns (address payable[] memory addresses, uint256[] memory bps) {\n    addresses = _getPayoutAddresses();\n    bps = _getPayoutBps();\n  }\n\n  /**\n   * @notice Get payout of all ETH in smart contract.\n   * @dev Distribute all the ETH(minus gas fees) to payout recipients.\n   */\n  function getEthPayout() public {\n    _validatePayoutRequestor();\n    _payoutEth();\n  }\n\n  /**\n   * @notice Get payout for a specific token address. Token must have a positive balance!\n   * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n   * @param tokenAddress An address of the token for which to issue payouts for.\n   */\n  function getTokenPayout(address tokenAddress) public {\n    _validatePayoutRequestor();\n    _payoutToken(tokenAddress);\n  }\n\n  /**\n   * @notice Get payouts for tokens listed by address. Tokens must have a positive balance!\n   * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n   * @param tokenAddresses An address array of tokens to issue payouts for.\n   */\n  function getTokensPayout(address[] memory tokenAddresses) public {\n    _validatePayoutRequestor();\n    _payoutTokens(tokenAddresses);\n  }\n\n  /**\n   * @notice Set the royalty information for entire contract, or a specific token.\n   * @dev Take great care to not make this function accessible by other public functions in your overlying smart contract.\n   * @param tokenId Set a specific token id, or leave at 0 to set as default parameters.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function setRoyalties(\n    uint256 tokenId,\n    address payable receiver,\n    uint256 bp\n  ) public onlyOwner {\n    if (tokenId == 0) {\n      _setDefaultReceiver(receiver);\n      _setDefaultBp(bp);\n    } else {\n      _setReceiver(tokenId, receiver);\n      _setBp(tokenId, bp);\n    }\n    address[] memory receivers = new address[](1);\n    receivers[0] = address(receiver);\n    uint256[] memory bps = new uint256[](1);\n    bps[0] = bp;\n    emit SecondarySaleFees(tokenId, receivers, bps);\n  }\n\n  // IEIP2981\n  function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultReceiver(), (_getDefaultBp() * value) / 10000);\n    } else {\n      return (_getReceiver(tokenId), (_getBp(tokenId) * value) / 10000);\n    }\n  }\n\n  // Rarible V1\n  function getFeeBps(uint256 tokenId) public view returns (uint256[] memory) {\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      bps[0] = _getDefaultBp();\n    } else {\n      bps[0] = _getBp(tokenId);\n    }\n    return bps;\n  }\n\n  // Rarible V1\n  function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n    }\n    return receivers;\n  }\n\n  // Rarible V2(not being used since it creates a conflict with Manifold royalties)\n  // struct Part {\n  //     address payable account;\n  //     uint96 value;\n  // }\n\n  // function getRoyalties(uint256 tokenId) public view returns (Part[] memory) {\n  //     return royalties[id];\n  // }\n\n  // Manifold\n  function getRoyalties(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // Foundation\n  function getFees(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // SuperRare\n  // Hint taken from Manifold's RoyaltyEngine(https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol)\n  // To be quite honest, SuperRare is a closed marketplace. They're working on opening it up but looks like they want to use private smart contracts.\n  // We'll just leave this here for just in case they open the flood gates.\n  function tokenCreator(\n    address,\n    /* contractAddress*/\n    uint256 tokenId\n  ) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // SuperRare\n  function calculateRoyaltyFee(\n    address,\n    /* contractAddress */\n    uint256 tokenId,\n    uint256 amount\n  ) public view returns (uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultBp() * amount) / 10000;\n    } else {\n      return (_getBp(tokenId) * amount) / 10000;\n    }\n  }\n\n  // Zora\n  // we indicate that this contract operates market functions\n  function marketContract() public view returns (address) {\n    return address(this);\n  }\n\n  // Zora\n  // we indicate that the receiver is the creator, to convince the smart contract to pay\n  function tokenCreators(uint256 tokenId) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // Zora\n  // we provide the percentage that needs to be paid out from the sale\n  function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {\n    // this information is outside of the scope of our\n    bidShares.prevOwner.value = 0;\n    bidShares.owner.value = 0;\n    if (_getReceiver(tokenId) == address(0)) {\n      bidShares.creator.value = _getDefaultBp();\n    } else {\n      bidShares.creator.value = _getBp(tokenId);\n    }\n    return bidShares;\n  }\n\n  /**\n   * @notice Get the smart contract address of a token by common name.\n   * @dev Used only to identify really major/common tokens. Avoid using due to gas usages.\n   * @param tokenName The ticker symbol of the token. For example \"USDC\" or \"DAI\".\n   * @return The smart contract address of the token ticker symbol. Or zero address if not found.\n   */\n  function getTokenAddress(string memory tokenName) public view returns (address) {\n    return _getTokenAddress(tokenName);\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "PA1D.sol#L317, PA1D.sol#L340",
                "Type": "missing return value check",
                "Description": "_payoutToken[s is blocked and tokens are stuck in contract.",
                "Repair": "Use OpenZeppelin's SafeERC20, which handles the return value check as well as non-standard-compliant tokens."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./Create2BeaconMaker.sol\";\nlibrary BeaconProxyDeployer {\n    function deploy(address beacon, bytes memory initializationCalldata)\n        internal\n        returns (address result)\n    {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n        bytes32 salt = bytes32(0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(\n        address deployer,\n        address beacon,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n\n        bytes32 salt = bytes32(0);\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(createCode);\n        addr = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            deployer, // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "BeaconProxyDeployer.deploy() function in BeaconProxyDeployer.sol",
                "Type": "Improper Validation Of create2 Return Value",
                "Description": "The function does not revert properly if there is a failed contract deployment or revert from the create2 opcode as it does not properly check the returned address for bytecode.",
                "Repair": "Update iszero(result) to iszero(extcodesize(result)) in the line mentioned above."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/compound/CEtherInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    currencyId,\n                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))\n                )\n            );\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {\n        bytes32 slot = _getSlot(currencyId, underlying);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n        address tokenAddress = address(bytes20(data << 96));\n        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;\n        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));\n        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));\n\n        return\n            Token({\n                tokenAddress: tokenAddress,\n                hasTransferFee: tokenHasTransferFee,\n                decimals: int256(10**tokenDecimalPlaces),\n                tokenType: tokenType\n            });\n    }\n\n    /// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }\n\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        uint256 success;\n        if (token.tokenType == TokenType.cToken) {\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\n        } else if (token.tokenType == TokenType.cETH) {\n            // Reverts on error\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\n        } else {\n            revert(); // dev: non mintable token\n        }\n\n        require(success == 0, \"Mint fail\");\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        // This is the starting and ending balance in external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    function redeem(\n        Token memory assetToken,\n        Token memory underlyingToken,\n        uint256 assetAmountExternal\n    ) internal returns (int256) {\n        uint256 startingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            startingBalance = address(this).balance;\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        } else {\n            revert(); // dev: non redeemable failure\n        }\n\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\n        require(success == 0, \"Redeem fail\");\n\n        uint256 endingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            endingBalance = address(this).balance;\n        } else {\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        }\n\n        // Underlying token external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\n    /// precision.\n    function transfer(\n        Token memory token,\n        address account,\n        int256 netTransferExternal\n    ) internal returns (int256) {\n        if (netTransferExternal > 0) {\n            // Deposits must account for transfer fees.\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\n        } else if (token.tokenType == TokenType.Ether) {\n            require(netTransferExternal < 0); // dev: cannot transfer ether\n            address payable accountPayable = payable(account);\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\n        } else {\n            safeTransferOut(\n                IERC20(token.tokenAddress),\n                account,\n                uint256(netTransferExternal.neg())\n            );\n        }\n\n        return netTransferExternal;\n    }\n\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\n    /// precision.\n    function _deposit(\n        Token memory token,\n        address account,\n        uint256 amount\n    ) private returns (int256) {\n        if (token.hasTransferFee) {\n            // Must deposit from the token and calculate the net transfer\n            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n            safeTransferIn(IERC20(token.tokenAddress), account, amount);\n            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n            return int256(endingBalance.sub(startingBalance));\n        }\n\n        safeTransferIn(IERC20(token.tokenAddress), account, amount);\n        return int256(amount);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);\n    }\n\n    function safeTransferOut(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transfer(account, amount);\n        checkReturnCode();\n    }\n\n    function safeTransferIn(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transferFrom(account, address(this), amount);\n        checkReturnCode();\n    }\n\n    function checkReturnCode() private pure {\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {\n                    // This is a non-standard ERC-20\n                    success := not(0) // set success to true\n                }\n                case 32 {\n                    // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0) // Set `success = returndata` of external call\n                }\n                default {\n                    // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        require(success, \"Transfer Failed\");\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Location": "TokenHandler.setToken",
                "Type": "missing return value check",
                "Description": "The setToken function performs an ERC20.approve() call but does not check the success return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens"
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeSend(address payable recipient, uint256 amount) public { recipient.call{value: amount}(\"\"); }}",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeSend function",
                "Type": "unchecked return",
                "Description": "The return value of 'call' is not checked, which may lead to unintended behavior. If the call fails (for example, if the recipient contract throws an exception), the current contract will not be aware of this and will continue execution.",
                "Repair": "Always handle the return value of 'call'. In case of failure, you might want to revert the transaction to prevent further execution with inconsistent state."
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeTransfer(address payable recipient, uint256 amount, address payable token) public { IERC20(token).transfer(recipient, amount); } }",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeTransfer function",
                "Type": "unchecked return",
                "Description": "The 'unsafeTransfer' function attempts to transfer ERC20 tokens using the 'transfer' method of the IERC20 interface, but it doesn't check the return value. If the 'transfer' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the 'transfer' call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeTransfer(address payable recipient, uint256 amount, address payable token) public { IERC20(token).transfer(recipient, amount); } }",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeTransfer function",
                "Type": "unchecked return",
                "Description": "The 'unsafeTransfer' function attempts to transfer ERC20 tokens using the 'transfer' method of the IERC20 interface, but it doesn't check the return value. If the 'transfer' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the 'transfer' call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeAllowance(address token, address owner, address spender) public { IERC20(token).allowance(owner, spender); } }",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeAllowance function",
                "Type": "unchecked return",
                "Description": "The 'unsafeAllowance' function attempts to check the amount of tokens that an owner allowed to a spender, using the 'allowance' method of the IERC20 interface. However, it doesn't use or check the return value. If the 'allowance' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Use the return value of the 'allowance' call and check it. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; contract Vulnerable is ERC721 { constructor() ERC721('Token', 'TKN') {} function unsafeMint(address to, uint256 tokenId) public { _mint(to, tokenId); } }",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeMint function",
                "Type": "unchecked return",
                "Description": "The 'unsafeMint' function attempts to mint an ERC721 token using the '_mint' method of the ERC721 contract, but it doesn't check the return value. If the '_mint' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "In case of the OpenZeppelin's ERC721 contract, the '_mint' function does not return a value. However, it can revert the transaction if the minting operation fails. Therefore, it's important to handle potential reverts or exceptions correctly in the code calling this function."
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; contract Vulnerable is ERC721 { constructor() ERC721('Token', 'TKN') {} function unsafeTransferFrom(address from, address to, uint256 tokenId) public { _transfer(from, to, tokenId); } }",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeTransferFrom function",
                "Type": "unchecked return",
                "Description": "The 'unsafeTransferFrom' function attempts to transfer an ERC721 token from one address to another using the '_transfer' method of the ERC721 contract, but it doesn't check the return value. If the '_transfer' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "In case of the OpenZeppelin's ERC721 contract, the '_transfer' function does not return a value. However, it can revert the transaction if the transfer operation fails. Therefore, it's important to handle potential reverts or exceptions correctly in the code calling this function."
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; contract Vulnerable { function unsafeBurn(address token, address account, uint256 amount) public { IERC20(token).burnFrom(account, amount); } }",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeBurn function",
                "Type": "unchecked return",
                "Description": "The 'unsafeBurn' function attempts to burn tokens from a specific account using the 'burnFrom' method of the IERC20 interface, but it doesn't check the return value. If the 'burnFrom' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the 'burnFrom' call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeLowLevelCall(address payable recipient) public { recipient.call(''); } }",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeLowLevelCall function",
                "Type": "unchecked return",
                "Description": "The 'unsafeLowLevelCall' function attempts a low-level call to a contract, but it doesn't check the return value. If the low-level call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the low-level call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
    "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeDelegateCall(address target, bytes memory data) public { target.delegatecall(data); } }",
    "VulnerabilityDesc": [
            {
                "Location": "unsafeDelegateCall function",
                "Type": "unchecked return",
                "Description": "The 'unsafeDelegateCall' function attempts a delegate call to a target contract, but it doesn't check the return value. If the delegate call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the delegate call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    }
]