[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./IBadgerSett.sol\";\nimport \"./IBadger.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/// @title A pooltogether yield source for badger sett\n/// @author Steffel Fenix, 0xkarl\ncontract BadgerYieldSource is IYieldSource {\n    using SafeMath for uint256;\n    IBadgerSett private immutable badgerSett;\n    IBadger private immutable badger;\n    mapping(address => uint256) private balances;\n\n    constructor(address badgerSettAddr, address badgerAddr) public {\n        badgerSett = IBadgerSett(badgerSettAddr);\n        badger = IBadger(badgerAddr);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return (address(badger));\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = badgerSett.totalSupply();\n        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));\n        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));\n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        badger.transferFrom(msg.sender, address(this), amount);\n        badger.approve(address(badgerSett), amount);\n\n        uint256 beforeBalance = badgerSett.balanceOf(address(this));\n        badgerSett.deposit(amount);\n        uint256 afterBalance = badgerSett.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @return The actual amount of tokens that were redeemed.\n    function redeemToken(uint256 amount) public override returns (uint256) {\n        uint256 totalShares = badgerSett.totalSupply();\n        if (totalShares == 0) return 0;\n\n        uint256 badgerSettBadgerBalance = badgerSett.balance();\n        if (badgerSettBadgerBalance == 0) return 0;\n\n        uint256 badgerBeforeBalance = badger.balanceOf(address(this));\n\n        uint256 requiredShares =\n            ((amount.mul(totalShares) + totalShares)).div(\n                badgerSettBadgerBalance\n            );\n        if (requiredShares == 0) return 0;\n\n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        badgerSett.withdraw(requiredSharesBalance);\n\n        uint256 badgerAfterBalance = badger.balanceOf(address(this));\n        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        badger.transfer(msg.sender, badgerBalanceDiff);\n        return (badgerBalanceDiff);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "return_1",
                "Location": "badger.transferFrom(msg.sender, address(this), amount); badger.transfer(msg.sender, badgerBalanceDiff);",
                "Type": "Unchecked return values",
                "Description": "The return values of ERC20 transfer and transferFrom are not checked to be true, which could be false if the transferred tokens are not ERC20-compliant.",
                "Repair": "Use SafeERC20 library implementation and call safeTransfer or safeTransferFrom when transferring ERC20 tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\ninterface CErc20 {\n    function underlying() external view returns (address);\n}\n\ncontract UniswapConfig is Ownable {\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n    enum PriceSource {\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n        REPORTER   /// implies the price is set by the reporter\n    }\n\n    /// @dev Describe how the USD price should be determined for an asset.\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\n    struct TokenConfig {\n        address cToken;\n        address underlying;\n        bytes32 symbolHash;\n        uint256 baseUnit;\n        PriceSource priceSource;\n        uint256 fixedPrice;\n        address uniswapMarket;\n        bool isUniswapReversed;\n    }\n\n    mapping(uint => TokenConfig) public tokens;\n    mapping(address => uint) public cTokenIndex;\n    mapping(address => uint) public underlyingIndex;\n    mapping(bytes32 => uint) public symbolHashIndex;\n\n    /// @notice The number of tokens this contract actually supports\n    uint public numTokens;\n\n    function _addTokensInternal(TokenConfig[] memory configs) internal {\n        for (uint i = 0; i < configs.length; i++) {\n            uint index = i + numTokens;\n            tokens[index] = configs[i];\n            cTokenIndex[configs[i].cToken] = index;\n            underlyingIndex[configs[i].underlying] = index;\n            symbolHashIndex[configs[i].symbolHash] = index;\n        }\n\n        numTokens = numTokens + configs.length;\n    }\n\n    function getCTokenIndex(address cToken) internal view returns (uint) {\n        return cTokenIndex[cToken];\n    }\n\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\n        return underlyingIndex[underlying];\n    }\n\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n        return symbolHashIndex[symbolHash];\n    }\n\n    /**\n     * @notice Get the i-th config, according to the order they were passed in originally\n     * @param i The index of the config to get\n     * @return The config object\n     */\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\n        require(i < numTokens, \"token config not found\");\n\n        return tokens[i];\n    }\n\n    /**\n     * @notice Get the config for symbol\n     * @param symbol The symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n    }\n\n    /**\n     * @notice Get the config for the symbolHash\n     * @param symbolHash The keccack256 of the symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n        uint index = getSymbolHashIndex(symbolHash);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        revert(\"token config not found\");\n    }\n\n    /**\n     * @notice Get the config for the cToken\n     * @dev If a config for the cToken is not found, falls back to searching for the underlying.\n     * @param cToken The address of the cToken of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\n        uint index = getCTokenIndex(cToken);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        return getTokenConfigByUnderlying(CErc20(cToken).underlying());\n    }\n\n    /**\n     * @notice Get the config for an underlying asset\n     * @param underlying The address of the underlying asset of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n        uint index = getUnderlyingIndex(underlying);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        revert(\"token config not found\");\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "return_2",
                "Location": "UniswapConfig.getTokenConfigBySymbolHash, getTokenConfigByCToken, getTokenConfigByUnderlying functions",
                "Type": "UniswapConfig getters return wrong token config.",
                "Description": "The functions return wrong token config if token config does not exist.functions getTokenConfigBySymbolHash, getTokenConfigByCToken and getTokenConfigByUnderlying check returned index against max uint:\nindex != uint(-1)\n-1 should indicate that the index is not found, however, a default value for an uninitialized uint is 0, so it is impossible to get -1. What is even weirder is that 0 will be returned for non-existing configs but 0 is a valid index for the 1st config.",
                "Repair": "Fix the non-existence check"
            }
        ]
    },
    {
        "Code": "struct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\ninterface INFTOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(address pair, uint256 tokenId) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(address pair, uint256 tokenId) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(address pair, uint256 tokenId) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(address pair, uint256 tokenId) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// @return (string) A human readable name about this oracle.\n    function name(address pair, uint256 tokenId) external view returns (string memory);\n}\n\nfunction removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, \"NFTPair: not the lender\");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS < amount, \"NFT is still valued\");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS &&\n                params.ltvBPS >= accepted.ltvBPS,\n            \"NFTPair: bad params\"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, \"Oracle: price too low.\");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "return_3",
                "Location": "(, uint256 rate) = loanParams.oracle.get(address(this), tokenId);(, uint256 rate) = params.oracle.get(address(this), tokenId);",
                "Type": "Unchecked return value",
                "Description": "The success value returned by the get function of the INFTOracle interface is not checked in the NFTPairWithOracle contract, which may result in stale data being used and assets being lost. The vulnerability has been confirmed and upgraded to High severity.",
                "Repair": "Check the success value returned by the get function of the INFTOracle interface before using the rate value"
            }
        ]
    },
    {
        "Code": "function _returnDust() private {\n        uint256 _remainingETH = remainingETH;\n        assembly {\n            if gt(_remainingETH, 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "return_4",
                "Location": "function _returnDust()",
                "Type": "Unchecked Yul call return value",
                "Description": "The Yul call return value on function _returnDust is not checked, which could lead to the sender losing funds.",
                "Repair": "Check the return value of the Yul call and revert if unsuccessful"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ISushiBar.sol\";\nimport \"./ISushi.sol\";\n\n/// @title A pooltogether yield source for sushi token\n/// @author Steffel Fenix\ncontract SushiYieldSource is IYieldSource {\n    \n    using SafeMath for uint256;\n    \n    ISushiBar public immutable sushiBar;\n    ISushi public immutable sushiAddr;\n    \n    mapping(address => uint256) public balances;\n\n    constructor(ISushiBar _sushiBar, ISushi _sushiAddr) public {\n        sushiBar = _sushiBar;\n        sushiAddr = _sushiAddr;\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return address(sushiAddr);\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = sushiBar.totalSupply();\n        uint256 barSushiBalance = sushiAddr.balanceOf(address(sushiBar));\n\n        return balances[addr].mul(barSushiBalance).div(totalShares);       \n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        sushiAddr.transferFrom(msg.sender, address(this), amount);\n        sushiAddr.approve(address(sushiBar), amount);\n\n        ISushiBar bar = sushiBar;\n        uint256 beforeBalance = bar.balanceOf(address(this));\n        \n        bar.enter(amount);\n        \n        uint256 afterBalance = bar.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        \n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @dev The maxiumum that can be called for token() is calculated by balanceOfToken() above.\n    /// @return The actual amount of tokens that were redeemed. This may be different from the amount passed due to the fractional math involved. \n    function redeemToken(uint256 amount) public override returns (uint256) {\n        ISushiBar bar = sushiBar;\n        ISushi sushi = sushiAddr;\n\n        uint256 totalShares = bar.totalSupply();\n        if(totalShares == 0) return 0; \n\n        uint256 barSushiBalance = sushi.balanceOf(address(bar));\n        if(barSushiBalance == 0) return 0;\n\n        uint256 sushiBeforeBalance = sushi.balanceOf(address(this));\n\n        uint256 requiredShares = ((amount.mul(totalShares) + totalShares)).div(barSushiBalance);\n        if(requiredShares == 0) return 0;\n        \n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        bar.leave(requiredSharesBalance);\n\n        uint256 sushiAfterBalance = sushi.balanceOf(address(this));\n        \n        uint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        sushi.transfer(msg.sender, sushiBalanceDiff);\n        \n        return (sushiBalanceDiff);\n    }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "return_5",
                "Location": "sushiAddr.transferFrom(msg.sender, address(this), amount); sushi.transfer(msg.sender, sushiBalanceDiff);",
                "Type": "Unchecked return values",
                "Description": "The return values of ERC20 transfer and transferFrom are not checked to be true, which could be false if the transferred tokens are not ERC20-compliant.",
                "Repair": "Use SafeERC20 library implementation and call safeTransfer or safeTransferFrom when transferring ERC20 tokens"
            }
        ]
    },
    {
        "Code": "function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n}",
        "VulnerabilityDesc": [
            {
                "Name": "return_6",
                "Location": "payableToken.transferFrom(address(this), msg.sender, amount);",
                "Type": "Not handling return value",
                "Description": "Not handling return value of transferFrom command can create inconsistency",
                "Repair": "Add a require statement to check the return value of transferFrom command"
            }
        ]
    },
    {
        "Code": "interface ITempus {\n    function maturityTime() external view returns (uint256);\n\n    function yieldBearingToken() external view returns (IERC20Metadata);\n\n    function depositAndFix(\n        Any,\n        Any,\n        uint256,\n        bool,\n        uint256,\n        uint256\n    ) external returns (uint256, uint256);\n}\n\nfunction lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n            revert NotEqual('underlying');\n        } else if (ITempus(principal).maturityTime() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Get the underlying token\n        IERC20 underlyingToken = IERC20(u);\n\n        // Transfer funds from user to Illuminate, Scope to avoid stack limit\n        Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "return_7",
                "Location": "uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));",
                "Type": "The lend function for tempus uses the wrong return value of depositAndFix",
                "Description": "The depositAndFix function of the TempusController contract returns two uint256 data, the first is the number of shares exchanged for the underlying token, the second is the number of principalToken exchanged for the shares, the second return value should be used in the lend function for tempus.",
                "Repair": "Use the second return value of depositAndFix function for the lend function for tempus."
            }
        ]
    },
    {
        "Code": "function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "return_8",
                "Location": "payableToken.transferFrom(address(this), msg.sender, amount);",
                "Type": "ERC20 transferFrom return values not checked",
                "Description": "ERC20 transferFrom return values not checked",
                "Repair": "Check the success boolean of all transferFrom calls or use OZ\u2019s SafeERC20\u2019s safeTransferFrom() function"
            }
        ]
    },
    {
        "Code": "function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n}\n\nfunction deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n\nfunction borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\nfunction repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\nfunction forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "return_9",
                "Location": "transfer and transferFrom functions in Market.sol",
                "Type": "Unhandled return values",
                "Description": "Some implementations of transfer and transferFrom could return \u2018false\u2019 on failure instead of reverting.",
                "Repair": "Wrap calls into require() statements to check for failures or use OpenZeppelin\u2019s SafeERC20 wrapper functions"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\n/// @title Permissions\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Inherited by almost all Malt contracts to provide access control\ncontract Permissions is AccessControl {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n  // Can mint/burn Malt\n  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(\"MONETARY_BURNER_ROLE\");\n  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(\"MONETARY_MINTER_ROLE\");\n\n  // Contract types\n  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(\"STABILIZER_NODE_ROLE\");\n  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(\"LIQUIDITY_MINE_ROLE\");\n  bytes32 public constant AUCTION_ROLE = keccak256(\"AUCTION_ROLE\");\n  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(\"REWARD_THROTTLE_ROLE\");\n\n  address internal globalAdmin;\n\n  mapping(address => uint256) public lastBlock; // protect against reentrancy\n\n  function _adminSetup(address _timelock) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(GOVERNOR_ROLE, _timelock);\n    _roleSetup(MONETARY_BURNER_ROLE, _timelock);\n    _roleSetup(MONETARY_MINTER_ROLE, _timelock);\n    _roleSetup(STABILIZER_NODE_ROLE, _timelock);\n    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);\n    _roleSetup(AUCTION_ROLE, _timelock);\n    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);\n\n    globalAdmin = _timelock;\n  }\n\n  function assignRole(bytes32 role, address _assignee)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _setupRole(role, _assignee);\n  }\n\n  function removeRole(bytes32 role, address _entity)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can revoke roles\")\n  {\n    revokeRole(role, _entity);\n  }\n\n  function reassignGlobalAdmin(address _admin)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);\n    _swapRole(_admin, globalAdmin, ADMIN_ROLE);\n    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);\n    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);\n    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);\n    _swapRole(_admin, globalAdmin, AUCTION_ROLE);\n    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);\n\n    globalAdmin = _admin;\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    // Transfers the entire balance of the Gas token to destination\n    destination.call{value: address(this).balance}('');\n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    destination.call{value: amount}('');\n  }\n\n  function partialWithdraw(address _token, address destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {\n    revokeRole(role, oldAccount);\n    _setupRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _setupRole(role, account);\n    _setRoleAdmin(role, ADMIN_ROLE);\n  }\n\n  function _onlyRole(bytes32 role, string memory reason) internal view {\n    require(\n      hasRole(\n        role,\n        _msgSender()\n      ),\n      reason\n    );\n  }\n\n  function _notSameBlock() internal {\n    require(\n      block.number > lastBlock[_msgSender()],\n      \"Can't carry out actions in the same block\"\n    );\n    lastBlock[_msgSender()] = block.number;\n  }\n\n  // Using internal function calls here reduces compiled bytecode size\n  modifier onlyRole(bytes32 role, string memory reason) {\n    _onlyRole(role, reason);\n    _;\n  }\n\n  modifier notSameBlock() {\n    _notSameBlock();\n    _;\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "return_10",
                "Location": "Permissions contract, lines 85 and 101",
                "Type": "Unchecked return value",
                "Description": "ETH transfer using .call function in Permissions contract can appear successful even if it failed due to lack of verification of the return value.",
                "Repair": "Check the return value of the .call function to ensure that the transfer succeeded."
            }
        ]
    },
    {
        "Code": "function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "return_11",
                "Location": "iERC20(_token).transfer(_recipient, _amount);",
                "Type": "unhandled return value",
                "Description": "The transfer call of transferOut() could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.",
                "Repair": "Check the return value and revert on 0/false or use OpenZeppelin\u2019s SafeERC20 wrapper functions"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "return_12",
                "Location": "RoyaltyVault.sol",
                "Type": "ERC20 tokens with no return value will fail to transfer",
                "Description": "ERC20 tokens with no return value will fail to transfer",
                "Repair": "Consider using OpenZeppelin\u2019s SafeERC20"
            }
        ]
    },
    {
        "Code": "function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n}\n\nfunction earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    if(active || block.timestamp < auctionEndTime) {\n      return 0;\n    }\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(account, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    uint256 userOutstanding = userCommitment - userRedeemed;\n\n    if (amount > userOutstanding) {\n      amount = userOutstanding;\n    }\n\n    if (amount == 0) {\n      return 0;\n    }\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      return amount + maxProfit;\n    } \n\n    return fullReturn;\n  }",
        "VulnerabilityDesc": [
            {
                "Name": "return_13",
                "Location": "(,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);",
                "Type": "Wrong return values",
                "Description": "The getAuctionCore() function returns wrong values out of order, leading to potential loss of user funds.",
                "Repair": "Add a missing comma in the function calls to getAuctionCore() to ensure the correct return values are used"
            }
        ]
    },
    {
        "Code": " function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "return_14",
                "Location": "CTokenInterface(token).approve(spender, type(uint256).max);",
                "Type": "ERC20 missing return value check",
                "Description": "The enableToken function performs an ERC20.approve() call but does not check the success return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens"
            }
        ]
    },
    {
        "Code": "function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "return_15",
                "Location": "bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);",
                "Type": "ERC20 return values not checked",
                "Description": "Some tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a success boolean.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens"
            }
        ]
    },
    {
        "Code": "\nfunction _payoutToken(address tokenAddress) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    ERC20 erc20 = ERC20(tokenAddress);\n    uint256 balance = erc20.balanceOf(address(this));\n    require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n    uint256 sending;\n    //uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n      // sent = sent + sending;\n    }\n  }\n\nfunction _payoutTokens(address[] memory tokenAddresses) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    ERC20 erc20;\n    uint256 balance;\n    uint256 sending;\n    for (uint256 t = 0; t < tokenAddresses.length; t++) {\n      erc20 = ERC20(tokenAddresses[t]);\n      balance = erc20.balanceOf(address(this));\n      require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n      // uint256 sent;\n      for (uint256 i = 0; i < addresses.length; i++) {\n        sending = ((bps[i] * balance) / 10000);\n        require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n        // sent = sent + sending;\n      }\n    }\n  }",
        "VulnerabilityDesc": [
            {
                "Name": "return_16",
                "Location": "require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");",
                "Type": "missing return value check",
                "Description": "_payoutToken is blocked and tokens are stuck in contract.",
                "Repair": "Use OpenZeppelin's SafeERC20, which handles the return value check as well as non-standard-compliant tokens."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./Create2BeaconMaker.sol\";\nlibrary BeaconProxyDeployer {\n    function deploy(address beacon, bytes memory initializationCalldata)\n        internal\n        returns (address result)\n    {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n        bytes32 salt = bytes32(0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(\n        address deployer,\n        address beacon,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n\n        bytes32 salt = bytes32(0);\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(createCode);\n        addr = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            deployer, // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "return_17",
                "Location": "if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }",
                "Type": "Improper Validation Of create2 Return Value",
                "Description": "The function does not revert properly if there is a failed contract deployment or revert from the create2 opcode as it does not properly check the returned address for bytecode.",
                "Repair": "Update iszero(result) to iszero(extcodesize(result)) in the line mentioned above."
            }
        ]
    },
    {
        "Code": "/// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "return_18",
                "Location": "ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );",
                "Type": "missing return value check",
                "Description": "The setToken function performs an ERC20.approve() call but does not check the success return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeSend(address payable recipient, uint256 amount) public { recipient.call{value: amount}(\"\"); }}",
        "VulnerabilityDesc": [
            {
                "Name": "return_19",
                "Location": "unsafeSend function",
                "Type": "unchecked return",
                "Description": "The return value of 'call' is not checked, which may lead to unintended behavior. If the call fails (for example, if the recipient contract throws an exception), the current contract will not be aware of this and will continue execution.",
                "Repair": "Always handle the return value of 'call'. In case of failure, you might want to revert the transaction to prevent further execution with inconsistent state."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeTransfer(address payable recipient, uint256 amount, address payable token) public { IERC20(token).transfer(recipient, amount); } }",
        "VulnerabilityDesc": [
            {
                "Name": "return_20",
                "Location": "unsafeTransfer function",
                "Type": "unchecked return",
                "Description": "The 'unsafeTransfer' function attempts to transfer ERC20 tokens using the 'transfer' method of the IERC20 interface, but it doesn't check the return value. If the 'transfer' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the 'transfer' call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeTransfer(address payable recipient, uint256 amount, address payable token) public { IERC20(token).transfer(recipient, amount); } }",
        "VulnerabilityDesc": [
            {
                "Name": "return_21",
                "Location": "unsafeTransfer function",
                "Type": "unchecked return",
                "Description": "The 'unsafeTransfer' function attempts to transfer ERC20 tokens using the 'transfer' method of the IERC20 interface, but it doesn't check the return value. If the 'transfer' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the 'transfer' call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeAllowance(address token, address owner, address spender) public { IERC20(token).allowance(owner, spender); } }",
        "VulnerabilityDesc": [
            {
                "Name": "return_22",
                "Location": "unsafeAllowance function",
                "Type": "unchecked return",
                "Description": "The 'unsafeAllowance' function attempts to check the amount of tokens that an owner allowed to a spender, using the 'allowance' method of the IERC20 interface. However, it doesn't use or check the return value. If the 'allowance' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Use the return value of the 'allowance' call and check it. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; contract Vulnerable is ERC721 { constructor() ERC721('Token', 'TKN') {} function unsafeMint(address to, uint256 tokenId) public { _mint(to, tokenId); } }",
        "VulnerabilityDesc": [
            {
                "Name": "return_23",
                "Location": "unsafeMint function",
                "Type": "unchecked return",
                "Description": "The 'unsafeMint' function attempts to mint an ERC721 token using the '_mint' method of the ERC721 contract, but it doesn't check the return value. If the '_mint' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "In case of the OpenZeppelin's ERC721 contract, the '_mint' function does not return a value. However, it can revert the transaction if the minting operation fails. Therefore, it's important to handle potential reverts or exceptions correctly in the code calling this function."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; contract Vulnerable is ERC721 { constructor() ERC721('Token', 'TKN') {} function unsafeTransferFrom(address from, address to, uint256 tokenId) public { _transfer(from, to, tokenId); } }",
        "VulnerabilityDesc": [
            {
                "Name": "return_24",
                "Location": "unsafeTransferFrom function",
                "Type": "unchecked return",
                "Description": "The 'unsafeTransferFrom' function attempts to transfer an ERC721 token from one address to another using the '_transfer' method of the ERC721 contract, but it doesn't check the return value. If the '_transfer' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "In case of the OpenZeppelin's ERC721 contract, the '_transfer' function does not return a value. However, it can revert the transaction if the transfer operation fails. Therefore, it's important to handle potential reverts or exceptions correctly in the code calling this function."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; contract Vulnerable { function unsafeBurn(address token, address account, uint256 amount) public { IERC20(token).burnFrom(account, amount); } }",
        "VulnerabilityDesc": [
            {
                "Name": "return_25",
                "Location": "unsafeBurn function",
                "Type": "unchecked return",
                "Description": "The 'unsafeBurn' function attempts to burn tokens from a specific account using the 'burnFrom' method of the IERC20 interface, but it doesn't check the return value. If the 'burnFrom' call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the 'burnFrom' call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeLowLevelCall(address payable recipient) public { recipient.call(''); } }",
        "VulnerabilityDesc": [
            {
                "Name": "return_26",
                "Location": "unsafeLowLevelCall function",
                "Type": "unchecked return",
                "Description": "The 'unsafeLowLevelCall' function attempts a low-level call to a contract, but it doesn't check the return value. If the low-level call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the low-level call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Vulnerable { function unsafeDelegateCall(address target, bytes memory data) public { target.delegatecall(data); } }",
        "VulnerabilityDesc": [
            {
                "Name": "return_27",
                "Location": "unsafeDelegateCall function",
                "Type": "unchecked return",
                "Description": "The 'unsafeDelegateCall' function attempts a delegate call to a target contract, but it doesn't check the return value. If the delegate call fails, the contract execution continues, potentially leading to unexpected behavior.",
                "Repair": "Check the return value of the delegate call. If the call fails, revert the transaction to prevent potential issues."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.transferFrom(msg.sender, recipient, _amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "return_28",
                "Location": "_handlePayment function",
                "Type": "Not handling return value",
                "Description": "Not handling return value of transferFrom command can create inconsistency",
                "Repair": "Add a require statement to check the return value of transferFrom command"
            }
        ]
    }

]