[
    {
        "Code": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.7;\n\nimport \"./libs/SignatureValidatorV2.sol\";\n\ncontract Identity {\n\tmapping (address => bytes32) public privileges;\n\t// The next allowed nonce\n\tuint public nonce = 0;\n\n\t// Events\n\tevent LogPrivilegeChanged(address indexed addr, bytes32 priv);\n\tevent LogErr(address indexed to, uint value, bytes data, bytes returnData); // only used in tryCatch\n\n\t// Transaction structure\n\t// we handle replay protection separately by requiring (address(this), chainID, nonce) as part of the sig\n\tstruct Transaction {\n\t\taddress to;\n\t\tuint value;\n\t\tbytes data;\n\t}\n\n\tconstructor(address[] memory addrs) {\n\t\tuint len = addrs.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\t// @TODO should we allow setting to any arb value here?\n\t\t\tprivileges[addrs[i]] = bytes32(uint(1));\n\t\t\temit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));\n\t\t}\n\t}\n\n\t// This contract can accept ETH without calldata\n\treceive() external payable {}\n\n\t// This contract can accept ETH with calldata\n\t// However, to support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature\n\tfallback() external payable {\n\t\tbytes4 method = msg.sig;\n\t\tif (\n\t\t\tmethod == 0x150b7a02 // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\t|| method == 0xf23a6e61 // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n\t\t\t\t|| method == 0xbc197c81 // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n\t\t) {\n\t\t\t// Copy back the method\n\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\tassembly {\n\t\t\t\tcalldatacopy(0, 0, 0x04)\n\t\t\t\treturn (0, 0x20)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setAddrPrivilege(address addr, bytes32 priv)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t// Anti-bricking measure: if the privileges slot is used for special data (not 0x01),\n\t\t// don't allow to set it to true\n\t\tif (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))\n\t\t\trequire(priv != bytes32(uint(1)), 'UNSETTING_SPECIAL_DATA');\n\t\tprivileges[addr] = priv;\n\t\temit LogPrivilegeChanged(addr, priv);\n\t}\n\n\tfunction tipMiner(uint amount)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t// See https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment/#managing-payments-to-coinbaseaddress-when-it-is-a-contract\n\t\t// generally this contract is reentrancy proof cause of the nonce\n\t\texecuteCall(block.coinbase, amount, new bytes(0));\n\t}\n\n\tfunction tryCatch(address to, uint value, bytes calldata data)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\n\t\tif (!success) emit LogErr(to, value, data, returnData);\n\t}\n\n\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction execute(Transaction[] calldata txns, bytes calldata signature)\n\t\texternal\n\t{\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\n\t\t// there is a discrepancy between ethereumjs-abi and solidity\n\t\t// @TODO check if this is resolved\n\t\tuint currentNonce = nonce;\n\t\t// NOTE: abi.encode is safer than abi.encodePacked in terms of collision safety\n\t\tbytes32 hash = keccak256(abi.encode(address(this), block.chainid, currentNonce, txns));\n\t\t// We have to increment before execution cause it protects from reentrancies\n\t\tnonce = currentNonce + 1;\n\n\t\taddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\n\t\trequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// The actual anti-bricking mechanism - do not allow a signer to drop their own priviledges\n\t\trequire(privileges[signer] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t// no need for nonce management here cause we're not dealing with sigs\n\tfunction executeBySender(Transaction[] calldata txns) external {\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\trequire(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// again, anti-bricking\n\t\trequire(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\n\t// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\n\t// there's also\n\t// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce\n\t// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\n\t// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol\n\tfunction executeCall(address to, uint256 value, bytes memory data)\n\t\tinternal\n\t{\n\t\tassembly {\n\t\t\tlet result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n\n\t\t\tswitch result case 0 {\n\t\t\t\tlet size := returndatasize()\n\t\t\t\tlet ptr := mload(0x40)\n\t\t\t\treturndatacopy(ptr, 0, size)\n\t\t\t\trevert(ptr, size)\n\t\t\t}\n\t\t\tdefault {}\n\t\t}\n\t\t// A single call consumes around 477 more gas with the pure solidity version, for whatever reason\n\t\t//(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\n\t\t//if (!success) revert(string(data));\n\t}\n\n\t// EIP 1271 implementation\n\t// see https://eips.ethereum.org/EIPS/eip-1271\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\n\t\tif (privileges[SignatureValidator.recoverAddr(hash, signature)] != bytes32(0)) {\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n\t\t\treturn 0x1626ba7e;\n\t\t} else {\n\t\t\treturn 0xffffffff;\n\t\t}\n\t}\n\n\t// EIP 1155 implementation\n\t// we pretty much only need to signal that we support the interface for 165, but for 1155 we also need the fallback function\n\tfunction supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n\t\treturn\n\t\t\tinterfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).\n\t\t\tinterfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^ bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\n\t}\n}\n\n\n",
        "CodeNames": [
            "Identity.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "sol#L",
                    "privileges[",
                    "addrs[i]",
                    "execute()",
                    "recoverAddrImpl"
                ],
                "Type": " Prevent execution with invalid signatures",
                "Description": "\nSuppose one of the supplied addrs[i] to the constructor of Identity.sol happens to be 0 ( by accident).\n\nIn that case: privileges[0] = 1\n\nNow suppose you call execute() with an invalid signature, then recoverAddrImpl will return a value of 0 and thus signer=0.\nIf you then check \"privileges[signer] !=0\"  this will be true and anyone can perform any transaction.\n\nThis is clearly an unwanted situation.\n\n  Identity.sol#L23 L30(https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30)\n  Identity.sol#L97 L98(https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98)\n\n",
                "Repair": "In the constructor of Identity.sol, add in the for loop the following:\n\nsolidity\nrequire (addrs[i] !=0,\"Zero not allowed\");\n\n\nIvshti (Ambire) confirmed(https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946844237):\n\nIvshti (Ambire) patched(https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946894869):\n  resolved in https://github.com/AmbireTech/adex-protocol-eth/commit/08d050676773fcdf7ec1c4eb53d51820b7e42534\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948088151):\n  This seems to be the risk of having erecover returning zero, any invalid signature ends up being usable from any address to execute arbitrary logic.\n\n Mitigation can be achieved by either reverting when about to return address(0), which the sponsor has used for mitigation\n\n The other mitigation is to ensure that an account with address(0) cannot have privileges set to 1\n\n I believe mitigation from sponsor to be sufficient, however I'd recommend adding a check against having address(0) in the constructor for Identity.sol just to be sure\n\n\nIvshti (Ambire) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948276331):\n  @GalloDeSballo an extra check is superfluous IMO, not only cause the revert on 0 in SIgnatureValidatorV2 guarantees that this is fixed, but also because it has to be in three places: constructor, setAddrPrivilege and the account creation system in js/IdentityProxyDeploy which rolls out bytecode that sstores privileges directly\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.7;\n\nimport \"../Identity.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract QuickAccManager {\n\t// Note: nonces are scoped by identity rather than by accHash - the reason for this is that there's no reason to scope them by accHash,\n\t// we merely need them for replay protection\n\tmapping (address => uint) nonces;\n\tmapping (bytes32 => uint) scheduled;\n\n\tbytes4 immutable CANCEL_PREFIX = 0xc47c3100;\n\n\t// Events\n\t// we only need those for timelocked stuff so we can show scheduled txns to the user; the oens that get executed immediately do not need logs\n\tevent LogScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint nonce, uint time, Identity.Transaction[] txns);\n\tevent LogCancelled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint time);\n\tevent LogExecScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, uint time);\n\n\t// EIP 2612\n\tbytes32 public DOMAIN_SEPARATOR;\n\tconstructor() {\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tkeccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n\t\t\t\t// @TODO: maybe we should use a more user friendly name here?\n\t\t\t\tkeccak256(bytes('QuickAccManager')),\n\t\t\t\tkeccak256(bytes('1')),\n\t\t\t\tblock.chainid,\n\t\t\t\taddress(this)\n\t\t\t)\n\t\t);\n\t}\n\n\tstruct QuickAccount {\n\t\tuint timelock;\n\t\taddress one;\n\t\taddress two;\n\t\t// We decided to not allow certain options here such as ability to skip the second sig for send(), but leaving this a struct rather than a tuple\n\t\t// for clarity and to ensure it's future proof\n\t}\n\tstruct DualSig {\n\t\tbool isBothSigned;\n\t\tbytes one;\n\t\tbytes two;\n\t}\n\n\t// NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]\n\t// this is by design\n\n\t// isBothSigned is hashed in so that we don't allow signatures from two-sig txns to be reused for single sig txns,\n\t// ...potentially frontrunning a normal two-sig transaction and making it wait\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {\n\t\tbytes32 accHash = keccak256(abi.encode(acc));\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\t\tuint initialNonce = nonces[address(identity)];\n\t\t// Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs\n\t\tbytes32 hash = keccak256(abi.encode(\n\t\t\taddress(this),\n\t\t\tblock.chainid,\n\t\t\taccHash,\n\t\t\tnonces[address(identity)]++,\n\t\t\ttxns,\n\t\t\tsigs.isBothSigned\n\t\t));\n\t\tif (sigs.isBothSigned) {\n\t\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigs.one), 'SIG_ONE');\n\t\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigs.two), 'SIG_TWO');\n\t\t\tidentity.executeBySender(txns);\n\t\t} else {\n\t\t\taddress signer = SignatureValidator.recoverAddr(hash, sigs.one);\n\t\t\trequire(acc.one == signer || acc.two == signer, 'SIG');\n\t\t\t// no need to check whether `scheduled[hash]` is already set here cause of the incrementing nonce\n\t\t\tscheduled[hash] = block.timestamp + acc.timelock;\n\t\t\temit LogScheduled(hash, accHash, signer, initialNonce, block.timestamp, txns);\n\t\t}\n\t}\n\n\tfunction cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {\n\t\tbytes32 accHash = keccak256(abi.encode(acc));\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\n\t\tbytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));\n\t\taddress signer = SignatureValidator.recoverAddr(hash, sig);\n\t\trequire(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');\n\n\t\t// @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief\n\t\t// opportunity: someone wants to cancel post-maturity, and you front them with execScheduled\n\t\tbytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));\n\t\trequire(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');\n\t\tdelete scheduled[hashTx];\n\n\t\temit LogCancelled(hashTx, accHash, signer, block.timestamp);\n\t}\n\n\tfunction execScheduled(Identity identity, bytes32 accHash, uint nonce, Identity.Transaction[] calldata txns) external {\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\n\t\tbytes32 hash = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false));\n\t\trequire(scheduled[hash] != 0 && block.timestamp >= scheduled[hash], 'NOT_TIME');\n\t\tdelete scheduled[hash];\n\t\tidentity.executeBySender(txns);\n\n\t\temit LogExecScheduled(hash, accHash, block.timestamp);\n\t}\n\n\t// EIP 1271 implementation\n\t// see https://eips.ethereum.org/EIPS/eip-1271\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\n\t\t(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));\n\t\tbytes32 accHash = keccak256(abi.encode(QuickAccount({\n\t\t\ttimelock: timelock,\n\t\t\tone: SignatureValidator.recoverAddr(hash, sig1),\n\t\t\ttwo: SignatureValidator.recoverAddr(hash, sig2)\n\t\t})));\n\t\tif (Identity(id).privileges(address(this)) == accHash) {\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n\t\t\treturn 0x1626ba7e;\n\t\t} else {\n\t\t\treturn 0xffffffff;\n\t\t}\n\t}\n\n\t// EIP 712 methods\n\t// all of the following are 2/2 only\n\tbytes32 private TRANSFER_TYPEHASH = keccak256('Transfer(address tokenAddr,address to,uint256 value,uint256 fee,uint256 nonce)');\n\tstruct Transfer { address token; address to; uint amount; uint fee; }\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction sendTransfer(Identity identity, QuickAccount calldata acc, bytes calldata sigOne, bytes calldata sigTwo, Transfer calldata t) external {\n\t\trequire(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');\n\n\t\tbytes32 hash = keccak256(abi.encodePacked(\n\t\t\t'\\x19\\x01',\n\t\t\tDOMAIN_SEPARATOR,\n\t\t\tkeccak256(abi.encode(TRANSFER_TYPEHASH, t.token, t.to, t.amount, t.fee, nonces[address(identity)]++))\n\t\t));\n\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigOne), 'SIG_ONE');\n\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigTwo), 'SIG_TWO');\n\t\tIdentity.Transaction[] memory txns = new Identity.Transaction[](2);\n\t\ttxns[0].to = t.token;\n\t\ttxns[0].data = abi.encodeWithSelector(IERC20.transfer.selector, t.to, t.amount);\n\t\ttxns[1].to = t.token;\n\t\ttxns[1].data = abi.encodeWithSelector(IERC20.transfer.selector, msg.sender, t.fee);\n\t\tidentity.executeBySender(txns);\n\t}\n\n\t// Reference for arrays: https://github.com/sportx-bet/smart-contracts/blob/e36965a0c4748bf73ae15ed3cab5660c9cf722e1/contracts/impl/trading/EIP712FillHasher.sol\n\t// and https://eips.ethereum.org/EIPS/eip-712\n\t// and for signTypedData_v4: https://gist.github.com/danfinlay/750ce1e165a75e1c3387ec38cf452b71\n\tstruct Txn { string description; address to; uint value; bytes data; }\n\tbytes32 private TXNS_TYPEHASH = keccak256('Txn(string description,address to,uint256 value,bytes data)');\n\tbytes32 private BUNDLE_TYPEHASH = keccak256('Bundle(uint256 nonce,Txn[] transactions)');\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction sendTxns(Identity identity, QuickAccount calldata acc, bytes calldata sigOne, bytes calldata sigTwo, Txn[] calldata txns) external {\n\t\trequire(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');\n\n\t\t// hashing + prepping args\n\t\tbytes32[] memory txnBytes = new bytes32[](txns.length);\n\t\tIdentity.Transaction[] memory identityTxns = new Identity.Transaction[](txns.length);\n\t\tfor (uint256 i = 0; i < txns.length; i++) {\n\t\t\ttxnBytes[i] = keccak256(abi.encode(TXNS_TYPEHASH, txns[i].description, txns[i].to, txns[i].value, txns[i].data));\n\t\t\tidentityTxns[i].to = txns[i].to;\n\t\t\tidentityTxns[i].value = txns[i].value;\n\t\t\tidentityTxns[i].data = txns[i].data;\n\t\t}\n\t\tbytes32 txnsHash = keccak256(abi.encodePacked(txnBytes));\n\t\tbytes32 hash = keccak256(abi.encodePacked(\n\t\t\t'\\x19\\x01',\n\t\t\tDOMAIN_SEPARATOR,\n\t\t\tkeccak256(abi.encode(BUNDLE_TYPEHASH, nonces[address(identity)]++, txnsHash))\n\t\t));\n\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigOne), 'SIG_ONE');\n\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigTwo), 'SIG_TWO');\n\t\tidentity.executeBySender(identityTxns);\n\t}\n\n}\n\n\n",
        "CodeNames": [
            "QuickAccManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {\n  bytes32 accHash = keccak256(abi.encode(acc));\n  require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\n  bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));\n  address signer = SignatureValidator.recoverAddr(hash, sig);\n  require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');\n\n  // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief\n  // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled\n  bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));\n  require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');\n  delete scheduled[hashTx];\n\n  emit LogCancelled(hashTx, accHash, signer, block.timestamp);\n}\n"
                ],
                "Type": "  QuickAccManager.sol#cancel()  Wrong  hashTx  makes it impossible to cancel a scheduled transaction",
                "Description": "\nIn QuickAccManager.sol#cancel(), the hashTx to identify the transaction to be canceled is wrong. The last parameter is missing.\n\nAs a result, users will be unable to cancel a scheduled transaction.\n\n QuickAccManager.sol#L91 L91(https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91)\nsolidity\nfunction cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {\n  bytes32 accHash = keccak256(abi.encode(acc));\n  require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\n  bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));\n  address signer = SignatureValidator.recoverAddr(hash, sig);\n  require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');\n\n  // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief\n  // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled\n  bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));\n  require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');\n  delete scheduled[hashTx];\n\n  emit LogCancelled(hashTx, accHash, signer, block.timestamp);\n}\n\n\n",
                "Repair": "Change to:\n\nsolidity\nbytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false));\n\n\nIvshti (Ambire) confirmed and resolved(https://github.com/code-423n4/2021-10-ambire-findings/issues/1#issuecomment-946823825):\n  Great find, resolved in https://github.com/AmbireTech/adex-protocol-eth/commit/5c5e6f0cb47e83793dafc08630577b93500c86ab\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/1#issuecomment-950416817):\n  The warden has found that the method cancel was calculating the wrong hashTx, this hash, used to verify which transaction to cancel, making it impossible to cancel a transaction.\n\n The sponsor has mitigated in a  subsequent pr\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.7;\n\nimport \"./libs/SignatureValidatorV2.sol\";\n\ncontract Identity {\n\tmapping (address => bytes32) public privileges;\n\t// The next allowed nonce\n\tuint public nonce = 0;\n\n\t// Events\n\tevent LogPrivilegeChanged(address indexed addr, bytes32 priv);\n\tevent LogErr(address indexed to, uint value, bytes data, bytes returnData); // only used in tryCatch\n\n\t// Transaction structure\n\t// we handle replay protection separately by requiring (address(this), chainID, nonce) as part of the sig\n\tstruct Transaction {\n\t\taddress to;\n\t\tuint value;\n\t\tbytes data;\n\t}\n\n\tconstructor(address[] memory addrs) {\n\t\tuint len = addrs.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\t// @TODO should we allow setting to any arb value here?\n\t\t\tprivileges[addrs[i]] = bytes32(uint(1));\n\t\t\temit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));\n\t\t}\n\t}\n\n\t// This contract can accept ETH without calldata\n\treceive() external payable {}\n\n\t// This contract can accept ETH with calldata\n\t// However, to support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature\n\tfallback() external payable {\n\t\tbytes4 method = msg.sig;\n\t\tif (\n\t\t\tmethod == 0x150b7a02 // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\t|| method == 0xf23a6e61 // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n\t\t\t\t|| method == 0xbc197c81 // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n\t\t) {\n\t\t\t// Copy back the method\n\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\tassembly {\n\t\t\t\tcalldatacopy(0, 0, 0x04)\n\t\t\t\treturn (0, 0x20)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setAddrPrivilege(address addr, bytes32 priv)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t// Anti-bricking measure: if the privileges slot is used for special data (not 0x01),\n\t\t// don't allow to set it to true\n\t\tif (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))\n\t\t\trequire(priv != bytes32(uint(1)), 'UNSETTING_SPECIAL_DATA');\n\t\tprivileges[addr] = priv;\n\t\temit LogPrivilegeChanged(addr, priv);\n\t}\n\n\tfunction tipMiner(uint amount)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t// See https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment/#managing-payments-to-coinbaseaddress-when-it-is-a-contract\n\t\t// generally this contract is reentrancy proof cause of the nonce\n\t\texecuteCall(block.coinbase, amount, new bytes(0));\n\t}\n\n\tfunction tryCatch(address to, uint value, bytes calldata data)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\n\t\tif (!success) emit LogErr(to, value, data, returnData);\n\t}\n\n\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction execute(Transaction[] calldata txns, bytes calldata signature)\n\t\texternal\n\t{\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\n\t\t// there is a discrepancy between ethereumjs-abi and solidity\n\t\t// @TODO check if this is resolved\n\t\tuint currentNonce = nonce;\n\t\t// NOTE: abi.encode is safer than abi.encodePacked in terms of collision safety\n\t\tbytes32 hash = keccak256(abi.encode(address(this), block.chainid, currentNonce, txns));\n\t\t// We have to increment before execution cause it protects from reentrancies\n\t\tnonce = currentNonce + 1;\n\n\t\taddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\n\t\trequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// The actual anti-bricking mechanism - do not allow a signer to drop their own priviledges\n\t\trequire(privileges[signer] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t// no need for nonce management here cause we're not dealing with sigs\n\tfunction executeBySender(Transaction[] calldata txns) external {\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\trequire(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// again, anti-bricking\n\t\trequire(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\n\t// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\n\t// there's also\n\t// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce\n\t// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\n\t// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol\n\tfunction executeCall(address to, uint256 value, bytes memory data)\n\t\tinternal\n\t{\n\t\tassembly {\n\t\t\tlet result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n\n\t\t\tswitch result case 0 {\n\t\t\t\tlet size := returndatasize()\n\t\t\t\tlet ptr := mload(0x40)\n\t\t\t\treturndatacopy(ptr, 0, size)\n\t\t\t\trevert(ptr, size)\n\t\t\t}\n\t\t\tdefault {}\n\t\t}\n\t\t// A single call consumes around 477 more gas with the pure solidity version, for whatever reason\n\t\t//(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\n\t\t//if (!success) revert(string(data));\n\t}\n\n\t// EIP 1271 implementation\n\t// see https://eips.ethereum.org/EIPS/eip-1271\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\n\t\tif (privileges[SignatureValidator.recoverAddr(hash, signature)] != bytes32(0)) {\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n\t\t\treturn 0x1626ba7e;\n\t\t} else {\n\t\t\treturn 0xffffffff;\n\t\t}\n\t}\n\n\t// EIP 1155 implementation\n\t// we pretty much only need to signal that we support the interface for 165, but for 1155 we also need the fallback function\n\tfunction supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n\t\treturn\n\t\t\tinterfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).\n\t\t\tinterfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^ bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\n\t}\n}\n\n\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.7;\n\nimport \"../Identity.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract QuickAccManager {\n\t// Note: nonces are scoped by identity rather than by accHash - the reason for this is that there's no reason to scope them by accHash,\n\t// we merely need them for replay protection\n\tmapping (address => uint) nonces;\n\tmapping (bytes32 => uint) scheduled;\n\n\tbytes4 immutable CANCEL_PREFIX = 0xc47c3100;\n\n\t// Events\n\t// we only need those for timelocked stuff so we can show scheduled txns to the user; the oens that get executed immediately do not need logs\n\tevent LogScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint nonce, uint time, Identity.Transaction[] txns);\n\tevent LogCancelled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint time);\n\tevent LogExecScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, uint time);\n\n\t// EIP 2612\n\tbytes32 public DOMAIN_SEPARATOR;\n\tconstructor() {\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tkeccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n\t\t\t\t// @TODO: maybe we should use a more user friendly name here?\n\t\t\t\tkeccak256(bytes('QuickAccManager')),\n\t\t\t\tkeccak256(bytes('1')),\n\t\t\t\tblock.chainid,\n\t\t\t\taddress(this)\n\t\t\t)\n\t\t);\n\t}\n\n\tstruct QuickAccount {\n\t\tuint timelock;\n\t\taddress one;\n\t\taddress two;\n\t\t// We decided to not allow certain options here such as ability to skip the second sig for send(), but leaving this a struct rather than a tuple\n\t\t// for clarity and to ensure it's future proof\n\t}\n\tstruct DualSig {\n\t\tbool isBothSigned;\n\t\tbytes one;\n\t\tbytes two;\n\t}\n\n\t// NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]\n\t// this is by design\n\n\t// isBothSigned is hashed in so that we don't allow signatures from two-sig txns to be reused for single sig txns,\n\t// ...potentially frontrunning a normal two-sig transaction and making it wait\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {\n\t\tbytes32 accHash = keccak256(abi.encode(acc));\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\t\tuint initialNonce = nonces[address(identity)];\n\t\t// Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs\n\t\tbytes32 hash = keccak256(abi.encode(\n\t\t\taddress(this),\n\t\t\tblock.chainid,\n\t\t\taccHash,\n\t\t\tnonces[address(identity)]++,\n\t\t\ttxns,\n\t\t\tsigs.isBothSigned\n\t\t));\n\t\tif (sigs.isBothSigned) {\n\t\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigs.one), 'SIG_ONE');\n\t\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigs.two), 'SIG_TWO');\n\t\t\tidentity.executeBySender(txns);\n\t\t} else {\n\t\t\taddress signer = SignatureValidator.recoverAddr(hash, sigs.one);\n\t\t\trequire(acc.one == signer || acc.two == signer, 'SIG');\n\t\t\t// no need to check whether `scheduled[hash]` is already set here cause of the incrementing nonce\n\t\t\tscheduled[hash] = block.timestamp + acc.timelock;\n\t\t\temit LogScheduled(hash, accHash, signer, initialNonce, block.timestamp, txns);\n\t\t}\n\t}\n\n\tfunction cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {\n\t\tbytes32 accHash = keccak256(abi.encode(acc));\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\n\t\tbytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));\n\t\taddress signer = SignatureValidator.recoverAddr(hash, sig);\n\t\trequire(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');\n\n\t\t// @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief\n\t\t// opportunity: someone wants to cancel post-maturity, and you front them with execScheduled\n\t\tbytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));\n\t\trequire(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');\n\t\tdelete scheduled[hashTx];\n\n\t\temit LogCancelled(hashTx, accHash, signer, block.timestamp);\n\t}\n\n\tfunction execScheduled(Identity identity, bytes32 accHash, uint nonce, Identity.Transaction[] calldata txns) external {\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\n\t\tbytes32 hash = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false));\n\t\trequire(scheduled[hash] != 0 && block.timestamp >= scheduled[hash], 'NOT_TIME');\n\t\tdelete scheduled[hash];\n\t\tidentity.executeBySender(txns);\n\n\t\temit LogExecScheduled(hash, accHash, block.timestamp);\n\t}\n\n\t// EIP 1271 implementation\n\t// see https://eips.ethereum.org/EIPS/eip-1271\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\n\t\t(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));\n\t\tbytes32 accHash = keccak256(abi.encode(QuickAccount({\n\t\t\ttimelock: timelock,\n\t\t\tone: SignatureValidator.recoverAddr(hash, sig1),\n\t\t\ttwo: SignatureValidator.recoverAddr(hash, sig2)\n\t\t})));\n\t\tif (Identity(id).privileges(address(this)) == accHash) {\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n\t\t\treturn 0x1626ba7e;\n\t\t} else {\n\t\t\treturn 0xffffffff;\n\t\t}\n\t}\n\n\t// EIP 712 methods\n\t// all of the following are 2/2 only\n\tbytes32 private TRANSFER_TYPEHASH = keccak256('Transfer(address tokenAddr,address to,uint256 value,uint256 fee,uint256 nonce)');\n\tstruct Transfer { address token; address to; uint amount; uint fee; }\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction sendTransfer(Identity identity, QuickAccount calldata acc, bytes calldata sigOne, bytes calldata sigTwo, Transfer calldata t) external {\n\t\trequire(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');\n\n\t\tbytes32 hash = keccak256(abi.encodePacked(\n\t\t\t'\\x19\\x01',\n\t\t\tDOMAIN_SEPARATOR,\n\t\t\tkeccak256(abi.encode(TRANSFER_TYPEHASH, t.token, t.to, t.amount, t.fee, nonces[address(identity)]++))\n\t\t));\n\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigOne), 'SIG_ONE');\n\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigTwo), 'SIG_TWO');\n\t\tIdentity.Transaction[] memory txns = new Identity.Transaction[](2);\n\t\ttxns[0].to = t.token;\n\t\ttxns[0].data = abi.encodeWithSelector(IERC20.transfer.selector, t.to, t.amount);\n\t\ttxns[1].to = t.token;\n\t\ttxns[1].data = abi.encodeWithSelector(IERC20.transfer.selector, msg.sender, t.fee);\n\t\tidentity.executeBySender(txns);\n\t}\n\n\t// Reference for arrays: https://github.com/sportx-bet/smart-contracts/blob/e36965a0c4748bf73ae15ed3cab5660c9cf722e1/contracts/impl/trading/EIP712FillHasher.sol\n\t// and https://eips.ethereum.org/EIPS/eip-712\n\t// and for signTypedData_v4: https://gist.github.com/danfinlay/750ce1e165a75e1c3387ec38cf452b71\n\tstruct Txn { string description; address to; uint value; bytes data; }\n\tbytes32 private TXNS_TYPEHASH = keccak256('Txn(string description,address to,uint256 value,bytes data)');\n\tbytes32 private BUNDLE_TYPEHASH = keccak256('Bundle(uint256 nonce,Txn[] transactions)');\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction sendTxns(Identity identity, QuickAccount calldata acc, bytes calldata sigOne, bytes calldata sigTwo, Txn[] calldata txns) external {\n\t\trequire(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');\n\n\t\t// hashing + prepping args\n\t\tbytes32[] memory txnBytes = new bytes32[](txns.length);\n\t\tIdentity.Transaction[] memory identityTxns = new Identity.Transaction[](txns.length);\n\t\tfor (uint256 i = 0; i < txns.length; i++) {\n\t\t\ttxnBytes[i] = keccak256(abi.encode(TXNS_TYPEHASH, txns[i].description, txns[i].to, txns[i].value, txns[i].data));\n\t\t\tidentityTxns[i].to = txns[i].to;\n\t\t\tidentityTxns[i].value = txns[i].value;\n\t\t\tidentityTxns[i].data = txns[i].data;\n\t\t}\n\t\tbytes32 txnsHash = keccak256(abi.encodePacked(txnBytes));\n\t\tbytes32 hash = keccak256(abi.encodePacked(\n\t\t\t'\\x19\\x01',\n\t\t\tDOMAIN_SEPARATOR,\n\t\t\tkeccak256(abi.encode(BUNDLE_TYPEHASH, nonces[address(identity)]++, txnsHash))\n\t\t));\n\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigOne), 'SIG_ONE');\n\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigTwo), 'SIG_TWO');\n\t\tidentity.executeBySender(identityTxns);\n\t}\n\n}\n\n\n",
        "CodeNames": [
            "Identity.sol",
            "QuickAccManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "send",
                    "QuickAccount",
                    "identity",
                    "hash"
                ],
                "Type": " Signature replay attacks for different identities (nonce on wrong party)",
                "Description": "\nA single QuickAccount can serve as the \"privilege\" for multiple identities, see the comment in QuickAccManager.sol:\n\n NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]. this is by design\n\nIf there exist two different identities that *both share the same QuickAccount* (identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash) the following attack is possible in QuickAccManager.send:\n\nUpon observing a valid send on the first identity, the same transactions can be replayed on the second identity by an attacker calling send with the same arguments and just changing the identity to the second identity.\n\nThis is because the identity is not part of the hash. Including the nonce of the identity in the hash is not enough.\n\nTwo fresh identities will both take on nonces on zero and lead to the same hash.\n\nTransactions on one identity can be replayed on another one if it uses the same QuickAccount.\nFor example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.\n\n",
                "Repair": "\n1.  Nonces should not be indexed by the identity but by the accHash. This is because nonces are used to stop replay attacks and thus need to be on the *signer* (QuickAccount in this case), not on the target contract to call.\n2.  The identity *address* itself needs to be part of hash as otherwise the send can be frontrun and executed by anyone on the other identity by switching out the identity parameter.\n\n#### Other occurrences\nThis issue of using the wrong nonce (on the identity which means the nonces repeat per identity) and not including identity address leads to other attacks throughout the QuickAccManager:\n\n*   cancel: attacker can use the same signature to cancel the same transactions on the second identity\n*   execScheduled: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as scheduled[hash] is deleted.\n*   sendTransfer: same transfers can be replayed on second identity\n*   sendTxns: same transactions can be replayed on second identity\n\n\nIvshti (Ambire) confirmed(https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-946825757):\n  duplicate of #24, but it's better documented\n\nIvshti (Ambire) patched(https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-946999413):\n  mitigation step 1 is not going to be done, since there's already plenty of upper level code relying on indexing by identity, and it doesn't really hurt if the replay attack is mitigated\n\n plus, it makes it harder to look up the nonce value, as we have to compute the accHash in the client-side code\n\n the replay attack has been fixed here https://github.com/AmbireTech/adex-protocol-eth/commit/f70ca38f368da30c9881d1ee5554fd0161c94486\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-950825823):\n  The warden identified a Signature Replay attack, allowing to re-use a signature throughout the system.\n\n Requiring the identity to be part of the signatures mitigates the vulnerability\n\n The sponsor has mitigated in a subsequent PR\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\naddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\n// signer will be QuickAccountContract\nrequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n",
                    "//solidity\n// @audit id is attacker-controlled\n(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));\n// @audit this may not be used for authorization, attacker can return desired value\nif (Identity(id).privileges(address(this)) == accHash) {\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n  return 0x1626ba7e;\n} else {\n  return 0xffffffff;\n}\n"
                ],
                "Type": "  QuickAccManager  Smart Contract signature verification can be exploited",
                "Description": "\nSeveral different signature modes can be used and Identity.execute forwards the signature parameter to the SignatureValidator library.\nThe returned signer is then used for the privileges check:\n\nsolidity\naddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\n// signer will be QuickAccountContract\nrequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\n\nIt's possible to create a smart contract mode signature (SignatureMode.SmartWallet) for arbitrary transactions as the QuickAccManager.isValidSignature uses an attacker-controlled id identity contract for the privileges check.\nAn attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:\n\nsolidity\n// @audit id is attacker-controlled\n(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));\n// @audit this may not be used for authorization, attacker can return desired value\nif (Identity(id).privileges(address(this)) == accHash) {\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n  return 0x1626ba7e;\n} else {\n  return 0xffffffff;\n}\n\n\nAssume an Identity contract is set up with a QuickAccManager as the privileges account, i.e. privileges[accHash] != 0.\n\nWe can construct a SignatureMode.SmartWallet signature for an *arbitrary* hash:\n\n1.  Call Identity.execute(txns, spoofedSignature) where spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)\n2.  This will call recoverAddrImpl(txnsHash, spoofedSignature, true), decode the bytes at the end of spoofedSignature and determine mode = SignatureMode.SmartWallet and wallet = quickAccountManager. It will cut off these arguments and call quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))\n3.  The QuickAccManager will decode the signature, construct accHash which is the hash of all zeroes (due to failed signatures returning 0). It will then call attacker.privileges(address(this)) and the attacker contract can return the accHash that matches an account hash of failed signatures, i.e., keccak256(abi.encode(QuickAccount(0,0,0))). The comparison is satisfied and it returns the success value.\n4.  The checks in Identity.execute pass and the transactions txns are executed.\n\nAny Identity contract using QuickAccManager can be exploited.\nFunds can then be stolen from the wallet.\n\n",
                "Repair": "The issue is that QuickAccManager blindly trusts the values in signature.\nIt might be enough to remove the id from the signature and use msg.sender as the identity instead: Identity(msg.sender).privileges(address(this)) == accHash.\nThis seems to work with the current Identity implementation but might not work if this is extended and the isValidSignature is called from another contract and wants to verify a signature on a different identity.\nIn that case, the Identity/SignatureValidator may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling QuickAccManager.\n\nIvshti (Ambire) confirmed and patched(https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-946828671):\n  great find! Mitigated in https://github.com/AmbireTech/adex-protocol-eth/commit/17c073d037ded76d56d6145faa92c1959fd47226 but still figuring out whether this is the best way to do it\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950840624):\n  May need to sit on this one for another day before I can fully comment\n\n Fundamentally by calling Identity.execute with mostly 0 data, you are able to call back to QuickAccManager. isValidSignature which, due to the implementation of ecrecover at the time, will return valid checks for address(0), allowing to bypass all the logic and returning true for the signature, allowing for the execution of arbitrary code.\n\n Again, need to sit on this one\n\n But wouldn't you also be able to set a malicious smartContractWallet as the IERC1271Wallet, hence you can sidestep the entire logic, as your malicious contract wallet can be programmed to always return true on any input value?\n\nIvshti (Ambire) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950849976):\n  @GalloDaSballo (judge) this doesn't have to do with address(0)\n\n Using smart wallets for signatures by itself is not a problem since they authorize as themselves.\n\n The fundamental root of this issue is that ERC 1271 was designed with the assumption that 1 contract = 1 wallet. And as such, isValidSignature only returns true/false. This makes sense, as essentially we're asking the wallet \"is this a valid signature from you\", and then the wallet decides how to actually validate this it depending on it's own behavior and permissions.\n\n However, the QuickAccManager is a singleton contract one single QuickAccManager represents multiple users. As such, combining it with ERC 1271 is a logical misunderstanding, as we can't really ask it \"is this a valid sig for X identity\" through the ERC 1271 interface. So instead, we encode the identity that we're signing as in the sig itself, but then a malicious user could call a top-level identity with a sig that validates in the singleton QuickAccManager, but meant to validate with a differerent identity.\n\n Because what we pass to isValidSignature is opaque data (the smart wallet may be any contract with any logic, not just our QuickAccManager) we can't just peak into the sig and see if it's meant to validate with the caller identity.\n\n Excellent finding IMO\n\n The current mitigation is hacky, and essentially leads to an isValidSignature implementation that is unusable (and doesn't make sense) off-chain, but we prefer it to introducing a new sig type especially for QuickAccManager.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950870846):\n  @Ivshti (Ambire) To clarify:\n Would adding privileges[QuickAccountManager] = bytes32(uint(1))enable the exploit?\n\nIvshti (Ambire) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950871925):\n  @GalloDaSballo (judge) yes, it would. Any authorized quickAcc would enable the exploit\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950906951):\n  I'm starting to get this\n\n The id sent to isValidSignature is an untrusted, unverified address\n The contract at that address can be programmed to have a function privileges which would return any bytes32 value to match accHash\n This effectively allows to run arbitrary transactions.\n\n A way to mitigate would be to have a way to ensure the called id is trusted\n A registry of trusted ids may be effective\n\n The mitigation the sponsor has chosen does solve for only using trusted Identities as in the case of a malicious Identity, the Identity would just validate it's own transaction, not putting other Identities funds at risk.\n\n An alternative solution would be to change theIdentityFactory to use the OpenZeppelin Clones Library (or similar) to ensure that the correct Logic is deployed (by deploying a minimal-proxy pointing to the trusted implementation).\n This would require a fair tech-lift and would limit the type of deployments that the IdentityFactory can perform.\n\n The exploit was severe and the sponsor has mitigated by checking the msg.sender against the id provided in the signature\n\n\n\n"
            }
        ]
    }
]