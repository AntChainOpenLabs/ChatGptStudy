[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport {IVault} from \"./vault/IVault.sol\";\nimport {IVaultSponsoring} from \"./vault/IVaultSponsoring.sol\";\nimport {PercentMath} from \"./lib/PercentMath.sol\";\nimport {Depositors} from \"./vault/Depositors.sol\";\nimport {Claimers} from \"./vault/Claimers.sol\";\nimport {IIntegration} from \"./integrations/IIntegration.sol\";\nimport {IStrategy} from \"./strategy/IStrategy.sol\";\nimport {ERC165Query} from \"./lib/ERC165Query.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * A vault where other accounts can deposit an underlying token\n * currency and set distribution params for their principal and yield\n *\n * @dev Yield generation strategies not yet implemented\n */\n\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nif (_force && sponsorAmount  totalUnderlying()) {\n    sponsorToTransfer = totalUnderlying();\n} else if (!_force) {\n    require(\n        sponsorToTransfer <= totalUnderlying(),\n        \"Vault: not enough funds to unsponsor\"\n    );\n}\n\ntotalSponsored -= sponsorAmount;\n\nunderlying.safeTransfer(_to, sponsorToTransfer);\n"
                ],
                "Type": "  forceUnsponsor()  may open a window for attackers to manipulate the  _totalShares  and freeze users' funds at a certain deposit amount",
                "Description": "\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L390-L401\n\nsolidity\nif (_force && sponsorAmount  totalUnderlying()) {\n    sponsorToTransfer = totalUnderlying();\n} else if (!_force) {\n    require(\n        sponsorToTransfer <= totalUnderlying(),\n        \"Vault: not enough funds to unsponsor\"\n    );\n}\n\ntotalSponsored -= sponsorAmount;\n\nunderlying.safeTransfer(_to, sponsorToTransfer);\n\n\nWhen sponsorAmount  totalUnderlying(), the contract will transfer totalUnderlying() to sponsorToTransfer, even if there are other depositors and totalShares  0.\n\nAfter that, and before others despoiting into the Vault, the Attacker can send 1 wei underlying token, then cal deposit() with 0.1 * 1e18 , since newShares  = (_amount * _totalShares) / _totalUnderlyingMinusSponsored and _totalUnderlyingMinusSponsored is 1, with a tiny amount of underlying token, newShares will become extremly large.\n\nAs we stated in issue #166(https://github.com/code-423n4/2022-01-sandclock-findings/issues/166), when the value of totalShares is manipulated precisely, the attacker can plant a bomb, and the contract will not work when the deposit/withdraw amount reaches a certain value, freezing the user's funds.\n\nHowever, this issue is not caused by lack of reentrancy protection, therefore it cant be solved by the same solution in issue #166(https://github.com/code-423n4/2022-01-sandclock-findings/issues/166).\n\n",
                "Repair": "\nConsider adding a minimum balance reserve (eg. 1e18 Wei) that cannot be withdrawn by anyone in any case. It can be transferred in alongside with the deployment by the deployer.\n\nThis should make it safe or at least make it extremely hard or expensive for the attacker to initiate such an attack.\n\nnaps62 (Sandclock) confirmed and commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/168#issuecomment-1012115367):\n  @gabrielpoca @ryuheimat is this new?\n\nryuheimat (Sandclock) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/168#issuecomment-1012116458):\n  it's new\n\ngabrielpoca (Sandclock) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/168#issuecomment-1012269148):\n  yap, it's interesting. The sponsor really is an issue\n\n\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "_totalUnderlyingMinusSponsored",
                    "onDepositBurned",
                    "deposit"
                ],
                "Type": " Withdrawers can get more value returned than expected with reentrant call",
                "Description": "\nThe impact of this is that users can get significantly more UST withdrawn than they would be alotted if they had done non-reentrant withdraw calls.\n\n\nHere's an outline of the attack:\n\nAssume the vault has 100 UST in it.\nThe attacker makes two deposits of 100UST and waits for them to be withdrawable.\nThe attacker triggers a withdraw one of their deposit positions.\nThe vault code executes until it reaches this point: <https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L565\nSince the attacker is the claimer, the vault will call back to the attacker.\nInside onDepositBurned, trigger another 100 UST deposit.\nSince claimers.onWithdraw has already been called, reducing the amount of shares, but the UST hasn't been transferred yet, the vault will compute the amount of UST to be withdrawn based on an unexpected value for _totalUnderlyingMinusSponsored (300).\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L618\n\nAfter the attack, the attacker will have significantly more than if they had withdrawn without reentrancy.\n\nHere's my proof of concept showing a very similar exploit with deposit, but I think it's enough to illustrate the point. I have a forge repo if you want to see it, just ping me on discord.\n<https://gist.github.com/CamdenClark/abc67bc1b387c15600549f6dfd5cb27a\n\n\nForge\n\n",
                "Repair": "\nReentrancy guards.\n\nAlso, consider simplifying some of the shares logic.\n\nryuheimat (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/32) \n\nnaps62 (Sandclock) resolved(https://github.com/code-423n4/2022-01-sandclock-findings/issues/32#issuecomment-1012049324):\n  Fixed in https://github.com/sandclock-org/solidity-contracts/pull/75\n\n\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "_createDeposit() = _createClaim()",
                    "deposit()",
                    "newShares"
                ],
                "Type": " deposit() function is open to reentrancy attacks",
                "Description": "\nIn Vault.sol the deposit() function is left wide open to reentrancy attacks.  The function eventually calls _createDeposit() = _createClaim() which calls depositors.mint() which will then mint an NFT.  When the NFT is minted the sender will receive a callback which can then be used to call the deposit() function again before execution is finished.  An attacker can do this minting multiple NFT's for themselves.  claimers.mint() is also called in the same function which can also be used to call back into the deposit function before execution is complete.  Since there are several state updates before and after NFT's are minted this can be used to further manipulate the protocol like with newShares which is called before minting.  This is not counting what an attacker can do with cross function reentrancy entering into several other protocol functions (like withdraw) before code execution is complete further manipulating the system.\n\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L160\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L470\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L476\n\n",
                "Repair": "\nReentrancy guard modifiers should be placed on the deposit(), withdraw() and all other important protocol functions to prevent devastating attacks.\n\nryuheimat (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/3)\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [
                    "sponsor()",
                    "mint()"
                ],
                "Type": " sponsor() function in open to reentrancy attacks",
                "Description": "\nIn Vault.sol the sponsor() function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender.  Since there are state updates after the call to depositors.mint() function this is especially dangerous.  An attacker can make it so the totalSponsored amount is only updated once after calling mint() several times since the update takes place after the callback.  The same will be true for the Sponsored event that is emitted.\n\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L244\n\n",
                "Repair": "\nA reentrancy guard modifier should be added to the sponsor() function in Vault.sol\n\nnaps62 (Sandclock) confirmed and resolved(https://github.com/code-423n4/2022-01-sandclock-findings/issues/4#issuecomment-1012049429):\n  Fixed in https://github.com/sandclock-org/solidity-contracts/pull/75\n\n\n\n \n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "totalShares",
                    "depositShares"
                ],
                "Type": " Late users will take more losses than expected when the underlying contract ( EthAnchor ) suffers investment losses",
                "Description": "\nEven though it's unlikely in practice, but in theory, the underlying contract (EthAnchor) may suffer investment losses and causing decreasing of the PPS of AUST token. (There are codes that considered this situation in the codebase. eg. handling of depositShares  claimerShares).\n\nHowever, when this happens, the late users will suffer more losses than expected than the users that withdraw earlier. The last few users may lose all their funds while the first users can get back 100% of their deposits.\n\n\n    // ### for deposits: d1, d2, d3, the beneficiary are: c1, c2, c2\n        depositAmount          claimerShares\n    d1: + 100e18           c1: + 100e36\n    d2: + 100e18           c2: + 100e36\n    d3: + 100e18           c2: + 100e36\n\n    depositAmount of d1, d2, d3 = 100e18\n    c1 claimerShares: 100e36\n    c2 claimerShares: 200e36\n    total shares: 300e36\n\n\n    // ### when the PPS of AUST drop by 50% \n    totalUnderlyingMinusSponsored: 300e18 - 150e18\n\n    // ### d2 withdraw\n    c2 claimerShares: 200e36\n    d2 depositAmount: 100e18\n    d2 depositShares: 300e36 * 100e18 / 150e18 = 200e36\n\n    Shares to reduce: 200e36\n    c2 claimerShares: 200e36 - 0\n    c2 totalPrincipal: 200e18 - 100e18\n    totalShares: 300e36 - 100e36\n\n    underlying.safeTransfer(d2, 100e18)\n    totalUnderlyingMinusSponsored: 150e18 - 50e18\n\n\nWhen the strategy is losing money, share / underlying increases, therefore the computed depositShares: depositAmount * share / underlying will increase unexpectedly.\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L544-L548\n\nWhile totalShares remain unchanged, but the computed depositShares is increasing, causing distortion of depositShares / totalShares, eg, \u2211 depositShares  totalShares.\n\n",
                "Repair": "\nIn order to properly handle the investment loss of the strategy, consider adding a new storage variable called totalLoss to maintain a stable value of share / adjustedUnderlying.\n\nsolidity\nadjustedUnderlying = underlying + totalLoss\n\n\nCrisBRM (Sandclock) confirmed and disagreed with severity(https://github.com/code-423n4/2022-01-sandclock-findings/issues/156)\n\ndmvt (judge) changed severity and commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/156#issuecomment-1023095624):\n  This is a classic medium risk when using the definition provided by Code4rena:\n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "depositAmount"
                ],
                "Type": "  NonUSTStrategy.sol  Improper handling of swap fees allows attacker to steal funds from other users",
                "Description": "\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/strategy/NonUSTStrategy.sol#L66-L69\n\nNonUSTStrategy will swap the deposited non-UST assets into UST before depositing to EthAnchor. However, the swap fee is not attributed to the depositor correctly like many other yield farming vaults involving swaps (ZapIn).\n\nAn attacker can exploit it for the swap fees paid by other users by taking a majority share of the liquidity pool.\n\n\nThe swap fee of depositing is not paid by the depositor but evenly distributed among all users.\n\n\nGiven:\n\n*   A NonUST vault and strategy is created for FRAX;\n*   The liquidity in FRAX-UST curve pool is relatively small (<$1M).\n\nThe attacker can do the following:\n\n1.  Add $1M worth of liquidity to the FRAX-UST curve pool, get 50% share of the pool;\n2.  Deposit 1M FRAX to the vault, get a depositAmount of 1M;\n3.  The strategy will swap 1M FRAX to UST via the curve pool, paying a certain amount of swap fee;\n4.  Withdraw all the funds from the vault.\n5.  Remove the liquidity added in step 1, profit from the swap fee. (A majority portion of the swap fee paid in step 3 can be retrieved by the attacker as the attacker is the majority liquidity provider.)\n\nIf the vault happens to have enough balance (from a recent depositor), the attacker can now receive 1M of FRAX.\n\nA more associated attacker may combine this with issue #160(https://github.com/code-423n4/2022-01-sandclock-findings/issues/160) and initiate a sandwich attack in step 3 to get even higher profits.\n\nAs a result, all other users will suffer fund loss as the swap fee is essentially covered by other users.\n\n",
                "Repair": "\nConsider changing the way new shares are issued:\n\n1.  Swap from Vault asset (eg. FRAX) to UST in deposit();\n2.  Using the UST amount out / total underlying UST for the amount of new shares issued to the depositor.\n\nIn essence, the depositor should be paying for the swap fee and slippage.\n\nCrisBRM (Sandclock) confirmed and disagreed with severity(https://github.com/code-423n4/2022-01-sandclock-findings/issues/158#issuecomment-1012221473):\n  This is only an issue if we support low liquidity Curve pools\n We are also adding slippage control as per some other issue which would cause massive transfers using low liquidity pools to revert, fully mitigating this.\n Likelihood of this happening would also be quite low given that profitability would go down tremendously as curve LPs would move to that pool in order to capture higher base fees, dissuading the attacker from continuing.\n \n That being said, I do agree that the curve swap fee (0.04%) should be paid by each individual depositor.\n\ndmvt (judge) changed severity and commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/158#issuecomment-1023099964):\n  This requires a number of external factors to line up just right. It is a medium risk according to the definition provided by Code4rena.\n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "totalUnderlying()"
                ],
                "Type": " unsponsor, claimYield and withdraw might fail unexpectedly",
                "Description": "\ntotalUnderlying() includes the invested assets, they are not in the contract balance.\n\nwhen a user calls withdraw, claimYield or unsponsor, the system might not have enough assets in the balance and the transfer would fail.\n\nespecially, force unsponsor will always fail, because it tries to transfer the entire totalUnderlying(), which the system doesn't have:\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L391\n\n",
                "Repair": "\nwhen the system doesn't have enough balance to make the transfer, withdraw from the strategy.\n\ngabrielpoca (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/76#issuecomment-1010881903):\n  I'm not sure this is an issue. We are aware of it, and redeeming from the strategy won't fix it because it is asynchronous. This is why we have an investment percentage.\n\ndmvt (judge) changed severity and commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/76#issuecomment-1023191389):\n  This one is a hard issue to size, but I'm going to go with the medium risk rating provided by other wardens reporting this issue. This seems to amount to a bank run like issue similar to what can happen with DeFi lending protocols.\n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n If the invested assets are compromised or locked, this could result in a loss of funds. Users of the protocol should be made aware of the risk. This risk exists with many DeFi protocols and probably shouldn't be a surprise to most users.\n\n\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "_transferAndCheckUnderlying()",
                    "safeTransferFrom()"
                ],
                "Type": " Vault can't receive deposits if underlying token charges fees on transfer",
                "Description": "\nSome ERC20 tokens charge a fee for every transfer. If the underlying token of a vault is such a token any deposit to the protocol will fail.\n\nSome tokens have the possibility of adding fees later on, e.g. USDT. So those have to be covered too.\n\nGenerally, the user would also receive fewer tokens on withdrawing in such a scenario but that's not the protocol's fault.\n\nI rated the issue as medium since part of the protocol become unavailable in such a situation.\n\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L583-L585\n\n_transferAndCheckUnderlying() is used to deposit and sponsor the vault. It checks that after a safeTransferFrom() the same exact amount is sent to the balance of the vault. But, if fees are enabled the values won't match, causing the function to revert. Thus, it won't be able to deposit or sponsor the vault in any way.\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L162\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L266\n\n",
                "Repair": "\nOne possibility would be to simply not use ERC20 tokens with fees.\n\nryuheimat (Sandclock) disputed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/55#issuecomment-1010086346):\n  We don't use tokens with fees\n\nnaps62 (Sandclock) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/55#issuecomment-1010244557):\n  The only place where we mention USDT is on an old pitch deck (not up to date anymore). The codebase itself doesn't mention it, and all tests are done with USDC and DAI as examples\n\ndmvt (judge) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/55#issuecomment-1023697029):\n  I'm going to let this issue stand given that #164 is also valid. Supported or not, fee on transfer tokens would cause a loss of funds in the scenario described. As the USDT example shows (in both issues), many stables can be upgraded and add a fee later.\n\n\n\n\n"
            },
            {
                "Name": "M-11",
                "Location": [
                    "investedAssets",
                    "setStrategy",
                    "strategy.investedAssets() == 0"
                ],
                "Type": " Changing a strategy can be bricked",
                "Description": "\nA vault wouldn't let the strategy be changed unless the strategy holds no funds.\n\nSince anybody can send funds to the strategy, a griefing attack is possible.\n\n\nStrategy couldn't be changed.\n\n\nsetStrategy requires strategy.investedAssets() == 0. (Code ref)(https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L113:#L116)\ninvestedAssets contains the aUST balance and the pending redeems: (Code ref)(https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/strategy/BaseStrategy.sol#L271)\n\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\nSo if a griefer sends 1 wei of aUST to the strategy before it is to be replaced, it would not be able to be replaced. The protocol would then need to redeem the aUST and wait for the process to finish and the griefer can repeat his griefing. As they say, griefers gonna grief.\n\n",
                "Repair": "\nConsider keeping an internal aUST balance of the strategy, which will be updated upon deposit and redeem, and use it (instead of raw aUST balance) to check if the strategy holds no aUST funds.\n\nAnother option is to add capability for the strategy to send the aUST to the vault.\n\nryuheimat (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/91)\n\nCloudEllie (C4) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/91#issuecomment-1008980524):\n  Warden kenzo requested that I add the following: \n \n \"Additionally, impact-wise: EthAnchor does not accept redeems of less than 10 aUST. This means that if a griefer only sends 1 wei aUST, the protocol would have to repeatedly send additional aUST to the strategy to be able to redeem the griefer's aUST.\"\n\n\n\n\n"
            },
            {
                "Name": "M-15",
                "Location": [
                    "_unsponsor",
                    "claimYield",
                    "_to",
                    "_withdraw"
                ],
                "Type": " Check _to is not empty",
                "Description": "\nfunctions claimYield, _withdraw, and _unsponsor should validate that _to is not an empty 0x0 address to prevent accidental burns.\n\n",
                "Repair": "\nConsider implementing the proposed validation:\nrequire _to != address(0)\n\ngabrielpoca (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/183) \n\ndmvt (judge) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/183#issuecomment-1024626171):\n  In this case assets are at risk due to external factors. A zero address check makes sense.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"./curve/ICurve.sol\";\nimport \"./BaseStrategy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * Strategy that handles non-UST tokens, by first converting them to UST via\n * Curve (https://curve.fi/), and only then depositing into EthAnchor\n */\ncontract NonUSTStrategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    // address of the Curve pool to use\n    ICurve public curvePool;\n\n    // index of the underlying token in the pool\n    int128 public underlyingI;\n\n    // index of the UST token in the pool\n    int128 public ustI;\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner,\n        address _curvePool,\n        int128 _underlyingI,\n        int128 _ustI\n    )\n        BaseStrategy(\n            _vault,\n            _treasury,\n            _ethAnchorRouter,\n            _exchangeRateFeeder,\n            _ustToken,\n            _aUstToken,\n            _perfFeePct,\n            _owner\n        )\n    {\n        require(underlying != _ustToken, \"invalid underlying\");\n        require(_curvePool != address(0), \"0x addr\");\n        curvePool = ICurve(_curvePool);\n        underlyingI = _underlyingI;\n        ustI = _ustI;\n\n        ustToken.safeApprove(_curvePool, type(uint256).max);\n        underlying.safeApprove(_curvePool, type(uint256).max);\n    }\n\n    /**\n     * Swaps the underlying currency for UST, and initiates a deposit of all\n     * the converted UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external override(BaseStrategy) restricted {\n        _swapUnderlyingToUst();\n        _initDepositStable();\n    }\n\n    /**\n     * Calls Curve to convert the existing underlying balance into UST\n     */\n    function _swapUnderlyingToUst() internal {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(\n                underlyingI,\n                ustI,\n                underlyingBalance,\n                0\n            );\n        }\n    }\n\n    /**\n     * Calls Curve to convert the existing UST back into the underlying token\n     */\n    function _swapUstToUnderlying() internal {\n        uint256 ustBalance = _getUstBalance();\n        if (ustBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);\n        }\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     * Once UST is retrieved, convert it back to underlying via Curve\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {\n        super.finishRedeemStable(idx);\n        _swapUstToUnderlying();\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        override(BaseStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\n            address(aUstToken),\n            true\n        ) * aUstBalance) / 1e18) + pendingDeposits;\n        return\n            underlyingBalance +\n            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\n    }\n}\n\n\n",
        "CodeNames": [
            "NonUSTStrategy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [],
                "Type": " Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool",
                "Description": "\nIn short, the NonUSTStrategy is vulnerable to attacks by flash loans on curve pools.\n\nHere's an outline of the attack:\n\n*   Assume there is a vault with DAI underlying and a NonUSTStrategy with a DAI / UST curve pool\n*   Take out a flash loan of DAI\n*   Exchange a ton of DAI for UST\n*   The exchange rate from DAI to UST has gone up (!!)\n*   Withdraw or deposit from vault with more favorable terms than market\n*   Transfer back UST to DAI\n*   Repay flash loan\n\n\nHere is my proof of concept:\n<https://gist.github.com/CamdenClark/932d5fbeecb963d0917cb1321f754132\n\nI can provide a full forge repo. Just ping me on discord.\n\nExploiting this line: <https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/strategy/NonUSTStrategy.sol#L135\n\n\nForge\n\n",
                "Repair": "\nUse an oracle\n\nnaps62 (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/7) \n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport {IVault} from \"./vault/IVault.sol\";\nimport {IVaultSponsoring} from \"./vault/IVaultSponsoring.sol\";\nimport {PercentMath} from \"./lib/PercentMath.sol\";\nimport {Depositors} from \"./vault/Depositors.sol\";\nimport {Claimers} from \"./vault/Claimers.sol\";\nimport {IIntegration} from \"./integrations/IIntegration.sol\";\nimport {IStrategy} from \"./strategy/IStrategy.sol\";\nimport {ERC165Query} from \"./lib/ERC165Query.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * A vault where other accounts can deposit an underlying token\n * currency and set distribution params for their principal and yield\n *\n * @dev Yield generation strategies not yet implemented\n */\n\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../strategy/anchor/IEthAnchorRouter.sol\";\n\ncontract MockEthAnchorRouter is IEthAnchorRouter {\n    using SafeERC20 for IERC20;\n\n    IERC20 public ustToken;\n    IERC20 public aUstToken;\n\n    address public pendingOperator;\n    mapping(address => uint256) public depositOperations;\n    mapping(address => uint256) public redeemOperations;\n    mapping(address => uint256) public depositFinishResults;\n    mapping(address => uint256) public redeemFinishResults;\n\n    constructor(IERC20 _ustToken, IERC20 _aUstToken) {\n        require(address(_ustToken) != address(0), \"invalid UST token\");\n        require(address(_aUstToken) != address(0), \"invalid aUST token\");\n\n        ustToken = _ustToken;\n        aUstToken = _aUstToken;\n    }\n\n    function addPendingOperator(address _operator) external {\n        require(_operator != address(0), \"invalid operator\");\n\n        pendingOperator = _operator;\n    }\n\n    function initDepositStable(uint256 _amount)\n        external\n        override(IEthAnchorRouter)\n        returns (address operator)\n    {\n        require(pendingOperator != address(0));\n        ustToken.safeTransferFrom(msg.sender, address(this), _amount);\n        depositOperations[pendingOperator] = _amount;\n        operator = pendingOperator;\n        pendingOperator = address(0);\n    }\n\n    function notifyDepositResult(address _operation, uint256 _amount) external {\n        require(depositOperations[_operation] > 0);\n        aUstToken.safeTransferFrom(msg.sender, address(this), _amount);\n        depositOperations[_operation] = 0;\n        depositFinishResults[_operation] = _amount;\n    }\n\n    function finishDepositStable(address _operation)\n        external\n        override(IEthAnchorRouter)\n    {\n        require(depositFinishResults[_operation] > 0);\n        aUstToken.safeTransfer(msg.sender, depositFinishResults[_operation]);\n        depositFinishResults[_operation] = 0;\n    }\n\n    function initRedeemStable(uint256 _amount)\n        external\n        override(IEthAnchorRouter)\n        returns (address operator)\n    {\n        require(pendingOperator != address(0));\n        aUstToken.safeTransferFrom(msg.sender, address(this), _amount);\n        redeemOperations[pendingOperator] = _amount;\n        operator = pendingOperator;\n        pendingOperator = address(0);\n    }\n\n    function notifyRedeemResult(address _operation, uint256 _amount) external {\n        require(redeemOperations[_operation] > 0);\n        ustToken.safeTransferFrom(msg.sender, address(this), _amount);\n        redeemOperations[_operation] = 0;\n        redeemFinishResults[_operation] = _amount;\n    }\n\n    function finishRedeemStable(address _operation) external override {\n        require(redeemFinishResults[_operation] > 0);\n        ustToken.safeTransfer(msg.sender, redeemFinishResults[_operation]);\n        redeemFinishResults[_operation] = 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "MockEthAnchorRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "investPerc",
                    "EthAnchor",
                    "initRedeemStable()"
                ],
                "Type": " Centralization Risk: Funds can be frozen when critical key holders lose access to their keys",
                "Description": "\nThe current implementation requires trusted key holders (isTrusted[msg.sender]) to send transactions (initRedeemStable()) to initialize withdrawals from EthAnchor before the users can withdraw funds from the contract.\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/strategy/BaseStrategy.sol#L214-L223\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/strategy/BaseStrategy.sol#L163-L170\n\nThis introduces a high centralization risk, which can cause funds to be frozen in the contract if the key holders lose access to their keys.\n\n\nGiven:\n\n*   investPerc = 80%\n*   1,000 users deposited 1M UST in total ($1000 each user in avg), 800k invested into AUST (EthAnchor)\n\nIf the key holders lose access to their keys (\"hit by a bus\"). The 800k will be frozen in EthAnchor as no one can initRedeemStable().\n\n",
                "Repair": "\nSee the recommendation on issue #157(https://github.com/code-423n4/2022-01-sandclock-findings/issues/157).\n\nCrisBRM (Sandclock) confirmed and disagreed with severity(https://github.com/code-423n4/2022-01-sandclock-findings/issues/165#issuecomment-1012218046):\n  Agree that there should be a way for users to call the uninvest functions themselves, subject to certain rules. Again, not sure I agree with the severity given the likelihood of the event transpiring.\n \n Consensus is for UST vaults, allow depositors to call uninvest. For nonUST vaults that pay per curve swap, add trusted multisig instead of just the backend's EOA.\n\ndmvt (judge) changed severity and commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/165#issuecomment-1023107965):\n  This issue requires external factors to align in a very negative way, but it would result in a potentially significant loss of funds. Because there is no direct attack path, it doesn't qualify as a high risk issue, but a medium risk per Code4rena definitions.\n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n\n"
            },
            {
                "Name": "M-12",
                "Location": [
                    "//solidity\nfunction finishRedeemStable(uint256 idx) public virtual {\n    require(redeemOperations.length  idx, \"not running\");\n    Operation storage operation = redeemOperations[idx];\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n    uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;\n    uint256 ustBalanceBefore = _getUstBalance();\n\n    ethAnchorRouter.finishRedeemStable(operation.operator);\n\n    uint256 redeemedAmount = _getUstBalance() ustBalanceBefore;\n    uint256 perfFee = redeemedAmount  originalUst\n        ? (redeemedAmount originalUst).percOf(perfFeePct)\n        : 0;\n    if (perfFee  0) {\n        ustToken.safeTransfer(treasury, perfFee);\n        emit PerfFeeClaimed(perfFee);\n    }\n    convertedUst -= originalUst;\n    pendingRedeems -= operation.amount;\n\n    operation.operator = redeemOperations[redeemOperations.length 1]\n        .operator;\n    operation.amount = redeemOperations[redeemOperations.length 1].amount;\n    redeemOperations.pop();\n}\n",
                    "//solidity\nfunction investedAssets()\n    external\n    view\n    virtual\n    override(IStrategy)\n    returns (uint256)\n{\n    uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n    return\n        underlyingBalance +\n        ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *\n            aUstBalance) / 1e18);\n}\n",
                    "//solidity\nfunction investedAssets()\n    external\n    view\n    override(BaseStrategy)\n    returns (uint256)\n{\n    uint256 underlyingBalance = _getUnderlyingBalance();\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n    uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\n        address(aUstToken),\n        true\n    ) * aUstBalance) / 1e18) + pendingDeposits;\n    return\n        underlyingBalance +\n        curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\n}\n"
                ],
                "Type": "  investedAssets()  Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals",
                "Description": "\nThe investedAssets() function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in finishRedeemStable().\n\nTherefore, an attacker could avoid paying their fair share of the performance fee by withdrawing their assets before several calls to finishRedeemStable() are made and reenter the vault once the fee is charged.\n\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/strategy/BaseStrategy.sol#L180-L204\nsolidity\nfunction finishRedeemStable(uint256 idx) public virtual {\n    require(redeemOperations.length  idx, \"not running\");\n    Operation storage operation = redeemOperations[idx];\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n    uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;\n    uint256 ustBalanceBefore = _getUstBalance();\n\n    ethAnchorRouter.finishRedeemStable(operation.operator);\n\n    uint256 redeemedAmount = _getUstBalance() ustBalanceBefore;\n    uint256 perfFee = redeemedAmount  originalUst\n        ? (redeemedAmount originalUst).percOf(perfFeePct)\n        : 0;\n    if (perfFee  0) {\n        ustToken.safeTransfer(treasury, perfFee);\n        emit PerfFeeClaimed(perfFee);\n    }\n    convertedUst -= originalUst;\n    pendingRedeems -= operation.amount;\n\n    operation.operator = redeemOperations[redeemOperations.length 1]\n        .operator;\n    operation.amount = redeemOperations[redeemOperations.length 1].amount;\n    redeemOperations.pop();\n}\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/strategy/BaseStrategy.sol#L263-L277\nsolidity\nfunction investedAssets()\n    external\n    view\n    virtual\n    override(IStrategy)\n    returns (uint256)\n{\n    uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n    return\n        underlyingBalance +\n        ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *\n            aUstBalance) / 1e18);\n}\n\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/strategy/NonUSTStrategy.sol#L120-L136\nsolidity\nfunction investedAssets()\n    external\n    view\n    override(BaseStrategy)\n    returns (uint256)\n{\n    uint256 underlyingBalance = _getUnderlyingBalance();\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n    uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\n        address(aUstToken),\n        true\n    ) * aUstBalance) / 1e18) + pendingDeposits;\n    return\n        underlyingBalance +\n        curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\n}\n\n\n\nManual code review.\nDiscussions with the Sandclock team (mostly Ryuhei).\n\n",
                "Repair": "\nWhen calculating the investedAssets() amount (expressed in the underlying currency), consider calculating the expected performance fee to be charged if all the strategy's assets are withdrawn from the Anchor protocol. This should ensure that investedAssets() returns the most accurate amount, preventing users from gaming the protocol.\n\nryuheimat (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/66) \n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [],
                "Type": " Add a timelock to  BaseStrategy:setPerfFeePct ",
                "Description": "\nTo give more trust to users: functions that set key/critical variables should be put behind a timelock.\n\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/strategy/BaseStrategy.sol#L249-L253\n\n\nVS Code\n\n",
                "Repair": "\nAdd a timelock to setter functions of key/critical variables.\n\nnaps62 (Sandclock) acknowledged(https://github.com/code-423n4/2022-01-sandclock-findings/issues/178#issuecomment-1015430589):\n  While this is a valid suggestion, it doesn't necessarily indicate a vulnerability in the existing approach. A timelock can indeed increase trust, but it never truly eliminates the same risk (i.e.: once the timelock finishes, the same theoretical attacks from a malicious operator could happen anyway)\n\nryuheimat (Sandclock) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/178#issuecomment-1024395152):\n  We will set admin as a timelock\n\n\n\n\n"
            },
            {
                "Name": "M-10",
                "Location": [
                    "//solidity\nfunction investedAssets() external view virtual override(IStrategy) returns (uint256) {\n    uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n    return underlyingBalance + ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) \n            * aUstBalance) / 1e18);\n}\n"
                ],
                "Type": " No setter for exchangeRateFeeder, whose address might change in future",
                "Description": "\nEthAnchor's docs state that \"the contract address of ExchangeRateFeeder may change as adjustments occur\".\nBaseStrategy does not have a setter to change exchangeRateFeeder after deployment.\n\n\nInaccurate/unupdated values from exchangeRateFeeder when calculating vault's total invested assets.\n\nWhile the strategy's funds could be withdrawn from EthAnchor and migrated to a new strategy with correct exchangeRateFeeder, during this process (which might take time due to EthAnchor's async model) the wrong exchangeRateFeeder will be used to calculate the vault's total invested assets. (The vault's various actions (deposit, claim, withdraw) can not be paused.)\n\n\nThe exchangeRateFeeder is being used to calculate the vault's invested assets, which is used extensively to calculate the correct amount of shares and amounts: (Code ref)(https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/strategy/BaseStrategy.sol#L275)\nsolidity\nfunction investedAssets() external view virtual override(IStrategy) returns (uint256) {\n    uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;\n    uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n    return underlyingBalance + ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) \n            * aUstBalance) / 1e18);\n}\n\n\nEthAnchor documentation states that unlike other contracts, exchangeRateFeeder is not proxied and it's address may change in future: \"the contract address of ExchangeRateFeeder may change as adjustments occur.\n\" (ref)(https://docs.anchorprotocol.com/ethanchor/ethanchor-contracts/deployed-contracts#core-contracts)\n\n",
                "Repair": "\nAdd a setter for exchangeRateFeeder.\n\nryuheimat (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/71) \n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"./curve/ICurve.sol\";\nimport \"./BaseStrategy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * Strategy that handles non-UST tokens, by first converting them to UST via\n * Curve (https://curve.fi/), and only then depositing into EthAnchor\n */\ncontract NonUSTStrategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    // address of the Curve pool to use\n    ICurve public curvePool;\n\n    // index of the underlying token in the pool\n    int128 public underlyingI;\n\n    // index of the UST token in the pool\n    int128 public ustI;\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner,\n        address _curvePool,\n        int128 _underlyingI,\n        int128 _ustI\n    )\n        BaseStrategy(\n            _vault,\n            _treasury,\n            _ethAnchorRouter,\n            _exchangeRateFeeder,\n            _ustToken,\n            _aUstToken,\n            _perfFeePct,\n            _owner\n        )\n    {\n        require(underlying != _ustToken, \"invalid underlying\");\n        require(_curvePool != address(0), \"0x addr\");\n        curvePool = ICurve(_curvePool);\n        underlyingI = _underlyingI;\n        ustI = _ustI;\n\n        ustToken.safeApprove(_curvePool, type(uint256).max);\n        underlying.safeApprove(_curvePool, type(uint256).max);\n    }\n\n    /**\n     * Swaps the underlying currency for UST, and initiates a deposit of all\n     * the converted UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external override(BaseStrategy) restricted {\n        _swapUnderlyingToUst();\n        _initDepositStable();\n    }\n\n    /**\n     * Calls Curve to convert the existing underlying balance into UST\n     */\n    function _swapUnderlyingToUst() internal {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(\n                underlyingI,\n                ustI,\n                underlyingBalance,\n                0\n            );\n        }\n    }\n\n    /**\n     * Calls Curve to convert the existing UST back into the underlying token\n     */\n    function _swapUstToUnderlying() internal {\n        uint256 ustBalance = _getUstBalance();\n        if (ustBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);\n        }\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     * Once UST is retrieved, convert it back to underlying via Curve\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {\n        super.finishRedeemStable(idx);\n        _swapUstToUnderlying();\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        override(BaseStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\n            address(aUstToken),\n            true\n        ) * aUstBalance) / 1e18) + pendingDeposits;\n        return\n            underlyingBalance +\n            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport {IVault} from \"./vault/IVault.sol\";\nimport {IVaultSponsoring} from \"./vault/IVaultSponsoring.sol\";\nimport {PercentMath} from \"./lib/PercentMath.sol\";\nimport {Depositors} from \"./vault/Depositors.sol\";\nimport {Claimers} from \"./vault/Claimers.sol\";\nimport {IIntegration} from \"./integrations/IIntegration.sol\";\nimport {IStrategy} from \"./strategy/IStrategy.sol\";\nimport {ERC165Query} from \"./lib/ERC165Query.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * A vault where other accounts can deposit an underlying token\n * currency and set distribution params for their principal and yield\n *\n * @dev Yield generation strategies not yet implemented\n */\n\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\n\n\n",
        "CodeNames": [
            "NonUSTStrategy.sol",
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction totalUnderlyingMinusSponsored() public view returns (uint256) {\n    // TODO no invested amount yet\n    return totalUnderlying() totalSponsored;\n}\n",
                    "//solidity\nif (_force && sponsorAmount  totalUnderlying()) {\n    sponsorToTransfer = totalUnderlying();\n}\n"
                ],
                "Type": "  totalUnderlyingMinusSponsored()  may revert on underflow and malfunction the contract",
                "Description": "\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L290-L293\n\nsolidity\nfunction totalUnderlyingMinusSponsored() public view returns (uint256) {\n    // TODO no invested amount yet\n    return totalUnderlying() totalSponsored;\n}\n\n\nAs a function that many other functions depended on, totalUnderlyingMinusSponsored() can revert on underflow when  sponsorAmount  totalUnderlying() which is possible and has been considered elsewhere in this contract:\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L390-L392\n\nsolidity\nif (_force && sponsorAmount  totalUnderlying()) {\n    sponsorToTransfer = totalUnderlying();\n}\n\n\n\n*   Underlying token = USDT\n*   Swap Fee = 0.04%\n\n1.  Sponsor call sponsor() and send 10,000 USDT\n\n*   totalSponsored = 10,000\n\n2.  NonUSTStrategy.sol#doHardWork() swapped USDT for UST\n\n*   pendingDeposits = 9,996\n*   totalUnderlying() = 9,996\n\n3.  Alice tries to call deposit(), the tx will revet due to underflow in totalUnderlyingMinusSponsored().\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction totalUnderlyingMinusSponsored() public view returns (uint256) {\n    uint256 _totalUnderlying = totalUnderlying();\n    if (totalSponsored  _totalUnderlying) {\n        return 0;\n    }\n    return _totalUnderlying totalSponsored;\n}\n\n\nnaps62 (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/164)\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);",
                    "minLockPeriod"
                ],
                "Type": " Medium: Consider alternative price feed + ensure _minLockPeriod > 0 to prevent flash loan attacks",
                "Description": "\nIt is critical to ensure that _minLockPeriod  0 because it is immutable and cannot be changed once set. A zero minLockPeriod will allow for flash loan attacks to occur. Vaults utilising the nonUST strategy are especially susceptible to this attack vector since the strategy utilises the spot price of the pool to calculate the total asset value.\n\n\nAssume the vault\u2019s underlying token is MIM, and the curve pool to be used is the MIM-UST pool. Further assume that both the vault and the strategy holds substantial funds in MIM and UST respectively.\n\n1.  Flash loan MIM from the Uniswap V3 MIM-USDC pool(https://etherscan.io/address/0x298b7c5e0770d151e4c5cf6cca4dae3a3ffc8e27) (currently has ~$3.5M in MIM at the time of writing).\n2.  Convert half of the loaned MIM to UST to inflate and deflate their prices respectively.\n3.  Deposit the other half of the loaned MIM into the vault. We expect curvePool.get_dy_underlying(ustI, underlyingI, ustAssets); to return a smaller amount than expected because of the previous step. As a result, the attacker is allocated more shares than expected.\n4.  Exchange UST back to MIM, bringing back the spot price of MIM-UST to a normal level.\n5.  Withdraw funds from the vault. The number of shares to be deducted is lower as a result of (4), with the profit being accounted for as yield.\n6.  Claim yield and repay the flash loan.\n\n",
                "Repair": "\nEnsure that _minLockPeriod is non-zero in the constructor. Also, given how manipulatable the spot price of the pool can be, it would be wise to consider an alternative price feed.\n\njsx\n// in Vault#constructor\nrequire(_minLockPeriod  0, 'zero minLockPeriod');\n\nryuheimat (Sandclock) disputed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/65#issuecomment-1011081419):\n  we don't think it's an issue.\n\ndmvt (judge) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/65#issuecomment-1023663287):\n  This does potentially open assets up to flash loan risk. It is probably a good idea to have this variable guarded.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.10;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Depositors is ERC721 {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIds;\n    address public vault;\n\n    struct Deposit {\n        /// amount of the deposit\n        uint256 amount;\n        /// wallet of the claimer\n        uint256 claimerId;\n        /// when can the deposit be withdrawn\n        uint256 lockedUntil;\n    }\n\n    mapping(uint256 => Deposit) public deposits;\n\n    /// ID of the next NFT to mint\n    uint256 nextId;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, \"Claimers: not authorized\");\n        _;\n    }\n\n    constructor(\n        address _vault,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        vault = _vault;\n    }\n\n    // should only be callable by the vault\n    // TODO: emit the groupId\n    function mint(\n        address _owner,\n        uint256 _amount,\n        uint256 _claimerId,\n        uint256 _lockedUntil\n    ) external onlyVault returns (uint256) {\n        uint256 localTokenId = _tokenIds.current();\n        _tokenIds.increment();\n\n        _safeMint(_owner, localTokenId);\n\n        deposits[localTokenId] = Deposit(_amount, _claimerId, _lockedUntil);\n\n        return localTokenId;\n    }\n\n    // called when a deposit's principal is withdrawn\n    function burn(uint256 _id) external onlyVault {\n        _burn(_id);\n    }\n\n    function exists(uint256 _tokenId) external view returns (bool) {\n        return _exists(_tokenId);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport {IVault} from \"./vault/IVault.sol\";\nimport {IVaultSponsoring} from \"./vault/IVaultSponsoring.sol\";\nimport {PercentMath} from \"./lib/PercentMath.sol\";\nimport {Depositors} from \"./vault/Depositors.sol\";\nimport {Claimers} from \"./vault/Claimers.sol\";\nimport {IIntegration} from \"./integrations/IIntegration.sol\";\nimport {IStrategy} from \"./strategy/IStrategy.sol\";\nimport {ERC165Query} from \"./lib/ERC165Query.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * A vault where other accounts can deposit an underlying token\n * currency and set distribution params for their principal and yield\n *\n * @dev Yield generation strategies not yet implemented\n */\n\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\n\n\n",
        "CodeNames": [
            "Depositors.sol",
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "_safeMint()",
                    "deposit()"
                ],
                "Type": " no use of safeMint() as safe guard for users ",
                "Description": "\nIn Vault.sol the deposit() function eventually calls claimers.mint() and depositers.mint().  Calling mint this way does not ensure that the receiver of the NFT is able to accept them.  _safeMint() should be used with reentrancy guards as a guard to protect the user as it checks to see if a user can properly accept an NFT and reverts otherwise.\n\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L470\n\n<https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L256\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L248\n\n",
                "Repair": "\nUse _safeMint() instead of mint()\n\nryuheimat (Sandclock) disagreed with severity(https://github.com/code-423n4/2022-01-sandclock-findings/issues/29#issuecomment-1007534909):\n  I think _safeMint check if the recipient contract is able to accept NFT, it does not involves any issues.\n However we will use _safeMint.\n\ngabrielpoca (Sandclock) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/29#issuecomment-1010895318):\n  @ryuheimat this is a non-issue. The mint functions called in the Vault's deposit function are implemented by us, they just happen to be called mint.\n\ndmvt (judge) commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/29#issuecomment-1024220647):\n  The Depositors contract does use _safeMint, but the Claimers contract does not.\n \n See:\n https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/vault/Claimers.sol#L63\n https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/vault/Depositors.sol#L53\n \n The deposit function on Vault also appears to lack reentrancy guards. The issue is valid and should be addressed, despite the fact that the warden clearly did not look at the Depositors contract to see that it already used _safeMint. \n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport \"../lib/PercentMath.sol\";\nimport \"../vault/IVault.sol\";\nimport \"./IStrategy.sol\";\nimport \"./anchor/IEthAnchorRouter.sol\";\nimport \"./anchor/IExchangeRateFeeder.sol\";\n\n// import \"./Controllable.sol\";\n\n/**\n * Base strategy that handles UST tokens and invests them via the EthAnchor\n * protocol (https://docs.anchorprotocol.com/ethanchor/ethanchor)\n */\nabstract contract BaseStrategy is IStrategy, Trust {\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n\n    event PerfFeeClaimed(uint256 amount);\n    event PerfFeePctUpdated(uint256 pct);\n\n    struct Operation {\n        address operator;\n        uint256 amount;\n    }\n\n    IERC20 public override(IStrategy) underlying;\n    // Vault address\n    address public override(IStrategy) vault;\n\n    // address of the treasury\n    address public treasury;\n\n    // address for the UST token\n    IERC20 public ustToken;\n\n    // address for the aUST token (wrapped Anchor UST, received to accrue interest for an Anchor deposit)\n    IERC20 public aUstToken;\n\n    // performance fee taken by the treasury on profits\n    uint16 public perfFeePct;\n\n    // external contract to interact with EthAnchor\n    IEthAnchorRouter public ethAnchorRouter;\n\n    // external exchange rate provider\n    IExchangeRateFeeder public exchangeRateFeeder;\n\n    // amount currently pending in deposits to EthAnchor\n    uint256 public pendingDeposits;\n\n    // amount currently pending redeemption from EthAnchor\n    uint256 public pendingRedeems;\n\n    // deposit operations history\n    Operation[] public depositOperations;\n\n    // redeem operations history\n    Operation[] public redeemOperations;\n\n    // amount of UST converted (used to calculate yield)\n    uint256 public convertedUst;\n\n    // restructs a function to be called only by the vault or governance\n    modifier restricted() {\n        require(msg.sender == vault || isTrusted[msg.sender], \"restricted\");\n\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == vault, \"only vault\");\n\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner\n    ) Trust(_owner) {\n        require(_ethAnchorRouter != address(0), \"0x addr\");\n        require(_exchangeRateFeeder != address(0), \"0x addr\");\n        require(address(_ustToken) != address(0), \"0x addr\");\n        require(address(_aUstToken) != address(0), \"0x addr\");\n        require(PercentMath.validPerc(_perfFeePct), \"invalid pct\");\n\n        treasury = _treasury;\n        vault = _vault;\n        underlying = IVault(_vault).underlying();\n        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);\n        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);\n        ustToken = _ustToken;\n        aUstToken = _aUstToken;\n        perfFeePct = _perfFeePct;\n\n        // pre-approve EthAnchor router to transact all UST and aUST\n        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);\n        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);\n    }\n\n    /**\n     * Initiates a deposit of all the currently held UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external virtual override(IStrategy) restricted {\n        _initDepositStable();\n    }\n\n    function _initDepositStable() internal {\n        uint256 ustBalance = _getUstBalance();\n        require(ustBalance > 0, \"balance 0\");\n        pendingDeposits += ustBalance;\n        address _operator = ethAnchorRouter.initDepositStable(ustBalance);\n        depositOperations.push(\n            Operation({operator: _operator, amount: ustBalance})\n        );\n    }\n\n    /**\n     * Calls EthAnchor with a pending deposit ID, and attempts to finish it.\n     *\n     * @notice Must be called some time after `doHardWork()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending deposit operation\n     */\n    function finishDepositStable(uint256 idx) external {\n        require(depositOperations.length > idx, \"not running\");\n        Operation storage operation = depositOperations[idx];\n        ethAnchorRouter.finishDepositStable(operation.operator);\n\n        pendingDeposits -= operation.amount;\n        convertedUst += operation.amount;\n\n        operation.operator = depositOperations[depositOperations.length - 1]\n            .operator;\n        operation.amount = depositOperations[depositOperations.length - 1]\n            .amount;\n        depositOperations.pop();\n    }\n\n    /**\n     * Initiates a withdrawal of UST from EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the redeem process, but does not finish it.\n     *\n     * @param amount Amount of aUST to redeem\n     */\n    function initRedeemStable(uint256 amount) public restricted {\n        uint256 aUstBalance = _getAUstBalance();\n        require(amount > 0, \"amount 0\");\n        require(aUstBalance >= amount, \"insufficient\");\n        pendingRedeems += amount;\n        address _operator = ethAnchorRouter.initRedeemStable(amount);\n        redeemOperations.push(Operation({operator: _operator, amount: amount}));\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public virtual {\n        require(redeemOperations.length > idx, \"not running\");\n        Operation storage operation = redeemOperations[idx];\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;\n        uint256 ustBalanceBefore = _getUstBalance();\n\n        ethAnchorRouter.finishRedeemStable(operation.operator);\n\n        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;\n        uint256 perfFee = redeemedAmount > originalUst\n            ? (redeemedAmount - originalUst).percOf(perfFeePct)\n            : 0;\n        if (perfFee > 0) {\n            ustToken.safeTransfer(treasury, perfFee);\n            emit PerfFeeClaimed(perfFee);\n        }\n        convertedUst -= originalUst;\n        pendingRedeems -= operation.amount;\n\n        operation.operator = redeemOperations[redeemOperations.length - 1]\n            .operator;\n        operation.amount = redeemOperations[redeemOperations.length - 1].amount;\n        redeemOperations.pop();\n    }\n\n    /**\n     * Withdraws the entire amount back to the vault\n     *\n     * @notice since some of the amount may be deposited into EthAnchor, this\n     * call may not withdraw all the funds right away. It will start a redeem\n     * process on EthAnchor, but this function must be called again a second\n     * time once that is finished.\n     */\n    function withdrawAllToVault() external override(IStrategy) restricted {\n        uint256 aUstBalance = _getAUstBalance();\n        if (aUstBalance > 0) {\n            initRedeemStable(aUstBalance);\n        }\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            underlying.safeTransfer(vault, underlyingBalance);\n        }\n    }\n\n    /**\n     * Withdraws a specified amount back to the vault\n     *\n     * @notice Unlike `withdrawToVault`, this function only considers the\n     * amount currently not invested, but only what is currently held by the\n     * strategy\n     *\n     * @param amount Amount to withdraw\n     */\n    function withdrawToVault(uint256 amount)\n        external\n        override(IStrategy)\n        restricted\n    {\n        underlying.safeTransfer(vault, amount);\n    }\n\n    /**\n     * Updates the performance fee\n     *\n     * @notice Can only be called by governance\n     *\n     * @param _perfFeePct The new performance fee %\n     */\n    function setPerfFeePct(uint16 _perfFeePct) external restricted {\n        require(PercentMath.validPerc(_perfFeePct), \"invalid pct\");\n        perfFeePct = _perfFeePct;\n        emit PerfFeePctUpdated(_perfFeePct);\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        virtual\n        override(IStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        return\n            underlyingBalance +\n            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *\n                aUstBalance) / 1e18);\n    }\n\n    // Amount of underlying tokens in the strategy\n    function _getUnderlyingBalance() internal view returns (uint256) {\n        return underlying.balanceOf(address(this));\n    }\n\n    // Amount of UST tokens in the strategy\n    function _getUstBalance() internal view returns (uint256) {\n        return ustToken.balanceOf(address(this));\n    }\n\n    // Amount of aUST tokens in the strategy\n    function _getAUstBalance() internal view returns (uint256) {\n        return aUstToken.balanceOf(address(this));\n    }\n\n    // Amount of pending deposit operations\n    function depositOperationLength() external view returns (uint256) {\n        return depositOperations.length;\n    }\n\n    // Amount of pending redeem operations\n    function redeemOperationLength() external view returns (uint256) {\n        return redeemOperations.length;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\ncontract SandclockFactory is Context, Trust {\n    //\n    // Events\n    //\n\n    event NewVault(address indexed vault, uint256 salt);\n    event NewDCA(address indexed dca, uint256 salt);\n\n    //\n    // Constructor\n    //\n\n    constructor() Trust(_msgSender()) {}\n\n    //\n    // Public API\n    //\n\n    function deployVault(bytes memory code, uint256 salt)\n        external\n        requiresTrust\n    {\n        address addr = deploy(code, salt);\n\n        emit NewVault(addr, salt);\n    }\n\n    function deployDCA(bytes memory code, uint256 salt) external requiresTrust {\n        address addr = deploy(code, salt);\n\n        emit NewDCA(addr, salt);\n    }\n\n    //\n    // Internal\n    //\n\n    function deploy(bytes memory code, uint256 salt)\n        internal\n        returns (address)\n    {\n        address addr;\n        assembly {\n            addr := create2(0, add(code, 0x20), mload(code), salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n\n        return addr;\n    }\n}\n\n\n",
        "CodeNames": [
            "BaseStrategy.sol",
            "SandclockFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-14",
                "Location": [
                    "//solidity\nabstract contract T//rust {\n    event UserT//rustUpdated(address indexed user, bool t//rusted);\n\n    mapping(address = bool) public isT//rusted;\n\n    constructor(address initialUser) {\n        isT//rusted[initialUser] = true;\n\n        emit UserT//rustUpdated(initialUser, true);\n    }\n\n    function setIsT//rusted(address user, bool t//rusted) public virtual requiresT//rust {\n        isT//rusted[user] = t//rusted;\n\n        emit UserT//rustUpdated(user, t//rusted);\n    }\n\n    modifier requiresT//rust() {\n        require(isT//rusted[msg.sender], \"UNTRUSTED\");\n\n        _;\n    }\n}\n"
                ],
                "Type": " A Single Malicious Trusted Account Can Takeover Parent Contract",
                "Description": "\nThe requiresTrust() modifier is used on the strategy, vault and factory contracts to prevent unauthorised accounts from calling restricted functions. Once an account is considered trusted, they are allowed to add and remove accounts by calling setIsTrusted() as they see fit.\n\nHowever, if any single account has its private keys compromised or decides to become malicious on their own, they can remove all other trusted accounts from the isTrusted mapping. As a result, they are effectively able to take over the trusted group that controls all restricted functions in the parent contract.\n\nsolidity\nabstract contract Trust {\n    event UserTrustUpdated(address indexed user, bool trusted);\n\n    mapping(address = bool) public isTrusted;\n\n    constructor(address initialUser) {\n        isTrusted[initialUser] = true;\n\n        emit UserTrustUpdated(initialUser, true);\n    }\n\n    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {\n        isTrusted[user] = trusted;\n\n        emit UserTrustUpdated(user, trusted);\n    }\n\n    modifier requiresTrust() {\n        require(isTrusted[msg.sender], \"UNTRUSTED\");\n\n        _;\n    }\n}\n\n\n",
                "Repair": "\nConsider utilising Rari Capital's updated Auth.sol contract found here(https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol). This updated contract gives the owner account authority over its underlying trusted accounts, preventing any single account from taking over the trusted group. The owner account should point to a multisig managed by the Sandclock team or by a community DAO.\n\nnaps62 (Sandclock) confirmed(https://github.com/code-423n4/2022-01-sandclock-findings/issues/132)\n\ndmvt (judge) changed severity and commented(https://github.com/code-423n4/2022-01-sandclock-findings/issues/132#issuecomment-1024609919):\n  If this were to happen, funds would definitely be lost. Accordingly, this is a medium risk issue.\n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n\n"
            }
        ]
    }
]