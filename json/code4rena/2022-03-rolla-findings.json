[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../pricing/PriceRegistry.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../interfaces/IQToken.sol\";\nimport \"../libraries/ProtocolValue.sol\";\nimport \"../libraries/OptionsUtils.sol\";\nimport \"../libraries/QuantMath.sol\";\nimport \"./QTokenStringUtils.sol\";\n\n/// @title Token that represents a user's long position\n/// @author Rolla\n/// @notice Can be used by owners to exercise their options\n/// @dev Every option long position is an ERC20 token: https://eips.ethereum.org/EIPS/eip-20\ncontract QToken is ERC20Permit, QTokenStringUtils, IQToken {\n    using QuantMath for uint256;\n\n    /// @inheritdoc IQToken\n    IQuantConfig public override quantConfig;\n\n    /// @inheritdoc IQToken\n    address public override underlyingAsset;\n\n    /// @inheritdoc IQToken\n    address public override strikeAsset;\n\n    /// @inheritdoc IQToken\n    address public override oracle;\n\n    /// @inheritdoc IQToken\n    uint256 public override strikePrice;\n\n    /// @inheritdoc IQToken\n    uint256 public override expiryTime;\n\n    /// @inheritdoc IQToken\n    bool public override isCall;\n\n    /// @notice Configures the parameters of a new option token\n    /// @param _quantConfig the address of the Quant system configuration contract\n    /// @param _underlyingAsset asset that the option references\n    /// @param _strikeAsset asset that the strike is denominated in\n    /// @param _oracle price oracle for the underlying\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    constructor(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _oracle,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    )\n        ERC20(\n            _qTokenName(\n                _quantConfig,\n                _underlyingAsset,\n                _strikeAsset,\n                _strikePrice,\n                _expiryTime,\n                _isCall\n            ),\n            _qTokenSymbol(\n                _quantConfig,\n                _underlyingAsset,\n                _strikeAsset,\n                _strikePrice,\n                _expiryTime,\n                _isCall\n            )\n        )\n        ERC20Permit(\n            _qTokenName(\n                _quantConfig,\n                _underlyingAsset,\n                _strikeAsset,\n                _strikePrice,\n                _expiryTime,\n                _isCall\n            )\n        )\n    {\n        require(\n            _quantConfig != address(0),\n            \"QToken: invalid QuantConfig address\"\n        );\n        require(\n            _underlyingAsset != address(0),\n            \"QToken: invalid underlying asset address\"\n        );\n        require(\n            _strikeAsset != address(0),\n            \"QToken: invalid strike asset address\"\n        );\n        require(_oracle != address(0), \"QToken: invalid oracle address\");\n\n        quantConfig = IQuantConfig(_quantConfig);\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        oracle = _oracle;\n        strikePrice = _strikePrice;\n        expiryTime = _expiryTime;\n        isCall = _isCall;\n    }\n\n    /// @inheritdoc IQToken\n    function mint(address account, uint256 amount) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"OPTIONS_MINTER_ROLE\"),\n                msg.sender\n            ),\n            \"QToken: Only an options minter can mint QTokens\"\n        );\n        _mint(account, amount);\n        emit QTokenMinted(account, amount);\n    }\n\n    /// @inheritdoc IQToken\n    function burn(address account, uint256 amount) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"OPTIONS_BURNER_ROLE\"),\n                msg.sender\n            ),\n            \"QToken: Only an options burner can burn QTokens\"\n        );\n        _burn(account, amount);\n        emit QTokenBurned(account, amount);\n    }\n\n    /// @inheritdoc IQToken\n    function getOptionPriceStatus()\n        external\n        view\n        override\n        returns (PriceStatus)\n    {\n        if (block.timestamp > expiryTime) {\n            PriceRegistry priceRegistry = PriceRegistry(\n                quantConfig.protocolAddresses(\n                    ProtocolValue.encode(\"priceRegistry\")\n                )\n            );\n\n            if (\n                priceRegistry.hasSettlementPrice(\n                    oracle,\n                    underlyingAsset,\n                    expiryTime\n                )\n            ) {\n                return PriceStatus.SETTLED;\n            }\n            return PriceStatus.AWAITING_SETTLEMENT_PRICE;\n        } else {\n            return PriceStatus.ACTIVE;\n        }\n    }\n\n    /// @inheritdoc IQToken\n    function getQTokenInfo()\n        external\n        view\n        override\n        returns (QTokenInfo memory)\n    {\n        return OptionsUtils.getQTokenInfo(address(this));\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\nimport \"../interfaces/IAssetsRegistry.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../libraries/ProtocolValue.sol\";\n\nabstract contract QTokenStringUtils {\n    /// @notice get the ERC20 token symbol from the AssetsRegistry\n    /// @dev the asset is assumed to be in the AssetsRegistry since QTokens\n    /// must be created through the OptionsFactory, which performs that check\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _asset address of the asset in the AssetsRegistry\n    /// @return assetSymbol string stored as the ERC20 token symbol\n    function _assetSymbol(address _quantConfig, address _asset)\n        internal\n        view\n        virtual\n        returns (string memory assetSymbol)\n    {\n        (, assetSymbol, ) = IAssetsRegistry(\n            IQuantConfig(_quantConfig).protocolAddresses(\n                ProtocolValue.encode(\"assetsRegistry\")\n            )\n        ).assetProperties(_asset);\n    }\n\n    /// @notice generates the name for an option\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _underlyingAsset asset that the option references\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenName name string for the QToken\n    function _qTokenName(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenName) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (, string memory typeFull) = _getOptionType(_isCall);\n\n        // get option month string\n        (, string memory monthFull) = _getMonth(month);\n\n        /// concatenated name string\n        tokenName = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \" \",\n                underlying,\n                \" \",\n                _uintToChars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                \" \",\n                typeFull\n            )\n        );\n    }\n\n    /// @notice generates the symbol for an option\n    /// @param _underlyingAsset asset that the option references\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenSymbol symbol string for the QToken\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n\n    /// @dev convert the option strike price scaled to a human readable value\n    /// @param _strikePrice the option strike price scaled by 1e20\n    /// @return strike price string\n    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n        uint256 strikePriceScale = 10**strikePriceDigits;\n        uint256 remainder = _strikePrice % strikePriceScale;\n        uint256 quotient = _strikePrice / strikePriceScale;\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) {\n            return quotientStr;\n        }\n\n        uint256 trailingZeroes;\n        while (remainder % 10 == 0) {\n            remainder /= 10;\n            trailingZeroes++;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(strikePriceDigits - trailingZeroes);\n\n        string memory tmp = Strings.toString(remainder);\n        tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);\n\n        return string(abi.encodePacked(quotientStr, \".\", tmp));\n    }\n\n    /// @dev get the string representation of the option type\n    /// @return a 1 character representation of the option type\n    /// @return a full length string of the option type\n    function _getOptionType(bool _isCall)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        return _isCall ? (\"C\", \"Call\") : (\"P\", \"Put\");\n    }\n\n    /// @dev get the representation of a number using 2 characters, adding a leading 0 if it's one digit,\n    /// and two trailing digits if it's a 3 digit number\n    /// @return 2 characters that correspond to a number\n    function _uintToChars(uint256 _number)\n        internal\n        pure\n        virtual\n        returns (string memory)\n    {\n        if (_number > 99) {\n            _number %= 100;\n        }\n\n        string memory str = Strings.toString(_number);\n\n        if (_number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n\n        return str;\n    }\n\n    /// @dev cut a string into string[start:end]\n    /// @param _s string to cut\n    /// @param _start the starting index\n    /// @param _end the ending index (not inclusive)\n    /// @return the indexed string\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure virtual returns (string memory) {\n        uint256 range = _end - _start;\n        bytes memory slice = new bytes(range);\n        for (uint256 i = 0; i < range; ) {\n            slice[i] = bytes(_s)[_start + 1];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return string(slice);\n    }\n\n    /// @dev get the string representations of a month\n    /// @return a 3 character representation\n    /// @return a full length string representation\n    function _getMonth(uint256 _month)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./QuantConfig.sol\";\nimport \"./utils/EIP712MetaTransaction.sol\";\nimport \"./utils/OperateProxy.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IOracleRegistry.sol\";\nimport \"./interfaces/ICollateralToken.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IOperateProxy.sol\";\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./libraries/ProtocolValue.sol\";\nimport \"./libraries/QuantMath.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/Actions.sol\";\n\n/// @title The main entry point in the Quant Protocol\n/// @author Rolla\n/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.\n/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.\n/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.\n/// @dev This contract is an upgradeable proxy, and it supports meta transactions.\n/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the\n/// OptionsFactory first.\ncontract Controller is\n    IController,\n    EIP712MetaTransaction,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using QuantMath for QuantMath.FixedPointInt;\n    using Actions for ActionArgs;\n\n    /// @inheritdoc IController\n    address public override optionsFactory;\n\n    /// @inheritdoc IController\n    address public override operateProxy;\n\n    /// @inheritdoc IController\n    address public override quantCalculator;\n\n    /// @inheritdoc IController\n    function operate(ActionArgs[] memory _actions)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        uint256 length = _actions.length;\n        for (uint256 i = 0; i < length; ) {\n            ActionArgs memory action = _actions[i];\n\n            if (action.actionType == ActionType.MintOption) {\n                (address to, address qToken, uint256 amount) = action\n                    .parseMintOptionArgs();\n                _mintOptionsPosition(to, qToken, amount);\n            } else if (action.actionType == ActionType.MintSpread) {\n                (\n                    address qTokenToMint,\n                    address qTokenForCollateral,\n                    uint256 amount\n                ) = action.parseMintSpreadArgs();\n                _mintSpread(qTokenToMint, qTokenForCollateral, amount);\n            } else if (action.actionType == ActionType.Exercise) {\n                (address qToken, uint256 amount) = action.parseExerciseArgs();\n                _exercise(qToken, amount);\n            } else if (action.actionType == ActionType.ClaimCollateral) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseClaimCollateralArgs();\n                _claimCollateral(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.Neutralize) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseNeutralizeArgs();\n                _neutralizePosition(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.QTokenPermit) {\n                (\n                    address qToken,\n                    address owner,\n                    address spender,\n                    uint256 value,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseQTokenPermitArgs();\n                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);\n            } else if (\n                action.actionType == ActionType.CollateralTokenApproval\n            ) {\n                (\n                    address owner,\n                    address operator,\n                    bool approved,\n                    uint256 nonce,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseCollateralTokenApprovalArgs();\n                _collateralTokenApproval(\n                    owner,\n                    operator,\n                    approved,\n                    nonce,\n                    deadline,\n                    v,\n                    r,\n                    s\n                );\n            } else {\n                require(\n                    action.actionType == ActionType.Call,\n                    \"Controller: Invalid action type\"\n                );\n                (address callee, bytes memory data) = action.parseCallArgs();\n                _call(callee, data);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n\n    // @inheritdoc IController\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _optionsFactory,\n        address _quantCalculator\n    ) public override initializer {\n        require(\n            _optionsFactory != address(0),\n            \"Controller: invalid OptionsFactory address\"\n        );\n        require(\n            _quantCalculator != address(0),\n            \"Controller: invalid QuantCalculator address\"\n        );\n\n        __ReentrancyGuard_init();\n        EIP712MetaTransaction.initializeEIP712(_name, _version);\n        optionsFactory = _optionsFactory;\n\n        /// @dev Unless this line is removed, a new OperateProxy will be created\n        /// during each upgrade. So make sure any application that requires approving\n        /// the OperateProxy to spend funds is aware of this.\n        operateProxy = address(new OperateProxy());\n\n        quantCalculator = _quantCalculator;\n    }\n\n    /// @notice Mints options for a given QToken, which must have been previously created in\n    /// the configured OptionsFactory.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset, and then this function can be called, pulling the collateral\n    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.\n    /// Note that QTokens represent a long position, giving holders the ability to exercise options\n    /// after expiry, while CollateralTokens represent a short position, giving holders the ability\n    /// to claim the collateral after expiry.\n    /// @param _to The address to which the QTokens and CollateralTokens will be minted.\n    /// @param _qToken The QToken that represents the long position for the option to be minted.\n    /// @param _amount The amount of options to be minted.\n    function _mintOptionsPosition(\n        address _to,\n        address _qToken,\n        uint256 _amount\n    ) internal returns (uint256) {\n        IQToken qToken = IQToken(_qToken);\n\n        // get the collateral required to mint the specified amount of options\n        // the zero address is passed as the second argument as it's only used\n        // for spreads\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(_qToken, address(0), _amount);\n\n        _checkIfUnexpiredQToken(_qToken);\n\n        // check if the oracle set during the option's creation through the OptionsFactory\n        // is an active oracle in the OracleRegistry\n        require(\n            IOracleRegistry(\n                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(\n                    ProtocolValue.encode(\"oracleRegistry\")\n                )\n            ).isOracleActive(qToken.oracle()),\n            \"Controller: Can't mint an options position as the oracle is inactive\"\n        );\n\n        // pull the required collateral from the caller/signer\n        IERC20(collateral).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            collateralAmount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Mint the options to the sender's address\n        qToken.mint(_to, _amount);\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qToken,\n            address(0)\n        );\n\n        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,\n        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory\n        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);\n\n        emit OptionsPositionMinted(\n            _to,\n            _msgSender(),\n            _qToken,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Creates a spread position from an option to long and another option to short.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset in cases of a debit spread.\n    /// @param _qTokenToMint The QToken for the option to be long.\n    /// @param _qTokenForCollateral The QToken for the option to be short.\n    /// @param _amount The amount of long options to be minted.\n    function _mintSpread(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    ) internal returns (uint256) {\n        require(\n            _qTokenToMint != _qTokenForCollateral,\n            \"Controller: Can only create a spread with different tokens\"\n        );\n\n        IQToken qTokenToMint = IQToken(_qTokenToMint);\n        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);\n\n        // Calculate the extra collateral required to create the spread.\n        // A positive value for debit spreads and zero for credit spreads.\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount\n            );\n\n        _checkIfUnexpiredQToken(_qTokenToMint);\n        _checkIfUnexpiredQToken(_qTokenForCollateral);\n\n        // Burn the QToken being shorted\n        qTokenForCollateral.burn(_msgSender(), _amount);\n\n        // Transfer in any collateral required for the spread\n        if (collateralAmount > 0) {\n            IERC20(collateral).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                collateralAmount\n            );\n        }\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Check if the CollateralToken representing this specific spread has already been created\n        // Create it if it hasn't\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qTokenToMint,\n            _qTokenForCollateral\n        );\n        (, address qTokenAsCollateral) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n        if (qTokenAsCollateral == address(0)) {\n            require(\n                collateralTokenId ==\n                    collateralToken.createCollateralToken(\n                        _qTokenToMint,\n                        _qTokenForCollateral\n                    ),\n                \"Controller: failed creating the collateral token to represent the spread\"\n            );\n        }\n\n        // Mint the tokens for the new spread position\n        collateralToken.mintCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            _amount\n        );\n        qTokenToMint.mint(_msgSender(), _amount);\n\n        emit SpreadMinted(\n            _msgSender(),\n            _qTokenToMint,\n            _qTokenForCollateral,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Closes a long position after the option's expiry.\n    /// @dev Pass an `_amount` of 0 to close the entire position.\n    /// @param _qToken The QToken representing the long position to be closed.\n    /// @param _amount The amount of options to exercise.\n    function _exercise(address _qToken, uint256 _amount) internal {\n        IQToken qToken = IQToken(_qToken);\n        require(\n            block.timestamp > qToken.expiryTime(),\n            \"Controller: Can not exercise options before their expiry\"\n        );\n\n        uint256 amountToExercise = _amount;\n        // if the amount is 0, the entire position will be exercised\n        if (amountToExercise == 0) {\n            amountToExercise = qToken.balanceOf(_msgSender());\n        }\n\n        // Use the QuantCalculator to check how much the sender/signer is due.\n        // Will only be a positive value for options that expired In The Money.\n        (\n            bool isSettled,\n            address payoutToken,\n            uint256 exerciseTotal\n        ) = IQuantCalculator(quantCalculator).getExercisePayout(\n                address(qToken),\n                amountToExercise\n            );\n\n        require(isSettled, \"Controller: Cannot exercise unsettled options\");\n\n        // Burn the long tokens\n        qToken.burn(_msgSender(), amountToExercise);\n\n        // Transfer any profit due after expiration\n        if (exerciseTotal > 0) {\n            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);\n        }\n\n        emit OptionsExercised(\n            _msgSender(),\n            address(qToken),\n            amountToExercise,\n            exerciseTotal,\n            payoutToken\n        );\n    }\n\n    /// @notice Closes a short position after the option's expiry.\n    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.\n    /// @param _amount The size of the position to close.\n    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        uint256 collateralTokenId = _collateralTokenId;\n\n        // Use the QuantCalculator to check how much collateral the sender/signer is due.\n        (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(\n                collateralTokenId,\n                _amount,\n                _msgSender()\n            );\n\n        // Burn the short tokens\n        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim\n        );\n\n        // Transfer any collateral due after expiration\n        if (returnableCollateral > 0) {\n            IERC20(collateralAsset).safeTransfer(\n                _msgSender(),\n                returnableCollateral\n            );\n        }\n\n        emit CollateralClaimed(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim,\n            returnableCollateral,\n            collateralAsset\n        );\n    }\n\n    /// @notice Closes a neutral position, claiming all the collateral required to create it.\n    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.\n    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.\n    /// @param _amount The size of the position to close.\n    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        /// @dev Put these values in the stack to save gas from having to read\n        /// from calldata\n        (uint256 collateralTokenId, uint256 amount) = (\n            _collateralTokenId,\n            _amount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n\n        //get the amount of CollateralTokens owned\n        uint256 collateralTokensOwned = collateralToken.balanceOf(\n            _msgSender(),\n            collateralTokenId\n        );\n\n        //get the amount of QTokens owned\n        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());\n\n        // the size of the position that can be neutralized\n        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned\n            ? qTokensOwned\n            : collateralTokensOwned;\n\n        // make sure that the amount passed is not greater than the amount that can be neutralized\n        uint256 amountToNeutralize;\n        if (amount != 0) {\n            require(\n                amount <= maxNeutralizable,\n                \"Controller: Tried to neutralize more than balance\"\n            );\n            amountToNeutralize = amount;\n        } else {\n            amountToNeutralize = maxNeutralizable;\n        }\n\n        // use the QuantCalculator to check how much collateral the sender/signer is due\n        // for closing the neutral position\n        (address collateralType, uint256 collateralOwed) = IQuantCalculator(\n            quantCalculator\n        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);\n\n        // burn the short tokens\n        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);\n\n        // burn the long tokens\n        collateralToken.burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToNeutralize\n        );\n\n        // tranfer the collateral owed\n        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);\n\n        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)\n        if (qTokenLong != address(0)) {\n            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);\n        }\n\n        emit NeutralizePosition(\n            _msgSender(),\n            qTokenShort,\n            amountToNeutralize,\n            collateralOwed,\n            collateralType,\n            qTokenLong\n        );\n    }\n\n    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.\n    /// @param _qToken The QToken to be approved.\n    /// @param _spender The address of the spender.\n    /// @param _value The amount of tokens to be approved for spending.\n    /// @param _deadline Timestamp at which the permit signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _qTokenPermit(\n        address _qToken,\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IQToken(_qToken).permit(\n            _owner,\n            _spender,\n            _value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice Allows a CollateralToken owner to either approve an operator address\n    /// to spend all of their tokens on their behalf, or to remove a prior approval.\n    /// @param _owner The address of the owner of the CollateralToken.\n    /// @param _operator The address of the operator to be approved or removed.\n    /// @param _approved Whether the operator is being approved or removed.\n    /// @param _nonce The nonce for the approval through a meta transaction.\n    /// @param _deadline Timestamp at which the approval signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _collateralTokenApproval(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _nonce,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(\n                _owner,\n                _operator,\n                _approved,\n                _nonce,\n                _deadline,\n                _v,\n                _r,\n                _s\n            );\n    }\n\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n\n    /// @notice Checks if the given QToken has not expired yet, reverting otherwise\n    /// @param _qToken The address of the QToken to check.\n    function _checkIfUnexpiredQToken(address _qToken) internal view {\n        require(\n            IQToken(_qToken).expiryTime() > block.timestamp,\n            \"Controller: Cannot mint expired options\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "QToken.sol",
            "QTokenStringUtils.sol",
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "\n\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n"
                ],
                "Type": " Incorrect strike price displayed in name/symbol of qToken ",
                "Description": "\n_slice() in options/QTokenStringUtils.sol cut a string into string[start:end] However, while fetching bytes, it uses bytes(_s)[_start+1] instead of bytes(_s)[_start+i]. This causes the return string to be composed of _s[start]*(_end-_start). The result of this function is then used to represent the decimal part of strike price in name/symbol of qToken, leading to potential confusion over the actual value of options.\n\n\nERC20 tokens are usually identified by their name and symbol. If the symbols are incorrect, confusions may occur. Some may argue that even if names and symbols are not accurate, it is still possible to identify correct information/usage of tokens by querying the provided view functions and looking at its interactions with other contracts. However, the truth is many users of those tokens are not very tech savvy, and it is reasonable to believe a large proportion of users are not equipped with enough knowledge, or not willing to dig further than the plain symbols and names. This highlights the importance of maintaining a correct facade for ERC20 tokens.\n\nThe bug demonstrated here shows that any qToken with decimals in its strike price will be misdisplayed, and the maximal difference between actual price and displayed one can be up to 0.1 BUSD.\n\nThe exploit can be outlined through the following steps:\n\n*   Alice created a call option with strike price 10000.90001. The expected symbol should for this qToken should be : ROLLA WETH 31-December-2022 10000.90001 Call\n\n*   Both _qTokenName() and _qTokenSymbol() in options/QTokenStringUtils.sol use _displayedStrikePrice() to get the strike price string which should be 10000.90001\n\n<https://github.com/RollaProject/quant-protocol/blob/98639a3/contracts/options/QTokenStringUtils.sol#L38<br\n<https://github.com/RollaProject/quant-protocol/blob/98639a3/contracts/options/QTokenStringUtils.sol#L90<br\n\n        function _qTokenName(\n            address _quantConfig,\n            address _underlyingAsset,\n            address _strikeAsset,\n            uint256 _strikePrice,\n            uint256 _expiryTime,\n            bool _isCall\n        ) internal view virtual returns (string memory tokenName) {\n            string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n            string memory displayStrikePrice = _displayedStrikePrice(\n                _strikePrice,\n                _strikeAsset\n            );\n    \t\t\n            ...\n    \t\t\n            tokenName = string(\n                abi.encodePacked(\n                    \"ROLLA\",\n                    \" \",\n                    underlying,\n                    \" \",\n                    _uintToChars(day),\n                    \"-\",\n                    monthFull,\n                    \"-\",\n                    Strings.toString(year),\n                    \" \",\n                    displayStrikePrice,\n                    \" \",\n                    typeFull\n                )\n            );\n        }\n\n\n\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n\n\n*   _displayedStrikePrice() combines the quotient and the remainder to form the strike price string. The remainder use _slice to compute. In this case, the quotient is 10000 and the remainder is 90001\n\n<https://github.com/RollaProject/quant-protocol/blob/98639a3/contracts/options/QTokenStringUtils.sol#L136<br\n\n    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n            internal\n            view\n            virtual\n            returns (string memory)\n        {\n            uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n            uint256 strikePriceScale = 10strikePriceDigits;\n            uint256 remainder = _strikePrice % strikePriceScale;\n            uint256 quotient = _strikePrice / strikePriceScale;\n            string memory quotientStr = Strings.toString(quotient);\n\n            if (remainder == 0) {\n                return quotientStr;\n            }\n\n            uint256 trailingZeroes;\n            while (remainder % 10 == 0) {\n                remainder /= 10;\n                trailingZeroes++;\n            }\n\n            // pad the number with \"1 + starting zeroes\"\n            remainder += 10(strikePriceDigits trailingZeroes);\n\n            string memory tmp = Strings.toString(remainder);\n            tmp = _slice(tmp, 1, (1 + strikePriceDigits) trailingZeroes);\n\n            return string(abi.encodePacked(quotientStr, \".\", tmp));\n        }\n\n*   However inside the loop of _slice(), slice[i] = bytes(_s)[_start + 1]; lead to an incorrect string, which is 90001\n\n<https://github.com/RollaProject/quant-protocol/blob/98639a3/contracts/options/QTokenStringUtils.sol#L206<br\n\n        function _slice(\n            string memory _s,\n            uint256 _start,\n            uint256 _end\n        ) internal pure virtual returns (string memory) {\n            uint256 range = _end _start;\n            bytes memory slice = new bytes(range);\n            for (uint256 i = 0; i < range; ) {\n                slice[i] = bytes(_s)[_start + 1];\n                unchecked {\n                    ++i;\n                }\n            }\n\n            return string(slice);\n        }\n\n*   The final qtoken name now becomes ROLLA WETH 31-December-2022 10000.99999 Call, which results in confusion over the actual value of options.\n\n",
                "Repair": "\nFix the bug in the _slice()\n\n        function _slice(\n            string memory _s,\n            uint256 _start,\n            uint256 _end\n        ) internal pure virtual returns (string memory) {\n            uint256 range = _end _start;\n            bytes memory slice = new bytes(range);\n            for (uint256 i = 0; i < range; ) {\n                slice[i] = bytes(_s)[_start + i];\n                unchecked {\n                    ++i;\n                }\n            }\n\n            return string(slice);\n        }\n\n0xca11 (Rolla) confirmed, resolved, and commented(https://github.com/code-423n4/2022-03-rolla-findings/issues/28#issuecomment-1102139409):\n  Resolved in RollaProject/quant-protocol#77(https://github.com/RollaProject/quant-protocol/pull/77)\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IPriceRegistry.sol\";\nimport \"./libraries/FundsCalculator.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/QuantMath.sol\";\n\n/// @title For calculating collateral requirements and payouts for options and spreads\n/// @author Rolla\n/// @dev Uses fixed point arithmetic from the QuantMath library.\ncontract QuantCalculator is IQuantCalculator {\n    using QuantMath for uint256;\n    using QuantMath for int256;\n    using QuantMath for QuantMath.FixedPointInt;\n\n    /// @inheritdoc IQuantCalculator\n    uint8 public constant override OPTIONS_DECIMALS = 18;\n\n    /// @inheritdoc IQuantCalculator\n    uint8 public immutable override strikeAssetDecimals;\n\n    /// @inheritdoc IQuantCalculator\n    address public immutable override optionsFactory;\n\n    /// @notice Checks that the QToken was created through the configured OptionsFactory\n    modifier validQToken(address _qToken) {\n        require(\n            IOptionsFactory(optionsFactory).isQToken(_qToken),\n            \"QuantCalculator: Invalid QToken address\"\n        );\n\n        _;\n    }\n\n    /// @notice Checks that the QToken used as collateral for a spread is either the zero address\n    /// or a QToken created through the configured OptionsFactory\n    modifier validQTokenAsCollateral(address _qTokenAsCollateral) {\n        if (_qTokenAsCollateral != address(0)) {\n            // it could be the zero address for the qTokenAsCollateral for non-spreads\n            require(\n                IOptionsFactory(optionsFactory).isQToken(_qTokenAsCollateral),\n                \"QuantCalculator: Invalid QToken address\"\n            );\n        }\n\n        _;\n    }\n\n    /// @param _strikeAssetDecimals the number of decimals used to denominate strike prices\n    /// @param _optionsFactory the address of the OptionsFactory contract\n    constructor(uint8 _strikeAssetDecimals, address _optionsFactory) {\n        strikeAssetDecimals = _strikeAssetDecimals;\n        optionsFactory = _optionsFactory;\n    }\n\n    /// @inheritdoc IQuantCalculator\n    function calculateClaimableCollateral(\n        uint256 _collateralTokenId,\n        uint256 _amount,\n        address _msgSender\n    )\n        external\n        view\n        override\n        returns (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        )\n    {\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        (address _qTokenShort, address qTokenAsCollateral) = collateralToken\n            .idToInfo(_collateralTokenId);\n\n        require(\n            _qTokenShort != address(0),\n            \"Can not claim collateral from non-existing option\"\n        );\n\n        IQToken qTokenShort = IQToken(_qTokenShort);\n\n        require(\n            block.timestamp > qTokenShort.expiryTime(),\n            \"Can not claim collateral from options before their expiry\"\n        );\n        require(\n            qTokenShort.getOptionPriceStatus() == PriceStatus.SETTLED,\n            \"Can not claim collateral before option is settled\"\n        );\n\n        amountToClaim = _amount == 0\n            ? collateralToken.balanceOf(_msgSender, _collateralTokenId)\n            : _amount;\n\n        IQuantConfig quantConfig = IOptionsFactory(optionsFactory)\n            .quantConfig();\n\n        IPriceRegistry priceRegistry = IPriceRegistry(\n            quantConfig.protocolAddresses(ProtocolValue.encode(\"priceRegistry\"))\n        );\n\n        IPriceRegistry.PriceWithDecimals memory expiryPrice = priceRegistry\n            .getSettlementPriceWithDecimals(\n                qTokenShort.oracle(),\n                qTokenShort.underlyingAsset(),\n                qTokenShort.expiryTime()\n            );\n\n        address qTokenLong;\n        QuantMath.FixedPointInt memory payoutFromLong;\n\n        if (qTokenAsCollateral != address(0)) {\n            qTokenLong = qTokenAsCollateral;\n\n            (, payoutFromLong) = FundsCalculator.getPayout(\n                qTokenLong,\n                amountToClaim,\n                OPTIONS_DECIMALS,\n                strikeAssetDecimals,\n                expiryPrice\n            );\n        } else {\n            qTokenLong = address(0);\n            payoutFromLong = int256(0).fromUnscaledInt();\n        }\n\n        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(\n            strikeAssetDecimals,\n            qTokenShort,\n            quantConfig\n        );\n\n        QuantMath.FixedPointInt memory collateralRequirement;\n        (collateralAsset, collateralRequirement) = FundsCalculator\n            .getCollateralRequirement(\n                _qTokenShort,\n                qTokenLong,\n                amountToClaim,\n                OPTIONS_DECIMALS,\n                payoutDecimals,\n                strikeAssetDecimals\n            );\n\n        (, QuantMath.FixedPointInt memory payoutFromShort) = FundsCalculator\n            .getPayout(\n                _qTokenShort,\n                amountToClaim,\n                OPTIONS_DECIMALS,\n                strikeAssetDecimals,\n                expiryPrice\n            );\n\n        returnableCollateral = payoutFromLong\n            .add(collateralRequirement)\n            .sub(payoutFromShort)\n            .toScaledUint(payoutDecimals, true);\n    }\n\n    /// @inheritdoc IQuantCalculator\n    function getNeutralizationPayout(\n        address _qTokenShort,\n        address _qTokenLong,\n        uint256 _amountToNeutralize\n    )\n        external\n        view\n        override\n        returns (address collateralType, uint256 collateralOwed)\n    {\n        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(\n            strikeAssetDecimals,\n            IQToken(_qTokenShort),\n            IOptionsFactory(optionsFactory).quantConfig()\n        );\n\n        QuantMath.FixedPointInt memory collateralOwedFP;\n        (collateralType, collateralOwedFP) = FundsCalculator\n            .getCollateralRequirement(\n                _qTokenShort,\n                _qTokenLong,\n                _amountToNeutralize,\n                OPTIONS_DECIMALS,\n                payoutDecimals,\n                strikeAssetDecimals\n            );\n\n        collateralOwed = collateralOwedFP.toScaledUint(payoutDecimals, true);\n    }\n\n    /// @inheritdoc IQuantCalculator\n    function getCollateralRequirement(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    )\n        external\n        view\n        override\n        validQToken(_qTokenToMint)\n        validQTokenAsCollateral(_qTokenForCollateral)\n        returns (address collateral, uint256 collateralAmount)\n    {\n        QuantMath.FixedPointInt memory collateralAmountFP;\n        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(\n            strikeAssetDecimals,\n            IQToken(_qTokenToMint),\n            IOptionsFactory(optionsFactory).quantConfig()\n        );\n\n        (collateral, collateralAmountFP) = FundsCalculator\n            .getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount,\n                OPTIONS_DECIMALS,\n                payoutDecimals,\n                strikeAssetDecimals\n            );\n\n        collateralAmount = collateralAmountFP.toScaledUint(\n            payoutDecimals,\n            false\n        );\n    }\n\n    /// @inheritdoc IQuantCalculator\n    function getExercisePayout(address _qToken, uint256 _amount)\n        external\n        view\n        override\n        validQToken(_qToken)\n        returns (\n            bool isSettled,\n            address payoutToken,\n            uint256 payoutAmount\n        )\n    {\n        IQToken qToken = IQToken(_qToken);\n        isSettled = qToken.getOptionPriceStatus() == PriceStatus.SETTLED;\n        if (!isSettled) {\n            return (false, address(0), 0);\n        } else {\n            isSettled = true;\n        }\n\n        QuantMath.FixedPointInt memory payout;\n\n        IQuantConfig quantConfig = IOptionsFactory(optionsFactory)\n            .quantConfig();\n\n        IPriceRegistry priceRegistry = IPriceRegistry(\n            quantConfig.protocolAddresses(ProtocolValue.encode(\"priceRegistry\"))\n        );\n\n        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(\n            strikeAssetDecimals,\n            qToken,\n            quantConfig\n        );\n\n        address underlyingAsset = qToken.underlyingAsset();\n\n        IPriceRegistry.PriceWithDecimals memory expiryPrice = priceRegistry\n            .getSettlementPriceWithDecimals(\n                qToken.oracle(),\n                underlyingAsset,\n                qToken.expiryTime()\n            );\n\n        (payoutToken, payout) = FundsCalculator.getPayout(\n            _qToken,\n            _amount,\n            OPTIONS_DECIMALS,\n            strikeAssetDecimals,\n            expiryPrice\n        );\n\n        payoutAmount = payout.toScaledUint(payoutDecimals, true);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./SignedConverter.sol\";\n\n/**\n * @title QuantMath\n * @author Rolla\n * @notice FixedPoint library\n */\nlibrary QuantMath {\n    using SignedConverter for int256;\n    using SignedConverter for uint256;\n\n    struct FixedPointInt {\n        int256 value;\n    }\n\n    int256 private constant _SCALING_FACTOR = 1e27;\n    uint256 private constant _BASE_DECIMALS = 27;\n\n    /**\n     * @notice constructs an `FixedPointInt` from an unscaled int, e.g., `b=5` gets stored internally as `5**27`.\n     * @param a int to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledInt(int256 a)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a * _SCALING_FACTOR);\n    }\n\n    /**\n     * @notice constructs an FixedPointInt from an scaled uint with {_decimals} decimals\n     * Examples:\n     * (1)  USDC    decimals = 6\n     *      Input:  5 * 1e6 USDC  =>    Output: 5 * 1e27 (FixedPoint 8.0 USDC)\n     * (2)  cUSDC   decimals = 8\n     *      Input:  5 * 1e6 cUSDC =>    Output: 5 * 1e25 (FixedPoint 0.08 cUSDC)\n     * @param _a uint256 to convert into a FixedPoint.\n     * @param _decimals  original decimals _a has\n     * @return the converted FixedPoint, with 27 decimals.\n     */\n    function fromScaledUint(uint256 _a, uint256 _decimals)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        FixedPointInt memory fixedPoint;\n\n        if (_decimals == _BASE_DECIMALS) {\n            fixedPoint = FixedPointInt(_a.uintToInt());\n        } else if (_decimals > _BASE_DECIMALS) {\n            uint256 exp = _decimals - _BASE_DECIMALS;\n            fixedPoint = FixedPointInt((_a / 10**exp).uintToInt());\n        } else {\n            uint256 exp = _BASE_DECIMALS - _decimals;\n            fixedPoint = FixedPointInt((_a * 10**exp).uintToInt());\n        }\n\n        return fixedPoint;\n    }\n\n    /**\n     * @notice convert a FixedPointInt number to an uint256 with a specific number of decimals\n     * @param _a FixedPointInt to convert\n     * @param _decimals number of decimals that the uint256 should be scaled to\n     * @param _roundDown True to round down the result, False to round up\n     * @return the converted uint256\n     */\n    function toScaledUint(\n        FixedPointInt memory _a,\n        uint256 _decimals,\n        bool _roundDown\n    ) internal pure returns (uint256) {\n        uint256 scaledUint;\n\n        if (_decimals == _BASE_DECIMALS) {\n            scaledUint = _a.value.intToUint();\n        } else if (_decimals > _BASE_DECIMALS) {\n            uint256 exp = _decimals - _BASE_DECIMALS;\n            scaledUint = (_a.value).intToUint() * 10**exp;\n        } else {\n            uint256 exp = _BASE_DECIMALS - _decimals;\n            uint256 tailing;\n            if (!_roundDown) {\n                uint256 remainer = (_a.value).intToUint() % 10**exp;\n                if (remainer > 0) tailing = 1;\n            }\n            scaledUint = (_a.value).intToUint() / 10**exp + tailing;\n        }\n\n        return scaledUint;\n    }\n\n    /**\n     * @notice add two signed integers, a + b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return sum of the two signed integers\n     */\n    function add(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a.value + b.value);\n    }\n\n    /**\n     * @notice subtract two signed integers, a-b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return difference of two signed integers\n     */\n    function sub(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a.value - b.value);\n    }\n\n    /**\n     * @notice multiply two signed integers, a by b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return mul of two signed integers\n     */\n    function mul(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);\n    }\n\n    /**\n     * @notice divide two signed integers, a by b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return div of two signed integers\n     */\n    function div(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);\n    }\n\n    /**\n     * @notice minimum between two signed integers, a and b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return min of two signed integers\n     */\n    function min(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return a.value < b.value ? a : b;\n    }\n\n    /**\n     * @notice maximum between two signed integers, a and b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return max of two signed integers\n     */\n    function max(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return a.value > b.value ? a : b;\n    }\n\n    /**\n     * @notice is a is equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if equal, False if not\n     */\n    function isEqual(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value == b.value;\n    }\n\n    /**\n     * @notice is a greater than b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a > b, False if not\n     */\n    function isGreaterThan(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value > b.value;\n    }\n\n    /**\n     * @notice is a greater than or equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a >= b, False if not\n     */\n    function isGreaterThanOrEqual(\n        FixedPointInt memory a,\n        FixedPointInt memory b\n    ) internal pure returns (bool) {\n        return a.value >= b.value;\n    }\n\n    /**\n     * @notice is a is less than b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a < b, False if not\n     */\n    function isLessThan(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value < b.value;\n    }\n\n    /**\n     * @notice is a less than or equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a <= b, False if not\n     */\n    function isLessThanOrEqual(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value <= b.value;\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./QuantConfig.sol\";\nimport \"./utils/EIP712MetaTransaction.sol\";\nimport \"./utils/OperateProxy.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IOracleRegistry.sol\";\nimport \"./interfaces/ICollateralToken.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IOperateProxy.sol\";\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./libraries/ProtocolValue.sol\";\nimport \"./libraries/QuantMath.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/Actions.sol\";\n\n/// @title The main entry point in the Quant Protocol\n/// @author Rolla\n/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.\n/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.\n/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.\n/// @dev This contract is an upgradeable proxy, and it supports meta transactions.\n/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the\n/// OptionsFactory first.\ncontract Controller is\n    IController,\n    EIP712MetaTransaction,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using QuantMath for QuantMath.FixedPointInt;\n    using Actions for ActionArgs;\n\n    /// @inheritdoc IController\n    address public override optionsFactory;\n\n    /// @inheritdoc IController\n    address public override operateProxy;\n\n    /// @inheritdoc IController\n    address public override quantCalculator;\n\n    /// @inheritdoc IController\n    function operate(ActionArgs[] memory _actions)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        uint256 length = _actions.length;\n        for (uint256 i = 0; i < length; ) {\n            ActionArgs memory action = _actions[i];\n\n            if (action.actionType == ActionType.MintOption) {\n                (address to, address qToken, uint256 amount) = action\n                    .parseMintOptionArgs();\n                _mintOptionsPosition(to, qToken, amount);\n            } else if (action.actionType == ActionType.MintSpread) {\n                (\n                    address qTokenToMint,\n                    address qTokenForCollateral,\n                    uint256 amount\n                ) = action.parseMintSpreadArgs();\n                _mintSpread(qTokenToMint, qTokenForCollateral, amount);\n            } else if (action.actionType == ActionType.Exercise) {\n                (address qToken, uint256 amount) = action.parseExerciseArgs();\n                _exercise(qToken, amount);\n            } else if (action.actionType == ActionType.ClaimCollateral) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseClaimCollateralArgs();\n                _claimCollateral(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.Neutralize) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseNeutralizeArgs();\n                _neutralizePosition(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.QTokenPermit) {\n                (\n                    address qToken,\n                    address owner,\n                    address spender,\n                    uint256 value,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseQTokenPermitArgs();\n                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);\n            } else if (\n                action.actionType == ActionType.CollateralTokenApproval\n            ) {\n                (\n                    address owner,\n                    address operator,\n                    bool approved,\n                    uint256 nonce,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseCollateralTokenApprovalArgs();\n                _collateralTokenApproval(\n                    owner,\n                    operator,\n                    approved,\n                    nonce,\n                    deadline,\n                    v,\n                    r,\n                    s\n                );\n            } else {\n                require(\n                    action.actionType == ActionType.Call,\n                    \"Controller: Invalid action type\"\n                );\n                (address callee, bytes memory data) = action.parseCallArgs();\n                _call(callee, data);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n\n    // @inheritdoc IController\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _optionsFactory,\n        address _quantCalculator\n    ) public override initializer {\n        require(\n            _optionsFactory != address(0),\n            \"Controller: invalid OptionsFactory address\"\n        );\n        require(\n            _quantCalculator != address(0),\n            \"Controller: invalid QuantCalculator address\"\n        );\n\n        __ReentrancyGuard_init();\n        EIP712MetaTransaction.initializeEIP712(_name, _version);\n        optionsFactory = _optionsFactory;\n\n        /// @dev Unless this line is removed, a new OperateProxy will be created\n        /// during each upgrade. So make sure any application that requires approving\n        /// the OperateProxy to spend funds is aware of this.\n        operateProxy = address(new OperateProxy());\n\n        quantCalculator = _quantCalculator;\n    }\n\n    /// @notice Mints options for a given QToken, which must have been previously created in\n    /// the configured OptionsFactory.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset, and then this function can be called, pulling the collateral\n    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.\n    /// Note that QTokens represent a long position, giving holders the ability to exercise options\n    /// after expiry, while CollateralTokens represent a short position, giving holders the ability\n    /// to claim the collateral after expiry.\n    /// @param _to The address to which the QTokens and CollateralTokens will be minted.\n    /// @param _qToken The QToken that represents the long position for the option to be minted.\n    /// @param _amount The amount of options to be minted.\n    function _mintOptionsPosition(\n        address _to,\n        address _qToken,\n        uint256 _amount\n    ) internal returns (uint256) {\n        IQToken qToken = IQToken(_qToken);\n\n        // get the collateral required to mint the specified amount of options\n        // the zero address is passed as the second argument as it's only used\n        // for spreads\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(_qToken, address(0), _amount);\n\n        _checkIfUnexpiredQToken(_qToken);\n\n        // check if the oracle set during the option's creation through the OptionsFactory\n        // is an active oracle in the OracleRegistry\n        require(\n            IOracleRegistry(\n                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(\n                    ProtocolValue.encode(\"oracleRegistry\")\n                )\n            ).isOracleActive(qToken.oracle()),\n            \"Controller: Can't mint an options position as the oracle is inactive\"\n        );\n\n        // pull the required collateral from the caller/signer\n        IERC20(collateral).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            collateralAmount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Mint the options to the sender's address\n        qToken.mint(_to, _amount);\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qToken,\n            address(0)\n        );\n\n        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,\n        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory\n        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);\n\n        emit OptionsPositionMinted(\n            _to,\n            _msgSender(),\n            _qToken,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Creates a spread position from an option to long and another option to short.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset in cases of a debit spread.\n    /// @param _qTokenToMint The QToken for the option to be long.\n    /// @param _qTokenForCollateral The QToken for the option to be short.\n    /// @param _amount The amount of long options to be minted.\n    function _mintSpread(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    ) internal returns (uint256) {\n        require(\n            _qTokenToMint != _qTokenForCollateral,\n            \"Controller: Can only create a spread with different tokens\"\n        );\n\n        IQToken qTokenToMint = IQToken(_qTokenToMint);\n        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);\n\n        // Calculate the extra collateral required to create the spread.\n        // A positive value for debit spreads and zero for credit spreads.\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount\n            );\n\n        _checkIfUnexpiredQToken(_qTokenToMint);\n        _checkIfUnexpiredQToken(_qTokenForCollateral);\n\n        // Burn the QToken being shorted\n        qTokenForCollateral.burn(_msgSender(), _amount);\n\n        // Transfer in any collateral required for the spread\n        if (collateralAmount > 0) {\n            IERC20(collateral).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                collateralAmount\n            );\n        }\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Check if the CollateralToken representing this specific spread has already been created\n        // Create it if it hasn't\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qTokenToMint,\n            _qTokenForCollateral\n        );\n        (, address qTokenAsCollateral) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n        if (qTokenAsCollateral == address(0)) {\n            require(\n                collateralTokenId ==\n                    collateralToken.createCollateralToken(\n                        _qTokenToMint,\n                        _qTokenForCollateral\n                    ),\n                \"Controller: failed creating the collateral token to represent the spread\"\n            );\n        }\n\n        // Mint the tokens for the new spread position\n        collateralToken.mintCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            _amount\n        );\n        qTokenToMint.mint(_msgSender(), _amount);\n\n        emit SpreadMinted(\n            _msgSender(),\n            _qTokenToMint,\n            _qTokenForCollateral,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Closes a long position after the option's expiry.\n    /// @dev Pass an `_amount` of 0 to close the entire position.\n    /// @param _qToken The QToken representing the long position to be closed.\n    /// @param _amount The amount of options to exercise.\n    function _exercise(address _qToken, uint256 _amount) internal {\n        IQToken qToken = IQToken(_qToken);\n        require(\n            block.timestamp > qToken.expiryTime(),\n            \"Controller: Can not exercise options before their expiry\"\n        );\n\n        uint256 amountToExercise = _amount;\n        // if the amount is 0, the entire position will be exercised\n        if (amountToExercise == 0) {\n            amountToExercise = qToken.balanceOf(_msgSender());\n        }\n\n        // Use the QuantCalculator to check how much the sender/signer is due.\n        // Will only be a positive value for options that expired In The Money.\n        (\n            bool isSettled,\n            address payoutToken,\n            uint256 exerciseTotal\n        ) = IQuantCalculator(quantCalculator).getExercisePayout(\n                address(qToken),\n                amountToExercise\n            );\n\n        require(isSettled, \"Controller: Cannot exercise unsettled options\");\n\n        // Burn the long tokens\n        qToken.burn(_msgSender(), amountToExercise);\n\n        // Transfer any profit due after expiration\n        if (exerciseTotal > 0) {\n            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);\n        }\n\n        emit OptionsExercised(\n            _msgSender(),\n            address(qToken),\n            amountToExercise,\n            exerciseTotal,\n            payoutToken\n        );\n    }\n\n    /// @notice Closes a short position after the option's expiry.\n    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.\n    /// @param _amount The size of the position to close.\n    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        uint256 collateralTokenId = _collateralTokenId;\n\n        // Use the QuantCalculator to check how much collateral the sender/signer is due.\n        (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(\n                collateralTokenId,\n                _amount,\n                _msgSender()\n            );\n\n        // Burn the short tokens\n        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim\n        );\n\n        // Transfer any collateral due after expiration\n        if (returnableCollateral > 0) {\n            IERC20(collateralAsset).safeTransfer(\n                _msgSender(),\n                returnableCollateral\n            );\n        }\n\n        emit CollateralClaimed(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim,\n            returnableCollateral,\n            collateralAsset\n        );\n    }\n\n    /// @notice Closes a neutral position, claiming all the collateral required to create it.\n    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.\n    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.\n    /// @param _amount The size of the position to close.\n    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        /// @dev Put these values in the stack to save gas from having to read\n        /// from calldata\n        (uint256 collateralTokenId, uint256 amount) = (\n            _collateralTokenId,\n            _amount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n\n        //get the amount of CollateralTokens owned\n        uint256 collateralTokensOwned = collateralToken.balanceOf(\n            _msgSender(),\n            collateralTokenId\n        );\n\n        //get the amount of QTokens owned\n        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());\n\n        // the size of the position that can be neutralized\n        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned\n            ? qTokensOwned\n            : collateralTokensOwned;\n\n        // make sure that the amount passed is not greater than the amount that can be neutralized\n        uint256 amountToNeutralize;\n        if (amount != 0) {\n            require(\n                amount <= maxNeutralizable,\n                \"Controller: Tried to neutralize more than balance\"\n            );\n            amountToNeutralize = amount;\n        } else {\n            amountToNeutralize = maxNeutralizable;\n        }\n\n        // use the QuantCalculator to check how much collateral the sender/signer is due\n        // for closing the neutral position\n        (address collateralType, uint256 collateralOwed) = IQuantCalculator(\n            quantCalculator\n        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);\n\n        // burn the short tokens\n        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);\n\n        // burn the long tokens\n        collateralToken.burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToNeutralize\n        );\n\n        // tranfer the collateral owed\n        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);\n\n        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)\n        if (qTokenLong != address(0)) {\n            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);\n        }\n\n        emit NeutralizePosition(\n            _msgSender(),\n            qTokenShort,\n            amountToNeutralize,\n            collateralOwed,\n            collateralType,\n            qTokenLong\n        );\n    }\n\n    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.\n    /// @param _qToken The QToken to be approved.\n    /// @param _spender The address of the spender.\n    /// @param _value The amount of tokens to be approved for spending.\n    /// @param _deadline Timestamp at which the permit signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _qTokenPermit(\n        address _qToken,\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IQToken(_qToken).permit(\n            _owner,\n            _spender,\n            _value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice Allows a CollateralToken owner to either approve an operator address\n    /// to spend all of their tokens on their behalf, or to remove a prior approval.\n    /// @param _owner The address of the owner of the CollateralToken.\n    /// @param _operator The address of the operator to be approved or removed.\n    /// @param _approved Whether the operator is being approved or removed.\n    /// @param _nonce The nonce for the approval through a meta transaction.\n    /// @param _deadline Timestamp at which the approval signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _collateralTokenApproval(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _nonce,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(\n                _owner,\n                _operator,\n                _approved,\n                _nonce,\n                _deadline,\n                _v,\n                _r,\n                _s\n            );\n    }\n\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n\n    /// @notice Checks if the given QToken has not expired yet, reverting otherwise\n    /// @param _qToken The address of the QToken to check.\n    function _checkIfUnexpiredQToken(address _qToken) internal view {\n        require(\n            IQToken(_qToken).expiryTime() > block.timestamp,\n            \"Controller: Cannot mint expired options\"\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\nimport \"../interfaces/IAssetsRegistry.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../libraries/ProtocolValue.sol\";\n\nabstract contract QTokenStringUtils {\n    /// @notice get the ERC20 token symbol from the AssetsRegistry\n    /// @dev the asset is assumed to be in the AssetsRegistry since QTokens\n    /// must be created through the OptionsFactory, which performs that check\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _asset address of the asset in the AssetsRegistry\n    /// @return assetSymbol string stored as the ERC20 token symbol\n    function _assetSymbol(address _quantConfig, address _asset)\n        internal\n        view\n        virtual\n        returns (string memory assetSymbol)\n    {\n        (, assetSymbol, ) = IAssetsRegistry(\n            IQuantConfig(_quantConfig).protocolAddresses(\n                ProtocolValue.encode(\"assetsRegistry\")\n            )\n        ).assetProperties(_asset);\n    }\n\n    /// @notice generates the name for an option\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _underlyingAsset asset that the option references\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenName name string for the QToken\n    function _qTokenName(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenName) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (, string memory typeFull) = _getOptionType(_isCall);\n\n        // get option month string\n        (, string memory monthFull) = _getMonth(month);\n\n        /// concatenated name string\n        tokenName = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \" \",\n                underlying,\n                \" \",\n                _uintToChars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                \" \",\n                typeFull\n            )\n        );\n    }\n\n    /// @notice generates the symbol for an option\n    /// @param _underlyingAsset asset that the option references\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenSymbol symbol string for the QToken\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n\n    /// @dev convert the option strike price scaled to a human readable value\n    /// @param _strikePrice the option strike price scaled by 1e20\n    /// @return strike price string\n    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n        uint256 strikePriceScale = 10**strikePriceDigits;\n        uint256 remainder = _strikePrice % strikePriceScale;\n        uint256 quotient = _strikePrice / strikePriceScale;\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) {\n            return quotientStr;\n        }\n\n        uint256 trailingZeroes;\n        while (remainder % 10 == 0) {\n            remainder /= 10;\n            trailingZeroes++;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(strikePriceDigits - trailingZeroes);\n\n        string memory tmp = Strings.toString(remainder);\n        tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);\n\n        return string(abi.encodePacked(quotientStr, \".\", tmp));\n    }\n\n    /// @dev get the string representation of the option type\n    /// @return a 1 character representation of the option type\n    /// @return a full length string of the option type\n    function _getOptionType(bool _isCall)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        return _isCall ? (\"C\", \"Call\") : (\"P\", \"Put\");\n    }\n\n    /// @dev get the representation of a number using 2 characters, adding a leading 0 if it's one digit,\n    /// and two trailing digits if it's a 3 digit number\n    /// @return 2 characters that correspond to a number\n    function _uintToChars(uint256 _number)\n        internal\n        pure\n        virtual\n        returns (string memory)\n    {\n        if (_number > 99) {\n            _number %= 100;\n        }\n\n        string memory str = Strings.toString(_number);\n\n        if (_number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n\n        return str;\n    }\n\n    /// @dev cut a string into string[start:end]\n    /// @param _s string to cut\n    /// @param _start the starting index\n    /// @param _end the ending index (not inclusive)\n    /// @return the indexed string\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure virtual returns (string memory) {\n        uint256 range = _end - _start;\n        bytes memory slice = new bytes(range);\n        for (uint256 i = 0; i < range; ) {\n            slice[i] = bytes(_s)[_start + 1];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return string(slice);\n    }\n\n    /// @dev get the string representations of a month\n    /// @return a 3 character representation\n    /// @return a full length string representation\n    function _getMonth(uint256 _month)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../libraries/Actions.sol\";\n\ninterface IController {\n    /// @notice emitted after a new position is created\n    /// @param mintedTo address that received both QTokens and CollateralTokens\n    /// @param minter address that provided collateral and created the position\n    /// @param qToken address of the QToken minted\n    /// @param optionsAmount amount of options minted\n    /// @param collateralAsset asset provided as collateral to create the position\n    /// @param collateralAmount amount of collateral provided\n    event OptionsPositionMinted(\n        address indexed mintedTo,\n        address indexed minter,\n        address indexed qToken,\n        uint256 optionsAmount,\n        address collateralAsset,\n        uint256 collateralAmount\n    );\n\n    /// @notice emitted after a spread position is created\n    /// @param account address that created the spread position, receiving both QTokens and CollateralTokens\n    /// @param qTokenToMint QToken of the option the position is going long on\n    /// @param qTokenForCollateral QToken of the option the position is shorting\n    /// @param optionsAmount amount of qTokenToMint options minted\n    /// @param collateralAsset asset provided as collateral to create the position (if debit spread)\n    /// @param collateralAmount amount of collateral provided (if debit spread)\n    event SpreadMinted(\n        address indexed account,\n        address indexed qTokenToMint,\n        address indexed qTokenForCollateral,\n        uint256 optionsAmount,\n        address collateralAsset,\n        uint256 collateralAmount\n    );\n\n    /// @notice emitted after a QToken is used to close a long position after expiry\n    /// @param account address that used the QToken to exercise the position\n    /// @param qToken address of the QToken representing the long position\n    /// @param amountExercised amount of options exercised\n    /// @param payout amount received from exercising the options\n    /// @param payoutAsset asset received after exercising the options\n    event OptionsExercised(\n        address indexed account,\n        address indexed qToken,\n        uint256 amountExercised,\n        uint256 payout,\n        address payoutAsset\n    );\n\n    /// @notice emitted after both QTokens and CollateralTokens are used to claim the initial collateral\n    /// that was used to create the position\n    /// @param account address that used the QTokens and CollateralTokens to claim the collateral\n    /// @param qToken address of the QToken representing the long position\n    /// @param amountNeutralized amount of options that were used to claim the collateral\n    /// @param collateralReclaimed amount of collateral returned\n    /// @param collateralAsset asset returned after claiming the collateral\n    /// @param longTokenReturned QToken returned if neutralizing a spread position\n    event NeutralizePosition(\n        address indexed account,\n        address qToken,\n        uint256 amountNeutralized,\n        uint256 collateralReclaimed,\n        address collateralAsset,\n        address longTokenReturned\n    );\n\n    /// @notice emitted after a CollateralToken is used to close a short position after expiry\n    /// @param account address that used the CollateralToken to close the position\n    /// @param collateralTokenId ERC1155 id of the CollateralToken representing the short position\n    /// @param amountClaimed amount of CollateralToken used to close the position\n    /// @param collateralReturned amount returned of the asset used to mint the option\n    /// @param collateralAsset asset returned after claiming the collateral, i.e. the same used when minting the option\n    event CollateralClaimed(\n        address indexed account,\n        uint256 indexed collateralTokenId,\n        uint256 amountClaimed,\n        uint256 collateralReturned,\n        address collateralAsset\n    );\n\n    /// @notice The main entry point in the Quant Protocol. This function takes an array of actions\n    /// and executes them in order. Actions are passed encoded as ActionArgs structs, and then for each\n    /// different action, the relevant arguments are parsed and passed to the respective internal function\n    /// @dev For documentation of each individual action, see the corresponding internal function in Controller.sol\n    /// @param _actions array of ActionArgs structs, each representing an action to be executed\n    /// @return boolean indicating whether the actions were successfully executed\n    function operate(ActionArgs[] memory _actions) external returns (bool);\n\n    /// @notice Upgradable proxy initialization function called during deployment and upgrades\n    function initialize(\n        string memory,\n        string memory,\n        address,\n        address\n    ) external;\n\n    /// @notice Address of the OptionsFactory contract\n    function optionsFactory() external view returns (address);\n\n    /// @notice Address of th OperateProxy contract deployed through the initialize function\n    function operateProxy() external view returns (address);\n\n    /// @notice Address of the QuantCalculator being used\n    function quantCalculator() external view returns (address);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./IQuantConfig.sol\";\nimport \"./ICollateralToken.sol\";\n\ninterface IOptionsFactory {\n    /// @notice emitted when the factory creates a new option\n    event OptionCreated(\n        address qTokenAddress,\n        address creator,\n        address indexed underlying,\n        address oracle,\n        uint256 strikePrice,\n        uint256 expiry,\n        uint256 collateralTokenId,\n        uint256 allOptionsLength,\n        bool isCall\n    );\n\n    /// @notice Creates new options (QToken + CollateralToken)\n    /// @dev The CREATE2 opcode is used to deterministically deploy new QTokens\n    /// @param _underlyingAsset asset that the option references\n    /// @param _oracle price oracle for the option underlying\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    function createOption(\n        address _underlyingAsset,\n        address _oracle,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) external returns (address, uint256);\n\n    /// @notice array of all the created QTokens\n    function qTokens(uint256) external view returns (address);\n\n    function quantConfig() external view returns (IQuantConfig);\n\n    function collateralToken() external view returns (ICollateralToken);\n\n    function qTokenAddressToCollateralTokenId(address)\n        external\n        view\n        returns (uint256);\n\n    /// @notice get the address at which a new QToken with the given parameters would be deployed\n    /// @notice return the exact address the QToken will be deployed at with OpenZeppelin's Create2\n    /// library computeAddress function\n    /// @param _underlyingAsset asset that the option references\n    /// @param _oracle price oracle for the option underlying\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return the address where a QToken would be deployed\n    function getTargetQTokenAddress(\n        address _underlyingAsset,\n        address _oracle,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) external view returns (address);\n\n    /// @notice get the id that a CollateralToken with the given parameters would have\n    /// @param _underlyingAsset asset that the option references\n    /// @param _oracle price oracle for the option underlying\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _qTokenAsCollateral initial spread collateral\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return the id that a CollateralToken would have\n    function getTargetCollateralTokenId(\n        address _underlyingAsset,\n        address _oracle,\n        address _qTokenAsCollateral,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) external view returns (uint256);\n\n    /// @notice get the CollateralToken id for an already created CollateralToken,\n    /// if no QToken has been created with these parameters, it will return 0\n    /// @param _underlyingAsset asset that the option references\n    /// @param _oracle price oracle for the option underlying\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _qTokenAsCollateral initial spread collateral\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return id of the requested CollateralToken\n    function getCollateralToken(\n        address _underlyingAsset,\n        address _oracle,\n        address _qTokenAsCollateral,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) external view returns (uint256);\n\n    /// @notice get the QToken address for an already created QToken, if no QToken has been created\n    /// with these parameters, it will return the zero address\n    /// @param _underlyingAsset asset that the option references\n    /// @param _oracle price oracle for the option underlying\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return address of the requested QToken\n    function getQToken(\n        address _underlyingAsset,\n        address _oracle,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) external view returns (address);\n\n    /// @notice get the total number of options created by the factory\n    /// @return length of the options array\n    function getOptionsLength() external view returns (uint256);\n\n    /// @notice checks if an address is a QToken\n    /// @return true if the given address represents a registered QToken.\n    /// false otherwise\n    function isQToken(address) external view returns (bool);\n\n    /// @notice get the strike asset used for options created by the factory\n    /// @return the strike asset address\n    function strikeAsset() external view returns (address);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IAssetsRegistry {\n    /// @notice emitted when a new asset is added to the registry\n    /// @param underlying address of the asset\n    /// @param name name of the asset\n    /// @param symbol symbol of the asset\n    /// @param decimals the amount of decimals the asset has\n    event AssetAdded(\n        address indexed underlying,\n        string name,\n        string symbol,\n        uint8 decimals\n    );\n\n    /// @notice Add a new asset to the registry\n    /// @dev It will revert when trying to add an asset with the same address twice\n    /// @dev Can only be called by addresses with the ASSETS_REGISTRY_MANAGER_ROLE role\n    /// @param _underlying address of the asset\n    /// @param _name name of the asset\n    /// @param _symbol symbol of the asset\n    /// @param _decimals the amount of decimals the asset has\n    function addAsset(\n        address _underlying,\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) external;\n\n    /// @notice Add a new asset to the registry, calling the optional ERC20 methods\n    /// to get its name, symbol and decimals\n    /// @param _underlying address of the asset\n    function addAssetWithOptionalERC20Methods(address _underlying) external;\n\n    /// @notice Returns the name, symbol and decimals of an asset that's already in the registry\n    /// @dev Will return empty strings and zero for non-existent assets\n    /// @return name asset's name\n    /// @return symbol asset's symbol\n    /// @return decimals asset's decimals\n    function assetProperties(address asset)\n        external\n        view\n        returns (\n            string memory name,\n            string memory symbol,\n            uint8 decimals\n        );\n\n    /// @notice Returns the address of the asset at the given index\n    /// @param index index of the asset in the registry\n    /// @return asset address of the asset at the given index\n    function registeredAssets(uint256 index)\n        external\n        view\n        returns (address asset);\n\n    /// @notice Returns the number of assets in the registry\n    /// @return length number of assets in the registry\n    function getAssetsLength() external view returns (uint256 length);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./QuantMath.sol\";\nimport \"../options/QToken.sol\";\nimport \"../interfaces/IPriceRegistry.sol\";\n\n/// @title For calculating collateral requirements and payouts for options and spreads\n/// in a fixed point format\n/// @author Rolla\nlibrary FundsCalculator {\n    using QuantMath for uint256;\n    using QuantMath for int256;\n    using QuantMath for QuantMath.FixedPointInt;\n\n    struct OptionPayoutInput {\n        QuantMath.FixedPointInt strikePrice;\n        QuantMath.FixedPointInt expiryPrice;\n        QuantMath.FixedPointInt amount;\n    }\n\n    /// @notice Calculates payout of an option post-expiry from a qToken address\n    /// @param _qToken the address of the qToken (option) which is being exercised\n    /// @param _amount the amount of the qToken which is being exercised\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @param _expiryPrice the expiry price of the option with the amount of decimals\n    /// @return payoutToken the address of the payout token\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayout(\n        address _qToken,\n        uint256 _amount,\n        uint8 _optionsDecimals,\n        uint8 _strikeAssetDecimals,\n        IPriceRegistry.PriceWithDecimals memory _expiryPrice\n    )\n        internal\n        view\n        returns (\n            address payoutToken,\n            QuantMath.FixedPointInt memory payoutAmount\n        )\n    {\n        QToken qToken = QToken(_qToken);\n        bool isCall = qToken.isCall();\n\n        payoutToken = isCall ? qToken.underlyingAsset() : qToken.strikeAsset();\n\n        payoutAmount = getPayoutAmount(\n            isCall,\n            qToken.strikePrice(),\n            _amount,\n            _optionsDecimals,\n            _strikeAssetDecimals,\n            _expiryPrice\n        );\n    }\n\n    /// @notice Calculates the collateral required to mint an option or a spread\n    /// @param _qTokenToMint the desired qToken\n    /// @param _qTokenForCollateral for spreads, this is the address of the qtoken to be used as collateral.\n    /// for options, no collateral is provided so the zero address should be passed.\n    /// @param _optionsAmount the amount of options/spread to mint\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateral the address of the collateral token required\n    /// @return collateralAmount the collateral amount required as a fixed point type\n    function getCollateralRequirement(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _optionsAmount,\n        uint8 _optionsDecimals,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        view\n        returns (\n            address collateral,\n            QuantMath.FixedPointInt memory collateralAmount\n        )\n    {\n        QToken qTokenToMint = QToken(_qTokenToMint);\n        uint256 qTokenToMintStrikePrice = qTokenToMint.strikePrice();\n\n        uint256 qTokenForCollateralStrikePrice;\n\n        // check if we're getting the collateral requirement for a spread\n        if (_qTokenForCollateral != address(0)) {\n            QToken qTokenForCollateral = QToken(_qTokenForCollateral);\n            qTokenForCollateralStrikePrice = qTokenForCollateral.strikePrice();\n\n            // Check that expiries match\n            require(\n                qTokenToMint.expiryTime() == qTokenForCollateral.expiryTime(),\n                \"Controller: Can't create spreads from options with different expiries\"\n            );\n\n            // Check that the underlyings match\n            require(\n                qTokenToMint.underlyingAsset() ==\n                    qTokenForCollateral.underlyingAsset(),\n                \"Controller: Can't create spreads from options with different underlying assets\"\n            );\n\n            // Check that the option types match\n            require(\n                qTokenToMint.isCall() == qTokenForCollateral.isCall(),\n                \"Controller: Can't create spreads from options with different types\"\n            );\n\n            // Check that the options have a matching oracle\n            require(\n                qTokenToMint.oracle() == qTokenForCollateral.oracle(),\n                \"Controller: Can't create spreads from options with different oracles\"\n            );\n        } else {\n            // we're not getting the collateral requirement for a spread\n            qTokenForCollateralStrikePrice = 0;\n        }\n\n        collateralAmount = getOptionCollateralRequirement(\n            qTokenToMintStrikePrice,\n            qTokenForCollateralStrikePrice,\n            _optionsAmount,\n            qTokenToMint.isCall(),\n            _optionsDecimals,\n            _underlyingDecimals,\n            _strikeAssetDecimals\n        );\n\n        collateral = qTokenToMint.isCall()\n            ? qTokenToMint.underlyingAsset()\n            : qTokenToMint.strikeAsset();\n    }\n\n    /// @notice Calculates payout of an option post-expiry from qToken attributes\n    /// @param _isCall true if the option is a call, false for a put\n    /// @param _strikePrice the strike price of the option\n    /// @param _amount the amount of options being exercised\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @param _expiryPrice the expiry price of the option with the amount of decimals\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutAmount(\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _amount,\n        uint8 _optionsDecimals,\n        uint8 _strikeAssetDecimals,\n        IPriceRegistry.PriceWithDecimals memory _expiryPrice\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        FundsCalculator.OptionPayoutInput memory payoutInput = FundsCalculator\n            .OptionPayoutInput(\n                _strikePrice.fromScaledUint(_strikeAssetDecimals),\n                _expiryPrice.price.fromScaledUint(_expiryPrice.decimals),\n                _amount.fromScaledUint(_optionsDecimals)\n            );\n\n        if (_isCall) {\n            payoutAmount = getPayoutForCall(payoutInput);\n        } else {\n            payoutAmount = getPayoutForPut(payoutInput);\n        }\n    }\n\n    /// @notice Calculates payout of a call given option payout inputs of strike, expiry and amount\n    /// @param payoutInput strike, expiry and amount as fixed points\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutForCall(\n        FundsCalculator.OptionPayoutInput memory payoutInput\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        payoutAmount = payoutInput.expiryPrice.isGreaterThan(\n            payoutInput.strikePrice\n        )\n            ? payoutInput\n                .expiryPrice\n                .sub(payoutInput.strikePrice)\n                .mul(payoutInput.amount)\n                .div(payoutInput.expiryPrice)\n            : int256(0).fromUnscaledInt();\n    }\n\n    /// @notice Calculates payout of a put given option payout inputs of strike, expiry and amount\n    /// @param payoutInput strike, expiry and amount as fixed points\n    /// @return payoutAmount the amount to be payed out as a fixed point type\n    function getPayoutForPut(\n        FundsCalculator.OptionPayoutInput memory payoutInput\n    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {\n        payoutAmount = payoutInput.strikePrice.isGreaterThan(\n            payoutInput.expiryPrice\n        )\n            ? (payoutInput.strikePrice.sub(payoutInput.expiryPrice)).mul(\n                payoutInput.amount\n            )\n            : int256(0).fromUnscaledInt();\n    }\n\n    /// @notice Calculates the collateral required to mint an option or spread\n    /// @param _qTokenToMintStrikePrice the strike price of the qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the qToken being used as\n    /// collateral in the case of a spread\n    /// @param _optionsAmount the amount of options/spread being minted\n    /// @param _qTokenToMintIsCall whether or not the token to mint is a call. if a spread,\n    /// the qToken as collateral is implicitly also a call. and for minting a put, the \n    /// qToken as collateral is implicitly also a put\n    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralAmount the collateral amount required as a fixed point type    \n    function getOptionCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint256 _optionsAmount,\n        bool _qTokenToMintIsCall,\n        uint8 _optionsDecimals,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    ) internal pure returns (QuantMath.FixedPointInt memory collateralAmount) {\n        QuantMath.FixedPointInt memory collateralPerOption;\n        if (_qTokenToMintIsCall) {\n            collateralPerOption = getCallCollateralRequirement(\n                _qTokenToMintStrikePrice,\n                _qTokenForCollateralStrikePrice,\n                _underlyingDecimals,\n                _strikeAssetDecimals\n            );\n        } else {\n            collateralPerOption = getPutCollateralRequirement(\n                _qTokenToMintStrikePrice,\n                _qTokenForCollateralStrikePrice,\n                _strikeAssetDecimals\n            );\n        }\n\n        collateralAmount = _optionsAmount.fromScaledUint(_optionsDecimals).mul(\n            collateralPerOption\n        );\n    }\n\n    /// @notice Calculates the collateral required to mint a single PUT option or PUT spread\n    /// @param _qTokenToMintStrikePrice the strike price of the PUT qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the PUT qToken being used as\n    /// collateral in the case of a spread\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralPerOption the collateral amount required per option as a fixed point type\n    function getPutCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        pure\n        returns (QuantMath.FixedPointInt memory collateralPerOption)\n    {\n        QuantMath.FixedPointInt\n            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(\n                _strikeAssetDecimals\n            );\n        QuantMath.FixedPointInt\n            memory collateralStrikePrice = _qTokenForCollateralStrikePrice\n                .fromScaledUint(_strikeAssetDecimals);\n\n        // Initially (non-spread) required collateral is the long strike price\n        collateralPerOption = mintStrikePrice;\n\n        if (_qTokenForCollateralStrikePrice > 0) {\n            collateralPerOption = mintStrikePrice.isGreaterThan(\n                collateralStrikePrice\n            )\n                ? mintStrikePrice.sub(collateralStrikePrice) // Put Credit Spread\n                : int256(0).fromUnscaledInt(); // Put Debit Spread\n        }\n    }\n\n    /// @notice Calculates the collateral required to mint a single CALL option or CALL spread\n    /// @param _qTokenToMintStrikePrice the strike price of the CALL qToken being minted \n    /// @param _qTokenForCollateralStrikePrice the strike price of the CALL qToken being\n    /// used as collateral in the case of a spread\n    /// @param _underlyingDecimals the amount of decimals the underlying asset has\n    /// @param _strikeAssetDecimals the amount of decimals the strike asset has\n    /// @return collateralPerOption the collateral amount required per option as a fixed point type\n    function getCallCollateralRequirement(\n        uint256 _qTokenToMintStrikePrice,\n        uint256 _qTokenForCollateralStrikePrice,\n        uint8 _underlyingDecimals,\n        uint8 _strikeAssetDecimals\n    )\n        internal\n        pure\n        returns (QuantMath.FixedPointInt memory collateralPerOption)\n    {\n        QuantMath.FixedPointInt\n            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(\n                _strikeAssetDecimals\n            );\n        QuantMath.FixedPointInt\n            memory collateralStrikePrice = _qTokenForCollateralStrikePrice\n                .fromScaledUint(_strikeAssetDecimals);\n\n        // Initially (non-spread) required collateral is the long strike price\n        collateralPerOption = (10**_underlyingDecimals).fromScaledUint(\n            _underlyingDecimals\n        );\n\n        if (_qTokenForCollateralStrikePrice > 0) {\n            collateralPerOption = mintStrikePrice.isGreaterThanOrEqual(\n                collateralStrikePrice\n            )\n                ? int256(0).fromUnscaledInt() // Call Debit Spread\n                : (collateralStrikePrice.sub(mintStrikePrice)).div(\n                    collateralStrikePrice\n                ); // Call Credit Spread\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            account != address(0),\n            \"ERC1155: balance query for the zero address\"\n        );\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            \"ERC1155: accounts and ids length mismatch\"\n        );\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = _balances[id][from];\n        require(\n            fromBalance >= amount,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(\n                fromBalance >= amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            address(0),\n            to,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            address(0),\n            to,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            address(0),\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            \"\"\n        );\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(\n                fromBalance >= amount,\n                \"ERC1155: burn amount exceeds balance\"\n            );\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element)\n        private\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n\n",
        "CodeNames": [
            "QuantCalculator.sol",
            "QuantMath.sol",
            "Controller.sol",
            "QTokenStringUtils.sol",
            "IController.sol",
            "IOptionsFactory.sol",
            "IAssetsRegistry.sol",
            "FundsCalculator.sol",
            "ERC1155.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "_decimals",
                    "_strikePrice",
                    "intToUint",
                    "_qTokenToMintStrikePrice",
                    "mul",
                    "getPayoutForCall",
                    "_optionsAmount",
                    "calculateClaimableCollateral",
                    "_strikeAssetDecimals (",
                    "qTokenShort",
                    "div",
                    "qToken",
                    "getPayoutAmount",
                    "abs(returnableCollateral)",
                    "_mintSpread",
                    "getCallCollateralRequirement",
                    "collateralPerOption = (collateralStrikePrice.sub(mintStrikePrice)).div(collateralStrikePrice)",
                    "getOptionCollateralRequirement",
                    "toScaledUint",
                    "qTokenLong",
                    "_optionsDecimals (",
                    "getCollateralRequirement",
                    "_qTokenForCollateralStrikePrice",
                    "_claimCollateral",
                    "collateralAmountFP",
                    "getSettlementPriceWithDecimals",
                    "getPayout",
                    "payoutDecimals (",
                    "_BASE_DECIMALS (",
                    "_decimal",
                    "_amount",
                    "abs"
                ],
                "Type": " Mint spread collateral-less and conjuring collateral claims out of thin air with implicit arithmetic rounding and flawed int to uint conversion",
                "Description": "\nQuantMath.sol#L137(https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L137)<br\nQuantMath.sol#L151(https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L151)<br\nSignedConverter.sol#L28(https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/SignedConverter.sol#L28)<br\n\nThis report presents 2 different incorrect behaviour that can affect the correctness of math calculations:\n\n1.  Unattended Implicit rounding in QuantMath.sol div and mul\n2.  Inappropriate method of casting integer to unsigned integer in SignedConverter.sol intToUint\n\nBug 1 affects the correctness when calculating collateral required for _mintSpread. Bug 2 expands the attack surface and allows attackers to target the _claimCollateral phase instead. Both attacks may result in tokens being stolen from Controller in the worst case, but is most likely too costly to exploit under current BNB chain environment. The potential impact however, should not be taken lightly, since it is known that the ethereum environment in highly volatile and minor changes in the environment can suddenly make those bugs cheap to exploit.\n\n\nIn this section, we will first present bug 1, and then demonstrate how this bug can be exploited. Then we will discuss how bug 2 opens up more attack chances and go over another PoC.\n\nBefore getting started, we should go over an important concept while dealing with fixed point number -rounding.\nMath has no limits on precision, but computers do. This problem is especially critical to systems handling large amount of \"money\" that is allowed to be arbitrarily divided. A common way for ethereum smart contract developers to handle this is through rounding numbers. Rolla is no exception.\n\nIn QuantMath, Rolla explicitly wrote the toScaledUint function to differentiate between rounding numbers up or down when scaling numbers to different precision (or we call it _decimals here). The intended usage is to scale calculated numbers (amount of tokens) up when Controller is the receiver, and scale it down when Controller is sender. In theory, this function should guarantee Controller can never \"lose tokens\" due to rounding.\n\n    library QuantMath {\n        ...\n        struct FixedPointInt {\n            int256 value;\n        }\n\n        int256 private constant _SCALING_FACTOR = 1e27;\n        uint256 private constant _BASE_DECIMALS = 27;\n\n        ...\n\n        function toScaledUint(\n            FixedPointInt memory _a,\n            uint256 _decimals,\n            bool _roundDown\n        ) internal pure returns (uint256) {\n            uint256 scaledUint;\n\n            if (_decimals == _BASE_DECIMALS) {\n                scaledUint = _a.value.intToUint();\n            } else if (_decimals  _BASE_DECIMALS) {\n                uint256 exp = _decimals _BASE_DECIMALS;\n                scaledUint = (_a.value).intToUint() * 10exp;\n            } else {\n                uint256 exp = _BASE_DECIMALS _decimals;\n                uint256 tailing;\n                if (!_roundDown) {\n                    uint256 remainer = (_a.value).intToUint() % 10exp;\n                    if (remainer  0) tailing = 1;\n                }\n                scaledUint = (_a.value).intToUint() / 10exp + tailing;\n            }\n\n            return scaledUint;\n        }\n        ...\n    }\n\nIn practice, the above function also works quite well (sadly, not perfect, notice the intToUint function within. We will come back to this later), but it only works if we can promise that before entering this function, all numbers retain full precision and is not already rounded. This is where div and mul comes into play. As we can easily see in the snippet below, both functions involve the division operator '/', which by default discards the decimal part of the calculated result (be aware to not confuse this with the _decimal used while scaling FixedPointInt). The operation here results in an implicit round down, which limits the effectiveness of  explicit rounding in toScaledUint showned above.\n\n        function mul(FixedPointInt memory a, FixedPointInt memory b)\n            internal\n            pure\n            returns (FixedPointInt memory)\n        {\n            return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);\n        }\n\n\n        function div(FixedPointInt memory a, FixedPointInt memory b)\n            internal\n            pure\n            returns (FixedPointInt memory)\n        {\n            return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);\n        }\n\nNow let's see how this implicit rounding can causes troubles. We start with the _mintSpread procedure creating a call credit spread. For brevity, the related code is not shown, but here's a summary of what is done.\n\n*   Controller._mintSpread\n    *   QuantCalculator.getCollateralRequirement\n        *   FundsCalculator.getCollateralRequirement\n            *   FundsCalculator.getOptionCollateralRequirement\n                *   FundsCalculator.getCallCollateralRequirement\n                    *   scales _qTokenToMintStrikePrice from\n                        _strikeAssetDecimals (8) to _BASE_DECIMALS (27)\n                    *   scales _qTokenForCollateralStrikePrice from\n                        _strikeAssetDecimals (8) to _BASE_DECIMALS (27)\n                    *   collateralPerOption = (collateralStrikePrice.sub(mintStrikePrice)).div(collateralStrikePrice)\n                *   scale _optionsAmount from _optionsDecimals (18) to _BASE_DECIMALS (27)\n                *   collateralAmount = _optionsAmount.mul(collateralPerOption)\n            *   uses qTokenToMint.underlyingAsset (weth or wbtc) as collateral\n        *   scale and round up collateralAmountFP from _BASE_DECIMALS (27) to payoutDecimals (18)\n\nIf we extract all the math related stuff, it would be something like below\n\n    def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n            X1 = _qTokenToMintStrikePrice * 10^19\n            X2 = _qTokenForCollateralStrikePrice * 10^19\n            X3 = _optionsAmount * 10^9\n\n            assert X1 < X2          #credit spread\n\n            Y1 = (X2 X1) * 10^27 // X2    #implicit round down due to div\n            Y2 = Y1 * X3 // 10^27   #implicit round down due to mul\n\n            Z = Y2 // 10^9\n            if Y2 % 10^9  0:       #round up since we are minting spread (Controller is receiver)\n                    Z+=1\n            return Z\n\nBoth implicit round downs can be abused, but we shall focus on the mul one here.\nAssume we follow the following actions\n\n1.  create option A with strike price 10 + 10^-8 BUSD (10^9 + 1 under 8 decimals) <- 1 WETH<br\n2.  create option B with strike price 10 BUSD (10^9 under 8 decimals) <- 1 WETH<br\n3.  mint 10^-18 (1 under 18 decimals) option A<br\n    3-1. pay 1 eth<br\n4.  mint 10^-18 (1 under 18 decimals) spread B with A as collateral<br\n    4-1. X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28<br\n    4-2. X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19<br\n    4-3. X3 = _optionsAmount * 10^9 = 1 * 10^9 = 10^9<br\n    4-4. Y1 = (X2 X1) * 10^27 // X2 = (10^28 + 10^19 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000<br\n    4-5. Y2 = Y1 * X3 // 10^27 = 99999999000000000 * 10^9 / 10^27 = 0<br\n    4-6. Z = Y2 // 10^9 = 0<br\n    4-7. Y2 % 10^9 = 0 so Z remains unchanged<br\n\nWe minted a call credit spread without paying any fee.\n\nNow let's think about how to extract the value we conjured out of thin air. To be able to withdraw excessive collateral, we can choose to do a excercise+claim or neutralize current options. Here we take the neutralize path.\n\nFor neutralizing spreads, the procedure is basically the same as minting spreads, except that the explicit round down is taken since Controller is the payer here. The neutralize procedure returns the qToken used as collateral and pays the collateral fee back. The math part can be summarized as below.\n\n    def neutralizeCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n            X1 = _qTokenToMintStrikePrice * 10^19\n            X2 = _qTokenForCollateralStrikePrice * 10^19\n            X3 = _optionsAmount * 10^9\n\n            assert X1 < X2          #credit spread\n\n            Y1 = (X2 X1) * 10^27 // X2    #implicit round down due to div\n            Y2 = Y1 * X3 // 10^27   #implicit round down due to mul\n\n            Z = Y2 // 10^9  #explicit scaling\n            return Z\n\nThere are two challenges that need to be bypassed, the first one is to avoid implicit round down in mul, and the second is to ensure the revenue is not rounded away during explicit scaling.\nTo achieve this, we first mint 10^-9 + 2 * 10^-18 spreads seperately (10^9 + 2 under 18 decimals), and as shown before, no additional fees are required while minting spread from original option.\nThen we neutralize all those spreads at once, the calculation is shown below.\n\n1.  neutralize 10^-9 + 2 * 10^-18 (10^9 + 2 under 18 decimals) spread B<br\n    4-1. X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28<br\n    4-2. X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19<br\n    4-3. X3 = _optionsAmount * 10^9 = (10^9 + 2) * 10^9 = 10^18 + 2<br\n    4-4. Y1 = (X2 X1) * 10^27 // X2 = (10^28 + 10^19 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000<br\n    4-5. Y2 = Y1 * X3 // 10^27 = 99999999000000000 * (10^18 + 2) / 10^27 = 1000000000<br\n    4-6. Z = Y2 // 10^9 = 10^9 // 10^9 = 1<br\n\nAnd with this, we managed to generate 10^-18 weth of revenue.\n\nThis approach is pretty impractical due to the requirement of minting 10^-18 for 10^9 + 2 times. This montrous count mostly likely requires a lot of gas to pull off, and offsets the marginal revenue generated through our attack. This leads us to explore other possible methods to bypass this limitation.\n\nIt's time to start looking at the second bug.\n\nRecall we mentioned the second bug is in intToUint, so here's the implementation of it. It is not hard to see that this is actually an abs function named as intToUint.\n\n        function intToUint(int256 a) internal pure returns (uint256) {\n            if (a < 0) {\n                return uint256(-a);\n            } else {\n                return uint256(a);\n            }\n        }\n\nWhere is this function used? And yes, you guessed it, in QuantCalculator.calculateClaimableCollateral. The process of claiming collateral is quite complex, but we will only look at the specific case relevant to the exploit. Before reading code, let's first show the desired scenario. Note that while we wait for expiry, there are no need to sell any option/spread.\n\n1.  mint a qTokenLong option\n2.  mint a qTokenShort spread with qTokenLong as collateral\n3.  wait until expire, and expect expiryPrice to be between qTokenLong and qTokenShort\n\n<!----\n\n    ----------qTokenLong strike price\n\n    ----------expiryPrice\n\n    ----------qTokenShort strike price\n\nHere is the outline of the long waited claimCollateral for spread.\n\n*   Controller._claimCollateral\n    *   QuantCalculator.calculateClaimableCollateral\n        *   FundsCalculator.getSettlementPriceWithDecimals\n        *   FundsCalculator.getPayout for qTokenLong\n            *   qTokenLong strike price is above expiry price, worth 0\n        *   FundsCalculator.getCollateralRequirement\n            *   This part we saw earlier, omit details\n        *   FundsCalculator.getPayout for qTokenShort\n            *   uses qTokenToMint.underlyingAsset (weth or wbtc) as collateral\n            *   FundsCalculator.getPayoutAmount for qTokenShort\n                *   scale _strikePrice from\n                    _strikeAssetDecimals (8) to _BASE_DECIMALS (27)\n                *   scale _expiryPrice.price from\n                    _expiryPrice.decimals (8) to _BASE_DECIMALS (27)\n                *   scale _amount from\n                    _optionsDecimals (18) to _BASE_DECIMALS (27)\n                *   FundsCalculator.getPayoutForCall for qTokenShort\n                    *   payoutAmount = expiryPrice.sub(strikePrice).mul(amount).div(expiryPrice)\n        *   returnableCollateral = payoutFromLong.add(collateralRequirement).sub(payoutFromShort)\n        *   scale and round down abs(returnableCollateral) from _BASE_DECIMALS (27) to payoutDecimals (18)\n\nAgain, we summarize the math part into a function.\n\n    def claimableCollateralCallCreditSpreadExpiryInbetween(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _expiryPrice, _amount):\n\n            def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n                    X1 = _qTokenToMintStrikePrice * 10^19\n                    X2 = _qTokenForCollateralStrikePrice * 10^19\n                    X3 = _optionsAmount * 10^9\n\n                    Y1 = (X2 X1) * 10^27 // X2\n                    Y2 = Y1 * X3 // 10^27\n                    return Y2\n\n            def callCreditSpreadQTokenShortPayout(_strikePrice, _expiryPrice, _amount):\n                    X1 = _strikePrice * 10^19\n                    X2 = _expiryPrice * 10^19\n                    X3 = _amount * 10^9\n\n                    Y1 = (X2-X1) * X3 // 10^27\n                    Y2 = Y1 * 10^27 // X2\n                    return Y2\n\n\n            assert _qTokenShortStrikePrice  _expiryPrice  _qTokenLongStrikePrice\n\n            A1 = payoutFromLong = 0\n            A2 = collateralRequirement = callCreditSpreadCollateralRequirement(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _amount)\n            A3 = payoutFromShort = callCreditSpreadQTokenShortPayout(_qTokenShortStrikePrice, _expiryPrice, _amount)\n\n            B1 = A1 + A2 A3\n\n            Z = abs(B1) // 10^9\n            return Z\n\nGiven the context, it should be pretty easy to imagine what I am aiming here, to make B1 < 0. We already know A1 = 0, so the gaol basically boils down to making A2 < A3. Let's further simplify this requirement and see if the equation is solvable.\n\n    X = _qTokenLongStrikePrice (8 decimals)\n    Y = _expiryPrice (8 decimals)\n    Z = _qTokenShortStrikePrice (8 decimals)\n    A = _amount (scaled to 27 decimals)\n\n    assert XYZ0\n    assert X,Y,Z are integers\n    assert (((X Z) * 10^27 // X) * A // 10^27) < (((Y Z) * A // 10^27) * 10^27 // Y)\n\nNotice apart from the use of X and Y, the two sides of the equation only differs by when A is mixed into the equation, meaning that if we temporarily ignore the limitation and set X = Y, as long as left hand side of equation does an implicit rounding after dividing by X, right hand side will most likely be larger.\n\nUtilizing this, we turn to solve the equation of:\n\n    (X-Z) / X (Y-Z) / Y < 10^-27\n    = Z / Y Z / X < 10^-27\n    = (Z = 1 yields best solution)\n    = 1 / Y 1 / X < 10^-27\n    = X Y < X * Y * 10^-27\n    = 0 < X * Y 10^27 * X + 10^27 * Y\n\n    = require X  Y, so model Y as X B, where B  0 and B is an integer\n    = 0 < X^2 B * X 10^27 * B\n\nIt is not easy to see that the larger X is, the larger the range of allowed B. This is pretty important since B stands for the range of expiry prices where attack could work, so the larger it is, the less accurate our guess can be to profit.\n\nApart form range of B, value of X is the long strike price and upper bound of range B, so we would also care about it, a simple estimation shows that X must be above 10^13.5 (8 decimals) for there to be a solution, which amounts to about 316228 BUSD <- 1 WETH. This is an extremely high price, but not high enough to be concluded as unreachable in the near future. So let's take a slightly generous number of 10^14 1 as X and calculate the revenue generated following this exploit path.\n\n    0 < (10^14 1)^2 B * (10^14 1) 10^27 * B\n    = (10^14 1)^2 / (10^14 1 + 10^27)  B\n    = B <= 9\n\nNow we've got the range of profitable expiry price. As we concluded earlier, the range is extremely small with a modest long strike price, but let's settle with this for now and see how much profit can be generated if we get lucky. To calculate profit, we take _qTokenLongStrikePrice = 10^14 1 (8 decimals), _qTokenShortStrikePrice = 1 (8 decimals), _expiryPrice = 10^14 2 (8 decimals) and _amount = 10^28 (18 decimals) and plug it back into the function.\n\n1.  in callCreditSpreadCollateralRequirement<br\n    1-1. X1 = _qTokenForCollateralStrikePrice * 10^19 = 1 * 10^19 = 10^19<br\n    1-2. X2 = _qTokenToMintStrikePrice * 10^19 = (10^14 1) * 10^19 = 10^33 10^19<br\n    1-3. X3 = _optionsAmount * 10^9 = 10^28 * 10^9 = 10^37<br\n    1-4. Y1 = (X2 X1) * 10^27 // X2 = (10^33 2 * 10^19) * 10^27 // (10^33 10^19) = 999999999999989999999999999<br\n    1-5. Y2 = Y1 * X3 // 10^27 = 999999999999989999999999999 * 10^37 // 10^27 = 999999999999989999999999999 * 10^10<br\n2.  in callCreditSpreadQTokenShortPayout<br\n    2-1. X1 = _strikePrice * 10^19 = 1 * 10^19 = 10^19<br\n    2-2. X2 = _expiryPrice * 10^19 = (10^14 2) * 10^19 = 10^33 2 * 10^19<br\n    2-3. X3 = _amount * 10^9 = 10^28 * 10^9 = 10^37<br\n    2-4. Y1 = (X2 X1) * X3 // 10^27 = (10^33 3 * 10^19) * 10^37 // 10^27 = 99999999999997 * 10^29<br\n    2-5. Y2 = Y1 * 10^27 / X2 = (99999999999997 * 10^28) * 10^27 / (10^33 2 * 10^19) = 9999999999999899999999999997999999999<br\n3.  combine terms<br\n    3-1.  B1 = A1 + A2 A3 = 0 + 9999999999999899999999999990000000000 9999999999999899999999999997999999999 = -2000000001<br\n         3-2.  Z = abs(B1) // 10^9 = 2000000000 // 10^9 = 2<br\n\nAnd with this, we managed to squeeze 2 wei from a presumably worthless collateral.\n\nThis attack still suffers from several problems\n\n1.  cost of WETH in BUSD is way higher than current market\n2.  need to predict target price accurately to profit\n3.  requires large amount of WETH to profit\n\nWhile it is still pretty hard to pull off attack, the requirements seems pretty more likely to be achievable compared to the first version of exploit. Apart from this, there is also the nice property that this attack allows profit to scale with money invested.\n\nThis concludes our demonstration of two attacks against the potential flaws in number handling.\n\n\nvim, ganache-cli\n\n",
                "Repair": "\nFor div and mul, adding in a similar opt-out round up argument would work. This would require some refactoring of code, but is the only way to fundamentally solve the problem.\n\nFor intToUint, I still can't understand what the original motive is to design it as abs in disguise. Since nowhere in this project would we benefit from the current abs behaviour, in my opinion, it would be best to adopt a similar strategy to the uintToInt function. If the value goes out of directly convertable range ( < 0), revert and throw an error message.\n\n0xca11 (Rolla) confirmed, resolved, and commented(https://github.com/code-423n4/2022-03-rolla-findings/issues/31#issuecomment-1102147125):\n  Resolved by adding explicit rounding on fixed-point multiplication and division operations: RollaProject/quant-protocol#91(https://github.com/RollaProject/quant-protocol/pull/91).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./QuantConfig.sol\";\nimport \"./utils/EIP712MetaTransaction.sol\";\nimport \"./utils/OperateProxy.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IOracleRegistry.sol\";\nimport \"./interfaces/ICollateralToken.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IOperateProxy.sol\";\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./libraries/ProtocolValue.sol\";\nimport \"./libraries/QuantMath.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/Actions.sol\";\n\n/// @title The main entry point in the Quant Protocol\n/// @author Rolla\n/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.\n/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.\n/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.\n/// @dev This contract is an upgradeable proxy, and it supports meta transactions.\n/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the\n/// OptionsFactory first.\ncontract Controller is\n    IController,\n    EIP712MetaTransaction,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using QuantMath for QuantMath.FixedPointInt;\n    using Actions for ActionArgs;\n\n    /// @inheritdoc IController\n    address public override optionsFactory;\n\n    /// @inheritdoc IController\n    address public override operateProxy;\n\n    /// @inheritdoc IController\n    address public override quantCalculator;\n\n    /// @inheritdoc IController\n    function operate(ActionArgs[] memory _actions)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        uint256 length = _actions.length;\n        for (uint256 i = 0; i < length; ) {\n            ActionArgs memory action = _actions[i];\n\n            if (action.actionType == ActionType.MintOption) {\n                (address to, address qToken, uint256 amount) = action\n                    .parseMintOptionArgs();\n                _mintOptionsPosition(to, qToken, amount);\n            } else if (action.actionType == ActionType.MintSpread) {\n                (\n                    address qTokenToMint,\n                    address qTokenForCollateral,\n                    uint256 amount\n                ) = action.parseMintSpreadArgs();\n                _mintSpread(qTokenToMint, qTokenForCollateral, amount);\n            } else if (action.actionType == ActionType.Exercise) {\n                (address qToken, uint256 amount) = action.parseExerciseArgs();\n                _exercise(qToken, amount);\n            } else if (action.actionType == ActionType.ClaimCollateral) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseClaimCollateralArgs();\n                _claimCollateral(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.Neutralize) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseNeutralizeArgs();\n                _neutralizePosition(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.QTokenPermit) {\n                (\n                    address qToken,\n                    address owner,\n                    address spender,\n                    uint256 value,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseQTokenPermitArgs();\n                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);\n            } else if (\n                action.actionType == ActionType.CollateralTokenApproval\n            ) {\n                (\n                    address owner,\n                    address operator,\n                    bool approved,\n                    uint256 nonce,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseCollateralTokenApprovalArgs();\n                _collateralTokenApproval(\n                    owner,\n                    operator,\n                    approved,\n                    nonce,\n                    deadline,\n                    v,\n                    r,\n                    s\n                );\n            } else {\n                require(\n                    action.actionType == ActionType.Call,\n                    \"Controller: Invalid action type\"\n                );\n                (address callee, bytes memory data) = action.parseCallArgs();\n                _call(callee, data);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n\n    // @inheritdoc IController\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _optionsFactory,\n        address _quantCalculator\n    ) public override initializer {\n        require(\n            _optionsFactory != address(0),\n            \"Controller: invalid OptionsFactory address\"\n        );\n        require(\n            _quantCalculator != address(0),\n            \"Controller: invalid QuantCalculator address\"\n        );\n\n        __ReentrancyGuard_init();\n        EIP712MetaTransaction.initializeEIP712(_name, _version);\n        optionsFactory = _optionsFactory;\n\n        /// @dev Unless this line is removed, a new OperateProxy will be created\n        /// during each upgrade. So make sure any application that requires approving\n        /// the OperateProxy to spend funds is aware of this.\n        operateProxy = address(new OperateProxy());\n\n        quantCalculator = _quantCalculator;\n    }\n\n    /// @notice Mints options for a given QToken, which must have been previously created in\n    /// the configured OptionsFactory.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset, and then this function can be called, pulling the collateral\n    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.\n    /// Note that QTokens represent a long position, giving holders the ability to exercise options\n    /// after expiry, while CollateralTokens represent a short position, giving holders the ability\n    /// to claim the collateral after expiry.\n    /// @param _to The address to which the QTokens and CollateralTokens will be minted.\n    /// @param _qToken The QToken that represents the long position for the option to be minted.\n    /// @param _amount The amount of options to be minted.\n    function _mintOptionsPosition(\n        address _to,\n        address _qToken,\n        uint256 _amount\n    ) internal returns (uint256) {\n        IQToken qToken = IQToken(_qToken);\n\n        // get the collateral required to mint the specified amount of options\n        // the zero address is passed as the second argument as it's only used\n        // for spreads\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(_qToken, address(0), _amount);\n\n        _checkIfUnexpiredQToken(_qToken);\n\n        // check if the oracle set during the option's creation through the OptionsFactory\n        // is an active oracle in the OracleRegistry\n        require(\n            IOracleRegistry(\n                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(\n                    ProtocolValue.encode(\"oracleRegistry\")\n                )\n            ).isOracleActive(qToken.oracle()),\n            \"Controller: Can't mint an options position as the oracle is inactive\"\n        );\n\n        // pull the required collateral from the caller/signer\n        IERC20(collateral).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            collateralAmount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Mint the options to the sender's address\n        qToken.mint(_to, _amount);\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qToken,\n            address(0)\n        );\n\n        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,\n        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory\n        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);\n\n        emit OptionsPositionMinted(\n            _to,\n            _msgSender(),\n            _qToken,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Creates a spread position from an option to long and another option to short.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset in cases of a debit spread.\n    /// @param _qTokenToMint The QToken for the option to be long.\n    /// @param _qTokenForCollateral The QToken for the option to be short.\n    /// @param _amount The amount of long options to be minted.\n    function _mintSpread(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    ) internal returns (uint256) {\n        require(\n            _qTokenToMint != _qTokenForCollateral,\n            \"Controller: Can only create a spread with different tokens\"\n        );\n\n        IQToken qTokenToMint = IQToken(_qTokenToMint);\n        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);\n\n        // Calculate the extra collateral required to create the spread.\n        // A positive value for debit spreads and zero for credit spreads.\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount\n            );\n\n        _checkIfUnexpiredQToken(_qTokenToMint);\n        _checkIfUnexpiredQToken(_qTokenForCollateral);\n\n        // Burn the QToken being shorted\n        qTokenForCollateral.burn(_msgSender(), _amount);\n\n        // Transfer in any collateral required for the spread\n        if (collateralAmount > 0) {\n            IERC20(collateral).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                collateralAmount\n            );\n        }\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Check if the CollateralToken representing this specific spread has already been created\n        // Create it if it hasn't\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qTokenToMint,\n            _qTokenForCollateral\n        );\n        (, address qTokenAsCollateral) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n        if (qTokenAsCollateral == address(0)) {\n            require(\n                collateralTokenId ==\n                    collateralToken.createCollateralToken(\n                        _qTokenToMint,\n                        _qTokenForCollateral\n                    ),\n                \"Controller: failed creating the collateral token to represent the spread\"\n            );\n        }\n\n        // Mint the tokens for the new spread position\n        collateralToken.mintCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            _amount\n        );\n        qTokenToMint.mint(_msgSender(), _amount);\n\n        emit SpreadMinted(\n            _msgSender(),\n            _qTokenToMint,\n            _qTokenForCollateral,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Closes a long position after the option's expiry.\n    /// @dev Pass an `_amount` of 0 to close the entire position.\n    /// @param _qToken The QToken representing the long position to be closed.\n    /// @param _amount The amount of options to exercise.\n    function _exercise(address _qToken, uint256 _amount) internal {\n        IQToken qToken = IQToken(_qToken);\n        require(\n            block.timestamp > qToken.expiryTime(),\n            \"Controller: Can not exercise options before their expiry\"\n        );\n\n        uint256 amountToExercise = _amount;\n        // if the amount is 0, the entire position will be exercised\n        if (amountToExercise == 0) {\n            amountToExercise = qToken.balanceOf(_msgSender());\n        }\n\n        // Use the QuantCalculator to check how much the sender/signer is due.\n        // Will only be a positive value for options that expired In The Money.\n        (\n            bool isSettled,\n            address payoutToken,\n            uint256 exerciseTotal\n        ) = IQuantCalculator(quantCalculator).getExercisePayout(\n                address(qToken),\n                amountToExercise\n            );\n\n        require(isSettled, \"Controller: Cannot exercise unsettled options\");\n\n        // Burn the long tokens\n        qToken.burn(_msgSender(), amountToExercise);\n\n        // Transfer any profit due after expiration\n        if (exerciseTotal > 0) {\n            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);\n        }\n\n        emit OptionsExercised(\n            _msgSender(),\n            address(qToken),\n            amountToExercise,\n            exerciseTotal,\n            payoutToken\n        );\n    }\n\n    /// @notice Closes a short position after the option's expiry.\n    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.\n    /// @param _amount The size of the position to close.\n    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        uint256 collateralTokenId = _collateralTokenId;\n\n        // Use the QuantCalculator to check how much collateral the sender/signer is due.\n        (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(\n                collateralTokenId,\n                _amount,\n                _msgSender()\n            );\n\n        // Burn the short tokens\n        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim\n        );\n\n        // Transfer any collateral due after expiration\n        if (returnableCollateral > 0) {\n            IERC20(collateralAsset).safeTransfer(\n                _msgSender(),\n                returnableCollateral\n            );\n        }\n\n        emit CollateralClaimed(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim,\n            returnableCollateral,\n            collateralAsset\n        );\n    }\n\n    /// @notice Closes a neutral position, claiming all the collateral required to create it.\n    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.\n    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.\n    /// @param _amount The size of the position to close.\n    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        /// @dev Put these values in the stack to save gas from having to read\n        /// from calldata\n        (uint256 collateralTokenId, uint256 amount) = (\n            _collateralTokenId,\n            _amount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n\n        //get the amount of CollateralTokens owned\n        uint256 collateralTokensOwned = collateralToken.balanceOf(\n            _msgSender(),\n            collateralTokenId\n        );\n\n        //get the amount of QTokens owned\n        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());\n\n        // the size of the position that can be neutralized\n        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned\n            ? qTokensOwned\n            : collateralTokensOwned;\n\n        // make sure that the amount passed is not greater than the amount that can be neutralized\n        uint256 amountToNeutralize;\n        if (amount != 0) {\n            require(\n                amount <= maxNeutralizable,\n                \"Controller: Tried to neutralize more than balance\"\n            );\n            amountToNeutralize = amount;\n        } else {\n            amountToNeutralize = maxNeutralizable;\n        }\n\n        // use the QuantCalculator to check how much collateral the sender/signer is due\n        // for closing the neutral position\n        (address collateralType, uint256 collateralOwed) = IQuantCalculator(\n            quantCalculator\n        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);\n\n        // burn the short tokens\n        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);\n\n        // burn the long tokens\n        collateralToken.burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToNeutralize\n        );\n\n        // tranfer the collateral owed\n        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);\n\n        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)\n        if (qTokenLong != address(0)) {\n            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);\n        }\n\n        emit NeutralizePosition(\n            _msgSender(),\n            qTokenShort,\n            amountToNeutralize,\n            collateralOwed,\n            collateralType,\n            qTokenLong\n        );\n    }\n\n    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.\n    /// @param _qToken The QToken to be approved.\n    /// @param _spender The address of the spender.\n    /// @param _value The amount of tokens to be approved for spending.\n    /// @param _deadline Timestamp at which the permit signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _qTokenPermit(\n        address _qToken,\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IQToken(_qToken).permit(\n            _owner,\n            _spender,\n            _value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice Allows a CollateralToken owner to either approve an operator address\n    /// to spend all of their tokens on their behalf, or to remove a prior approval.\n    /// @param _owner The address of the owner of the CollateralToken.\n    /// @param _operator The address of the operator to be approved or removed.\n    /// @param _approved Whether the operator is being approved or removed.\n    /// @param _nonce The nonce for the approval through a meta transaction.\n    /// @param _deadline Timestamp at which the approval signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _collateralTokenApproval(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _nonce,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(\n                _owner,\n                _operator,\n                _approved,\n                _nonce,\n                _deadline,\n                _v,\n                _r,\n                _s\n            );\n    }\n\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n\n    /// @notice Checks if the given QToken has not expired yet, reverting otherwise\n    /// @param _qToken The address of the QToken to check.\n    function _checkIfUnexpiredQToken(address _qToken) internal view {\n        require(\n            IQToken(_qToken).expiryTime() > block.timestamp,\n            \"Controller: Cannot mint expired options\"\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\nimport \"../interfaces/IAssetsRegistry.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../libraries/ProtocolValue.sol\";\n\nabstract contract QTokenStringUtils {\n    /// @notice get the ERC20 token symbol from the AssetsRegistry\n    /// @dev the asset is assumed to be in the AssetsRegistry since QTokens\n    /// must be created through the OptionsFactory, which performs that check\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _asset address of the asset in the AssetsRegistry\n    /// @return assetSymbol string stored as the ERC20 token symbol\n    function _assetSymbol(address _quantConfig, address _asset)\n        internal\n        view\n        virtual\n        returns (string memory assetSymbol)\n    {\n        (, assetSymbol, ) = IAssetsRegistry(\n            IQuantConfig(_quantConfig).protocolAddresses(\n                ProtocolValue.encode(\"assetsRegistry\")\n            )\n        ).assetProperties(_asset);\n    }\n\n    /// @notice generates the name for an option\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _underlyingAsset asset that the option references\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenName name string for the QToken\n    function _qTokenName(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenName) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (, string memory typeFull) = _getOptionType(_isCall);\n\n        // get option month string\n        (, string memory monthFull) = _getMonth(month);\n\n        /// concatenated name string\n        tokenName = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \" \",\n                underlying,\n                \" \",\n                _uintToChars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                \" \",\n                typeFull\n            )\n        );\n    }\n\n    /// @notice generates the symbol for an option\n    /// @param _underlyingAsset asset that the option references\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenSymbol symbol string for the QToken\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n\n    /// @dev convert the option strike price scaled to a human readable value\n    /// @param _strikePrice the option strike price scaled by 1e20\n    /// @return strike price string\n    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n        uint256 strikePriceScale = 10**strikePriceDigits;\n        uint256 remainder = _strikePrice % strikePriceScale;\n        uint256 quotient = _strikePrice / strikePriceScale;\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) {\n            return quotientStr;\n        }\n\n        uint256 trailingZeroes;\n        while (remainder % 10 == 0) {\n            remainder /= 10;\n            trailingZeroes++;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(strikePriceDigits - trailingZeroes);\n\n        string memory tmp = Strings.toString(remainder);\n        tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);\n\n        return string(abi.encodePacked(quotientStr, \".\", tmp));\n    }\n\n    /// @dev get the string representation of the option type\n    /// @return a 1 character representation of the option type\n    /// @return a full length string of the option type\n    function _getOptionType(bool _isCall)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        return _isCall ? (\"C\", \"Call\") : (\"P\", \"Put\");\n    }\n\n    /// @dev get the representation of a number using 2 characters, adding a leading 0 if it's one digit,\n    /// and two trailing digits if it's a 3 digit number\n    /// @return 2 characters that correspond to a number\n    function _uintToChars(uint256 _number)\n        internal\n        pure\n        virtual\n        returns (string memory)\n    {\n        if (_number > 99) {\n            _number %= 100;\n        }\n\n        string memory str = Strings.toString(_number);\n\n        if (_number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n\n        return str;\n    }\n\n    /// @dev cut a string into string[start:end]\n    /// @param _s string to cut\n    /// @param _start the starting index\n    /// @param _end the ending index (not inclusive)\n    /// @return the indexed string\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure virtual returns (string memory) {\n        uint256 range = _end - _start;\n        bytes memory slice = new bytes(range);\n        for (uint256 i = 0; i < range; ) {\n            slice[i] = bytes(_s)[_start + 1];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return string(slice);\n    }\n\n    /// @dev get the string representations of a month\n    /// @return a 3 character representation\n    /// @return a full length string representation\n    function _getMonth(uint256 _month)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol",
            "QTokenStringUtils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n",
                    "//solidity\n    /\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n",
                    "//solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n",
                    "//solidity\nabstract contract EIP712Upgradeable is Initializable {\n    // ...\n}\n"
                ],
                "Type": "  Wrong implementation of  EIP712MetaTransaction ",
                "Description": "\n1.  EIP712MetaTransaction is a utils contract that intended to be inherited by concrete (actual) contracts, therefore. it's initializer function should not use the initializer modifier, instead, it should use onlyInitializing modifier. See the implementation of openzeppelin EIP712Upgradeable initializer function(https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L48-L57).\n\nEIP712MetaTransaction.sol#L102-L114(https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114)<br\n\nsolidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n\n\nOtherwise, when the concrete contract's initializer function (with a initializer modifier) is calling EIP712MetaTransaction's initializer function, it will be mistok as reentered and so that it will be reverted (unless in the context of a constructor, e.g. Using @openzeppelin/hardhat-upgrades deployProxy() to initialize).\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/proxy/utils/Initializable.sol#L50-L53\n\nsolidity\n    /\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n\nSee also: <https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/releases/tag/v4.4.1\n\n2.  initializer can only be called once, it can not be \"called once after every upgrade\".\n\nEIP712MetaTransaction.sol#L102-L114(https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114)<br\n\nsolidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n\n\n3.  A utils contract that is not expected to be deployed as a standalone contract should be declared as abstract. It's initializer function should be internal.\n\nSee the implementation of openzeppelin EIP712Upgradeable(https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28).\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28\n\nsolidity\nabstract contract EIP712Upgradeable is Initializable {\n    // ...\n}\n\n\n",
                "Repair": "\nChange to:\n\nsolidity\nabstract contract EIP712MetaTransaction is EIP712Upgradeable {\n    // ...\n}\n\n\nsolidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function __EIP712MetaTransaction_init(string memory _name, string memory _version)\n        internal\n        onlyInitializing\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n\n\n0xca11 (Rolla) confirmed, resolved, and commented(https://github.com/code-423n4/2022-03-rolla-findings/issues/43#issuecomment-1102143348):\n  Resolved in RollaProject/quant-protocol@25112fa(https://github.com/RollaProject/quant-protocol/commit/25112fa93a650f7b889e8472faf75dd5c471cdf2), but upgradeability was later removed as per RollaProject/quant-protocol#90(https://github.com/RollaProject/quant-protocol/pull/90).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./QuantConfig.sol\";\nimport \"./utils/EIP712MetaTransaction.sol\";\nimport \"./utils/OperateProxy.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IOracleRegistry.sol\";\nimport \"./interfaces/ICollateralToken.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IOperateProxy.sol\";\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./libraries/ProtocolValue.sol\";\nimport \"./libraries/QuantMath.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/Actions.sol\";\n\n/// @title The main entry point in the Quant Protocol\n/// @author Rolla\n/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.\n/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.\n/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.\n/// @dev This contract is an upgradeable proxy, and it supports meta transactions.\n/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the\n/// OptionsFactory first.\ncontract Controller is\n    IController,\n    EIP712MetaTransaction,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using QuantMath for QuantMath.FixedPointInt;\n    using Actions for ActionArgs;\n\n    /// @inheritdoc IController\n    address public override optionsFactory;\n\n    /// @inheritdoc IController\n    address public override operateProxy;\n\n    /// @inheritdoc IController\n    address public override quantCalculator;\n\n    /// @inheritdoc IController\n    function operate(ActionArgs[] memory _actions)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        uint256 length = _actions.length;\n        for (uint256 i = 0; i < length; ) {\n            ActionArgs memory action = _actions[i];\n\n            if (action.actionType == ActionType.MintOption) {\n                (address to, address qToken, uint256 amount) = action\n                    .parseMintOptionArgs();\n                _mintOptionsPosition(to, qToken, amount);\n            } else if (action.actionType == ActionType.MintSpread) {\n                (\n                    address qTokenToMint,\n                    address qTokenForCollateral,\n                    uint256 amount\n                ) = action.parseMintSpreadArgs();\n                _mintSpread(qTokenToMint, qTokenForCollateral, amount);\n            } else if (action.actionType == ActionType.Exercise) {\n                (address qToken, uint256 amount) = action.parseExerciseArgs();\n                _exercise(qToken, amount);\n            } else if (action.actionType == ActionType.ClaimCollateral) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseClaimCollateralArgs();\n                _claimCollateral(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.Neutralize) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseNeutralizeArgs();\n                _neutralizePosition(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.QTokenPermit) {\n                (\n                    address qToken,\n                    address owner,\n                    address spender,\n                    uint256 value,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseQTokenPermitArgs();\n                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);\n            } else if (\n                action.actionType == ActionType.CollateralTokenApproval\n            ) {\n                (\n                    address owner,\n                    address operator,\n                    bool approved,\n                    uint256 nonce,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseCollateralTokenApprovalArgs();\n                _collateralTokenApproval(\n                    owner,\n                    operator,\n                    approved,\n                    nonce,\n                    deadline,\n                    v,\n                    r,\n                    s\n                );\n            } else {\n                require(\n                    action.actionType == ActionType.Call,\n                    \"Controller: Invalid action type\"\n                );\n                (address callee, bytes memory data) = action.parseCallArgs();\n                _call(callee, data);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n\n    // @inheritdoc IController\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _optionsFactory,\n        address _quantCalculator\n    ) public override initializer {\n        require(\n            _optionsFactory != address(0),\n            \"Controller: invalid OptionsFactory address\"\n        );\n        require(\n            _quantCalculator != address(0),\n            \"Controller: invalid QuantCalculator address\"\n        );\n\n        __ReentrancyGuard_init();\n        EIP712MetaTransaction.initializeEIP712(_name, _version);\n        optionsFactory = _optionsFactory;\n\n        /// @dev Unless this line is removed, a new OperateProxy will be created\n        /// during each upgrade. So make sure any application that requires approving\n        /// the OperateProxy to spend funds is aware of this.\n        operateProxy = address(new OperateProxy());\n\n        quantCalculator = _quantCalculator;\n    }\n\n    /// @notice Mints options for a given QToken, which must have been previously created in\n    /// the configured OptionsFactory.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset, and then this function can be called, pulling the collateral\n    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.\n    /// Note that QTokens represent a long position, giving holders the ability to exercise options\n    /// after expiry, while CollateralTokens represent a short position, giving holders the ability\n    /// to claim the collateral after expiry.\n    /// @param _to The address to which the QTokens and CollateralTokens will be minted.\n    /// @param _qToken The QToken that represents the long position for the option to be minted.\n    /// @param _amount The amount of options to be minted.\n    function _mintOptionsPosition(\n        address _to,\n        address _qToken,\n        uint256 _amount\n    ) internal returns (uint256) {\n        IQToken qToken = IQToken(_qToken);\n\n        // get the collateral required to mint the specified amount of options\n        // the zero address is passed as the second argument as it's only used\n        // for spreads\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(_qToken, address(0), _amount);\n\n        _checkIfUnexpiredQToken(_qToken);\n\n        // check if the oracle set during the option's creation through the OptionsFactory\n        // is an active oracle in the OracleRegistry\n        require(\n            IOracleRegistry(\n                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(\n                    ProtocolValue.encode(\"oracleRegistry\")\n                )\n            ).isOracleActive(qToken.oracle()),\n            \"Controller: Can't mint an options position as the oracle is inactive\"\n        );\n\n        // pull the required collateral from the caller/signer\n        IERC20(collateral).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            collateralAmount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Mint the options to the sender's address\n        qToken.mint(_to, _amount);\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qToken,\n            address(0)\n        );\n\n        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,\n        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory\n        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);\n\n        emit OptionsPositionMinted(\n            _to,\n            _msgSender(),\n            _qToken,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Creates a spread position from an option to long and another option to short.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset in cases of a debit spread.\n    /// @param _qTokenToMint The QToken for the option to be long.\n    /// @param _qTokenForCollateral The QToken for the option to be short.\n    /// @param _amount The amount of long options to be minted.\n    function _mintSpread(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    ) internal returns (uint256) {\n        require(\n            _qTokenToMint != _qTokenForCollateral,\n            \"Controller: Can only create a spread with different tokens\"\n        );\n\n        IQToken qTokenToMint = IQToken(_qTokenToMint);\n        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);\n\n        // Calculate the extra collateral required to create the spread.\n        // A positive value for debit spreads and zero for credit spreads.\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount\n            );\n\n        _checkIfUnexpiredQToken(_qTokenToMint);\n        _checkIfUnexpiredQToken(_qTokenForCollateral);\n\n        // Burn the QToken being shorted\n        qTokenForCollateral.burn(_msgSender(), _amount);\n\n        // Transfer in any collateral required for the spread\n        if (collateralAmount > 0) {\n            IERC20(collateral).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                collateralAmount\n            );\n        }\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Check if the CollateralToken representing this specific spread has already been created\n        // Create it if it hasn't\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qTokenToMint,\n            _qTokenForCollateral\n        );\n        (, address qTokenAsCollateral) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n        if (qTokenAsCollateral == address(0)) {\n            require(\n                collateralTokenId ==\n                    collateralToken.createCollateralToken(\n                        _qTokenToMint,\n                        _qTokenForCollateral\n                    ),\n                \"Controller: failed creating the collateral token to represent the spread\"\n            );\n        }\n\n        // Mint the tokens for the new spread position\n        collateralToken.mintCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            _amount\n        );\n        qTokenToMint.mint(_msgSender(), _amount);\n\n        emit SpreadMinted(\n            _msgSender(),\n            _qTokenToMint,\n            _qTokenForCollateral,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Closes a long position after the option's expiry.\n    /// @dev Pass an `_amount` of 0 to close the entire position.\n    /// @param _qToken The QToken representing the long position to be closed.\n    /// @param _amount The amount of options to exercise.\n    function _exercise(address _qToken, uint256 _amount) internal {\n        IQToken qToken = IQToken(_qToken);\n        require(\n            block.timestamp > qToken.expiryTime(),\n            \"Controller: Can not exercise options before their expiry\"\n        );\n\n        uint256 amountToExercise = _amount;\n        // if the amount is 0, the entire position will be exercised\n        if (amountToExercise == 0) {\n            amountToExercise = qToken.balanceOf(_msgSender());\n        }\n\n        // Use the QuantCalculator to check how much the sender/signer is due.\n        // Will only be a positive value for options that expired In The Money.\n        (\n            bool isSettled,\n            address payoutToken,\n            uint256 exerciseTotal\n        ) = IQuantCalculator(quantCalculator).getExercisePayout(\n                address(qToken),\n                amountToExercise\n            );\n\n        require(isSettled, \"Controller: Cannot exercise unsettled options\");\n\n        // Burn the long tokens\n        qToken.burn(_msgSender(), amountToExercise);\n\n        // Transfer any profit due after expiration\n        if (exerciseTotal > 0) {\n            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);\n        }\n\n        emit OptionsExercised(\n            _msgSender(),\n            address(qToken),\n            amountToExercise,\n            exerciseTotal,\n            payoutToken\n        );\n    }\n\n    /// @notice Closes a short position after the option's expiry.\n    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.\n    /// @param _amount The size of the position to close.\n    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        uint256 collateralTokenId = _collateralTokenId;\n\n        // Use the QuantCalculator to check how much collateral the sender/signer is due.\n        (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(\n                collateralTokenId,\n                _amount,\n                _msgSender()\n            );\n\n        // Burn the short tokens\n        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim\n        );\n\n        // Transfer any collateral due after expiration\n        if (returnableCollateral > 0) {\n            IERC20(collateralAsset).safeTransfer(\n                _msgSender(),\n                returnableCollateral\n            );\n        }\n\n        emit CollateralClaimed(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim,\n            returnableCollateral,\n            collateralAsset\n        );\n    }\n\n    /// @notice Closes a neutral position, claiming all the collateral required to create it.\n    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.\n    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.\n    /// @param _amount The size of the position to close.\n    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        /// @dev Put these values in the stack to save gas from having to read\n        /// from calldata\n        (uint256 collateralTokenId, uint256 amount) = (\n            _collateralTokenId,\n            _amount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n\n        //get the amount of CollateralTokens owned\n        uint256 collateralTokensOwned = collateralToken.balanceOf(\n            _msgSender(),\n            collateralTokenId\n        );\n\n        //get the amount of QTokens owned\n        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());\n\n        // the size of the position that can be neutralized\n        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned\n            ? qTokensOwned\n            : collateralTokensOwned;\n\n        // make sure that the amount passed is not greater than the amount that can be neutralized\n        uint256 amountToNeutralize;\n        if (amount != 0) {\n            require(\n                amount <= maxNeutralizable,\n                \"Controller: Tried to neutralize more than balance\"\n            );\n            amountToNeutralize = amount;\n        } else {\n            amountToNeutralize = maxNeutralizable;\n        }\n\n        // use the QuantCalculator to check how much collateral the sender/signer is due\n        // for closing the neutral position\n        (address collateralType, uint256 collateralOwed) = IQuantCalculator(\n            quantCalculator\n        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);\n\n        // burn the short tokens\n        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);\n\n        // burn the long tokens\n        collateralToken.burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToNeutralize\n        );\n\n        // tranfer the collateral owed\n        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);\n\n        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)\n        if (qTokenLong != address(0)) {\n            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);\n        }\n\n        emit NeutralizePosition(\n            _msgSender(),\n            qTokenShort,\n            amountToNeutralize,\n            collateralOwed,\n            collateralType,\n            qTokenLong\n        );\n    }\n\n    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.\n    /// @param _qToken The QToken to be approved.\n    /// @param _spender The address of the spender.\n    /// @param _value The amount of tokens to be approved for spending.\n    /// @param _deadline Timestamp at which the permit signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _qTokenPermit(\n        address _qToken,\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IQToken(_qToken).permit(\n            _owner,\n            _spender,\n            _value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice Allows a CollateralToken owner to either approve an operator address\n    /// to spend all of their tokens on their behalf, or to remove a prior approval.\n    /// @param _owner The address of the owner of the CollateralToken.\n    /// @param _operator The address of the operator to be approved or removed.\n    /// @param _approved Whether the operator is being approved or removed.\n    /// @param _nonce The nonce for the approval through a meta transaction.\n    /// @param _deadline Timestamp at which the approval signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _collateralTokenApproval(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _nonce,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(\n                _owner,\n                _operator,\n                _approved,\n                _nonce,\n                _deadline,\n                _v,\n                _r,\n                _s\n            );\n    }\n\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n\n    /// @notice Checks if the given QToken has not expired yet, reverting otherwise\n    /// @param _qToken The address of the QToken to check.\n    function _checkIfUnexpiredQToken(address _qToken) internal view {\n        require(\n            IQToken(_qToken).expiryTime() > block.timestamp,\n            \"Controller: Cannot mint expired options\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n    function executeMetaTransaction(\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external payable returns (bytes memory) {\n        require(\n            _verify(metaAction.from, metaAction, r, s, v),\n            \"signer and signature don't match\"\n        );\n\n        uint256 currentNonce = _nonces[metaAction.from];\n\n        // intentionally allow this to overflow to save gas,\n        // and it's impossible for someone to do 2 ^ 256 1 meta txs\n        unchecked {\n            _nonces[metaAction.from] = currentNonce + 1;\n        }\n\n        // Append the metaAction.from at the end so that it can be extracted later\n        // from the calling context (see _msgSender() below)\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    IController(address(this)).operate.selector,\n                    metaAction.actions\n                ),\n                metaAction.from\n            )\n        );\n\n        require(success, \"unsuccessful function call\");\n        emit MetaTransactionExecuted(\n            metaAction.from,\n            payable(msg.sender),\n            currentNonce\n        );\n        return returnData;\n    }\n"
                ],
                "Type": "  EIP712MetaTransaction.executeMetaTransaction()  failed txs are open to replay attacks",
                "Description": "\nAny transactions that fail based on some conditions that may change in the future are not safe to be executed again later (e.g. transactions that are based on others actions, or time-dependent etc).\n\nIn the current implementation, once the low-level call is failed, the whole tx will be reverted and so that _nonces[metaAction.from] will remain unchanged.\n\nAs a result, the same tx can be replayed by anyone, using the same signature.\n\nEIP712MetaTransaction.sol#L86(https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86)<br\n\nsolidity\n    function executeMetaTransaction(\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external payable returns (bytes memory) {\n        require(\n            _verify(metaAction.from, metaAction, r, s, v),\n            \"signer and signature don't match\"\n        );\n\n        uint256 currentNonce = _nonces[metaAction.from];\n\n        // intentionally allow this to overflow to save gas,\n        // and it's impossible for someone to do 2 ^ 256 1 meta txs\n        unchecked {\n            _nonces[metaAction.from] = currentNonce + 1;\n        }\n\n        // Append the metaAction.from at the end so that it can be extracted later\n        // from the calling context (see _msgSender() below)\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    IController(address(this)).operate.selector,\n                    metaAction.actions\n                ),\n                metaAction.from\n            )\n        );\n\n        require(success, \"unsuccessful function call\");\n        emit MetaTransactionExecuted(\n            metaAction.from,\n            payable(msg.sender),\n            currentNonce\n        );\n        return returnData;\n    }\n\n\nSee also the implementation of OpenZeppelin's MinimalForwarder:\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/metatx/MinimalForwarder.sol#L42-L66\n\n\nGiven:\n\n*   The collateral is USDC;\n*   Alice got 10,000 USDC in the wallet.\n\n1.  Alice submitted a MetaTransaction to operate() and _mintOptionsPosition() with 10,000 USDC;\n2.  Before the MetaTransaction get executed, Alice sent 1,000 USDC to Bob;\n3.  The MetaTransaction submited by Alice in step 1 get executed but failed;\n4.  A few days later, Bob sent 1,000 USDC to Alice;\n5.  The attacker can replay the MetaTransaction failed to execute at step 3 and succeed.\n\nAlice's 10,000 USDC is now been spent unexpectedly against her will and can potentially cause fund loss depends on the market situation.\n\n",
                "Repair": "\nFailed txs should still increase the nonce.\n\nWhile implementating the change above, consider adding one more check to require sufficient gas to be paid, to prevent \"insufficient gas griefing attack\" as described in this article(https://ipfs.io/ipfs/QmbbYTGTeot9ic4hVrsvnvVuHw4b5P7F5SeMSNX9TYPGjY/blog/ethereum-gas-dangers/).\n\n0xca11 (Rolla) confirmed, resolved, and commented(https://github.com/code-423n4/2022-03-rolla-findings/issues/45#issuecomment-1102144427):\n  Meta transactions replay and insufficient gas griefing attacks are now prevented since RollaProject/quant-protocol#80(https://github.com/RollaProject/quant-protocol/pull/80).\n\n\n\n*\n \n\n"
            }
        ]
    }
]