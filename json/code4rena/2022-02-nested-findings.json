[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation &&\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"../OperatorResolver.sol\";\nimport \"../interfaces/IOperatorResolver.sol\";\nimport \"../interfaces/INestedFactory.sol\";\n\n/// @title Mixin operator resolver\n/// @notice Store in cache operators name and address/selector\nabstract contract MixinOperatorResolver {\n    /// @notice Emitted when cache is updated\n    /// @param name The operator name\n    /// @param destination The operator address\n    event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\n\n    /// @dev The OperatorResolver used to build the cache\n    OperatorResolver public immutable resolver;\n\n    /// @dev Cache operators map of the name and Operator struct (address/selector)\n    mapping(bytes32 => IOperatorResolver.Operator) private operatorCache;\n\n    constructor(address _resolver) {\n        resolver = OperatorResolver(_resolver);\n    }\n\n    /// @dev This function is public not external in order for it to be overridden and\n    ///      invoked via super in subclasses\n    function resolverOperatorsRequired() public view virtual returns (bytes32[] memory) {}\n\n    /// @notice Rebuild the operatorCache\n    function rebuildCache() external {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory destination;\n        // The resolver must call this function whenever it updates its state\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            destination = resolver.getOperator(name);\n            if (destination.implementation != address(0)) {\n                operatorCache[name] = destination;\n            } else {\n                delete operatorCache[name];\n            }\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /// @notice Check the state of operatorCache\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory cacheTmp;\n        IOperatorResolver.Operator memory actualValue;\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            cacheTmp = operatorCache[name];\n            actualValue = resolver.getOperator(name);\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (\n                actualValue.implementation != cacheTmp.implementation ||\n                actualValue.selector != cacheTmp.selector ||\n                cacheTmp.implementation == address(0)\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev Get operator address in cache and require (if exists)\n    /// @param name The operator name\n    /// @return The operator address\n    function requireAndGetAddress(bytes32 name) internal view returns (IOperatorResolver.Operator memory) {\n        IOperatorResolver.Operator memory _foundAddress = operatorCache[name];\n        require(_foundAddress.implementation != address(0), string(abi.encodePacked(\"MOR: MISSING_OPERATOR: \", name)));\n        return _foundAddress;\n    }\n\n    /// @dev Build the calldata (with safe datas) and call the Operator\n    /// @param _order The order to execute\n    /// @return success If the operator call is successful\n    /// @return amounts The amounts from the execution (used and received)\n    ///         - amounts[0] : The amount of output token\n    ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)\n    function callOperator(\n        INestedFactory.Order calldata _order,\n        address _inputToken,\n        address _outputToken\n    ) internal returns (bool success, uint256[] memory amounts) {\n        IOperatorResolver.Operator memory _operator = requireAndGetAddress(_order.operator);\n        // Parameters are concatenated and padded to 32 bytes.\n        // We are concatenating the selector + given params\n        bytes memory data;\n        (success, data) = _operator.implementation.delegatecall(bytes.concat(_operator.selector, _order.callData));\n\n        if (success) {\n            address[] memory tokens;\n            (amounts, tokens) = abi.decode(data, (uint256[], address[]));\n            require(tokens[0] == _outputToken, \"OH: INVALID_OUTPUT_TOKEN\");\n            require(tokens[1] == _inputToken, \"OH: INVALID_OUTPUT_TOKEN\");\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "OperatorResolver.sol",
            "MixinOperatorResolver.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\n/// @inheritdoc INestedFactory\nfunction addOperator(bytes32 operator) external override onlyOwner {\n  require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n  bytes32[] memory operatorsCache = operators;\n  for (uint256 i = 0; i < operatorsCache.length; i++) {\n      require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n  }\n  operators.push(operator);\n  emit OperatorAdded(operator);\n}\n",
                    "//solidity\n/// @notice Rebuild the operatorCache\nfunction rebuildCache() external {\n    bytes32[] memory requiredOperators = resolverOperatorsRequired();\n    bytes32 name;\n    IOperatorResolver.Operator memory destination;\n    // The resolver must call this function whenever it updates its state\n    for (uint256 i = 0; i < requiredOperators.length; i++) {\n        name = requiredOperators[i];\n        // Note: can only be invoked once the resolver has all the targets needed added\n        destination = resolver.getOperator(name);\n        if (destination.implementation != address(0)) {\n            operatorCache[name] = destination;\n        } else {\n            delete operatorCache[name];\n        }\n        emit CacheUpdated(name, destination);\n    }\n}\n",
                    "//solidity\n/// @inheritdoc INestedFactory\nfunction removeOperator(bytes32 operator) external override onlyOwner {\n  uint256 operatorsLength = operators.length;\n  for (uint256 i = 0; i < operatorsLength; i++) {\n      if (operators[i] == operator) {\n          operators[i] = operators[operatorsLength 1];\n          operators.pop();\n          emit OperatorRemoved(operator);\n          return;\n      }\n  }\n  revert(\"NF: NON_EXISTENT_OPERATOR\");\n}\n",
                    "//solidity\n/// @notice Check the state of operatorCache\nfunction isResolverCached() external view returns (bool) {\n  bytes32[] memory requiredOperators = resolverOperatorsRequired();\n  bytes32 name;\n  IOperatorResolver.Operator memory cacheTmp;\n  IOperatorResolver.Operator memory actualValue;\n  for (uint256 i = 0; i < requiredOperators.length; i++) {\n"
                ],
                "Type": "  NestedFactory  does not track operators properly",
                "Description": "\nNestedFactory.sol#L99-L108(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108)<br\nMixinOperatorResolver.sol#L30-L47(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47)<br\nNestedFactory.sol#L110-L122(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122)<br\nMixinOperatorResolver.sol#L49-L55(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55)\n\nNestedFactory extends the MixinOperatorResolver contract which comes from the synthetix/MixinResolver.sol(https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/contracts/MixinResolver.sol) code base where the expectation is that isResolverCached() returns false until rebuildCache() is called and the cache is fully up to date(https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/test/contracts/MixinResolver.js#L82-L105). Due to a medium issue(https://github.com/code-423n4/2021-11-nested-findings/issues/217) identified in a prior contest, the OperatorResolver.importOperators() step was made to be atomically combined with the NestedFactory.rebuildCache() step. However, the atomicity was not applied everywhere and the ability to add/remove operators from the NestedFactory also had other cache-inconsistency issues. There are *four separate instances* of operator tracking problems in this submission.\n\n\nAs with the prior issue, many core operations (such as NestedFactory.create() and NestedFactory.swapTokenForTokens()) are dependant on the assumption that the operatorCache cache is synced prior to these functions being executed, but this may not necessarily be the case. Unlike the prior issue which was about updates to the resolver not getting reflected in the cache, this issue is about changes to the factory not updating the cache.\n\n\n\n1.  NestedFactory.removeOperator() is called to remove an operator\n2.  A user calls NestedFactory(MixinOperatorResolver).create() using that operator and succeedes\n3.  NestedFactory.rebuildCache() is called to rebuild cache\n\nThis flow is not aware that the cache is not in sync\n\nsolidity\n/// @inheritdoc INestedFactory\nfunction addOperator(bytes32 operator) external override onlyOwner {\n  require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n  bytes32[] memory operatorsCache = operators;\n  for (uint256 i = 0; i < operatorsCache.length; i++) {\n      require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n  }\n  operators.push(operator);\n  emit OperatorAdded(operator);\n}\n\n\nNestedFactory.sol#L99-L108(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108)\n\n\nEven if removeOperator() calls rebuildCache() the function will still not work because resolverOperatorsRequired() only keeps track of remaining operators, and rebuildCache() currently has no way of knowing that an entry was removed from that array and that a corresponding entry from operatorCache needs to be removed too.\n\nsolidity\n/// @notice Rebuild the operatorCache\nfunction rebuildCache() external {\n    bytes32[] memory requiredOperators = resolverOperatorsRequired();\n    bytes32 name;\n    IOperatorResolver.Operator memory destination;\n    // The resolver must call this function whenever it updates its state\n    for (uint256 i = 0; i < requiredOperators.length; i++) {\n        name = requiredOperators[i];\n        // Note: can only be invoked once the resolver has all the targets needed added\n        destination = resolver.getOperator(name);\n        if (destination.implementation != address(0)) {\n            operatorCache[name] = destination;\n        } else {\n            delete operatorCache[name];\n        }\n        emit CacheUpdated(name, destination);\n    }\n}\n\n\nMixinOperatorResolver.sol#L30-L47(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47)\n\n\n1.  NestedFactory.addOperator() is called to add an operator\n2.  A user calls NestedFactory(MixinOperatorResolver).create() using that operator and fails because the operator wasn't in the resolverOperatorsRequired() during the last call to rebuildCaches(), so the operator isn't in operatorCache\n3.  NestedFactory.rebuildCache() is called to rebuild cache\n\nThis flow is not aware that the cache is not in sync\n\nsolidity\n/// @inheritdoc INestedFactory\nfunction removeOperator(bytes32 operator) external override onlyOwner {\n  uint256 operatorsLength = operators.length;\n  for (uint256 i = 0; i < operatorsLength; i++) {\n      if (operators[i] == operator) {\n          operators[i] = operators[operatorsLength 1];\n          operators.pop();\n          emit OperatorRemoved(operator);\n          return;\n      }\n  }\n  revert(\"NF: NON_EXISTENT_OPERATOR\");\n}\n\n\nNestedFactory.sol#L110-L122(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122)\n\n\nThis function, like removeOperator() is not able to tell that there is an operator that needs to be removed from resolverCache, causing the owner not to know a call to rebuildCache() is required to 'remove' the operator\n\nsolidity\n/// @notice Check the state of operatorCache\nfunction isResolverCached() external view returns (bool) {\n  bytes32[] memory requiredOperators = resolverOperatorsRequired();\n  bytes32 name;\n  IOperatorResolver.Operator memory cacheTmp;\n  IOperatorResolver.Operator memory actualValue;\n  for (uint256 i = 0; i < requiredOperators.length; i++) {\n\n\nMixinOperatorResolver.sol#L49-L55(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55)\n\n",
                "Repair": "\nAdd calls to rebuildCache() in addOperator() and removeOperator(), have INestedFactory also track operators that have been removed with a new array, and have isResolverCached() also check whether this new array is empty or not.\n\nmaximebrugel (Nested Finance) confirmed and commented(https://github.com/code-423n4/2022-02-nested-findings/issues/38#issuecomment-1041944815):\n  With this fix = #18(https://github.com/code-423n4/2022-02-nested-findings/issues/18)<br\n No need to add an array of removed operators, because we are now removing the operators from the cache at the same time. Only need to call rebuildCache when adding and removing operators.\n \n PR: Med/High Risk Fixes(https://github.com/NestedFi/nested-core-lego/pull/100)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is received\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Emitted when the royalties weight is updated\n    /// @param weigth The new weigth\n    event RoyaltiesWeightUpdated(uint256 weigth);\n\n    /// @dev Emitted when a new shareholder is added\n    /// @param account The new shareholder account\n    /// @param weight The shareholder weigth\n    event ShareholdersAdded(address account, uint256 weight);\n\n    /// @dev Emitted when a shareholder weight is updated\n    /// @param account The shareholder address\n    /// @param weight The new weight\n    event ShareholderUpdated(address account, uint256 weight);\n\n    /// @dev Emitted when royalties are claim released\n    /// @param to The address claiming the royalties\n    /// @param token The token received\n    /// @param value The amount received\n    event RoyaltiesReceived(address to, address token, uint256 value);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint96 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        address[] memory _accounts,\n        uint96[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        require(_weth != address(0), \"FS: INVALID_ADDRESS\");\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(msg.sender == weth, \"FS: ETH_SENDER_NOT_WETH\");\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        require(_weight != 0, \"FS: WEIGHT_ZERO\");\n        totalWeights = totalWeights + _weight - royaltiesWeight;\n        royaltiesWeight = _weight;\n        emit RoyaltiesWeightUpdated(_weight);\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint96[] memory _weights) public onlyOwner {\n        delete shareholders;\n        uint256 accountsLength = _accounts.length;\n        require(accountsLength != 0 && accountsLength == _weights.length, \"FS: INPUTS_LENGTH_MUST_MATCH\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < accountsLength; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {\n        require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");\n        totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;\n        require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");\n        shareholders[_accountIndex].weight = _weight;\n        emit ShareholderUpdated(shareholders[_accountIndex].account, _weight);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @notice Release multiple tokens and handle ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            if (address(_tokens[i]) == weth) {\n                IWETH(weth).withdraw(amount);\n                (bool success, ) = _msgSender().call{ value: amount }(\"\");\n                require(success, \"FS: ETH_TRANFER_ERROR\");\n            } else {\n                _tokens[i].safeTransfer(_msgSender(), amount);\n            }\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Release multiple tokens without ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokensNoETH(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            _tokens[i].safeTransfer(_msgSender(), amount);\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights;\n        unchecked {\n            weights = totalWeights - royaltiesWeight;\n        }\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FS: INVALID_ROYALTIES_TARGET\");\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_msgSender(), address(this), _amount);\n        uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;\n\n        uint256 royaltiesAmount = _computeShareCount(amountReceived, royaltiesWeight, totalWeights);\n\n        _sendFees(_token, amountReceived, totalWeights);\n        _addShares(_royaltiesTarget, royaltiesAmount, address(_token));\n\n        emit RoyaltiesReceived(_royaltiesTarget, address(_token), royaltiesAmount);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        if (_tokenRecords.totalShares == 0) return 0;\n\n        uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));\n        return\n            (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FS: SHAREHOLDER_NOT_FOUND\");\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @notice Transfers a fee to this contract\n    /// @dev This method calculates the amount received, to support deflationary tokens\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token sent\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        Shareholder[] memory shareholdersCache = shareholders;\n        for (uint256 i = 0; i < shareholdersCache.length; i++) {\n            _addShares(\n                shareholdersCache[i].account,\n                _computeShareCount(_amount, shareholdersCache[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares += _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FS: NO_PAYMENT_DUE\");\n\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        _tokenRecords.released[_account] += amountToRelease;\n        _tokenRecords.totalReleased += amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint96 _weight) private {\n        require(_weight != 0, \"FS: ZERO_WEIGHT\");\n        require(_account != address(0), \"FS: INVALID_ADDRESS\");\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            require(shareholders[i].account != _account, \"FS: ALREADY_SHAREHOLDER\");\n        }\n\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n        emit ShareholdersAdded(_account, _weight);\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./abstracts/OwnableFactoryHandler.sol\";\n\n/// @title Collection of NestedNFTs used to represent ownership of real assets stored in NestedReserves\n/// @dev Only NestedFactory contracts are allowed to call functions that write to storage\ncontract NestedAsset is ERC721Enumerable, OwnableFactoryHandler {\n    using Counters for Counters.Counter;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    Counters.Counter private _tokenIds;\n\n    /// @dev Stores the URI of each asset\n    mapping(uint256 => string) private _tokenURIs;\n\n    /// @dev Stores the original asset of each asset\n    mapping(uint256 => uint256) public originalAsset;\n\n    /// @dev Stores owners of burnt assets\n    mapping(uint256 => address) public lastOwnerBeforeBurn;\n\n    /* ---------------------------- CONSTRUCTORS --------------------------- */\n\n    constructor() ERC721(\"NestedNFT\", \"NESTED\") {}\n\n    /* ----------------------------- MODIFIERS ----------------------------- */\n\n    /// @dev Reverts the transaction if the address is not the token owner\n    modifier onlyTokenOwner(address _address, uint256 _tokenId) {\n        require(_address == ownerOf(_tokenId), \"NA: FORBIDDEN_NOT_OWNER\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @return The token Uniform Resource Identifier (URI)\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n        require(_exists(_tokenId), \"URI query for nonexistent token\");\n        return _tokenURIs[_tokenId];\n    }\n\n    /// @notice Returns the owner of the original token if the token was replicated\n    /// If the original asset was burnt, the last owner before burn is returned\n    /// @param _tokenId The asset for which we want to know the original owner\n    /// @return The owner of the original asset\n    function originalOwner(uint256 _tokenId) public view returns (address) {\n        uint256 originalAssetId = originalAsset[_tokenId];\n\n        if (originalAssetId != 0) {\n            return _exists(originalAssetId) ? ownerOf(originalAssetId) : lastOwnerBeforeBurn[originalAssetId];\n        }\n        return address(0);\n    }\n\n    /* ---------------------------- ONLY FACTORY --------------------------- */\n\n    /// @notice Mints an ERC721 token for the user and stores the original asset used to create the new asset if any\n    /// @param _owner The account address that signed the transaction\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mint(address _owner, uint256 _replicatedTokenId) public onlyFactory returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 tokenId = _tokenIds.current();\n        _safeMint(_owner, tokenId);\n\n        // Stores the first asset of the replication chain as the original\n        if (_replicatedTokenId == 0) {\n            return tokenId;\n        }\n\n        require(_exists(_replicatedTokenId) && tokenId != _replicatedTokenId, \"NA: INVALID_REPLICATED_TOKEN_ID\");\n\n        uint256 originalTokenId = originalAsset[_replicatedTokenId];\n        originalAsset[tokenId] = originalTokenId != 0 ? originalTokenId : _replicatedTokenId;\n\n        return tokenId;\n    }\n\n    /// @notice Mints an ERC721 token and sets the tokenUri.\n    /// Only the NestedFactory contract can call this function.\n    /// @param _owner The account address that signed the transaction\n    /// @param _metadataURI he metadata URI string\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mintWithMetadata(\n        address _owner,\n        string memory _metadataURI,\n        uint256 _replicatedTokenId\n    ) external returns (uint256) {\n        uint256 tokenId = mint(_owner, _replicatedTokenId);\n        _setTokenURI(tokenId, _metadataURI);\n        return tokenId;\n    }\n\n    /// @notice Backfills the token URI if it had never set\n    /// @param _tokenId The id of the NestedAsset\n    /// @param _owner The id of the NestedAsset\n    /// @param _metadataURI The metadata URI string\n    function backfillTokenURI(\n        uint256 _tokenId,\n        address _owner,\n        string memory _metadataURI\n    ) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        require(bytes(tokenURI(_tokenId)).length == 0, \"NA: TOKEN_URI_IMMUTABLE\");\n        _setTokenURI(_tokenId, _metadataURI);\n    }\n\n    /// @notice Burns an ERC721 token\n    /// @param _owner The account address that signed the transaction\n    /// @param _tokenId The id of the NestedAsset\n    function burn(address _owner, uint256 _tokenId) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        lastOwnerBeforeBurn[_tokenId] = _owner;\n        _burn(_tokenId);\n\n        if (bytes(_tokenURIs[_tokenId]).length != 0) {\n            delete _tokenURIs[_tokenId];\n        }\n    }\n\n    /* ------------------------- INTERNAL FUNCTIONS ------------------------ */\n\n    /// @dev Sets the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @param _metadataURI The metadata URI string\n    function _setTokenURI(uint256 _tokenId, string memory _metadataURI) internal {\n        _tokenURIs[_tokenId] = _metadataURI;\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "FeeSplitter.sol",
            "NestedAsset.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "javascript\n /// @dev Transfer tokens to the reserve, and compute the amount received to store\n /// in the records. We need to know the amount received in case of deflationary tokens.\n /// @param _token The token to transfer (IERC20)\n /// @param _amount The amount to send to the reserve\n /// @param _nftId The Token ID to store the assets\n function _transferToReserveAndStore(\n     IERC20 _token,\n     uint256 _amount,\n     uint256 _nftId\n ) private {\n     address reserveAddr = address(reserve);\n     uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n     // Send output to reserve\n     _token.safeTransfer(reserveAddr, _amount);\n     uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n     nestedRecords.store(_nftId, address(_token), balanceReserveAfter balanceReserveBefore, reserveAddr);\n }\n ",
                    "javascript\n amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n \n (...)\n \n amountBought = _batchedOrders.outputToken.balanceOf(address(this)) amountBought;\n feesAmount = amountBought / 100; // 1% Fee\n if (_toReserve) {\n     _transferToReserveAndStore(_batchedOrders.outputToken, amountBought feesAmount, _nftId);\n }\n ",
                    "javascript\n (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n require(success, \"NF: OPERATOR_CALL_FAILED\");\n if (_toReserve) {\n     _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n }\n "
                ],
                "Type": " Undesired behavior",
                "Description": "\nNestedRecords.sol#L117-L131(https://github.com/code-423n4/2022-02-nested/blob/69cf51d8e4eeb8bce3025db7f4f74cc565c9fad3/contracts/NestedRecords.sol#:~:text=uint256%20amount%20%3D%20records,_nftId%5D.reserve%20%3D%20_reserve%3B)<br\n\nYou push a parameter into an array of tokens without checking if it already exists. And, if at first it's added with amount 0, it can later on be pushed with a greater amount and be twice in the array. Then in all processing it will consider the first occurrence and therefore the occurrence with amount 0.\n\n         NestedRecords.store pushed the parameter _token\n\nmaximebrugel (Nested Finance) disagreed with High severity and commented(https://github.com/code-423n4/2022-02-nested-findings/issues/6#issuecomment-1034735686):\n  Indeed, _amount is not checked and may result in the loss of funds for the user... If we only look at the store function.\n \n However, this situation can't happen because of the NestedFactory' (the only one able to call).\n \n The Factory is calling with this private function : \n javascript\n /// @dev Transfer tokens to the reserve, and compute the amount received to store\n /// in the records. We need to know the amount received in case of deflationary tokens.\n /// @param _token The token to transfer (IERC20)\n /// @param _amount The amount to send to the reserve\n /// @param _nftId The Token ID to store the assets\n function _transferToReserveAndStore(\n     IERC20 _token,\n     uint256 _amount,\n     uint256 _nftId\n ) private {\n     address reserveAddr = address(reserve);\n     uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n     // Send output to reserve\n     _token.safeTransfer(reserveAddr, _amount);\n     uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n     nestedRecords.store(_nftId, address(_token), balanceReserveAfter balanceReserveBefore, reserveAddr);\n }\n \n \n Here, the store amount parameter can be 0 if : \n _amount is equal to 0. Then balanceReserveAfter balanceReserveBefore = 0.\n _amount is not equal to 0 but the safeTransfer function is transferring 0 tokens (100% fees, malicious contract,...).\n \n We can't consider the second option, It is an external cause and we are not able to manage the exotic behaviors of ERC20s.\n So, when the _amount parameter of this function can be equal to 0 ?\n \n = In submitOutOrders : \n javascript\n amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n \n (...)\n \n amountBought = _batchedOrders.outputToken.balanceOf(address(this)) amountBought;\n feesAmount = amountBought / 100; // 1% Fee\n if (_toReserve) {\n     _transferToReserveAndStore(_batchedOrders.outputToken, amountBought feesAmount, _nftId);\n }\n \n But the ZeroExOperator or FlatOperator will revert if the amount bought is 0.\n \n = In _submitOrder\n \n javascript\n (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n require(success, \"NF: OPERATOR_CALL_FAILED\");\n if (_toReserve) {\n     _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n }\n \n Same,  the ZeroExOperator or FlatOperator will revert if the amount bought is 0.\n \n In conclusion, we should check this parameter, but in the actual code state it can't happen (without taking into account the exotic ERC20s that we do not manage). If we add an operator that does not check the amount bought it can happen, so, maybe reducing the severity ?\n \n PR: Med/High Risk Fixes(https://github.com/NestedFi/nested-core-lego/pull/100)\n\nharleythedog (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-nested-findings/issues/6#issuecomment-1053229547):\n  Agree with sponsor, this issue doesn't exist with the current operators, so it is not currently a threat. I am going to downgrade this to medium.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is received\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Emitted when the royalties weight is updated\n    /// @param weigth The new weigth\n    event RoyaltiesWeightUpdated(uint256 weigth);\n\n    /// @dev Emitted when a new shareholder is added\n    /// @param account The new shareholder account\n    /// @param weight The shareholder weigth\n    event ShareholdersAdded(address account, uint256 weight);\n\n    /// @dev Emitted when a shareholder weight is updated\n    /// @param account The shareholder address\n    /// @param weight The new weight\n    event ShareholderUpdated(address account, uint256 weight);\n\n    /// @dev Emitted when royalties are claim released\n    /// @param to The address claiming the royalties\n    /// @param token The token received\n    /// @param value The amount received\n    event RoyaltiesReceived(address to, address token, uint256 value);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint96 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        address[] memory _accounts,\n        uint96[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        require(_weth != address(0), \"FS: INVALID_ADDRESS\");\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(msg.sender == weth, \"FS: ETH_SENDER_NOT_WETH\");\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        require(_weight != 0, \"FS: WEIGHT_ZERO\");\n        totalWeights = totalWeights + _weight - royaltiesWeight;\n        royaltiesWeight = _weight;\n        emit RoyaltiesWeightUpdated(_weight);\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint96[] memory _weights) public onlyOwner {\n        delete shareholders;\n        uint256 accountsLength = _accounts.length;\n        require(accountsLength != 0 && accountsLength == _weights.length, \"FS: INPUTS_LENGTH_MUST_MATCH\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < accountsLength; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {\n        require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");\n        totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;\n        require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");\n        shareholders[_accountIndex].weight = _weight;\n        emit ShareholderUpdated(shareholders[_accountIndex].account, _weight);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @notice Release multiple tokens and handle ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            if (address(_tokens[i]) == weth) {\n                IWETH(weth).withdraw(amount);\n                (bool success, ) = _msgSender().call{ value: amount }(\"\");\n                require(success, \"FS: ETH_TRANFER_ERROR\");\n            } else {\n                _tokens[i].safeTransfer(_msgSender(), amount);\n            }\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Release multiple tokens without ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokensNoETH(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            _tokens[i].safeTransfer(_msgSender(), amount);\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights;\n        unchecked {\n            weights = totalWeights - royaltiesWeight;\n        }\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FS: INVALID_ROYALTIES_TARGET\");\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_msgSender(), address(this), _amount);\n        uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;\n\n        uint256 royaltiesAmount = _computeShareCount(amountReceived, royaltiesWeight, totalWeights);\n\n        _sendFees(_token, amountReceived, totalWeights);\n        _addShares(_royaltiesTarget, royaltiesAmount, address(_token));\n\n        emit RoyaltiesReceived(_royaltiesTarget, address(_token), royaltiesAmount);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        if (_tokenRecords.totalShares == 0) return 0;\n\n        uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));\n        return\n            (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FS: SHAREHOLDER_NOT_FOUND\");\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @notice Transfers a fee to this contract\n    /// @dev This method calculates the amount received, to support deflationary tokens\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token sent\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        Shareholder[] memory shareholdersCache = shareholders;\n        for (uint256 i = 0; i < shareholdersCache.length; i++) {\n            _addShares(\n                shareholdersCache[i].account,\n                _computeShareCount(_amount, shareholdersCache[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares += _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FS: NO_PAYMENT_DUE\");\n\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        _tokenRecords.released[_account] += amountToRelease;\n        _tokenRecords.totalReleased += amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint96 _weight) private {\n        require(_weight != 0, \"FS: ZERO_WEIGHT\");\n        require(_account != address(0), \"FS: INVALID_ADDRESS\");\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            require(shareholders[i].account != _account, \"FS: ALREADY_SHAREHOLDER\");\n        }\n\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n        emit ShareholdersAdded(_account, _weight);\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "FeeSplitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "jsx\nif (address(_inputToken) == ETH) {\n  require(address(this).balance = _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n  weth.deposit{ value: _inputTokenAmount }();\n  return (IERC20(address(weth)), _inputTokenAmount);\n}\n"
                ],
                "Type": "  NestedFactory : User can utilise accidentally sent ETH funds via  processOutputOrders()  /  processInputAndOutputOrders() ",
                "Description": "\nNestedFactory.sol#L71(https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L71)<br\nNestedFactory.sol#L286-L296(https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L286-L296)<br\nNestedFactory.sol#L370-L375(https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L370-L375)<br\nNestedFactory.sol#L482-L492(https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L482-L492)<br\n\nShould a user accidentally send ETH to the NestedFactory, anyone can utilise it to their own benefit by calling processOutputOrders() / processInputAndOutputOrders(). This is possible because:\n\n1.  receive() has no restriction on the sender\n2.  processOutputOrders() does not check msg.value, and rightly so, because funds are expected to come from reserve.\n3.  transferInputTokens() does not handle the case where ETH could be specified as an address by the user for an output order.\n\njsx\nif (address(_inputToken) == ETH) {\n  require(address(this).balance = _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n  weth.deposit{ value: _inputTokenAmount }();\n  return (IERC20(address(weth)), _inputTokenAmount);\n}\n\n\nHence, the attack vector is simple. Should a user accidentally send ETH to the contract, create an output Order with token being ETH and amount corresponding to the NestedFactory\u2019s ETH balance.\n\n",
                "Repair": "\n1.  Since plain / directETH transfers are only expected to solely come from weth (excluding payable functions), we recommend restricting the sender to be weth, like how it is done in [FeeSplitter(https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L101-L104).\n\n    We are aware that this was raised previously here: code-423n4/2021-11-nested-findings#188(https://github.com/code-423n4/2021-11-nested-findings/issues/188) and would like to add that restricting the sender in the receive() function will not affect payable functions. From from what we see, plain ETH transfers are also not expected to come from other sources like NestedReserve or operators.\n\nsolidity\nreceive() external payable {\n  require(msg.sender == address(weth), \"NF: ETH_SENDER_NOT_WETH\");\n}\n\n\n2.  Check that _fromReserve is false in the scenario address(_inputToken) == ETH.\n\nsolidity\nif (address(_inputToken) == ETH) {\n  require(!_fromReserve, \"NF: INVALID_INPUT_TOKEN\");\n  require(address(this).balance = _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n  weth.deposit{ value: _inputTokenAmount }();\n  return (IERC20(address(weth)), _inputTokenAmount);\n}\n\n\nmaximebrugel (Nested Finance) confirmed and resolved(https://github.com/code-423n4/2022-02-nested-findings/issues/44):\n PR: Med/High Risk Fixes(https://github.com/NestedFi/nested-core-lego/pull/100)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./abstracts/OwnableFactoryHandler.sol\";\n\n/// @title Collection of NestedNFTs used to represent ownership of real assets stored in NestedReserves\n/// @dev Only NestedFactory contracts are allowed to call functions that write to storage\ncontract NestedAsset is ERC721Enumerable, OwnableFactoryHandler {\n    using Counters for Counters.Counter;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    Counters.Counter private _tokenIds;\n\n    /// @dev Stores the URI of each asset\n    mapping(uint256 => string) private _tokenURIs;\n\n    /// @dev Stores the original asset of each asset\n    mapping(uint256 => uint256) public originalAsset;\n\n    /// @dev Stores owners of burnt assets\n    mapping(uint256 => address) public lastOwnerBeforeBurn;\n\n    /* ---------------------------- CONSTRUCTORS --------------------------- */\n\n    constructor() ERC721(\"NestedNFT\", \"NESTED\") {}\n\n    /* ----------------------------- MODIFIERS ----------------------------- */\n\n    /// @dev Reverts the transaction if the address is not the token owner\n    modifier onlyTokenOwner(address _address, uint256 _tokenId) {\n        require(_address == ownerOf(_tokenId), \"NA: FORBIDDEN_NOT_OWNER\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @return The token Uniform Resource Identifier (URI)\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n        require(_exists(_tokenId), \"URI query for nonexistent token\");\n        return _tokenURIs[_tokenId];\n    }\n\n    /// @notice Returns the owner of the original token if the token was replicated\n    /// If the original asset was burnt, the last owner before burn is returned\n    /// @param _tokenId The asset for which we want to know the original owner\n    /// @return The owner of the original asset\n    function originalOwner(uint256 _tokenId) public view returns (address) {\n        uint256 originalAssetId = originalAsset[_tokenId];\n\n        if (originalAssetId != 0) {\n            return _exists(originalAssetId) ? ownerOf(originalAssetId) : lastOwnerBeforeBurn[originalAssetId];\n        }\n        return address(0);\n    }\n\n    /* ---------------------------- ONLY FACTORY --------------------------- */\n\n    /// @notice Mints an ERC721 token for the user and stores the original asset used to create the new asset if any\n    /// @param _owner The account address that signed the transaction\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mint(address _owner, uint256 _replicatedTokenId) public onlyFactory returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 tokenId = _tokenIds.current();\n        _safeMint(_owner, tokenId);\n\n        // Stores the first asset of the replication chain as the original\n        if (_replicatedTokenId == 0) {\n            return tokenId;\n        }\n\n        require(_exists(_replicatedTokenId) && tokenId != _replicatedTokenId, \"NA: INVALID_REPLICATED_TOKEN_ID\");\n\n        uint256 originalTokenId = originalAsset[_replicatedTokenId];\n        originalAsset[tokenId] = originalTokenId != 0 ? originalTokenId : _replicatedTokenId;\n\n        return tokenId;\n    }\n\n    /// @notice Mints an ERC721 token and sets the tokenUri.\n    /// Only the NestedFactory contract can call this function.\n    /// @param _owner The account address that signed the transaction\n    /// @param _metadataURI he metadata URI string\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mintWithMetadata(\n        address _owner,\n        string memory _metadataURI,\n        uint256 _replicatedTokenId\n    ) external returns (uint256) {\n        uint256 tokenId = mint(_owner, _replicatedTokenId);\n        _setTokenURI(tokenId, _metadataURI);\n        return tokenId;\n    }\n\n    /// @notice Backfills the token URI if it had never set\n    /// @param _tokenId The id of the NestedAsset\n    /// @param _owner The id of the NestedAsset\n    /// @param _metadataURI The metadata URI string\n    function backfillTokenURI(\n        uint256 _tokenId,\n        address _owner,\n        string memory _metadataURI\n    ) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        require(bytes(tokenURI(_tokenId)).length == 0, \"NA: TOKEN_URI_IMMUTABLE\");\n        _setTokenURI(_tokenId, _metadataURI);\n    }\n\n    /// @notice Burns an ERC721 token\n    /// @param _owner The account address that signed the transaction\n    /// @param _tokenId The id of the NestedAsset\n    function burn(address _owner, uint256 _tokenId) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        lastOwnerBeforeBurn[_tokenId] = _owner;\n        _burn(_tokenId);\n\n        if (bytes(_tokenURIs[_tokenId]).length != 0) {\n            delete _tokenURIs[_tokenId];\n        }\n    }\n\n    /* ------------------------- INTERNAL FUNCTIONS ------------------------ */\n\n    /// @dev Sets the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @param _metadataURI The metadata URI string\n    function _setTokenURI(uint256 _tokenId, string memory _metadataURI) internal {\n        _tokenURIs[_tokenId] = _metadataURI;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation &&\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedAsset.sol",
            "OperatorResolver.sol",
            "NestedFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "selector",
                    "implementation",
                    "bytes",
                    "operators",
                    "true",
                    "areOperatorsImported"
                ],
                "Type": " Wrong logic around  areOperatorsImported ",
                "Description": "\nOperatorResolver.sol#L42-L43(https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L42-L43)<br\n\nThe logic related to the areOperatorsImported method is incorrect and can cause an operator not to be updated because the owner thinks it is already updated, and a vulnerable or defective one can be used.\n\n\nThe operators mapping is made up of a key bytes32 name and a value made up of two values: implementation and selector, both of which identify the contract and function to be called when an operator is invoked.\n\nThe areOperatorsImported method tries to check if the operators to check already exist, however, the check is not done correctly, since && is used instead of ||.\n\nIf the operator with name A and value {implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector=\"performSwapVulnerable\"} exists, and the owner try to check if the operator with name A and value {implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector=\"performSwapFixed\"} exists, that function will return true, and the owner may decide not to import it , producing unexpected errors.\nBecause operators manage the tokens, this error can produce a token lost.\n\n",
                "Repair": "\nChange && by ||\n\nmaximebrugel (Nested Finance) confirmed and resolved(https://github.com/code-423n4/2022-02-nested-findings/issues/17):\n PR: Med/High Risk Fixes(https://github.com/NestedFi/nested-core-lego/pull/100)\n\nharleythedog (judge) commented(https://github.com/code-423n4/2022-02-nested-findings/issues/17#issuecomment-1053625678):\n  Good catch, I agree with severity.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 15 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-02-nested-findings/issues/66) by warden pauliax received the top score from the judge.\n\n_The following wardens also submitted reports: Dravee(https://github.com/code-423n4/2022-02-nested-findings/issues/70), Omik(https://github.com/code-423n4/2022-02-nested-findings/issues/58), IllIllI(https://github.com/code-423n4/2022-02-nested-findings/issues/35), kenzo(https://github.com/code-423n4/2022-02-nested-findings/issues/46), samruna(https://github.com/code-423n4/2022-02-nested-findings/issues/24), gzeon(https://github.com/code-423n4/2022-02-nested-findings/issues/50), bobi(https://github.com/code-423n4/2022-02-nested-findings/issues/45), robee(https://github.com/code-423n4/2022-02-nested-findings/issues/4), rfa(https://github.com/code-423n4/2022-02-nested-findings/issues/65), WatchPug(https://github.com/code-423n4/2022-02-nested-findings/issues/52), GreyArt(https://github.com/code-423n4/2022-02-nested-findings/issues/40), csanuragjain(https://github.com/code-423n4/2022-02-nested-findings/issues/9), 0xliumin(https://github.com/code-423n4/2022-02-nested-findings/issues/33), and ShippooorDAO(https://github.com/code-423n4/2022-02-nested-findings/issues/26)._\n\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "1",
                "Location": [
                    "//solidity\nif (address(_tokens[i]) == weth)\n  IWETH(weth).withdraw(amount);\n  (bool success, ) = _msgSender().call{ value: amount }(\"\");\n  require(success, \"FS: ETH_TRANFER_ERROR\");\n",
                    "//solidity\naddress private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n",
                    "//solidity\nif (address(_tokens[i]) == ETH)\n  ...\n"
                ],
                "Type": "",
                "Description": "\nFunction releaseTokens uses weth, not eth when comparing against a native asset. if the token address is weth, it unwraps and sends the native asset to the user:\n\nsolidity\nif (address(_tokens[i]) == weth)\n  IWETH(weth).withdraw(amount);\n  (bool success, ) = _msgSender().call{ value: amount }(\"\");\n  require(success, \"FS: ETH_TRANFER_ERROR\");\n\n\nReleasing weth token should be left as a valid option if the user prefers wrapped ERC20 eth, and I think for this native purpose there is a not used storage variable named ETH:\n\nsolidity\naddress private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\nBased on my assumptions, the intention was:\n\nsolidity\nif (address(_tokens[i]) == ETH)\n  ...\n\n\nor if you do not want to implement this change, then at least remove this unused variable to save some gas.\nHowever, the issue is small, because the user can always retrieve weth by using another function named releaseTokensNoETH.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "2",
                "Location": [
                    "//solidity\nrequire(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, \"OFP: FORBIDDEN\");\n"
                ],
                "Type": "",
                "Description": "\nThis was mentioned in the Red4Sec audit (NFSC09), but it wasn't fixed here: OwnableProxyDelegation is Context, but still uses msg.sender, not _msgSender():\n\nsolidity\nrequire(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, \"OFP: FORBIDDEN\");\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "5",
                "Location": [
                    "//solidity\nrequire(supportedFactories[_factory], \"OFH: NOT_SUPPORTED\"); \n",
                    "//solidity\nrequire(!supportedFactories[_factory], \"OFH: ALREADY_SUPPORTED\"); \n"
                ],
                "Type": "",
                "Description": "\nIf removeFactory has this check:\n\nsolidity\nrequire(supportedFactories[_factory], \"OFH: NOT_SUPPORTED\"); \n\n\nthen I think addFactory should have an analogous check:\n\nsolidity\nrequire(!supportedFactories[_factory], \"OFH: ALREADY_SUPPORTED\"); \n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "6",
                "Location": [
                    "//solidity\nrequire(assetTokensLength  1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n"
                ],
                "Type": "",
                "Description": "\nThe revert message is a bit misleading here:\n\nsolidity\nrequire(assetTokensLength  1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\n  function setReserve onlyFactory\n"
                ],
                "Type": "",
                "Description": "\nFunction transfer in NestedReserve is never used and can only be called by the factory (onlyFactory), so consider removing it because I think the factory uses a withdraw function from the Reserve.\n\nCurrently never used:\n\nsolidity\n  function setReserve onlyFactory\n\n\nYou can remove it to save some gas, or leave it if it was intended for future use with other factories.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nfunction unlockTokens(IERC20 _token) external override onlyOwner {\n  ...\n  _token.safeTransfer(owner(), amount);\n"
                ],
                "Type": "",
                "Description": "\nCould just use msg.sender and do not call an owner() function here:\n\nsolidity\nfunction unlockTokens(IERC20 _token) external override onlyOwner {\n  ...\n  _token.safeTransfer(owner(), amount);\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nrequire(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n"
                ],
                "Type": "",
                "Description": "\nThere are several functions that call _checkMsgValue. This function is quite expensive as it iterates over all the _batchedOrders and is only relevant when the inputToken is ETH. Later the callers will have to iterate over all the _batchedOrders again anyway, so I think this function should be refactored to significantly reduce gas. My suggestion:\n\nBecause processInputOrders and processInputAndOutputOrders both call _processInputOrders, the logic from _checkMsgValue could be moved to _processInputOrders. function create then can be refactored to re-use _processInputOrders. I see 2 discrepancies here: _fromReserve is always false when _submitInOrders is called from create (could be solved if _processInputOrders takes extra parameter), and _processInputOrders has this extra line:\n\nsolidity\nrequire(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n\nbut this could be solved if you first mint the NFT and then invoke _processInputOrders from create.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nuint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n...\naddress token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n"
                ],
                "Type": "",
                "Description": "\nFunction withdraw calls nestedRecords twice:\n\nsolidity\nuint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n...\naddress token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n\nI think it could just substitute these links by first fetching all the tokens, and then calculating the length itself instead of making 2 external calls for pretty much the same data.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is received\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Emitted when the royalties weight is updated\n    /// @param weigth The new weigth\n    event RoyaltiesWeightUpdated(uint256 weigth);\n\n    /// @dev Emitted when a new shareholder is added\n    /// @param account The new shareholder account\n    /// @param weight The shareholder weigth\n    event ShareholdersAdded(address account, uint256 weight);\n\n    /// @dev Emitted when a shareholder weight is updated\n    /// @param account The shareholder address\n    /// @param weight The new weight\n    event ShareholderUpdated(address account, uint256 weight);\n\n    /// @dev Emitted when royalties are claim released\n    /// @param to The address claiming the royalties\n    /// @param token The token received\n    /// @param value The amount received\n    event RoyaltiesReceived(address to, address token, uint256 value);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint96 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        address[] memory _accounts,\n        uint96[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        require(_weth != address(0), \"FS: INVALID_ADDRESS\");\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(msg.sender == weth, \"FS: ETH_SENDER_NOT_WETH\");\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        require(_weight != 0, \"FS: WEIGHT_ZERO\");\n        totalWeights = totalWeights + _weight - royaltiesWeight;\n        royaltiesWeight = _weight;\n        emit RoyaltiesWeightUpdated(_weight);\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint96[] memory _weights) public onlyOwner {\n        delete shareholders;\n        uint256 accountsLength = _accounts.length;\n        require(accountsLength != 0 && accountsLength == _weights.length, \"FS: INPUTS_LENGTH_MUST_MATCH\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < accountsLength; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {\n        require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");\n        totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;\n        require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");\n        shareholders[_accountIndex].weight = _weight;\n        emit ShareholderUpdated(shareholders[_accountIndex].account, _weight);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @notice Release multiple tokens and handle ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            if (address(_tokens[i]) == weth) {\n                IWETH(weth).withdraw(amount);\n                (bool success, ) = _msgSender().call{ value: amount }(\"\");\n                require(success, \"FS: ETH_TRANFER_ERROR\");\n            } else {\n                _tokens[i].safeTransfer(_msgSender(), amount);\n            }\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Release multiple tokens without ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokensNoETH(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            _tokens[i].safeTransfer(_msgSender(), amount);\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights;\n        unchecked {\n            weights = totalWeights - royaltiesWeight;\n        }\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FS: INVALID_ROYALTIES_TARGET\");\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_msgSender(), address(this), _amount);\n        uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;\n\n        uint256 royaltiesAmount = _computeShareCount(amountReceived, royaltiesWeight, totalWeights);\n\n        _sendFees(_token, amountReceived, totalWeights);\n        _addShares(_royaltiesTarget, royaltiesAmount, address(_token));\n\n        emit RoyaltiesReceived(_royaltiesTarget, address(_token), royaltiesAmount);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        if (_tokenRecords.totalShares == 0) return 0;\n\n        uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));\n        return\n            (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FS: SHAREHOLDER_NOT_FOUND\");\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @notice Transfers a fee to this contract\n    /// @dev This method calculates the amount received, to support deflationary tokens\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token sent\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        Shareholder[] memory shareholdersCache = shareholders;\n        for (uint256 i = 0; i < shareholdersCache.length; i++) {\n            _addShares(\n                shareholdersCache[i].account,\n                _computeShareCount(_amount, shareholdersCache[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares += _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FS: NO_PAYMENT_DUE\");\n\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        _tokenRecords.released[_account] += amountToRelease;\n        _tokenRecords.totalReleased += amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint96 _weight) private {\n        require(_weight != 0, \"FS: ZERO_WEIGHT\");\n        require(_account != address(0), \"FS: INVALID_ADDRESS\");\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            require(shareholders[i].account != _account, \"FS: ALREADY_SHAREHOLDER\");\n        }\n\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n        emit ShareholdersAdded(_account, _weight);\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Asbtract \"Ownable\" contract managing a whitelist of factories\nabstract contract OwnableFactoryHandler is Ownable {\n    /// @dev Emitted when a new factory is added\n    /// @param newFactory Address of the new factory\n    event FactoryAdded(address newFactory);\n\n    /// @dev Emitted when a factory is removed\n    /// @param oldFactory Address of the removed factory\n    event FactoryRemoved(address oldFactory);\n\n    /// @dev Supported factories to interact with\n    mapping(address => bool) public supportedFactories;\n\n    /// @dev Reverts the transaction if the caller is a supported factory\n    modifier onlyFactory() {\n        require(supportedFactories[msg.sender], \"OFH: FORBIDDEN\");\n        _;\n    }\n\n    /// @notice Add a supported factory\n    /// @param _factory The address of the new factory\n    function addFactory(address _factory) external onlyOwner {\n        require(_factory != address(0), \"OFH: INVALID_ADDRESS\");\n        supportedFactories[_factory] = true;\n        emit FactoryAdded(_factory);\n    }\n\n    /// @notice Remove a supported factory\n    /// @param _factory The address of the factory to remove\n    function removeFactory(address _factory) external onlyOwner {\n        require(supportedFactories[_factory], \"OFH: NOT_SUPPORTED\");\n        supportedFactories[_factory] = false;\n        emit FactoryRemoved(_factory);\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "FeeSplitter.sol",
            "OwnableFactoryHandler.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "7",
                "Location": [
                    "receive",
                    "_checkMsgValue",
                    "address private constant ETH =",
                    "supportedFactories[_factory] = true",
                    "removeOperator"
                ],
                "Type": "",
                "Description": "\nNestedFactory has a function unlockTokens that lets admin rescue any ERC20 token. Consider also adding support for rescuing the native asset (e.g. ETH).\n\nmaximebrugel (Nested Finance) commented(https://github.com/code-423n4/2022-02-nested-findings/issues/66#issuecomment-1040355605):\n  01] Function releaseTokens uses weth, not eth<br\n  We are only sending fees with ERC20 (so WETH and not ETH). In the releaseTokens tokens we are unwrapping the WETH to transfer ETH. The nestedFactory is wrapping ETH before sending fees.\n \n But we should remove this variable = address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; and change comment.\n \n 02] OwnableProxyDelegation is Context, but still uses msg.sender, not _msgSender()<br\n Acknowledged. No meta-transaction support for this admin function.\n \n 03] Function rebuildCache() in MixinOperatorResolver does not delete removed operators from operatorCache<br\n Confirmed. The mitigation found is to remove from cache in the removeOperator function.\n \n 04] Consider introducing an upper limit for _timestamp in updateLockTimestamp<br\n Acknowledged. We are not sure about an upper limit to set.\n \n 05] addFactory should have an analogous check<br\n Disputed. No need for a require as long as  supportedFactories[_factory] = true does not disrupt the protocol state.\n \n 06] The revert message is a bit misleading here<br\n Disputed. I don\u2019t really know what is misleading. You can\u2019t withdraw the last token and keep an empty portfolio.\n \n 07] adding support for rescuing the native asset<br\n Acknowledged. We will fix this issue by adding a require in the receive function. Also, the user can't send more ETH than needed with the _checkMsgValue function.\n\nharleythedog (judge) commented(https://github.com/code-423n4/2022-02-nested-findings/issues/66#issuecomment-1057576659):\n  My personal judgements:<br\n 01] \"Function releaseTokens uses weth\"<br\n This is a gas optimization. Will keep it in mind when scoring #67(https://github.com/code-423n4/2022-02-nested-findings/issues/67) G-07]. For here, invalid.\n\n 02] \"OwnableProxyDelegation is Context\"<br\n Valid and very-low-critical.\n\n 03] \"Function rebuildCache() in MixinOperatorResolver does not delete removed operators from operatorCache\"<br\n This has been upgraded to medium severity in #77(https://github.com/code-423n4/2022-02-nested-findings/issues/77) M-02]. Will not contribute to QA score.\n\n 04] \"Consider introducing an upper limit for _timestamp in updateLockTimestamp\"<br\n I think this is a good idea. Valid and low-critical.\n\n 05] \"addFactory should have an analogous check\"<br\n Just a consistency suggestion, valid and non-critical.\n\n 06] \"The revert message is a bit missleading here\"<br\n Warden doesn't explain enough why it is misleading. Invalid.\n\n 07] \"Consider also adding support for rescuing the native asset\"<br\n Valid and low-critical.\n\n Now, here is the methodology I used for calculating a score for each QA report. I first assigned each submission to be either non-critical (1 point), very-low-critical (5 points) or low-critical (10 points), depending on how severe/useful the issue is. The score of a QA report is the sum of these points, divided by the maximum number of points achieved by a QA report. This maximum number was 26 points, achieved by this report #66(https://github.com/code-423n4/2022-02-nested-findings/issues/66).\n \n The number of points achieved by this report is 26 points.<br\n Thus the final score of this QA report is (26/26)*100 = 100.\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 19 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-02-nested-findings/issues/67) by warden pauliax received the top score from the judge.\n\n*The following wardens also submitted reports: robee(https://github.com/code-423n4/2022-02-nested-findings/issues/5), Dravee(https://github.com/code-423n4/2022-02-nested-findings/issues/28), kenzo(https://github.com/code-423n4/2022-02-nested-findings/issues/47), GreyArt(https://github.com/code-423n4/2022-02-nested-findings/issues/39), Tomio(https://github.com/code-423n4/2022-02-nested-findings/issues/55), Omik(https://github.com/code-423n4/2022-02-nested-findings/issues/57), kenta(https://github.com/code-423n4/2022-02-nested-findings/issues/72), rfa(https://github.com/code-423n4/2022-02-nested-findings/issues/64), m_smirnova2020(https://github.com/code-423n4/2022-02-nested-findings/issues/32), csanuragjain(https://github.com/code-423n4/2022-02-nested-findings/issues/8), 0x1f8b(https://github.com/code-423n4/2022-02-nested-findings/issues/16), ye0lde(https://github.com/code-423n4/2022-02-nested-findings/issues/56), sirhashalot(https://github.com/code-423n4/2022-02-nested-findings/issues/68), ShippooorDAO(https://github.com/code-423n4/2022-02-nested-findings/issues/25), gzeon(https://github.com/code-423n4/2022-02-nested-findings/issues/48), defsec(https://github.com/code-423n4/2022-02-nested-findings/issues/71), cmichel(https://github.com/code-423n4/2022-02-nested-findings/issues/15), and bobi(https://github.com/code-423n4/2022-02-nested-findings/issues/43).*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nif (_amountToSpend  amounts[1]) {\n  IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend amounts[1]);\n}\n"
                ],
                "Type": "",
                "Description": "\nCould use 'unchecked' maths here, as underflow is not possible:\n\nsolidity\nif (_amountToSpend  amounts[1]) {\n  IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend amounts[1]);\n}\n\n\nmaximebrugel (Nested Finance) commented(https://github.com/code-423n4/2022-02-nested-findings/issues/67#issuecomment-1042990798):\n  G-01] \"You can remove it to save some gas, or leave it if it was intended for future use with other factories\"<br\n  Acknowledged\n \n G-02] Consider using EnumerableSet to store operators<br\n Acknowledged\n \n G-03] \"Could just use msg.sender and do not call an owner() function here\"<br\n Confirmed\n \n G-04] _checkMsgValue refactoring<br \n Disputed<br\n \"Could be\". You need to pre-calculate the amount of ETH needed to check msg.value in a simple way.\n \n G-05] \"function withdraw calls nestedRecords twice\"<br\n Acknowledged\n \n G-06] \"Could use 'unchecked' maths here, as underflow is not possible\"<br\n Confirmed\n\n PR: Gas Optimizations Fixes(https://github.com/NestedFi/nested-core-lego/pull/101)\n\nharleythedog (judge) commented(https://github.com/code-423n4/2022-02-nested-findings/issues/67#issuecomment-1066015587):\n  My personal judgments:<br\n\n G-01] \"function transfer in NestedReserve is never used\".<br\n Valid and medium-optimization.<br\n\n G-02] \"EnumerableSet to store them\".<br\n Valid and small-optimization.<br\n \n G-03] \"Could just use msg.sender\".<br\n Valid and small-optimization.<br\n\n G-04] \"_checkMsgValue refactoring\".<br\n The idea of refactoring the reserve check to be in the combined function is valid.<br\n Valid and small-optimization.<br\n\n G-05] \"withdraw calls nestedRecords twice\".<br\n Valid and small-optimization.<br\n\n G-06] \"Could use 'unchecked' here\".<br\n This was disputed in other gas reports as this already surfaced in the first contest. To be fair, this should be marked as invalid too.<br\n Invalid.<br\n \n  Also, #66(https://github.com/code-423n4/2022-02-nested-findings/issues/66) has the additional issue:<br\n G-07] \"remove this unused variable to save some gas (ETH)\".<br\n Valid and small-optimization.\n\n  Now, here is the methodology I used for calculating a score for each gas report. I first assigned each submission to be either small-optimization (1 point), medium-optimization (5 points) or large-optimization (10 points), depending on how useful the optimization is. The score of a gas report is the sum of these points, divided by the maximum number of points achieved by a gas report. This maximum number was 10 points, achieved by this report #67(https://github.com/code-423n4/2022-02-nested-findings/issues/67).\n \n The number of points achieved by this report is 10 points.<br\n Thus the final score of this gas report is (10/10)*100 = 100.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    }
]