[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/**\n@title Dola Borrow Rights\n@notice The DolaBorrowRights contract is a non-standard ERC20 token, that gives the right of holders to borrow DOLA at 0% interest.\n As a borrower takes on DOLA debt, their DBR balance will be exhausted at 1 DBR per 1 DOLA borrowed per year.\n*/\ncontract DolaBorrowingRights {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public _totalSupply;\n    address public operator;\n    address public pendingOperator;\n    uint public totalDueTokensAccrued;\n    uint public replenishmentPriceBps;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    mapping (address => bool) public minters;\n    mapping (address => bool) public markets;\n    mapping (address => uint) public debts; // user => debt across all tracked markets\n    mapping (address => uint) public dueTokensAccrued; // user => amount of due tokens accrued\n    mapping (address => uint) public lastUpdated; // user => last update timestamp\n\n    constructor(\n        uint _replenishmentPriceBps,\n        string memory _name,\n        string memory _symbol,\n        address _operator\n    ) {\n        replenishmentPriceBps = _replenishmentPriceBps;\n        name = _name;\n        symbol = _symbol;\n        operator = _operator;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n    @param newOperator_ The address of the newOperator\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator {\n        pendingOperator = newOperator_;\n    }\n\n    /**\n    @notice Sets the replenishment price in basis points. Replenishment price denotes the increase in DOLA debt upon forced replenishments.\n     At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n    @param newReplenishmentPriceBps_ The new replen\n    */\n    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n        require(newReplenishmentPriceBps_ > 0, \"replenishment price must be over 0\");\n        replenishmentPriceBps = newReplenishmentPriceBps_;\n    }\n    \n    /**\n    @notice claims the Operator role if set as pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address of the new minter.\n    */\n    function addMinter(address minter_) public onlyOperator {\n        minters[minter_] = true;\n        emit AddMinter(minter_);\n    }\n\n    /**\n    @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address to be removed from the minter set.\n    */\n    function removeMinter(address minter_) public onlyOperator {\n        minters[minter_] = false;\n        emit RemoveMinter(minter_);\n    }\n    /**\n    @notice Adds a market to the set of active markets. Only callable by Operator.\n    @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n    @param market_ The address of the new market contract to be added.\n    */\n    function addMarket(address market_) public onlyOperator {\n        markets[market_] = true;\n        emit AddMarket(market_);\n    }\n\n    /**\n    @notice Get the total supply of DBR tokens.\n    @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n    @return uint representing the total supply of DBR.\n    */\n    function totalSupply() public view returns (uint) {\n        if(totalDueTokensAccrued > _totalSupply) return 0;\n        return _totalSupply - totalDueTokensAccrued;\n    }\n\n    /**\n    @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n    @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n    @param user Address of the user.\n    @return uint representing the balance of the user.\n    */\n    function balanceOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued > balances[user]) return 0;\n        return balances[user] - dueTokensAccrued[user] - accrued;\n    }\n\n    /**\n    @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n    @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n    @param user Address of the user.\n    @return uint representing the deficit of the user.\n    */\n    function deficitOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n        return dueTokensAccrued[user] + accrued - balances[user];\n    }\n    \n    /**\n    @notice Get the signed DBR balance of an address.\n    @dev This function will revert if a user has a balance of more than 2^255-1 DBR\n    @param user Address of the user.\n    @return Returns a signed int of the user's balance\n    */\n    function signedBalanceOf(address user) public view returns (int) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        return int(balances[user]) - int(dueTokensAccrued[user]) - int(accrued);\n    }\n\n    /**\n    @notice Approves spender to spend amount of DBR on behalf of the message sender.\n    @param spender Address of the spender to be approved\n    @param amount Amount to be approved to spend\n    @return Always returns true, will revert if not successful.\n    */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfers amount to address to from message sender.\n    @param to The address to transfer to\n    @param amount The amount of DBR to transfer\n    @return Always returns true, will revert if not successful.\n    */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfer amount of DBR  on behalf of address from to address to. Message sender must have a sufficient allowance from the from address.\n    @dev Allowance is reduced by the amount transferred.\n    @param from Address to transfer from.\n    @param to Address to transfer to.\n    @param amount Amount of DBR to transfer.\n    @return Always returns true, will revert if not successful.\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Permits an address to spend on behalf of another address via a signed message.\n    @dev Can be bundled with a transferFrom call, to reduce transaction load on users.\n    @param owner Address of the owner permitting the spending\n    @param spender Address allowed to spend on behalf of owner.\n    @param value Amount to be allowed to spend.\n    @param deadline Timestamp after which the signed message is no longer valid.\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n    @notice Function for invalidating the nonce of a signed message.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice Accrue due DBR debt of user\n    @dev DBR debt is accrued at a rate of 1 DBR per 1 DOLA of debt per year.\n    @param user The address of the user to accrue DBR debt to.\n    */\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n\n    /**\n    @notice Function to be called by markets when a borrow occurs.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt.\n    @param user The address of the borrower\n    @param additionalDebt The additional amount of DOLA the user is borrowing\n    */\n    function onBorrow(address user, uint additionalDebt) public {\n        require(markets[msg.sender], \"Only markets can call onBorrow\");\n        accrueDueTokens(user);\n        require(deficitOf(user) == 0, \"DBR Deficit\");\n        debts[user] += additionalDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a repayment occurs.\n    @dev Accrues due tokens on behalf of the user, before reducing their debt.\n    @param user The address of the borrower having their debt repaid\n    @param repaidDebt The amount of DOLA repaid\n    */\n    function onRepay(address user, uint repaidDebt) public {\n        require(markets[msg.sender], \"Only markets can call onRepay\");\n        accrueDueTokens(user);\n        debts[user] -= repaidDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a force replenish occurs. This function can only be called if the user has a DBR deficit.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt by the replenishment price and minting them new DBR.\n    @param user The user to be force replenished.\n    @param amount The amount of DBR the user will be force replenished.\n    */\n    function onForceReplenish(address user, uint amount) public {\n        require(markets[msg.sender], \"Only markets can call onForceReplenish\");\n        uint deficit = deficitOf(user);\n        require(deficit > 0, \"No deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n        accrueDueTokens(user);\n        debts[user] += replenishmentCost;\n        _mint(user, amount);\n    }\n\n    /**\n    @notice Function for burning DBR from message sender, reducing supply.\n    @param amount Amount to be burned\n    */\n    function burn(uint amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n    @notice Function for minting new DBR, increasing supply. Only callable by minters and the operator.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function mint(address to, uint amount) public {\n        require(minters[msg.sender] == true || msg.sender == operator, \"ONLY MINTERS OR OPERATOR\");\n        _mint(to, amount);\n    }\n\n    /**\n    @notice Internal function for minting DBR.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n    @notice Internal function for burning DBR.\n    @param from Address to burn DBR from.\n    @param amount Amount of DBR to be burned.\n    */\n    function _burn(address from, uint256 amount) internal virtual {\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            _totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event AddMinter(address indexed minter);\n    event RemoveMinter(address indexed minter);\n    event AddMarket(address indexed market);\n    event ChangeOperator(address indexed newOperator);\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n",
        "CodeNames": [
            "DBR.sol",
            "demo.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "transfer",
                    "transferFrom",
                    "require()"
                ],
                "Type": " Unhandled return values of  transfer  and  transferFrom ",
                "Description": "*Submitted by 2997ms(https://github.com/code-423n4/2022-10-inverse-findings/issues/10)*\n\nERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return \u2018false\u2019 on failure instead of reverting. It is safer to wrap such calls into require() statements to these failures.\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L205<br\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L280<br\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L399<br\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L537<br\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L570<br\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L602<br\n\n",
                "Repair": "\nCheck the return value and revert on 0/false or use OpenZeppelin\u2019s SafeERC20 wrapper functions.\n\n08xmt (Inverse) acknowledged and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/10#issuecomment-1351551238):\n  Every deployment of a market will use a trusted token, and be audited by the DAO and governance. Even when using safe transfer, there's no guarantee that an ERC20 token will behave as expected.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "Solidity\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n"
                ],
                "Type": " Users can avoid paying fees if they manage to update their accrued fees periodically",
                "Description": "*Submitted by RaoulSchaffranek(https://github.com/code-423n4/2022-10-inverse-findings/issues/83), also found by carlitox477(https://github.com/code-423n4/2022-10-inverse-findings/issues/215)*\n\nDBR.sol#L287(https://github.com/code-423n4/2022-10-inverse/blob/main/src/DBR.sol#L287)<br\n\nWhile a user borrows DOLA, his debt position in the DBR contract accrues more debt over time. However, Solidity contracts cannot update their storage automatically over time; state updates must always be triggered by externally owned accounts. For this reason, the DBR contract cannot accurately represent a user's debt position in its storage at all times. Instead, the contract offers a method accrueDueTokens that, when called, updates the internal storage with the debts that accrued since the last update. This method is called before all critical financial operations that depend on an accurate value of the accumulated deficit in the contract's storage. On top, this method can also be invoked permissionless at any time. Suppose a borrower manages to call this function periodically and keep the time difference between updates short. In that case, a rounding error in the computation of the accrued debt can cause the expression to round down to zero. In this case, the user successfully avoided paying interest on his debt.\n\n\nFor reference, here is the affected code:\n\nSolidity\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n\n\nThe problem is that the function updates the lastUpdated[user] storage variable even when accrued is 0.\n\n\nLet's assume that the last update occurred at t_0.<br\nFurther assume that the next update occurs at t_1 with t_1 t_0 = 12s. (12s is the current Ethereum block time)<br\nSuppose that the user's recorded debt position at  t_0 is 1,000,000 wei.<br\nThen the accrued debt formula gives us the following:<br\n\n    accrued = (t_1 t_0) * debt / 365 days\n            = 12          * 1,000,000 / 31,536,000\n            = 1,000,000 / 31,536,000\n            = 0 (because unsigned integer division rounds down)\n\n\nThe accrued debt formula rounds towards zero if we have (t_1 t_0) * debt < 365 days.<br\nThis gives us a method to compute the maximal debt that we can deposit to make the attack more efficient:\n\n    debt_max = 365 days / 12s -1 = 2,627,999\n\nNotice that an attacker is not limited to these small loans. He can split a massive loan into multiple small loans, capped at 2,627,999.<br\nTo borrow X tokens (where X is given in WEI), we can compute the number of needed loans as:\n\n    #loans = X / 2,627,999\n\nFor example, to borrow 1 DOLA:\n\n    #loans = 10^18 / 2,627,999 = 380517648599\n\nTo borrow 1,000,000 DOLA we would thus need 380,517,648,599,000,000 small loans.\n\n\nThe attack would be economically feasible if the costs of the attack were lower than the interest that accrued throughout the successful attack.<br\nThe dominating factor of the attack costs is the gas costs which the attacker needs to pay to update the accrued interest of the small loans every second. A clever attacker would batch as many updates into a single transaction as possible to minimize the gas overhead of the transaction. Still, at the current block time (12s), gas price (7 gwei), block gas limit (30,000,000), and current ETH price ($1,550.80), it's hardly imaginable that this attack is economically feasible at the moment.\n\n\nHowever, all these values could change in the future. And if we look at other networks, Layer2 or EVM compatible Layer1, the parameters might be different today.\n\nAlso, notice that if the contract were used to borrow a different asset than DOLA, the numbers would look drastically different. The risk increases with the asset's price and becomes bigger the fewer decimals the token uses. For example, to borrow 1 WBTC (8 decimals), we would only need 39 small loans:\n\n    #loans = 10^8 / 2,627,999 ~39\n\nAnd to borrow WBTC worth $1,000,000 at a price of 20,746$/BTC, we would need 1864 small loans.\n\n    #loans ~= 49*10^8 / 2,627,999 ~= 1864\n\n\nThe following test demonstrates how to avoid paying interest on a loan for 1h. A failing test means that the attack was successful.\n\n    $ git diff src/test/DBR.t.sol\n    diff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol\n    index 3988cf7..8779da7 100644\n    --a/src/test/DBR.t.sol\n    +++ b/src/test/DBR.t.sol\n    @@ -25,6 +25,20 @@ contract DBRTest is FiRMTest {\n             vm.stopPrank();\n         }\n     \n    +    function testFail_free_borrow() public {\n    +        uint borrowAmount =  2_627_999;\n    +\n    +        vm.prank(address(market));\n    +        dbr.onBorrow(user, borrowAmount);\n    +\n    +        for (uint i = 12; i <= 3600; i += 12) {\n    +            vm.warp(block.timestamp + 12);\n    +            dbr.accrueDueTokens(user);\n    +        }\n    +        assertEq(dbr.deficitOf(user), 0);\n    +    }\n    +\n    +\n         function testOnBorrow_Reverts_When_AccrueDueTokensBringsUserDbrBelow0() public {\n             gibWeth(user, wethTestAmount);\n             gibDBR(user, wethTestAmount);\n\nOutput:\n\n    $ forge test --match-test testFail_free_borrow -vv\n    \u2806] Compiling...\n    \u280a] Compiling 1 files with 0.8.17\n    \u2822] Solc 0.8.17 finished in 2.62s\n    Compiler run successful\n\n    Running 1 test for src/test/DBR.t.sol:DBRTest\n    FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)\n    Test result: FAILED. 0 passed; 1 failed; finished in 8.03ms\n\n    Failing tests:\n    Encountered 1 failing test in src/test/DBR.t.sol:DBRTest\n    FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)\n\n    Encountered a total of 1 failing tests, 0 tests succeeded\n\nClassified as a high medium because the yields can get stolen/denied. It's not high risk because I don't see an economically feasible exploit.\n\n\nVSCode, Wolramapha, Foundry\n\n",
                "Repair": "\n*   Document the risks transparently and prominently.\n*   Re-evaluate the risks according to the specific network parameters of every network you want to deploy to.\n*   Do not update the lastUpdated timestamp of the user if the computed accrued amount was zero.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/83#issuecomment-1304324558):\n  Debatable if this even qualifies as Medium. Leaning towards QA / LOW but will leave open for sponsor review.\n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/83#issuecomment-1315741882):\n  Fixed in https://github.com/InverseFinance/FrontierV2/pull/20.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "repay()",
                    "repay",
                    "require"
                ],
                "Type": "  repay  function can be DOSed",
                "Description": "*Submitted by djxploit(https://github.com/code-423n4/2022-10-inverse-findings/issues/252), also found by immeas(https://github.com/code-423n4/2022-10-inverse-findings/issues/439)*\n\nMarket.sol#L531(https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531)<br\n\nIn repay() users can repay their debt.\n\n    function repay(address user, uint amount) public {\n            uint debt = debts[user];\n            require(debt = amount, \"Insufficient debt\");\n            debts[user] -= amount;\n            totalDebt -= amount;\n            dbr.onRepay(user, amount);\n            dola.transferFrom(msg.sender, address(this), amount);\n            emit Repay(user, msg.sender, amount);\n        }\n\nThere is a require condition, that checks if the amount provided, is greater than the debt of the user. If it is, then the function reverts. This is where the vulnerability arises.\n\nrepay function can be frontrun by an attacker. Say an attacker pay a small amount of debt for the victim user, by frontrunning his repay transaction. Now when the victim's transaction gets executed, the require condition will fail, as the amount of debt is less than the amount of DOLA provided. Hence the attacker can repeat the process to DOS the victim from calling the repay function.\n\n\n1.  Victim calls repay() function to pay his debt of 500 DOLA , by providing the amount as 500\n2.  Now attacker saw this transaction on mempool\n3.  Attacker frontruns the transaction, by calling repay() with amount provided as 1 DOLA\n4.  Attacker's transaction get's executed first due to frontrunning, which reduces the debt of the victim user to 499 DOLA\n5.  Now when the victim's transaction get's executed, the debt of victim has reduced to 499 DOLA, and the amount to repay provided was 500 DOLA. Now as debt is less than the amount provided, so the require function will fail, and the victim's transaction will revert.\n\nThis will prevent the victim from calling repay function.\n\nHence an attacker can DOS the repay function for the victim user.\n\n",
                "Repair": "\nImplement DOS protection.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/252#issuecomment-1304641340):\n  This seems like a stretch to me. Will leave open for sponsor review but most likely close as invalid. \n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/252#issuecomment-1308151711):\n  Mitigating PR: https://github.com/InverseFinance/FrontierV2/pull/13.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/**\n@title Dola Borrow Rights\n@notice The DolaBorrowRights contract is a non-standard ERC20 token, that gives the right of holders to borrow DOLA at 0% interest.\n As a borrower takes on DOLA debt, their DBR balance will be exhausted at 1 DBR per 1 DOLA borrowed per year.\n*/\ncontract DolaBorrowingRights {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public _totalSupply;\n    address public operator;\n    address public pendingOperator;\n    uint public totalDueTokensAccrued;\n    uint public replenishmentPriceBps;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    mapping (address => bool) public minters;\n    mapping (address => bool) public markets;\n    mapping (address => uint) public debts; // user => debt across all tracked markets\n    mapping (address => uint) public dueTokensAccrued; // user => amount of due tokens accrued\n    mapping (address => uint) public lastUpdated; // user => last update timestamp\n\n    constructor(\n        uint _replenishmentPriceBps,\n        string memory _name,\n        string memory _symbol,\n        address _operator\n    ) {\n        replenishmentPriceBps = _replenishmentPriceBps;\n        name = _name;\n        symbol = _symbol;\n        operator = _operator;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n    @param newOperator_ The address of the newOperator\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator {\n        pendingOperator = newOperator_;\n    }\n\n    /**\n    @notice Sets the replenishment price in basis points. Replenishment price denotes the increase in DOLA debt upon forced replenishments.\n     At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n    @param newReplenishmentPriceBps_ The new replen\n    */\n    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n        require(newReplenishmentPriceBps_ > 0, \"replenishment price must be over 0\");\n        replenishmentPriceBps = newReplenishmentPriceBps_;\n    }\n    \n    /**\n    @notice claims the Operator role if set as pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address of the new minter.\n    */\n    function addMinter(address minter_) public onlyOperator {\n        minters[minter_] = true;\n        emit AddMinter(minter_);\n    }\n\n    /**\n    @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address to be removed from the minter set.\n    */\n    function removeMinter(address minter_) public onlyOperator {\n        minters[minter_] = false;\n        emit RemoveMinter(minter_);\n    }\n    /**\n    @notice Adds a market to the set of active markets. Only callable by Operator.\n    @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n    @param market_ The address of the new market contract to be added.\n    */\n    function addMarket(address market_) public onlyOperator {\n        markets[market_] = true;\n        emit AddMarket(market_);\n    }\n\n    /**\n    @notice Get the total supply of DBR tokens.\n    @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n    @return uint representing the total supply of DBR.\n    */\n    function totalSupply() public view returns (uint) {\n        if(totalDueTokensAccrued > _totalSupply) return 0;\n        return _totalSupply - totalDueTokensAccrued;\n    }\n\n    /**\n    @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n    @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n    @param user Address of the user.\n    @return uint representing the balance of the user.\n    */\n    function balanceOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued > balances[user]) return 0;\n        return balances[user] - dueTokensAccrued[user] - accrued;\n    }\n\n    /**\n    @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n    @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n    @param user Address of the user.\n    @return uint representing the deficit of the user.\n    */\n    function deficitOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n        return dueTokensAccrued[user] + accrued - balances[user];\n    }\n    \n    /**\n    @notice Get the signed DBR balance of an address.\n    @dev This function will revert if a user has a balance of more than 2^255-1 DBR\n    @param user Address of the user.\n    @return Returns a signed int of the user's balance\n    */\n    function signedBalanceOf(address user) public view returns (int) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        return int(balances[user]) - int(dueTokensAccrued[user]) - int(accrued);\n    }\n\n    /**\n    @notice Approves spender to spend amount of DBR on behalf of the message sender.\n    @param spender Address of the spender to be approved\n    @param amount Amount to be approved to spend\n    @return Always returns true, will revert if not successful.\n    */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfers amount to address to from message sender.\n    @param to The address to transfer to\n    @param amount The amount of DBR to transfer\n    @return Always returns true, will revert if not successful.\n    */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfer amount of DBR  on behalf of address from to address to. Message sender must have a sufficient allowance from the from address.\n    @dev Allowance is reduced by the amount transferred.\n    @param from Address to transfer from.\n    @param to Address to transfer to.\n    @param amount Amount of DBR to transfer.\n    @return Always returns true, will revert if not successful.\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Permits an address to spend on behalf of another address via a signed message.\n    @dev Can be bundled with a transferFrom call, to reduce transaction load on users.\n    @param owner Address of the owner permitting the spending\n    @param spender Address allowed to spend on behalf of owner.\n    @param value Amount to be allowed to spend.\n    @param deadline Timestamp after which the signed message is no longer valid.\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n    @notice Function for invalidating the nonce of a signed message.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice Accrue due DBR debt of user\n    @dev DBR debt is accrued at a rate of 1 DBR per 1 DOLA of debt per year.\n    @param user The address of the user to accrue DBR debt to.\n    */\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n\n    /**\n    @notice Function to be called by markets when a borrow occurs.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt.\n    @param user The address of the borrower\n    @param additionalDebt The additional amount of DOLA the user is borrowing\n    */\n    function onBorrow(address user, uint additionalDebt) public {\n        require(markets[msg.sender], \"Only markets can call onBorrow\");\n        accrueDueTokens(user);\n        require(deficitOf(user) == 0, \"DBR Deficit\");\n        debts[user] += additionalDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a repayment occurs.\n    @dev Accrues due tokens on behalf of the user, before reducing their debt.\n    @param user The address of the borrower having their debt repaid\n    @param repaidDebt The amount of DOLA repaid\n    */\n    function onRepay(address user, uint repaidDebt) public {\n        require(markets[msg.sender], \"Only markets can call onRepay\");\n        accrueDueTokens(user);\n        debts[user] -= repaidDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a force replenish occurs. This function can only be called if the user has a DBR deficit.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt by the replenishment price and minting them new DBR.\n    @param user The user to be force replenished.\n    @param amount The amount of DBR the user will be force replenished.\n    */\n    function onForceReplenish(address user, uint amount) public {\n        require(markets[msg.sender], \"Only markets can call onForceReplenish\");\n        uint deficit = deficitOf(user);\n        require(deficit > 0, \"No deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n        accrueDueTokens(user);\n        debts[user] += replenishmentCost;\n        _mint(user, amount);\n    }\n\n    /**\n    @notice Function for burning DBR from message sender, reducing supply.\n    @param amount Amount to be burned\n    */\n    function burn(uint amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n    @notice Function for minting new DBR, increasing supply. Only callable by minters and the operator.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function mint(address to, uint amount) public {\n        require(minters[msg.sender] == true || msg.sender == operator, \"ONLY MINTERS OR OPERATOR\");\n        _mint(to, amount);\n    }\n\n    /**\n    @notice Internal function for minting DBR.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n    @notice Internal function for burning DBR.\n    @param from Address to burn DBR from.\n    @param amount Amount of DBR to be burned.\n    */\n    function _burn(address from, uint256 amount) internal virtual {\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            _totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event AddMinter(address indexed minter);\n    event RemoveMinter(address indexed minter);\n    event AddMarket(address indexed market);\n    event ChangeOperator(address indexed newOperator);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IMarket {\n    function recall(uint amount) external;\n    function totalDebt() external view returns (uint);\n    function borrowPaused() external view returns (bool);\n}\n\ninterface IDola {\n    function mint(address to, uint amount) external;\n    function burn(uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function transfer(address to, uint amount) external returns (bool);\n}\n\ninterface IDBR {\n    function markets(address) external view returns (bool);\n}\n\n/**\n@title The Market Fed\n@notice Feds are a class of contracts in the Inverse Finance ecosystem responsible for minting and burning DOLA.\n This specific Fed can expand DOLA supply into markets and contract DOLA supply from markets.\n*/\ncontract Fed {\n\n    IDBR public immutable dbr;\n    IDola public immutable dola;\n    address public gov;\n    address public chair;\n    uint public supplyCeiling;\n    uint public globalSupply;\n    mapping (IMarket => uint) public supplies;\n\n    constructor (IDBR _dbr, IDola _dola, address _gov, address _chair, uint _supplyCeiling) {\n        dbr = _dbr;\n        dola = _dola;\n        gov = _gov;\n        chair = _chair;\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Change the governance of the Fed contact. Only callable by governance.\n    @param _gov The address of the new governance contract\n    */\n    function changeGov(address _gov) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        gov = _gov;\n    }\n\n    /**\n    @notice Set the supply ceiling of the Fed. Only callable by governance.\n    @param _supplyCeiling Amount to set the supply ceiling to\n    */\n    function changeSupplyCeiling(uint _supplyCeiling) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Set the chair of the fed. Only callable by governance.\n    @param _chair Address of the new chair.\n    */\n    function changeChair(address _chair) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        chair = _chair;\n    }\n\n    /**\n    @notice Set the address of the chair to the 0 address. Only callable by the chair.\n    @dev Useful for immediately removing chair powers in case of a wallet compromise.\n    */\n    function resign() public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        chair = address(0);\n    }\n\n    /**\n    @notice Expand the amount of DOLA by depositing the amount into a specific market.\n    @dev While not immediately dangerous to the DOLA peg, make sure the market can absorb the new potential supply.\n    @param market The market to add additional DOLA supply to.\n    @param amount The amount of DOLA to mint and supply to the market.\n    */\n    function expansion(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        require(market.borrowPaused() != true, \"CANNOT EXPAND PAUSED MARKETS\");\n        dola.mint(address(market), amount);\n        supplies[market] += amount;\n        globalSupply += amount;\n        require(globalSupply <= supplyCeiling);\n        emit Expansion(market, amount);\n    }\n\n    /**\n    @notice Contract the amount of DOLA by withdrawing some amount of DOLA from a market, before burning it.\n    @dev Markets can have more DOLA in them than they've been supplied, due to force replenishes. This call will revert if trying to contract more than have been supplied.\n    @param market The market to withdraw DOLA from\n    @param amount The amount of DOLA to withdraw and burn.\n    */\n    function contraction(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        uint supply = supplies[market];\n        require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n        market.recall(amount);\n        dola.burn(amount);\n        supplies[market] -= amount;\n        globalSupply -= amount;\n        emit Contraction(market, amount);\n    }\n\n    /**\n    @notice Gets the profit of a market.\n    @param market The market to withdraw profit from.\n    @return A uint representing the profit of the market.\n    */\n    function getProfit(IMarket market) public view returns (uint) {\n        uint marketValue = dola.balanceOf(address(market)) + market.totalDebt();\n        uint supply = supplies[market];\n        if(supply >= marketValue) return 0;\n        return marketValue - supply;\n    }\n\n    /**\n    @notice Takes profit from a market\n    @param market The market to take profit from.\n    */\n    function takeProfit(IMarket market) public {\n        uint profit = getProfit(market);\n        if(profit > 0) {\n            market.recall(profit);\n            dola.transfer(gov, profit);\n        }\n    }\n\n\n    event Expansion(IMarket indexed market, uint amount);\n    event Contraction(IMarket indexed market, uint amount);\n\n}\n\n\n",
        "CodeNames": [
            "DBR.sol",
            "Market.sol",
            "Fed.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "repay()",
                    "forceReplenish()",
                    "forceReplenish(",
                    "gov"
                ],
                "Type": " User can borrow DOLA indefinitely without settling DBR deficit by keeping their debt close to the allowed maximum",
                "Description": "*Submitted by Holmgren(https://github.com/code-423n4/2022-10-inverse-findings/issues/155)*\n\nA user can borrow DOLA interest-free. This requires the user to precisely manage their collateral. This issue might become especially troublesome if a Market is opened with some stablecoin as the collateral (because price fluctuations would become negligible and carefully managing collateral level would be easy).\n\nThis issue is harder to exploit (but not impossible) if gov takes responsibility for forcing replenishment, since gov has a stronger economic incentive than third parties.\n\n\nIf my calculations are correct, with the current gas prices it costs about $5 to call Market.forceReplenish(...). Thus  there is no economic incentive to do so as long as a debtor's DBR deficit is worth less than $5/replenishmentIncentive so probably around $100.\n\nThis is because replenishing cannot push a user's debt under the water (<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567) and a user can repay their debt without having settled the DBR deficit (<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531).\n\nSo, assuming the current prices, a user can:\n\n1.  Deposit some collateral\n2.  Borrow close to the maximum allowed amount of DOLA\n3.  Keep withdrawing or depositing collateral so that the collateral surplus does not exceed $100 (assuming current gas prices)\n4.  repay() their debt at any time in the future.\n5.  Withdraw all the collateral.\n\nAll this is possible with arbitrarily large DBR deficit because due to small collateral surplus at no point was it economical for a third party to forceReplenish() the user. If gov takes responsibility for forceReplenish()ing, the above procedure is still viable although the user has to maintain the collateral surplus at no more than around $5.\n\n",
                "Repair": "\nAllow replenishing to push the debt under the water and disallow repaying the debt with an outstanding DBR deficit. E.g.:\n\n    diff --git a/src/Market.sol b/src/Market.sol\n    index 9585b85..d69b599 100644\n    --a/src/Market.sol\n    +++ b/src/Market.sol\n    @@ -531,6 +531,7 @@ contract Market {\n         function repay(address user, uint amount) public {\n             uint debt = debts[user];\n             require(debt = amount, \"Insufficient debt\");\n    +        require(dbr.deficitOf(user) == 0, \"DBR Deficit\");\n             debts[user] -= amount;\n             totalDebt -= amount;\n             dbr.onRepay(user, amount);\n    @@ -563,8 +564,6 @@ contract Market {\n             uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n             uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n             debts[user] += replenishmentCost;\n           uint collateralValue = getCollateralValueInternal(user);\n           require(collateralValue = debts[user], \"Exceeded collateral value\");\n             totalDebt += replenishmentCost;\n             dbr.onForceReplenish(user, amount);\n             dola.transfer(msg.sender, replenisherReward);\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/155#issuecomment-1304634317):\n  This seems like a dust attack. Will leave open for sponsor review. \n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/155#issuecomment-1327347446):\n  Fixed in https://github.com/InverseFinance/FrontierV2/pull/24.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-16",
                "Location": [
                    "//solidity\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit  0, \"No DBR deficit\");\n        require(deficit = amount, \"Amount  deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue = debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n",
                    "//solidity\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt = amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n",
                    "//solidity\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n",
                    "//solidity\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit = amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n",
                    "//solidity\n    function testRepayAndWithdrawInFullWhenIncurringDBRDeficitIfNotBeingForcedToReplenish() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        // user deposits wethTestAmount WETH and borrows wethTestAmount DOLA\n        deposit(wethTestAmount);\n        market.borrow(wethTestAmount);\n\n        assertEq(DOLA.balanceOf(user), wethTestAmount);\n        assertEq(WETH.balanceOf(user), 0);\n\n        vm.warp(block.timestamp + 60 weeks);\n\n        // after some time, user incurs DBR deficit\n        assertGt(dbr.deficitOf(user), 0);\n\n        // yet, since no one notices that user has a DBR deficit and forces user to replenish DBR,\n        //   user is able to repay wethTestAmount DOLA that was borrowed previously and withdraw wethTestAmount WETH that was deposited previously\n        market.repay(user, wethTestAmount);\n        market.withdraw(wethTestAmount);\n\n        vm.stopPrank();\n\n        // as a result, user is able to get back all of the deposited WETH, which should not be possible if user has been forced to replenish DBR\n        assertEq(DOLA.balanceOf(user), 0);\n        assertEq(WETH.balanceOf(user), wethTestAmount);\n    }\n"
                ],
                "Type": " Calling  repay  function sends less DOLA to  Market  contract when  forceReplenish  function is not called while it could be called",
                "Description": "*Submitted by rbserver(https://github.com/code-423n4/2022-10-inverse-findings/issues/583), also found by Picodes(https://github.com/code-423n4/2022-10-inverse-findings/issues/519), Ch_301(https://github.com/code-423n4/2022-10-inverse-findings/issues/417), Jeiwan(https://github.com/code-423n4/2022-10-inverse-findings/issues/401), ElKu(https://github.com/code-423n4/2022-10-inverse-findings/issues/385), 0xRobocop(https://github.com/code-423n4/2022-10-inverse-findings/issues/311), MiloTruck(https://github.com/code-423n4/2022-10-inverse-findings/issues/182), and sam_cunningham(https://github.com/code-423n4/2022-10-inverse-findings/issues/158)*\n\nWhen a user incurs a DBR deficit, a replenisher can call the forceReplenish function to force the user to replenish DBR. However, there is no guarantee that the forceReplenish function will always be called. When the forceReplenish function is not called, such as because that the replenisher does not notice the user's DBR deficit promptly, the user can just call the repay function to repay the origianl debt and the withdraw function to receive all of the deposited collateral even when the user has a DBR deficit already. Yet, in the same situation, if the forceReplenish function has been called, more debt should be added for the user, and the user needs to repay more in order to get back all of the deposited collateral. Hence, when the forceReplenish function is not called while it could be called, the Market contract would receive less DOLA if the user decides to repay the debt and withdraw the collateral both in full.\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L559-L572\n\nsolidity\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit  0, \"No DBR deficit\");\n        require(deficit = amount, \"Amount  deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue = debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531-L539\n\nsolidity\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt = amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L472-L474\n\nsolidity\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L460-L466\n\nsolidity\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit = amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n\n\nPlease add the following test in srctestMarket.t.sol. This test will pass to demonstrate the described scenario.\n\nsolidity\n    function testRepayAndWithdrawInFullWhenIncurringDBRDeficitIfNotBeingForcedToReplenish() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        // user deposits wethTestAmount WETH and borrows wethTestAmount DOLA\n        deposit(wethTestAmount);\n        market.borrow(wethTestAmount);\n\n        assertEq(DOLA.balanceOf(user), wethTestAmount);\n        assertEq(WETH.balanceOf(user), 0);\n\n        vm.warp(block.timestamp + 60 weeks);\n\n        // after some time, user incurs DBR deficit\n        assertGt(dbr.deficitOf(user), 0);\n\n        // yet, since no one notices that user has a DBR deficit and forces user to replenish DBR,\n        //   user is able to repay wethTestAmount DOLA that was borrowed previously and withdraw wethTestAmount WETH that was deposited previously\n        market.repay(user, wethTestAmount);\n        market.withdraw(wethTestAmount);\n\n        vm.stopPrank();\n\n        // as a result, user is able to get back all of the deposited WETH, which should not be possible if user has been forced to replenish DBR\n        assertEq(DOLA.balanceOf(user), 0);\n        assertEq(WETH.balanceOf(user), wethTestAmount);\n    }\n\n\n\nVSCode\n\n",
                "Repair": "\nWhen calling the repay function, the user's DBR deficit can also be checked. If the user has a DBR deficit, an amount, which is similar to replenishmentCost that is calculated in the forceReplenish function, can be calculated; it can then be used to adjust the repay function's amount input for updating the states regarding the user's and total debts in the relevant contracts.\n\n08xmt (Inverse) disputed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/583#issuecomment-1351478264):\n  Working as intended.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/// @dev Caution: We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\n/**\n@title Simple ERC20 Escrow\n@notice Collateral is stored in unique escrow contracts for every user and every market.\n@dev Caution: This is a proxy implementation. Follow proxy pattern best practices\n*/\ncontract SimpleERC20Escrow {\n    address public market;\n    IERC20 public token;\n    \n    /**\n    @notice Initialize escrow with a token\n    @dev Must be called right after proxy is created\n    @param _token The IERC20 token to be stored in this specific escrow\n    */\n    function initialize(IERC20 _token, address) public {\n        require(market == address(0), \"ALREADY INITIALIZED\");\n        market = msg.sender;\n        token = _token;\n    }\n    \n    /**\n    @notice Transfers the associated ERC20 token to a recipient.\n    @param recipient The address to receive payment from the escrow\n    @param amount The amount of ERC20 token to be transferred.\n    */\n    function pay(address recipient, uint amount) public {\n        require(msg.sender == market, \"ONLY MARKET\");\n        token.transfer(recipient, amount);\n    }\n\n    /**\n    @notice Get the token balance of the escrow\n    @return Uint representing the token balance of the escrow\n    */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    /* Uncomment if Escrow contract should handle on deposit callbacks. This function should remain callable by anyone to handle direct inbound transfers.\n    function onDeposit() public {\n\n    }\n    */\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IMarket {\n    function recall(uint amount) external;\n    function totalDebt() external view returns (uint);\n    function borrowPaused() external view returns (bool);\n}\n\ninterface IDola {\n    function mint(address to, uint amount) external;\n    function burn(uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function transfer(address to, uint amount) external returns (bool);\n}\n\ninterface IDBR {\n    function markets(address) external view returns (bool);\n}\n\n/**\n@title The Market Fed\n@notice Feds are a class of contracts in the Inverse Finance ecosystem responsible for minting and burning DOLA.\n This specific Fed can expand DOLA supply into markets and contract DOLA supply from markets.\n*/\ncontract Fed {\n\n    IDBR public immutable dbr;\n    IDola public immutable dola;\n    address public gov;\n    address public chair;\n    uint public supplyCeiling;\n    uint public globalSupply;\n    mapping (IMarket => uint) public supplies;\n\n    constructor (IDBR _dbr, IDola _dola, address _gov, address _chair, uint _supplyCeiling) {\n        dbr = _dbr;\n        dola = _dola;\n        gov = _gov;\n        chair = _chair;\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Change the governance of the Fed contact. Only callable by governance.\n    @param _gov The address of the new governance contract\n    */\n    function changeGov(address _gov) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        gov = _gov;\n    }\n\n    /**\n    @notice Set the supply ceiling of the Fed. Only callable by governance.\n    @param _supplyCeiling Amount to set the supply ceiling to\n    */\n    function changeSupplyCeiling(uint _supplyCeiling) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Set the chair of the fed. Only callable by governance.\n    @param _chair Address of the new chair.\n    */\n    function changeChair(address _chair) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        chair = _chair;\n    }\n\n    /**\n    @notice Set the address of the chair to the 0 address. Only callable by the chair.\n    @dev Useful for immediately removing chair powers in case of a wallet compromise.\n    */\n    function resign() public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        chair = address(0);\n    }\n\n    /**\n    @notice Expand the amount of DOLA by depositing the amount into a specific market.\n    @dev While not immediately dangerous to the DOLA peg, make sure the market can absorb the new potential supply.\n    @param market The market to add additional DOLA supply to.\n    @param amount The amount of DOLA to mint and supply to the market.\n    */\n    function expansion(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        require(market.borrowPaused() != true, \"CANNOT EXPAND PAUSED MARKETS\");\n        dola.mint(address(market), amount);\n        supplies[market] += amount;\n        globalSupply += amount;\n        require(globalSupply <= supplyCeiling);\n        emit Expansion(market, amount);\n    }\n\n    /**\n    @notice Contract the amount of DOLA by withdrawing some amount of DOLA from a market, before burning it.\n    @dev Markets can have more DOLA in them than they've been supplied, due to force replenishes. This call will revert if trying to contract more than have been supplied.\n    @param market The market to withdraw DOLA from\n    @param amount The amount of DOLA to withdraw and burn.\n    */\n    function contraction(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        uint supply = supplies[market];\n        require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n        market.recall(amount);\n        dola.burn(amount);\n        supplies[market] -= amount;\n        globalSupply -= amount;\n        emit Contraction(market, amount);\n    }\n\n    /**\n    @notice Gets the profit of a market.\n    @param market The market to withdraw profit from.\n    @return A uint representing the profit of the market.\n    */\n    function getProfit(IMarket market) public view returns (uint) {\n        uint marketValue = dola.balanceOf(address(market)) + market.totalDebt();\n        uint supply = supplies[market];\n        if(supply >= marketValue) return 0;\n        return marketValue - supply;\n    }\n\n    /**\n    @notice Takes profit from a market\n    @param market The market to take profit from.\n    */\n    function takeProfit(IMarket market) public {\n        uint profit = getProfit(market);\n        if(profit > 0) {\n            market.recall(profit);\n            dola.transfer(gov, profit);\n        }\n    }\n\n\n    event Expansion(IMarket indexed market, uint amount);\n    event Contraction(IMarket indexed market, uint amount);\n\n}\n\n\n",
        "CodeNames": [
            "SimpleERC20Escrow.sol",
            "Market.sol",
            "Fed.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "withdrawInternal",
                    "withdraw(amount)",
                    "collateral",
                    "escrow.pay(to, amount)",
                    "collateralFactorBps",
                    "getWithdrawalLimitInternal",
                    "SimpleERC"
                ],
                "Type": " ERC777 reentrancy when withdrawing can be used to withdraw all collateral",
                "Description": "*Submitted by Lambda(https://github.com/code-423n4/2022-10-inverse-findings/issues/206)*\n\nMarket.sol#L464(https://github.com/code-423n4/2022-10-inverse/blob/cc281e5800d5860c816138980f08b84225e430fe/src/Market.sol#L464)<br\n\nMarkets can be deployed with arbitrary tokens for the collateral, including ERC777 tokens (that are downwards-compatible with ERC20). However, when the system is used with those tokens, an attacker can drain his escrow contract completely while still having a loan. This happens because with ERC777 tokens, there is a tokensToSend hook that is executed before the actual transfer (and the balance updates) happen. Therefore, escrow.balance() (which retrieves the token balance) will still report the old balance when an attacker reenters from this hook.\n\n\nWe assume that collateral is an ERC777 token and that the collateralFactorBps is 5,000 (50%). The user has deposited 10,000 USD (worth of collateral) and taken out a loan worth 2,500 USD. He is therefore allowed to withdraw 5,000 USD (worth of collateral). However, he can usse the ERC777 reentrancy to take out all 10,000 USD (worth of collateral) and still keep the loaned 2,500 USD:\n1. The user calls withdraw(amount) to withdraw his 5,000 USD (worth of collateral).\n2. In withdrawInternal, the limit check succeeds (the user is allowed to withdraw 5,000 USD) and escrow.pay(to, amount) is called. This will initiate a transfer to the provided address (no matter which escrow is used, but we assume SimpleERC20Escrow for this example).\n3. Because the collateral is an ERC777 token, the tokensToSend hook is executed before the actual transfer (and before any balance updates are made). The user can exploit this by calling withdraw(amount) again within the hook.\n4. withdrawInternal will call getWithdrawalLimitInternal, which calls escrow.balance(). This receives the collateral balance of the escrow, which is not yet updated. Because of that, the balance is still 10,000 USD (worth of collateral) and the calculated withdraw limit is therefore still 5,000 USD.\n5. Both transfers (the reentered one and the original one) succeed and the user has received all of his collateral (10,000 USD), while still having the 2,500 USD loan.\n\n",
                "Repair": "\nMark these functions as nonReentrant.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1304567191):\n  Sponsor should review as the attack does seem valid with some pre-conditions (ERC777 tokens being used for collateral). Probably more of a Medium severity.\n\n08xmt (Inverse) acknowledged, but disagreed with severity and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1313354099):\n  We make the security assumption that future collateral added by Inverse Finance DAO is compliant with standard ERC-20 behavior. Inverse Finance is full control of collateral that will be added to the platform and only intend to add collateral that properly reverts on failed transfers. Each ERC20 token added as collateral will be audited for non-standard behaviour. I would consider this a Low Risk finding, depending on how you value errors made in launch parameters.\n\n0xean (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1329464062):\n  @08xmt The revert on a failed transfer here isn't the issue, it is the re-entrancy that isn't guarded against properly. While I understand your comment, if it were my codebase, I would simply add the modifier and incur the small gas costs as an additional layer of security to avoid mistakes in the future. I don't think this qualifies as High, but does show an attack path that *could* be achieved with an ERC777 token being used as collateral. Going to downgrade to Medium and will be happy to hear more discussion on the topic before final review. \n\n08xmt (Inverse) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1332543501):\n  @0xean The risk is still only present with unvetted contracts, and if the desire should exist in the future to implement a market with a token with re-entrancy, the code can be modified as necessary.\n \n Will respect the judge's decision on severity in the end, but ultimately seem like a deployment parameter risk more than anything.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1333969128):\n  Thanks @08xmt for the response.\n \n While I agree that proper vetting *could* avoid this issue, the wardens are analyzing the code and documentation that is presented before them and I think in light of this, the issue is valid. Had the warden simply stated that there was a reentrancy modifier missing without showing a valid path to it being exploited, I would downgrade to QA. But given they showed a valid attack path due to the lack of reentrancy controls I think this should be awarded.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IMarket {\n    function recall(uint amount) external;\n    function totalDebt() external view returns (uint);\n    function borrowPaused() external view returns (bool);\n}\n\ninterface IDola {\n    function mint(address to, uint amount) external;\n    function burn(uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function transfer(address to, uint amount) external returns (bool);\n}\n\ninterface IDBR {\n    function markets(address) external view returns (bool);\n}\n\n/**\n@title The Market Fed\n@notice Feds are a class of contracts in the Inverse Finance ecosystem responsible for minting and burning DOLA.\n This specific Fed can expand DOLA supply into markets and contract DOLA supply from markets.\n*/\ncontract Fed {\n\n    IDBR public immutable dbr;\n    IDola public immutable dola;\n    address public gov;\n    address public chair;\n    uint public supplyCeiling;\n    uint public globalSupply;\n    mapping (IMarket => uint) public supplies;\n\n    constructor (IDBR _dbr, IDola _dola, address _gov, address _chair, uint _supplyCeiling) {\n        dbr = _dbr;\n        dola = _dola;\n        gov = _gov;\n        chair = _chair;\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Change the governance of the Fed contact. Only callable by governance.\n    @param _gov The address of the new governance contract\n    */\n    function changeGov(address _gov) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        gov = _gov;\n    }\n\n    /**\n    @notice Set the supply ceiling of the Fed. Only callable by governance.\n    @param _supplyCeiling Amount to set the supply ceiling to\n    */\n    function changeSupplyCeiling(uint _supplyCeiling) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Set the chair of the fed. Only callable by governance.\n    @param _chair Address of the new chair.\n    */\n    function changeChair(address _chair) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        chair = _chair;\n    }\n\n    /**\n    @notice Set the address of the chair to the 0 address. Only callable by the chair.\n    @dev Useful for immediately removing chair powers in case of a wallet compromise.\n    */\n    function resign() public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        chair = address(0);\n    }\n\n    /**\n    @notice Expand the amount of DOLA by depositing the amount into a specific market.\n    @dev While not immediately dangerous to the DOLA peg, make sure the market can absorb the new potential supply.\n    @param market The market to add additional DOLA supply to.\n    @param amount The amount of DOLA to mint and supply to the market.\n    */\n    function expansion(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        require(market.borrowPaused() != true, \"CANNOT EXPAND PAUSED MARKETS\");\n        dola.mint(address(market), amount);\n        supplies[market] += amount;\n        globalSupply += amount;\n        require(globalSupply <= supplyCeiling);\n        emit Expansion(market, amount);\n    }\n\n    /**\n    @notice Contract the amount of DOLA by withdrawing some amount of DOLA from a market, before burning it.\n    @dev Markets can have more DOLA in them than they've been supplied, due to force replenishes. This call will revert if trying to contract more than have been supplied.\n    @param market The market to withdraw DOLA from\n    @param amount The amount of DOLA to withdraw and burn.\n    */\n    function contraction(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        uint supply = supplies[market];\n        require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n        market.recall(amount);\n        dola.burn(amount);\n        supplies[market] -= amount;\n        globalSupply -= amount;\n        emit Contraction(market, amount);\n    }\n\n    /**\n    @notice Gets the profit of a market.\n    @param market The market to withdraw profit from.\n    @return A uint representing the profit of the market.\n    */\n    function getProfit(IMarket market) public view returns (uint) {\n        uint marketValue = dola.balanceOf(address(market)) + market.totalDebt();\n        uint supply = supplies[market];\n        if(supply >= marketValue) return 0;\n        return marketValue - supply;\n    }\n\n    /**\n    @notice Takes profit from a market\n    @param market The market to take profit from.\n    */\n    function takeProfit(IMarket market) public {\n        uint profit = getProfit(market);\n        if(profit > 0) {\n            market.recall(profit);\n            dola.transfer(gov, profit);\n        }\n    }\n\n\n    event Expansion(IMarket indexed market, uint amount);\n    event Contraction(IMarket indexed market, uint amount);\n\n}\n\n\n",
        "CodeNames": [
            "Market.sol",
            "Fed.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\n        if(liquidationFeeBps  0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() = liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n"
                ],
                "Type": " User can free from liquidation fee if its escrow balance is less than the calculated liquidation fee",
                "Description": "*Submitted by jayphbee(https://github.com/code-423n4/2022-10-inverse-findings/issues/275), also found by catchup(https://github.com/code-423n4/2022-10-inverse-findings/issues/391), corerouter(https://github.com/code-423n4/2022-10-inverse-findings/issues/330), trustindistrust(https://github.com/code-423n4/2022-10-inverse-findings/issues/302), and cccz(https://github.com/code-423n4/2022-10-inverse-findings/issues/115)*\n\nUser can free from liquidation fee if its escrow balance less than the calculated liquidation fee.\n\n\nIf the liquidationFeeBps is enabled, the gov should receive the liquidation fee. But if user's escrow balance is less than the calculated liquidation fee, gov got nothing.<br\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610\n\nsolidity\n        if(liquidationFeeBps  0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() = liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n\n\n",
                "Repair": "\nUser should pay all the remaining escrow balance if the calculated liquidation fee is greater than its escrow balance.\n\nsolidity\n        if(liquidationFeeBps  0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() = liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            } else {\n                escrow.pay(gov, escrow.balance());\n            }\n        }\n\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/275#issuecomment-1304642370):\n  This should amount to dust. \n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/275#issuecomment-1308193523):\n  Fixed in https://github.com/InverseFinance/FrontierV2/pull/15.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "7",
                "Location": [
                    "diff\n  function expansion(IMarket market, uint amount) public {\n+   function expansion(IMarket market, uint amount) public noReentrant {\n        ...\n    }\n\n  function contraction(IMarket market, uint amount) public {\n+   function contraction(IMarket market, uint amount) public noReentrant {\n        ...\n    }\n",
                    "js\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n"
                ],
                "Type": " Lack of no reentrant modifier",
                "Description": "\nThe Market.getEscrow, Fed.expansion and Fed.contraction methods do not have the noReentrant modifier and make calls to an external contract that can take advantage of and call these methods again, but it seems to fail due to the lack of tokens.\n\nHowever, if any of the other addresses used their receive event to provide liquidity to the contract, the attacking account could benefit from it.\n\ndiff\n  function expansion(IMarket market, uint amount) public {\n+   function expansion(IMarket market, uint amount) public noReentrant {\n        ...\n    }\n\n  function contraction(IMarket market, uint amount) public {\n+   function contraction(IMarket market, uint amount) public noReentrant {\n        ...\n    }\n\n\nFor example, in getEscrow if the escrow allows a callback, it could create two scrows, loosing funds if in this callback it will call again getEscrow, using for example deposit\n\njs\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n\n*   Bob call deposit.\n*   During the escrow initialization it happend a reentrancy and call again deposit.\n*   The first deposit will be loss in the first escrow.\n\n*Please note that current escrows do not allow re-entry, so I decided to use Low*.\nIt's always good to change the storage flags before the externals calls.\n\n\n*   Fed.sol:86(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Fed.sol#L86)\n*   Fed.sol:103(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Fed.sol#L103)\n*   Market.sol:245(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L245)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n",
        "CodeNames": [
            "demo.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "sol\nuint day = block.timestamp / 1 days;\n"
                ],
                "Type": " Oracle's two-day feature can be gamed",
                "Description": "*Submitted by Ruhum(https://github.com/code-423n4/2022-10-inverse-findings/issues/278)*\n\nOracle.sol#L124(https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L124)<br\n\nThe two-day feature of the oracle can be gamed where you only have to manipulate the oracle for ~2 blocks.\n\n\nThe oracle computes the day using:\n\nsol\nuint day = block.timestamp / 1 days;\n\n\nSince we're working with uint values here, the following is true:<br\n1728799 / 86400 = 1<br\n172800 / 86400 = 2<br\n\nMeaning, if you manipulate the oracle at the last block of day X, e.g. 23:59:50, and at the first block of day X + 1, e.g. 00:00:02, you bypass the two-day feature of the oracle. You only have to manipulate the oracle for two blocks.\n\nThis is quite hard to pull off. I'm also not sure whether there were any instances of Chainlink oracle manipulation before. But, since you designed this feature to prevent small timeframe oracle manipulation I think it's valid to point this out.\n\n",
                "Repair": "\nIf you increase it to a three-day interval you can fix this issue. Then, the oracle has to be manipulated for at least 24 hours.\n\n08xmt (Inverse) acknowledged and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/278#issuecomment-1315421650):\n  This is an issue if a 24 hour period elapses without any calls to the oracle *and* the underlying oracle is manipulable. The two day low is meant to be an added layer of security, but not bullet proof.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "2",
                "Location": [
                    "address("
                ],
                "Type": " Lack of checks  address(0) ",
                "Description": "\nThe following methods have a lack of checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than address(0).\n\n\n*   BorrowController.sol:14(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/BorrowController.sol#L14)\n*   BorrowController.sol:26(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/BorrowController.sol#L26)\n*   SimpleERC20Escrow.sol:28(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/escrows/SimpleERC20Escrow.sol#L28)\n*   GovTokenEscrow.sol:33-34(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/escrows/GovTokenEscrow.sol#L33-L34)\n*   INVEscrow.sol:35(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/escrows/INVEscrow.sol#L35)\n*   INVEscrow.sol:47-48(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/escrows/INVEscrow.sol#L47-L48)\n*   Fed.sol:37-40(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Fed.sol#L37-L40)\n*   Fed.sol:50(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Fed.sol#L50)\n*   Fed.sol:68(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Fed.sol#L68)\n*   Oracle.sol:32(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L32)\n*   Oracle.sol:44(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L44)\n*   DBR.sol:39(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/DBR.sol#L39)\n*   DBR.sol:54(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/DBR.sol#L54)\n*   Market.sol:77-83(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L77-L83)\n*   Market.sol:130(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L130)\n*   Market.sol:136(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L136)\n*   Market.sol:142(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L142)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "4",
                "Location": [
                    "bytes"
                ],
                "Type": " Mixing and Outdated compiler",
                "Description": "\nThe pragma version used are:\n\n    pragma solidity ^0.8.13;\n\n*Note that mixing pragma is not recommended. Because different compiler versions have different meanings and behaviors, it also significantly raises maintenance costs. As a result, depending on the compiler version selected for any given file, deployed contracts may have security issues.*\n\nThe minimum required version must be 0.8.17(https://github.com/ethereum/solidity/releases/tag/v0.8.17); otherwise, contracts will be affected by the following important bug fixes:\n\n0.8.14(https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/):\n\n*   ABI Encoder: When ABI-encoding values from calldata that contain nested arrays, correctly validate the nested array length against calldatasize() in all cases.\n*   Override Checker: Allow changing data location for parameters only when overriding external functions.\n\n0.8.15(https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/)\n\n*   Code Generation: Avoid writing dirty bytes to storage when copying bytes arrays.\n*   Yul Optimizer: Keep all memory side-effects of inline assembly blocks.\n\n0.8.16(https://blog.soliditylang.org/2022/08/08/solidity-0.8.16-release-announcement/)\n\n*   Code Generation: Fix data corruption that affected ABI-encoding of calldata values represented by tuples: structs at any nesting level; argument lists of external functions, events and errors; return value lists of external functions. The 32 leading bytes of the first dynamically-encoded value in the tuple would get zeroed when the last component contained a statically-encoded array.\n\n0.8.17(https://blog.soliditylang.org/2022/09/08/solidity-0.8.17-release-announcement/)\n\n*   Yul Optimizer: Prevent the incorrect removal of storage writes before calls to Yul functions that conditionally terminate the external EVM call.\n\nApart from these, there are several minor bug fixes and improvements.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "3",
                "Location": [
                    "diff\ndiff --git a/src/Fed.sol b/src/Fed.sol\nindex 1e819bb..8b54676 100644\n--a/src/Fed.sol\n+++ b/src/Fed.sol\n@@ -41,12 +41,24 @@ contract Fed {\n   41,  41:         supplyCeiling = _supplyCeiling;\n   42,  42:     }\n   43,  43: \n+       44:+    function is_gov() private view {\n+       45:+        require(msg.sender == gov, \"ONLY GOV\");\n+       46:+    }\n+       47:+\n+       48:+    function is_chair() private view {\n+       49:+        require(msg.sender == chair, \"ONLY CHAIR\");\n+       50:+    }\n+       51:+\n+       52:+    function is_supported_market(IMarket _market) private view {\n+       53:+        require(dbr.markets(address(_market)), \"UNSUPPORTED MARKET\");\n+       54:+    }\n+       55:+\n   44,  56:     /\n   45,  57:     @notice Change the governance of the Fed contact. Only callable by governance.\n   46,  58:     @param _gov The address of the new governance contract\n   47,  59:     */\n   48,  60:     function changeGov(address _gov) public {\n 49     :       require(msg.sender == gov, \"ONLY GOV\");\n+       61:+        is_gov();\n   50,  62:         gov = _gov;\n   51,  63:     }\n   52,  64: \n@@ -55,7 +67,7 @@ contract Fed {\n   55,  67:     @param _supplyCeiling Amount to set the supply ceiling to\n   56,  68:     */\n   57,  69:     function changeSupplyCeiling(uint _supplyCeiling) public {\n 58     :       require(msg.sender == gov, \"ONLY GOV\");\n+       70:+        is_gov();\n   59,  71:         supplyCeiling = _supplyCeiling;\n   60,  72:     }\n   61,  73: \n@@ -64,7 +76,7 @@ contract Fed {\n   64,  76:     @param _chair Address of the new chair.\n   65,  77:     */\n   66,  78:     function changeChair(address _chair) public {\n 67     :       require(msg.sender == gov, \"ONLY GOV\");\n+       79:+        is_gov();\n   68,  80:         chair = _chair;\n   69,  81:     }\n   70,  82: \n@@ -73,7 +85,7 @@ contract Fed {\n   73,  85:     @dev Useful for immediately removing chair powers in case of a wallet compromise.\n   74,  86:     */\n   75,  87:     function resign() public {\n 76     :       require(msg.sender == chair, \"ONLY CHAIR\");\n+       88:+        is_chair();\n   77,  89:         chair = address(0);\n   78,  90:     }\n   79,  91: \n@@ -84,8 +96,8 @@ contract Fed {\n   84,  96:     @param amount The amount of DOLA to mint and supply to the market.\n   85,  97:     */\n   86,  98:     function expansion(IMarket market, uint amount) public {\n 87     :       require(msg.sender == chair, \"ONLY CHAIR\");\n 88     :       require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n+       99:+        is_chair();\n+      100:+        is_supported_market(market);\n   89, 101:         require(market.borrowPaused() != true, \"CANNOT EXPAND PAUSED MARKETS\");\n   90, 102:         dola.mint(address(market), amount);\n   91, 103:         supplies[market] += amount;\n@@ -101,8 +113,8 @@ contract Fed {\n  101, 113:     @param amount The amount of DOLA to withdraw and burn.\n  102, 114:     */\n  103, 115:     function contraction(IMarket market, uint amount) public {\n104     :       require(msg.sender == chair, \"ONLY CHAIR\");\n105     :       require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n+      116:+        is_chair();\n+      117:+        is_supported_market(market);\n  106, 118:         uint supply = supplies[market];\n  107, 119:         require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n  108, 120:         market.recall(amount);\n",
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..625c422 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -46,6 +46,10 @@ contract DolaBorrowingRights {\n   46,  46:         _;\n   47,  47:     }\n   48,  48:     \n+       49:+    function is_balance_sufficient(address _user, uint256 amount) private view {\n+       50:+        require(balanceOf(_user) = amount, \"Insufficient balance\");\n+       51:+    }\n+       52:+\n   49,  53:     /\n   50,  54:     @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n   51,  55:     @param newOperator_ The address of the newOperator\n@@ -168,7 +172,7 @@ contract DolaBorrowingRights {\n  168, 172:     @return Always returns true, will revert if not successful.\n  169, 173:     */\n  170, 174:     function transfer(address to, uint256 amount) public virtual returns (bool) {\n171     :       require(balanceOf(msg.sender) = amount, \"Insufficient balance\");\n+      175:+        is_balance_sufficient(msg.sender, amount);\n  172, 176:         balances[msg.sender] -= amount;\n  173, 177:         unchecked {\n  174, 178:             balances[to] += amount;\n@@ -192,7 +196,7 @@ contract DolaBorrowingRights {\n  192, 196:     ) public virtual returns (bool) {\n  193, 197:         uint256 allowed = allowance[from][msg.sender];\n  194, 198:         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed amount;\n195     :       require(balanceOf(from) = amount, \"Insufficient balance\");\n+      199:+        is_balance_sufficient(from, amount);\n  196, 200:         balances[from] -= amount;\n  197, 201:         unchecked {\n  198, 202:             balances[to] += amount;\n@@ -370,7 +374,7 @@ contract DolaBorrowingRights {\n  370, 374:     @param amount Amount of DBR to be burned.\n  371, 375:     */\n  372, 376:     function _burn(address from, uint256 amount) internal virtual {\n373     :       require(balanceOf(from) = amount, \"Insufficient balance\");\n+      377:+        is_balance_sufficient(from, amount);\n  374, 378:         balances[from] -= amount;\n  375, 379:         unchecked {\n  376, 380:             _totalSupply -= amount;\n"
                ],
                "Type": " Duplicated  require() / revert()  checks should be refactored to a modifier or function (instances)",
                "Description": "\nDeployment. Gas Saved: 114 932\n\nMinimum Method Call. Gas Saved: -59\n\nAverage Method Call. Gas Saved: -284\n\nMaximum Method Call. Gas Saved: -398\n\nOverall gas change: -2 665 (-12.599%)\n\n\ndiff\ndiff --git a/src/Fed.sol b/src/Fed.sol\nindex 1e819bb..8b54676 100644\n--a/src/Fed.sol\n+++ b/src/Fed.sol\n@@ -41,12 +41,24 @@ contract Fed {\n   41,  41:         supplyCeiling = _supplyCeiling;\n   42,  42:     }\n   43,  43: \n+       44:+    function is_gov() private view {\n+       45:+        require(msg.sender == gov, \"ONLY GOV\");\n+       46:+    }\n+       47:+\n+       48:+    function is_chair() private view {\n+       49:+        require(msg.sender == chair, \"ONLY CHAIR\");\n+       50:+    }\n+       51:+\n+       52:+    function is_supported_market(IMarket _market) private view {\n+       53:+        require(dbr.markets(address(_market)), \"UNSUPPORTED MARKET\");\n+       54:+    }\n+       55:+\n   44,  56:     /\n   45,  57:     @notice Change the governance of the Fed contact. Only callable by governance.\n   46,  58:     @param _gov The address of the new governance contract\n   47,  59:     */\n   48,  60:     function changeGov(address _gov) public {\n 49     :       require(msg.sender == gov, \"ONLY GOV\");\n+       61:+        is_gov();\n   50,  62:         gov = _gov;\n   51,  63:     }\n   52,  64: \n@@ -55,7 +67,7 @@ contract Fed {\n   55,  67:     @param _supplyCeiling Amount to set the supply ceiling to\n   56,  68:     */\n   57,  69:     function changeSupplyCeiling(uint _supplyCeiling) public {\n 58     :       require(msg.sender == gov, \"ONLY GOV\");\n+       70:+        is_gov();\n   59,  71:         supplyCeiling = _supplyCeiling;\n   60,  72:     }\n   61,  73: \n@@ -64,7 +76,7 @@ contract Fed {\n   64,  76:     @param _chair Address of the new chair.\n   65,  77:     */\n   66,  78:     function changeChair(address _chair) public {\n 67     :       require(msg.sender == gov, \"ONLY GOV\");\n+       79:+        is_gov();\n   68,  80:         chair = _chair;\n   69,  81:     }\n   70,  82: \n@@ -73,7 +85,7 @@ contract Fed {\n   73,  85:     @dev Useful for immediately removing chair powers in case of a wallet compromise.\n   74,  86:     */\n   75,  87:     function resign() public {\n 76     :       require(msg.sender == chair, \"ONLY CHAIR\");\n+       88:+        is_chair();\n   77,  89:         chair = address(0);\n   78,  90:     }\n   79,  91: \n@@ -84,8 +96,8 @@ contract Fed {\n   84,  96:     @param amount The amount of DOLA to mint and supply to the market.\n   85,  97:     */\n   86,  98:     function expansion(IMarket market, uint amount) public {\n 87     :       require(msg.sender == chair, \"ONLY CHAIR\");\n 88     :       require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n+       99:+        is_chair();\n+      100:+        is_supported_market(market);\n   89, 101:         require(market.borrowPaused() != true, \"CANNOT EXPAND PAUSED MARKETS\");\n   90, 102:         dola.mint(address(market), amount);\n   91, 103:         supplies[market] += amount;\n@@ -101,8 +113,8 @@ contract Fed {\n  101, 113:     @param amount The amount of DOLA to withdraw and burn.\n  102, 114:     */\n  103, 115:     function contraction(IMarket market, uint amount) public {\n104     :       require(msg.sender == chair, \"ONLY CHAIR\");\n105     :       require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n+      116:+        is_chair();\n+      117:+        is_supported_market(market);\n  106, 118:         uint supply = supplies[market];\n  107, 119:         require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n  108, 120:         market.recall(amount);\n\n\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..625c422 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -46,6 +46,10 @@ contract DolaBorrowingRights {\n   46,  46:         _;\n   47,  47:     }\n   48,  48:     \n+       49:+    function is_balance_sufficient(address _user, uint256 amount) private view {\n+       50:+        require(balanceOf(_user) = amount, \"Insufficient balance\");\n+       51:+    }\n+       52:+\n   49,  53:     /\n   50,  54:     @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n   51,  55:     @param newOperator_ The address of the newOperator\n@@ -168,7 +172,7 @@ contract DolaBorrowingRights {\n  168, 172:     @return Always returns true, will revert if not successful.\n  169, 173:     */\n  170, 174:     function transfer(address to, uint256 amount) public virtual returns (bool) {\n171     :       require(balanceOf(msg.sender) = amount, \"Insufficient balance\");\n+      175:+        is_balance_sufficient(msg.sender, amount);\n  172, 176:         balances[msg.sender] -= amount;\n  173, 177:         unchecked {\n  174, 178:             balances[to] += amount;\n@@ -192,7 +196,7 @@ contract DolaBorrowingRights {\n  192, 196:     ) public virtual returns (bool) {\n  193, 197:         uint256 allowed = allowance[from][msg.sender];\n  194, 198:         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed amount;\n195     :       require(balanceOf(from) = amount, \"Insufficient balance\");\n+      199:+        is_balance_sufficient(from, amount);\n  196, 200:         balances[from] -= amount;\n  197, 201:         unchecked {\n  198, 202:             balances[to] += amount;\n@@ -370,7 +374,7 @@ contract DolaBorrowingRights {\n  370, 374:     @param amount Amount of DBR to be burned.\n  371, 375:     */\n  372, 376:     function _burn(address from, uint256 amount) internal virtual {\n373     :       require(balanceOf(from) = amount, \"Insufficient balance\");\n+      377:+        is_balance_sufficient(from, amount);\n  374, 378:         balances[from] -= amount;\n  375, 379:         unchecked {\n  376, 380:             _totalSupply -= amount;\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n",
        "CodeNames": [
            "demo.sol",
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "collateralFactorBps",
                    "if(collateralFactorBps ==",
                    "getWithdrawalLimitInternal()",
                    "getCreditLimitInternal()",
                    "setCollateralFactorBps()"
                ],
                "Type": " Protocol withdrawals of collateral can be unexpectedly locked if governance sets the  collateralFactorBps  to 0",
                "Description": "*Submitted by trustindistrust(https://github.com/code-423n4/2022-10-inverse-findings/issues/301), also found by cryptonue(https://github.com/code-423n4/2022-10-inverse-findings/issues/576), d3e4(https://github.com/code-423n4/2022-10-inverse-findings/issues/570), pashov(https://github.com/code-423n4/2022-10-inverse-findings/issues/563), eierina(https://github.com/code-423n4/2022-10-inverse-findings/issues/541), pedroais(https://github.com/code-423n4/2022-10-inverse-findings/issues/511), RaoulSchaffranek(https://github.com/code-423n4/2022-10-inverse-findings/issues/502), c7e7eff(https://github.com/code-423n4/2022-10-inverse-findings/issues/470), simon135(https://github.com/code-423n4/2022-10-inverse-findings/issues/442), Jujic(https://github.com/code-423n4/2022-10-inverse-findings/issues/422), catchup(https://github.com/code-423n4/2022-10-inverse-findings/issues/338), 0xbepresent(https://github.com/code-423n4/2022-10-inverse-findings/issues/292), jwood(https://github.com/code-423n4/2022-10-inverse-findings/issues/261), Lambda(https://github.com/code-423n4/2022-10-inverse-findings/issues/209), peanuts(https://github.com/code-423n4/2022-10-inverse-findings/issues/200), and codexploder(https://github.com/code-423n4/2022-10-inverse-findings/issues/120)*\n\n<https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L359<br\n<https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L376<br\n\nThe FiRM Marketplace contract contains multiple governance functions for setting important values for a given debt market. Many of these are numeric values that affect ratios/levels for debt positions, fees, incentives, etc.\n\nIn particular, Market.setCollateralFactorBps() sets the ratio for how much collateral is required for loans vs the debt taken on by the user. The lower the value, the less debt a user can take on. See Market.getCreditLimitInternal() for that implementation.\n\nThe function Market.getWithdrawalLimitInternal() calculates how much collateral a user can withdraw from the protocol, factoring in their current level of debt. It contains the following check:\n\nif(collateralFactorBps == 0) return 0;\n\nThis would cause the user to not be able to withdraw any tokens, so long as they had any non-0 amount of debt and the collateralFactorBps was 0.\n\n\nIt is the warden's estimation that all semantics for locking functionality of the protocol should be explicit rather than implicit. While it is very unlikely that governance would intentionally set this value to 0, if it were to do so it would disproportionately affect users whose debt values were low compared to their deposited collateral.\n\nIt is also obvious that the same function that set the value to 0 could be used to revert the change. However, this would take time. Inverse Finance has mandatory minimums for the time required to process governance items in its workflow (<https://docs.inverse.finance/inverse-finance/governance/creating-a-proposal)\n\n The community has a social agreement to post all proposals on the forum and as a draft in GovMills at least 24 hours before the proposal is put up for an on-chain vote, and also to host a community call focusing on the proposal before the voting period.\n\n Once a proposal has passed, it must be queued on-chain. This action can be triggered by anyone who is willing to pay the gas fee (usually done by a DAO member). The proposal then enters a holding period of 40 hours to allow users time to prepare for the consequences of the execution of the proposal.\n\nAs such, were the situation to occur it would cause at least 64 hours of lock.\n\nSince the contract itself only overtly contains locking for new borrowing, this implicit lock on withdraws seems like an unnecessary risk.\n\n",
                "Repair": "\nConsider a minimum for this value, to go along with the maximum value check already present in the setter function. While this will still reduce the quantity of collateral that can be withdrawn by users, it would allow for some withdraws to occur.\n\nAn explicit withdrawal lock could be implemented, making the semantic clear. This function could have modified access controls to enable faster reactions vs governance alone.\n\nAlternatively, if there was an intention for this value to accept 0, consider an 'escape hatch' function that could be enacted by users when a 'defaulted' state is set on the Market.\n\n08xmt (Inverse) disputed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/301#issuecomment-1351644972):\n  This is functioning as intended. Setting a low collateralFactor like this is essentially a way to force borrowers to repay their debt. It may be a necessary operation in an emergency.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n    function delegate(address delegatee) external;\n    function delegates(address delegator) external view returns (address delegatee);\n}\n\n/**\n@title Gov Token Escrow\n@notice Collateral is stored in unique escrow contracts for every user and every market.\n This specific escrow is meant as an example of how an escrow can be implemented that allows depositors to delegate votes with their collateral, unlike pooled deposit protocols.\n@dev Caution: This is a proxy implementation. Follow proxy pattern best practices\n*/\ncontract GovTokenEscrow {\n    address public market;\n    IERC20 public token;\n    address public beneficiary;\n\n    /**\n    @notice Initialize escrow with a token\n    @dev Must be called right after proxy is created.\n    @param _token The IERC20 token representing the governance token\n    @param _beneficiary The beneficiary who may delegate token voting power\n    */\n    function initialize(IERC20 _token, address _beneficiary) public {\n        require(market == address(0), \"ALREADY INITIALIZED\");\n        market = msg.sender;\n        token = _token;\n        beneficiary = _beneficiary;\n        _token.delegate(_token.delegates(_beneficiary));\n    }\n\n    /**\n    @notice Transfers the associated ERC20 token to a recipient.\n    @param recipient The address to receive payment from the escrow\n    @param amount The amount of ERC20 token to be transferred.\n    */\n    function pay(address recipient, uint amount) public {\n        require(msg.sender == market, \"ONLY MARKET\");\n        token.transfer(recipient, amount);\n    }\n\n    /**\n    @notice Get the token balance of the escrow\n    @return Uint representing the INV token balance of the escrow including the additional INV accrued from xINV\n    */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    /* Uncomment if Escrow contract should handle on deposit callbacks. This function should remain callable by anyone to handle direct inbound transfers.\n    function onDeposit() public {\n\n    }\n    */\n\n    /**\n    @notice Delegates voting power of the underlying xINV.\n    @param delegatee The address to be delegated voting power\n    */\n    function delegate(address delegatee) public {\n        require(msg.sender == beneficiary);\n        token.delegate(delegatee);\n    }\n}\n\n\n",
        "CodeNames": [
            "GovTokenEscrow.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "javascript\n...\naddress public immutable escrowImplementation;\n...\nbool immutable callOnDepositCallback;\n...\n",
                    "javascript\nconstructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n\t...\n\tescrowImplementation = _escrowImplementation;\n\t...\n\tcallOnDepositCallback = _callOnDepositCallback;\n\t...\n }\n",
                    "javascript\nfunction deposit(address user, uint amount) public {\n\t...\n\tif(callOnDepositCallback) {\n\t\tescrow.onDeposit();\n\t}\n\temit Deposit(user, amount);\n}\n",
                    "javascript\nfunction onDeposit() public {\n\tuint invBalance = token.balanceOf(address(this));\n\tif(invBalance  0) {\n\t\txINV.mint(invBalance); // we do not check return value because we don't want errors to block this call\n\t}\n}\n"
                ],
                "Type": " Avoidable misconfiguration could lead to  INVEscrow  contract not minting  xINV  tokens",
                "Description": "*Submitted by neumo(https://github.com/code-423n4/2022-10-inverse-findings/issues/379), also found by minhtrng(https://github.com/code-423n4/2022-10-inverse-findings/issues/506), ladboy233(https://github.com/code-423n4/2022-10-inverse-findings/issues/187), BClabs(https://github.com/code-423n4/2022-10-inverse-findings/issues/106), and rvierdiiev(https://github.com/code-423n4/2022-10-inverse-findings/issues/88)*\n\nMarket.sol#L281-L283(https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L281-L283)<br\n\nIf a user creates a market with the INVEscrow implementation as escrowImplementation and false as callOnDepositCallback, the deposits made by users in the escrow (through the market) would not mint xINV tokens for them. As callOnDepositCallback is an immutable variable set in the constructor, this mistake would make the market a failure and the user should deploy a new one (even worse, if the error is detected after any user has deposited funds, some sort of migration of funds should be needed).\n\n\nBoth escrowImplementation and callOnDepositCallback are immutable:\n\njavascript\n...\naddress public immutable escrowImplementation;\n...\nbool immutable callOnDepositCallback;\n...\n\n\nand its value is set at creation:\n\njavascript\nconstructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n\t...\n\tescrowImplementation = _escrowImplementation;\n\t...\n\tcallOnDepositCallback = _callOnDepositCallback;\n\t...\n }\n\n\nWhen the user deposits collateral, if callOnDepositCallback is true, there is a call to the escrow's onDeposit callback:\n\njavascript\nfunction deposit(address user, uint amount) public {\n\t...\n\tif(callOnDepositCallback) {\n\t\tescrow.onDeposit();\n\t}\n\temit Deposit(user, amount);\n}\n\n\nThis is INVEscrow's onDeposit function:\n\njavascript\nfunction onDeposit() public {\n\tuint invBalance = token.balanceOf(address(this));\n\tif(invBalance  0) {\n\t\txINV.mint(invBalance); // we do not check return value because we don't want errors to block this call\n\t}\n}\n\n\nThe thing is if callOnDepositCallback is false, this function is never called and the user does not turn his/her collateral (INV) into xINV.\n\n",
                "Repair": "\nEither make callOnDepositCallback a configurable parameter in Market.sol or always call the onDeposit callback (just get rid of the callOnDepositCallback variable) and leave it empty in case there's no extra functionality that needs to be executed for that escrow. In the case that the same escrow has to execute the callback for some markets and not for others, this solution would imply that there should be two escrows, one with the callback to be executed and another with the callback empty.\n\n08xmt (Inverse) acknowledged, but disagreed with severity and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/379#issuecomment-1352201329):\n  Fixed in https://github.com/InverseFinance/FrontierV2/pull/21/commits/0d4b01c594fb56a9f0ba944f6946874a5b335152\n\n  We acknowledge that markets can be configured incorrectly, but it should generally be assumed that markets will be configured correctly, as this will go through both internal and governance review.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n",
        "CodeNames": [
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [
                    "//solidity\n// src/test/Oracle.t.sol\nfunction test_viewPriceNoDampenedPrice_AUDIT() public {\n    uint collateralFactor = market.collateralFactorBps();\n    uint day = block.timestamp / 1 days;\n    uint feedPrice = ethFeed.latestAnswer();\n\n    //1600e18 price saved as daily low\n    oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), day), feedPrice);\n\n    vm.warp(block.timestamp + 1 days);\n    uint newPrice = 1200e18;\n    ethFeed.changeAnswer(newPrice);\n    //1200e18 price saved as daily low\n    oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);\n\n    vm.warp(block.timestamp + 1 days);\n    newPrice = 3000e18;\n    ethFeed.changeAnswer(newPrice);\n\n    //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.\n    // Notice that viewPrice is called before getPrice.\n    uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);\n    uint price = oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);\n\n    assertEq(price, 1200e18 * 10_000 / collateralFactor);\n\n    // View price wasn't dampened.\n    assertEq(viewPrice, 3000e18);\n}\n"
                ],
                "Type": "  viewPrice  doesn't always report dampened price",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-10-inverse-findings/issues/404)*\n\nOracle.sol#L91(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L91)<br\n\nOracle's viewPrice function doesn't report a dampened price until getPrice is called and today's price is updated. This will impact the public read-only functions that call it:\n\n*   getCollateralValue(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L312);\n*   getCreditLimit(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L334) (calls getCollateralValue);\n*   getLiquidatableDebt(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L578) (calls getCreditLimit);\n*   getWithdrawalLimit(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L370).\n\nThese functions are used to get on-chain state and prepare values for write calls (e.g. calculate withdrawal amount before withdrawing or calculate a user's debt that can be liquidated before liquidating it). Thus, wrong values returned by these functions can cause withdrawal of a wrong amount or liquidation of a wrong debt or cause reverts.\n\n\nsolidity\n// src/test/Oracle.t.sol\nfunction test_viewPriceNoDampenedPrice_AUDIT() public {\n    uint collateralFactor = market.collateralFactorBps();\n    uint day = block.timestamp / 1 days;\n    uint feedPrice = ethFeed.latestAnswer();\n\n    //1600e18 price saved as daily low\n    oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), day), feedPrice);\n\n    vm.warp(block.timestamp + 1 days);\n    uint newPrice = 1200e18;\n    ethFeed.changeAnswer(newPrice);\n    //1200e18 price saved as daily low\n    oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);\n\n    vm.warp(block.timestamp + 1 days);\n    newPrice = 3000e18;\n    ethFeed.changeAnswer(newPrice);\n\n    //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.\n    // Notice that viewPrice is called before getPrice.\n    uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);\n    uint price = oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);\n\n    assertEq(price, 1200e18 * 10_000 / collateralFactor);\n\n    // View price wasn't dampened.\n    assertEq(viewPrice, 3000e18);\n}\n\n\n",
                "Repair": "\nConsider this change:\n\ndiff\n--a/src/Oracle.sol\n+++ b/src/Oracle.sol\n@@ -89,6 +89,9 @@ contract Oracle {\n             uint day = block.timestamp / 1 days;\n             // get today's low\n             uint todaysLow = dailyLows[token][day];\n+            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n+                todaysLow = normalizedPrice;\n+            }\n             // get yesterday's low\n             uint yesterdaysLow = dailyLows[token][day 1];\n             // calculate new borrowing power based on collateral factor\n\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/404#issuecomment-1304647858):\n  Well written report that explains the impact of this unlike the others. Will leave open for review. \n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/404#issuecomment-1315325006):\n  Fixed in https://github.com/InverseFinance/FrontierV2/pull/18.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "javascript\n    function testForceReplenishFrontRun() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n        uint initialReplenisherDola = DOLA.balanceOf(replenisher);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint initialUserDebt = market.debts(user);\n        uint initialMarketDola = DOLA.balanceOf(address(market));\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + 5 days);\n        uint deficitBefore = dbr.deficitOf(user);\n        vm.startPrank(replenisher);\n\n        market.forceReplenish(user,1); // front run DoS\n\n        vm.expectRevert(\"Amount  deficit\");\n        market.forceReplenish(user, deficitBefore); // fails due to amount being larger than deficit\n        \n        assertEq(DOLA.balanceOf(replenisher), initialReplenisherDola, \"DOLA balance of replenisher changed\");\n        assertEq(DOLA.balanceOf(address(market)), initialMarketDola, \"DOLA balance of market changed\");\n        assertEq(DOLA.balanceOf(replenisher) initialReplenisherDola, initialMarketDola DOLA.balanceOf(address(market)),\n            \"DOLA balance of market did not decrease by amount paid to replenisher\");\n        assertEq(dbr.deficitOf(user), deficitBefore-1, \"Deficit of borrower was not fully replenished\");\n\n        // debt only increased by dust\n        assertEq(market.debts(user) initialUserDebt, 1 * replenishmentPriceBps / 10000, \"Debt of borrower did not increase by replenishment price\");\n    }\n"
                ],
                "Type": "  Market::forceReplenish  can be DoSed",
                "Description": "*Submitted by immeas(https://github.com/code-423n4/2022-10-inverse-findings/issues/443)*\n\nMarket.sol#L562(https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L562)<br\n\nIf a user wants to completely forceReplenish a borrower with deficit, the borrower or any other malicious party can front run this with a dust amount to prevent the replenish.\n\n\njavascript\n    function testForceReplenishFrontRun() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n        uint initialReplenisherDola = DOLA.balanceOf(replenisher);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint initialUserDebt = market.debts(user);\n        uint initialMarketDola = DOLA.balanceOf(address(market));\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + 5 days);\n        uint deficitBefore = dbr.deficitOf(user);\n        vm.startPrank(replenisher);\n\n        market.forceReplenish(user,1); // front run DoS\n\n        vm.expectRevert(\"Amount  deficit\");\n        market.forceReplenish(user, deficitBefore); // fails due to amount being larger than deficit\n        \n        assertEq(DOLA.balanceOf(replenisher), initialReplenisherDola, \"DOLA balance of replenisher changed\");\n        assertEq(DOLA.balanceOf(address(market)), initialMarketDola, \"DOLA balance of market changed\");\n        assertEq(DOLA.balanceOf(replenisher) initialReplenisherDola, initialMarketDola DOLA.balanceOf(address(market)),\n            \"DOLA balance of market did not decrease by amount paid to replenisher\");\n        assertEq(dbr.deficitOf(user), deficitBefore-1, \"Deficit of borrower was not fully replenished\");\n\n        // debt only increased by dust\n        assertEq(market.debts(user) initialUserDebt, 1 * replenishmentPriceBps / 10000, \"Debt of borrower did not increase by replenishment price\");\n    }\n\n\nThis requires that the two txs end up in the same block. If they end up in different blocks the front run transaction will need to account for the increase in deficit between blocks.\n\n\nvscode, forge\n\n",
                "Repair": "\nUse min(deficit,amount) as amount to replenish.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/443#issuecomment-1304652467):\n  Very similar to #439(https://github.com/code-423n4/2022-10-inverse-findings/issues/439) and unclear as the benefit the attacker is gaining here. They would be better off just front running the entire transaction and getting additional reward. Will leave open for sponsor review, but most likely QA or invalid. \n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/443#issuecomment-1309781833):\n  Fixed in https://github.com/InverseFinance/FrontierV2/pull/16.<br\n Possible to imagine a situation where an attacker has an underwater loan and keeps front running his own forced replenishments with single digit DBR forced replenishments.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "0",
                "Location": [
                    "setCollateralFactorBps",
                    "pauseBorrows",
                    "setLiquidationFeeBps",
                    "setLiquidationFactorBps",
                    "setOracle",
                    "setBorrowController",
                    "setLiquidationIncentiveBps",
                    "setReplenismentIncentiveBps"
                ],
                "Type": " Lack of event emit",
                "Description": "\nThe Market.pauseBorrows, Market.setLiquidationFeeBps, Market.setLiquidationIncentiveBps, Market.setReplenismentIncentiveBps, Market.setLiquidationFactorBps, Market.setCollateralFactorBps, Market.setBorrowController, Market.setOracle methods do not emit an event when the state changes, something that it's very important for dApps and users.\n\n\n*   Market.sol:118(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L118)\n*   Market.sol:124(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L124)\n*   Market.sol:149(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L149)\n*   Market.sol:161(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L161)\n*   Market.sol:172(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L172)\n*   Market.sol:183(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L183)\n*   Market.sol:194(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L194)\n*   Market.sol:218(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L218)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "5",
                "Location": [
                    "js\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n"
                ],
                "Type": " Avoid duplicate code",
                "Description": "\nThe viewPrice and getPrice methods of the Oracle contract are very similar, the only difference being the following peace of code:\n\njs\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n\n\nIt's recommended to reuse the code in order to be more readable and light.\n\n\n*   Oracle.sol:126-130(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L126-L130)\n*   Oracle.sol:79-103(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L79-L103)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/**\n@title Dola Borrow Rights\n@notice The DolaBorrowRights contract is a non-standard ERC20 token, that gives the right of holders to borrow DOLA at 0% interest.\n As a borrower takes on DOLA debt, their DBR balance will be exhausted at 1 DBR per 1 DOLA borrowed per year.\n*/\ncontract DolaBorrowingRights {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public _totalSupply;\n    address public operator;\n    address public pendingOperator;\n    uint public totalDueTokensAccrued;\n    uint public replenishmentPriceBps;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    mapping (address => bool) public minters;\n    mapping (address => bool) public markets;\n    mapping (address => uint) public debts; // user => debt across all tracked markets\n    mapping (address => uint) public dueTokensAccrued; // user => amount of due tokens accrued\n    mapping (address => uint) public lastUpdated; // user => last update timestamp\n\n    constructor(\n        uint _replenishmentPriceBps,\n        string memory _name,\n        string memory _symbol,\n        address _operator\n    ) {\n        replenishmentPriceBps = _replenishmentPriceBps;\n        name = _name;\n        symbol = _symbol;\n        operator = _operator;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n    @param newOperator_ The address of the newOperator\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator {\n        pendingOperator = newOperator_;\n    }\n\n    /**\n    @notice Sets the replenishment price in basis points. Replenishment price denotes the increase in DOLA debt upon forced replenishments.\n     At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n    @param newReplenishmentPriceBps_ The new replen\n    */\n    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n        require(newReplenishmentPriceBps_ > 0, \"replenishment price must be over 0\");\n        replenishmentPriceBps = newReplenishmentPriceBps_;\n    }\n    \n    /**\n    @notice claims the Operator role if set as pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address of the new minter.\n    */\n    function addMinter(address minter_) public onlyOperator {\n        minters[minter_] = true;\n        emit AddMinter(minter_);\n    }\n\n    /**\n    @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address to be removed from the minter set.\n    */\n    function removeMinter(address minter_) public onlyOperator {\n        minters[minter_] = false;\n        emit RemoveMinter(minter_);\n    }\n    /**\n    @notice Adds a market to the set of active markets. Only callable by Operator.\n    @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n    @param market_ The address of the new market contract to be added.\n    */\n    function addMarket(address market_) public onlyOperator {\n        markets[market_] = true;\n        emit AddMarket(market_);\n    }\n\n    /**\n    @notice Get the total supply of DBR tokens.\n    @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n    @return uint representing the total supply of DBR.\n    */\n    function totalSupply() public view returns (uint) {\n        if(totalDueTokensAccrued > _totalSupply) return 0;\n        return _totalSupply - totalDueTokensAccrued;\n    }\n\n    /**\n    @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n    @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n    @param user Address of the user.\n    @return uint representing the balance of the user.\n    */\n    function balanceOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued > balances[user]) return 0;\n        return balances[user] - dueTokensAccrued[user] - accrued;\n    }\n\n    /**\n    @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n    @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n    @param user Address of the user.\n    @return uint representing the deficit of the user.\n    */\n    function deficitOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n        return dueTokensAccrued[user] + accrued - balances[user];\n    }\n    \n    /**\n    @notice Get the signed DBR balance of an address.\n    @dev This function will revert if a user has a balance of more than 2^255-1 DBR\n    @param user Address of the user.\n    @return Returns a signed int of the user's balance\n    */\n    function signedBalanceOf(address user) public view returns (int) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        return int(balances[user]) - int(dueTokensAccrued[user]) - int(accrued);\n    }\n\n    /**\n    @notice Approves spender to spend amount of DBR on behalf of the message sender.\n    @param spender Address of the spender to be approved\n    @param amount Amount to be approved to spend\n    @return Always returns true, will revert if not successful.\n    */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfers amount to address to from message sender.\n    @param to The address to transfer to\n    @param amount The amount of DBR to transfer\n    @return Always returns true, will revert if not successful.\n    */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfer amount of DBR  on behalf of address from to address to. Message sender must have a sufficient allowance from the from address.\n    @dev Allowance is reduced by the amount transferred.\n    @param from Address to transfer from.\n    @param to Address to transfer to.\n    @param amount Amount of DBR to transfer.\n    @return Always returns true, will revert if not successful.\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Permits an address to spend on behalf of another address via a signed message.\n    @dev Can be bundled with a transferFrom call, to reduce transaction load on users.\n    @param owner Address of the owner permitting the spending\n    @param spender Address allowed to spend on behalf of owner.\n    @param value Amount to be allowed to spend.\n    @param deadline Timestamp after which the signed message is no longer valid.\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n    @notice Function for invalidating the nonce of a signed message.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice Accrue due DBR debt of user\n    @dev DBR debt is accrued at a rate of 1 DBR per 1 DOLA of debt per year.\n    @param user The address of the user to accrue DBR debt to.\n    */\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n\n    /**\n    @notice Function to be called by markets when a borrow occurs.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt.\n    @param user The address of the borrower\n    @param additionalDebt The additional amount of DOLA the user is borrowing\n    */\n    function onBorrow(address user, uint additionalDebt) public {\n        require(markets[msg.sender], \"Only markets can call onBorrow\");\n        accrueDueTokens(user);\n        require(deficitOf(user) == 0, \"DBR Deficit\");\n        debts[user] += additionalDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a repayment occurs.\n    @dev Accrues due tokens on behalf of the user, before reducing their debt.\n    @param user The address of the borrower having their debt repaid\n    @param repaidDebt The amount of DOLA repaid\n    */\n    function onRepay(address user, uint repaidDebt) public {\n        require(markets[msg.sender], \"Only markets can call onRepay\");\n        accrueDueTokens(user);\n        debts[user] -= repaidDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a force replenish occurs. This function can only be called if the user has a DBR deficit.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt by the replenishment price and minting them new DBR.\n    @param user The user to be force replenished.\n    @param amount The amount of DBR the user will be force replenished.\n    */\n    function onForceReplenish(address user, uint amount) public {\n        require(markets[msg.sender], \"Only markets can call onForceReplenish\");\n        uint deficit = deficitOf(user);\n        require(deficit > 0, \"No deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n        accrueDueTokens(user);\n        debts[user] += replenishmentCost;\n        _mint(user, amount);\n    }\n\n    /**\n    @notice Function for burning DBR from message sender, reducing supply.\n    @param amount Amount to be burned\n    */\n    function burn(uint amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n    @notice Function for minting new DBR, increasing supply. Only callable by minters and the operator.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function mint(address to, uint amount) public {\n        require(minters[msg.sender] == true || msg.sender == operator, \"ONLY MINTERS OR OPERATOR\");\n        _mint(to, amount);\n    }\n\n    /**\n    @notice Internal function for minting DBR.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n    @notice Internal function for burning DBR.\n    @param from Address to burn DBR from.\n    @param amount Amount of DBR to be burned.\n    */\n    function _burn(address from, uint256 amount) internal virtual {\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            _totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event AddMinter(address indexed minter);\n    event RemoveMinter(address indexed minter);\n    event AddMarket(address indexed market);\n    event ChangeOperator(address indexed newOperator);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n",
        "CodeNames": [
            "DBR.sol",
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "forceReplenish()",
                    "DOLA",
                    "getCollateralValueInternal(user)",
                    "dueTokensAccrued[user]",
                    "collateralFactorBps",
                    "collateralFactorBps /",
                    "liquidationFactorBps"
                ],
                "Type": "  Users could get some  DOLA  even if they are on liquidation position",
                "Description": "*Submitted by Ch_301(https://github.com/code-423n4/2022-10-inverse-findings/issues/419)*\n\nMarket.sol#L566(https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L566)<br\n\nUsers able to invoke forceReplenish() when they are on liquidation position.\n\n\nOn Market.sol == forceReplenish()<br\nOn this line\n\n    uint collateralValue = getCollateralValueInternal(user);\n\ngetCollateralValueInternal(user) only return the value of the collateral\n\n        function getCollateralValueInternal(address user) internal returns (uint) {\n            IEscrow escrow = predictEscrow(user);\n            uint collateralBalance = escrow.balance();\n            return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether; \n\nSo if the user have 1.5 wETH at the price of  1 ETH = 1600 USD <br\nIt will return 1.5 * 1600 and this value is the real value we can\u2019t just check it directly with the debt like this\n\n     require(collateralValue = debts[user], \"Exceeded collateral value\");\n\nThis is no longer over collateralized protocol.<br\nThe value needs to be multiplied by collateralFactorBps / 10000\n\n*   So depending on the value of collateralFactorBps and liquidationFactorBps the user could be in the liquidation position but he is able to invoke forceReplenish() to cover all their dueTokensAccrued[user] on DBR.sol and get more DOLA\n*   or it will lead a healthy debt to be in the liquidation position after invoking forceReplenish()\n*\n\n",
                "Repair": "\nUse getCreditLimitInternal() rather than getCollateralValueInternal().\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/419#issuecomment-1304650692):\n  I believe this warden may be correct in the fact that we should actually be adding the collateralFactor into the check.\n\n08xmt (Inverse) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/419#issuecomment-1313694712):\n  While increasing debt beyond the Credit limit do risk creating bad debt, this bad debt is owed entirely to the protocol. If one wanted to minimise the amount of bad debt created this way, it would be possible to change the line to getCollateralValueInternal() * (10000 liquidationIncentiveBps) / 10000;, as this would also slightly reduce the amount of bad debt paid out to force replenishers as incentives.\n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/419#issuecomment-1315243835):\n  https://github.com/InverseFinance/FrontierV2/pull/17.\n \n Added a variant of this solution: https://github.com/code-423n4/2022-10-inverse-findings/issues/419#issuecomment-1313694712.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}\n\n\n",
        "CodeNames": [
            "Market.sol",
            "Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-14",
                "Location": [
                    "liquidate()",
                    "getPrice()"
                ],
                "Type": " Two day low oracle used in  Market.liquidate()  makes the system highly at risk in an oracle attack ",
                "Description": "*Submitted by gs8nrv(https://github.com/code-423n4/2022-10-inverse-findings/issues/469), also found by immeas(https://github.com/code-423n4/2022-10-inverse-findings/issues/424), yamapyblack(https://github.com/code-423n4/2022-10-inverse-findings/issues/408), idkwhatimdoing(https://github.com/code-423n4/2022-10-inverse-findings/issues/232), kaden(https://github.com/code-423n4/2022-10-inverse-findings/issues/220), Holmgren(https://github.com/code-423n4/2022-10-inverse-findings/issues/164), and rvierdiiev(https://github.com/code-423n4/2022-10-inverse-findings/issues/89)*\n\n<https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L596<br\n<https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L594<br\n<https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L597<br\n\nUsage of the 2 day low exchange rate when trying to liquidate is highly risky as it incentives even more malicious agents to control the price feed for a short period of time. By controlling shortly the feed, it puts at risk any debt opened for a 2 day period + the collateral released will be overshoot during the liquidation.\n\n\nThe attack can be done by either an attack directly on the feed to push bad data, or in the case of Chainlink manipulating for a short period of time the markets to force an update from Chainlink. Then when either of the attacks has been made the attacker call Oracle.getPrice(). It then gives a 2 day period to the attacker (and any other agent who wants to liquidate) to liquidate any escrow.\n\nThis has a second drawback, we see that we use the same value at line 596, which is used to compute the liquidator reward (l.597), leading to more collateral released than expected. For instance manipulating once the feed and bring the ETH/USD rate to 20 instead of 2000, liquidator will earn 100 more than he should have had.\n\n",
                "Repair": "\nInstead of using the 2 day lowest price during the liquidation, the team could either take the current oracle price, while still using the 2 day period for any direct agent interaction to minimise attacks both from users side and liquidators side.\n\n0xean (judge) decreased severity to Medium(https://github.com/code-423n4/2022-10-inverse-findings/issues/469#issuecomment-1338401236)\n\n08xmt (Inverse) disputed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/469#issuecomment-1351441640):\n  The debt is not more at risk than through normal oracle manipulation. The oracle will return the normalized price if it's lower than the dampened two-day low, meaning oracle manipulations can always be used for bad liquidations.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}\n\n\n",
        "CodeNames": [
            "Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-15",
                "Location": [
                    "tokenDecimals",
                    "feedDecimals"
                ],
                "Type": " Oracle assumes token and feed decimals will be limited to 18 decimals",
                "Description": "*Submitted by adriro(https://github.com/code-423n4/2022-10-inverse-findings/issues/533), also found by pashov(https://github.com/code-423n4/2022-10-inverse-findings/issues/562), sorrynotsorry(https://github.com/code-423n4/2022-10-inverse-findings/issues/550), neumo(https://github.com/code-423n4/2022-10-inverse-findings/issues/540), Chom(https://github.com/code-423n4/2022-10-inverse-findings/issues/448), CertoraInc(https://github.com/code-423n4/2022-10-inverse-findings/issues/361), Ruhum(https://github.com/code-423n4/2022-10-inverse-findings/issues/306), eierina(https://github.com/code-423n4/2022-10-inverse-findings/issues/285), Lambda(https://github.com/code-423n4/2022-10-inverse-findings/issues/207), RaoulSchaffranek(https://github.com/code-423n4/2022-10-inverse-findings/issues/148), cryptphi(https://github.com/code-423n4/2022-10-inverse-findings/issues/135), codexploder(https://github.com/code-423n4/2022-10-inverse-findings/issues/118), BClabs(https://github.com/code-423n4/2022-10-inverse-findings/issues/109), 8olidity(https://github.com/code-423n4/2022-10-inverse-findings/issues/94), and joestakey(https://github.com/code-423n4/2022-10-inverse-findings/issues/90)*\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L87<br\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L121<br\n\nThe Oracle contract normalizes prices in both viewPrices and getPrices functions to adjust for potential decimal differences between feed and token decimals and the expected return value.\n\nHowever these functions assume that feedDecimals and tokenDecimals won't exceed 18 since the normalization calculation is 36 feedDecimals tokenDecimals, or that at worst case the sum of both won't exceed 36.\n\nThis assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but may cause an overflow (and a revert) for the general case, rendering the Oracle useless in these cases.\n\n\nIf feedDecimals + tokenDecimals  36 then the expression 36 feedDecimals tokenDecimals will be negative and (due to Solidity 0.8 default checked math) will cause a revert.\n\n",
                "Repair": "\nIn case feedDecimals + tokenDecimals exceeds 36, then the proper normalization procedure would be to divide the price by 10  decimals. Something like this:\n\n    uint normalizedPrice;\n\n    if (feedDecimals + tokenDecimals  36) {\n        uint decimals = feedDecimals + tokenDecimals 36;\n        normalizedPrice = price / (10  decimals)\n    } else {\n        uint8 decimals = 36 feedDecimals tokenDecimals;\n        normalizedPrice = price * (10  decimals);\n    }\n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/533#issuecomment-1351469171):\n  Fixed in https://github.com/InverseFinance/FrontierV2/pull/25<br\n Also pretty sure this is a dupe\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/**\n@title Dola Borrow Rights\n@notice The DolaBorrowRights contract is a non-standard ERC20 token, that gives the right of holders to borrow DOLA at 0% interest.\n As a borrower takes on DOLA debt, their DBR balance will be exhausted at 1 DBR per 1 DOLA borrowed per year.\n*/\ncontract DolaBorrowingRights {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public _totalSupply;\n    address public operator;\n    address public pendingOperator;\n    uint public totalDueTokensAccrued;\n    uint public replenishmentPriceBps;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    mapping (address => bool) public minters;\n    mapping (address => bool) public markets;\n    mapping (address => uint) public debts; // user => debt across all tracked markets\n    mapping (address => uint) public dueTokensAccrued; // user => amount of due tokens accrued\n    mapping (address => uint) public lastUpdated; // user => last update timestamp\n\n    constructor(\n        uint _replenishmentPriceBps,\n        string memory _name,\n        string memory _symbol,\n        address _operator\n    ) {\n        replenishmentPriceBps = _replenishmentPriceBps;\n        name = _name;\n        symbol = _symbol;\n        operator = _operator;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n    @param newOperator_ The address of the newOperator\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator {\n        pendingOperator = newOperator_;\n    }\n\n    /**\n    @notice Sets the replenishment price in basis points. Replenishment price denotes the increase in DOLA debt upon forced replenishments.\n     At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n    @param newReplenishmentPriceBps_ The new replen\n    */\n    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n        require(newReplenishmentPriceBps_ > 0, \"replenishment price must be over 0\");\n        replenishmentPriceBps = newReplenishmentPriceBps_;\n    }\n    \n    /**\n    @notice claims the Operator role if set as pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address of the new minter.\n    */\n    function addMinter(address minter_) public onlyOperator {\n        minters[minter_] = true;\n        emit AddMinter(minter_);\n    }\n\n    /**\n    @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address to be removed from the minter set.\n    */\n    function removeMinter(address minter_) public onlyOperator {\n        minters[minter_] = false;\n        emit RemoveMinter(minter_);\n    }\n    /**\n    @notice Adds a market to the set of active markets. Only callable by Operator.\n    @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n    @param market_ The address of the new market contract to be added.\n    */\n    function addMarket(address market_) public onlyOperator {\n        markets[market_] = true;\n        emit AddMarket(market_);\n    }\n\n    /**\n    @notice Get the total supply of DBR tokens.\n    @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n    @return uint representing the total supply of DBR.\n    */\n    function totalSupply() public view returns (uint) {\n        if(totalDueTokensAccrued > _totalSupply) return 0;\n        return _totalSupply - totalDueTokensAccrued;\n    }\n\n    /**\n    @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n    @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n    @param user Address of the user.\n    @return uint representing the balance of the user.\n    */\n    function balanceOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued > balances[user]) return 0;\n        return balances[user] - dueTokensAccrued[user] - accrued;\n    }\n\n    /**\n    @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n    @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n    @param user Address of the user.\n    @return uint representing the deficit of the user.\n    */\n    function deficitOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n        return dueTokensAccrued[user] + accrued - balances[user];\n    }\n    \n    /**\n    @notice Get the signed DBR balance of an address.\n    @dev This function will revert if a user has a balance of more than 2^255-1 DBR\n    @param user Address of the user.\n    @return Returns a signed int of the user's balance\n    */\n    function signedBalanceOf(address user) public view returns (int) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        return int(balances[user]) - int(dueTokensAccrued[user]) - int(accrued);\n    }\n\n    /**\n    @notice Approves spender to spend amount of DBR on behalf of the message sender.\n    @param spender Address of the spender to be approved\n    @param amount Amount to be approved to spend\n    @return Always returns true, will revert if not successful.\n    */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfers amount to address to from message sender.\n    @param to The address to transfer to\n    @param amount The amount of DBR to transfer\n    @return Always returns true, will revert if not successful.\n    */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfer amount of DBR  on behalf of address from to address to. Message sender must have a sufficient allowance from the from address.\n    @dev Allowance is reduced by the amount transferred.\n    @param from Address to transfer from.\n    @param to Address to transfer to.\n    @param amount Amount of DBR to transfer.\n    @return Always returns true, will revert if not successful.\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Permits an address to spend on behalf of another address via a signed message.\n    @dev Can be bundled with a transferFrom call, to reduce transaction load on users.\n    @param owner Address of the owner permitting the spending\n    @param spender Address allowed to spend on behalf of owner.\n    @param value Amount to be allowed to spend.\n    @param deadline Timestamp after which the signed message is no longer valid.\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n    @notice Function for invalidating the nonce of a signed message.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice Accrue due DBR debt of user\n    @dev DBR debt is accrued at a rate of 1 DBR per 1 DOLA of debt per year.\n    @param user The address of the user to accrue DBR debt to.\n    */\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n\n    /**\n    @notice Function to be called by markets when a borrow occurs.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt.\n    @param user The address of the borrower\n    @param additionalDebt The additional amount of DOLA the user is borrowing\n    */\n    function onBorrow(address user, uint additionalDebt) public {\n        require(markets[msg.sender], \"Only markets can call onBorrow\");\n        accrueDueTokens(user);\n        require(deficitOf(user) == 0, \"DBR Deficit\");\n        debts[user] += additionalDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a repayment occurs.\n    @dev Accrues due tokens on behalf of the user, before reducing their debt.\n    @param user The address of the borrower having their debt repaid\n    @param repaidDebt The amount of DOLA repaid\n    */\n    function onRepay(address user, uint repaidDebt) public {\n        require(markets[msg.sender], \"Only markets can call onRepay\");\n        accrueDueTokens(user);\n        debts[user] -= repaidDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a force replenish occurs. This function can only be called if the user has a DBR deficit.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt by the replenishment price and minting them new DBR.\n    @param user The user to be force replenished.\n    @param amount The amount of DBR the user will be force replenished.\n    */\n    function onForceReplenish(address user, uint amount) public {\n        require(markets[msg.sender], \"Only markets can call onForceReplenish\");\n        uint deficit = deficitOf(user);\n        require(deficit > 0, \"No deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n        accrueDueTokens(user);\n        debts[user] += replenishmentCost;\n        _mint(user, amount);\n    }\n\n    /**\n    @notice Function for burning DBR from message sender, reducing supply.\n    @param amount Amount to be burned\n    */\n    function burn(uint amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n    @notice Function for minting new DBR, increasing supply. Only callable by minters and the operator.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function mint(address to, uint amount) public {\n        require(minters[msg.sender] == true || msg.sender == operator, \"ONLY MINTERS OR OPERATOR\");\n        _mint(to, amount);\n    }\n\n    /**\n    @notice Internal function for minting DBR.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n    @notice Internal function for burning DBR.\n    @param from Address to burn DBR from.\n    @param amount Amount of DBR to be burned.\n    */\n    function _burn(address from, uint256 amount) internal virtual {\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            _totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event AddMinter(address indexed minter);\n    event RemoveMinter(address indexed minter);\n    event AddMarket(address indexed market);\n    event ChangeOperator(address indexed newOperator);\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}\n\n\n",
        "CodeNames": [
            "DBR.sol",
            "demo.sol",
            "Market.sol",
            "Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-17",
                "Location": [
                    "//solidity\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token]  0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price  0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 feedDecimals tokenDecimals;\n            uint normalizedPrice = price * (10  decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow  yesterdaysLow && yesterdaysLow  0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow  0 && newBorrowingPower  twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n",
                    "//solidity\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token]  0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price  0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 feedDecimals tokenDecimals;\n            uint normalizedPrice = price * (10  decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow  yesterdaysLow && yesterdaysLow  0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow  0 && newBorrowingPower  twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n",
                    "//solidity\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n",
                    "//solidity\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n",
                    "//solidity\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance minimumCollateral;\n    }\n"
                ],
                "Type": " Chainlink oracle data feed is not sufficiently validated and can return stale  price ",
                "Description": "*Submitted by rbserver(https://github.com/code-423n4/2022-10-inverse-findings/issues/584), also found by d3e4(https://github.com/code-423n4/2022-10-inverse-findings/issues/601), TomJ(https://github.com/code-423n4/2022-10-inverse-findings/issues/573), pashov(https://github.com/code-423n4/2022-10-inverse-findings/issues/565), sorrynotsorry(https://github.com/code-423n4/2022-10-inverse-findings/issues/547), Aymen0909(https://github.com/code-423n4/2022-10-inverse-findings/issues/545), c7e7eff(https://github.com/code-423n4/2022-10-inverse-findings/issues/537), horsefacts(https://github.com/code-423n4/2022-10-inverse-findings/issues/530), pedroais(https://github.com/code-423n4/2022-10-inverse-findings/issues/529), minhtrng(https://github.com/code-423n4/2022-10-inverse-findings/issues/512), dipp(https://github.com/code-423n4/2022-10-inverse-findings/issues/481), 0xc0ffEE(https://github.com/code-423n4/2022-10-inverse-findings/issues/458), Chom(https://github.com/code-423n4/2022-10-inverse-findings/issues/455), immeas(https://github.com/code-423n4/2022-10-inverse-findings/issues/435), imare(https://github.com/code-423n4/2022-10-inverse-findings/issues/431), Olivierdem(https://github.com/code-423n4/2022-10-inverse-findings/issues/426), Jeiwan(https://github.com/code-423n4/2022-10-inverse-findings/issues/403), cccz(https://github.com/code-423n4/2022-10-inverse-findings/issues/400), hansfriese(https://github.com/code-423n4/2022-10-inverse-findings/issues/397), bin2chen(https://github.com/code-423n4/2022-10-inverse-findings/issues/384), elprofesor(https://github.com/code-423n4/2022-10-inverse-findings/issues/383), __141345__(https://github.com/code-423n4/2022-10-inverse-findings/issues/350), tonisives(https://github.com/code-423n4/2022-10-inverse-findings/issues/339), catchup(https://github.com/code-423n4/2022-10-inverse-findings/issues/337), 0xNazgul(https://github.com/code-423n4/2022-10-inverse-findings/issues/299), Rolezn(https://github.com/code-423n4/2022-10-inverse-findings/issues/284), Ruhum(https://github.com/code-423n4/2022-10-inverse-findings/issues/276), Franfran(https://github.com/code-423n4/2022-10-inverse-findings/issues/260), Wawrdog(https://github.com/code-423n4/2022-10-inverse-findings/issues/258), idkwhatimdoing(https://github.com/code-423n4/2022-10-inverse-findings/issues/231), carlitox477(https://github.com/code-423n4/2022-10-inverse-findings/issues/217), Lambda(https://github.com/code-423n4/2022-10-inverse-findings/issues/205), peanuts(https://github.com/code-423n4/2022-10-inverse-findings/issues/197), saneryee(https://github.com/code-423n4/2022-10-inverse-findings/issues/196), djxploit(https://github.com/code-423n4/2022-10-inverse-findings/issues/193), eierina(https://github.com/code-423n4/2022-10-inverse-findings/issues/189), cuteboiz(https://github.com/code-423n4/2022-10-inverse-findings/issues/181), martin(https://github.com/code-423n4/2022-10-inverse-findings/issues/162), M4TZ1P(https://github.com/code-423n4/2022-10-inverse-findings/issues/153), Jujic(https://github.com/code-423n4/2022-10-inverse-findings/issues/151), rokinot(https://github.com/code-423n4/2022-10-inverse-findings/issues/140), ladboy233(https://github.com/code-423n4/2022-10-inverse-findings/issues/131), codexploder(https://github.com/code-423n4/2022-10-inverse-findings/issues/116), 0x1f8b(https://github.com/code-423n4/2022-10-inverse-findings/issues/97), joestakey(https://github.com/code-423n4/2022-10-inverse-findings/issues/92), leosathya(https://github.com/code-423n4/2022-10-inverse-findings/issues/68), rvierdiiev(https://github.com/code-423n4/2022-10-inverse-findings/issues/45), and 8olidity(https://github.com/code-423n4/2022-10-inverse-findings/issues/39)*\n\nCalling the Oracle contract's viewPrice or getPrice function executes uint price = feeds[token].feed.latestAnswer() and require(price  0, \"Invalid feed price\"). Besides that Chainlink's latestAnswer function is deprecated, only verifying that price  0 is true is also not enough to guarantee that the returned price is not stale. Using a stale price can cause the calculations for the credit and withdrawal limits to be inaccurate, which, for example, can mistakenly consider a user's debt to be under water and unexpectedly allow the user's debt to be liquidated.\n\nTo avoid using a stale answer returned by the Chainlink oracle data feed, according to Chainlink's documentation(https://docs.chain.link/docs/historical-price-data):\n\n1.  The latestRoundData function can be used instead of the deprecated latestAnswer function.\n2.  roundId and answeredInRound are also returned. \"You can check answeredInRound against the current roundId. If answeredInRound is less than roundId, the answer is being carried over. If answeredInRound is equal to roundId, then the answer is fresh.\"\n3.  \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105\n\nsolidity\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token]  0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price  0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 feedDecimals tokenDecimals;\n            uint normalizedPrice = price * (10  decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow  yesterdaysLow && yesterdaysLow  0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow  0 && newBorrowingPower  twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144\n\nsolidity\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token]  0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price  0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 feedDecimals tokenDecimals;\n            uint normalizedPrice = price * (10  decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow  yesterdaysLow && yesterdaysLow  0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow  0 && newBorrowingPower  twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347\n\nsolidity\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327\n\nsolidity\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363\n\nsolidity\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance minimumCollateral;\n    }\n\n\n\nThe following steps can occur for the described scenario.\n\n1.  Alice calls the depositAndBorrow function to deposit some WETH as the collateral and borrows some DOLA against the collateral.\n2.  Bob calls the liquidate function for trying to liquidate Alice's debt. Because the Chainlink oracle data feed returns an up-to-date price at this moment, the getCreditLimitInternal function calculates Alice's credit limit accurately, which does not cause Alice's debt to be under water. Hence, Bob's liquidate transaction reverts.\n3.  After some time, Bob calls the liquidate function again for trying to liquidate Alice's debt. This time, because the Chainlink oracle data feed returns a positive but stale price, the getCreditLimitInternal function calculates Alice's credit limit inaccurately, which mistakenly causes Alice's debt to be under water.\n4.  Bob's liquidate transaction is executed successfully so he gains some of Alice's WETH collateral. Alice loses such WETH collateral amount unexpectedly because her debt should not be considered as under water if the stale price was not used.\n\n\nVSCode\n\n",
                "Repair": "\nOracle.sol#L82-L83(https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L82-L83) and Oracle.sol#L116-L117(https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L116-L117) can be updated to the following code.\n\nsolidity\n            (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = feeds[token].feed.latestRoundData();\n            require(answeredInRound = roundId, \"answer is stale\");\n            require(updatedAt  0, \"round is incomplete\");\n            require(answer  0, \"Invalid feed answer\");\n\n            uint256 price = uint256(answer);\n\n\n08xmt (Inverse) confirmed and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/584#issuecomment-1351486543):\n  Fixed in https://github.com/InverseFinance/FrontierV2/pull/19\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/**\n@title Borrow Controller\n@notice Contract for limiting the contracts that are allowed to interact with markets\n*/\ncontract BorrowController {\n    \n    address public operator;\n    mapping(address => bool) public contractAllowlist;\n\n    constructor(address _operator) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"Only operator\");\n        _;\n    }\n    \n    /**\n    @notice Sets the operator of the borrow controller. Only callable by the operator.\n    @param _operator The address of the new operator.\n    */\n    function setOperator(address _operator) public onlyOperator { operator = _operator; }\n\n    /**\n    @notice Allows a contract to use the associated market.\n    @param allowedContract The address of the allowed contract\n    */\n    function allow(address allowedContract) public onlyOperator { contractAllowlist[allowedContract] = true; }\n\n    /**\n    @notice Denies a contract to use the associated market\n    @param deniedContract The addres of the denied contract\n    */\n    function deny(address deniedContract) public onlyOperator { contractAllowlist[deniedContract] = false; }\n\n    /**\n    @notice Checks if a borrow is allowed\n    @dev Currently the borrowController only checks if contracts are part of an allow list\n    @param msgSender The message sender trying to borrow\n    @return A boolean that is true if borrowing is allowed and false if not.\n    */\n    function borrowAllowed(address msgSender, address, uint) public view returns (bool) {\n        if(msgSender == tx.origin) return true;\n        return contractAllowlist[msgSender];\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IMarket {\n    function recall(uint amount) external;\n    function totalDebt() external view returns (uint);\n    function borrowPaused() external view returns (bool);\n}\n\ninterface IDola {\n    function mint(address to, uint amount) external;\n    function burn(uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function transfer(address to, uint amount) external returns (bool);\n}\n\ninterface IDBR {\n    function markets(address) external view returns (bool);\n}\n\n/**\n@title The Market Fed\n@notice Feds are a class of contracts in the Inverse Finance ecosystem responsible for minting and burning DOLA.\n This specific Fed can expand DOLA supply into markets and contract DOLA supply from markets.\n*/\ncontract Fed {\n\n    IDBR public immutable dbr;\n    IDola public immutable dola;\n    address public gov;\n    address public chair;\n    uint public supplyCeiling;\n    uint public globalSupply;\n    mapping (IMarket => uint) public supplies;\n\n    constructor (IDBR _dbr, IDola _dola, address _gov, address _chair, uint _supplyCeiling) {\n        dbr = _dbr;\n        dola = _dola;\n        gov = _gov;\n        chair = _chair;\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Change the governance of the Fed contact. Only callable by governance.\n    @param _gov The address of the new governance contract\n    */\n    function changeGov(address _gov) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        gov = _gov;\n    }\n\n    /**\n    @notice Set the supply ceiling of the Fed. Only callable by governance.\n    @param _supplyCeiling Amount to set the supply ceiling to\n    */\n    function changeSupplyCeiling(uint _supplyCeiling) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Set the chair of the fed. Only callable by governance.\n    @param _chair Address of the new chair.\n    */\n    function changeChair(address _chair) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        chair = _chair;\n    }\n\n    /**\n    @notice Set the address of the chair to the 0 address. Only callable by the chair.\n    @dev Useful for immediately removing chair powers in case of a wallet compromise.\n    */\n    function resign() public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        chair = address(0);\n    }\n\n    /**\n    @notice Expand the amount of DOLA by depositing the amount into a specific market.\n    @dev While not immediately dangerous to the DOLA peg, make sure the market can absorb the new potential supply.\n    @param market The market to add additional DOLA supply to.\n    @param amount The amount of DOLA to mint and supply to the market.\n    */\n    function expansion(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        require(market.borrowPaused() != true, \"CANNOT EXPAND PAUSED MARKETS\");\n        dola.mint(address(market), amount);\n        supplies[market] += amount;\n        globalSupply += amount;\n        require(globalSupply <= supplyCeiling);\n        emit Expansion(market, amount);\n    }\n\n    /**\n    @notice Contract the amount of DOLA by withdrawing some amount of DOLA from a market, before burning it.\n    @dev Markets can have more DOLA in them than they've been supplied, due to force replenishes. This call will revert if trying to contract more than have been supplied.\n    @param market The market to withdraw DOLA from\n    @param amount The amount of DOLA to withdraw and burn.\n    */\n    function contraction(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        uint supply = supplies[market];\n        require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n        market.recall(amount);\n        dola.burn(amount);\n        supplies[market] -= amount;\n        globalSupply -= amount;\n        emit Contraction(market, amount);\n    }\n\n    /**\n    @notice Gets the profit of a market.\n    @param market The market to withdraw profit from.\n    @return A uint representing the profit of the market.\n    */\n    function getProfit(IMarket market) public view returns (uint) {\n        uint marketValue = dola.balanceOf(address(market)) + market.totalDebt();\n        uint supply = supplies[market];\n        if(supply >= marketValue) return 0;\n        return marketValue - supply;\n    }\n\n    /**\n    @notice Takes profit from a market\n    @param market The market to take profit from.\n    */\n    function takeProfit(IMarket market) public {\n        uint profit = getProfit(market);\n        if(profit > 0) {\n            market.recall(profit);\n            dola.transfer(gov, profit);\n        }\n    }\n\n\n    event Expansion(IMarket indexed market, uint amount);\n    event Contraction(IMarket indexed market, uint amount);\n\n}\n\n\n",
        "CodeNames": [
            "BorrowController.sol",
            "Market.sol",
            "Oracle.sol",
            "Fed.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-18",
                "Location": [
                    "//solidity\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token]  0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price  0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 feedDecimals tokenDecimals;\n            uint normalizedPrice = price * (10  decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow  yesterdaysLow && yesterdaysLow  0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow  0 && newBorrowingPower  twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n",
                    "//solidity\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token]  0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price  0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 feedDecimals tokenDecimals;\n            uint normalizedPrice = price * (10  decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow  yesterdaysLow && yesterdaysLow  0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow  0 && newBorrowingPower  twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n",
                    "//solidity\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n",
                    "//solidity\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n",
                    "//solidity\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance minimumCollateral;\n    }\n"
                ],
                "Type": " Protocol's usability becomes very limited when access to Chainlink oracle data feed is blocked",
                "Description": "*Submitted by rbserver(https://github.com/code-423n4/2022-10-inverse-findings/issues/586)*\n\nBased on the current implementation, when the protocol wants to use Chainlink oracle data feed for getting a collateral token's price, the fixed price for the token should not be set. When the fixed price is not set for the token, calling the Oracle contract's viewPrice or getPrice function will execute uint price = feeds[token].feed.latestAnswer(). As <https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/ mentions, it is possible that Chainlink\u2019s \"multisigs can immediately block access to price feeds at will\". When this occurs, executing feeds[token].feed.latestAnswer() will revert so calling the viewPrice and getPrice functions also revert, which cause denial of service when calling functions like getCollateralValueInternal andgetWithdrawalLimitInternal. The getCollateralValueInternal andgetWithdrawalLimitInternal functions are the key elements to the core functionalities, such as borrowing, withdrawing, force-replenishing, and liquidating; with these functionalities facing DOS, the protocol's usability becomes very limited.\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105\n\nsolidity\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token]  0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price  0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 feedDecimals tokenDecimals;\n            uint normalizedPrice = price * (10  decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow  yesterdaysLow && yesterdaysLow  0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow  0 && newBorrowingPower  twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144\n\nsolidity\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token]  0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price  0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 feedDecimals tokenDecimals;\n            uint normalizedPrice = price * (10  decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow  yesterdaysLow && yesterdaysLow  0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow  0 && newBorrowingPower  twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347\n\nsolidity\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327\n\nsolidity\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363\n\nsolidity\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance minimumCollateral;\n    }\n\n\n\nThe following steps can occur for the described scenario.\n\n1.  Chainlink oracle data feed is used for getting the collateral token's price so the fixed price for the token is not set.\n2.  Alice calls the depositAndBorrow function to deposit some of the collateral token and borrows some DOLA against the collateral.\n3.  Chainlink's multisigs suddenly blocks access to price feeds so executing feeds[token].feed.latestAnswer() will revert.\n4.  Alice tries to borrow more DOLA but calling the borrow function, which eventually executes feeds[token].feed.latestAnswer(), reverts.\n5.  Alice tries to withdraw the deposited collateral but calling the withdraw function, which eventually executes feeds[token].feed.latestAnswer(), reverts.\n6.  Similarly, calling the forceReplenish and liquidate functions would all revert as well.\n\n\nVSCode\n\n",
                "Repair": "\nThe Oracle contract's viewPrice and getPrice functions can be updated to refactor feeds[token].feed.latestAnswer() into try feeds[token].feed.latestAnswer() returns (int256 price) { ... } catch Error(string memory) { ... }. The logic for getting the collateral token's price from the Chainlink oracle data feed should be placed in the try block while some fallback logic when the access to the Chainlink oracle data feed is denied should be placed in the catch block. If getting the fixed price for the collateral token is considered as a fallback logic, then setting the fixed price for the token should become mandatory, which is different from the current implementation. Otherwise, fallback logic for getting the token's price from a fallback oracle is needed.\n\n08xmt (Inverse) acknowledged, but disagreed with severity and commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/586#issuecomment-1313321130):\n  In the unlikely event of a chainlink msig block, the protocol can still recover through the use of governance actions to insert a new feed. I'd consider this a Low Severity, as protocol is only DOS'ed for a short period, and can't be repeatedly DOS'ed.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/586#issuecomment-1329521891):\n  \n  2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n I don't think a Medium requires some amount of time for the DOS to be valid, so I think without a mitigation or fallback in place, this is a valid issue and should qualify as Medium.\n\n08xmt (Inverse) commented(https://github.com/code-423n4/2022-10-inverse-findings/issues/586#issuecomment-1332010534):\n  @0xean That's fair.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 54 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-10-inverse-findings/issues/126) by 0x1f8b received the top score from the judge.\n\n*The following wardens also submitted reports: JC(https://github.com/code-423n4/2022-10-inverse-findings/issues/594), Deivitto(https://github.com/code-423n4/2022-10-inverse-findings/issues/593), rbserver(https://github.com/code-423n4/2022-10-inverse-findings/issues/590), \nd3e4(https://github.com/code-423n4/2022-10-inverse-findings/issues/588), cylzxje(https://github.com/code-423n4/2022-10-inverse-findings/issues/569), \ntnevler(https://github.com/code-423n4/2022-10-inverse-findings/issues/567), c7e7eff(https://github.com/code-423n4/2022-10-inverse-findings/issues/548), \nadriro(https://github.com/code-423n4/2022-10-inverse-findings/issues/536), brgltd(https://github.com/code-423n4/2022-10-inverse-findings/issues/535), \nhorsefacts(https://github.com/code-423n4/2022-10-inverse-findings/issues/531), c3phas(https://github.com/code-423n4/2022-10-inverse-findings/issues/527), \ncryptonue(https://github.com/code-423n4/2022-10-inverse-findings/issues/523), delfin454000(https://github.com/code-423n4/2022-10-inverse-findings/issues/517), \nAymen0909(https://github.com/code-423n4/2022-10-inverse-findings/issues/516), Josiah(https://github.com/code-423n4/2022-10-inverse-findings/issues/513), \nReyAdmirado(https://github.com/code-423n4/2022-10-inverse-findings/issues/498), rotcivegaf(https://github.com/code-423n4/2022-10-inverse-findings/issues/496), \ncducrest(https://github.com/code-423n4/2022-10-inverse-findings/issues/493), robee(https://github.com/code-423n4/2022-10-inverse-findings/issues/491), \ngogo(https://github.com/code-423n4/2022-10-inverse-findings/issues/489), lukris02(https://github.com/code-423n4/2022-10-inverse-findings/issues/486), \nWaze(https://github.com/code-423n4/2022-10-inverse-findings/issues/484), simon135(https://github.com/code-423n4/2022-10-inverse-findings/issues/460), \nenckrish(https://github.com/code-423n4/2022-10-inverse-findings/issues/456), wagmi(https://github.com/code-423n4/2022-10-inverse-findings/issues/452), \nimmeas(https://github.com/code-423n4/2022-10-inverse-findings/issues/444), pedr02b2(https://github.com/code-423n4/2022-10-inverse-findings/issues/413), \nsakshamguruji(https://github.com/code-423n4/2022-10-inverse-findings/issues/406), hansfriese(https://github.com/code-423n4/2022-10-inverse-findings/issues/398), \nElKu(https://github.com/code-423n4/2022-10-inverse-findings/issues/392), neumo(https://github.com/code-423n4/2022-10-inverse-findings/issues/377), \nshark(https://github.com/code-423n4/2022-10-inverse-findings/issues/365), __141345__(https://github.com/code-423n4/2022-10-inverse-findings/issues/345), \ncryptostellar5(https://github.com/code-423n4/2022-10-inverse-findings/issues/321), 0xSmartContract(https://github.com/code-423n4/2022-10-inverse-findings/issues/305), \n0xNazgul(https://github.com/code-423n4/2022-10-inverse-findings/issues/298), trustindistrust(https://github.com/code-423n4/2022-10-inverse-findings/issues/295), \nRolezn(https://github.com/code-423n4/2022-10-inverse-findings/issues/281), oyc_109(https://github.com/code-423n4/2022-10-inverse-findings/issues/257), \ncarlitox477(https://github.com/code-423n4/2022-10-inverse-findings/issues/214), ch0bu(https://github.com/code-423n4/2022-10-inverse-findings/issues/212), \nDiana(https://github.com/code-423n4/2022-10-inverse-findings/issues/186), B2(https://github.com/code-423n4/2022-10-inverse-findings/issues/184), \nevmwanderer(https://github.com/code-423n4/2022-10-inverse-findings/issues/161), aphak5010(https://github.com/code-423n4/2022-10-inverse-findings/issues/108), \nrvierdiiev(https://github.com/code-423n4/2022-10-inverse-findings/issues/99), chrisdior4(https://github.com/code-423n4/2022-10-inverse-findings/issues/72), \nRahoz(https://github.com/code-423n4/2022-10-inverse-findings/issues/46), Bnke0x0(https://github.com/code-423n4/2022-10-inverse-findings/issues/37), \nDinesh11G(https://github.com/code-423n4/2022-10-inverse-findings/issues/33), fatherOfBlocks(https://github.com/code-423n4/2022-10-inverse-findings/issues/27), \nRaymondFam(https://github.com/code-423n4/2022-10-inverse-findings/issues/7), and leosathya(https://github.com/code-423n4/2022-10-inverse-findings/issues/2).*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/**\n@title Dola Borrow Rights\n@notice The DolaBorrowRights contract is a non-standard ERC20 token, that gives the right of holders to borrow DOLA at 0% interest.\n As a borrower takes on DOLA debt, their DBR balance will be exhausted at 1 DBR per 1 DOLA borrowed per year.\n*/\ncontract DolaBorrowingRights {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public _totalSupply;\n    address public operator;\n    address public pendingOperator;\n    uint public totalDueTokensAccrued;\n    uint public replenishmentPriceBps;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    mapping (address => bool) public minters;\n    mapping (address => bool) public markets;\n    mapping (address => uint) public debts; // user => debt across all tracked markets\n    mapping (address => uint) public dueTokensAccrued; // user => amount of due tokens accrued\n    mapping (address => uint) public lastUpdated; // user => last update timestamp\n\n    constructor(\n        uint _replenishmentPriceBps,\n        string memory _name,\n        string memory _symbol,\n        address _operator\n    ) {\n        replenishmentPriceBps = _replenishmentPriceBps;\n        name = _name;\n        symbol = _symbol;\n        operator = _operator;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n    @param newOperator_ The address of the newOperator\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator {\n        pendingOperator = newOperator_;\n    }\n\n    /**\n    @notice Sets the replenishment price in basis points. Replenishment price denotes the increase in DOLA debt upon forced replenishments.\n     At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n    @param newReplenishmentPriceBps_ The new replen\n    */\n    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n        require(newReplenishmentPriceBps_ > 0, \"replenishment price must be over 0\");\n        replenishmentPriceBps = newReplenishmentPriceBps_;\n    }\n    \n    /**\n    @notice claims the Operator role if set as pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address of the new minter.\n    */\n    function addMinter(address minter_) public onlyOperator {\n        minters[minter_] = true;\n        emit AddMinter(minter_);\n    }\n\n    /**\n    @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address to be removed from the minter set.\n    */\n    function removeMinter(address minter_) public onlyOperator {\n        minters[minter_] = false;\n        emit RemoveMinter(minter_);\n    }\n    /**\n    @notice Adds a market to the set of active markets. Only callable by Operator.\n    @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n    @param market_ The address of the new market contract to be added.\n    */\n    function addMarket(address market_) public onlyOperator {\n        markets[market_] = true;\n        emit AddMarket(market_);\n    }\n\n    /**\n    @notice Get the total supply of DBR tokens.\n    @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n    @return uint representing the total supply of DBR.\n    */\n    function totalSupply() public view returns (uint) {\n        if(totalDueTokensAccrued > _totalSupply) return 0;\n        return _totalSupply - totalDueTokensAccrued;\n    }\n\n    /**\n    @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n    @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n    @param user Address of the user.\n    @return uint representing the balance of the user.\n    */\n    function balanceOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued > balances[user]) return 0;\n        return balances[user] - dueTokensAccrued[user] - accrued;\n    }\n\n    /**\n    @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n    @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n    @param user Address of the user.\n    @return uint representing the deficit of the user.\n    */\n    function deficitOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n        return dueTokensAccrued[user] + accrued - balances[user];\n    }\n    \n    /**\n    @notice Get the signed DBR balance of an address.\n    @dev This function will revert if a user has a balance of more than 2^255-1 DBR\n    @param user Address of the user.\n    @return Returns a signed int of the user's balance\n    */\n    function signedBalanceOf(address user) public view returns (int) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        return int(balances[user]) - int(dueTokensAccrued[user]) - int(accrued);\n    }\n\n    /**\n    @notice Approves spender to spend amount of DBR on behalf of the message sender.\n    @param spender Address of the spender to be approved\n    @param amount Amount to be approved to spend\n    @return Always returns true, will revert if not successful.\n    */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfers amount to address to from message sender.\n    @param to The address to transfer to\n    @param amount The amount of DBR to transfer\n    @return Always returns true, will revert if not successful.\n    */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfer amount of DBR  on behalf of address from to address to. Message sender must have a sufficient allowance from the from address.\n    @dev Allowance is reduced by the amount transferred.\n    @param from Address to transfer from.\n    @param to Address to transfer to.\n    @param amount Amount of DBR to transfer.\n    @return Always returns true, will revert if not successful.\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Permits an address to spend on behalf of another address via a signed message.\n    @dev Can be bundled with a transferFrom call, to reduce transaction load on users.\n    @param owner Address of the owner permitting the spending\n    @param spender Address allowed to spend on behalf of owner.\n    @param value Amount to be allowed to spend.\n    @param deadline Timestamp after which the signed message is no longer valid.\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n    @notice Function for invalidating the nonce of a signed message.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice Accrue due DBR debt of user\n    @dev DBR debt is accrued at a rate of 1 DBR per 1 DOLA of debt per year.\n    @param user The address of the user to accrue DBR debt to.\n    */\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n\n    /**\n    @notice Function to be called by markets when a borrow occurs.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt.\n    @param user The address of the borrower\n    @param additionalDebt The additional amount of DOLA the user is borrowing\n    */\n    function onBorrow(address user, uint additionalDebt) public {\n        require(markets[msg.sender], \"Only markets can call onBorrow\");\n        accrueDueTokens(user);\n        require(deficitOf(user) == 0, \"DBR Deficit\");\n        debts[user] += additionalDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a repayment occurs.\n    @dev Accrues due tokens on behalf of the user, before reducing their debt.\n    @param user The address of the borrower having their debt repaid\n    @param repaidDebt The amount of DOLA repaid\n    */\n    function onRepay(address user, uint repaidDebt) public {\n        require(markets[msg.sender], \"Only markets can call onRepay\");\n        accrueDueTokens(user);\n        debts[user] -= repaidDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a force replenish occurs. This function can only be called if the user has a DBR deficit.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt by the replenishment price and minting them new DBR.\n    @param user The user to be force replenished.\n    @param amount The amount of DBR the user will be force replenished.\n    */\n    function onForceReplenish(address user, uint amount) public {\n        require(markets[msg.sender], \"Only markets can call onForceReplenish\");\n        uint deficit = deficitOf(user);\n        require(deficit > 0, \"No deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n        accrueDueTokens(user);\n        debts[user] += replenishmentCost;\n        _mint(user, amount);\n    }\n\n    /**\n    @notice Function for burning DBR from message sender, reducing supply.\n    @param amount Amount to be burned\n    */\n    function burn(uint amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n    @notice Function for minting new DBR, increasing supply. Only callable by minters and the operator.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function mint(address to, uint amount) public {\n        require(minters[msg.sender] == true || msg.sender == operator, \"ONLY MINTERS OR OPERATOR\");\n        _mint(to, amount);\n    }\n\n    /**\n    @notice Internal function for minting DBR.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n    @notice Internal function for burning DBR.\n    @param from Address to burn DBR from.\n    @param amount Amount of DBR to be burned.\n    */\n    function _burn(address from, uint256 amount) internal virtual {\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            _totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event AddMinter(address indexed minter);\n    event RemoveMinter(address indexed minter);\n    event AddMarket(address indexed market);\n    event ChangeOperator(address indexed newOperator);\n}\n\n\n",
        "CodeNames": [
            "DBR.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "1",
                "Location": [
                    "ecrecover()"
                ],
                "Type": " Allows malleable  SECP256K1  signatures",
                "Description": "\nHere, the ecrecover() method doesn't check the s range.\n\nHomestead ([EIP-2(https://eips.ethereum.org/EIPS/eip-2)) added this limitation, however the precompile remained unaltered. The majority of libraries, including OpenZeppelin, do this check.\n\nSince an order can only be confirmed once and its hash is saved, there doesn't seem to be a serious danger in existing use cases.\n\n\n*   <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7201e6707f6631d9499a569f492870ebdd4133cf/contracts/utils/cryptography/ECDSA.sol#L138-L149\n\n\n*   DBR.sol:226-248(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/DBR.sol#L226-L248)\n*   Market.sol:425-447(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L425-L447)\n*   Market.sol:489-511(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L489-L511)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "2",
                "Location": [
                    "js\nrequire(markets[msg.sender], \"Only markets can call onBorrow\");\n"
                ],
                "Type": " Wrong visibility",
                "Description": "\nThe method accrueDueTokens doesn't check that the call is made by a market, and it's public, it should be changed to internal or private to be more resilient.\n\njs\nrequire(markets[msg.sender], \"Only markets can call onBorrow\");\n\n\n\n*   DBR.sol:284(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/DBR.sol#L284)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "3",
                "Location": [],
                "Type": " Avoid using  tx.origin ",
                "Description": "\ntx.origin is a global variable in Solidity that returns the address of the account that sent the transaction.\n\nUsing the variable could make a contract vulnerable if an authorized account calls a malicious contract. You can impersonate a user using a third party contract.\n\nThis can make it easier to create a vault on behalf of another user with an external administrator (by receiving it as an argument).\n\n\n*   BorrowController.sol:47(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/BorrowController.sol#L47)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "9",
                "Location": [],
                "Type": " Lack of checks  supportsInterface ",
                "Description": "\nThe EIP-165 standard helps detect that a smart contract implements the expected logic, prevents human error when configuring smart contract bindings, so it is recommended to check that the received argument is a contract and supports the expected interface.\n\n\n*   <https://eips.ethereum.org/EIPS/eip-165\n\n\n*   DBR.sol:99(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/DBR.sol#L99)\n*   Market.sol:81-83(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L81-L83)\n*   Market.sol:118(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L118)\n*   Market.sol:124(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L124)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "1",
                "Location": [
                    "javascript\n    uint8 feedDecimals = feeds[token].feed.decimals();  // 18 = ETH/DAI] https://rinkeby.etherscan.io/address/0x74825dbc8bf76cc4e9494d0ecb210f676efa001d#readContract\n    uint8 tokenDecimals = feeds[token].tokenDecimals;   //  18\n    uint8 decimals = 36 feedDecimals tokenDecimals; // overflow\n"
                ],
                "Type": " Oracle not compatible with tokens of 19 or more decimals",
                "Description": "\nKeep in mind that the version of solidity used, despite being greater than 0.8, does not prevent integer overflows during casting, it only does so in mathematical operations.\n\nIn the case that feed.decimals() returns 18, and the token is more than 18 decimals, the following subtraction will cause an underflow, denying the oracle service.\n\njavascript\n    uint8 feedDecimals = feeds[token].feed.decimals();  // 18 = ETH/DAI] https://rinkeby.etherscan.io/address/0x74825dbc8bf76cc4e9494d0ecb210f676efa001d#readContract\n    uint8 tokenDecimals = feeds[token].tokenDecimals;   //  18\n    uint8 decimals = 36 feedDecimals tokenDecimals; // overflow\n\n\nAll pairs have 8 decimals except the ETH(https://docs.chain.link/docs/ethereum-addresses) pairs, so a token with 19 decimals in ETH, will fault.\n\n\n*   Oracle.sol:87-98(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L87-L98)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "1",
                "Location": [
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..013960f 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -8,8 +8,8 @@ pragma //solidity ^0.8.13;\n    8,   8: */\n    9,   9: contract DolaBorrowingRights {\n   10,  10: \n 11     :   string public name;\n 12     :   string public symbol;\n+       11:+    bytes32 public immutable name;\n+       12:+    bytes32 public immutable symbol;\n   13,  13:     uint8 public constant decimals = 18;\n   14,  14:     uint256 public _totalSupply;\n   15,  15:     address public operator;\n@@ -34,8 +34,8 @@ contract DolaBorrowingRights {\n   34,  34:         address _operator\n   35,  35:     ) {\n   36,  36:         replenishmentPriceBps = _replenishmentPriceBps;\n 37     :       name = _name;\n 38     :       symbol = _symbol;\n+       37:+        name = bytes32(bytes(_name));\n+       38:+        symbol = bytes32(bytes(_symbol));\n   39,  39:         operator = _operator;\n   40,  40:         INITIAL_CHAIN_ID = block.chainid;\n   41,  41:         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n@@ -268,7 +268,7 @@ contract DolaBorrowingRights {\n  268, 268:             keccak256(\n  269, 269:                 abi.encode(\n  270, 270:                     keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n271     :                   keccak256(bytes(name)),\n+      271:+                    keccak256(bytes.concat(name)),\n  272, 272:                     keccak256(\"1\"),\n  273, 273:                     block.chainid,\n  274, 274:                     address(this)\n"
                ],
                "Type": " State variables only set in the constructor should be declared immutable (2 instances)",
                "Description": "\nDeployment. Gas Saved: 117 275\n\nMinimum Method Call. Gas Saved: 104\n\nAverage Method Call. Gas Saved: 110\n\nMaximum Method Call. Gas Saved: 110\n\nOverall gas change: -678 (-0.723%)\n\nAvoids a Gsset (20000 gas) in the constructor, and replaces each Gwarmacces (100 gas) with a PUSH32 (3 gas).\n\n\nNOTE: name and symbol must be within 32 bytes\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..013960f 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -8,8 +8,8 @@ pragma solidity ^0.8.13;\n    8,   8: */\n    9,   9: contract DolaBorrowingRights {\n   10,  10: \n 11     :   string public name;\n 12     :   string public symbol;\n+       11:+    bytes32 public immutable name;\n+       12:+    bytes32 public immutable symbol;\n   13,  13:     uint8 public constant decimals = 18;\n   14,  14:     uint256 public _totalSupply;\n   15,  15:     address public operator;\n@@ -34,8 +34,8 @@ contract DolaBorrowingRights {\n   34,  34:         address _operator\n   35,  35:     ) {\n   36,  36:         replenishmentPriceBps = _replenishmentPriceBps;\n 37     :       name = _name;\n 38     :       symbol = _symbol;\n+       37:+        name = bytes32(bytes(_name));\n+       38:+        symbol = bytes32(bytes(_symbol));\n   39,  39:         operator = _operator;\n   40,  40:         INITIAL_CHAIN_ID = block.chainid;\n   41,  41:         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n@@ -268,7 +268,7 @@ contract DolaBorrowingRights {\n  268, 268:             keccak256(\n  269, 269:                 abi.encode(\n  270, 270:                     keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n271     :                   keccak256(bytes(name)),\n+      271:+                    keccak256(bytes.concat(name)),\n  272, 272:                     keccak256(\"1\"),\n  273, 273:                     block.chainid,\n  274, 274:                     address(this)\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "2",
                "Location": [
                    "diff\ndiff --git a/src/BorrowController.sol b/src/BorrowController.sol\nindex 6decad1..080a4e3 100644\n--a/src/BorrowController.sol\n+++ b/src/BorrowController.sol\n@@ -14,28 +14,36 @@ contract BorrowController {\n   14,  14:         operator = _operator;\n   15,  15:     }\n   16,  16: \n 17     :   modifier onlyOperator {\n+       17:+    function onlyOperator() private view {\n   18,  18:         require(msg.sender == operator, \"Only operator\");\n 19     :       _;\n   20,  19:     }\n   21,  20:     \n   22,  21:     /\n   23,  22:     @notice Sets the operator of the borrow controller. Only callable by the operator.\n   24,  23:     @param _operator The address of the new operator.\n   25,  24:     */\n 26     :   function setOperator(address _operator) public onlyOperator { operator = _operator; }\n+       25:+    function setOperator(address _operator) public { \n+       26:+        onlyOperator();\n+       27:+        operator = _operator; \n+       28:+    }\n   27,  29: \n   28,  30:     /\n   29,  31:     @notice Allows a contract to use the associated market.\n   30,  32:     @param allowedContract The address of the allowed contract\n   31,  33:     */\n 32     :   function allow(address allowedContract) public onlyOperator { contractAllowlist[allowedContract] = true; }\n+       34:+    function allow(address allowedContract) public { \n+       35:+        onlyOperator();\n+       36:+        contractAllowlist[allowedContract] = true; \n+       37:+    }\n   33,  38: \n   34,  39:     /\n   35,  40:     @notice Denies a contract to use the associated market\n   36,  41:     @param deniedContract The addres of the denied contract\n   37,  42:     */\n 38     :   function deny(address deniedContract) public onlyOperator { contractAllowlist[deniedContract] = false; }\n+       43:+    function deny(address deniedContract) public { \n+       44:+        onlyOperator();\n+       45:+        contractAllowlist[deniedContract] = false; \n+       46:+    }\n   39,  47: \n   40,  48:     /\n   41,  49:     @notice Checks if a borrow is allowed\n",
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..50428cd 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -41,16 +41,16 @@ contract DolaBorrowingRights {\n   41,  41:         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n   42,  42:     }\n   43,  43: \n 44     :   modifier onlyOperator {\n+       44:+    function onlyOperator() private view {\n   45,  45:         require(msg.sender == operator, \"ONLY OPERATOR\");\n 46     :       _;\n   47,  46:     }\n   48,  47:     \n   49,  48:     /\n   50,  49:     @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n   51,  50:     @param newOperator_ The address of the newOperator\n   52,  51:     */\n 53     :   function setPendingOperator(address newOperator_) public onlyOperator {\n+       52:+    function setPendingOperator(address newOperator_) public {\n+       53:+        onlyOperator();\n   54,  54:         pendingOperator = newOperator_;\n   55,  55:     }\n   56,  56: \n@@ -59,7 +59,8 @@ contract DolaBorrowingRights {\n   59,  59:      At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n   60,  60:     @param newReplenishmentPriceBps_ The new replen\n   61,  61:     */\n 62     :   function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n+       62:+    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public {\n+       63:+        onlyOperator();\n   63,  64:         require(newReplenishmentPriceBps_  0, \"replenishment price must be over 0\");\n   64,  65:         replenishmentPriceBps = newReplenishmentPriceBps_;\n   65,  66:     }\n@@ -78,7 +79,8 @@ contract DolaBorrowingRights {\n   78,  79:     @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n   79,  80:     @param minter_ The address of the new minter.\n   80,  81:     */\n 81     :   function addMinter(address minter_) public onlyOperator {\n+       82:+    function addMinter(address minter_) public {\n+       83:+        onlyOperator();\n   82,  84:         minters[minter_] = true;\n   83,  85:         emit AddMinter(minter_);\n   84,  86:     }\n@@ -87,7 +89,8 @@ contract DolaBorrowingRights {\n   87,  89:     @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n   88,  90:     @param minter_ The address to be removed from the minter set.\n   89,  91:     */\n 90     :   function removeMinter(address minter_) public onlyOperator {\n+       92:+    function removeMinter(address minter_) public {\n+       93:+        onlyOperator();\n   91,  94:         minters[minter_] = false;\n   92,  95:         emit RemoveMinter(minter_);\n   93,  96:     }\n@@ -96,7 +99,8 @@ contract DolaBorrowingRights {\n   96,  99:     @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n   97, 100:     @param market_ The address of the new market contract to be added.\n   98, 101:     */\n 99     :   function addMarket(address market_) public onlyOperator {\n+      102:+    function addMarket(address market_) public {\n+      103:+        onlyOperator();\n  100, 104:         markets[market_] = true;\n  101, 105:         emit AddMarket(market_);\n  102, 106:     }\n",
                    "diff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..796d0d0 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -89,9 +89,8 @@ contract Market {\n   89,  89:         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n   90,  90:     }\n   91,  91:     \n 92     :   modifier onlyGov {\n+       92:+    function onlyGov() private view {\n   93,  93:         require(msg.sender == gov, \"Only gov can call this function\");\n 94     :       _;\n   95,  94:     }\n   96,  95: \n   97,  96:     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n@@ -115,38 +114,54 @@ contract Market {\n  115, 114:     @notice sets the oracle to a new oracle. Only callable by governance.\n  116, 115:     @param _oracle The new oracle conforming to the IOracle interface.\n  117, 116:     */\n118     :   function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n+      117:+    function setOracle(IOracle _oracle) public { \n+      118:+        onlyGov();\n+      119:+        oracle = _oracle; \n+      120:+    }\n  119, 121: \n  120, 122:     /\n  121, 123:     @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n  122, 124:     @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n  123, 125:     */\n124     :   function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n+      126:+    function setBorrowController(IBorrowController _borrowController) public { \n+      127:+        onlyGov();\n+      128:+        borrowController = _borrowController; \n+      129:+    }\n  125, 130: \n  126, 131:     /\n  127, 132:     @notice sets the address of governance. Only callable by governance.\n  128, 133:     @param _gov Address of the new governance.\n  129, 134:     */\n130     :   function setGov(address _gov) public onlyGov { gov = _gov; }\n+      135:+    function setGov(address _gov) public { \n+      136:+        onlyGov();\n+      137:+        gov = _gov; \n+      138:+    }\n  131, 139: \n  132, 140:     /\n  133, 141:     @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n  134, 142:     @param _lender Address of the new lender.\n  135, 143:     */\n136     :   function setLender(address _lender) public onlyGov { lender = _lender; }\n+      144:+    function setLender(address _lender) public { \n+      145:+        onlyGov();\n+      146:+        lender = _lender; \n+      147:+    }\n  137, 148: \n  138, 149:     /\n  139, 150:     @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n  140, 151:     @param _pauseGuardian Address of the new pauseGuardian.\n  141, 152:     */\n142     :   function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n+      153:+    function setPauseGuardian(address _pauseGuardian) public { \n+      154:+        onlyGov();\n+      155:+        pauseGuardian = _pauseGuardian; \n+      156:+    }\n  143, 157:     \n  144, 158:     /\n  145, 159:     @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n  146, 160:     @dev Collateral factor mus be set below 100%\n  147, 161:     @param _collateralFactorBps The new collateral factor as measured in basis points. \n  148, 162:     */\n149     :   function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n+      163:+    function setCollateralFactorBps(uint _collateralFactorBps) public  {\n+      164:+        onlyGov();\n  150, 165:         require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n  151, 166:         collateralFactorBps = _collateralFactorBps;\n  152, 167:     }\n@@ -158,7 +173,8 @@ contract Market {\n  158, 173:     @dev Must be set between 1 and 10000.\n  159, 174:     @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n  160, 175:     */\n161     :   function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n+      176:+    function setLiquidationFactorBps(uint _liquidationFactorBps) public  {\n+      177:+        onlyGov();\n  162, 178:         require(_liquidationFactorBps  0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n  163, 179:         liquidationFactorBps = _liquidationFactorBps;\n  164, 180:     }\n@@ -169,7 +185,8 @@ contract Market {\n  169, 185:     @dev Must be set between 1 and 10000.\n  170, 186:     @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n  171, 187:     */\n172     :   function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n+      188:+    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public {\n+      189:+        onlyGov();\n  173, 190:         require(_replenishmentIncentiveBps  0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n  174, 191:         replenishmentIncentiveBps = _replenishmentIncentiveBps;\n  175, 192:     }\n@@ -180,7 +197,8 @@ contract Market {\n  180, 197:     @dev Must be set between 0 and 10000 liquidation fee.\n  181, 198:     @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n  182, 199:     */\n183     :   function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n+      200:+    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public {\n+      201:+        onlyGov();\n  184, 202:         require(_liquidationIncentiveBps  0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n  185, 203:         liquidationIncentiveBps = _liquidationIncentiveBps;\n  186, 204:     }\n@@ -191,7 +209,8 @@ contract Market {\n  191, 209:     @dev Must be set between 0 and 10000 liquidation factor.\n  192, 210:     @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n  193, 211:     */\n194     :   function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n+      212:+    function setLiquidationFeeBps(uint _liquidationFeeBps) public {\n+      213:+        onlyGov();\n  195, 214:         require(_liquidationFeeBps  0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n  196, 215:         liquidationFeeBps = _liquidationFeeBps;\n  197, 216:     }\n",
                    "diff\ndiff --git a/src/Oracle.sol b/src/Oracle.sol\nindex 14338ed..3e7c608 100644\n--a/src/Oracle.sol\n+++ b/src/Oracle.sol\n@@ -32,16 +32,18 @@ contract Oracle {\n   32,  32:         operator = _operator;\n   33,  33:     }\n   34,  34: \n 35     :   modifier onlyOperator {\n+       35:+    function onlyOperator() private view {\n   36,  36:         require(msg.sender == operator, \"ONLY OPERATOR\");\n 37     :       _;\n   38,  37:     }\n   39,  38:     \n   40,  39:     /\n   41,  40:     @notice Sets the pending operator of the oracle. Only callable by operator.\n   42,  41:     @param newOperator_ The address of the pending operator.\n   43,  42:     */\n 44     :   function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n+       43:+    function setPendingOperator(address newOperator_) public { \n+       44:+        onlyOperator();\n+       45:+        pendingOperator = newOperator_; \n+       46:+    }\n   45,  47: \n   46,  48:     /\n   47,  49:     @notice Sets the price feed of a specific token address.\n@@ -50,7 +52,10 @@ contract Oracle {\n   50,  52:     @param feed The chainlink feed of the ERC20 token.\n   51,  53:     @param tokenDecimals uint8 representing the decimal precision of the token\n   52,  54:     */\n 53     :   function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n+       55:+    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public { \n+       56:+        onlyOperator();\n+       57:+        feeds[token] = FeedData(feed, tokenDecimals); \n+       58:+    }\n   54,  59: \n   55,  60:     /\n   56,  61:     @notice Sets a fixed price for a token\n@@ -58,7 +63,10 @@ contract Oracle {\n   58,  63:     @param token The address of the fixed price token\n   59,  64:     @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n   60,  65:     */\n 61     :   function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n+       66:+    function setFixedPrice(address token, uint price) public { \n+       67:+        onlyOperator();\n+       68:+        fixedPrices[token] = price; \n+       69:+    }\n   62,  70: \n   63,  71:     /\n   64,  72:     @notice Claims the operator role. Only successfully callable by the pending operator.\n"
                ],
                "Type": " Use function instead of modifiers (4 instances)",
                "Description": "\nDeployment. Gas Saved: 115 926\n\nMinimum Method Call. Gas Saved: 162\n\nAverage Method Call. Gas Saved: -264\n\nMaximum Method Call. Gas Saved: -481\n\nOverall gas change: 734 (2.459%)\n\n\ndiff\ndiff --git a/src/BorrowController.sol b/src/BorrowController.sol\nindex 6decad1..080a4e3 100644\n--a/src/BorrowController.sol\n+++ b/src/BorrowController.sol\n@@ -14,28 +14,36 @@ contract BorrowController {\n   14,  14:         operator = _operator;\n   15,  15:     }\n   16,  16: \n 17     :   modifier onlyOperator {\n+       17:+    function onlyOperator() private view {\n   18,  18:         require(msg.sender == operator, \"Only operator\");\n 19     :       _;\n   20,  19:     }\n   21,  20:     \n   22,  21:     /\n   23,  22:     @notice Sets the operator of the borrow controller. Only callable by the operator.\n   24,  23:     @param _operator The address of the new operator.\n   25,  24:     */\n 26     :   function setOperator(address _operator) public onlyOperator { operator = _operator; }\n+       25:+    function setOperator(address _operator) public { \n+       26:+        onlyOperator();\n+       27:+        operator = _operator; \n+       28:+    }\n   27,  29: \n   28,  30:     /\n   29,  31:     @notice Allows a contract to use the associated market.\n   30,  32:     @param allowedContract The address of the allowed contract\n   31,  33:     */\n 32     :   function allow(address allowedContract) public onlyOperator { contractAllowlist[allowedContract] = true; }\n+       34:+    function allow(address allowedContract) public { \n+       35:+        onlyOperator();\n+       36:+        contractAllowlist[allowedContract] = true; \n+       37:+    }\n   33,  38: \n   34,  39:     /\n   35,  40:     @notice Denies a contract to use the associated market\n   36,  41:     @param deniedContract The addres of the denied contract\n   37,  42:     */\n 38     :   function deny(address deniedContract) public onlyOperator { contractAllowlist[deniedContract] = false; }\n+       43:+    function deny(address deniedContract) public { \n+       44:+        onlyOperator();\n+       45:+        contractAllowlist[deniedContract] = false; \n+       46:+    }\n   39,  47: \n   40,  48:     /\n   41,  49:     @notice Checks if a borrow is allowed\n\n\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..50428cd 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -41,16 +41,16 @@ contract DolaBorrowingRights {\n   41,  41:         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n   42,  42:     }\n   43,  43: \n 44     :   modifier onlyOperator {\n+       44:+    function onlyOperator() private view {\n   45,  45:         require(msg.sender == operator, \"ONLY OPERATOR\");\n 46     :       _;\n   47,  46:     }\n   48,  47:     \n   49,  48:     /\n   50,  49:     @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n   51,  50:     @param newOperator_ The address of the newOperator\n   52,  51:     */\n 53     :   function setPendingOperator(address newOperator_) public onlyOperator {\n+       52:+    function setPendingOperator(address newOperator_) public {\n+       53:+        onlyOperator();\n   54,  54:         pendingOperator = newOperator_;\n   55,  55:     }\n   56,  56: \n@@ -59,7 +59,8 @@ contract DolaBorrowingRights {\n   59,  59:      At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n   60,  60:     @param newReplenishmentPriceBps_ The new replen\n   61,  61:     */\n 62     :   function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n+       62:+    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public {\n+       63:+        onlyOperator();\n   63,  64:         require(newReplenishmentPriceBps_  0, \"replenishment price must be over 0\");\n   64,  65:         replenishmentPriceBps = newReplenishmentPriceBps_;\n   65,  66:     }\n@@ -78,7 +79,8 @@ contract DolaBorrowingRights {\n   78,  79:     @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n   79,  80:     @param minter_ The address of the new minter.\n   80,  81:     */\n 81     :   function addMinter(address minter_) public onlyOperator {\n+       82:+    function addMinter(address minter_) public {\n+       83:+        onlyOperator();\n   82,  84:         minters[minter_] = true;\n   83,  85:         emit AddMinter(minter_);\n   84,  86:     }\n@@ -87,7 +89,8 @@ contract DolaBorrowingRights {\n   87,  89:     @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n   88,  90:     @param minter_ The address to be removed from the minter set.\n   89,  91:     */\n 90     :   function removeMinter(address minter_) public onlyOperator {\n+       92:+    function removeMinter(address minter_) public {\n+       93:+        onlyOperator();\n   91,  94:         minters[minter_] = false;\n   92,  95:         emit RemoveMinter(minter_);\n   93,  96:     }\n@@ -96,7 +99,8 @@ contract DolaBorrowingRights {\n   96,  99:     @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n   97, 100:     @param market_ The address of the new market contract to be added.\n   98, 101:     */\n 99     :   function addMarket(address market_) public onlyOperator {\n+      102:+    function addMarket(address market_) public {\n+      103:+        onlyOperator();\n  100, 104:         markets[market_] = true;\n  101, 105:         emit AddMarket(market_);\n  102, 106:     }\n\n\n\ndiff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..796d0d0 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -89,9 +89,8 @@ contract Market {\n   89,  89:         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n   90,  90:     }\n   91,  91:     \n 92     :   modifier onlyGov {\n+       92:+    function onlyGov() private view {\n   93,  93:         require(msg.sender == gov, \"Only gov can call this function\");\n 94     :       _;\n   95,  94:     }\n   96,  95: \n   97,  96:     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n@@ -115,38 +114,54 @@ contract Market {\n  115, 114:     @notice sets the oracle to a new oracle. Only callable by governance.\n  116, 115:     @param _oracle The new oracle conforming to the IOracle interface.\n  117, 116:     */\n118     :   function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n+      117:+    function setOracle(IOracle _oracle) public { \n+      118:+        onlyGov();\n+      119:+        oracle = _oracle; \n+      120:+    }\n  119, 121: \n  120, 122:     /\n  121, 123:     @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n  122, 124:     @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n  123, 125:     */\n124     :   function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n+      126:+    function setBorrowController(IBorrowController _borrowController) public { \n+      127:+        onlyGov();\n+      128:+        borrowController = _borrowController; \n+      129:+    }\n  125, 130: \n  126, 131:     /\n  127, 132:     @notice sets the address of governance. Only callable by governance.\n  128, 133:     @param _gov Address of the new governance.\n  129, 134:     */\n130     :   function setGov(address _gov) public onlyGov { gov = _gov; }\n+      135:+    function setGov(address _gov) public { \n+      136:+        onlyGov();\n+      137:+        gov = _gov; \n+      138:+    }\n  131, 139: \n  132, 140:     /\n  133, 141:     @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n  134, 142:     @param _lender Address of the new lender.\n  135, 143:     */\n136     :   function setLender(address _lender) public onlyGov { lender = _lender; }\n+      144:+    function setLender(address _lender) public { \n+      145:+        onlyGov();\n+      146:+        lender = _lender; \n+      147:+    }\n  137, 148: \n  138, 149:     /\n  139, 150:     @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n  140, 151:     @param _pauseGuardian Address of the new pauseGuardian.\n  141, 152:     */\n142     :   function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n+      153:+    function setPauseGuardian(address _pauseGuardian) public { \n+      154:+        onlyGov();\n+      155:+        pauseGuardian = _pauseGuardian; \n+      156:+    }\n  143, 157:     \n  144, 158:     /\n  145, 159:     @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n  146, 160:     @dev Collateral factor mus be set below 100%\n  147, 161:     @param _collateralFactorBps The new collateral factor as measured in basis points. \n  148, 162:     */\n149     :   function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n+      163:+    function setCollateralFactorBps(uint _collateralFactorBps) public  {\n+      164:+        onlyGov();\n  150, 165:         require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n  151, 166:         collateralFactorBps = _collateralFactorBps;\n  152, 167:     }\n@@ -158,7 +173,8 @@ contract Market {\n  158, 173:     @dev Must be set between 1 and 10000.\n  159, 174:     @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n  160, 175:     */\n161     :   function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n+      176:+    function setLiquidationFactorBps(uint _liquidationFactorBps) public  {\n+      177:+        onlyGov();\n  162, 178:         require(_liquidationFactorBps  0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n  163, 179:         liquidationFactorBps = _liquidationFactorBps;\n  164, 180:     }\n@@ -169,7 +185,8 @@ contract Market {\n  169, 185:     @dev Must be set between 1 and 10000.\n  170, 186:     @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n  171, 187:     */\n172     :   function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n+      188:+    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public {\n+      189:+        onlyGov();\n  173, 190:         require(_replenishmentIncentiveBps  0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n  174, 191:         replenishmentIncentiveBps = _replenishmentIncentiveBps;\n  175, 192:     }\n@@ -180,7 +197,8 @@ contract Market {\n  180, 197:     @dev Must be set between 0 and 10000 liquidation fee.\n  181, 198:     @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n  182, 199:     */\n183     :   function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n+      200:+    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public {\n+      201:+        onlyGov();\n  184, 202:         require(_liquidationIncentiveBps  0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n  185, 203:         liquidationIncentiveBps = _liquidationIncentiveBps;\n  186, 204:     }\n@@ -191,7 +209,8 @@ contract Market {\n  191, 209:     @dev Must be set between 0 and 10000 liquidation factor.\n  192, 210:     @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n  193, 211:     */\n194     :   function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n+      212:+    function setLiquidationFeeBps(uint _liquidationFeeBps) public {\n+      213:+        onlyGov();\n  195, 214:         require(_liquidationFeeBps  0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n  196, 215:         liquidationFeeBps = _liquidationFeeBps;\n  197, 216:     }\n\n\n\ndiff\ndiff --git a/src/Oracle.sol b/src/Oracle.sol\nindex 14338ed..3e7c608 100644\n--a/src/Oracle.sol\n+++ b/src/Oracle.sol\n@@ -32,16 +32,18 @@ contract Oracle {\n   32,  32:         operator = _operator;\n   33,  33:     }\n   34,  34: \n 35     :   modifier onlyOperator {\n+       35:+    function onlyOperator() private view {\n   36,  36:         require(msg.sender == operator, \"ONLY OPERATOR\");\n 37     :       _;\n   38,  37:     }\n   39,  38:     \n   40,  39:     /\n   41,  40:     @notice Sets the pending operator of the oracle. Only callable by operator.\n   42,  41:     @param newOperator_ The address of the pending operator.\n   43,  42:     */\n 44     :   function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n+       43:+    function setPendingOperator(address newOperator_) public { \n+       44:+        onlyOperator();\n+       45:+        pendingOperator = newOperator_; \n+       46:+    }\n   45,  47: \n   46,  48:     /\n   47,  49:     @notice Sets the price feed of a specific token address.\n@@ -50,7 +52,10 @@ contract Oracle {\n   50,  52:     @param feed The chainlink feed of the ERC20 token.\n   51,  53:     @param tokenDecimals uint8 representing the decimal precision of the token\n   52,  54:     */\n 53     :   function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n+       55:+    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public { \n+       56:+        onlyOperator();\n+       57:+        feeds[token] = FeedData(feed, tokenDecimals); \n+       58:+    }\n   54,  59: \n   55,  60:     /\n   56,  61:     @notice Sets a fixed price for a token\n@@ -58,7 +63,10 @@ contract Oracle {\n   58,  63:     @param token The address of the fixed price token\n   59,  64:     @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n   60,  65:     */\n 61     :   function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n+       66:+    function setFixedPrice(address token, uint price) public { \n+       67:+        onlyOperator();\n+       68:+        fixedPrices[token] = price; \n+       69:+    }\n   62,  70: \n   63,  71:     /\n   64,  72:     @notice Claims the operator role. Only successfully callable by the pending operator.\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "4",
                "Location": [
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..43db0aa 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -8,6 +8,17 @@ pragma //solidity ^0.8.13;\n    8,   8: */\n    9,   9: contract DolaBorrowingRights {\n   10,  10: \n+       11:+    struct UserInfo {\n+       12:+        uint256 balances;\n+       13:+        \n+       14:+        uint256 nonce;\n+       15:+        uint256 debts;  // user = debt across all tracked markets\n+       16:+        uint256 dueTokensAccrued; // user = amount of due tokens accrued\n+       17:+        uint256 lastUpdated; // user = last update timestamp\n+       18:+    }\n+       19:+    \n+       20:+    mapping(address = mapping(address = uint256)) public allowance;\n+       21:+\n   11,  22:     string public name;\n   12,  23:     string public symbol;\n   13,  24:     uint8 public constant decimals = 18;\n@@ -16,16 +27,11 @@ contract DolaBorrowingRights {\n   16,  27:     address public pendingOperator;\n   17,  28:     uint public totalDueTokensAccrued;\n   18,  29:     uint public replenishmentPriceBps;\n 19     :   mapping(address = uint256) public balances;\n 20     :   mapping(address = mapping(address = uint256)) public allowance;\n+       30:+    mapping(address = UserInfo) public userInfo;\n   21,  31:     uint256 internal immutable INITIAL_CHAIN_ID;\n   22,  32:     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n 23     :   mapping(address = uint256) public nonces;\n   24,  33:     mapping (address = bool) public minters;\n   25,  34:     mapping (address = bool) public markets;\n 26     :   mapping (address = uint) public debts; // user = debt across all tracked markets\n 27     :   mapping (address = uint) public dueTokensAccrued; // user = amount of due tokens accrued\n 28     :   mapping (address = uint) public lastUpdated; // user = last update timestamp\n   29,  35: \n   30,  36:     constructor(\n   31,  37:         uint _replenishmentPriceBps,\n@@ -118,10 +124,10 @@ contract DolaBorrowingRights {\n  118, 124:     @return uint representing the balance of the user.\n  119, 125:     */\n  120, 126:     function balanceOf(address user) public view returns (uint) {\n121     :       uint debt = debts[user];\n122     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n123     :       if(dueTokensAccrued[user] + accrued  balances[user]) return 0;\n124     :       return balances[user] dueTokensAccrued[user] accrued;\n+      127:+        uint debt = userInfo[user].debts;\n+      128:+        uint accrued = (block.timestamp userInfo[user].lastUpdated) * debt / 365 days;\n+      129:+        if(userInfo[user].dueTokensAccrued + accrued  userInfo[user].balances) return 0;\n+      130:+        return userInfo[user].balances userInfo[user].dueTokensAccrued accrued;\n  125, 131:     }\n  126, 132: \n  127, 133:     /\n@@ -131,10 +137,10 @@ contract DolaBorrowingRights {\n  131, 137:     @return uint representing the deficit of the user.\n  132, 138:     */\n  133, 139:     function deficitOf(address user) public view returns (uint) {\n134     :       uint debt = debts[user];\n135     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n136     :       if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n137     :       return dueTokensAccrued[user] + accrued balances[user];\n+      140:+        uint debt = userInfo[user].debts;\n+      141:+        uint accrued = (block.timestamp userInfo[user].lastUpdated) * debt / 365 days;\n+      142:+        if(userInfo[user].dueTokensAccrued + accrued < userInfo[user].balances) return 0;\n+      143:+        return userInfo[user].dueTokensAccrued + accrued userInfo[user].balances;\n  138, 144:     }\n  139, 145:     \n  140, 146:     /\n@@ -144,9 +150,9 @@ contract DolaBorrowingRights {\n  144, 150:     @return Returns a signed int of the user's balance\n  145, 151:     */\n  146, 152:     function signedBalanceOf(address user) public view returns (int) {\n147     :       uint debt = debts[user];\n148     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n149     :       return int(balances[user]) int(dueTokensAccrued[user]) int(accrued);\n+      153:+        uint debt = userInfo[user].debts;\n+      154:+        uint accrued = (block.timestamp userInfo[user].lastUpdated) * debt / 365 days;\n+      155:+        return int(userInfo[user].balances) int(userInfo[user].dueTokensAccrued) int(accrued);\n  150, 156:     }\n  151, 157: \n  152, 158:     /\n@@ -169,9 +175,9 @@ contract DolaBorrowingRights {\n  169, 175:     */\n  170, 176:     function transfer(address to, uint256 amount) public virtual returns (bool) {\n  171, 177:         require(balanceOf(msg.sender) = amount, \"Insufficient balance\");\n172     :       balances[msg.sender] -= amount;\n+      178:+        userInfo[msg.sender].balances -= amount;\n  173, 179:         unchecked {\n174     :           balances[to] += amount;\n+      180:+            userInfo[to].balances += amount;\n  175, 181:         }\n  176, 182:         emit Transfer(msg.sender, to, amount);\n  177, 183:         return true;\n@@ -193,9 +199,9 @@ contract DolaBorrowingRights {\n  193, 199:         uint256 allowed = allowance[from][msg.sender];\n  194, 200:         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed amount;\n  195, 201:         require(balanceOf(from) = amount, \"Insufficient balance\");\n196     :       balances[from] -= amount;\n+      202:+        userInfo[from].balances -= amount;\n  197, 203:         unchecked {\n198     :           balances[to] += amount;\n+      204:+            userInfo[to].balances += amount;\n  199, 205:         }\n  200, 206:         emit Transfer(from, to, amount);\n  201, 207:         return true;\n@@ -236,7 +242,7 @@ contract DolaBorrowingRights {\n  236, 242:                                 owner,\n  237, 243:                                 spender,\n  238, 244:                                 value,\n239     :                               nonces[owner]++,\n+      245:+                                userInfo[owner].nonce++,\n  240, 246:                                 deadline\n  241, 247:                             )\n  242, 248:                         )\n@@ -256,7 +262,7 @@ contract DolaBorrowingRights {\n  256, 262:     @notice Function for invalidating the nonce of a signed message.\n  257, 263:     */\n  258, 264:     function invalidateNonce() public {\n259     :       nonces[msg.sender]++;\n+      265:+        userInfo[msg.sender].nonce++;\n  260, 266:     }\n  261, 267: \n  262, 268:     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n@@ -282,12 +288,12 @@ contract DolaBorrowingRights {\n  282, 288:     @param user The address of the user to accrue DBR debt to.\n  283, 289:     */\n  284, 290:     function accrueDueTokens(address user) public {\n285     :       uint debt = debts[user];\n286     :       if(lastUpdated[user] == block.timestamp) return;\n287     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n288     :       dueTokensAccrued[user] += accrued;\n+      291:+        uint debt = userInfo[user].debts;\n+      292:+        if(userInfo[user].lastUpdated == block.timestamp) return;\n+      293:+        uint accrued = (block.timestamp userInfo[user].lastUpdated) * debt / 365 days;\n+      294:+        userInfo[user].dueTokensAccrued += accrued;\n  289, 295:         totalDueTokensAccrued += accrued;\n290     :       lastUpdated[user] = block.timestamp;\n+      296:+        userInfo[user].lastUpdated = block.timestamp;\n  291, 297:         emit Transfer(user, address(0), accrued);\n  292, 298:     }\n  293, 299: \n@@ -301,7 +307,7 @@ contract DolaBorrowingRights {\n  301, 307:         require(markets[msg.sender], \"Only markets can call onBorrow\");\n  302, 308:         accrueDueTokens(user);\n  303, 309:         require(deficitOf(user) == 0, \"DBR Deficit\");\n304     :       debts[user] += additionalDebt;\n+      310:+        userInfo[user].debts += additionalDebt;\n  305, 311:     }\n  306, 312: \n  307, 313:     /\n@@ -313,7 +319,7 @@ contract DolaBorrowingRights {\n  313, 319:     function onRepay(address user, uint repaidDebt) public {\n  314, 320:         require(markets[msg.sender], \"Only markets can call onRepay\");\n  315, 321:         accrueDueTokens(user);\n316     :       debts[user] -= repaidDebt;\n+      322:+        userInfo[user].debts -= repaidDebt;\n  317, 323:     }\n  318, 324: \n  319, 325:     /\n@@ -329,7 +335,7 @@ contract DolaBorrowingRights {\n  329, 335:         require(deficit = amount, \"Amount  deficit\");\n  330, 336:         uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n  331, 337:         accrueDueTokens(user);\n332     :       debts[user] += replenishmentCost;\n+      338:+        userInfo[user].debts += replenishmentCost;\n  333, 339:         _mint(user, amount);\n  334, 340:     }\n  335, 341: \n@@ -359,7 +365,7 @@ contract DolaBorrowingRights {\n  359, 365:     function _mint(address to, uint256 amount) internal virtual {\n  360, 366:         _totalSupply += amount;\n  361, 367:         unchecked {\n362     :           balances[to] += amount;\n+      368:+            userInfo[to].balances += amount;\n  363, 369:         }\n  364, 370:         emit Transfer(address(0), to, amount);\n  365, 371:     }\n@@ -371,7 +377,7 @@ contract DolaBorrowingRights {\n  371, 377:     */\n  372, 378:     function _burn(address from, uint256 amount) internal virtual {\n  373, 379:         require(balanceOf(from) = amount, \"Insufficient balance\");\n374     :       balances[from] -= amount;\n+      380:+        userInfo[from].balances -= amount;\n  375, 381:         unchecked {\n  376, 382:             _totalSupply -= amount;\n  377, 383:         }\ndiff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol\nindex 3988cf7..754bf7f 100644\n--a/src/test/DBR.t.sol\n+++ b/src/test/DBR.t.sol\n@@ -145,17 +145,19 @@ contract DBRTest is FiRMTest {\n  145, 145:     }\n  146, 146: \n  147, 147:     function test_invalidateNonce() public {\n148     :       assertEq(dbr.nonces(user), 0, \"User nonce should be uninitialized\");\n+      148:+        (, uint256 nonce,,,) = dbr.userInfo(user);\n+      149:+        assertEq(nonce, 0, \"User nonce should be uninitialized\");\n  149, 150: \n  150, 151:         vm.startPrank(user);\n  151, 152:         dbr.invalidateNonce();\n  152, 153: \n153     :       assertEq(dbr.nonces(user), 1, \"User nonce was not invalidated\");\n+      154:+        (,nonce,,,) = dbr.userInfo(user);\n+      155:+        assertEq(nonce, 1, \"User nonce was not invalidated\");\n  154, 156:     }\n  155, 157: \n  156, 158:     function test_approve_increasesAllowanceByAmount() public {\n  157, 159:         uint amount = 100e18;\n158     :-\n+      160:+        \n  159, 161:         assertEq(dbr.allowance(user, gov), 0, \"Allowance should not be set yet\");\n  160, 162: \n  161, 163:         vm.startPrank(user);\n"
                ],
                "Type": " Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate (5 instances)",
                "Description": "\nDeployment. Gas Saved: 24 227\n\nMinimum Method Call. Gas Saved: 254\n\nAverage Method Call. Gas Saved: 533\n\nMaximum Method Call. Gas Saved: -6 726\n\nOverall gas change: -1 371 (20.741%)\n\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 30 gas) and that calculation's associated stack operations.\n\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..43db0aa 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -8,6 +8,17 @@ pragma solidity ^0.8.13;\n    8,   8: */\n    9,   9: contract DolaBorrowingRights {\n   10,  10: \n+       11:+    struct UserInfo {\n+       12:+        uint256 balances;\n+       13:+        \n+       14:+        uint256 nonce;\n+       15:+        uint256 debts;  // user = debt across all tracked markets\n+       16:+        uint256 dueTokensAccrued; // user = amount of due tokens accrued\n+       17:+        uint256 lastUpdated; // user = last update timestamp\n+       18:+    }\n+       19:+    \n+       20:+    mapping(address = mapping(address = uint256)) public allowance;\n+       21:+\n   11,  22:     string public name;\n   12,  23:     string public symbol;\n   13,  24:     uint8 public constant decimals = 18;\n@@ -16,16 +27,11 @@ contract DolaBorrowingRights {\n   16,  27:     address public pendingOperator;\n   17,  28:     uint public totalDueTokensAccrued;\n   18,  29:     uint public replenishmentPriceBps;\n 19     :   mapping(address = uint256) public balances;\n 20     :   mapping(address = mapping(address = uint256)) public allowance;\n+       30:+    mapping(address = UserInfo) public userInfo;\n   21,  31:     uint256 internal immutable INITIAL_CHAIN_ID;\n   22,  32:     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n 23     :   mapping(address = uint256) public nonces;\n   24,  33:     mapping (address = bool) public minters;\n   25,  34:     mapping (address = bool) public markets;\n 26     :   mapping (address = uint) public debts; // user = debt across all tracked markets\n 27     :   mapping (address = uint) public dueTokensAccrued; // user = amount of due tokens accrued\n 28     :   mapping (address = uint) public lastUpdated; // user = last update timestamp\n   29,  35: \n   30,  36:     constructor(\n   31,  37:         uint _replenishmentPriceBps,\n@@ -118,10 +124,10 @@ contract DolaBorrowingRights {\n  118, 124:     @return uint representing the balance of the user.\n  119, 125:     */\n  120, 126:     function balanceOf(address user) public view returns (uint) {\n121     :       uint debt = debts[user];\n122     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n123     :       if(dueTokensAccrued[user] + accrued  balances[user]) return 0;\n124     :       return balances[user] dueTokensAccrued[user] accrued;\n+      127:+        uint debt = userInfo[user].debts;\n+      128:+        uint accrued = (block.timestamp userInfo[user].lastUpdated) * debt / 365 days;\n+      129:+        if(userInfo[user].dueTokensAccrued + accrued  userInfo[user].balances) return 0;\n+      130:+        return userInfo[user].balances userInfo[user].dueTokensAccrued accrued;\n  125, 131:     }\n  126, 132: \n  127, 133:     /\n@@ -131,10 +137,10 @@ contract DolaBorrowingRights {\n  131, 137:     @return uint representing the deficit of the user.\n  132, 138:     */\n  133, 139:     function deficitOf(address user) public view returns (uint) {\n134     :       uint debt = debts[user];\n135     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n136     :       if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n137     :       return dueTokensAccrued[user] + accrued balances[user];\n+      140:+        uint debt = userInfo[user].debts;\n+      141:+        uint accrued = (block.timestamp userInfo[user].lastUpdated) * debt / 365 days;\n+      142:+        if(userInfo[user].dueTokensAccrued + accrued < userInfo[user].balances) return 0;\n+      143:+        return userInfo[user].dueTokensAccrued + accrued userInfo[user].balances;\n  138, 144:     }\n  139, 145:     \n  140, 146:     /\n@@ -144,9 +150,9 @@ contract DolaBorrowingRights {\n  144, 150:     @return Returns a signed int of the user's balance\n  145, 151:     */\n  146, 152:     function signedBalanceOf(address user) public view returns (int) {\n147     :       uint debt = debts[user];\n148     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n149     :       return int(balances[user]) int(dueTokensAccrued[user]) int(accrued);\n+      153:+        uint debt = userInfo[user].debts;\n+      154:+        uint accrued = (block.timestamp userInfo[user].lastUpdated) * debt / 365 days;\n+      155:+        return int(userInfo[user].balances) int(userInfo[user].dueTokensAccrued) int(accrued);\n  150, 156:     }\n  151, 157: \n  152, 158:     /\n@@ -169,9 +175,9 @@ contract DolaBorrowingRights {\n  169, 175:     */\n  170, 176:     function transfer(address to, uint256 amount) public virtual returns (bool) {\n  171, 177:         require(balanceOf(msg.sender) = amount, \"Insufficient balance\");\n172     :       balances[msg.sender] -= amount;\n+      178:+        userInfo[msg.sender].balances -= amount;\n  173, 179:         unchecked {\n174     :           balances[to] += amount;\n+      180:+            userInfo[to].balances += amount;\n  175, 181:         }\n  176, 182:         emit Transfer(msg.sender, to, amount);\n  177, 183:         return true;\n@@ -193,9 +199,9 @@ contract DolaBorrowingRights {\n  193, 199:         uint256 allowed = allowance[from][msg.sender];\n  194, 200:         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed amount;\n  195, 201:         require(balanceOf(from) = amount, \"Insufficient balance\");\n196     :       balances[from] -= amount;\n+      202:+        userInfo[from].balances -= amount;\n  197, 203:         unchecked {\n198     :           balances[to] += amount;\n+      204:+            userInfo[to].balances += amount;\n  199, 205:         }\n  200, 206:         emit Transfer(from, to, amount);\n  201, 207:         return true;\n@@ -236,7 +242,7 @@ contract DolaBorrowingRights {\n  236, 242:                                 owner,\n  237, 243:                                 spender,\n  238, 244:                                 value,\n239     :                               nonces[owner]++,\n+      245:+                                userInfo[owner].nonce++,\n  240, 246:                                 deadline\n  241, 247:                             )\n  242, 248:                         )\n@@ -256,7 +262,7 @@ contract DolaBorrowingRights {\n  256, 262:     @notice Function for invalidating the nonce of a signed message.\n  257, 263:     */\n  258, 264:     function invalidateNonce() public {\n259     :       nonces[msg.sender]++;\n+      265:+        userInfo[msg.sender].nonce++;\n  260, 266:     }\n  261, 267: \n  262, 268:     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n@@ -282,12 +288,12 @@ contract DolaBorrowingRights {\n  282, 288:     @param user The address of the user to accrue DBR debt to.\n  283, 289:     */\n  284, 290:     function accrueDueTokens(address user) public {\n285     :       uint debt = debts[user];\n286     :       if(lastUpdated[user] == block.timestamp) return;\n287     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n288     :       dueTokensAccrued[user] += accrued;\n+      291:+        uint debt = userInfo[user].debts;\n+      292:+        if(userInfo[user].lastUpdated == block.timestamp) return;\n+      293:+        uint accrued = (block.timestamp userInfo[user].lastUpdated) * debt / 365 days;\n+      294:+        userInfo[user].dueTokensAccrued += accrued;\n  289, 295:         totalDueTokensAccrued += accrued;\n290     :       lastUpdated[user] = block.timestamp;\n+      296:+        userInfo[user].lastUpdated = block.timestamp;\n  291, 297:         emit Transfer(user, address(0), accrued);\n  292, 298:     }\n  293, 299: \n@@ -301,7 +307,7 @@ contract DolaBorrowingRights {\n  301, 307:         require(markets[msg.sender], \"Only markets can call onBorrow\");\n  302, 308:         accrueDueTokens(user);\n  303, 309:         require(deficitOf(user) == 0, \"DBR Deficit\");\n304     :       debts[user] += additionalDebt;\n+      310:+        userInfo[user].debts += additionalDebt;\n  305, 311:     }\n  306, 312: \n  307, 313:     /\n@@ -313,7 +319,7 @@ contract DolaBorrowingRights {\n  313, 319:     function onRepay(address user, uint repaidDebt) public {\n  314, 320:         require(markets[msg.sender], \"Only markets can call onRepay\");\n  315, 321:         accrueDueTokens(user);\n316     :       debts[user] -= repaidDebt;\n+      322:+        userInfo[user].debts -= repaidDebt;\n  317, 323:     }\n  318, 324: \n  319, 325:     /\n@@ -329,7 +335,7 @@ contract DolaBorrowingRights {\n  329, 335:         require(deficit = amount, \"Amount  deficit\");\n  330, 336:         uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n  331, 337:         accrueDueTokens(user);\n332     :       debts[user] += replenishmentCost;\n+      338:+        userInfo[user].debts += replenishmentCost;\n  333, 339:         _mint(user, amount);\n  334, 340:     }\n  335, 341: \n@@ -359,7 +365,7 @@ contract DolaBorrowingRights {\n  359, 365:     function _mint(address to, uint256 amount) internal virtual {\n  360, 366:         _totalSupply += amount;\n  361, 367:         unchecked {\n362     :           balances[to] += amount;\n+      368:+            userInfo[to].balances += amount;\n  363, 369:         }\n  364, 370:         emit Transfer(address(0), to, amount);\n  365, 371:     }\n@@ -371,7 +377,7 @@ contract DolaBorrowingRights {\n  371, 377:     */\n  372, 378:     function _burn(address from, uint256 amount) internal virtual {\n  373, 379:         require(balanceOf(from) = amount, \"Insufficient balance\");\n374     :       balances[from] -= amount;\n+      380:+        userInfo[from].balances -= amount;\n  375, 381:         unchecked {\n  376, 382:             _totalSupply -= amount;\n  377, 383:         }\ndiff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol\nindex 3988cf7..754bf7f 100644\n--a/src/test/DBR.t.sol\n+++ b/src/test/DBR.t.sol\n@@ -145,17 +145,19 @@ contract DBRTest is FiRMTest {\n  145, 145:     }\n  146, 146: \n  147, 147:     function test_invalidateNonce() public {\n148     :       assertEq(dbr.nonces(user), 0, \"User nonce should be uninitialized\");\n+      148:+        (, uint256 nonce,,,) = dbr.userInfo(user);\n+      149:+        assertEq(nonce, 0, \"User nonce should be uninitialized\");\n  149, 150: \n  150, 151:         vm.startPrank(user);\n  151, 152:         dbr.invalidateNonce();\n  152, 153: \n153     :       assertEq(dbr.nonces(user), 1, \"User nonce was not invalidated\");\n+      154:+        (,nonce,,,) = dbr.userInfo(user);\n+      155:+        assertEq(nonce, 1, \"User nonce was not invalidated\");\n  154, 156:     }\n  155, 157: \n  156, 158:     function test_approve_increasesAllowanceByAmount() public {\n  157, 159:         uint amount = 100e18;\n158     :-\n+      160:+        \n  159, 161:         assertEq(dbr.allowance(user, gov), 0, \"Allowance should not be set yet\");\n  160, 162: \n  161, 163:         vm.startPrank(user);\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "5",
                "Location": [
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..0781c97 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -107,8 +107,10 @@ contract DolaBorrowingRights {\n  107, 107:     @return uint representing the total supply of DBR.\n  108, 108:     */\n  109, 109:     function totalSupply() public view returns (uint) {\n110     :       if(totalDueTokensAccrued  _totalSupply) return 0;\n111     :       return _totalSupply totalDueTokensAccrued;\n+      110:+        unchecked {\n+      111:+            if(totalDueTokensAccrued  _totalSupply) return 0;\n+      112:+            return _totalSupply totalDueTokensAccrued;\n+      113:+        }\n  112, 114:     }\n  113, 115: \n  114, 116:     /\n@@ -121,7 +123,7 @@ contract DolaBorrowingRights {\n  121, 123:         uint debt = debts[user];\n  122, 124:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n  123, 125:         if(dueTokensAccrued[user] + accrued  balances[user]) return 0;\n124     :       return balances[user] dueTokensAccrued[user] accrued;\n+      126:+        unchecked { return balances[user] dueTokensAccrued[user] accrued; }\n  125, 127:     }\n  126, 128: \n  127, 129:     /\n@@ -134,7 +136,7 @@ contract DolaBorrowingRights {\n  134, 136:         uint debt = debts[user];\n  135, 137:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n  136, 138:         if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n137     :       return dueTokensAccrued[user] + accrued balances[user];\n+      139:+        unchecked { return dueTokensAccrued[user] + accrued balances[user]; }\n  138, 140:     }\n  139, 141:     \n  140, 142:     /\n@@ -256,7 +258,7 @@ contract DolaBorrowingRights {\n  256, 258:     @notice Function for invalidating the nonce of a signed message.\n  257, 259:     */\n  258, 260:     function invalidateNonce() public {\n259     :       nonces[msg.sender]++;\n+      261:+        unchecked { nonces[msg.sender]++; }\n  260, 262:     }\n  261, 263: \n  262, 264:     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n",
                    "diff\ndiff --git a/src/Fed.sol b/src/Fed.sol\nindex 1e819bb..b57b444 100644\n--a/src/Fed.sol\n+++ b/src/Fed.sol\n@@ -121,7 +121,7 @@ contract Fed {\n  121, 121:         uint marketValue = dola.balanceOf(address(market)) + market.totalDebt();\n  122, 122:         uint supply = supplies[market];\n  123, 123:         if(supply = marketValue) return 0;\n124     :       return marketValue supply;\n+      124:+        unchecked { return marketValue supply; }\n  125, 125:     }\n  126, 126: \n  127, 127:     /\n",
                    "diff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..293bbb6 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -518,7 +518,7 @@ contract Market {\n  518, 518:     @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n  519, 519:     */\n  520, 520:     function invalidateNonce() public {\n521     :       nonces[msg.sender]++;\n+      521:+        unchecked { nonces[msg.sender]++; }\n  522, 522:     }\n  523, 523:     \n  524, 524:     /\n"
                ],
                "Type": " Expression can be unchecked when overflow is not possible (6 instances)",
                "Description": "\nDeployment. Gas Saved: 20 220\n\nMinimum Method Call. Gas Saved: 410\n\nAverage Method Call. Gas Saved: 4 630\n\nMaximum Method Call. Gas Saved: 1 354\n\nOverall gas change: -6 233 (-5.326%)\n\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..0781c97 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -107,8 +107,10 @@ contract DolaBorrowingRights {\n  107, 107:     @return uint representing the total supply of DBR.\n  108, 108:     */\n  109, 109:     function totalSupply() public view returns (uint) {\n110     :       if(totalDueTokensAccrued  _totalSupply) return 0;\n111     :       return _totalSupply totalDueTokensAccrued;\n+      110:+        unchecked {\n+      111:+            if(totalDueTokensAccrued  _totalSupply) return 0;\n+      112:+            return _totalSupply totalDueTokensAccrued;\n+      113:+        }\n  112, 114:     }\n  113, 115: \n  114, 116:     /\n@@ -121,7 +123,7 @@ contract DolaBorrowingRights {\n  121, 123:         uint debt = debts[user];\n  122, 124:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n  123, 125:         if(dueTokensAccrued[user] + accrued  balances[user]) return 0;\n124     :       return balances[user] dueTokensAccrued[user] accrued;\n+      126:+        unchecked { return balances[user] dueTokensAccrued[user] accrued; }\n  125, 127:     }\n  126, 128: \n  127, 129:     /\n@@ -134,7 +136,7 @@ contract DolaBorrowingRights {\n  134, 136:         uint debt = debts[user];\n  135, 137:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n  136, 138:         if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n137     :       return dueTokensAccrued[user] + accrued balances[user];\n+      139:+        unchecked { return dueTokensAccrued[user] + accrued balances[user]; }\n  138, 140:     }\n  139, 141:     \n  140, 142:     /\n@@ -256,7 +258,7 @@ contract DolaBorrowingRights {\n  256, 258:     @notice Function for invalidating the nonce of a signed message.\n  257, 259:     */\n  258, 260:     function invalidateNonce() public {\n259     :       nonces[msg.sender]++;\n+      261:+        unchecked { nonces[msg.sender]++; }\n  260, 262:     }\n  261, 263: \n  262, 264:     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n\n\n\ndiff\ndiff --git a/src/Fed.sol b/src/Fed.sol\nindex 1e819bb..b57b444 100644\n--a/src/Fed.sol\n+++ b/src/Fed.sol\n@@ -121,7 +121,7 @@ contract Fed {\n  121, 121:         uint marketValue = dola.balanceOf(address(market)) + market.totalDebt();\n  122, 122:         uint supply = supplies[market];\n  123, 123:         if(supply = marketValue) return 0;\n124     :       return marketValue supply;\n+      124:+        unchecked { return marketValue supply; }\n  125, 125:     }\n  126, 126: \n  127, 127:     /\n\n\n\ndiff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..293bbb6 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -518,7 +518,7 @@ contract Market {\n  518, 518:     @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n  519, 519:     */\n  520, 520:     function invalidateNonce() public {\n521     :       nonces[msg.sender]++;\n+      521:+        unchecked { nonces[msg.sender]++; }\n  522, 522:     }\n  523, 523:     \n  524, 524:     /\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "6",
                "Location": [
                    "diff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..6141e5c 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -36,6 +36,7 @@ interface IBorrowController {\n   36,  36: contract Market {\n   37,  37: \n   38,  38:     address public gov;\n+       39:+    bool public borrowPaused;\n   39,  40:     address public lender;\n   40,  41:     address public pauseGuardian;\n   41,  42:     address public immutable escrowImplementation;\n@@ -50,7 +51,6 @@ contract Market {\n   50,  51:     uint public liquidationFeeBps;\n   51,  52:     uint public liquidationFactorBps = 5000; // 50% by default\n   52,  53:     bool immutable callOnDepositCallback;\n 53     :   bool public borrowPaused;\n   54,  54:     uint public totalDebt;\n   55,  55:     uint256 internal immutable INITIAL_CHAIN_ID;\n   56,  56:     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n"
                ],
                "Type": " State variables can be packed into fewer storage slots (1 instance)",
                "Description": "\nDeployment. Gas Saved: -5 008\n\nMinimum Method Call. Gas Saved: 1 911\n\nAverage Method Call. Gas Saved: 15 525\n\nMaximum Method Call. Gas Saved: 20 972\n\nOverall gas change: -62 419 (-69.524%)\n\nIf variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (20000 gas). Reads of the variables can also be cheaper\n\nuint256(32), mapping(32), address(20), bool(1)\n\n\ndiff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..6141e5c 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -36,6 +36,7 @@ interface IBorrowController {\n   36,  36: contract Market {\n   37,  37: \n   38,  38:     address public gov;\n+       39:+    bool public borrowPaused;\n   39,  40:     address public lender;\n   40,  41:     address public pauseGuardian;\n   41,  42:     address public immutable escrowImplementation;\n@@ -50,7 +51,6 @@ contract Market {\n   50,  51:     uint public liquidationFeeBps;\n   51,  52:     uint public liquidationFactorBps = 5000; // 50% by default\n   52,  53:     bool immutable callOnDepositCallback;\n 53     :   bool public borrowPaused;\n   54,  54:     uint public totalDebt;\n   55,  55:     uint256 internal immutable INITIAL_CHAIN_ID;\n   56,  56:     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "7",
                "Location": [
                    "diff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..da295e5 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -210,11 +210,9 @@ contract Market {\n  210, 210:     @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n  211, 211:     */\n  212, 212:     function pauseBorrows(bool _value) public {\n213     :       if(_value) {\n214     :           require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n215     :       } else {\n216     :           require(msg.sender == gov, \"Only governance can unpause\");\n217     :       }\n+      213:+        require(\n+      214:+            ( _value && msg.sender == pauseGuardian) || msg.sender == gov,\n+      215:+            \"Only pause guardian or governance can pause\");\n  218, 216:         borrowPaused = _value;\n  219, 217:     }\n  220, 218: \ndiff --git a/src/test/Market.t.sol b/src/test/Market.t.sol\nindex 8992ab9..86af449 100644\n--a/src/test/Market.t.sol\n+++ b/src/test/Market.t.sol\n@@ -16,7 +16,7 @@ import \"./mocks/BorrowContract.sol\";\n   16,  16: import {EthFeed} from \"./mocks/EthFeed.sol\";\n   17,  17: \n   18,  18: contract MarketTest is FiRMTest {\n 19     :   bytes onlyGovUnpause = \"Only governance can unpause\";\n+       19:+    bytes onlyGovUnpause = \"Only pause guardian or governance can pause\";\n   20,  20:     bytes onlyPauseGuardianOrGov = \"Only pause guardian or governance can pause\";\n   21,  21: \n   22,  22:     BorrowContract borrowContract;\n"
                ],
                "Type": " Refactoring similar statements (1 instance)",
                "Description": "\nDeployment. Gas Saved: 18 422\n\nMinimum Method Call. Gas Saved: -18\n\nAverage Method Call. Gas Saved: -11\n\nMaximum Method Call. Gas Saved: 6\n\nOverall gas change: 4 876 (7.739%)\n\n\ndiff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..da295e5 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -210,11 +210,9 @@ contract Market {\n  210, 210:     @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n  211, 211:     */\n  212, 212:     function pauseBorrows(bool _value) public {\n213     :       if(_value) {\n214     :           require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n215     :       } else {\n216     :           require(msg.sender == gov, \"Only governance can unpause\");\n217     :       }\n+      213:+        require(\n+      214:+            ( _value && msg.sender == pauseGuardian) || msg.sender == gov,\n+      215:+            \"Only pause guardian or governance can pause\");\n  218, 216:         borrowPaused = _value;\n  219, 217:     }\n  220, 218: \ndiff --git a/src/test/Market.t.sol b/src/test/Market.t.sol\nindex 8992ab9..86af449 100644\n--a/src/test/Market.t.sol\n+++ b/src/test/Market.t.sol\n@@ -16,7 +16,7 @@ import \"./mocks/BorrowContract.sol\";\n   16,  16: import {EthFeed} from \"./mocks/EthFeed.sol\";\n   17,  17: \n   18,  18: contract MarketTest is FiRMTest {\n 19     :   bytes onlyGovUnpause = \"Only governance can unpause\";\n+       19:+    bytes onlyGovUnpause = \"Only pause guardian or governance can pause\";\n   20,  20:     bytes onlyPauseGuardianOrGov = \"Only pause guardian or governance can pause\";\n   21,  21: \n   22,  22:     BorrowContract borrowContract;\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "8",
                "Location": [
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..bff9fef 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -104,37 +104,39 @@ contract DolaBorrowingRights {\n  104, 104:     /\n  105, 105:     @notice Get the total supply of DBR tokens.\n  106, 106:     @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n107     :   @return uint representing the total supply of DBR.\n+      107:+    @return ret uint representing the total supply of DBR.\n  108, 108:     */\n109     :   function totalSupply() public view returns (uint) {\n110     :       if(totalDueTokensAccrued  _totalSupply) return 0;\n111     :       return _totalSupply totalDueTokensAccrued;\n+      109:+    function totalSupply() public view returns (uint ret) {\n+      110:+        unchecked { ret = _totalSupply totalDueTokensAccrued; }\n+      111:+        if(ret  _totalSupply) return 0;\n  112, 112:     }\n  113, 113: \n  114, 114:     /\n  115, 115:     @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n  116, 116:     @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n  117, 117:     @param user Address of the user.\n118     :   @return uint representing the balance of the user.\n+      118:+    @return ret uint representing the balance of the user.\n  119, 119:     */\n120     :   function balanceOf(address user) public view returns (uint) {\n+      120:+    function balanceOf(address user) public view returns (uint ret) {\n  121, 121:         uint debt = debts[user];\n  122, 122:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n123     :       if(dueTokensAccrued[user] + accrued  balances[user]) return 0;\n124     :       return balances[user] dueTokensAccrued[user] accrued;\n+      123:+        uint mid = dueTokensAccrued[user] + accrued;\n+      124:+        unchecked { ret = balances[user] mid; }\n+      125:+        if(ret  balances[user]) return 0;\n  125, 126:     }\n  126, 127: \n  127, 128:     /\n  128, 129:     @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n  129, 130:     @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n  130, 131:     @param user Address of the user.\n131     :   @return uint representing the deficit of the user.\n+      132:+    @return ret uint representing the deficit of the user.\n  132, 133:     */\n133     :   function deficitOf(address user) public view returns (uint) {\n+      134:+    function deficitOf(address user) public view returns (uint ret) {\n  134, 135:         uint debt = debts[user];\n  135, 136:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n136     :       if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n137     :       return dueTokensAccrued[user] + accrued balances[user];\n+      137:+        uint mid = dueTokensAccrued[user] + accrued;\n+      138:+        unchecked { ret = mid balances[user]; }\n+      139:+        if(mid < ret) return 0;\n  138, 140:     }\n  139, 141:     \n  140, 142:     /\n"
                ],
                "Type": " Better algorithm for underflow check (3 instances)",
                "Description": "\nDeployment. Gas Saved: 12 613\n\nMinimum Method Call. Gas Saved: 656\n\nAverage Method Call. Gas Saved: 8 332\n\nMaximum Method Call. Gas Saved: 3 741\n\nOverall gas change: -18 048 (-15.981%)\n\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..bff9fef 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -104,37 +104,39 @@ contract DolaBorrowingRights {\n  104, 104:     /\n  105, 105:     @notice Get the total supply of DBR tokens.\n  106, 106:     @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n107     :   @return uint representing the total supply of DBR.\n+      107:+    @return ret uint representing the total supply of DBR.\n  108, 108:     */\n109     :   function totalSupply() public view returns (uint) {\n110     :       if(totalDueTokensAccrued  _totalSupply) return 0;\n111     :       return _totalSupply totalDueTokensAccrued;\n+      109:+    function totalSupply() public view returns (uint ret) {\n+      110:+        unchecked { ret = _totalSupply totalDueTokensAccrued; }\n+      111:+        if(ret  _totalSupply) return 0;\n  112, 112:     }\n  113, 113: \n  114, 114:     /\n  115, 115:     @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n  116, 116:     @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n  117, 117:     @param user Address of the user.\n118     :   @return uint representing the balance of the user.\n+      118:+    @return ret uint representing the balance of the user.\n  119, 119:     */\n120     :   function balanceOf(address user) public view returns (uint) {\n+      120:+    function balanceOf(address user) public view returns (uint ret) {\n  121, 121:         uint debt = debts[user];\n  122, 122:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n123     :       if(dueTokensAccrued[user] + accrued  balances[user]) return 0;\n124     :       return balances[user] dueTokensAccrued[user] accrued;\n+      123:+        uint mid = dueTokensAccrued[user] + accrued;\n+      124:+        unchecked { ret = balances[user] mid; }\n+      125:+        if(ret  balances[user]) return 0;\n  125, 126:     }\n  126, 127: \n  127, 128:     /\n  128, 129:     @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n  129, 130:     @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n  130, 131:     @param user Address of the user.\n131     :   @return uint representing the deficit of the user.\n+      132:+    @return ret uint representing the deficit of the user.\n  132, 133:     */\n133     :   function deficitOf(address user) public view returns (uint) {\n+      134:+    function deficitOf(address user) public view returns (uint ret) {\n  134, 135:         uint debt = debts[user];\n  135, 136:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n136     :       if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n137     :       return dueTokensAccrued[user] + accrued balances[user];\n+      137:+        uint mid = dueTokensAccrued[user] + accrued;\n+      138:+        unchecked { ret = mid balances[user]; }\n+      139:+        if(mid < ret) return 0;\n  138, 140:     }\n  139, 141:     \n  140, 142:     /\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "9",
                "Location": [
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..c02b782 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -171,7 +171,7 @@ contract DolaBorrowingRights {\n  171, 171:         require(balanceOf(msg.sender) = amount, \"Insufficient balance\");\n  172, 172:         balances[msg.sender] -= amount;\n  173, 173:         unchecked {\n174     :           balances[to] += amount;\n+      174:+            balances[to] = balances[to] + amount;\n  175, 175:         }\n  176, 176:         emit Transfer(msg.sender, to, amount);\n  177, 177:         return true;\n@@ -193,7 +193,7 @@ contract DolaBorrowingRights {\n  193, 193:         uint256 allowed = allowance[from][msg.sender];\n  194, 194:         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed amount;\n  195, 195:         require(balanceOf(from) = amount, \"Insufficient balance\");\n196     :       balances[from] -= amount;\n+      196:+        balances[from] = balances[from] amount;\n  197, 197:         unchecked {\n  198, 198:             balances[to] += amount;\n  199, 199:         }\n@@ -286,7 +286,7 @@ contract DolaBorrowingRights {\n  286, 286:         if(lastUpdated[user] == block.timestamp) return;\n  287, 287:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n  288, 288:         dueTokensAccrued[user] += accrued;\n289     :       totalDueTokensAccrued += accrued;\n+      289:+        totalDueTokensAccrued = totalDueTokensAccrued + accrued;\n  290, 290:         lastUpdated[user] = block.timestamp;\n  291, 291:         emit Transfer(user, address(0), accrued);\n  292, 292:     }\n@@ -357,9 +357,9 @@ contract DolaBorrowingRights {\n  357, 357:     @param amount Amount of DBR to mint.\n  358, 358:     */\n  359, 359:     function _mint(address to, uint256 amount) internal virtual {\n360     :       _totalSupply += amount;\n+      360:+        _totalSupply = _totalSupply + amount;\n  361, 361:         unchecked {\n362     :           balances[to] += amount;\n+      362:+            balances[to] = balances[to] + amount;\n  363, 363:         }\n  364, 364:         emit Transfer(address(0), to, amount);\n  365, 365:     }\n@@ -373,7 +373,7 @@ contract DolaBorrowingRights {\n  373, 373:         require(balanceOf(from) = amount, \"Insufficient balance\");\n  374, 374:         balances[from] -= amount;\n  375, 375:         unchecked {\n376     :           _totalSupply -= amount;\n+      376:+            _totalSupply = _totalSupply amount;\n  377, 377:         }\n  378, 378:         emit Transfer(from, address(0), amount);\n  379, 379:     }\n",
                    "diff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..bc0ff93 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -392,9 +392,9 @@ contract Market {\n  392, 392:             require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n  393, 393:         }\n  394, 394:         uint credit = getCreditLimitInternal(borrower);\n395     :       debts[borrower] += amount;\n+      395:+        debts[borrower] = debts[borrower] + amount;\n  396, 396:         require(credit = debts[borrower], \"Exceeded credit limit\");\n397     :       totalDebt += amount;\n+      397:+        totalDebt = totalDebt + amount;\n  398, 398:         dbr.onBorrow(borrower, amount);\n  399, 399:         dola.transfer(to, amount);\n  400, 400:         emit Borrow(borrower, amount);\n@@ -532,7 +532,7 @@ contract Market {\n  532, 532:         uint debt = debts[user];\n  533, 533:         require(debt = amount, \"Insufficient debt\");\n  534, 534:         debts[user] -= amount;\n535     :       totalDebt -= amount;\n+      535:+        totalDebt = totalDebt amount;\n  536, 536:         dbr.onRepay(user, amount);\n  537, 537:         dola.transferFrom(msg.sender, address(this), amount);\n  538, 538:         emit Repay(user, msg.sender, amount);\n@@ -565,7 +565,7 @@ contract Market {\n  565, 565:         debts[user] += replenishmentCost;\n  566, 566:         uint collateralValue = getCollateralValueInternal(user);\n  567, 567:         require(collateralValue = debts[user], \"Exceeded collateral value\");\n568     :       totalDebt += replenishmentCost;\n+      568:+        totalDebt = totalDebt + replenishmentCost;\n  569, 569:         dbr.onForceReplenish(user, amount);\n  570, 570:         dola.transfer(msg.sender, replenisherReward);\n  571, 571:         emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n@@ -595,9 +595,9 @@ contract Market {\n  595, 595:         require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n  596, 596:         uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n  597, 597:         uint liquidatorReward = repaidDebt * 1 ether / price;\n598     :       liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n+      598:+        liquidatorReward = liquidatorReward + liquidatorReward * liquidationIncentiveBps / 10000;\n  599, 599:         debts[user] -= repaidDebt;\n600     :       totalDebt -= repaidDebt;\n+      600:+        totalDebt = totalDebt repaidDebt;\n  601, 601:         dbr.onRepay(user, repaidDebt);\n  602, 602:         dola.transferFrom(msg.sender, address(this), repaidDebt);\n  603, 603:         IEscrow escrow = predictEscrow(user);\n"
                ],
                "Type": "  x = x + y  is cheaper than  x += y  (12 instances)",
                "Description": "\nDeployment. Gas Saved: 11 214\n\nMinimum Method Call. Gas Saved: 180\n\nAverage Method Call. Gas Saved: 468\n\nMaximum Method Call. Gas Saved: 616\n\nOverall gas change: -5 325 (-1.318%)\n\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..c02b782 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -171,7 +171,7 @@ contract DolaBorrowingRights {\n  171, 171:         require(balanceOf(msg.sender) = amount, \"Insufficient balance\");\n  172, 172:         balances[msg.sender] -= amount;\n  173, 173:         unchecked {\n174     :           balances[to] += amount;\n+      174:+            balances[to] = balances[to] + amount;\n  175, 175:         }\n  176, 176:         emit Transfer(msg.sender, to, amount);\n  177, 177:         return true;\n@@ -193,7 +193,7 @@ contract DolaBorrowingRights {\n  193, 193:         uint256 allowed = allowance[from][msg.sender];\n  194, 194:         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed amount;\n  195, 195:         require(balanceOf(from) = amount, \"Insufficient balance\");\n196     :       balances[from] -= amount;\n+      196:+        balances[from] = balances[from] amount;\n  197, 197:         unchecked {\n  198, 198:             balances[to] += amount;\n  199, 199:         }\n@@ -286,7 +286,7 @@ contract DolaBorrowingRights {\n  286, 286:         if(lastUpdated[user] == block.timestamp) return;\n  287, 287:         uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n  288, 288:         dueTokensAccrued[user] += accrued;\n289     :       totalDueTokensAccrued += accrued;\n+      289:+        totalDueTokensAccrued = totalDueTokensAccrued + accrued;\n  290, 290:         lastUpdated[user] = block.timestamp;\n  291, 291:         emit Transfer(user, address(0), accrued);\n  292, 292:     }\n@@ -357,9 +357,9 @@ contract DolaBorrowingRights {\n  357, 357:     @param amount Amount of DBR to mint.\n  358, 358:     */\n  359, 359:     function _mint(address to, uint256 amount) internal virtual {\n360     :       _totalSupply += amount;\n+      360:+        _totalSupply = _totalSupply + amount;\n  361, 361:         unchecked {\n362     :           balances[to] += amount;\n+      362:+            balances[to] = balances[to] + amount;\n  363, 363:         }\n  364, 364:         emit Transfer(address(0), to, amount);\n  365, 365:     }\n@@ -373,7 +373,7 @@ contract DolaBorrowingRights {\n  373, 373:         require(balanceOf(from) = amount, \"Insufficient balance\");\n  374, 374:         balances[from] -= amount;\n  375, 375:         unchecked {\n376     :           _totalSupply -= amount;\n+      376:+            _totalSupply = _totalSupply amount;\n  377, 377:         }\n  378, 378:         emit Transfer(from, address(0), amount);\n  379, 379:     }\n\n\n\ndiff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..bc0ff93 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -392,9 +392,9 @@ contract Market {\n  392, 392:             require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n  393, 393:         }\n  394, 394:         uint credit = getCreditLimitInternal(borrower);\n395     :       debts[borrower] += amount;\n+      395:+        debts[borrower] = debts[borrower] + amount;\n  396, 396:         require(credit = debts[borrower], \"Exceeded credit limit\");\n397     :       totalDebt += amount;\n+      397:+        totalDebt = totalDebt + amount;\n  398, 398:         dbr.onBorrow(borrower, amount);\n  399, 399:         dola.transfer(to, amount);\n  400, 400:         emit Borrow(borrower, amount);\n@@ -532,7 +532,7 @@ contract Market {\n  532, 532:         uint debt = debts[user];\n  533, 533:         require(debt = amount, \"Insufficient debt\");\n  534, 534:         debts[user] -= amount;\n535     :       totalDebt -= amount;\n+      535:+        totalDebt = totalDebt amount;\n  536, 536:         dbr.onRepay(user, amount);\n  537, 537:         dola.transferFrom(msg.sender, address(this), amount);\n  538, 538:         emit Repay(user, msg.sender, amount);\n@@ -565,7 +565,7 @@ contract Market {\n  565, 565:         debts[user] += replenishmentCost;\n  566, 566:         uint collateralValue = getCollateralValueInternal(user);\n  567, 567:         require(collateralValue = debts[user], \"Exceeded collateral value\");\n568     :       totalDebt += replenishmentCost;\n+      568:+        totalDebt = totalDebt + replenishmentCost;\n  569, 569:         dbr.onForceReplenish(user, amount);\n  570, 570:         dola.transfer(msg.sender, replenisherReward);\n  571, 571:         emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n@@ -595,9 +595,9 @@ contract Market {\n  595, 595:         require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n  596, 596:         uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n  597, 597:         uint liquidatorReward = repaidDebt * 1 ether / price;\n598     :       liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n+      598:+        liquidatorReward = liquidatorReward + liquidatorReward * liquidationIncentiveBps / 10000;\n  599, 599:         debts[user] -= repaidDebt;\n600     :       totalDebt -= repaidDebt;\n+      600:+        totalDebt = totalDebt repaidDebt;\n  601, 601:         dbr.onRepay(user, repaidDebt);\n  602, 602:         dola.transferFrom(msg.sender, address(this), repaidDebt);\n  603, 603:         IEscrow escrow = predictEscrow(user);\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "1",
                "Location": [
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..c70fcd7 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -283,8 +283,9 @@ contract DolaBorrowingRights {\n  283, 283:     */\n  284, 284:     function accrueDueTokens(address user) public {\n  285, 285:         uint debt = debts[user];\n286     :       if(lastUpdated[user] == block.timestamp) return;\n287     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n+      286:+        uint _lastUpdated = lastUpdated[user];\n+      287:+        if(_lastUpdated == block.timestamp) return;\n+      288:+        uint accrued = (block.timestamp _lastUpdated) * debt / 365 days;\n  288, 289:         dueTokensAccrued[user] += accrued;\n  289, 290:         totalDueTokensAccrued += accrued;\n  290, 291:         lastUpdated[user] = block.timestamp;\n",
                    "diff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..5f3264d 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -388,8 +388,9 @@ contract Market {\n  388, 388:     */\n  389, 389:     function borrowInternal(address borrower, address to, uint amount) internal {\n  390, 390:         require(!borrowPaused, \"Borrowing is paused\");\n391     :       if(borrowController != IBorrowController(address(0))) {\n392     :           require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n+      391:+        IBorrowController _borrowController = borrowController;\n+      392:+        if(_borrowController != IBorrowController(address(0))) {\n+      393:+            require(_borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n  393, 394:         }\n  394, 395:         uint credit = getCreditLimitInternal(borrower);\n  395, 396:         debts[borrower] += amount;\n"
                ],
                "Type": " State variables should be cached in stack variables rather than re-reading them from storage (2 instances)",
                "Description": "\nDeployment. Gas Saved: 5 007\n\nMinimum Method Call. Gas Saved: 478\n\nAverage Method Call. Gas Saved: 1 117\n\nMaximum Method Call. Gas Saved: 1 423\n\nOverall gas change: -6 231 (-1.618%)\n\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..c70fcd7 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -283,8 +283,9 @@ contract DolaBorrowingRights {\n  283, 283:     */\n  284, 284:     function accrueDueTokens(address user) public {\n  285, 285:         uint debt = debts[user];\n286     :       if(lastUpdated[user] == block.timestamp) return;\n287     :       uint accrued = (block.timestamp lastUpdated[user]) * debt / 365 days;\n+      286:+        uint _lastUpdated = lastUpdated[user];\n+      287:+        if(_lastUpdated == block.timestamp) return;\n+      288:+        uint accrued = (block.timestamp _lastUpdated) * debt / 365 days;\n  288, 289:         dueTokensAccrued[user] += accrued;\n  289, 290:         totalDueTokensAccrued += accrued;\n  290, 291:         lastUpdated[user] = block.timestamp;\n\n\n\ndiff\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..5f3264d 100644\n--a/src/Market.sol\n+++ b/src/Market.sol\n@@ -388,8 +388,9 @@ contract Market {\n  388, 388:     */\n  389, 389:     function borrowInternal(address borrower, address to, uint amount) internal {\n  390, 390:         require(!borrowPaused, \"Borrowing is paused\");\n391     :       if(borrowController != IBorrowController(address(0))) {\n392     :           require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n+      391:+        IBorrowController _borrowController = borrowController;\n+      392:+        if(_borrowController != IBorrowController(address(0))) {\n+      393:+            require(_borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n  393, 394:         }\n  394, 395:         uint credit = getCreditLimitInternal(borrower);\n  395, 396:         debts[borrower] += amount;\n\n\n## Overall gas savings\n\nDeployment. Gas Saved: 416 802\n\nMinimum Method Call. Gas Saved: 3 423\n\nAverage Method Call. Gas Saved: 15 773\n\nMaximum Method Call. Gas Saved: 18 283\n\nOverall gas change: -84 866 (-67.204%)\n\nPlease see warden's original submission(https://github.com/code-423n4/2022-10-inverse-findings/issues/368) for full details and diff.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IMarket {\n    function recall(uint amount) external;\n    function totalDebt() external view returns (uint);\n    function borrowPaused() external view returns (bool);\n}\n\ninterface IDola {\n    function mint(address to, uint amount) external;\n    function burn(uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function transfer(address to, uint amount) external returns (bool);\n}\n\ninterface IDBR {\n    function markets(address) external view returns (bool);\n}\n\n/**\n@title The Market Fed\n@notice Feds are a class of contracts in the Inverse Finance ecosystem responsible for minting and burning DOLA.\n This specific Fed can expand DOLA supply into markets and contract DOLA supply from markets.\n*/\ncontract Fed {\n\n    IDBR public immutable dbr;\n    IDola public immutable dola;\n    address public gov;\n    address public chair;\n    uint public supplyCeiling;\n    uint public globalSupply;\n    mapping (IMarket => uint) public supplies;\n\n    constructor (IDBR _dbr, IDola _dola, address _gov, address _chair, uint _supplyCeiling) {\n        dbr = _dbr;\n        dola = _dola;\n        gov = _gov;\n        chair = _chair;\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Change the governance of the Fed contact. Only callable by governance.\n    @param _gov The address of the new governance contract\n    */\n    function changeGov(address _gov) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        gov = _gov;\n    }\n\n    /**\n    @notice Set the supply ceiling of the Fed. Only callable by governance.\n    @param _supplyCeiling Amount to set the supply ceiling to\n    */\n    function changeSupplyCeiling(uint _supplyCeiling) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        supplyCeiling = _supplyCeiling;\n    }\n\n    /**\n    @notice Set the chair of the fed. Only callable by governance.\n    @param _chair Address of the new chair.\n    */\n    function changeChair(address _chair) public {\n        require(msg.sender == gov, \"ONLY GOV\");\n        chair = _chair;\n    }\n\n    /**\n    @notice Set the address of the chair to the 0 address. Only callable by the chair.\n    @dev Useful for immediately removing chair powers in case of a wallet compromise.\n    */\n    function resign() public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        chair = address(0);\n    }\n\n    /**\n    @notice Expand the amount of DOLA by depositing the amount into a specific market.\n    @dev While not immediately dangerous to the DOLA peg, make sure the market can absorb the new potential supply.\n    @param market The market to add additional DOLA supply to.\n    @param amount The amount of DOLA to mint and supply to the market.\n    */\n    function expansion(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        require(market.borrowPaused() != true, \"CANNOT EXPAND PAUSED MARKETS\");\n        dola.mint(address(market), amount);\n        supplies[market] += amount;\n        globalSupply += amount;\n        require(globalSupply <= supplyCeiling);\n        emit Expansion(market, amount);\n    }\n\n    /**\n    @notice Contract the amount of DOLA by withdrawing some amount of DOLA from a market, before burning it.\n    @dev Markets can have more DOLA in them than they've been supplied, due to force replenishes. This call will revert if trying to contract more than have been supplied.\n    @param market The market to withdraw DOLA from\n    @param amount The amount of DOLA to withdraw and burn.\n    */\n    function contraction(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n        uint supply = supplies[market];\n        require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n        market.recall(amount);\n        dola.burn(amount);\n        supplies[market] -= amount;\n        globalSupply -= amount;\n        emit Contraction(market, amount);\n    }\n\n    /**\n    @notice Gets the profit of a market.\n    @param market The market to withdraw profit from.\n    @return A uint representing the profit of the market.\n    */\n    function getProfit(IMarket market) public view returns (uint) {\n        uint marketValue = dola.balanceOf(address(market)) + market.totalDebt();\n        uint supply = supplies[market];\n        if(supply >= marketValue) return 0;\n        return marketValue - supply;\n    }\n\n    /**\n    @notice Takes profit from a market\n    @param market The market to take profit from.\n    */\n    function takeProfit(IMarket market) public {\n        uint profit = getProfit(market);\n        if(profit > 0) {\n            market.recall(profit);\n            dola.transfer(gov, profit);\n        }\n    }\n\n\n    event Expansion(IMarket indexed market, uint amount);\n    event Contraction(IMarket indexed market, uint amount);\n\n}\n\n\n",
        "CodeNames": [
            "Fed.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "6",
                "Location": [
                    "diff\n    function contraction(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n+       require(!market.borrowPaused(), \"CANNOT EXPAND PAUSED MARKETS\");\n        uint supply = supplies[market];\n        require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n        market.recall(amount);\n        dola.burn(amount);\n        supplies[market] -= amount;\n        globalSupply -= amount;\n        emit Contraction(market, amount);\n    }\n"
                ],
                "Type": " Market pause is not checked during  contraction ",
                "Description": "\nIn the Fed contract, during the expansion method is checked that the market is not paused, this requirement is not done during the contraction.\n\ndiff\n    function contraction(IMarket market, uint amount) public {\n        require(msg.sender == chair, \"ONLY CHAIR\");\n        require(dbr.markets(address(market)), \"UNSUPPORTED MARKET\");\n+       require(!market.borrowPaused(), \"CANNOT EXPAND PAUSED MARKETS\");\n        uint supply = supplies[market];\n        require(amount <= supply, \"AMOUNT TOO BIG\"); // can't burn profits\n        market.recall(amount);\n        dola.burn(amount);\n        supplies[market] -= amount;\n        globalSupply -= amount;\n        emit Contraction(market, amount);\n    }\n\n\n\n*   Fed.sol:105(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Fed.sol#L105)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../Test.sol\";\n\ncontract StdCheatsTest is Test {\n    Bar test;\n\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testSkip() public {\n        vm.warp(100);\n        skip(25);\n        assertEq(block.timestamp, 125);\n    }\n\n    function testRewind() public {\n        vm.warp(100);\n        rewind(25);\n        assertEq(block.timestamp, 75);\n    }\n\n    function testHoax() public {\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n    }\n\n    function testHoaxOrigin() public {\n        hoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n    }\n\n    function testHoaxDifferentAddresses() public {\n        hoax(address(1337), address(7331));\n        test.origin{value: 100}(address(1337), address(7331));\n    }\n\n    function testStartHoax() public {\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function testStartHoaxOrigin() public {\n        startHoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n        test.origin{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function testChangePrank() public {\n        vm.startPrank(address(1337));\n        test.bar(address(1337));\n        changePrank(address(0xdead));\n        test.bar(address(0xdead));\n        changePrank(address(1337));\n        test.bar(address(1337));\n        vm.stopPrank();\n    }\n\n    function testDeal() public {\n        deal(address(this), 1 ether);\n        assertEq(address(this).balance, 1 ether);\n    }\n\n    function testDealToken() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n    }\n\n    function testDealTokenAdjustTS() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18, true);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n        assertEq(barToken.totalSupply(), 20000e18);\n        deal(bar, address(this), 0, true);\n        assertEq(barToken.balanceOf(address(this)), 0);\n        assertEq(barToken.totalSupply(), 10000e18);\n    }\n\n    function testBound() public {\n        assertEq(bound(5, 0, 4), 0);\n        assertEq(bound(0, 69, 69), 69);\n        assertEq(bound(0, 68, 69), 68);\n        assertEq(bound(10, 150, 190), 160);\n        assertEq(bound(300, 2800, 3200), 3100);\n        assertEq(bound(9999, 1337, 6666), 6006);\n    }\n\n    function testCannotBoundMaxLessThanMin() public {\n        vm.expectRevert(bytes(\"Test bound(uint256,uint256,uint256): Max is less than min.\"));\n        bound(5, 100, 10);\n    }\n\n    function testBound(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 bounded = bound(num, min, max);\n\n        assertGe(bounded, min);\n        assertLe(bounded, max);\n    }\n\n    function testBoundUint256Max() public {\n        assertEq(bound(0, type(uint256).max - 1, type(uint256).max), type(uint256).max - 1);\n        assertEq(bound(1, type(uint256).max - 1, type(uint256).max), type(uint256).max);\n    }\n\n    function testCannotBoundMaxLessThanMin(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        vm.assume(min > max);\n        vm.expectRevert(bytes(\"Test bound(uint256,uint256,uint256): Max is less than min.\"));\n        bound(num, min, max);\n    }\n\n    function testDeployCode() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\", bytes(\"\"));\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n    }\n\n    function testDeployCodeNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\");\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n    }\n\n    // We need that payable constructor in order to send ETH on construction\n    constructor() payable {}\n\n    function testDeployCodeVal() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\", bytes(\"\"), 1 ether);\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n\tassertEq(deployed.balance, 1 ether);\n    }\n\n    function testDeployCodeValNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\", 1 ether);\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n\tassertEq(deployed.balance, 1 ether);\n    }\n\n    // We need this so we can call \"this.deployCode\" rather than \"deployCode\" directly\n    function deployCodeHelper(string memory what) external {\n        deployCode(what);\n    }\n    \n    function testDeployCodeFail() public {\n        vm.expectRevert(bytes(\"Test deployCode(string): Deployment failed.\"));\n        this.deployCodeHelper(\"StdCheats.t.sol:RevertingContract\");\n    }\n\n    function getCode(address who) internal view returns (bytes memory o_code) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(who)\n            // allocate output byte array - this could also be done without assembly\n            // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n            // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            // store length in memory\n            mstore(o_code, size)\n            // actually retrieve the code, this needs assembly\n            extcodecopy(who, add(o_code, 0x20), 0, size)\n        }\n    }\n}\n\ncontract Bar {\n    constructor() {\n        /// `DEAL` STDCHEAT\n        totalSupply = 10000e18;\n        balanceOf[address(this)] = totalSupply;\n    }\n\n    /// `HOAX` STDCHEATS\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n    function origin(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedSender, \"!prank\");\n    }\n    function origin(address expectedSender, address expectedOrigin) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedOrigin, \"!prank\");\n    }\n\n    /// `DEAL` STDCHEAT\n    mapping (address => uint256) public balanceOf;\n    uint256 public totalSupply;\n}\n\ncontract RevertingContract {\n    constructor() {\n        revert();\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/**\n@title Dola Borrow Rights\n@notice The DolaBorrowRights contract is a non-standard ERC20 token, that gives the right of holders to borrow DOLA at 0% interest.\n As a borrower takes on DOLA debt, their DBR balance will be exhausted at 1 DBR per 1 DOLA borrowed per year.\n*/\ncontract DolaBorrowingRights {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public _totalSupply;\n    address public operator;\n    address public pendingOperator;\n    uint public totalDueTokensAccrued;\n    uint public replenishmentPriceBps;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    mapping (address => bool) public minters;\n    mapping (address => bool) public markets;\n    mapping (address => uint) public debts; // user => debt across all tracked markets\n    mapping (address => uint) public dueTokensAccrued; // user => amount of due tokens accrued\n    mapping (address => uint) public lastUpdated; // user => last update timestamp\n\n    constructor(\n        uint _replenishmentPriceBps,\n        string memory _name,\n        string memory _symbol,\n        address _operator\n    ) {\n        replenishmentPriceBps = _replenishmentPriceBps;\n        name = _name;\n        symbol = _symbol;\n        operator = _operator;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets pending operator of the contract. Operator role must be claimed by the new oprator. Only callable by Operator.\n    @param newOperator_ The address of the newOperator\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator {\n        pendingOperator = newOperator_;\n    }\n\n    /**\n    @notice Sets the replenishment price in basis points. Replenishment price denotes the increase in DOLA debt upon forced replenishments.\n     At 10000, the cost of replenishing 1 DBR is 1 DOLA in debt. Only callable by Operator.\n    @param newReplenishmentPriceBps_ The new replen\n    */\n    function setReplenishmentPriceBps(uint newReplenishmentPriceBps_) public onlyOperator {\n        require(newReplenishmentPriceBps_ > 0, \"replenishment price must be over 0\");\n        replenishmentPriceBps = newReplenishmentPriceBps_;\n    }\n    \n    /**\n    @notice claims the Operator role if set as pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Add a minter to the set of addresses allowed to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address of the new minter.\n    */\n    function addMinter(address minter_) public onlyOperator {\n        minters[minter_] = true;\n        emit AddMinter(minter_);\n    }\n\n    /**\n    @notice Removes a minter from the set of addresses allowe to mint DBR tokens. Only callable by Operator.\n    @param minter_ The address to be removed from the minter set.\n    */\n    function removeMinter(address minter_) public onlyOperator {\n        minters[minter_] = false;\n        emit RemoveMinter(minter_);\n    }\n    /**\n    @notice Adds a market to the set of active markets. Only callable by Operator.\n    @dev markets can be added but cannot be removed. A removed market would result in unrepayable debt for some users.\n    @param market_ The address of the new market contract to be added.\n    */\n    function addMarket(address market_) public onlyOperator {\n        markets[market_] = true;\n        emit AddMarket(market_);\n    }\n\n    /**\n    @notice Get the total supply of DBR tokens.\n    @dev The total supply is calculated as the difference between total DBR minted and total DBR accrued.\n    @return uint representing the total supply of DBR.\n    */\n    function totalSupply() public view returns (uint) {\n        if(totalDueTokensAccrued > _totalSupply) return 0;\n        return _totalSupply - totalDueTokensAccrued;\n    }\n\n    /**\n    @notice Get the DBR balance of an address. Will return 0 if the user has zero DBR or a deficit.\n    @dev The balance of a user is calculated as the difference between the user's balance and the user's accrued DBR debt + due DBR debt.\n    @param user Address of the user.\n    @return uint representing the balance of the user.\n    */\n    function balanceOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued > balances[user]) return 0;\n        return balances[user] - dueTokensAccrued[user] - accrued;\n    }\n\n    /**\n    @notice Get the DBR deficit of an address. Will return 0 if th user has zero DBR or more.\n    @dev The deficit of a user is calculated as the difference between the user's accrued DBR deb + due DBR debt and their balance.\n    @param user Address of the user.\n    @return uint representing the deficit of the user.\n    */\n    function deficitOf(address user) public view returns (uint) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        if(dueTokensAccrued[user] + accrued < balances[user]) return 0;\n        return dueTokensAccrued[user] + accrued - balances[user];\n    }\n    \n    /**\n    @notice Get the signed DBR balance of an address.\n    @dev This function will revert if a user has a balance of more than 2^255-1 DBR\n    @param user Address of the user.\n    @return Returns a signed int of the user's balance\n    */\n    function signedBalanceOf(address user) public view returns (int) {\n        uint debt = debts[user];\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        return int(balances[user]) - int(dueTokensAccrued[user]) - int(accrued);\n    }\n\n    /**\n    @notice Approves spender to spend amount of DBR on behalf of the message sender.\n    @param spender Address of the spender to be approved\n    @param amount Amount to be approved to spend\n    @return Always returns true, will revert if not successful.\n    */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfers amount to address to from message sender.\n    @param to The address to transfer to\n    @param amount The amount of DBR to transfer\n    @return Always returns true, will revert if not successful.\n    */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Transfer amount of DBR  on behalf of address from to address to. Message sender must have a sufficient allowance from the from address.\n    @dev Allowance is reduced by the amount transferred.\n    @param from Address to transfer from.\n    @param to Address to transfer to.\n    @param amount Amount of DBR to transfer.\n    @return Always returns true, will revert if not successful.\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n    @notice Permits an address to spend on behalf of another address via a signed message.\n    @dev Can be bundled with a transferFrom call, to reduce transaction load on users.\n    @param owner Address of the owner permitting the spending\n    @param spender Address allowed to spend on behalf of owner.\n    @param value Amount to be allowed to spend.\n    @param deadline Timestamp after which the signed message is no longer valid.\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n    @notice Function for invalidating the nonce of a signed message.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice Accrue due DBR debt of user\n    @dev DBR debt is accrued at a rate of 1 DBR per 1 DOLA of debt per year.\n    @param user The address of the user to accrue DBR debt to.\n    */\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n\n    /**\n    @notice Function to be called by markets when a borrow occurs.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt.\n    @param user The address of the borrower\n    @param additionalDebt The additional amount of DOLA the user is borrowing\n    */\n    function onBorrow(address user, uint additionalDebt) public {\n        require(markets[msg.sender], \"Only markets can call onBorrow\");\n        accrueDueTokens(user);\n        require(deficitOf(user) == 0, \"DBR Deficit\");\n        debts[user] += additionalDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a repayment occurs.\n    @dev Accrues due tokens on behalf of the user, before reducing their debt.\n    @param user The address of the borrower having their debt repaid\n    @param repaidDebt The amount of DOLA repaid\n    */\n    function onRepay(address user, uint repaidDebt) public {\n        require(markets[msg.sender], \"Only markets can call onRepay\");\n        accrueDueTokens(user);\n        debts[user] -= repaidDebt;\n    }\n\n    /**\n    @notice Function to be called by markets when a force replenish occurs. This function can only be called if the user has a DBR deficit.\n    @dev Accrues due tokens on behalf of the user, before increasing their debt by the replenishment price and minting them new DBR.\n    @param user The user to be force replenished.\n    @param amount The amount of DBR the user will be force replenished.\n    */\n    function onForceReplenish(address user, uint amount) public {\n        require(markets[msg.sender], \"Only markets can call onForceReplenish\");\n        uint deficit = deficitOf(user);\n        require(deficit > 0, \"No deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * replenishmentPriceBps / 10000;\n        accrueDueTokens(user);\n        debts[user] += replenishmentCost;\n        _mint(user, amount);\n    }\n\n    /**\n    @notice Function for burning DBR from message sender, reducing supply.\n    @param amount Amount to be burned\n    */\n    function burn(uint amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n    @notice Function for minting new DBR, increasing supply. Only callable by minters and the operator.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function mint(address to, uint amount) public {\n        require(minters[msg.sender] == true || msg.sender == operator, \"ONLY MINTERS OR OPERATOR\");\n        _mint(to, amount);\n    }\n\n    /**\n    @notice Internal function for minting DBR.\n    @param to Address to mint DBR to.\n    @param amount Amount of DBR to mint.\n    */\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n        unchecked {\n            balances[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n    @notice Internal function for burning DBR.\n    @param from Address to burn DBR from.\n    @param amount Amount of DBR to be burned.\n    */\n    function _burn(address from, uint256 amount) internal virtual {\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        unchecked {\n            _totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event AddMinter(address indexed minter);\n    event RemoveMinter(address indexed minter);\n    event AddMarket(address indexed market);\n    event ChangeOperator(address indexed newOperator);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n",
        "CodeNames": [
            "StdCheats.t.sol",
            "DBR.sol",
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "8",
                "Location": [
                    "replenishmentIncentiveBps",
                    "_replenishmentPriceBps",
                    "constructor"
                ],
                "Type": " Lack of checks the integer ranges",
                "Description": "\nThe following methods lack checks on the following integer arguments, you can see the recommendations above.\n\n\n_replenishmentPriceBps is not checked to be != 0 during the constructor, nevertheless it's checked in setReplenishmentPriceBps(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/DBR.sol#L63)\n\n*   DBR.sol:36(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/DBR.sol#L36)\n\nreplenishmentIncentiveBps is not checked to be  0 during the constructor, nevertheless it's checked in setReplenismentIncentiveBps(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L173)\n\n*   Market.sol:76(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L76)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n    function delegate(address delegatee) external;\n    function delegates(address delegator) external view returns (address delegatee);\n}\n\n/**\n@title Gov Token Escrow\n@notice Collateral is stored in unique escrow contracts for every user and every market.\n This specific escrow is meant as an example of how an escrow can be implemented that allows depositors to delegate votes with their collateral, unlike pooled deposit protocols.\n@dev Caution: This is a proxy implementation. Follow proxy pattern best practices\n*/\ncontract GovTokenEscrow {\n    address public market;\n    IERC20 public token;\n    address public beneficiary;\n\n    /**\n    @notice Initialize escrow with a token\n    @dev Must be called right after proxy is created.\n    @param _token The IERC20 token representing the governance token\n    @param _beneficiary The beneficiary who may delegate token voting power\n    */\n    function initialize(IERC20 _token, address _beneficiary) public {\n        require(market == address(0), \"ALREADY INITIALIZED\");\n        market = msg.sender;\n        token = _token;\n        beneficiary = _beneficiary;\n        _token.delegate(_token.delegates(_beneficiary));\n    }\n\n    /**\n    @notice Transfers the associated ERC20 token to a recipient.\n    @param recipient The address to receive payment from the escrow\n    @param amount The amount of ERC20 token to be transferred.\n    */\n    function pay(address recipient, uint amount) public {\n        require(msg.sender == market, \"ONLY MARKET\");\n        token.transfer(recipient, amount);\n    }\n\n    /**\n    @notice Get the token balance of the escrow\n    @return Uint representing the INV token balance of the escrow including the additional INV accrued from xINV\n    */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    /* Uncomment if Escrow contract should handle on deposit callbacks. This function should remain callable by anyone to handle direct inbound transfers.\n    function onDeposit() public {\n\n    }\n    */\n\n    /**\n    @notice Delegates voting power of the underlying xINV.\n    @param delegatee The address to be delegated voting power\n    */\n    function delegate(address delegatee) public {\n        require(msg.sender == beneficiary);\n        token.delegate(delegatee);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n",
        "CodeNames": [
            "GovTokenEscrow.sol",
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "3",
                "Location": [
                    "IERC",
                    "delegates",
                    "delegate"
                ],
                "Type": " Bad nomenclature",
                "Description": "\nThe interface IERC20 contains two methdos that are not pressent in the official ERC20, delegate and delegates, it's recommended to change the name of the contract because not any ERC20 it's valid.\n\n\n*   GovTokenEscrow.sol:9-10(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/escrows/GovTokenEscrow.sol#L9-L10)\n*   INVEscrow.sol:10-11(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/escrows/INVEscrow.sol#L10-L11)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "demo.sol",
            "test.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "6",
                "Location": [
                    "internal",
                    "require()"
                ],
                "Type": " Avoid hardcoded values",
                "Description": "\nIt is not good practice to hardcode values, but if you are dealing with addresses much less, these can change between implementations, networks or projects, so it is convenient to remove these values from the source code.\n\n\n*   Market.sol:44(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L44)\n\nIt's recommended to create a factor variable for 10000:\n\n*   Market.sol:74-76(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L74-L76)\n*   Market.sol:150(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L150)\n*   Market.sol:162(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L162)\n*   Market.sol:173(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L173)\n*   Market.sol:184(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L184)\n*   Market.sol:195(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L195)\n*   Market.sol:336(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L336)\n*   Market.sol:346(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L346)\n*   Market.sol:360(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L360)\n*   Market.sol:377(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L377)\n*   Market.sol:563-564(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L563-L564)\n*   Market.sol:583(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L583)\n*   Market.sol:595-606(https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L595-L606)\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 55 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-10-inverse-findings/issues/368) by pfapostol received the top score from the judge.\n\n*The following wardens also submitted reports: mcwildy(https://github.com/code-423n4/2022-10-inverse-findings/issues/604), sakman(https://github.com/code-423n4/2022-10-inverse-findings/issues/595), JC(https://github.com/code-423n4/2022-10-inverse-findings/issues/592), tnevler(https://github.com/code-423n4/2022-10-inverse-findings/issues/559), ajtra(https://github.com/code-423n4/2022-10-inverse-findings/issues/554), adriro(https://github.com/code-423n4/2022-10-inverse-findings/issues/539), \nhorsefacts(https://github.com/code-423n4/2022-10-inverse-findings/issues/532), c3phas(https://github.com/code-423n4/2022-10-inverse-findings/issues/528), Aymen0909(https://github.com/code-423n4/2022-10-inverse-findings/issues/515), KoKo(https://github.com/code-423n4/2022-10-inverse-findings/issues/505), ReyAdmirado(https://github.com/code-423n4/2022-10-inverse-findings/issues/497), djxploit(https://github.com/code-423n4/2022-10-inverse-findings/issues/492), robee(https://github.com/code-423n4/2022-10-inverse-findings/issues/490), gogo(https://github.com/code-423n4/2022-10-inverse-findings/issues/488), JrNet(https://github.com/code-423n4/2022-10-inverse-findings/issues/485), 0xRoxas(https://github.com/code-423n4/2022-10-inverse-findings/issues/475), enckrish(https://github.com/code-423n4/2022-10-inverse-findings/issues/471), Amithuddar(https://github.com/code-423n4/2022-10-inverse-findings/issues/465), CloudX(https://github.com/code-423n4/2022-10-inverse-findings/issues/451), karanctf(https://github.com/code-423n4/2022-10-inverse-findings/issues/411), Deivitto(https://github.com/code-423n4/2022-10-inverse-findings/issues/380), Chandr(https://github.com/code-423n4/2022-10-inverse-findings/issues/369), HardlyCodeMan(https://github.com/code-423n4/2022-10-inverse-findings/issues/355), __141345__(https://github.com/code-423n4/2022-10-inverse-findings/issues/344), shark(https://github.com/code-423n4/2022-10-inverse-findings/issues/326), Shinchan(https://github.com/code-423n4/2022-10-inverse-findings/issues/322), 0xSmartContract(https://github.com/code-423n4/2022-10-inverse-findings/issues/313), sakshamguruji(https://github.com/code-423n4/2022-10-inverse-findings/issues/312), Rolezn(https://github.com/code-423n4/2022-10-inverse-findings/issues/282), ElKu(https://github.com/code-423n4/2022-10-inverse-findings/issues/259), oyc_109(https://github.com/code-423n4/2022-10-inverse-findings/issues/256), kaden(https://github.com/code-423n4/2022-10-inverse-findings/issues/226), carlitox477(https://github.com/code-423n4/2022-10-inverse-findings/issues/213), B2(https://github.com/code-423n4/2022-10-inverse-findings/issues/194), ch0bu(https://github.com/code-423n4/2022-10-inverse-findings/issues/169), martin(https://github.com/code-423n4/2022-10-inverse-findings/issues/154), Ozy42(https://github.com/code-423n4/2022-10-inverse-findings/issues/130), cryptostellar5(https://github.com/code-423n4/2022-10-inverse-findings/issues/124), Diana(https://github.com/code-423n4/2022-10-inverse-findings/issues/121), aphak5010(https://github.com/code-423n4/2022-10-inverse-findings/issues/107), 0x1f8b(https://github.com/code-423n4/2022-10-inverse-findings/issues/96), skyle(https://github.com/code-423n4/2022-10-inverse-findings/issues/85), exolorkistis(https://github.com/code-423n4/2022-10-inverse-findings/issues/65), durianSausage(https://github.com/code-423n4/2022-10-inverse-findings/issues/50), Rahoz(https://github.com/code-423n4/2022-10-inverse-findings/issues/47), Bnke0x0(https://github.com/code-423n4/2022-10-inverse-findings/issues/36), ret2basic(https://github.com/code-423n4/2022-10-inverse-findings/issues/34), Dinesh11G(https://github.com/code-423n4/2022-10-inverse-findings/issues/32), ballx(https://github.com/code-423n4/2022-10-inverse-findings/issues/26), fatherOfBlocks(https://github.com/code-423n4/2022-10-inverse-findings/issues/25), chaduke(https://github.com/code-423n4/2022-10-inverse-findings/issues/19), RaymondFam(https://github.com/code-423n4/2022-10-inverse-findings/issues/11), Mathieu(https://github.com/code-423n4/2022-10-inverse-findings/issues/4), and leosathya(https://github.com/code-423n4/2022-10-inverse-findings/issues/3).*\n\n## Summary\n\nGas savings are estimated using the gas report of existing forge test --gas-report tests (the sum of all deployment costs and the sum of the costs of calling methods) and may vary depending on the implementation of the fix.\n\n|        | Issue                                                                                                        | Instances | Estimated gas(deployments) | Estimated gas(min method call) | Estimated gas(avg method call) | Estimated gas(max method call) |\n| :----: | :----------------------------------------------------------------------------------------------------------| :-------: | :------------------------: | :----------------------------: | :----------------------------: | :----------------------------: |\n|  01 | State variables only set in the constructor should be declared immutable                                     |     2     |           117 275          |               104              |               110              |               110              |\n|  02 | Use function instead of modifiers                                                                            |     4     |           115 926          |               162              |              -264              |              -481              |\n|  03 | Duplicated require()/revert() checks should be refactored to a modifier or function                          |     11    |           114 932          |               -59              |              -284              |              -398              |\n|  04 | Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate |     5     |           24 227           |               254              |               533              |             -6 726             |\n|  05 | Expression can be unchecked when overflow is not possible                                                    |     6     |           20 220           |               410              |              4 630             |              1354              |\n|  06 | State variables can be packed into fewer storage slots                                                       |     1     |           -5 008           |              1 911             |             15 525             |             20 972             |\n|  07 | Refactoring similar statements                                                                               |     1     |           18 422           |               -18              |               -11              |                6               |\n|  08 | Better algorithm for underflow check                                                                         |     3     |           12 613           |               656              |              8 332             |              3 741             |\n|  09 | x = x + y is cheaper than x += y                                                                         |     12    |           11 214           |               180              |               468              |               616              |\n| 10 | internal functions only called once can be inlined to save gas                                             |     1     |            5 207           |               67               |               47               |               24               |\n| 11 | State variables should be cached in stack variables rather than re-reading them from storage                 |     2     |            5 007           |               478              |              1 117             |              1 423             |\n|        | Overall gas savings                                                                                      |   48  |     416 802 (6,58%)    |        3 423 (0,34%)       |       15 773 (0,82%)       |       18 283 (0,72%)       |\n\nTotal: 48 instances over 11 issues\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "test.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "0",
                "Location": [
                    "diff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..a357f92 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -338,7 +338,12 @@ contract DolaBorrowingRights {\n  338, 338:     @param amount Amount to be burned\n  339, 339:     */\n  340, 340:     function burn(uint amount) public {\n341     :       _burn(msg.sender, amount);\n+      341:+        require(balanceOf(msg.sender) = amount, \"Insufficient balance\");\n+      342:+        balances[msg.sender] -= amount;\n+      343:+        unchecked {\n+      344:+            _totalSupply -= amount;\n+      345:+        }\n+      346:+        emit Transfer(msg.sender, address(0), amount);\n  342, 347:     }\n  343, 348: \n  344, 349:     /\n@@ -364,20 +369,6 @@ contract DolaBorrowingRights {\n  364, 369:         emit Transfer(address(0), to, amount);\n  365, 370:     }\n  366, 371: \n367     :   /\n368     :   @notice Internal function for burning DBR.\n369     :   @param from Address to burn DBR from.\n370     :   @param amount Amount of DBR to be burned.\n371     :   */\n372     :   function _burn(address from, uint256 amount) internal virtual {\n373     :       require(balanceOf(from) = amount, \"Insufficient balance\");\n374     :       balances[from] -= amount;\n375     :       unchecked {\n376     :           _totalSupply -= amount;\n377     :       }\n378     :       emit Transfer(from, address(0), amount);\n379     :   }\n380     :-\n  381, 372:     event Transfer(address indexed from, address indexed to, uint256 amount);\n  382, 373:     event Approval(address indexed owner, address indexed spender, uint256 amount);\n  383, 374:     event AddMinter(address indexed minter);\n"
                ],
                "Type": "  internal  functions only called once can be inlined to save gas (1 instance)",
                "Description": "\nDeployment. Gas Saved: 5 207\n\nMinimum Method Call. Gas Saved: 67\n\nAverage Method Call. Gas Saved: 47\n\nMaximum Method Call. Gas Saved: 24\n\nOverall gas change: -137 (-0.154%)\n\n\ndiff\ndiff --git a/src/DBR.sol b/src/DBR.sol\nindex aab6daf..a357f92 100644\n--a/src/DBR.sol\n+++ b/src/DBR.sol\n@@ -338,7 +338,12 @@ contract DolaBorrowingRights {\n  338, 338:     @param amount Amount to be burned\n  339, 339:     */\n  340, 340:     function burn(uint amount) public {\n341     :       _burn(msg.sender, amount);\n+      341:+        require(balanceOf(msg.sender) = amount, \"Insufficient balance\");\n+      342:+        balances[msg.sender] -= amount;\n+      343:+        unchecked {\n+      344:+            _totalSupply -= amount;\n+      345:+        }\n+      346:+        emit Transfer(msg.sender, address(0), amount);\n  342, 347:     }\n  343, 348: \n  344, 349:     /\n@@ -364,20 +369,6 @@ contract DolaBorrowingRights {\n  364, 369:         emit Transfer(address(0), to, amount);\n  365, 370:     }\n  366, 371: \n367     :   /\n368     :   @notice Internal function for burning DBR.\n369     :   @param from Address to burn DBR from.\n370     :   @param amount Amount of DBR to be burned.\n371     :   */\n372     :   function _burn(address from, uint256 amount) internal virtual {\n373     :       require(balanceOf(from) = amount, \"Insufficient balance\");\n374     :       balances[from] -= amount;\n375     :       unchecked {\n376     :           _totalSupply -= amount;\n377     :       }\n378     :       emit Transfer(from, address(0), amount);\n379     :   }\n380     :-\n  381, 372:     event Transfer(address indexed from, address indexed to, uint256 amount);\n  382, 373:     event Approval(address indexed owner, address indexed spender, uint256 amount);\n  383, 374:     event AddMinter(address indexed minter);\n\n\n\n",
                "Repair": ""
            }
        ]
    }
]