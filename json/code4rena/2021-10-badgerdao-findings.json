[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./escrow/EscrowUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Simple implementation of a\n * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]\n * strategy, where the paying contract doesn't interact directly with the\n * receiver account, which must withdraw its payments itself.\n *\n * Pull-payments are often considered the best practice when it comes to sending\n * Ether, security-wise. It prevents recipients from blocking execution, and\n * eliminates reentrancy concerns.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * To use, derive from the `PullPayment` contract, and use {_asyncTransfer}\n * instead of Solidity's `transfer` function. Payees can query their due\n * payments with {payments}, and retrieve them with {withdrawPayments}.\n */\ncontract PullPaymentUpgradeable is Initializable {\n    EscrowUpgradeable private _escrow;\n\n    function __PullPayment_init() internal initializer {\n        __PullPayment_init_unchained();\n    }\n\n    function __PullPayment_init_unchained() internal initializer {\n        _escrow = new EscrowUpgradeable();\n        _escrow.initialize();\n    }\n\n    /**\n     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.\n     *\n     * Note that _any_ account can call this function, not just the `payee`.\n     * This means that contracts unaware of the `PullPayment` protocol can still\n     * receive funds this way, by having a separate account call\n     * {withdrawPayments}.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee Whose payments will be withdrawn.\n     */\n    function withdrawPayments(address payable payee) public virtual {\n        _escrow.withdraw(payee);\n    }\n\n    /**\n     * @dev Returns the payments owed to an address.\n     * @param dest The creditor's address.\n     */\n    function payments(address dest) public view returns (uint256) {\n        return _escrow.depositsOf(dest);\n    }\n\n    /**\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\n     * Funds sent in this way are stored in an intermediate {Escrow} contract, so\n     * there is no danger of them being spent before withdrawal.\n     *\n     * @param dest The destination address of the funds.\n     * @param amount The amount to transfer.\n     */\n    function _asyncTransfer(address dest, uint256 amount) internal virtual {\n        _escrow.deposit{ value: amount }(dest);\n    }\n    uint256[49] private __gap;\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface ICore {\n    function mint(\n        uint256 btc,\n        address account,\n        bytes32[] calldata merkleProof\n    ) external returns (uint256);\n\n    function redeem(uint256 btc, address account) external returns (uint256);\n\n    function btcToBbtc(uint256 btc) external view returns (uint256, uint256);\n\n    function bBtcToBtc(uint256 bBtc) external view returns (uint256 btc, uint256 fee);\n\n    function pricePerShare() external view returns (uint256);\n\n    function setGuestList(address guestlist) external;\n\n    function collectFee() external;\n\n    function owner() external view returns (address);\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.6.12;\n\nimport \"../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./ICoreOracle.sol\";\n\n/*\n    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)\n*/\ncontract WrappedIbbtc is Initializable, ERC20Upgradeable {\n    address public governance;\n    address public pendingGovernance;\n    ERC20Upgradeable public ibbtc; \n\n    ICoreOracle public oracle;\n\n    event SetOracle(address oracle);\n    event SetPendingGovernance(address pendingGovernance);\n    event AcceptPendingGovernance(address pendingGovernance);\n\n    /// ===== Modifiers =====\n    modifier onlyPendingGovernance() {\n        require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"onlyGovernance\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == address(oracle), \"onlyOracle\");\n        _;\n    }\n\n    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n        governance = _governance;\n        oracle = ICoreOracle(_oracle);\n        ibbtc = ERC20Upgradeable(_ibbtc);\n\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Governance =====\n    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {\n        pendingGovernance = _pendingGovernance;\n        emit SetPendingGovernance(pendingGovernance);\n    }\n\n    function setOracle(address _oracle) external onlyGovernance {\n        oracle = ICoreOracle(_oracle);\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Pending Governance =====\n    function acceptPendingGovernance() external onlyPendingGovernance {\n        governance = pendingGovernance;\n        emit AcceptPendingGovernance(pendingGovernance);\n    }\n\n    /// ===== Permissionless Calls =====\n\n    /// @dev Deposit ibBTC to mint wibBTC shares\n    function mint(uint256 _shares) external {\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n        _mint(_msgSender(), _shares);\n    }\n\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n    function burn(uint256 _shares) external {\n        _burn(_msgSender(), _shares);\n        require(ibbtc.transfer(_msgSender(), _shares));\n    }\n\n    /// ===== Transfer Overrides =====\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\n    /// ===== View Methods =====\n\n    /// @dev Current pricePerShare read live from oracle\n    function pricePerShare() public view virtual returns (uint256) {\n        return oracle.pricePerShare();\n    }\n\n    /// @dev Wrapped ibBTC shares of account\n    function sharesOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @dev Current account shares * pricePerShare\n    function balanceOf(address account) public view override returns (uint256) {\n        return sharesOf(account).mul(pricePerShare()).div(1e18);\n    }\n\n    /// @dev Total wrapped ibBTC shares\n    function totalShares() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev Current total shares * pricePerShare\n    function totalSupply() public view override returns (uint256) {\n        return totalShares().mul(pricePerShare()).div(1e18);\n    }\n\n    function balanceToShares(uint256 balance) public view returns (uint256) {\n        return balance.mul(1e18).div(pricePerShare());\n    }\n\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\n        return shares.mul(pricePerShare()).div(1e18);\n    }\n}\n\n\n",
        "CodeNames": [
            "PullPaymentUpgradeable.sol",
            "ICore.sol",
            "WrappedIbbtc.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "ibBTC",
                    "wibBTC",
                    "pricePerShare",
                    "sync()"
                ],
                "Type": " The design of  wibBTC  is not fully compatible with the current Curve StableSwap pool",
                "Description": "\nPer the documentation, wibBTC is designed for a Curve StableSwap pool. However, the design of wibBTC makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.\n\nSpecifically, a Curve StableSwap pool will maintain the balances of its coins based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.\n\nThe pool's actual dynamic balance of wibBTC will deviate from the recorded balance in the pool contract as the pricePerShare increases.\n\nFurthermore, there is no such way in Curve StableSwap similar to the sync() function of UNI v2, which will force sync the stored reserves to match the balances.\n\nGiven:\n\n*   The current pricePerShare is: 1;\n*   The Curve pool is newly created with 0 liquidity;\n\n1.  Alice added 100 wibBTC and 100 wBTC to the Curve pool; Alice holds 100% of the pool;\n2.  After 1 month with no activity (no other users, no trading), and the pricePerShare of ibBTC increases to 1.2;\n3.  Alice removes all the liquidity from the Curve pool.\n\nWhile it's expected to receive 150 wibBTC and 100 wBTC, Alice actually can only receive 100 wibBTC and 100 wBTC.\n\n",
                "Repair": "Consider creating a revised version of the Curve StableSwap contract that can handle dynamic balances properly.\n\ndapp-whisperer (BadgerDAO) confirmed(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/65#issuecomment-963668495):\n  We will be creating a custom pool that takes this into account based on the rate_multiplier variable on the MetaPools.\n * Draft implementation(https://github.com/shuklaayush/ibbtc-curve-zap/commit/36f5900bb276a61a2f85425f496c1ba99c1ddd7c)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface ICore {\n    function mint(\n        uint256 btc,\n        address account,\n        bytes32[] calldata merkleProof\n    ) external returns (uint256);\n\n    function redeem(uint256 btc, address account) external returns (uint256);\n\n    function btcToBbtc(uint256 btc) external view returns (uint256, uint256);\n\n    function bBtcToBtc(uint256 bBtc) external view returns (uint256 btc, uint256 fee);\n\n    function pricePerShare() external view returns (uint256);\n\n    function setGuestList(address guestlist) external;\n\n    function collectFee() external;\n\n    function owner() external view returns (address);\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.6.12;\n\nimport \"../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./ICoreOracle.sol\";\n\n/*\n    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)\n*/\ncontract WrappedIbbtc is Initializable, ERC20Upgradeable {\n    address public governance;\n    address public pendingGovernance;\n    ERC20Upgradeable public ibbtc; \n\n    ICoreOracle public oracle;\n\n    event SetOracle(address oracle);\n    event SetPendingGovernance(address pendingGovernance);\n    event AcceptPendingGovernance(address pendingGovernance);\n\n    /// ===== Modifiers =====\n    modifier onlyPendingGovernance() {\n        require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"onlyGovernance\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == address(oracle), \"onlyOracle\");\n        _;\n    }\n\n    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n        governance = _governance;\n        oracle = ICoreOracle(_oracle);\n        ibbtc = ERC20Upgradeable(_ibbtc);\n\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Governance =====\n    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {\n        pendingGovernance = _pendingGovernance;\n        emit SetPendingGovernance(pendingGovernance);\n    }\n\n    function setOracle(address _oracle) external onlyGovernance {\n        oracle = ICoreOracle(_oracle);\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Pending Governance =====\n    function acceptPendingGovernance() external onlyPendingGovernance {\n        governance = pendingGovernance;\n        emit AcceptPendingGovernance(pendingGovernance);\n    }\n\n    /// ===== Permissionless Calls =====\n\n    /// @dev Deposit ibBTC to mint wibBTC shares\n    function mint(uint256 _shares) external {\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n        _mint(_msgSender(), _shares);\n    }\n\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n    function burn(uint256 _shares) external {\n        _burn(_msgSender(), _shares);\n        require(ibbtc.transfer(_msgSender(), _shares));\n    }\n\n    /// ===== Transfer Overrides =====\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\n    /// ===== View Methods =====\n\n    /// @dev Current pricePerShare read live from oracle\n    function pricePerShare() public view virtual returns (uint256) {\n        return oracle.pricePerShare();\n    }\n\n    /// @dev Wrapped ibBTC shares of account\n    function sharesOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @dev Current account shares * pricePerShare\n    function balanceOf(address account) public view override returns (uint256) {\n        return sharesOf(account).mul(pricePerShare()).div(1e18);\n    }\n\n    /// @dev Total wrapped ibBTC shares\n    function totalShares() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev Current total shares * pricePerShare\n    function totalSupply() public view override returns (uint256) {\n        return totalShares().mul(pricePerShare()).div(1e18);\n    }\n\n    function balanceToShares(uint256 balance) public view returns (uint256) {\n        return balance.mul(1e18).div(pricePerShare());\n    }\n\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\n        return shares.mul(pricePerShare()).div(1e18);\n    }\n}\n\n\n",
        "CodeNames": [
            "ICore.sol",
            "WrappedIbbtc.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "approve",
                    "transferFrom",
                    "shares",
                    "transfer(From)",
                    "pricePerShare"
                ],
                "Type": " Approved spender can spend too many tokens",
                "Description": "The approve function has not been overridden and therefore uses the internal *shares*, whereas transfer(From) uses the rebalanced amount.\n\nThe approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with pricePerShare.\n\nMany contracts also use the same amount for the approve call as for the amount they want to have transferred in a subsequent transferFrom call, and in this case, they approve an amount that is too large (as the approved shares amount yields a higher rebalanced amount).\n\n",
                "Repair": "\nThe _allowances field should track the rebalanced amounts such that the approval value does not grow. (This does not actually require overriding the approve function.)\nIn transferFrom, the approvals should then be subtracted by the *transferred* amount, not the amountInShares:\n\nsolidity\n// _allowances are in rebalanced amounts such that they don't grow\n// need to subtract the transferred amount\n_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n\ntabshaikh (Badger) confirmed and resolved(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/43#issuecomment-957197908):\n  Fix here: https://github.com/Badger-Finance/rebasing-ibbtc/pull/7\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "balanceToShares",
                    "transfer",
                    "pricePerShare"
                ],
                "Type": " No sanity check on  pricePerShare  might lead to lost value",
                "Description": "\npricePerShare is read either from an oracle or from ibBTC's core.\n\nIf one of these is bugged or exploited, there are no safety checks to prevent loss of funds.\n\nAs pricePerShare is used to calculate transfer amount, a bug or wrong data retuning a smaller pricePerShare than it really is, could result in drainage of wibbtc from Curve pool.\n\nCurve's swap and remove liquidity functions will both call wibbtc's transfer function:\nhttps://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L790\nhttps://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L831\nThe transfer function calculates the amount to send by calling balanceToShares: WrappedIbbtcEth.sol L127(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L127)\nbalanceToShares calculates the shares (=amount to send) by dividing in pricePerShare: WrappedIbbtcEth.sol L156(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L156)\n\nTherefore, if due to a bug or exploit in ibBTC core / the trusted oracle pricePerShare is smaller than it really is, the amount that will be sent will grow larger. So Curve will send to the user/exploiter doing swap/remove liquidity more tokens that he deserves.\n\nManual analysis, hardhat\n\n",
                "Repair": "Add sanity check:\n\npricePerShare should never decrease but only increase with time (as ibbtc accrues interest) (validated with DefiDollar team). This means that on every pricePerShare read/update, if the new pricePerShare is smaller than the current one, we can discard the update as bad data.\n\nThis will prevent an exploiter from draining Curve pool's wibbtc reserves by decreasing pricePerShare.\n\ndapp-whisperer (BadgerDAO) confirmed(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/68)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface ICore {\n    function mint(\n        uint256 btc,\n        address account,\n        bytes32[] calldata merkleProof\n    ) external returns (uint256);\n\n    function redeem(uint256 btc, address account) external returns (uint256);\n\n    function btcToBbtc(uint256 btc) external view returns (uint256, uint256);\n\n    function bBtcToBtc(uint256 bBtc) external view returns (uint256 btc, uint256 fee);\n\n    function pricePerShare() external view returns (uint256);\n\n    function setGuestList(address guestlist) external;\n\n    function collectFee() external;\n\n    function owner() external view returns (address);\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.6.12;\n\nimport \"../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./ICore.sol\";\n\n/*\n    Wrapped Interest-Bearing Bitcoin (Ethereum mainnet variant)\n*/\ncontract WrappedIbbtcEth is Initializable, ERC20Upgradeable {\n    address public governance;\n    address public pendingGovernance;\n    ERC20Upgradeable public ibbtc; \n    \n    ICore public core;\n\n    uint256 public pricePerShare;\n    uint256 public lastPricePerShareUpdate;\n\n    event SetCore(address core);\n    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);\n    event SetPendingGovernance(address pendingGovernance);\n    event AcceptPendingGovernance(address pendingGovernance);\n\n    /// ===== Modifiers =====\n    modifier onlyPendingGovernance() {\n        require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"onlyGovernance\");\n        _;\n    }\n\n    function initialize(address _governance, address _ibbtc, address _core) public initializer {\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n        governance = _governance;\n        core = ICore(_core);\n        ibbtc = ERC20Upgradeable(_ibbtc);\n\n        updatePricePerShare();\n\n        emit SetCore(_core);\n    }\n\n    /// ===== Permissioned: Governance =====\n    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {\n        pendingGovernance = _pendingGovernance;\n        emit SetPendingGovernance(pendingGovernance);\n    }\n\n    /// @dev The ibBTC token is technically capable of having it's Core contract changed via governance process. This allows the wrapper to adapt.\n    /// @dev This function should be run atomically with setCore() on ibBTC if that eventuality ever arises.\n    function setCore(address _core) external onlyGovernance {\n        core = ICore(_core);\n        emit SetCore(_core);\n    }\n\n    /// ===== Permissioned: Pending Governance =====\n    function acceptPendingGovernance() external onlyPendingGovernance {\n        governance = pendingGovernance;\n        emit AcceptPendingGovernance(pendingGovernance);\n    }\n\n    /// ===== Permissionless Calls =====\n\n    /// @dev Update live ibBTC price per share from core\n    /// @dev We cache this to reduce gas costs of mint / burn / transfer operations.\n    /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date\n    function updatePricePerShare() public virtual returns (uint256) {\n        pricePerShare = core.pricePerShare();\n        lastPricePerShareUpdate = now;\n\n        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);\n    }\n\n    /// @dev Deposit ibBTC to mint wibBTC shares\n    function mint(uint256 _shares) external {\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n        _mint(_msgSender(), _shares);\n    }\n\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n    function burn(uint256 _shares) external {\n        _burn(_msgSender(), _shares);\n        require(ibbtc.transfer(_msgSender(), _shares));\n    }\n\n    /// ===== Transfer Overrides =====\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\n    /// ===== View Methods =====\n\n    /// @dev Wrapped ibBTC shares of account\n    function sharesOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @dev Current account shares * pricePerShare\n    function balanceOf(address account) public view override returns (uint256) {\n        return sharesOf(account).mul(pricePerShare).div(1e18);\n    }\n\n    /// @dev Total wrapped ibBTC shares\n    function totalShares() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev Current total shares * pricePerShare\n    function totalSupply() public view override returns (uint256) {\n        return totalShares().mul(pricePerShare).div(1e18);\n    }\n\n    function balanceToShares(uint256 balance) public view returns (uint256) {\n        return balance.mul(1e18).div(pricePerShare);\n    }\n\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\n        return shares.mul(pricePerShare).div(1e18);\n    }\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.6.12;\n\nimport \"../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./ICoreOracle.sol\";\n\n/*\n    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)\n*/\ncontract WrappedIbbtc is Initializable, ERC20Upgradeable {\n    address public governance;\n    address public pendingGovernance;\n    ERC20Upgradeable public ibbtc; \n\n    ICoreOracle public oracle;\n\n    event SetOracle(address oracle);\n    event SetPendingGovernance(address pendingGovernance);\n    event AcceptPendingGovernance(address pendingGovernance);\n\n    /// ===== Modifiers =====\n    modifier onlyPendingGovernance() {\n        require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"onlyGovernance\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == address(oracle), \"onlyOracle\");\n        _;\n    }\n\n    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n        governance = _governance;\n        oracle = ICoreOracle(_oracle);\n        ibbtc = ERC20Upgradeable(_ibbtc);\n\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Governance =====\n    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {\n        pendingGovernance = _pendingGovernance;\n        emit SetPendingGovernance(pendingGovernance);\n    }\n\n    function setOracle(address _oracle) external onlyGovernance {\n        oracle = ICoreOracle(_oracle);\n        emit SetOracle(_oracle);\n    }\n\n    /// ===== Permissioned: Pending Governance =====\n    function acceptPendingGovernance() external onlyPendingGovernance {\n        governance = pendingGovernance;\n        emit AcceptPendingGovernance(pendingGovernance);\n    }\n\n    /// ===== Permissionless Calls =====\n\n    /// @dev Deposit ibBTC to mint wibBTC shares\n    function mint(uint256 _shares) external {\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n        _mint(_msgSender(), _shares);\n    }\n\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n    function burn(uint256 _shares) external {\n        _burn(_msgSender(), _shares);\n        require(ibbtc.transfer(_msgSender(), _shares));\n    }\n\n    /// ===== Transfer Overrides =====\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        /// @dev the _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible\n\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\n    /// ===== View Methods =====\n\n    /// @dev Current pricePerShare read live from oracle\n    function pricePerShare() public view virtual returns (uint256) {\n        return oracle.pricePerShare();\n    }\n\n    /// @dev Wrapped ibBTC shares of account\n    function sharesOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @dev Current account shares * pricePerShare\n    function balanceOf(address account) public view override returns (uint256) {\n        return sharesOf(account).mul(pricePerShare()).div(1e18);\n    }\n\n    /// @dev Total wrapped ibBTC shares\n    function totalShares() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev Current total shares * pricePerShare\n    function totalSupply() public view override returns (uint256) {\n        return totalShares().mul(pricePerShare()).div(1e18);\n    }\n\n    function balanceToShares(uint256 balance) public view returns (uint256) {\n        return balance.mul(1e18).div(pricePerShare());\n    }\n\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\n        return shares.mul(pricePerShare()).div(1e18);\n    }\n}\n\n\n",
        "CodeNames": [
            "ICore.sol",
            "WrappedIbbtcEth.sol",
            "WrappedIbbtc.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "SetPricePerShare",
                    "balanceToShares",
                    "burn()",
                    "mint()",
                    "pricePerShare",
                    "updatePricePerShare"
                ],
                "Type": "  WrappedIbbtcEth  contract will use stalled price for mint/burn if  updatePricePerShare  wasn't run properly",
                "Description": "\n\nMalicious user can monitor SetPricePerShare event and, if it was run long enough time ago and market moved, but, since there were no SetPricePerShare fired, the contract's pricePerShare is outdated, so a user can mint() with pricePerShare that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.\n\n\nWrappedIbbtcEth updates pricePerShare variable by externally run updatePricePerShare function. The variable is then used in mint/burn/transfer functions without any additional checks, even if outdated/stalled. This can happen if the external function wasn't run for any reason.\nThe variable is used via balanceToShares function: WrappedIbbtcEth.sol L155(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155)\n\n\nThis is feasible as updatePricePerShare to be run by off-chain script being a part of the system, and malfunction of this script leads to contract exposure by stalling the price. The malfunction can happen both by internal reasons (bugs) and by external ones (any system-level dependencies, network outrages).\nupdatePricePerShare function: WrappedIbbtcEth.sol L72(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72)\n\n",
                "Repair": "The risk comes with system design. Wrapping price updates with contract level variable for gas costs minimization is a viable approach, but it needs to be paired with corner cases handling. One of the ways to reduce the risk is as follows:\n\nIntroduce a threshold variable for maximum time elapsed since last pricePerShare update to WrappedIbbtcEth contract.\n\nThen 2 variants of transferFrom and transfer functions can be introduced, both check condition {now time since last price update < threshold}. If condition holds both variants, do the transfer. If it doesn't, then the first variant reverts, while the second do costly price update.\nI.e. it will be cheap transfer (that works only if price is recent) and full transfer (that is similar to the first when price is recent, but do price update on its own when price is stalled). This way, this full transfer is guaranteed to run and is usually cheap, costing more if price is stalled and it does the update.\n\nAfter this, whenever scheduled price update malfunctions (for example because of network conditions), the risk will be limited by market volatility during threshold time at maximum, i.e. capped.\n\nSee issue page(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/86) for example code:\n\ndapp-whisperer (BadgerDAO) confirmed(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/86#issuecomment-962180704):\n  Agreed, appreciate the thorough breakdown. We will add a \"max staleness\" to the ppfs update.\n\n I do see some merit in the idea of \"updating when needed\" at expense of the next user, but due to interface considerations we'd like to keep that consistent for users. In practice, we will run a bot to ensure timely updates.\n\n The pps updates are small and infrequent.\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "balanceToShares",
                    "pricePerShare",
                    "updatePricePerShare"
                ],
                "Type": "  WrappedIbbtc  and  WrappedIbbtcEth  contracts do not filter out price feed outliers",
                "Description": "\nIf price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user.\nIn the same time it's possible to construct mitigation mechanics for such cases, so user economics would be affected by sustainable price movements only.\nAs price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.\n\nIn WrappedIbbtcEth pricePerShare variable is updated by externally run updatePricePerShare function ([WrappedIbbtcEth.sol L72(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72)), and then used in mint/burn/transfer functions without additional checks via balanceToShares function: WrappedIbbtcEth.sol L155(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155)\n\nIn WrappedIbbtc price is requested via pricePerShare function([WrappedIbbtc.sol L123(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123)), and used in the same way without additional checks via balanceToShares function(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L147).\n\n",
                "Repair": "Introduce a minting/burning query that runs on a schedule, separating user funds contribution and actual mint/burn. With user deposit or burn, the corresponding action to be added to commitment query, which execution for mint or redeem will later be sparked by off-chain script according to fixed schedule.\nThis also can be open to public execution with gas compensation incentive, for example as it's done in Tracer protocol: PoolKeeper.sol L131(https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolKeeper.sol#L131)\n\nFull code of an implementation is too big to include in the report, but viable versions are available publicly (Tracer protocol version can be found at the same repo, implementation/PoolCommitter sol(https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolCommitter.sol)\n).\n\nOnce the scheduled mint/redeem query is added, the additional logic to control for price outliers will become possible there, as in this case mint/redeem execution can be conditioned to happen on calm market only, where various definitions of calm can be implemented.\nOne of the approaches is to keep track of recent prices and require that new price each time be within a threshold from median of their array.\n\nExample:\nsolidity\n// Introduce small price tracking arrays:\nuint256[] private times;\nuint256[] private prices;\n\n// Current position in array\nuint8 curPos;\n\n// Current length, grows from 0 to totalMaxPos as prices are being added\nuint8 curMaxPos;\n\n// Maximum length, we track up to totalMaxPos prices\nuint8 totalMaxPos = 10;\n\n// Price movement threshold\nuint256 moveThreshold = 0.1*1e18;\n\n\nWe omit the full implementation here as it is lengthy enough and can vary.\nThe key steps are:\n*   Run query for scheduled mint/redeem with logic: if next price is greater than median of currently recorded prices by threshold, add it to the records, but do not mint/redeem.\n*   That is, when scheduled mint/redeem is run, on new price request, WrappedIbbtcEth.core.pricePerShare() or WrappedIbbtc.oracle.pricePerShare(), get newPrice and calculate current price array median, curMed\n*   prices[curPos] = newPrice\n*   if (curMaxPos < totalMaxPos) {curMaxPos += 1}\n*   if (curPos == curMaxPos) {curPos = 0} else {curPos += 1}\n*   if (absolute_value_of(newPrice curMed) < moveThreshold * curMed / 1e18) {do_mint/redeem; return_0_status}\n*   else {return_1_status}\n\nSchedule should be frequent enough, say once per 30 minutes, which is kept while returned status is 0. While threshold condition isn't met and returned status is 1, it runs once per 10 minutes. The parameters here are subject to calibration.\n\nThis way if the price movement is sustained the mint/redeem happens after price array median comes to a new equilibrium. If price reverts, the outbreak will not have material effect mint/burn operations. This way the contract vulnerability is considerably reduced as attacker would need to keep distorted price for period long enough, which will happen after the first part of deposit/withdraw cycle. I.e. deposit and mint, burn and redeem operations will happen not simultaneously, preventing flash loans to be used to elevate the quantities, and for price to be effectively distorted it would be needed to keep it so for substantial amount of time.\n\ndapp-whisperer (BadgerDAO) confirmed(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/87#issuecomment-958145768):\n  Minting and burning happens atomically within larger function calls and our current approach isn't amenable to this change.\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "updatePricePerShare()",
                    "transferFrom",
                    "pricePerShare()",
                    "balanceToShares()",
                    "pricePerShare"
                ],
                "Type": " Unable to transfer  WrappedIbbtc  if Oracle go down",
                "Description": "\nIn WrappedIbbtc, user will not be able to transfer if oracle.pricePerShare() (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().\n\nIf this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it uses the cached value in a local variable pricePerShare, which is only updated upon call to updatePricePerShare().\n\n",
                "Repair": "Depending on the specification, one of them need to be changed.\n\ndapp-whisperer (BadgerDAO) confirmed(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/20)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface ICore {\n    function mint(\n        uint256 btc,\n        address account,\n        bytes32[] calldata merkleProof\n    ) external returns (uint256);\n\n    function redeem(uint256 btc, address account) external returns (uint256);\n\n    function btcToBbtc(uint256 btc) external view returns (uint256, uint256);\n\n    function bBtcToBtc(uint256 bBtc) external view returns (uint256 btc, uint256 fee);\n\n    function pricePerShare() external view returns (uint256);\n\n    function setGuestList(address guestlist) external;\n\n    function collectFee() external;\n\n    function owner() external view returns (address);\n}\n\n\n",
        "CodeNames": [
            "ICore.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "pricePerShare"
                ],
                "Type": " Null check in  pricePerShare ",
                "Description": "\n oracle can 0 as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: WrappedIbbtc.sol L148(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L148)) resulting in Denial Of Service.\n\nWrappedIbbtcEth.sol L73(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L73)\nWrappedIbbtc.sol L123(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123)\n\n\n",
                "Repair": "Add a null check to ensure that on every update, the price is greater than 0.\n\ndapp-whisperer (BadgerDAO) confirmed(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/90#issuecomment-962178554):\n  Agreed. we will implicitly or explicitly add this check.\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "pricePerShare"
                ],
                "Type": " hard to clear balance",
                "Description": "\nThe contract does not allow users to transfer by share. Therefore, It is hard for users to clear out all the shares.\nThere will be users using this token with Metamask and it is likely the pricePerShare would increase after the user sends transactions. I consider this is a medium-risk issue.\n\nWrappedIbbtc.sol#L110-L118(https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L110-L118)\n\n",
                "Repair": "A new transferShares beside the original transfer() would build a better UX. sushi's bento box would be a good ref BentoBox.sol(https://github.com/sushiswap/bentobox/blob/master/contracts/BentoBox.sol)\n\ndapp-whisperer (BadgerDAO) confirmed(https://github.com/code-423n4/2021-10-badgerdao-findings/issues/24)\n\n\n"
            }
        ]
    }
]