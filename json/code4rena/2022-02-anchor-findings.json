[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Spend limit on owner can be bypassed",
                "Description": "*Submitted by csanuragjain, also found by cmichel*\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/distributor/src/contract.rs#L140<br\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/community/src/contract.rs#L69<br\n\nIt seems that the owner is only allowed to spend amount uptil config.spend_limit. However it was observed that this config.spend_limit is never decreased even if owner has spend an amount. This makes config.spend_limit useless as owner can simply send 2-multiple transactions each of config.spend_limit which will all pass and hence bypassing the spend limit placed on owner.\n\n\n1.  Assume spend limit of 100 is placed on owner\n2.  Owner simply calls the spend function at either distributor or community contract with amount 100\n3.  Ideally after this transaction owner should not be allowed to perform any more spend operation\n4.  Since config.spend_limit remains unchanged, owner can call step 2 multiple times which will spend amount 100 several times bypassing spend limit\n\n",
                "Repair": "\nAfter successful spend, the config.spend_limit should be decreased by the amount spend.\n\nAlbert Chon (judge) commented via duplicate issue #34(https://github.com/code-423n4/2022-02-anchor-findings/issues/34#issuecomment-1250500683):\n  Indeed, this is a serious oversight, unless one expects the whitelisted addresses to not exceed the spend limit (which is not a good assumption to bake in). \n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [],
                "Type": "  money-market-contracts/oracle#feed_prices()  delayed transaction may disrupt price feeds",
                "Description": "*Submitted by WatchPug*\n\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/money-market-contracts/contracts/oracle/src/contract.rs#L106-L113\n\nThe implementation only takes two attributes: asset and price. And the last_updated_time of the record will always be set to the current block.time.\n\nThis makes it possible for the price feeds to be disrupted when the network is congested, or the endpoint is down for a while, or the feeder bot handled the message queue inappropriately, as a result, the transactions with stale prices get accepted as fresh prices.\n\nSince the price feeds are essential to the protocol, that can result in users' positions being liquidated wrongfully and case fund loss to users.\n\n\nGiven:\n\n*   feeder i connected to an endpoint currently experiencing degraded performance;\n*   ETH price is $10,000;\n*   The max_ltv ratio of ETH is 60%.\n\n1.  Alice borrowed 5,000 USDC with 1 ETH as collateral;\n2.  ETH price dropped to $9,000, to avoid liquidation, Alice repaid 1,000 USD;\n3.  The price of ETH dropped to $8,000; feeder tries to updateMainFeedData() with the latest price: $8,000, however, since the network is congested, the transactions were not get packed timely;\n4.  ETH price rebound to $10,000; Alice borrowed another 1,000 USDC;\n5.  The txs send by feeder at step 3 finally got packed, the protocol now believes the price of ETH has suddenly dropped to $8,000, as a result, Alice's position got liquidated.\n\n",
                "Repair": "\nChange to:\n\nsolidity\npub fn feed_prices(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    prices: Vec<(String, Decimal256, u64),\n) - Result<Response, ContractError {\n    let mut attributes = vec![attr(\"action\", \"feed_prices\")];\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    for price in prices {\n        let asset: String = price.0;\n        let mut updated_time: u64 = price.2;\n        let price: Decimal256 = price.1;\n\n        // Check feeder permission\n        let feeder = read_feeder(deps.storage, &asset)?;\n        if feeder != sender_raw {\n            return Err(ContractError::Unauthorized {});\n        }\n\n        let config: Config = read_config(deps.storage)?;\n        if env.block.time.seconds()  updated_time {\n            // reject stale price\n            if env.block.time.seconds() updated_time  config.valid_period {\n                return Err(ContractError::InvalidInputs {});\n            }\n        } else {\n            // reject future timestamp, graceFuturePeriod can be set to 3, which means < 3s is allowed\n            if updated_time env.block.time.seconds()  config.grace_future_period {\n                return Err(ContractError::InvalidInputs {});\n            }\n            updated_time = env.block.time.seconds();\n        }\n\n        attributes.push(attr(\"asset\", asset.to_string()));\n        attributes.push(attr(\"price\", price.to_string()));\n\n        store_price(\n            deps.storage,\n            &asset,\n            &PriceInfo {\n                last_updated_time: updated_time,\n                price,\n            },\n        )?;\n    }\n\n    Ok(Response::new().add_attributes(attributes))\n}\n\n\nbitn8 (Anchor) disputed and commented(https://github.com/code-423n4/2022-02-anchor-findings/issues/47#issuecomment-1102992100):\n  We currently have a mean shorting function that pulls multiple price feeds so that if one is stale it gets rejected. \n\nAlex the Entreprenerd (triage) commented(https://github.com/code-423n4/2022-02-anchor-findings/issues/47#issuecomment-1205898865):\n  Seems like the warden has shown a specific scenario, contingent on external conditions.\n \n However, from the code, there seems to be no \"mean shorting function\", at least in the code in scope.\n\nAlbert Chon (judge) commented(https://github.com/code-423n4/2022-02-anchor-findings/issues/47#issuecomment-1251670569):\n  Agreed with @Alex the Entreprenerd, oracle staleness is still an issue in this version of the code. \n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [],
                "Type": " Missing Access Control for  FabricateMIRClaim  and  FabricateANCClaim ",
                "Description": "*Submitted by jmak*\n\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_airdrop_registry/src/contract.rs#L109<br\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_airdrop_registry/src/contract.rs#L71<br\n\nFabricateMIRClaim and FabricateANCClaim should only be issued by the Hub contract (the central hub for all minted bLuna managed by Lido). However, execute_fabricate_anchor_claim and execute_fabricate_mir_claim do not restrict the caller, allowing anyone to submit these msgs.\n\n",
                "Repair": "\nRecommended to add at least simple access control checks in the contract to ensure that these functions can only be called by the Hub and not by others.\n\nSee a below for a potential code snippet.\n\n    // only hub contract can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.hub_contract {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\nAlex the Entreprenerd (triage) commented(https://github.com/code-423n4/2022-02-anchor-findings/issues/58#issuecomment-1207280476):\n  The finding is correct in that anyone can call the function.\n \n The finding lacks any form of impact as to what would happen.\n \n I think these may be test functions also.\n \n Not convinced the report makes sense for high severity given the lack of detail.\n\n\n\n*\n \n\n"
            }
        ]
    }
]