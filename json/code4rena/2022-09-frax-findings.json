[
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n// Primarily added to prevent ERC20 name collisions in frxETHMinter.sol\ninterface IsfrxETH {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function allowance(address, address) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function asset() external view returns (address);\n    function balanceOf(address) external view returns (uint256);\n    function convertToAssets(uint256 shares) external view returns (uint256);\n    function convertToShares(uint256 assets) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n    function depositWithSignature(uint256 assets, address receiver, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 shares);\n    function lastRewardAmount() external view returns (uint192);\n    function lastSync() external view returns (uint32);\n    function maxDeposit(address) external view returns (uint256);\n    function maxMint(address) external view returns (uint256);\n    function maxRedeem(address owner) external view returns (uint256);\n    function maxWithdraw(address owner) external view returns (uint256);\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n    function mintWithSignature(uint256 shares, address receiver, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 assets);\n    function name() external view returns (string memory);\n    function nonces(address) external view returns (uint256);\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function previewDeposit(uint256 assets) external view returns (uint256);\n    function previewMint(uint256 shares) external view returns (uint256);\n    function previewRedeem(uint256 shares) external view returns (uint256);\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n    function rewardsCycleEnd() external view returns (uint32);\n    function rewardsCycleLength() external view returns (uint32);\n    function symbol() external view returns (string memory);\n    function syncRewards() external;\n    function totalAssets() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================== sfrxETH =============================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Nader Ghazvini: https://github.com/amirnader-ghazvini \n\n// Reviewer(s) / Contributor(s)\n// Sam Kazemian: https://github.com/samkazemian\n// Dennett: https://github.com/denett\n// Travis Moore: https://github.com/FortisFortuna\n// Jamie Turley: https://github.com/jyturley\n\nimport { ERC20, ERC4626, xERC4626 } from \"ERC4626/xERC4626.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Vault token for staked frxETH\n/// @notice Is a vault that takes frxETH and gives you sfrxETH erc20 tokens\n/** @dev Exchange rate between frxETH and sfrxETH floats, you can convert your sfrxETH for more frxETH over time.\n    Exchange rate increases as the frax msig mints new frxETH corresponding to the staking yield and drops it into the vault (sfrxETH contract).\n    There is a short time period, \u201ccycles\u201d which the exchange rate increases linearly over. This is to prevent gaming the exchange rate (MEV).\n    The cycles are constant length, but calling syncRewards slightly into a would-be cycle keeps the same would-be endpoint (so cycle ends are every X seconds).\n    Someone must call syncRewards, which queues any new frxETH in the contract to be added to the redeemable amount.\n    sfrxETH adheres to ERC-4626 vault specs \n    Mint vs Deposit\n    mint() - deposit targeting a specific number of sfrxETH out\n    deposit() - deposit knowing a specific number of frxETH in */\ncontract sfrxETH is xERC4626, ReentrancyGuard {\n    /* ========== CONSTRUCTOR ========== */\n    constructor(ERC20 _underlying, uint32 _rewardsCycleLength)\n        ERC4626(_underlying, \"Staked Frax Ether\", \"sfrxETH\")\n        xERC4626(_rewardsCycleLength)\n    {}\n\n    /// @notice Syncs rewards if applicable beforehand. Noop if otherwise \n    function beforeWithdraw(uint256 assets, uint256 shares) internal override {\n        super.beforeWithdraw(assets, shares); // call xERC4626's beforeWithdraw first\n        if (block.timestamp >= rewardsCycleEnd) { syncRewards(); } \n    }\n\n    /// @notice How much frxETH is 1E18 sfrxETH worth. Price is in ETH, not USD\n    function pricePerShare() public view returns (uint256) {\n        return convertToAssets(1e18);\n    }\n\n    /// @notice Approve and deposit() in one transaction\n    function depositWithSignature(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant returns (uint256 shares) {\n        uint256 amount = approveMax ? type(uint256).max : assets;\n        asset.permit(msg.sender, address(this), amount, deadline, v, r, s);\n        return (deposit(assets, receiver));\n    }\n\n    /// @notice Approve and mint() in one transaction\n    /// @dev Similar to the deposit method, but you give it the number of shares you want instead.\n    function mintWithSignature(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant returns (uint256 assets) {\n        uint256 amount = approveMax ? type(uint256).max : previewMint(shares);\n        asset.permit(msg.sender, address(this), amount, deadline, v, r, s);\n        return (mint(shares, receiver));\n    }\n\n}\n\n\n",
        "CodeNames": [
            "IsfrxETH.sol",
            "sfrxETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "syncRewards",
                    "lastRewardAmount",
                    "syncRewards()",
                    "xERC",
                    "beforeWithdraw",
                    "rewardsCycleEnd"
                ],
                "Type": " Wrong accounting logic when syncRewards() is called within beforeWithdraw makes withdrawals impossible",
                "Description": "\nsfrxETH.beforeWithdraw first calls the beforeWithdraw of xERC4626, which decrements storedTotalAssets by the given amount. If the timestamp is greater than the rewardsCycleEnd, syncRewards is called. However, the problem is that the assets have not been transferred out yet, meaning asset.balanceOf(address(this)) still has the old value. On the other hand, storedTotalAssets was already updated. Therefore, the following calculation will be inflated by the amount for which the withdrawal was requested:\n\n    uint256 nextRewards = asset.balanceOf(address(this)) storedTotalAssets_ lastRewardAmount_;\n\nThis has severe consequences:\n1. During the following reward period, lastRewardAmount is too high, which means that too many rewards are paid out to users who want to withdraw. A user could exploit this to steal the assets of other users.\n2. When syncRewards() is called the next time, it is possible that the nextRewards calculation underflows because lastRewardAmount  asset.balanceOf(address(this)). This is very bad because syncRewards() will be called in every withdrawal (after the rewardsCycleEnd) and none of them will succeed because of the underflow. Depositing more also does not help here, it just increases asset.balanceOf(address(this)) and storedTotalAssets by the same amount, which does not eliminate the underflow.\n\nNote that this bug does not require a malicious user or a targeted attack to surface. It can (and probably will) happen in practice just by normal user interactions with the vault (which is for instance shown in the PoC).\n\n\nConsider the following test:\n\n    function testTotalAssetsAfterWithdraw() public {        \n            uint128 deposit = 1 ether;\n            uint128 withdraw = 1 ether;\n            // Mint frxETH to this testing contract from nothing, for testing\n            mintTo(address(this), deposit);\n\n            // Generate some sfrxETH to this testing contract using frxETH\n            frxETHtoken.approve(address(sfrxETHtoken), deposit);\n            sfrxETHtoken.deposit(deposit, address(this));\n            require(sfrxETHtoken.totalAssets() == deposit);\n\n            vm.warp(block.timestamp + 1000);\n            // Withdraw frxETH (from sfrxETH) to this testing contract\n            sfrxETHtoken.withdraw(withdraw, address(this), address(this));\n            vm.warp(block.timestamp + 1000);\n            sfrxETHtoken.syncRewards();\n            require(sfrxETHtoken.totalAssets() == deposit withdraw);\n        }\n\nThis is a normal user interaction where a user deposits into the vault, and makes a withdrawal some time later. However, at this point the syncRewards() within the beforeWithdraw is executed. Because of that, the documented accounting mistake happens and the next call (in fact every call that will be done in the future) to syncRewards() reverts with an underflow.\n\n",
                "Repair": "\nCall syncRewards() before decrementing storedTotalAssets, i.e.:\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override {\n    \tif (block.timestamp = rewardsCycleEnd) { syncRewards(); }\n    \tsuper.beforeWithdraw(assets, shares); // call xERC4626's beforeWithdraw AFTER\n    }\n\nThen, asset.balanceOf(address(this)) and storedTotalAssets are still in sync within syncRewards().\n\nFortisFortuna (Frax) commented(https://github.com/code-423n4/2022-09-frax-findings/issues/15#issuecomment-1258266526):\n  Does this only occur if all users try to withdraw at the exact same time? If so, this is a known bug by us and the risk would be low in a real-life deployment scenario. We can also let the users know about the ramping of the rewards.\n\n FortisFortuna (Frax) marked as duplicate(https://github.com/code-423n4/2022-09-frax-findings/issues/15)\n\nLambda (warden) commented(https://github.com/code-423n4/2022-09-frax-findings/issues/15#issuecomment-1259916036):\n  I do not think that this is a duplicate of #311(https://github.com/code-423n4/2022-09-frax-findings/issues/311). #311 (and the other issues that are linked there) describe a recoverable issue where the withdrawal for the last user fails (which was listed as a known issue of xERC4626) until the cycle ends.\n \n The issue here that is described here and demonstrated in the PoC is a non-recoverable sfrxETH-specific issue (because sfrxETH potentially calls syncRewards() in the beforeWithdraw function) where withdrawals even fail after the cycle has ended. It also does not require all users to withdraw at the same time.\n\nFortisFortuna (Frax) commented(https://github.com/code-423n4/2022-09-frax-findings/issues/15#issuecomment-1260012652):\n  @Lambda What about 24(https://github.com/code-423n4/2022-09-frax-findings/issues/24) ?\n\nLambda (warden) commented(https://github.com/code-423n4/2022-09-frax-findings/issues/15#issuecomment-1260015183):\n  @FortisFortuna Good catch did not see that, yes 24(https://github.com/code-423n4/2022-09-frax-findings/issues/24) addresses the same issue\n\nFortisFortuna (Frax) confirmed and commented(https://github.com/code-423n4/2022-09-frax-findings/issues/15#issuecomment-1260016194):\n  @Lambda I will mark yours as primary because it is better documented.\n\ncorddry (Frax) commented(https://github.com/code-423n4/2022-09-frax-findings/issues/15#issuecomment-1262851746):\n  Here's the proposed fix, which instead moves the syncRewards call to a modifier, so that it actually occurs _before the _withdraw__ instead of in beforeWithdraw. It also adds it to the other 4626 withdraw/redeem functions. Would appreciate feedback if you have any\n \n https://github.com/FraxFinance/frxETH-public/pull/2/commits/1ec457c7f5faed618971fb29b9bcc6d54453b093\n\nLambda (warden) commented(https://github.com/code-423n4/2022-09-frax-findings/issues/15#issuecomment-1262858801):\n  The modifier is currently missing for mint and redeem, is that on purpose? Otherwise, it looks good to me\n\ncorddry (Frax) commented(https://github.com/code-423n4/2022-09-frax-findings/issues/15#issuecomment-1262872809):\n  Whoops-nice catch,\n added here https://github.com/FraxFinance/frxETH-public/commit/996d528b46d1b2a0ac2e5b8f6d2138ccab8e03f5\n\n\n\n*\n\n\n"
            }
        ]
    }
]