[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\n\ncontract Pricing is IPricing {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n\n    address public tracer;\n    IInsurance public insurance;\n    IOracle public oracle;\n\n    // pricing metrics\n    Prices.PriceInstant[24] internal hourlyTracerPrices;\n    Prices.PriceInstant[24] internal hourlyOraclePrices;\n\n    // funding index => funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public fundingRates;\n\n    // funding index => insurance funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;\n\n    // market's time value\n    int256 public override timeValue;\n\n    // funding index\n    uint256 public override currentFundingIndex;\n\n    // timing variables\n    uint256 public startLastHour;\n    uint256 public startLast24Hours;\n    uint8 public override currentHour;\n\n    event HourlyPriceUpdated(uint256 price, uint256 currentHour);\n    event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);\n    event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);\n\n    /**\n     * @dev Set tracer perps factory\n     * @dev ensure that oracle contract is returning WAD values. This may be done\n     *      by wrapping the raw oracle in an adapter (see contracts/oracle)\n     * @param _tracer The address of the tracer this pricing contract links too\n     */\n    constructor(\n        address _tracer,\n        address _insurance,\n        address _oracle\n    ) {\n        tracer = _tracer;\n        insurance = IInsurance(_insurance);\n        oracle = IOracle(_oracle);\n        startLastHour = block.timestamp;\n        startLast24Hours = block.timestamp;\n    }\n\n    /**\n     * @notice Updates pricing information given a trade of a certain volume at\n     *         a set price\n     * @param tradePrice the price the trade executed at\n     */\n    function recordTrade(uint256 tradePrice) external override onlyTracer {\n        uint256 currentOraclePrice = oracle.latestAnswer();\n        if (startLastHour <= block.timestamp - 1 hours) {\n            // emit the old hourly average\n            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);\n            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);\n\n            // update funding rate for the previous hour\n            updateFundingRate();\n\n            // update the time value\n            if (startLast24Hours <= block.timestamp - 24 hours) {\n                // Update the interest rate every 24 hours\n                updateTimeValue();\n                startLast24Hours = block.timestamp;\n            }\n\n            // update time metrics after all other state\n            startLastHour = block.timestamp;\n\n            // Check current hour and loop around if need be\n            if (currentHour == 23) {\n                currentHour = 0;\n            } else {\n                currentHour = currentHour + 1;\n            }\n\n            // add new pricing entry for new hour\n            updatePrice(tradePrice, currentOraclePrice, true);\n        } else {\n            // Update old pricing entry\n            updatePrice(tradePrice, currentOraclePrice, false);\n        }\n    }\n\n    /**\n     * @notice Updates both the latest market price and the latest underlying asset price (from an oracle) for a given tracer market given a tracer price\n     *         and an oracle price.\n     * @param marketPrice The price that a tracer was bought at, returned by the TracerPerpetualSwaps.sol contract when an order is filled\n     * @param oraclePrice The price of the underlying asset that the Tracer is based upon as returned by a Chainlink Oracle\n     * @param newRecord Bool that decides if a new hourly record should be started (true) or if a current hour should be updated (false)\n     */\n    function updatePrice(\n        uint256 marketPrice,\n        uint256 oraclePrice,\n        bool newRecord\n    ) internal {\n        // Price records entries updated every hour\n        if (newRecord) {\n            // Make new hourly record, total = marketprice, numtrades set to 1;\n            Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);\n            hourlyTracerPrices[currentHour] = newHourly;\n            // As above but with Oracle price\n            Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);\n            hourlyOraclePrices[currentHour] = oracleHour;\n        } else {\n            // If an update is needed, add the market price to a running total and increment number of trades\n            hourlyTracerPrices[currentHour].cumulativePrice =\n                hourlyTracerPrices[currentHour].cumulativePrice +\n                marketPrice;\n            hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;\n            // As above but with oracle price\n            hourlyOraclePrices[currentHour].cumulativePrice =\n                hourlyOraclePrices[currentHour].cumulativePrice +\n                oraclePrice;\n            hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;\n        }\n    }\n\n    /**\n     * @notice Updates the funding rate and the insurance funding rate\n     */\n    function updateFundingRate() internal {\n        // Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable\n        ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);\n        Prices.TWAP memory twapPrices = getTWAPs(currentHour);\n        int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();\n        uint256 underlyingTWAP = twapPrices.underlying;\n        uint256 derivativeTWAP = twapPrices.derivative;\n\n        int256 newFundingRate = PRBMathSD59x18.mul(\n            derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,\n            _tracer.fundingRateSensitivity().toInt256()\n        );\n\n        // Create variable with value of new funding rate value\n        int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;\n\n        // as above but with insurance funding rate value\n        int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;\n\n        // Call setter functions on calculated variables\n        setFundingRate(newFundingRate, cumulativeFundingRate);\n        emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);\n        setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);\n        emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);\n        // increment funding index\n        currentFundingIndex = currentFundingIndex + 1;\n    }\n\n    /**\n     * @notice Given the address of a tracer market this function will get the current fair price for that market\n     */\n    function fairPrice() external view override returns (uint256) {\n        return Prices.fairPrice(oracle.latestAnswer(), timeValue);\n    }\n\n    ////////////////////////////\n    ///  SETTER FUNCTIONS   ///\n    //////////////////////////\n\n    /**\n     * @notice Calculates and then updates the time Value for a tracer market\n     */\n    function updateTimeValue() internal {\n        (uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();\n\n        timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct\n     * @param fundingRate The funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        fundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct for a particular Tracer Marker\n     * @param fundingRate The insurance funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    // todo by using public variables lots of these can be removed\n    /**\n     * @return each variable of the fundingRate struct of a particular tracer at a particular funding rate index\n     */\n    function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return fundingRates[index];\n    }\n\n    /**\n     * @return all of the variables in the funding rate struct (insurance rate) from a particular tracer market\n     */\n    function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return insuranceFundingRates[index];\n    }\n\n    /**\n     * @notice Gets an 8 hour time weighted avg price for a given tracer, at a particular hour. More recent prices are weighted more heavily.\n     * @param hour An integer representing what hour of the day to collect from (0-24)\n     * @return the time weighted average price for both the oraclePrice (derivative price) and the Tracer Price\n     */\n    function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {\n        return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);\n    }\n\n    /**\n     * @notice Gets a 24 hour tracer and oracle price for a given tracer market\n     * @return the average price over a 24 hour period for oracle and Tracer price\n     */\n    function get24HourPrices() public view override returns (uint256, uint256) {\n        return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));\n    }\n\n    /**\n     * @notice Gets the average tracer price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     * @return the average price of the tracer for a particular hour\n     */\n    function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {\n        return Prices.averagePrice(hourlyTracerPrices[hour]);\n    }\n\n    /**\n     * @notice Gets the average oracle price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     */\n    function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {\n        return Prices.averagePrice(hourlyOraclePrices[hour]);\n    }\n\n    /**\n     * @dev Used when only valid tracers are allowed\n     */\n    modifier onlyTracer() {\n        require(msg.sender == tracer, \"PRC: Only Tracer\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibLiquidation.sol\";\nimport \"./lib/LibBalances.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/ILiquidation.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/IInsurance.sol\";\n\n/**\n * Each call enforces that the contract calling the account is only updating the balance\n * of the account for that contract.\n */\ncontract Liquidation is ILiquidation, Ownable {\n    using LibMath for uint256;\n    using LibMath for int256;\n\n    uint256 public override currentLiquidationId;\n    uint256 public override maxSlippage;\n    uint256 public override releaseTime = 15 minutes;\n    uint256 public override minimumLeftoverGasCostMultiplier = 10;\n    IPricing public pricing;\n    ITracerPerpetualSwaps public tracer;\n    address public insuranceContract;\n    address public fastGasOracle;\n\n    // Receipt ID => LiquidationReceipt\n    mapping(uint256 => LibLiquidation.LiquidationReceipt) public liquidationReceipts;\n\n    event ClaimedReceipts(address indexed liquidator, address indexed market, uint256 indexed receiptId);\n    event ClaimedEscrow(address indexed liquidatee, address indexed market, uint256 indexed id);\n    event Liquidate(\n        address indexed account,\n        address indexed liquidator,\n        int256 liquidationAmount,\n        Perpetuals.Side side,\n        address indexed market,\n        uint256 liquidationId\n    );\n    event InvalidClaimOrder(uint256 indexed receiptId);\n\n    /**\n     * @param _pricing Pricing.sol contract address\n     * @param _tracer TracerPerpetualSwaps.sol contract address\n     * @param _insuranceContract Insurance.sol contract address\n     * @param _fastGasOracle Address of the contract that implements the IOracle.sol interface\n     * @param _maxSlippage The maximum slippage percentage that is allowed on selling a\n                           liquidated position. Given as a decimal WAD. e.g 5% = 0.05*10^18\n     */\n    constructor(\n        address _pricing,\n        address _tracer,\n        address _insuranceContract,\n        address _fastGasOracle,\n        uint256 _maxSlippage\n    ) Ownable() {\n        pricing = IPricing(_pricing);\n        tracer = ITracerPerpetualSwaps(_tracer);\n        insuranceContract = _insuranceContract;\n        fastGasOracle = _fastGasOracle;\n        maxSlippage = _maxSlippage;\n    }\n\n    /**\n     * @notice Creates a liquidation receipt for a given trader\n     * @param liquidator the account executing the liquidation\n     * @param liquidatee the account being liquidated\n     * @param price the price at which this liquidation event occurred\n     * @param escrowedAmount the amount of funds required to be locked into escrow\n     *                       by the liquidator\n     * @param amountLiquidated the amount of positions that were liquidated\n     * @param liquidationSide the side of the positions being liquidated. true for long\n     *                        false for short.\n     */\n    function submitLiquidation(\n        address liquidator,\n        address liquidatee,\n        uint256 price,\n        uint256 escrowedAmount,\n        int256 amountLiquidated,\n        Perpetuals.Side liquidationSide\n    ) internal {\n        liquidationReceipts[currentLiquidationId] = LibLiquidation.LiquidationReceipt({\n            tracer: address(tracer),\n            liquidator: liquidator,\n            liquidatee: liquidatee,\n            price: price,\n            time: block.timestamp,\n            escrowedAmount: escrowedAmount,\n            releaseTime: block.timestamp + releaseTime,\n            amountLiquidated: amountLiquidated,\n            escrowClaimed: false,\n            liquidationSide: liquidationSide,\n            liquidatorRefundClaimed: false\n        });\n        currentLiquidationId += 1;\n    }\n\n    /**\n     * @notice Allows a trader to claim escrowed funds after the escrow period has expired\n     * @param receiptId The ID number of the insurance receipt from which funds are being claimed from\n     */\n    function claimEscrow(uint256 receiptId) public override {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(!receipt.escrowClaimed, \"LIQ: Escrow claimed\");\n        require(block.timestamp > receipt.releaseTime, \"LIQ: Not released\");\n\n        // Mark as claimed\n        liquidationReceipts[receiptId].escrowClaimed = true;\n\n        // Update balance\n        int256 amountToReturn = receipt.escrowedAmount.toInt256();\n        emit ClaimedEscrow(receipt.liquidatee, receipt.tracer, receiptId);\n        tracer.updateAccountsOnClaim(address(0), 0, receipt.liquidatee, amountToReturn, 0);\n    }\n\n    /**\n     * @notice Returns liquidation receipt data for a given receipt id.\n     * @param id the receipt id to get data for\n     */\n    function getLiquidationReceipt(uint256 id)\n        external\n        view\n        override\n        returns (LibLiquidation.LiquidationReceipt memory)\n    {\n        return liquidationReceipts[id];\n    }\n\n    /**\n     * @notice Verify that a Liquidation is valid; submits liquidation receipt if it is\n     * @dev Reverts if the liquidation is invalid\n     * @param base Amount of base in the account to be liquidated (denominated in base tokens)\n     * @param price Fair price of the asset (denominated in quote/base)\n     * @param quote Amount of quote in the account to be liquidated (denominated in quote tokens)\n     * @param amount Amount of tokens to be liquidated\n     * @param gasPrice Current gas price, denominated in gwei\n     * @param account Account to be liquidated\n     * @return Amount to be escrowed for the liquidation\n     */\n    function verifyAndSubmitLiquidation(\n        int256 base,\n        uint256 price,\n        int256 quote,\n        int256 amount,\n        uint256 gasPrice,\n        address account\n    ) internal returns (uint256) {\n        require(amount > 0, \"LIQ: Liquidation amount <= 0\");\n        require(tx.gasprice <= IOracle(fastGasOracle).latestAnswer(), \"LIQ: GasPrice > FGasPrice\");\n\n        Balances.Position memory pos = Balances.Position(quote, base);\n        uint256 gasCost = gasPrice * tracer.LIQUIDATION_GAS_COST();\n\n        int256 currentMargin = Balances.margin(pos, price);\n        require(\n            currentMargin <= 0 ||\n                uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            \"LIQ: Account above margin\"\n        );\n        require(amount <= base.abs(), \"LIQ: Liquidate Amount > Position\");\n\n        // calc funds to liquidate and move to Escrow\n        uint256 amountToEscrow = LibLiquidation.calcEscrowLiquidationAmount(\n            Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            currentMargin,\n            amount,\n            base\n        );\n\n        // create a liquidation receipt\n        Perpetuals.Side side = base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long;\n        submitLiquidation(msg.sender, account, price, amountToEscrow, amount, side);\n        return amountToEscrow;\n    }\n\n    /**\n     * @return true if the margin is greater than 10x liquidation gas cost (in quote tokens)\n     * @param updatedPosition The agent's position after being liquidated\n     * @param lastUpdatedGasPrice The last updated gas price of the account to be liquidated\n     */\n    function checkPartialLiquidation(Balances.Position memory updatedPosition, uint256 lastUpdatedGasPrice)\n        public\n        view\n        returns (bool)\n    {\n        uint256 liquidationGasCost = tracer.LIQUIDATION_GAS_COST();\n        uint256 price = pricing.fairPrice();\n\n        return\n            LibLiquidation.partialLiquidationIsValid(\n                updatedPosition,\n                lastUpdatedGasPrice,\n                liquidationGasCost,\n                price,\n                minimumLeftoverGasCostMultiplier\n            );\n    }\n\n    /**\n     * @notice Liquidates the margin account of a particular user. A deposit is needed from the liquidator.\n     *         Generates a liquidation receipt for the liquidator to use should they need a refund.\n     * @param amount The amount of tokens to be liquidated\n     * @param account The account that is to be liquidated.\n     */\n    function liquidate(int256 amount, address account) external override {\n        /* Liquidated account's balance */\n        Balances.Account memory liquidatedBalance = tracer.getBalance(account);\n\n        uint256 amountToEscrow = verifyAndSubmitLiquidation(\n            liquidatedBalance.position.base,\n            pricing.fairPrice(),\n            liquidatedBalance.position.quote,\n            amount,\n            liquidatedBalance.lastUpdatedGasPrice,\n            account\n        );\n\n        (\n            int256 liquidatorQuoteChange,\n            int256 liquidatorBaseChange,\n            int256 liquidateeQuoteChange,\n            int256 liquidateeBaseChange\n        ) = LibLiquidation.liquidationBalanceChanges(\n            liquidatedBalance.position.base,\n            liquidatedBalance.position.quote,\n            amount\n        );\n\n        Balances.Position memory updatedPosition = Balances.Position(\n            liquidatedBalance.position.quote + liquidateeQuoteChange,\n            liquidatedBalance.position.base + liquidateeBaseChange\n        );\n\n        require(\n            checkPartialLiquidation(updatedPosition, liquidatedBalance.lastUpdatedGasPrice),\n            \"LIQ: leaves too little left over\"\n        );\n\n        tracer.updateAccountsOnLiquidation(\n            msg.sender,\n            account,\n            liquidatorQuoteChange,\n            liquidatorBaseChange,\n            liquidateeQuoteChange,\n            liquidateeBaseChange,\n            amountToEscrow\n        );\n\n        emit Liquidate(\n            account,\n            msg.sender,\n            amount,\n            (liquidatedBalance.position.base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long),\n            address(tracer),\n            currentLiquidationId - 1\n        );\n    }\n\n    /**\n     * @notice Calculates the number of units sold and the average price of those units by a trader\n     *         given multiple order\n     * @param orders a list of orders for which the units sold is being calculated from\n     * @param traderContract The trader contract with which the orders were made\n     * @param receiptId the id of the liquidation receipt the orders are being claimed against\n     */\n    function calcUnitsSold(\n        Perpetuals.Order[] memory orders,\n        address traderContract,\n        uint256 receiptId\n    ) public override returns (uint256, uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        uint256 unitsSold;\n        uint256 avgPrice;\n        for (uint256 i; i < orders.length; i++) {\n            Perpetuals.Order memory order = ITrader(traderContract).getOrder(orders[i]);\n\n            if (\n                order.created < receipt.time || // Order made before receipt\n                order.maker != receipt.liquidator || // Order made by someone who isn't liquidator\n                order.side == receipt.liquidationSide // Order is in same direction as liquidation\n                /* Order should be the opposite to the position acquired on liquidation */\n            ) {\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            if (\n                (receipt.liquidationSide == Perpetuals.Side.Long && order.price >= receipt.price) ||\n                (receipt.liquidationSide == Perpetuals.Side.Short && order.price <= receipt.price)\n            ) {\n                // Liquidation position was long\n                // Price went up, so not a slippage order\n                // or\n                // Liquidation position was short\n                // Price went down, so not a slippage order\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            uint256 orderFilled = ITrader(traderContract).filledAmount(order);\n            uint256 averageExecutionPrice = ITrader(traderContract).getAverageExecutionPrice(order);\n\n            /* order.created >= receipt.time\n             * && order.maker == receipt.liquidator\n             * && order.side != receipt.liquidationSide */\n            unitsSold = unitsSold + orderFilled;\n            avgPrice = avgPrice + (averageExecutionPrice * orderFilled);\n        }\n\n        // Avoid divide by 0 if no orders sold\n        if (unitsSold == 0) {\n            return (0, 0);\n        }\n        return (unitsSold, avgPrice / unitsSold);\n    }\n\n    /**\n     * @notice Marks receipts as claimed and returns the refund amount\n     * @param escrowId the id of the receipt created during the liquidation event\n     * @param orders the orders that sell the liquidated positions\n     * @param traderContract the address of the trader contract the selling orders were made by\n     */\n    function calcAmountToReturn(\n        uint256 escrowId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) public override returns (uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[escrowId];\n        // Validate the escrowed order was fully sold\n        (uint256 unitsSold, uint256 avgPrice) = calcUnitsSold(orders, traderContract, escrowId);\n        require(unitsSold <= uint256(receipt.amountLiquidated.abs()), \"LIQ: Unit mismatch\");\n\n        uint256 amountToReturn = LibLiquidation.calculateSlippage(unitsSold, maxSlippage, avgPrice, receipt);\n        return amountToReturn;\n    }\n\n    /**\n     * @notice Drains a certain amount from insurance pool to cover excess slippage not covered by escrow\n     * @param amountWantedFromInsurance How much we want to drain\n     * @param receipt The liquidation receipt for which we are calling on the insurance pool to cover\n     */\n    function drainInsurancePoolOnLiquidation(\n        uint256 amountWantedFromInsurance,\n        LibLiquidation.LiquidationReceipt memory receipt\n    ) internal returns (uint256 _amountTakenFromInsurance, uint256 _amountToGiveToClaimant) {\n        /*\n         * If there was not enough escrowed, we want to call the insurance pool to help out.\n         * First, check the margin of the insurance Account. If this is enough, just drain from there.\n         * If this is not enough, call Insurance.drainPool to get some tokens from the insurance pool.\n         * If drainPool is able to drain enough, drain from the new margin.\n         * If the margin still does not have enough after calling drainPool, we are not able to fully\n         * claim the receipt, only up to the amount the insurance pool allows for.\n         */\n\n        Balances.Account memory insuranceBalance = tracer.getBalance(insuranceContract);\n        if (insuranceBalance.position.quote >= amountWantedFromInsurance.toInt256()) {\n            // We don't need to drain insurance contract. The balance is already in the market contract\n            _amountTakenFromInsurance = amountWantedFromInsurance;\n        } else {\n            // insuranceBalance.quote < amountWantedFromInsurance\n            if (insuranceBalance.position.quote <= 0) {\n                // attempt to drain entire balance that is needed from the pool\n                IInsurance(insuranceContract).drainPool(amountWantedFromInsurance);\n            } else {\n                // attempt to drain the required balance taking into account the insurance balance in the account contract\n                IInsurance(insuranceContract).drainPool(\n                    amountWantedFromInsurance - uint256(insuranceBalance.position.quote)\n                );\n            }\n            Balances.Account memory updatedInsuranceBalance = tracer.getBalance(insuranceContract);\n            if (updatedInsuranceBalance.position.quote < amountWantedFromInsurance.toInt256()) {\n                // Still not enough\n                _amountTakenFromInsurance = uint256(updatedInsuranceBalance.position.quote);\n            } else {\n                _amountTakenFromInsurance = amountWantedFromInsurance;\n            }\n        }\n\n        _amountToGiveToClaimant = receipt.escrowedAmount + _amountTakenFromInsurance;\n        // Don't add any to liquidatee\n    }\n\n    /**\n     * @notice Allows a liquidator to submit a single liquidation receipt and multiple order ids. If the\n     *         liquidator experienced slippage, will refund them a proportional amount of their deposit.\n     * @param receiptId Used to identify the receipt that will be claimed\n     * @param orders The orders that sold the liquidated position\n     */\n    function claimReceipt(\n        uint256 receiptId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) external override {\n        // Claim the receipts from the escrow system, get back amount to return\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(receipt.liquidator == msg.sender, \"LIQ: Liquidator mismatch\");\n        // Mark refund as claimed\n        require(!receipt.liquidatorRefundClaimed, \"LIQ: Already claimed\");\n        liquidationReceipts[receiptId].liquidatorRefundClaimed = true;\n        liquidationReceipts[receiptId].escrowClaimed = true;\n        require(block.timestamp < receipt.releaseTime, \"LIQ: claim time passed\");\n        require(tracer.tradingWhitelist(traderContract), \"LIQ: Trader is not whitelisted\");\n\n        uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            liquidationReceipts[receiptId].escrowedAmount = 0;\n        } else {\n            liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;\n        }\n\n        // Keep track of how much was actually taken out of insurance\n        uint256 amountTakenFromInsurance;\n        uint256 amountToGiveToClaimant;\n        uint256 amountToGiveToLiquidatee;\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            // Need to cover some loses with the insurance contract\n            // Whatever is the remainder that can't be covered from escrow\n            uint256 amountWantedFromInsurance = amountToReturn - receipt.escrowedAmount;\n            (amountTakenFromInsurance, amountToGiveToClaimant) = drainInsurancePoolOnLiquidation(\n                amountWantedFromInsurance,\n                receipt\n            );\n        } else {\n            amountToGiveToClaimant = amountToReturn;\n            amountToGiveToLiquidatee = receipt.escrowedAmount - amountToReturn;\n        }\n\n        tracer.updateAccountsOnClaim(\n            receipt.liquidator,\n            amountToGiveToClaimant.toInt256(),\n            receipt.liquidatee,\n            amountToGiveToLiquidatee.toInt256(),\n            amountTakenFromInsurance.toInt256()\n        );\n        emit ClaimedReceipts(msg.sender, address(tracer), receiptId);\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ILiquidation) onlyOwner {\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Modifies the release time\n     * @param _releaseTime new release time\n     */\n    function setReleaseTime(uint256 _releaseTime) external onlyOwner() {\n        releaseTime = _releaseTime;\n    }\n\n    /**\n     * @notice Modifies the value to multiply the liquidation cost by in determining\n     *         the minimum leftover margin on partial liquidation\n     * @param _minimumLeftoverGasCostMultiplier The new multiplier\n     */\n    function setMinimumLeftoverGasCostMultiplier(uint256 _minimumLeftoverGasCostMultiplier) external onlyOwner() {\n        minimumLeftoverGasCostMultiplier = _minimumLeftoverGasCostMultiplier;\n    }\n\n    /**\n     * @notice Modifies the max slippage\n     * @param _maxSlippage new max slippage\n     */\n    function setMaxSlippage(uint256 _maxSlippage) public override onlyOwner() {\n        maxSlippage = _maxSlippage;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/Types.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./lib/LibBalances.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * The Trader contract is used to validate and execute off chain signed and matched orders\n */\ncontract Trader is ITrader {\n    // EIP712 Constants\n    // https://eips.ethereum.org/EIPS/eip-712\n    string private constant EIP712_DOMAIN_NAME = \"Tracer Protocol\";\n    string private constant EIP712_DOMAIN_VERSION = \"1.0\";\n    bytes32 private constant EIP712_DOMAIN_SEPERATOR =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // EIP712 Types\n    bytes32 private constant ORDER_TYPE =\n        keccak256(\n            \"Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)\"\n        );\n\n    uint256 public constant override chainId = 1337; // Changes per chain\n    bytes32 public immutable override EIP712_DOMAIN;\n\n    // order hash to memory\n    mapping(bytes32 => Perpetuals.Order) public orders;\n    // maps an order hash to its signed order if seen before\n    mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;\n    // order hash to amount filled\n    mapping(bytes32 => uint256) public override filled;\n    // order hash to average execution price thus far\n    mapping(bytes32 => uint256) public override averageExecutionPrice;\n\n    constructor() {\n        // Construct the EIP712 Domain\n        EIP712_DOMAIN = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_SEPERATOR,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function filledAmount(Perpetuals.Order memory order) external view override returns (uint256) {\n        return filled[Perpetuals.orderId(order)];\n    }\n\n    function getAverageExecutionPrice(Perpetuals.Order memory order) external view override returns (uint256) {\n        return averageExecutionPrice[Perpetuals.orderId(order)];\n    }\n\n    /**\n     * @notice Batch executes maker and taker orders against a given market. Currently matching works\n     *         by matching orders 1 to 1\n     * @param makers An array of signed make orders\n     * @param takers An array of signed take orders\n     */\n    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)\n        external\n        override\n    {\n        require(makers.length == takers.length, \"TDR: Lengths differ\");\n\n        // safe as we've already bounds checked the array lengths\n        uint256 n = makers.length;\n\n        require(n > 0, \"TDR: Received empty arrays\");\n\n        for (uint256 i = 0; i < n; i++) {\n            // verify each order individually and together\n            if (\n                !isValidSignature(makers[i].order.maker, makers[i]) ||\n                !isValidSignature(takers[i].order.maker, takers[i]) ||\n                !isValidPair(takers[i], makers[i])\n            ) {\n                // skip if either order is invalid\n                continue;\n            }\n\n            // retrieve orders\n            // if the order does not exist, it is created here\n            Perpetuals.Order memory makeOrder = grabOrder(makers, i);\n            Perpetuals.Order memory takeOrder = grabOrder(takers, i);\n\n            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);\n            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);\n\n            uint256 makeOrderFilled = filled[makerOrderId];\n            uint256 takeOrderFilled = filled[takerOrderId];\n\n            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);\n\n            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);\n            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                makeOrderFilled,\n                averageExecutionPrice[makerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                takeOrderFilled,\n                averageExecutionPrice[takerOrderId],\n                fillAmount,\n                executionPrice\n            );\n\n            // match orders\n            // referencing makeOrder.market is safe due to above require\n            // make low level call to catch revert\n            // todo this could be succeptible to re-entrancy as\n            // market is never verified\n            (bool success, ) = makeOrder.market.call(\n                abi.encodePacked(\n                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,\n                    abi.encode(makeOrder, takeOrder, fillAmount)\n                )\n            );\n\n            // ignore orders that cannot be executed\n            if (!success) continue;\n\n            // update order state\n            filled[makerOrderId] = makeOrderFilled + fillAmount;\n            filled[takerOrderId] = takeOrderFilled + fillAmount;\n            averageExecutionPrice[makerOrderId] = newMakeAverage;\n            averageExecutionPrice[takerOrderId] = newTakeAverage;\n        }\n    }\n\n    /**\n     * @notice Retrieves and validates an order from an order array\n     * @param signedOrders an array of signed orders\n     * @param index the index into the array where the desired order is\n     * @return the specified order\n     * @dev Should only be called with a verified signedOrder and with index\n     *      < signedOrders.length\n     */\n    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index)\n        internal\n        returns (Perpetuals.Order memory)\n    {\n        Perpetuals.Order memory rawOrder = signedOrders[index].order;\n\n        bytes32 orderHash = Perpetuals.orderId(rawOrder);\n        // check if order exists on chain, if not, create it\n        if (orders[orderHash].maker == address(0)) {\n            // store this order to keep track of state\n            orders[orderHash] = rawOrder;\n            // map the order hash to the signed order\n            orderToSig[orderHash] = signedOrders[index];\n        }\n\n        return orders[orderHash];\n    }\n\n    /**\n     * @notice hashes a limit order type in order to verify signatures, per EIP712\n     * @param order the limit order being hashed\n     * @return an EIP712 compliant hash (with headers) of the limit order\n     */\n    function hashOrder(Perpetuals.Order memory order) public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    EIP712_DOMAIN,\n                    keccak256(\n                        abi.encode(\n                            ORDER_TYPE,\n                            order.maker,\n                            order.market,\n                            order.price,\n                            order.amount,\n                            uint256(order.side),\n                            order.expires,\n                            order.created\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the EIP712 domain hash of the contract\n     */\n    function getDomain() external view override returns (bytes32) {\n        return EIP712_DOMAIN;\n    }\n\n    /**\n     * @notice Verifies a given limit order has been signed by a given signer and has a correct nonce\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The signed order to verify the signature of\n     * @return if an order has a valid signature and a valid nonce\n     * @dev does not throw if the signature is invalid.\n     */\n    function isValidSignature(address signer, Types.SignedLimitOrder memory signedOrder) internal view returns (bool) {\n        return verifySignature(signer, signedOrder);\n    }\n\n    /**\n     * @notice Validates a given pair of signed orders against each other\n     * @param signedOrder1 the first signed order\n     * @param signedOrder2 the second signed order\n     * @return if signedOrder1 is compatible with signedOrder2\n     * @dev does not throw if pairs are invalid\n     */\n    function isValidPair(Types.SignedLimitOrder memory signedOrder1, Types.SignedLimitOrder memory signedOrder2)\n        internal\n        pure\n        returns (bool)\n    {\n        return (signedOrder1.order.market == signedOrder2.order.market);\n    }\n\n    /**\n     * @notice Verifies the signature component of a signed order\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The unsigned order to verify the signature of\n     * @return true is signer has signed the order, else false\n     */\n    function verifySignature(address signer, Types.SignedLimitOrder memory signedOrder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            signer == ECDSA.recover(hashOrder(signedOrder.order), signedOrder.sigV, signedOrder.sigR, signedOrder.sigS);\n    }\n\n    /**\n     * @return An order that has been previously created in contract, given a user-supplied order\n     * @dev Useful for checking to see if a supplied order has actually been created\n     */\n    function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {\n        bytes32 orderId = Perpetuals.orderId(order);\n        return orders[orderId];\n    }\n}\n\n\n",
        "CodeNames": [
            "Pricing.sol",
            "Liquidation.sol",
            "Trader.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "fundingRates",
                    "hourlyTracerPrices[currentHour]",
                    "recordTrade",
                    "executeTrade",
                    "fairPrice"
                ],
                "Type": " Wrong trading pricing calculations",
                "Description": "\nIn the Pricing contract, an agent can manipulate the trading prices by spamming a high amount of trades.\n\nIndeed an agent can create a high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls Trader.executeTrade; now every order calls a Pricing.recordTrade using the arbitrary price set by the agent.\n\nSince the trades are all made in the same hour, by the way hourlyTracerPrices[currentHour] is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the fundingRates and the fairPrice, allowing a malicious agent the ability to manipulate the market.\n\n",
                "Repair": "Recommend passing the fillAmount parameter to recordTrade(...), and calculate hourlyTracerPrices[currentHour].trades summing fillAmount instead of 1 every trade.\n\nraymogg (Tracer) confirmed(https://github.com/code-423n4/2021-06-tracer-findings/issues/119#issuecomment-873747695):\n  Issue is valid, and there appear to be a few other issues that reference similar problems.\n\n The Trader contract will have a whitelist allowing only select relayers to push orders on chain. As long as off chain order books have sufficient liquidity, this issue is then mitigated as users can't just arbitrarily match orders and send them in, they must be matched on a book with liquidity. To alter the price you would then need to eat through significant liquidity (increasing the cost of this attack).\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\n\ncontract Pricing is IPricing {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n\n    address public tracer;\n    IInsurance public insurance;\n    IOracle public oracle;\n\n    // pricing metrics\n    Prices.PriceInstant[24] internal hourlyTracerPrices;\n    Prices.PriceInstant[24] internal hourlyOraclePrices;\n\n    // funding index => funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public fundingRates;\n\n    // funding index => insurance funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;\n\n    // market's time value\n    int256 public override timeValue;\n\n    // funding index\n    uint256 public override currentFundingIndex;\n\n    // timing variables\n    uint256 public startLastHour;\n    uint256 public startLast24Hours;\n    uint8 public override currentHour;\n\n    event HourlyPriceUpdated(uint256 price, uint256 currentHour);\n    event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);\n    event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);\n\n    /**\n     * @dev Set tracer perps factory\n     * @dev ensure that oracle contract is returning WAD values. This may be done\n     *      by wrapping the raw oracle in an adapter (see contracts/oracle)\n     * @param _tracer The address of the tracer this pricing contract links too\n     */\n    constructor(\n        address _tracer,\n        address _insurance,\n        address _oracle\n    ) {\n        tracer = _tracer;\n        insurance = IInsurance(_insurance);\n        oracle = IOracle(_oracle);\n        startLastHour = block.timestamp;\n        startLast24Hours = block.timestamp;\n    }\n\n    /**\n     * @notice Updates pricing information given a trade of a certain volume at\n     *         a set price\n     * @param tradePrice the price the trade executed at\n     */\n    function recordTrade(uint256 tradePrice) external override onlyTracer {\n        uint256 currentOraclePrice = oracle.latestAnswer();\n        if (startLastHour <= block.timestamp - 1 hours) {\n            // emit the old hourly average\n            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);\n            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);\n\n            // update funding rate for the previous hour\n            updateFundingRate();\n\n            // update the time value\n            if (startLast24Hours <= block.timestamp - 24 hours) {\n                // Update the interest rate every 24 hours\n                updateTimeValue();\n                startLast24Hours = block.timestamp;\n            }\n\n            // update time metrics after all other state\n            startLastHour = block.timestamp;\n\n            // Check current hour and loop around if need be\n            if (currentHour == 23) {\n                currentHour = 0;\n            } else {\n                currentHour = currentHour + 1;\n            }\n\n            // add new pricing entry for new hour\n            updatePrice(tradePrice, currentOraclePrice, true);\n        } else {\n            // Update old pricing entry\n            updatePrice(tradePrice, currentOraclePrice, false);\n        }\n    }\n\n    /**\n     * @notice Updates both the latest market price and the latest underlying asset price (from an oracle) for a given tracer market given a tracer price\n     *         and an oracle price.\n     * @param marketPrice The price that a tracer was bought at, returned by the TracerPerpetualSwaps.sol contract when an order is filled\n     * @param oraclePrice The price of the underlying asset that the Tracer is based upon as returned by a Chainlink Oracle\n     * @param newRecord Bool that decides if a new hourly record should be started (true) or if a current hour should be updated (false)\n     */\n    function updatePrice(\n        uint256 marketPrice,\n        uint256 oraclePrice,\n        bool newRecord\n    ) internal {\n        // Price records entries updated every hour\n        if (newRecord) {\n            // Make new hourly record, total = marketprice, numtrades set to 1;\n            Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);\n            hourlyTracerPrices[currentHour] = newHourly;\n            // As above but with Oracle price\n            Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);\n            hourlyOraclePrices[currentHour] = oracleHour;\n        } else {\n            // If an update is needed, add the market price to a running total and increment number of trades\n            hourlyTracerPrices[currentHour].cumulativePrice =\n                hourlyTracerPrices[currentHour].cumulativePrice +\n                marketPrice;\n            hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;\n            // As above but with oracle price\n            hourlyOraclePrices[currentHour].cumulativePrice =\n                hourlyOraclePrices[currentHour].cumulativePrice +\n                oraclePrice;\n            hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;\n        }\n    }\n\n    /**\n     * @notice Updates the funding rate and the insurance funding rate\n     */\n    function updateFundingRate() internal {\n        // Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable\n        ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);\n        Prices.TWAP memory twapPrices = getTWAPs(currentHour);\n        int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();\n        uint256 underlyingTWAP = twapPrices.underlying;\n        uint256 derivativeTWAP = twapPrices.derivative;\n\n        int256 newFundingRate = PRBMathSD59x18.mul(\n            derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,\n            _tracer.fundingRateSensitivity().toInt256()\n        );\n\n        // Create variable with value of new funding rate value\n        int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;\n\n        // as above but with insurance funding rate value\n        int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;\n\n        // Call setter functions on calculated variables\n        setFundingRate(newFundingRate, cumulativeFundingRate);\n        emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);\n        setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);\n        emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);\n        // increment funding index\n        currentFundingIndex = currentFundingIndex + 1;\n    }\n\n    /**\n     * @notice Given the address of a tracer market this function will get the current fair price for that market\n     */\n    function fairPrice() external view override returns (uint256) {\n        return Prices.fairPrice(oracle.latestAnswer(), timeValue);\n    }\n\n    ////////////////////////////\n    ///  SETTER FUNCTIONS   ///\n    //////////////////////////\n\n    /**\n     * @notice Calculates and then updates the time Value for a tracer market\n     */\n    function updateTimeValue() internal {\n        (uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();\n\n        timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct\n     * @param fundingRate The funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        fundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct for a particular Tracer Marker\n     * @param fundingRate The insurance funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    // todo by using public variables lots of these can be removed\n    /**\n     * @return each variable of the fundingRate struct of a particular tracer at a particular funding rate index\n     */\n    function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return fundingRates[index];\n    }\n\n    /**\n     * @return all of the variables in the funding rate struct (insurance rate) from a particular tracer market\n     */\n    function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return insuranceFundingRates[index];\n    }\n\n    /**\n     * @notice Gets an 8 hour time weighted avg price for a given tracer, at a particular hour. More recent prices are weighted more heavily.\n     * @param hour An integer representing what hour of the day to collect from (0-24)\n     * @return the time weighted average price for both the oraclePrice (derivative price) and the Tracer Price\n     */\n    function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {\n        return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);\n    }\n\n    /**\n     * @notice Gets a 24 hour tracer and oracle price for a given tracer market\n     * @return the average price over a 24 hour period for oracle and Tracer price\n     */\n    function get24HourPrices() public view override returns (uint256, uint256) {\n        return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));\n    }\n\n    /**\n     * @notice Gets the average tracer price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     * @return the average price of the tracer for a particular hour\n     */\n    function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {\n        return Prices.averagePrice(hourlyTracerPrices[hour]);\n    }\n\n    /**\n     * @notice Gets the average oracle price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     */\n    function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {\n        return Prices.averagePrice(hourlyOraclePrices[hour]);\n    }\n\n    /**\n     * @dev Used when only valid tracers are allowed\n     */\n    modifier onlyTracer() {\n        require(msg.sender == tracer, \"PRC: Only Tracer\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Pricing.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "[currentFundingIndex]",
                    "updateFundingRate()"
                ],
                "Type": " Use of incorrect index leads to incorrect updation of funding rates",
                "Description": "\nThe updateFundingRate() function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of [currentFundingIndex] which has been updated since the previous call to this function while it should really be using [currentFundingIndex-1] to reference the previous funding rate.\n\nThe impact of this, is that the cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and the protocol takes a reputation hit.\n\n",
                "Repair": "Recommend using [currentFundingIndex-1] for non-zero values of currentFundingIndex to get the value updated in the previous call on lines L155 and L159 of Pricing.sol.\n\nraymogg (Tracer) confirmed(https://github.com/code-423n4/2021-06-tracer-findings/issues/74#issuecomment-873752562):\n  Confirmed as an index issue with funding rate \ud83d\udc4d\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./InsurancePoolToken.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport \"./lib/LibInsurance.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract Insurance is IInsurance {\n    using LibMath for uint256;\n    using LibMath for int256;\n    ITracerPerpetualsFactory public perpsFactory;\n\n    address public collateralAsset; // Address of collateral asset\n    uint256 public override publicCollateralAmount; // amount of underlying collateral in public pool, in WAD format\n    uint256 public override bufferCollateralAmount; // amount of collateral in buffer pool, in WAD format\n    address public token; // token representation of a users holding in the pool\n\n    ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool\n\n    event InsuranceDeposit(address indexed market, address indexed user, uint256 indexed amount);\n    event InsuranceWithdraw(address indexed market, address indexed user, uint256 indexed amount);\n    event InsurancePoolDeployed(address indexed market, address indexed asset);\n\n    constructor(address _tracer) {\n        tracer = ITracerPerpetualSwaps(_tracer);\n        InsurancePoolToken _token = new InsurancePoolToken(\"Tracer Pool Token\", \"TPT\");\n        token = address(_token);\n        collateralAsset = tracer.tracerQuoteToken();\n\n        emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());\n    }\n\n    /**\n     * @notice Allows a user to deposit to a given tracer market insurance pool\n     * @dev Mints amount of the pool token to the user\n     * @param amount the amount of tokens to deposit. Provided in WAD format\n     */\n    function deposit(uint256 amount) external override {\n        IERC20 collateralToken = IERC20(collateralAsset);\n\n        // convert token amount to WAD\n        uint256 quoteTokenDecimals = tracer.quoteTokenDecimals();\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        collateralToken.transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // amount in wad format after being converted from token format\n        uint256 wadAmount = uint256(Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount));\n\n        // Update pool balances and user\n        updatePoolAmount();\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to mint = (pool token supply / collateral holdings) * collateral amount to stake\n        uint256 tokensToMint = LibInsurance.calcMintAmount(poolToken.totalSupply(), publicCollateralAmount, wadAmount);\n\n        // mint pool tokens, hold collateral tokens\n        poolToken.mint(msg.sender, tokensToMint);\n        publicCollateralAmount = publicCollateralAmount + wadAmount;\n        emit InsuranceDeposit(address(tracer), msg.sender, wadAmount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw their assets from a given insurance pool\n     * @dev burns amount of tokens from the pool token\n     * @param amount the amount of pool tokens to burn. Provided in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        updatePoolAmount();\n        uint256 balance = getPoolUserBalance(msg.sender);\n        require(balance >= amount, \"INS: balance < amount\");\n\n        IERC20 collateralToken = IERC20(collateralAsset);\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to return = (collateral holdings / pool token supply) * amount of pool tokens to withdraw\n        uint256 wadTokensToSend = LibInsurance.calcWithdrawAmount(\n            poolToken.totalSupply(),\n            publicCollateralAmount,\n            amount\n        );\n\n        // convert token amount to raw amount from WAD\n        uint256 rawTokenAmount = Balances.wadToToken(tracer.quoteTokenDecimals(), wadTokensToSend);\n\n        // pool amount is always in WAD format\n        publicCollateralAmount = publicCollateralAmount - wadTokensToSend;\n\n        // burn pool tokens, return collateral tokens\n        poolToken.burnFrom(msg.sender, amount);\n        collateralToken.transfer(msg.sender, rawTokenAmount);\n\n        emit InsuranceWithdraw(address(tracer), msg.sender, wadTokensToSend);\n    }\n\n    /**\n     * @notice Internally updates a given tracer's pool amount according to the tracer contract\n     * @dev Withdraws from tracer, and adds amount to the pool's amount field.\n     */\n    function updatePoolAmount() public override {\n        uint256 quote = uint256((tracer.getBalance(address(this))).position.quote);\n\n        tracer.withdraw(quote);\n\n        if (publicCollateralAmount > 0) {\n            // Amount to pay to public is the ratio of public collateral amount to total funds\n            uint256 payToPublic = PRBMathUD60x18.mul(\n                quote,\n                PRBMathUD60x18.div(publicCollateralAmount, getPoolHoldings())\n            );\n\n            publicCollateralAmount = publicCollateralAmount + payToPublic;\n\n            // Amount to pay to buffer is the remainder\n            bufferCollateralAmount = bufferCollateralAmount + quote - payToPublic;\n        } else {\n            // Pay to buffer if nothing in public insurance\n            bufferCollateralAmount = bufferCollateralAmount + quote;\n        }\n    }\n\n    /**\n     * @notice Deposits some of the insurance pool's amount into the tracer contract\n     * @dev If amount is greater than the insurance pool's balance, deposit total balance.\n     *      This was done because in such an emergency situation, we want to recover as much as possible\n     * @param amount The desired amount to take from the insurance pool\n     */\n    function drainPool(uint256 amount) external override onlyLiquidation() {\n        IERC20 tracerMarginToken = IERC20(tracer.tracerQuoteToken());\n\n        uint256 poolHoldings = getPoolHoldings();\n\n        if (amount >= poolHoldings) {\n            // If public collateral left after draining is less than 1 token, we want to keep it at 1 token\n            if (publicCollateralAmount > 10**18) {\n                // Leave 1 token for the public pool\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                amount = bufferCollateralAmount;\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else if (amount > bufferCollateralAmount) {\n            if (publicCollateralAmount < 10**18) {\n                // If there's not enough public collateral for there to be 1 token, cap amount being drained at the buffer\n                amount = bufferCollateralAmount;\n            } else if (poolHoldings - amount < 10**18) {\n                // If the amount of collateral left in the public insurance would be less than 1 token, cap amount being drained\n                // from the public insurance such that 1 token is left in the public buffer\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                // Take out what you need from the public pool; there's enough for there to be >= 1 token left\n                publicCollateralAmount = publicCollateralAmount - (amount - bufferCollateralAmount);\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else {\n            // Only need to take part of buffer pool out\n            bufferCollateralAmount = bufferCollateralAmount - amount;\n        }\n\n        tracerMarginToken.approve(address(tracer), amount);\n        tracer.deposit(amount);\n    }\n\n    /**\n     * @notice gets a users balance in a given insurance pool\n     * @param user the user whose balance is being retrieved\n     */\n    function getPoolUserBalance(address user) public view override returns (uint256) {\n        return InsurancePoolToken(token).balanceOf(user);\n    }\n\n    /**\n     * @notice Get total holdings of the insurance pool (= public + buffer collateral)\n     */\n    function getPoolHoldings() public view override returns (uint256) {\n        return bufferCollateralAmount + publicCollateralAmount;\n    }\n\n    /**\n     * @notice Gets the target fund amount for a given insurance pool\n     * @dev The target amount is 1% of the leveraged notional value of the tracer being insured.\n     */\n    function getPoolTarget() public view override returns (uint256) {\n        return tracer.leveragedNotionalValue() / 100;\n    }\n\n    /**\n     * @notice Gets the 8 hour funding rate for an insurance pool\n     * @dev the funding rate is represented as\n     *      0.0036523 * (insurance_fund_target - insurance_fund_holdings) / leveraged_notional_value)\n     */\n    function getPoolFundingRate() external view override returns (uint256) {\n        // 0.0036523 as a WAD = 36523 * (10**11)\n        uint256 multiplyFactor = 36523 * (10**11);\n\n        uint256 levNotionalValue = tracer.leveragedNotionalValue();\n\n        // Traders only pay the insurance funding rate if the market has leverage\n        if (levNotionalValue == 0) {\n            return 0;\n        }\n\n        uint256 poolHoldings = getPoolHoldings();\n        uint256 poolTarget = getPoolTarget();\n\n        // If the pool is above the target, we don't pay the insurance funding rate\n        if (poolTarget <= poolHoldings) {\n            return 0;\n        }\n\n        uint256 ratio = PRBMathUD60x18.div(poolTarget - poolHoldings, levNotionalValue);\n\n        return PRBMathUD60x18.mul(multiplyFactor, ratio);\n    }\n\n    modifier onlyLiquidation() {\n        require(msg.sender == tracer.liquidationContract(), \"INS: sender not LIQ contract\");\n        _;\n    }\n}\n\n\n//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface ISafetyWithdraw {\n    function withdrawERC20Token(\n        address tokenAddress,\n        address to,\n        uint256 amount\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "Insurance.sol",
            "ISafetyWithdraw.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "tokenAddress",
                    "tracerQuoteToken",
                    "withdrawERC"
                ],
                "Type": " Malicious owner can drain the market at any time using  SafetyWithdraw ",
                "Description": "\nThe withdrawERC20Token() in SafetyWithdraw inherited in TracerPerpetualSwaps is presumably a guarded launch emergency withdrawal mechanism. However, given the trust model where the market creator/owner is potentially untrusted/malicious, this is a dangerous approach to emergency withdrawal in the context of guarded launch.\n\nAlternatively, if this is meant for the owner to withdraw \u201cexternal\u201d ERC20 tokens mistakenly deposited to the Tracer market, then the function should exclude tracerQuoteToken from being the tokenAddress that can be used as a parameter to withdrawERC20Token().\n\nThe impact of this is that, if a malicious owner of a market withdraws/rugs all tracerQuoteTokens deposited at any time after market launch, all users lose deposits and the protocol takes a reputational hit and has to refund the users from treasury.\n\nTherefor, it is recommended that, for a guarded launch circuit breaker, design a pause/unpause feature where deposits are paused (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to market, exclude the tracerQuoteToken from being given as the tokenAddress.\n\nraymogg (Tracer) confirmed but suggested a severity of 2 (https://github.com/code-423n4/2021-06-tracer-findings/issues/81#issuecomment-873752133):\n  The only reason for the dispute on severity is that as part of the security model, the owner can manipulate the market in other ways (such as changing the oracle being used), so this trust assumption over the owner already exists. For this reason the team thinks this issue is closer to a medium\n\n This however is a good issue as it is not the greatest circuit breaking mechanism, and as noted in #7 can reflect badly on the project without the exploit being used. The mechanism is being removed and replaced with more structured circuit breaker.\n\ncemozerr (Judge) commented(https://github.com/code-423n4/2021-06-tracer-findings/issues/81#issuecomment-882110087):\n  Marking this as high risk, as regardless of the owner manipulating in other ways, the threat persists.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./LibMath.sol\";\nimport \"../Interfaces/Types.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport \"./LibPerpetuals.sol\";\n\nlibrary Balances {\n    using LibMath for int256;\n    using LibMath for uint256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant MAX_DECIMALS = 18;\n\n    // Size of a position\n    struct Position {\n        int256 quote;\n        int256 base;\n    }\n\n    // Information about a trade\n    struct Trade {\n        uint256 price;\n        uint256 amount;\n        Perpetuals.Side side;\n    }\n\n    // Contains information about the balance of an account in a Tracer market\n    struct Account {\n        Position position;\n        uint256 totalLeveragedValue;\n        uint256 lastUpdatedIndex;\n        uint256 lastUpdatedGasPrice;\n    }\n\n    /**\n     * @notice Calculates the notional value of a position as base * price\n     * @param position the position the account is currently in\n     * @param price The (fair) price of the base asset\n     * @return Notional value of a position given the price\n     */\n    function notionalValue(Position memory position, uint256 price) internal pure returns (uint256) {\n        /* cast is safe due to semantics of `abs` */\n        return PRBMathUD60x18.mul(uint256(PRBMathSD59x18.abs(position.base)), price);\n    }\n\n    /**\n     * @notice Calculates the margin as quote + base * base_price\n     * @param position The position the account is currently in\n     * @param price The price of the base asset\n     * @return Margin of the position\n     */\n    function margin(Position memory position, uint256 price) internal pure returns (int256) {\n        /*\n         * A cast *must* occur somewhere here in order for this to type check.\n         *\n         * After you've convinced yourself of this, the next intellectual jump\n         * that needs to be made is *what* to cast. We can't cast `quote` as it's\n         * allowed to be negative. We can't cast `base` as it's allowed to be\n         * negative. Thus, by elimination, the only thing we're left with is\n         * `price`.\n         *\n         * `price` has type `uint256` (i.e., it's unsigned). Thus, our below\n         * cast **will** throw iff. `price >= type(int256).max()`.\n         */\n        int256 signedPrice = LibMath.toInt256(price);\n        return position.quote + PRBMathSD59x18.mul(position.base, signedPrice);\n    }\n\n    /**\n     * @notice Calculates the notional value. i.e. the absolute value of a position\n     * @param position The position the account is currently in\n     * @param price The price of the base asset\n     */\n    function leveragedNotionalValue(Position memory position, uint256 price) internal pure returns (uint256) {\n        uint256 _notionalValue = notionalValue(position, price);\n        int256 marginValue = margin(position, price);\n\n        int256 signedNotionalValue = LibMath.toInt256(_notionalValue);\n\n        if (signedNotionalValue - marginValue < 0) {\n            return 0;\n        } else {\n            return uint256(signedNotionalValue - marginValue);\n        }\n    }\n\n    /**\n     * @notice Calculates the minimum margin needed for an account.\n     * Calculated as minMargin = notionalValue / maxLev + 6 * liquidationGasCost\n     *                         = (base * price) / maxLev + 6 * liquidationGasCost\n     * @param position Position to calculate the minimum margin for\n     * @param price Price by which to evaluate the minimum margin\n     * @param liquidationGasCost Cost for liquidation denominated in quote tokens\n     * @param maximumLeverage (True) maximum leverage of a market.\n     *   May be less than the set max leverage of the market because\n     *   of deleveraging\n     * @return Minimum margin of the position given the parameters\n     */\n    function minimumMargin(\n        Position memory position,\n        uint256 price,\n        uint256 liquidationGasCost,\n        uint256 maximumLeverage\n    ) internal pure returns (uint256) {\n        // There should be no Minimum margin when user has no position\n        if (position.base == 0) {\n            return 0;\n        }\n\n        uint256 _notionalValue = notionalValue(position, price);\n\n        uint256 adjustedLiquidationGasCost = liquidationGasCost * 6;\n\n        uint256 minimumMarginWithoutGasCost = PRBMathUD60x18.div(_notionalValue, maximumLeverage);\n\n        return adjustedLiquidationGasCost + minimumMarginWithoutGasCost;\n    }\n\n    /**\n     * @notice Checks the validity of a potential margin given the necessary parameters\n     * @param position The position\n     * @param liquidationGasCost The cost of calling liquidate\n     * @return a bool representing the validity of a margin\n     */\n    function marginIsValid(\n        Balances.Position memory position,\n        uint256 liquidationGasCost,\n        uint256 price,\n        uint256 trueMaxLeverage\n    ) internal pure returns (bool) {\n        uint256 minMargin = minimumMargin(position, price, liquidationGasCost, trueMaxLeverage);\n        int256 _margin = margin(position, price);\n\n        if (_margin < 0) {\n            /* Margin being less than 0 is always invalid, even if position is 0.\n               This could happen if user attempts to over-withdraw */\n            return false;\n        }\n\n        return (uint256(_margin) >= minMargin);\n    }\n\n    /**\n     * @notice Gets the amount that can be matched between two orders\n     *         Calculated as min(amountRemaining)\n     * @param orderA First order\n     * @param fillA Amount of the first order that has been filled\n     * @param orderB Second order\n     * @param fillB Amount of the second order that has been filled\n     * @return Amount matched between two orders\n     */\n    function fillAmount(\n        Perpetuals.Order memory orderA,\n        uint256 fillA,\n        Perpetuals.Order memory orderB,\n        uint256 fillB\n    ) internal pure returns (uint256) {\n        return LibMath.min(orderA.amount - fillA, orderB.amount - fillB);\n    }\n\n    /**\n     * @notice Applies changes to a position given a trade\n     * @param position Position of the people giving the trade\n     * @param trade Amount of the first order that has been filled\n     * @param feeRate Fee rate being applied to the trade\n     * @return New position\n     */\n    function applyTrade(\n        Position memory position,\n        Trade memory trade,\n        uint256 feeRate\n    ) internal pure returns (Position memory) {\n        int256 signedAmount = LibMath.toInt256(trade.amount);\n        int256 signedPrice = LibMath.toInt256(trade.price);\n        int256 quoteChange = PRBMathSD59x18.mul(signedAmount, signedPrice);\n        int256 fee = getFee(trade.amount, trade.price, feeRate);\n\n        int256 newQuote = 0;\n        int256 newBase = 0;\n\n        if (trade.side == Perpetuals.Side.Long) {\n            newBase = position.base + signedAmount;\n            newQuote = position.quote - quoteChange + fee;\n        } else if (trade.side == Perpetuals.Side.Short) {\n            newBase = position.base - signedAmount;\n            newQuote = position.quote + quoteChange - fee;\n        }\n\n        Position memory newPosition = Position(newQuote, newBase);\n\n        return newPosition;\n    }\n\n    /**\n     * @notice Calculates the fee (in quote tokens)\n     * @param amount The position (in base tokens)\n     * @param executionPrice The execution price (denominated in quote/base)\n     * @param feeRate Fee rate being applied to the trade (a %, in WAD)\n     * @return Value of the fee being applied to the trade\n     */\n    function getFee(\n        uint256 amount,\n        uint256 executionPrice,\n        uint256 feeRate\n    ) internal pure returns (int256) {\n        uint256 quoteChange = PRBMathUD60x18.mul(amount, executionPrice);\n\n        int256 fee = PRBMathUD60x18.mul(quoteChange, feeRate).toInt256();\n        return fee;\n    }\n\n    /**\n     * @notice converts a raw token amount to its WAD representation. Used for tokens\n     * that don't have 18 decimal places\n     */\n    function tokenToWad(uint256 tokenDecimals, uint256 amount) internal pure returns (int256) {\n        uint256 scaler = 10**(MAX_DECIMALS - tokenDecimals);\n        return amount.toInt256() * scaler.toInt256();\n    }\n\n    /**\n     * @notice converts a wad token amount to its raw representation.\n     */\n    function wadToToken(uint256 tokenDecimals, uint256 wadAmount) internal pure returns (uint256) {\n        uint256 scaler = uint256(10**(MAX_DECIMALS - tokenDecimals));\n        return uint256(wadAmount / scaler);\n    }\n}\n\n\n",
        "CodeNames": [
            "LibBalances.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "applyTrade()"
                ],
                "Type": " Logic error in fee subtraction",
                "Description": "\nIn LibBalances.applyTrade(), we need to collect a fee from the trade. However, the current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see TracerPerpetualSwaps.sol L272).\nThis issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.\n\n",
                "Repair": "Recommend changing +fee to -fee in the highlighted line(https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L187).\n\nraymogg (Tracer) confirmed(https://github.com/code-423n4/2021-06-tracer-findings/issues/127#issuecomment-873778933):\n  Valid issue \ud83d\udc4d\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibLiquidation.sol\";\nimport \"./lib/LibBalances.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/ILiquidation.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/IInsurance.sol\";\n\n/**\n * Each call enforces that the contract calling the account is only updating the balance\n * of the account for that contract.\n */\ncontract Liquidation is ILiquidation, Ownable {\n    using LibMath for uint256;\n    using LibMath for int256;\n\n    uint256 public override currentLiquidationId;\n    uint256 public override maxSlippage;\n    uint256 public override releaseTime = 15 minutes;\n    uint256 public override minimumLeftoverGasCostMultiplier = 10;\n    IPricing public pricing;\n    ITracerPerpetualSwaps public tracer;\n    address public insuranceContract;\n    address public fastGasOracle;\n\n    // Receipt ID => LiquidationReceipt\n    mapping(uint256 => LibLiquidation.LiquidationReceipt) public liquidationReceipts;\n\n    event ClaimedReceipts(address indexed liquidator, address indexed market, uint256 indexed receiptId);\n    event ClaimedEscrow(address indexed liquidatee, address indexed market, uint256 indexed id);\n    event Liquidate(\n        address indexed account,\n        address indexed liquidator,\n        int256 liquidationAmount,\n        Perpetuals.Side side,\n        address indexed market,\n        uint256 liquidationId\n    );\n    event InvalidClaimOrder(uint256 indexed receiptId);\n\n    /**\n     * @param _pricing Pricing.sol contract address\n     * @param _tracer TracerPerpetualSwaps.sol contract address\n     * @param _insuranceContract Insurance.sol contract address\n     * @param _fastGasOracle Address of the contract that implements the IOracle.sol interface\n     * @param _maxSlippage The maximum slippage percentage that is allowed on selling a\n                           liquidated position. Given as a decimal WAD. e.g 5% = 0.05*10^18\n     */\n    constructor(\n        address _pricing,\n        address _tracer,\n        address _insuranceContract,\n        address _fastGasOracle,\n        uint256 _maxSlippage\n    ) Ownable() {\n        pricing = IPricing(_pricing);\n        tracer = ITracerPerpetualSwaps(_tracer);\n        insuranceContract = _insuranceContract;\n        fastGasOracle = _fastGasOracle;\n        maxSlippage = _maxSlippage;\n    }\n\n    /**\n     * @notice Creates a liquidation receipt for a given trader\n     * @param liquidator the account executing the liquidation\n     * @param liquidatee the account being liquidated\n     * @param price the price at which this liquidation event occurred\n     * @param escrowedAmount the amount of funds required to be locked into escrow\n     *                       by the liquidator\n     * @param amountLiquidated the amount of positions that were liquidated\n     * @param liquidationSide the side of the positions being liquidated. true for long\n     *                        false for short.\n     */\n    function submitLiquidation(\n        address liquidator,\n        address liquidatee,\n        uint256 price,\n        uint256 escrowedAmount,\n        int256 amountLiquidated,\n        Perpetuals.Side liquidationSide\n    ) internal {\n        liquidationReceipts[currentLiquidationId] = LibLiquidation.LiquidationReceipt({\n            tracer: address(tracer),\n            liquidator: liquidator,\n            liquidatee: liquidatee,\n            price: price,\n            time: block.timestamp,\n            escrowedAmount: escrowedAmount,\n            releaseTime: block.timestamp + releaseTime,\n            amountLiquidated: amountLiquidated,\n            escrowClaimed: false,\n            liquidationSide: liquidationSide,\n            liquidatorRefundClaimed: false\n        });\n        currentLiquidationId += 1;\n    }\n\n    /**\n     * @notice Allows a trader to claim escrowed funds after the escrow period has expired\n     * @param receiptId The ID number of the insurance receipt from which funds are being claimed from\n     */\n    function claimEscrow(uint256 receiptId) public override {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(!receipt.escrowClaimed, \"LIQ: Escrow claimed\");\n        require(block.timestamp > receipt.releaseTime, \"LIQ: Not released\");\n\n        // Mark as claimed\n        liquidationReceipts[receiptId].escrowClaimed = true;\n\n        // Update balance\n        int256 amountToReturn = receipt.escrowedAmount.toInt256();\n        emit ClaimedEscrow(receipt.liquidatee, receipt.tracer, receiptId);\n        tracer.updateAccountsOnClaim(address(0), 0, receipt.liquidatee, amountToReturn, 0);\n    }\n\n    /**\n     * @notice Returns liquidation receipt data for a given receipt id.\n     * @param id the receipt id to get data for\n     */\n    function getLiquidationReceipt(uint256 id)\n        external\n        view\n        override\n        returns (LibLiquidation.LiquidationReceipt memory)\n    {\n        return liquidationReceipts[id];\n    }\n\n    /**\n     * @notice Verify that a Liquidation is valid; submits liquidation receipt if it is\n     * @dev Reverts if the liquidation is invalid\n     * @param base Amount of base in the account to be liquidated (denominated in base tokens)\n     * @param price Fair price of the asset (denominated in quote/base)\n     * @param quote Amount of quote in the account to be liquidated (denominated in quote tokens)\n     * @param amount Amount of tokens to be liquidated\n     * @param gasPrice Current gas price, denominated in gwei\n     * @param account Account to be liquidated\n     * @return Amount to be escrowed for the liquidation\n     */\n    function verifyAndSubmitLiquidation(\n        int256 base,\n        uint256 price,\n        int256 quote,\n        int256 amount,\n        uint256 gasPrice,\n        address account\n    ) internal returns (uint256) {\n        require(amount > 0, \"LIQ: Liquidation amount <= 0\");\n        require(tx.gasprice <= IOracle(fastGasOracle).latestAnswer(), \"LIQ: GasPrice > FGasPrice\");\n\n        Balances.Position memory pos = Balances.Position(quote, base);\n        uint256 gasCost = gasPrice * tracer.LIQUIDATION_GAS_COST();\n\n        int256 currentMargin = Balances.margin(pos, price);\n        require(\n            currentMargin <= 0 ||\n                uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            \"LIQ: Account above margin\"\n        );\n        require(amount <= base.abs(), \"LIQ: Liquidate Amount > Position\");\n\n        // calc funds to liquidate and move to Escrow\n        uint256 amountToEscrow = LibLiquidation.calcEscrowLiquidationAmount(\n            Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            currentMargin,\n            amount,\n            base\n        );\n\n        // create a liquidation receipt\n        Perpetuals.Side side = base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long;\n        submitLiquidation(msg.sender, account, price, amountToEscrow, amount, side);\n        return amountToEscrow;\n    }\n\n    /**\n     * @return true if the margin is greater than 10x liquidation gas cost (in quote tokens)\n     * @param updatedPosition The agent's position after being liquidated\n     * @param lastUpdatedGasPrice The last updated gas price of the account to be liquidated\n     */\n    function checkPartialLiquidation(Balances.Position memory updatedPosition, uint256 lastUpdatedGasPrice)\n        public\n        view\n        returns (bool)\n    {\n        uint256 liquidationGasCost = tracer.LIQUIDATION_GAS_COST();\n        uint256 price = pricing.fairPrice();\n\n        return\n            LibLiquidation.partialLiquidationIsValid(\n                updatedPosition,\n                lastUpdatedGasPrice,\n                liquidationGasCost,\n                price,\n                minimumLeftoverGasCostMultiplier\n            );\n    }\n\n    /**\n     * @notice Liquidates the margin account of a particular user. A deposit is needed from the liquidator.\n     *         Generates a liquidation receipt for the liquidator to use should they need a refund.\n     * @param amount The amount of tokens to be liquidated\n     * @param account The account that is to be liquidated.\n     */\n    function liquidate(int256 amount, address account) external override {\n        /* Liquidated account's balance */\n        Balances.Account memory liquidatedBalance = tracer.getBalance(account);\n\n        uint256 amountToEscrow = verifyAndSubmitLiquidation(\n            liquidatedBalance.position.base,\n            pricing.fairPrice(),\n            liquidatedBalance.position.quote,\n            amount,\n            liquidatedBalance.lastUpdatedGasPrice,\n            account\n        );\n\n        (\n            int256 liquidatorQuoteChange,\n            int256 liquidatorBaseChange,\n            int256 liquidateeQuoteChange,\n            int256 liquidateeBaseChange\n        ) = LibLiquidation.liquidationBalanceChanges(\n            liquidatedBalance.position.base,\n            liquidatedBalance.position.quote,\n            amount\n        );\n\n        Balances.Position memory updatedPosition = Balances.Position(\n            liquidatedBalance.position.quote + liquidateeQuoteChange,\n            liquidatedBalance.position.base + liquidateeBaseChange\n        );\n\n        require(\n            checkPartialLiquidation(updatedPosition, liquidatedBalance.lastUpdatedGasPrice),\n            \"LIQ: leaves too little left over\"\n        );\n\n        tracer.updateAccountsOnLiquidation(\n            msg.sender,\n            account,\n            liquidatorQuoteChange,\n            liquidatorBaseChange,\n            liquidateeQuoteChange,\n            liquidateeBaseChange,\n            amountToEscrow\n        );\n\n        emit Liquidate(\n            account,\n            msg.sender,\n            amount,\n            (liquidatedBalance.position.base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long),\n            address(tracer),\n            currentLiquidationId - 1\n        );\n    }\n\n    /**\n     * @notice Calculates the number of units sold and the average price of those units by a trader\n     *         given multiple order\n     * @param orders a list of orders for which the units sold is being calculated from\n     * @param traderContract The trader contract with which the orders were made\n     * @param receiptId the id of the liquidation receipt the orders are being claimed against\n     */\n    function calcUnitsSold(\n        Perpetuals.Order[] memory orders,\n        address traderContract,\n        uint256 receiptId\n    ) public override returns (uint256, uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        uint256 unitsSold;\n        uint256 avgPrice;\n        for (uint256 i; i < orders.length; i++) {\n            Perpetuals.Order memory order = ITrader(traderContract).getOrder(orders[i]);\n\n            if (\n                order.created < receipt.time || // Order made before receipt\n                order.maker != receipt.liquidator || // Order made by someone who isn't liquidator\n                order.side == receipt.liquidationSide // Order is in same direction as liquidation\n                /* Order should be the opposite to the position acquired on liquidation */\n            ) {\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            if (\n                (receipt.liquidationSide == Perpetuals.Side.Long && order.price >= receipt.price) ||\n                (receipt.liquidationSide == Perpetuals.Side.Short && order.price <= receipt.price)\n            ) {\n                // Liquidation position was long\n                // Price went up, so not a slippage order\n                // or\n                // Liquidation position was short\n                // Price went down, so not a slippage order\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            uint256 orderFilled = ITrader(traderContract).filledAmount(order);\n            uint256 averageExecutionPrice = ITrader(traderContract).getAverageExecutionPrice(order);\n\n            /* order.created >= receipt.time\n             * && order.maker == receipt.liquidator\n             * && order.side != receipt.liquidationSide */\n            unitsSold = unitsSold + orderFilled;\n            avgPrice = avgPrice + (averageExecutionPrice * orderFilled);\n        }\n\n        // Avoid divide by 0 if no orders sold\n        if (unitsSold == 0) {\n            return (0, 0);\n        }\n        return (unitsSold, avgPrice / unitsSold);\n    }\n\n    /**\n     * @notice Marks receipts as claimed and returns the refund amount\n     * @param escrowId the id of the receipt created during the liquidation event\n     * @param orders the orders that sell the liquidated positions\n     * @param traderContract the address of the trader contract the selling orders were made by\n     */\n    function calcAmountToReturn(\n        uint256 escrowId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) public override returns (uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[escrowId];\n        // Validate the escrowed order was fully sold\n        (uint256 unitsSold, uint256 avgPrice) = calcUnitsSold(orders, traderContract, escrowId);\n        require(unitsSold <= uint256(receipt.amountLiquidated.abs()), \"LIQ: Unit mismatch\");\n\n        uint256 amountToReturn = LibLiquidation.calculateSlippage(unitsSold, maxSlippage, avgPrice, receipt);\n        return amountToReturn;\n    }\n\n    /**\n     * @notice Drains a certain amount from insurance pool to cover excess slippage not covered by escrow\n     * @param amountWantedFromInsurance How much we want to drain\n     * @param receipt The liquidation receipt for which we are calling on the insurance pool to cover\n     */\n    function drainInsurancePoolOnLiquidation(\n        uint256 amountWantedFromInsurance,\n        LibLiquidation.LiquidationReceipt memory receipt\n    ) internal returns (uint256 _amountTakenFromInsurance, uint256 _amountToGiveToClaimant) {\n        /*\n         * If there was not enough escrowed, we want to call the insurance pool to help out.\n         * First, check the margin of the insurance Account. If this is enough, just drain from there.\n         * If this is not enough, call Insurance.drainPool to get some tokens from the insurance pool.\n         * If drainPool is able to drain enough, drain from the new margin.\n         * If the margin still does not have enough after calling drainPool, we are not able to fully\n         * claim the receipt, only up to the amount the insurance pool allows for.\n         */\n\n        Balances.Account memory insuranceBalance = tracer.getBalance(insuranceContract);\n        if (insuranceBalance.position.quote >= amountWantedFromInsurance.toInt256()) {\n            // We don't need to drain insurance contract. The balance is already in the market contract\n            _amountTakenFromInsurance = amountWantedFromInsurance;\n        } else {\n            // insuranceBalance.quote < amountWantedFromInsurance\n            if (insuranceBalance.position.quote <= 0) {\n                // attempt to drain entire balance that is needed from the pool\n                IInsurance(insuranceContract).drainPool(amountWantedFromInsurance);\n            } else {\n                // attempt to drain the required balance taking into account the insurance balance in the account contract\n                IInsurance(insuranceContract).drainPool(\n                    amountWantedFromInsurance - uint256(insuranceBalance.position.quote)\n                );\n            }\n            Balances.Account memory updatedInsuranceBalance = tracer.getBalance(insuranceContract);\n            if (updatedInsuranceBalance.position.quote < amountWantedFromInsurance.toInt256()) {\n                // Still not enough\n                _amountTakenFromInsurance = uint256(updatedInsuranceBalance.position.quote);\n            } else {\n                _amountTakenFromInsurance = amountWantedFromInsurance;\n            }\n        }\n\n        _amountToGiveToClaimant = receipt.escrowedAmount + _amountTakenFromInsurance;\n        // Don't add any to liquidatee\n    }\n\n    /**\n     * @notice Allows a liquidator to submit a single liquidation receipt and multiple order ids. If the\n     *         liquidator experienced slippage, will refund them a proportional amount of their deposit.\n     * @param receiptId Used to identify the receipt that will be claimed\n     * @param orders The orders that sold the liquidated position\n     */\n    function claimReceipt(\n        uint256 receiptId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) external override {\n        // Claim the receipts from the escrow system, get back amount to return\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(receipt.liquidator == msg.sender, \"LIQ: Liquidator mismatch\");\n        // Mark refund as claimed\n        require(!receipt.liquidatorRefundClaimed, \"LIQ: Already claimed\");\n        liquidationReceipts[receiptId].liquidatorRefundClaimed = true;\n        liquidationReceipts[receiptId].escrowClaimed = true;\n        require(block.timestamp < receipt.releaseTime, \"LIQ: claim time passed\");\n        require(tracer.tradingWhitelist(traderContract), \"LIQ: Trader is not whitelisted\");\n\n        uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            liquidationReceipts[receiptId].escrowedAmount = 0;\n        } else {\n            liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;\n        }\n\n        // Keep track of how much was actually taken out of insurance\n        uint256 amountTakenFromInsurance;\n        uint256 amountToGiveToClaimant;\n        uint256 amountToGiveToLiquidatee;\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            // Need to cover some loses with the insurance contract\n            // Whatever is the remainder that can't be covered from escrow\n            uint256 amountWantedFromInsurance = amountToReturn - receipt.escrowedAmount;\n            (amountTakenFromInsurance, amountToGiveToClaimant) = drainInsurancePoolOnLiquidation(\n                amountWantedFromInsurance,\n                receipt\n            );\n        } else {\n            amountToGiveToClaimant = amountToReturn;\n            amountToGiveToLiquidatee = receipt.escrowedAmount - amountToReturn;\n        }\n\n        tracer.updateAccountsOnClaim(\n            receipt.liquidator,\n            amountToGiveToClaimant.toInt256(),\n            receipt.liquidatee,\n            amountToGiveToLiquidatee.toInt256(),\n            amountTakenFromInsurance.toInt256()\n        );\n        emit ClaimedReceipts(msg.sender, address(tracer), receiptId);\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ILiquidation) onlyOwner {\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Modifies the release time\n     * @param _releaseTime new release time\n     */\n    function setReleaseTime(uint256 _releaseTime) external onlyOwner() {\n        releaseTime = _releaseTime;\n    }\n\n    /**\n     * @notice Modifies the value to multiply the liquidation cost by in determining\n     *         the minimum leftover margin on partial liquidation\n     * @param _minimumLeftoverGasCostMultiplier The new multiplier\n     */\n    function setMinimumLeftoverGasCostMultiplier(uint256 _minimumLeftoverGasCostMultiplier) external onlyOwner() {\n        minimumLeftoverGasCostMultiplier = _minimumLeftoverGasCostMultiplier;\n    }\n\n    /**\n     * @notice Modifies the max slippage\n     * @param _maxSlippage new max slippage\n     */\n    function setMaxSlippage(uint256 _maxSlippage) public override onlyOwner() {\n        maxSlippage = _maxSlippage;\n    }\n}\n\n\n",
        "CodeNames": [
            "Liquidation.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "avgPrice",
                    "claimReceipt",
                    "calcUnitsSold",
                    "claimReceipt(orders)",
                    "orders"
                ],
                "Type": " Insurance slippage reimbursement can be used to steal insurance fund",
                "Description": "\nThe Liquidation contract allows the liquidator to submit \"bad\" trade orders and the insurance reimburses them from the insurance fund, see Liquidation.claimReceipt.\nThe function can be called with an orders array, which does not check for duplicate orders.\nAn attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.\n\nExample:\nAttacker uses two accounts, one as the liquidator and one as the liquidatee.\nThey run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.)\nLiquidator liquidates liquidatee\nThey now do two trades:\n  One \"good\" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade\n  One \"bad\" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade\nThe liquidator now calls claimReceipt(orders) where orders is an array that contains many duplicates of the \"bad\" trade, for example 100 times. The calcUnitsSold function will return unitsSold = receipt.amountLiquidated and a bad avgPrice. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit\n\nThis can be repeated until the insurance fund is drained.\n\nThe attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.\n\n",
                "Repair": "Recommend disallowing duplicate orders in the orders argument of claimReceipt. This should make the attack at least unprofitable, but it could still be a griefing attack.\nA quick way to ensure that orders does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the calcUnitsSold for loop that the current order ID is strictly greater than the previous one.\n\nBenjaminPatch (Tracer) confirmed(https://github.com/code-423n4/2021-06-tracer-findings/issues/105#issuecomment-873780483):\n  Valid issue. The recommended mitigation step would also work. :+1:\n\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "latestAnswer()"
                ],
                "Type": " Use of deprecated Chainlink API",
                "Description": "\nThe contracts use Chainlink\u2019s deprecated API latestAnswer(). Such functions might suddenly stop working if Chainlink stopped supporting deprecated APIs.\n\nThe impact is that, if the deprecated API stops working, prices cannot be obtained, the protocol stops and contracts have to be redeployed.\n\n",
                "Repair": "Recommend using V3 interface functions(https://docs.chain.link/docs/price-feeds-api-reference/).\n\nraymogg (Tracer) confirmed in a separate issue(https://github.com/code-423n4/2021-06-tracer-findings/issues/145)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../Interfaces/IOracle.sol\";\nimport \"../Interfaces/IChainlinkOracle.sol\";\nimport \"../lib/LibMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * The Chainlink oracle adapter allows you to wrap a Chainlink oracle feed\n * and ensure that the price is always returned in a wad format.\n * The upstream feed may be changed (Eg updated to a new Chainlink feed) while\n * keeping price consistency for the actual Tracer perp market.\n */\ncontract OracleAdapter is IOracle, Ownable {\n    using LibMath for uint256;\n    IChainlinkOracle public oracle;\n    uint256 private constant MAX_DECIMALS = 18;\n    uint256 public scaler;\n\n    constructor(address _oracle) {\n        setOracle(_oracle);\n    }\n\n    /**\n     * @notice Gets the latest anwser from the oracle\n     * @dev converts the price to a WAD price before returning\n     */\n    function latestAnswer() external view override returns (uint256) {\n        return toWad(uint256(oracle.latestAnswer()));\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return uint8(MAX_DECIMALS);\n    }\n\n    /**\n     * @notice converts a raw value to a WAD value.\n     * @dev this allows consistency for oracles used throughout the protocol\n     *      and allows oracles to have their decimals changed withou affecting\n     *      the market itself\n     */\n    function toWad(uint256 raw) internal view returns (uint256) {\n        return raw * scaler;\n    }\n\n    /**\n     * @notice Change the upstream feed address.\n     */\n    function changeOracle(address newOracle) public onlyOwner {\n        setOracle(newOracle);\n    }\n\n    /**\n     * @notice sets the upstream oracle\n     * @dev resets the scalar value to ensure WAD values are always returned\n     */\n    function setOracle(address newOracle) internal {\n        oracle = IChainlinkOracle(newOracle);\n        // reset the scaler for consistency\n        uint8 _decimals = oracle.decimals();\n        require(_decimals <= MAX_DECIMALS, \"COA: too many decimals\");\n        scaler = uint256(10**(MAX_DECIMALS - _decimals));\n    }\n}\n\n\n",
        "CodeNames": [
            "ChainlinkOracleAdapter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "toWad"
                ],
                "Type": " Wrong price scale for  GasOracle ",
                "Description": "\nThe GasOracle uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.\n\nHowever, the scaling depends on the underlying decimals of the two oracles and could be anything.\nBut the code assumes it's in 18 decimals.\n\n \"Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\"\n\nThere is a toWad function that seems to involve scaling but it is never used.\n\nThe impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported.\n\n",
                "Repair": "Recommend checking chainlink.decimals() to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the latestAnswer function always returns the answer in 18 decimals.\n\nraymogg (Tracer) confirmed and disagreed with severity(https://github.com/code-423n4/2021-06-tracer-findings/issues/93#issuecomment-873750451):\n  Disagree with severity as while the statement that the underlying decimals of the oracles could be anything, we will be using production Chainlink feeds for which the decimals are known at the time of deploy.\n\n This is still however an issue as you don't want someone using different oracles (eg non Chainlink) that have different underlying decimals and not realising that this contract will not support that.\n\ncemozerr (Judge) commented(https://github.com/code-423n4/2021-06-tracer-findings/issues/93#issuecomment-882123137):\n  Marking this a high-risk issue as it poses a big threat to users deploying their own markets\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./InsurancePoolToken.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport \"./lib/LibInsurance.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract Insurance is IInsurance {\n    using LibMath for uint256;\n    using LibMath for int256;\n    ITracerPerpetualsFactory public perpsFactory;\n\n    address public collateralAsset; // Address of collateral asset\n    uint256 public override publicCollateralAmount; // amount of underlying collateral in public pool, in WAD format\n    uint256 public override bufferCollateralAmount; // amount of collateral in buffer pool, in WAD format\n    address public token; // token representation of a users holding in the pool\n\n    ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool\n\n    event InsuranceDeposit(address indexed market, address indexed user, uint256 indexed amount);\n    event InsuranceWithdraw(address indexed market, address indexed user, uint256 indexed amount);\n    event InsurancePoolDeployed(address indexed market, address indexed asset);\n\n    constructor(address _tracer) {\n        tracer = ITracerPerpetualSwaps(_tracer);\n        InsurancePoolToken _token = new InsurancePoolToken(\"Tracer Pool Token\", \"TPT\");\n        token = address(_token);\n        collateralAsset = tracer.tracerQuoteToken();\n\n        emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());\n    }\n\n    /**\n     * @notice Allows a user to deposit to a given tracer market insurance pool\n     * @dev Mints amount of the pool token to the user\n     * @param amount the amount of tokens to deposit. Provided in WAD format\n     */\n    function deposit(uint256 amount) external override {\n        IERC20 collateralToken = IERC20(collateralAsset);\n\n        // convert token amount to WAD\n        uint256 quoteTokenDecimals = tracer.quoteTokenDecimals();\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        collateralToken.transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // amount in wad format after being converted from token format\n        uint256 wadAmount = uint256(Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount));\n\n        // Update pool balances and user\n        updatePoolAmount();\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to mint = (pool token supply / collateral holdings) * collateral amount to stake\n        uint256 tokensToMint = LibInsurance.calcMintAmount(poolToken.totalSupply(), publicCollateralAmount, wadAmount);\n\n        // mint pool tokens, hold collateral tokens\n        poolToken.mint(msg.sender, tokensToMint);\n        publicCollateralAmount = publicCollateralAmount + wadAmount;\n        emit InsuranceDeposit(address(tracer), msg.sender, wadAmount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw their assets from a given insurance pool\n     * @dev burns amount of tokens from the pool token\n     * @param amount the amount of pool tokens to burn. Provided in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        updatePoolAmount();\n        uint256 balance = getPoolUserBalance(msg.sender);\n        require(balance >= amount, \"INS: balance < amount\");\n\n        IERC20 collateralToken = IERC20(collateralAsset);\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to return = (collateral holdings / pool token supply) * amount of pool tokens to withdraw\n        uint256 wadTokensToSend = LibInsurance.calcWithdrawAmount(\n            poolToken.totalSupply(),\n            publicCollateralAmount,\n            amount\n        );\n\n        // convert token amount to raw amount from WAD\n        uint256 rawTokenAmount = Balances.wadToToken(tracer.quoteTokenDecimals(), wadTokensToSend);\n\n        // pool amount is always in WAD format\n        publicCollateralAmount = publicCollateralAmount - wadTokensToSend;\n\n        // burn pool tokens, return collateral tokens\n        poolToken.burnFrom(msg.sender, amount);\n        collateralToken.transfer(msg.sender, rawTokenAmount);\n\n        emit InsuranceWithdraw(address(tracer), msg.sender, wadTokensToSend);\n    }\n\n    /**\n     * @notice Internally updates a given tracer's pool amount according to the tracer contract\n     * @dev Withdraws from tracer, and adds amount to the pool's amount field.\n     */\n    function updatePoolAmount() public override {\n        uint256 quote = uint256((tracer.getBalance(address(this))).position.quote);\n\n        tracer.withdraw(quote);\n\n        if (publicCollateralAmount > 0) {\n            // Amount to pay to public is the ratio of public collateral amount to total funds\n            uint256 payToPublic = PRBMathUD60x18.mul(\n                quote,\n                PRBMathUD60x18.div(publicCollateralAmount, getPoolHoldings())\n            );\n\n            publicCollateralAmount = publicCollateralAmount + payToPublic;\n\n            // Amount to pay to buffer is the remainder\n            bufferCollateralAmount = bufferCollateralAmount + quote - payToPublic;\n        } else {\n            // Pay to buffer if nothing in public insurance\n            bufferCollateralAmount = bufferCollateralAmount + quote;\n        }\n    }\n\n    /**\n     * @notice Deposits some of the insurance pool's amount into the tracer contract\n     * @dev If amount is greater than the insurance pool's balance, deposit total balance.\n     *      This was done because in such an emergency situation, we want to recover as much as possible\n     * @param amount The desired amount to take from the insurance pool\n     */\n    function drainPool(uint256 amount) external override onlyLiquidation() {\n        IERC20 tracerMarginToken = IERC20(tracer.tracerQuoteToken());\n\n        uint256 poolHoldings = getPoolHoldings();\n\n        if (amount >= poolHoldings) {\n            // If public collateral left after draining is less than 1 token, we want to keep it at 1 token\n            if (publicCollateralAmount > 10**18) {\n                // Leave 1 token for the public pool\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                amount = bufferCollateralAmount;\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else if (amount > bufferCollateralAmount) {\n            if (publicCollateralAmount < 10**18) {\n                // If there's not enough public collateral for there to be 1 token, cap amount being drained at the buffer\n                amount = bufferCollateralAmount;\n            } else if (poolHoldings - amount < 10**18) {\n                // If the amount of collateral left in the public insurance would be less than 1 token, cap amount being drained\n                // from the public insurance such that 1 token is left in the public buffer\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                // Take out what you need from the public pool; there's enough for there to be >= 1 token left\n                publicCollateralAmount = publicCollateralAmount - (amount - bufferCollateralAmount);\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else {\n            // Only need to take part of buffer pool out\n            bufferCollateralAmount = bufferCollateralAmount - amount;\n        }\n\n        tracerMarginToken.approve(address(tracer), amount);\n        tracer.deposit(amount);\n    }\n\n    /**\n     * @notice gets a users balance in a given insurance pool\n     * @param user the user whose balance is being retrieved\n     */\n    function getPoolUserBalance(address user) public view override returns (uint256) {\n        return InsurancePoolToken(token).balanceOf(user);\n    }\n\n    /**\n     * @notice Get total holdings of the insurance pool (= public + buffer collateral)\n     */\n    function getPoolHoldings() public view override returns (uint256) {\n        return bufferCollateralAmount + publicCollateralAmount;\n    }\n\n    /**\n     * @notice Gets the target fund amount for a given insurance pool\n     * @dev The target amount is 1% of the leveraged notional value of the tracer being insured.\n     */\n    function getPoolTarget() public view override returns (uint256) {\n        return tracer.leveragedNotionalValue() / 100;\n    }\n\n    /**\n     * @notice Gets the 8 hour funding rate for an insurance pool\n     * @dev the funding rate is represented as\n     *      0.0036523 * (insurance_fund_target - insurance_fund_holdings) / leveraged_notional_value)\n     */\n    function getPoolFundingRate() external view override returns (uint256) {\n        // 0.0036523 as a WAD = 36523 * (10**11)\n        uint256 multiplyFactor = 36523 * (10**11);\n\n        uint256 levNotionalValue = tracer.leveragedNotionalValue();\n\n        // Traders only pay the insurance funding rate if the market has leverage\n        if (levNotionalValue == 0) {\n            return 0;\n        }\n\n        uint256 poolHoldings = getPoolHoldings();\n        uint256 poolTarget = getPoolTarget();\n\n        // If the pool is above the target, we don't pay the insurance funding rate\n        if (poolTarget <= poolHoldings) {\n            return 0;\n        }\n\n        uint256 ratio = PRBMathUD60x18.div(poolTarget - poolHoldings, levNotionalValue);\n\n        return PRBMathUD60x18.mul(multiplyFactor, ratio);\n    }\n\n    modifier onlyLiquidation() {\n        require(msg.sender == tracer.liquidationContract(), \"INS: sender not LIQ contract\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Insurance.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "transferFrom()"
                ],
                "Type": " No check  transferFrom()  return value",
                "Description": "\nThe smart contract doesn't check the return value of token.transfer() and token.transferFrom(), some erc20 token might not revert in case of error but return false.\nIn the TracerPerpetualSwaps:deposit(https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and Insurance:deposit(https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. See issue page for other places.\n\n",
                "Repair": "Recommend wrapping the call into a require() or using openzeppelin's SafeERC20 library(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol).\n\nraymogg (Tracer) confirmed(https://github.com/code-423n4/2021-06-tracer-findings/issues/115)\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "transfer()",
                    "transferFrom",
                    "transferFrom()",
                    "amount",
                    "deposit()"
                ],
                "Type": " Deflationary tokens are not supported",
                "Description": "\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom().\n\nThe deposit() functions of Insurance and TracerPerpetualSwaps assume that the external ERC20 balance of the contract increases by the same amount as the amount parameter of the transferFrom.\n\nThe user is credited the full amount without the taxes (userBalance.position.quote).\n\n",
                "Repair": "Recommend as one possible mitigation, measuring the asset change right before and after the asset-transferring functions.\n\nraymogg (Tracer) confirmed but disagreed with severity(https://github.com/code-423n4/2021-06-tracer-findings/issues/104#issuecomment-873757118):\n  Most likely not a medium risk as you can do a lot more nasty things than just use rebasing tokens. Since the owner of a market can set their own quote token, this token could be a token they control the supply of allowing them to arbitrarily transfer tokens between accounts, etc.\n\n As such, this sort of falls outside of our trust model. Market creators should use tokens that behave as \"standard\" ERC20s. We will make a not that rebasing and deflationary tokens should not be used as quote tokens without weird behaviour.\n\n Would be better as a low or informational issue due to this.\n\ncemozerr (Judge) downgraded severity from 2 to 1(https://github.com/code-423n4/2021-06-tracer-findings/issues/104#issuecomment-882104304):\n  Marking this as low risk as it seems to fall outside of the trust model, yet important enough to communicate to users explicitly.\n\n\n"
            },
            {
                "Name": "M-10",
                "Location": [
                    "prb-math"
                ],
                "Type": "  prb-math  not audited",
                "Description": "\nThe library prb-math documents(// https://github.com/hifi-finance/prb-math#security) have not been audited by a security researcher.  This means its more risky to rely on this library.\n\n",
                "Repair": "Recommend considering (crowdsourcing) an audit for prb-math.\n\nraymogg (Tracer) confirmed(https://github.com/code-423n4/2021-06-tracer-findings/issues/11)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/SafetyWithdraw.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport {Types} from \"./Interfaces/Types.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant override LIQUIDATION_GAS_COST = 63516;\n    address public immutable override tracerQuoteToken;\n    uint256 public immutable override quoteTokenDecimals;\n    bytes32 public immutable override marketId;\n    IPricing public pricingContract;\n    IInsurance public insuranceContract;\n    address public override liquidationContract;\n    uint256 public override feeRate;\n    uint256 public override fees;\n    address public override feeReceiver;\n\n    /* Config variables */\n    // The price of gas in gwei\n    address public override gasPriceOracle;\n    // The maximum ratio of notionalValue to margin\n    uint256 public override maxLeverage;\n    // WAD value. sensitivity of 1 = 1*10^18\n    uint256 public override fundingRateSensitivity;\n    // WAD value. The percentage for insurance pool holdings/pool target where deleveraging begins\n    uint256 public override deleveragingCliff;\n    /* The percentage of insurance holdings to target at which the insurance pool\n       funding rate changes, and lowestMaxLeverage is reached */\n    uint256 public override insurancePoolSwitchStage;\n    // The lowest value that maxLeverage can be, if insurance pool is empty.\n    uint256 public override lowestMaxLeverage;\n\n    // Account State Variables\n    mapping(address => Balances.Account) public balances;\n    uint256 public tvl;\n    uint256 public override leveragedNotionalValue;\n\n    // Trading interfaces whitelist\n    mapping(address => bool) public override tradingWhitelist;\n\n    event FeeReceiverUpdated(address indexed receiver);\n    event FeeWithdrawn(address indexed receiver, uint256 feeAmount);\n    event Deposit(address indexed user, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed amount);\n    event Settled(address indexed account, int256 margin);\n    event MatchedOrders(\n        address indexed long,\n        address indexed short,\n        uint256 amount,\n        uint256 price,\n        bytes32 longOrderId,\n        bytes32 shortOrderId\n    );\n    event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);\n\n    /**\n     * @notice Creates a new tracer market and sets the initial funding rate of the market. Anyone\n     *         will be able to purchase and trade tracers after this deployment.\n     * @param _marketId the id of the market, given as BASE/QUOTE\n     * @param _tracerQuoteToken the address of the token used for margin accounts (i.e. The margin token)\n     * @param _tokenDecimals the number of decimal places the quote token supports\n     * @param _gasPriceOracle the address of the contract implementing gas price oracle\n     * @param _maxLeverage the max leverage of the market represented as a WAD value.\n     * @param _fundingRateSensitivity the affect funding rate changes have on funding paid; u60.18-decimal fixed-point number (WAD value)\n     * @param _feeRate the fee taken on trades; WAD value. e.g. 2% fee = 0.02 * 10^18 = 2 * 10^16\n     * @param _feeReceiver the address of the person who can withdraw the fees from trades in this market\n     * @param _deleveragingCliff The percentage for insurance pool holdings/pool target where deleveraging begins.\n     *                           WAD value. e.g. 20% = 20*10^18\n     * @param _lowestMaxLeverage The lowest value that maxLeverage can be, if insurance pool is empty.\n     * @param _insurancePoolSwitchStage The percentage of insurance holdings to target at which the insurance pool\n     *                                  funding rate changes, and lowestMaxLeverage is reached\n     */\n    constructor(\n        bytes32 _marketId,\n        address _tracerQuoteToken,\n        uint256 _tokenDecimals,\n        address _gasPriceOracle,\n        uint256 _maxLeverage,\n        uint256 _fundingRateSensitivity,\n        uint256 _feeRate,\n        address _feeReceiver,\n        uint256 _deleveragingCliff,\n        uint256 _lowestMaxLeverage,\n        uint256 _insurancePoolSwitchStage\n    ) Ownable() {\n        // don't convert to interface as we don't need to interact with the contract\n        tracerQuoteToken = _tracerQuoteToken;\n        quoteTokenDecimals = _tokenDecimals;\n        gasPriceOracle = _gasPriceOracle;\n        marketId = _marketId;\n        feeRate = _feeRate;\n        maxLeverage = _maxLeverage;\n        fundingRateSensitivity = _fundingRateSensitivity;\n        feeReceiver = _feeReceiver;\n        deleveragingCliff = _deleveragingCliff;\n        lowestMaxLeverage = _lowestMaxLeverage;\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    /**\n     * @notice Adjust the max leverage as insurance pool slides from 100% of target to 0% of target\n     */\n    function trueMaxLeverage() public view override returns (uint256) {\n        IInsurance insurance = IInsurance(insuranceContract);\n\n        return\n            Perpetuals.calculateTrueMaxLeverage(\n                insurance.getPoolHoldings(),\n                insurance.getPoolTarget(),\n                maxLeverage,\n                lowestMaxLeverage,\n                deleveragingCliff,\n                insurancePoolSwitchStage\n            );\n    }\n\n    /**\n     * @notice Allows a user to deposit into their margin account\n     * @dev this contract must be an approved spender of the markets quote token on behalf of the depositer.\n     * @param amount The amount of quote tokens to be deposited into the Tracer Market account. This amount\n     * should be given in WAD format.\n     */\n    function deposit(uint256 amount) external override {\n        Balances.Account storage userBalance = balances[msg.sender];\n        // settle outstanding payments\n        settle(msg.sender);\n\n        // convert the WAD amount to the correct token amount to transfer\n        // cast is safe since amount is a uint, and wadToToken can only\n        // scale down the value\n        uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());\n        IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // this prevents dust from being added to the user account\n        // eg 10^18 -> 10^8 -> 10^18 will remove lower order bits\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        // update user state\n        userBalance.position.quote = userBalance.position.quote + convertedWadAmount;\n        _updateAccountLeverage(msg.sender);\n\n        // update market TVL\n        tvl = tvl + uint256(convertedWadAmount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw from their margin account\n     * @dev Ensures that the users margin percent is valid after withdraw\n     * @param amount The amount of margin tokens to be withdrawn from the tracer market account. This amount\n     * should be given in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        // settle outstanding payments\n        settle(msg.sender);\n\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        Balances.Account storage userBalance = balances[msg.sender];\n        int256 newQuote = userBalance.position.quote - convertedWadAmount;\n\n        // this may be able to be optimised\n        Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);\n\n        require(\n            Balances.marginIsValid(\n                newPosition,\n                userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ),\n            \"TCR: Withdraw below valid Margin\"\n        );\n\n        // update user state\n        userBalance.position.quote = newQuote;\n        _updateAccountLeverage(msg.sender);\n\n        // Safemath will throw if tvl < amount\n        tvl = tvl - amount;\n\n        // perform transfer\n        IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);\n        emit Withdraw(msg.sender, uint256(convertedWadAmount));\n    }\n\n    /**\n     * @notice Attempt to match two orders that exist on-chain against each other\n     * @dev Emits a FailedOrders or MatchedOrders event based on whether the\n     *      orders were successfully able to be matched\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount Amount that the two orders are being filled for\n     * @return Whether the two orders were able to be matched successfully\n     */\n    function matchOrders(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount\n    ) external override onlyWhitelisted returns (bool) {\n        bytes32 order1Id = Perpetuals.orderId(order1);\n        bytes32 order2Id = Perpetuals.orderId(order2);\n        uint256 filled1 = ITrader(msg.sender).filled(order1Id);\n        uint256 filled2 = ITrader(msg.sender).filled(order2Id);\n\n        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);\n\n        // settle accounts\n        // note: this can revert and hence no order events will be emitted\n        settle(order1.maker);\n        settle(order2.maker);\n\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(\n            order1,\n            order2,\n            fillAmount,\n            executionPrice\n        );\n        // validate orders can match, and outcome state is valid\n        if (\n            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||\n            !Balances.marginIsValid(\n                newPos1,\n                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ) ||\n            !Balances.marginIsValid(\n                newPos2,\n                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            )\n        ) {\n            // emit failed to match event and return false\n            if (order1.side == Perpetuals.Side.Long) {\n                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);\n            } else {\n                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);\n            }\n            return false;\n        }\n\n        // update account states\n        balances[order1.maker].position = newPos1;\n        balances[order2.maker].position = newPos2;\n\n        // update fees\n        fees =\n            fees +\n            // add 2 * fees since getFeeRate returns the fee rate for a single\n            // side of the order. Both users were charged fees\n            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);\n\n        // update leverage\n        _updateAccountLeverage(order1.maker);\n        _updateAccountLeverage(order2.maker);\n\n        // Update internal trade state\n        pricingContract.recordTrade(executionPrice);\n\n        if (order1.side == Perpetuals.Side.Long) {\n            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);\n        } else {\n            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Updates account states of two accounts given two orders that are being executed\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount The amount that the two ordered are being filled for\n     * @param executionPrice The execution price of the trades\n     * @return The new balances of the two accounts after the trade\n     */\n    function _executeTrade(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount,\n        uint256 executionPrice\n    ) internal view returns (Balances.Position memory, Balances.Position memory) {\n        // Retrieve account state\n        Balances.Account memory account1 = balances[order1.maker];\n        Balances.Account memory account2 = balances[order2.maker];\n\n        // Construct `Trade` types suitable for use with LibBalances\n        (Balances.Trade memory trade1, Balances.Trade memory trade2) = (\n            Balances.Trade(executionPrice, fillAmount, order1.side),\n            Balances.Trade(executionPrice, fillAmount, order2.side)\n        );\n\n        // Calculate new account state\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = (\n            Balances.applyTrade(account1.position, trade1, feeRate),\n            Balances.applyTrade(account2.position, trade2, feeRate)\n        );\n\n        // return new account state\n        return (newPos1, newPos2);\n    }\n\n    /**\n     * @notice internal function for updating leverage. Called within the Account contract. Also\n     *         updates the total leveraged notional value for the tracer market itself.\n     */\n    function _updateAccountLeverage(address account) internal {\n        Balances.Account memory userBalance = balances[account];\n        uint256 originalLeverage = userBalance.totalLeveragedValue;\n        uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());\n        balances[account].totalLeveragedValue = newLeverage;\n\n        // Update market leveraged notional value\n        _updateTracerLeverage(newLeverage, originalLeverage);\n    }\n\n    /**\n     * @notice Updates the global leverage value given an accounts new leveraged value and old leveraged value\n     * @param accountNewLeveragedNotional The future notional value of the account\n     * @param accountOldLeveragedNotional The stored notional value of the account\n     */\n    function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {\n        leveragedNotionalValue = Prices.globalLeverage(\n            leveragedNotionalValue,\n            accountOldLeveragedNotional,\n            accountNewLeveragedNotional\n        );\n    }\n\n    /**\n     * @notice When a liquidation occurs, Liquidation.sol needs to push this contract to update\n     *         account states as necessary.\n     * @param liquidator Address of the account that called liquidate(...)\n     * @param liquidatee Address of the under-margined account getting liquidated\n     * @param liquidatorQuoteChange Amount the liquidator's quote is changing\n     * @param liquidatorBaseChange Amount the liquidator's base is changing\n     * @param liquidateeQuoteChange Amount the liquidated account's quote is changing\n     * @param liquidateeBaseChange Amount the liquidated account's base is changing\n     * @param amountToEscrow The amount the liquidator has to put into escrow\n     */\n    function updateAccountsOnLiquidation(\n        address liquidator,\n        address liquidatee,\n        int256 liquidatorQuoteChange,\n        int256 liquidatorBaseChange,\n        int256 liquidateeQuoteChange,\n        int256 liquidateeBaseChange,\n        uint256 amountToEscrow\n    ) external override onlyLiquidation {\n        // Limits the gas use when liquidating\n        uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();\n        // Update liquidators last updated gas price\n        Balances.Account storage liquidatorBalance = balances[liquidator];\n        Balances.Account storage liquidateeBalance = balances[liquidatee];\n\n        // update liquidators balance\n        liquidatorBalance.lastUpdatedGasPrice = gasPrice;\n        liquidatorBalance.position.quote =\n            liquidatorBalance.position.quote +\n            liquidatorQuoteChange -\n            amountToEscrow.toInt256();\n        liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;\n\n        // update liquidatee balance\n        liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;\n        liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;\n\n        // Checks if the liquidator is in a valid position to process the liquidation\n        require(userMarginIsValid(liquidator), \"TCR: Liquidator under min margin\");\n    }\n\n    /**\n     * @notice When a liquidation receipt is claimed by the liquidator (i.e. they experienced slippage),\n               Liquidation.sol needs to tell the market to update its balance and the balance of the\n               liquidated agent.\n     * @dev Gives the leftover amount from the receipt to the liquidated agent\n     * @param claimant The liquidator, who has experienced slippage selling the liquidated position\n     * @param amountToGiveToClaimant The amount the liquidator is owe based off slippage\n     * @param liquidatee The account that originally got liquidated\n     * @param amountToGiveToLiquidatee Amount owed to the liquidated account\n     * @param amountToTakeFromInsurance Amount that needs to be taken from the insurance pool\n                                        in order to cover liquidation\n     */\n    function updateAccountsOnClaim(\n        address claimant,\n        int256 amountToGiveToClaimant,\n        address liquidatee,\n        int256 amountToGiveToLiquidatee,\n        int256 amountToTakeFromInsurance\n    ) external override onlyLiquidation {\n        address insuranceAddr = address(insuranceContract);\n        balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;\n        balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;\n        balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;\n        require(balances[insuranceAddr].position.quote >= 0, \"TCR: Insurance not funded enough\");\n    }\n\n    /**\n     * @notice settles an account. Compares current global rate with the users last updated rate\n     *         Updates the accounts margin balance accordingly.\n     * @dev Ensures the account remains in a valid margin position. Will throw if account is under margin\n     *      and the account must then be liquidated.\n     * @param account the address to settle.\n     * @dev This function aggregates data to feed into account.sols settle function which sets\n     */\n    function settle(address account) public override {\n        // Get account and global last updated indexes\n        uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;\n        uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();\n        Balances.Account storage accountBalance = balances[account];\n\n        // if this user has no positions, bring them in sync\n        if (accountBalance.position.base == 0) {\n            // set to the last fully established index\n            accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n        } else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {\n            // Only settle account if its last updated index was before the last established\n            // global index this is since we reference the last global index\n            // Get current and global funding statuses\n            uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;\n            // Note: global rates reference the last fully established rate (hence the -1), and not\n            // the current global rate. User rates reference the last saved user rate\n            Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);\n            Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);\n\n            Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(\n                lastEstablishedIndex\n            );\n\n            Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(\n                accountLastUpdatedIndex\n            );\n\n            // settle the account\n            Balances.Account storage insuranceBalance = balances[address(insuranceContract)];\n\n            accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);\n\n            // Update account gas price\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n\n            if (accountBalance.totalLeveragedValue > 0) {\n                (Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(\n                    accountBalance.position,\n                    insuranceBalance.position,\n                    currInsuranceGlobalRate,\n                    currInsuranceUserRate,\n                    accountBalance.totalLeveragedValue\n                );\n\n                balances[account].position = newUserPos;\n                balances[(address(insuranceContract))].position = newInsurancePos;\n            }\n\n            // Update account index\n            accountBalance.lastUpdatedIndex = lastEstablishedIndex;\n            require(userMarginIsValid(account), \"TCR: Target under-margined\");\n            emit Settled(account, accountBalance.position.quote);\n        }\n    }\n\n    /**\n     * @notice Checks if a given accounts margin is valid\n     * @param account The address of the account whose margin is to be checked\n     * @return true if the margin is valid or false otherwise\n     */\n    function userMarginIsValid(address account) public view returns (bool) {\n        Balances.Account memory accountBalance = balances[account];\n        return\n            Balances.marginIsValid(\n                accountBalance.position,\n                accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            );\n    }\n\n    /**\n     * @notice Withdraws the fees taken on trades, and sends them to the designated\n     *         fee receiver (set by the owner of the market)\n     * @dev Anyone can call this function, but fees are transferred to the fee receiver.\n     *      Fees is also subtracted from the total value locked in the market because\n     *      fees are taken out of trades that result in users' quotes being modified, and\n     *      don't otherwise get subtracted from the tvl of the market\n     */\n    function withdrawFees() external override {\n        uint256 tempFees = fees;\n        fees = 0;\n        tvl = tvl - tempFees;\n\n        // Withdraw from the account\n        IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);\n        emit FeeWithdrawn(feeReceiver, tempFees);\n    }\n\n    function getBalance(address account) external view override returns (Balances.Account memory) {\n        return balances[account];\n    }\n\n    function setLiquidationContract(address _liquidationContract) external override onlyOwner {\n        require(_liquidationContract != address(0), \"address(0) given\");\n        liquidationContract = _liquidationContract;\n    }\n\n    function setInsuranceContract(address insurance) external override onlyOwner {\n        require(insurance != address(0), \"address(0) given\");\n        insuranceContract = IInsurance(insurance);\n    }\n\n    function setPricingContract(address pricing) external override onlyOwner {\n        require(pricing != address(0), \"address(0) given\");\n        pricingContract = IPricing(pricing);\n    }\n\n    function setGasOracle(address _gasOracle) external override onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasPriceOracle = _gasOracle;\n    }\n\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address(0) given\");\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    function setFeeRate(uint256 _feeRate) external override onlyOwner {\n        feeRate = _feeRate;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {\n        maxLeverage = _maxLeverage;\n    }\n\n    function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {\n        fundingRateSensitivity = _fundingRateSensitivity;\n    }\n\n    function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {\n        deleveragingCliff = _deleveragingCliff;\n    }\n\n    function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {\n        lowestMaxLeverage = _lowestMaxLeverage;\n    }\n\n    function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {\n        require(newOwner != address(0), \"address(0) given\");\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice allows the owner of a market to set the whitelisting of a trading interface address\n     * @dev a permissioned interface may call the matchOrders function.\n     * @param tradingContract the contract to have its whitelisting permissions set\n     * @param whitelisted the permission of the contract. If true this contract make call makeOrder\n     */\n    function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {\n        tradingWhitelist[tradingContract] = whitelisted;\n    }\n\n    // Modifier such that only the set liquidation contract can call a function\n    modifier onlyLiquidation() {\n        require(msg.sender == liquidationContract, \"TCR: Sender not liquidation\");\n        _;\n    }\n\n    // Modifier such that only a whitelisted trader can call a function\n    modifier onlyWhitelisted() {\n        require(tradingWhitelist[msg.sender], \"TCR: Contract not whitelisted\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "TracerPerpetualSwaps.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "executeTrade"
                ],
                "Type": " Add reentrancy protections on function  executeTrade ",
                "Description": "\nAs written in the to-do comments, reentrancy could happen in the executeTrade function of Trader since the makeOrder.market can be a user-controlled external contract. See L121-L126(https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L121-L126) in Trader.sol.\n\n",
                "Repair": "Recommend adding a reentrancy guard (e.g., the implementation from OpenZeppelin(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)) to prevent the users from reentering critical functions.\n\nraymogg (Tracer) disputed(https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-874405296):\n  Disputing just as while this is important, its quite explicitly stated in the todo comment and as such is already known by the team as a potential issue.\n\n Realistically shouldn't be too much of a problem with whitelisting of the trader.\n\ncemozerr (Judge) commented(https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-882105114):\n  Marking this as medium risk as, regardless of being noted by the team, still poses a security threat.\n\nOsmanBran (Tracer) commented(https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-874405296):\n  Duplicate of #72(https://github.com/code-423n4/2021-06-tracer-findings/issues/72)\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "executeTrade"
                ],
                "Type": " Trader orders can be front-run and users can be denied from trading",
                "Description": "\nThe Trader contract accepts two signed orders and tries to match them. Once they are matched and become filled, they can therefore not be matched against other orders anymore.\n\nThis allows for a griefing attack where an attacker can deny any other user from trading by observing the mempool and front-running their trades by creating their own order and match it against the counter order instead.\n\nIn this way, a trader can be denied from trading. The cost of the griefing attack is that the trader has to match the order themselves, however depending on the liquidity of the order book and the spread, they might be able to do the counter-trade again afterwards, basically just paying the fees.\n\nIt could be useful if the attacker is a liquidator and is stopping a user who is close to liquidation from becoming liquid again.\n\nThis seems hard to circumvent in the current design. If the order book is also off-chain, the executeTrade could also be a bot-only function.\n\nraymogg (Tracer) disputed (in duplicate)(https://github.com/code-423n4/2021-06-tracer-findings/issues/123#issuecomment-873755673)\n Marked as a dispute as this is not really an issue. Tracer will initially maintain an off chain order book that is the entry point for users to make orders (and for market makers to interact with).\n\n Orders only get propagated on chain once they have been matched, and they will only be propagated on chain by whitelisted relayers. As such nobody can arbitrarily frontrun the orders with their own.\n\ncemozerr (Judge) commented(https://github.com/code-423n4/2021-06-tracer-findings/issues/123#issuecomment-882119567):\n  Currently not seeing a whitelisted relayer functionality, so marking this a valid medium risk issue.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\n\ncontract Pricing is IPricing {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n\n    address public tracer;\n    IInsurance public insurance;\n    IOracle public oracle;\n\n    // pricing metrics\n    Prices.PriceInstant[24] internal hourlyTracerPrices;\n    Prices.PriceInstant[24] internal hourlyOraclePrices;\n\n    // funding index => funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public fundingRates;\n\n    // funding index => insurance funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;\n\n    // market's time value\n    int256 public override timeValue;\n\n    // funding index\n    uint256 public override currentFundingIndex;\n\n    // timing variables\n    uint256 public startLastHour;\n    uint256 public startLast24Hours;\n    uint8 public override currentHour;\n\n    event HourlyPriceUpdated(uint256 price, uint256 currentHour);\n    event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);\n    event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);\n\n    /**\n     * @dev Set tracer perps factory\n     * @dev ensure that oracle contract is returning WAD values. This may be done\n     *      by wrapping the raw oracle in an adapter (see contracts/oracle)\n     * @param _tracer The address of the tracer this pricing contract links too\n     */\n    constructor(\n        address _tracer,\n        address _insurance,\n        address _oracle\n    ) {\n        tracer = _tracer;\n        insurance = IInsurance(_insurance);\n        oracle = IOracle(_oracle);\n        startLastHour = block.timestamp;\n        startLast24Hours = block.timestamp;\n    }\n\n    /**\n     * @notice Updates pricing information given a trade of a certain volume at\n     *         a set price\n     * @param tradePrice the price the trade executed at\n     */\n    function recordTrade(uint256 tradePrice) external override onlyTracer {\n        uint256 currentOraclePrice = oracle.latestAnswer();\n        if (startLastHour <= block.timestamp - 1 hours) {\n            // emit the old hourly average\n            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);\n            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);\n\n            // update funding rate for the previous hour\n            updateFundingRate();\n\n            // update the time value\n            if (startLast24Hours <= block.timestamp - 24 hours) {\n                // Update the interest rate every 24 hours\n                updateTimeValue();\n                startLast24Hours = block.timestamp;\n            }\n\n            // update time metrics after all other state\n            startLastHour = block.timestamp;\n\n            // Check current hour and loop around if need be\n            if (currentHour == 23) {\n                currentHour = 0;\n            } else {\n                currentHour = currentHour + 1;\n            }\n\n            // add new pricing entry for new hour\n            updatePrice(tradePrice, currentOraclePrice, true);\n        } else {\n            // Update old pricing entry\n            updatePrice(tradePrice, currentOraclePrice, false);\n        }\n    }\n\n    /**\n     * @notice Updates both the latest market price and the latest underlying asset price (from an oracle) for a given tracer market given a tracer price\n     *         and an oracle price.\n     * @param marketPrice The price that a tracer was bought at, returned by the TracerPerpetualSwaps.sol contract when an order is filled\n     * @param oraclePrice The price of the underlying asset that the Tracer is based upon as returned by a Chainlink Oracle\n     * @param newRecord Bool that decides if a new hourly record should be started (true) or if a current hour should be updated (false)\n     */\n    function updatePrice(\n        uint256 marketPrice,\n        uint256 oraclePrice,\n        bool newRecord\n    ) internal {\n        // Price records entries updated every hour\n        if (newRecord) {\n            // Make new hourly record, total = marketprice, numtrades set to 1;\n            Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);\n            hourlyTracerPrices[currentHour] = newHourly;\n            // As above but with Oracle price\n            Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);\n            hourlyOraclePrices[currentHour] = oracleHour;\n        } else {\n            // If an update is needed, add the market price to a running total and increment number of trades\n            hourlyTracerPrices[currentHour].cumulativePrice =\n                hourlyTracerPrices[currentHour].cumulativePrice +\n                marketPrice;\n            hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;\n            // As above but with oracle price\n            hourlyOraclePrices[currentHour].cumulativePrice =\n                hourlyOraclePrices[currentHour].cumulativePrice +\n                oraclePrice;\n            hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;\n        }\n    }\n\n    /**\n     * @notice Updates the funding rate and the insurance funding rate\n     */\n    function updateFundingRate() internal {\n        // Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable\n        ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);\n        Prices.TWAP memory twapPrices = getTWAPs(currentHour);\n        int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();\n        uint256 underlyingTWAP = twapPrices.underlying;\n        uint256 derivativeTWAP = twapPrices.derivative;\n\n        int256 newFundingRate = PRBMathSD59x18.mul(\n            derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,\n            _tracer.fundingRateSensitivity().toInt256()\n        );\n\n        // Create variable with value of new funding rate value\n        int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;\n\n        // as above but with insurance funding rate value\n        int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;\n\n        // Call setter functions on calculated variables\n        setFundingRate(newFundingRate, cumulativeFundingRate);\n        emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);\n        setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);\n        emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);\n        // increment funding index\n        currentFundingIndex = currentFundingIndex + 1;\n    }\n\n    /**\n     * @notice Given the address of a tracer market this function will get the current fair price for that market\n     */\n    function fairPrice() external view override returns (uint256) {\n        return Prices.fairPrice(oracle.latestAnswer(), timeValue);\n    }\n\n    ////////////////////////////\n    ///  SETTER FUNCTIONS   ///\n    //////////////////////////\n\n    /**\n     * @notice Calculates and then updates the time Value for a tracer market\n     */\n    function updateTimeValue() internal {\n        (uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();\n\n        timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct\n     * @param fundingRate The funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        fundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct for a particular Tracer Marker\n     * @param fundingRate The insurance funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    // todo by using public variables lots of these can be removed\n    /**\n     * @return each variable of the fundingRate struct of a particular tracer at a particular funding rate index\n     */\n    function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return fundingRates[index];\n    }\n\n    /**\n     * @return all of the variables in the funding rate struct (insurance rate) from a particular tracer market\n     */\n    function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return insuranceFundingRates[index];\n    }\n\n    /**\n     * @notice Gets an 8 hour time weighted avg price for a given tracer, at a particular hour. More recent prices are weighted more heavily.\n     * @param hour An integer representing what hour of the day to collect from (0-24)\n     * @return the time weighted average price for both the oraclePrice (derivative price) and the Tracer Price\n     */\n    function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {\n        return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);\n    }\n\n    /**\n     * @notice Gets a 24 hour tracer and oracle price for a given tracer market\n     * @return the average price over a 24 hour period for oracle and Tracer price\n     */\n    function get24HourPrices() public view override returns (uint256, uint256) {\n        return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));\n    }\n\n    /**\n     * @notice Gets the average tracer price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     * @return the average price of the tracer for a particular hour\n     */\n    function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {\n        return Prices.averagePrice(hourlyTracerPrices[hour]);\n    }\n\n    /**\n     * @notice Gets the average oracle price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     */\n    function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {\n        return Prices.averagePrice(hourlyOraclePrices[hour]);\n    }\n\n    /**\n     * @dev Used when only valid tracers are allowed\n     */\n    modifier onlyTracer() {\n        require(msg.sender == tracer, \"PRC: Only Tracer\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract InsurancePoolToken is ERC20, Ownable, ERC20Burnable {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function mint(address to, uint256 amount) external onlyOwner() {\n        _mint(to, amount);\n    }\n\n    function burnFrom(address from, uint256 amount) public override onlyOwner() {\n        // override the burnFrom function and allow only the owner to burn\n        // pool tokens on behalf of a holder\n        _burn(from, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "Pricing.sol",
            "InsurancePoolToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "factory",
                    "onlyOwner()"
                ],
                "Type": " Single-step process for critical ownership transfer",
                "Description": "\nThe Tracer Perpetuals Factory contract is arguably the most critical contract in the project given that it deploys all the markets. The ownership of this contract is transferred to _governance address, i.e. TracerDAO, in the constructor. This critical address transfer in one-step is very risky because it is irrecoverable from any mistakes.\n\nThe impact is that, if an incorrect address (e.g. one for which the private key is not known) is used accidentally, then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various deployer contract addresses and market approvals. This use of an incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of the factory contract and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in markets and incur a significant reputational damage. See issue page(https://github.com/code-423n4/2021-06-tracer-findings/issues/43) for proof of concept.\n\n",
                "Repair": "Recommend retaining the deployer ownership in the constructor and then using a two-step address change to _governance address separately using setter functions:\n1) Approve a new address as a pendingOwner\n2) A transaction from the pendingOwner (TracerDAO) address claims the pending ownership change.\n\nThis mitigates risk because if an incorrect address is used in step (1), then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.\n\nraymogg (Tracer) acknowledged(https://github.com/code-423n4/2021-06-tracer-findings/issues/43#issuecomment-873762658):\n  Correct that having the owner be set to a wrong address could be detrimental, however for the first deploy of the factory, this will be owned by the DAO and will be easy to validate on deployment.\n\n Subsequent ownership transfers will be done via DAO proposal, and will have many eyes across them (due to them being a public Tracer DAO proposal) before function execution happens.\n\n For this reason it seems like a lot of overhead to have a two step process for this. Not withstanding that the issue you mention could still be possible\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\n\ncontract Pricing is IPricing {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n\n    address public tracer;\n    IInsurance public insurance;\n    IOracle public oracle;\n\n    // pricing metrics\n    Prices.PriceInstant[24] internal hourlyTracerPrices;\n    Prices.PriceInstant[24] internal hourlyOraclePrices;\n\n    // funding index => funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public fundingRates;\n\n    // funding index => insurance funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;\n\n    // market's time value\n    int256 public override timeValue;\n\n    // funding index\n    uint256 public override currentFundingIndex;\n\n    // timing variables\n    uint256 public startLastHour;\n    uint256 public startLast24Hours;\n    uint8 public override currentHour;\n\n    event HourlyPriceUpdated(uint256 price, uint256 currentHour);\n    event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);\n    event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);\n\n    /**\n     * @dev Set tracer perps factory\n     * @dev ensure that oracle contract is returning WAD values. This may be done\n     *      by wrapping the raw oracle in an adapter (see contracts/oracle)\n     * @param _tracer The address of the tracer this pricing contract links too\n     */\n    constructor(\n        address _tracer,\n        address _insurance,\n        address _oracle\n    ) {\n        tracer = _tracer;\n        insurance = IInsurance(_insurance);\n        oracle = IOracle(_oracle);\n        startLastHour = block.timestamp;\n        startLast24Hours = block.timestamp;\n    }\n\n    /**\n     * @notice Updates pricing information given a trade of a certain volume at\n     *         a set price\n     * @param tradePrice the price the trade executed at\n     */\n    function recordTrade(uint256 tradePrice) external override onlyTracer {\n        uint256 currentOraclePrice = oracle.latestAnswer();\n        if (startLastHour <= block.timestamp - 1 hours) {\n            // emit the old hourly average\n            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);\n            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);\n\n            // update funding rate for the previous hour\n            updateFundingRate();\n\n            // update the time value\n            if (startLast24Hours <= block.timestamp - 24 hours) {\n                // Update the interest rate every 24 hours\n                updateTimeValue();\n                startLast24Hours = block.timestamp;\n            }\n\n            // update time metrics after all other state\n            startLastHour = block.timestamp;\n\n            // Check current hour and loop around if need be\n            if (currentHour == 23) {\n                currentHour = 0;\n            } else {\n                currentHour = currentHour + 1;\n            }\n\n            // add new pricing entry for new hour\n            updatePrice(tradePrice, currentOraclePrice, true);\n        } else {\n            // Update old pricing entry\n            updatePrice(tradePrice, currentOraclePrice, false);\n        }\n    }\n\n    /**\n     * @notice Updates both the latest market price and the latest underlying asset price (from an oracle) for a given tracer market given a tracer price\n     *         and an oracle price.\n     * @param marketPrice The price that a tracer was bought at, returned by the TracerPerpetualSwaps.sol contract when an order is filled\n     * @param oraclePrice The price of the underlying asset that the Tracer is based upon as returned by a Chainlink Oracle\n     * @param newRecord Bool that decides if a new hourly record should be started (true) or if a current hour should be updated (false)\n     */\n    function updatePrice(\n        uint256 marketPrice,\n        uint256 oraclePrice,\n        bool newRecord\n    ) internal {\n        // Price records entries updated every hour\n        if (newRecord) {\n            // Make new hourly record, total = marketprice, numtrades set to 1;\n            Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);\n            hourlyTracerPrices[currentHour] = newHourly;\n            // As above but with Oracle price\n            Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);\n            hourlyOraclePrices[currentHour] = oracleHour;\n        } else {\n            // If an update is needed, add the market price to a running total and increment number of trades\n            hourlyTracerPrices[currentHour].cumulativePrice =\n                hourlyTracerPrices[currentHour].cumulativePrice +\n                marketPrice;\n            hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;\n            // As above but with oracle price\n            hourlyOraclePrices[currentHour].cumulativePrice =\n                hourlyOraclePrices[currentHour].cumulativePrice +\n                oraclePrice;\n            hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;\n        }\n    }\n\n    /**\n     * @notice Updates the funding rate and the insurance funding rate\n     */\n    function updateFundingRate() internal {\n        // Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable\n        ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);\n        Prices.TWAP memory twapPrices = getTWAPs(currentHour);\n        int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();\n        uint256 underlyingTWAP = twapPrices.underlying;\n        uint256 derivativeTWAP = twapPrices.derivative;\n\n        int256 newFundingRate = PRBMathSD59x18.mul(\n            derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,\n            _tracer.fundingRateSensitivity().toInt256()\n        );\n\n        // Create variable with value of new funding rate value\n        int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;\n\n        // as above but with insurance funding rate value\n        int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;\n\n        // Call setter functions on calculated variables\n        setFundingRate(newFundingRate, cumulativeFundingRate);\n        emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);\n        setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);\n        emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);\n        // increment funding index\n        currentFundingIndex = currentFundingIndex + 1;\n    }\n\n    /**\n     * @notice Given the address of a tracer market this function will get the current fair price for that market\n     */\n    function fairPrice() external view override returns (uint256) {\n        return Prices.fairPrice(oracle.latestAnswer(), timeValue);\n    }\n\n    ////////////////////////////\n    ///  SETTER FUNCTIONS   ///\n    //////////////////////////\n\n    /**\n     * @notice Calculates and then updates the time Value for a tracer market\n     */\n    function updateTimeValue() internal {\n        (uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();\n\n        timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct\n     * @param fundingRate The funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        fundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct for a particular Tracer Marker\n     * @param fundingRate The insurance funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    // todo by using public variables lots of these can be removed\n    /**\n     * @return each variable of the fundingRate struct of a particular tracer at a particular funding rate index\n     */\n    function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return fundingRates[index];\n    }\n\n    /**\n     * @return all of the variables in the funding rate struct (insurance rate) from a particular tracer market\n     */\n    function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return insuranceFundingRates[index];\n    }\n\n    /**\n     * @notice Gets an 8 hour time weighted avg price for a given tracer, at a particular hour. More recent prices are weighted more heavily.\n     * @param hour An integer representing what hour of the day to collect from (0-24)\n     * @return the time weighted average price for both the oraclePrice (derivative price) and the Tracer Price\n     */\n    function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {\n        return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);\n    }\n\n    /**\n     * @notice Gets a 24 hour tracer and oracle price for a given tracer market\n     * @return the average price over a 24 hour period for oracle and Tracer price\n     */\n    function get24HourPrices() public view override returns (uint256, uint256) {\n        return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));\n    }\n\n    /**\n     * @notice Gets the average tracer price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     * @return the average price of the tracer for a particular hour\n     */\n    function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {\n        return Prices.averagePrice(hourlyTracerPrices[hour]);\n    }\n\n    /**\n     * @notice Gets the average oracle price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     */\n    function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {\n        return Prices.averagePrice(hourlyOraclePrices[hour]);\n    }\n\n    /**\n     * @dev Used when only valid tracers are allowed\n     */\n    modifier onlyTracer() {\n        require(msg.sender == tracer, \"PRC: Only Tracer\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/SafetyWithdraw.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport {Types} from \"./Interfaces/Types.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant override LIQUIDATION_GAS_COST = 63516;\n    address public immutable override tracerQuoteToken;\n    uint256 public immutable override quoteTokenDecimals;\n    bytes32 public immutable override marketId;\n    IPricing public pricingContract;\n    IInsurance public insuranceContract;\n    address public override liquidationContract;\n    uint256 public override feeRate;\n    uint256 public override fees;\n    address public override feeReceiver;\n\n    /* Config variables */\n    // The price of gas in gwei\n    address public override gasPriceOracle;\n    // The maximum ratio of notionalValue to margin\n    uint256 public override maxLeverage;\n    // WAD value. sensitivity of 1 = 1*10^18\n    uint256 public override fundingRateSensitivity;\n    // WAD value. The percentage for insurance pool holdings/pool target where deleveraging begins\n    uint256 public override deleveragingCliff;\n    /* The percentage of insurance holdings to target at which the insurance pool\n       funding rate changes, and lowestMaxLeverage is reached */\n    uint256 public override insurancePoolSwitchStage;\n    // The lowest value that maxLeverage can be, if insurance pool is empty.\n    uint256 public override lowestMaxLeverage;\n\n    // Account State Variables\n    mapping(address => Balances.Account) public balances;\n    uint256 public tvl;\n    uint256 public override leveragedNotionalValue;\n\n    // Trading interfaces whitelist\n    mapping(address => bool) public override tradingWhitelist;\n\n    event FeeReceiverUpdated(address indexed receiver);\n    event FeeWithdrawn(address indexed receiver, uint256 feeAmount);\n    event Deposit(address indexed user, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed amount);\n    event Settled(address indexed account, int256 margin);\n    event MatchedOrders(\n        address indexed long,\n        address indexed short,\n        uint256 amount,\n        uint256 price,\n        bytes32 longOrderId,\n        bytes32 shortOrderId\n    );\n    event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);\n\n    /**\n     * @notice Creates a new tracer market and sets the initial funding rate of the market. Anyone\n     *         will be able to purchase and trade tracers after this deployment.\n     * @param _marketId the id of the market, given as BASE/QUOTE\n     * @param _tracerQuoteToken the address of the token used for margin accounts (i.e. The margin token)\n     * @param _tokenDecimals the number of decimal places the quote token supports\n     * @param _gasPriceOracle the address of the contract implementing gas price oracle\n     * @param _maxLeverage the max leverage of the market represented as a WAD value.\n     * @param _fundingRateSensitivity the affect funding rate changes have on funding paid; u60.18-decimal fixed-point number (WAD value)\n     * @param _feeRate the fee taken on trades; WAD value. e.g. 2% fee = 0.02 * 10^18 = 2 * 10^16\n     * @param _feeReceiver the address of the person who can withdraw the fees from trades in this market\n     * @param _deleveragingCliff The percentage for insurance pool holdings/pool target where deleveraging begins.\n     *                           WAD value. e.g. 20% = 20*10^18\n     * @param _lowestMaxLeverage The lowest value that maxLeverage can be, if insurance pool is empty.\n     * @param _insurancePoolSwitchStage The percentage of insurance holdings to target at which the insurance pool\n     *                                  funding rate changes, and lowestMaxLeverage is reached\n     */\n    constructor(\n        bytes32 _marketId,\n        address _tracerQuoteToken,\n        uint256 _tokenDecimals,\n        address _gasPriceOracle,\n        uint256 _maxLeverage,\n        uint256 _fundingRateSensitivity,\n        uint256 _feeRate,\n        address _feeReceiver,\n        uint256 _deleveragingCliff,\n        uint256 _lowestMaxLeverage,\n        uint256 _insurancePoolSwitchStage\n    ) Ownable() {\n        // don't convert to interface as we don't need to interact with the contract\n        tracerQuoteToken = _tracerQuoteToken;\n        quoteTokenDecimals = _tokenDecimals;\n        gasPriceOracle = _gasPriceOracle;\n        marketId = _marketId;\n        feeRate = _feeRate;\n        maxLeverage = _maxLeverage;\n        fundingRateSensitivity = _fundingRateSensitivity;\n        feeReceiver = _feeReceiver;\n        deleveragingCliff = _deleveragingCliff;\n        lowestMaxLeverage = _lowestMaxLeverage;\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    /**\n     * @notice Adjust the max leverage as insurance pool slides from 100% of target to 0% of target\n     */\n    function trueMaxLeverage() public view override returns (uint256) {\n        IInsurance insurance = IInsurance(insuranceContract);\n\n        return\n            Perpetuals.calculateTrueMaxLeverage(\n                insurance.getPoolHoldings(),\n                insurance.getPoolTarget(),\n                maxLeverage,\n                lowestMaxLeverage,\n                deleveragingCliff,\n                insurancePoolSwitchStage\n            );\n    }\n\n    /**\n     * @notice Allows a user to deposit into their margin account\n     * @dev this contract must be an approved spender of the markets quote token on behalf of the depositer.\n     * @param amount The amount of quote tokens to be deposited into the Tracer Market account. This amount\n     * should be given in WAD format.\n     */\n    function deposit(uint256 amount) external override {\n        Balances.Account storage userBalance = balances[msg.sender];\n        // settle outstanding payments\n        settle(msg.sender);\n\n        // convert the WAD amount to the correct token amount to transfer\n        // cast is safe since amount is a uint, and wadToToken can only\n        // scale down the value\n        uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());\n        IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // this prevents dust from being added to the user account\n        // eg 10^18 -> 10^8 -> 10^18 will remove lower order bits\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        // update user state\n        userBalance.position.quote = userBalance.position.quote + convertedWadAmount;\n        _updateAccountLeverage(msg.sender);\n\n        // update market TVL\n        tvl = tvl + uint256(convertedWadAmount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw from their margin account\n     * @dev Ensures that the users margin percent is valid after withdraw\n     * @param amount The amount of margin tokens to be withdrawn from the tracer market account. This amount\n     * should be given in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        // settle outstanding payments\n        settle(msg.sender);\n\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        Balances.Account storage userBalance = balances[msg.sender];\n        int256 newQuote = userBalance.position.quote - convertedWadAmount;\n\n        // this may be able to be optimised\n        Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);\n\n        require(\n            Balances.marginIsValid(\n                newPosition,\n                userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ),\n            \"TCR: Withdraw below valid Margin\"\n        );\n\n        // update user state\n        userBalance.position.quote = newQuote;\n        _updateAccountLeverage(msg.sender);\n\n        // Safemath will throw if tvl < amount\n        tvl = tvl - amount;\n\n        // perform transfer\n        IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);\n        emit Withdraw(msg.sender, uint256(convertedWadAmount));\n    }\n\n    /**\n     * @notice Attempt to match two orders that exist on-chain against each other\n     * @dev Emits a FailedOrders or MatchedOrders event based on whether the\n     *      orders were successfully able to be matched\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount Amount that the two orders are being filled for\n     * @return Whether the two orders were able to be matched successfully\n     */\n    function matchOrders(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount\n    ) external override onlyWhitelisted returns (bool) {\n        bytes32 order1Id = Perpetuals.orderId(order1);\n        bytes32 order2Id = Perpetuals.orderId(order2);\n        uint256 filled1 = ITrader(msg.sender).filled(order1Id);\n        uint256 filled2 = ITrader(msg.sender).filled(order2Id);\n\n        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);\n\n        // settle accounts\n        // note: this can revert and hence no order events will be emitted\n        settle(order1.maker);\n        settle(order2.maker);\n\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(\n            order1,\n            order2,\n            fillAmount,\n            executionPrice\n        );\n        // validate orders can match, and outcome state is valid\n        if (\n            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||\n            !Balances.marginIsValid(\n                newPos1,\n                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ) ||\n            !Balances.marginIsValid(\n                newPos2,\n                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            )\n        ) {\n            // emit failed to match event and return false\n            if (order1.side == Perpetuals.Side.Long) {\n                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);\n            } else {\n                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);\n            }\n            return false;\n        }\n\n        // update account states\n        balances[order1.maker].position = newPos1;\n        balances[order2.maker].position = newPos2;\n\n        // update fees\n        fees =\n            fees +\n            // add 2 * fees since getFeeRate returns the fee rate for a single\n            // side of the order. Both users were charged fees\n            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);\n\n        // update leverage\n        _updateAccountLeverage(order1.maker);\n        _updateAccountLeverage(order2.maker);\n\n        // Update internal trade state\n        pricingContract.recordTrade(executionPrice);\n\n        if (order1.side == Perpetuals.Side.Long) {\n            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);\n        } else {\n            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Updates account states of two accounts given two orders that are being executed\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount The amount that the two ordered are being filled for\n     * @param executionPrice The execution price of the trades\n     * @return The new balances of the two accounts after the trade\n     */\n    function _executeTrade(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount,\n        uint256 executionPrice\n    ) internal view returns (Balances.Position memory, Balances.Position memory) {\n        // Retrieve account state\n        Balances.Account memory account1 = balances[order1.maker];\n        Balances.Account memory account2 = balances[order2.maker];\n\n        // Construct `Trade` types suitable for use with LibBalances\n        (Balances.Trade memory trade1, Balances.Trade memory trade2) = (\n            Balances.Trade(executionPrice, fillAmount, order1.side),\n            Balances.Trade(executionPrice, fillAmount, order2.side)\n        );\n\n        // Calculate new account state\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = (\n            Balances.applyTrade(account1.position, trade1, feeRate),\n            Balances.applyTrade(account2.position, trade2, feeRate)\n        );\n\n        // return new account state\n        return (newPos1, newPos2);\n    }\n\n    /**\n     * @notice internal function for updating leverage. Called within the Account contract. Also\n     *         updates the total leveraged notional value for the tracer market itself.\n     */\n    function _updateAccountLeverage(address account) internal {\n        Balances.Account memory userBalance = balances[account];\n        uint256 originalLeverage = userBalance.totalLeveragedValue;\n        uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());\n        balances[account].totalLeveragedValue = newLeverage;\n\n        // Update market leveraged notional value\n        _updateTracerLeverage(newLeverage, originalLeverage);\n    }\n\n    /**\n     * @notice Updates the global leverage value given an accounts new leveraged value and old leveraged value\n     * @param accountNewLeveragedNotional The future notional value of the account\n     * @param accountOldLeveragedNotional The stored notional value of the account\n     */\n    function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {\n        leveragedNotionalValue = Prices.globalLeverage(\n            leveragedNotionalValue,\n            accountOldLeveragedNotional,\n            accountNewLeveragedNotional\n        );\n    }\n\n    /**\n     * @notice When a liquidation occurs, Liquidation.sol needs to push this contract to update\n     *         account states as necessary.\n     * @param liquidator Address of the account that called liquidate(...)\n     * @param liquidatee Address of the under-margined account getting liquidated\n     * @param liquidatorQuoteChange Amount the liquidator's quote is changing\n     * @param liquidatorBaseChange Amount the liquidator's base is changing\n     * @param liquidateeQuoteChange Amount the liquidated account's quote is changing\n     * @param liquidateeBaseChange Amount the liquidated account's base is changing\n     * @param amountToEscrow The amount the liquidator has to put into escrow\n     */\n    function updateAccountsOnLiquidation(\n        address liquidator,\n        address liquidatee,\n        int256 liquidatorQuoteChange,\n        int256 liquidatorBaseChange,\n        int256 liquidateeQuoteChange,\n        int256 liquidateeBaseChange,\n        uint256 amountToEscrow\n    ) external override onlyLiquidation {\n        // Limits the gas use when liquidating\n        uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();\n        // Update liquidators last updated gas price\n        Balances.Account storage liquidatorBalance = balances[liquidator];\n        Balances.Account storage liquidateeBalance = balances[liquidatee];\n\n        // update liquidators balance\n        liquidatorBalance.lastUpdatedGasPrice = gasPrice;\n        liquidatorBalance.position.quote =\n            liquidatorBalance.position.quote +\n            liquidatorQuoteChange -\n            amountToEscrow.toInt256();\n        liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;\n\n        // update liquidatee balance\n        liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;\n        liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;\n\n        // Checks if the liquidator is in a valid position to process the liquidation\n        require(userMarginIsValid(liquidator), \"TCR: Liquidator under min margin\");\n    }\n\n    /**\n     * @notice When a liquidation receipt is claimed by the liquidator (i.e. they experienced slippage),\n               Liquidation.sol needs to tell the market to update its balance and the balance of the\n               liquidated agent.\n     * @dev Gives the leftover amount from the receipt to the liquidated agent\n     * @param claimant The liquidator, who has experienced slippage selling the liquidated position\n     * @param amountToGiveToClaimant The amount the liquidator is owe based off slippage\n     * @param liquidatee The account that originally got liquidated\n     * @param amountToGiveToLiquidatee Amount owed to the liquidated account\n     * @param amountToTakeFromInsurance Amount that needs to be taken from the insurance pool\n                                        in order to cover liquidation\n     */\n    function updateAccountsOnClaim(\n        address claimant,\n        int256 amountToGiveToClaimant,\n        address liquidatee,\n        int256 amountToGiveToLiquidatee,\n        int256 amountToTakeFromInsurance\n    ) external override onlyLiquidation {\n        address insuranceAddr = address(insuranceContract);\n        balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;\n        balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;\n        balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;\n        require(balances[insuranceAddr].position.quote >= 0, \"TCR: Insurance not funded enough\");\n    }\n\n    /**\n     * @notice settles an account. Compares current global rate with the users last updated rate\n     *         Updates the accounts margin balance accordingly.\n     * @dev Ensures the account remains in a valid margin position. Will throw if account is under margin\n     *      and the account must then be liquidated.\n     * @param account the address to settle.\n     * @dev This function aggregates data to feed into account.sols settle function which sets\n     */\n    function settle(address account) public override {\n        // Get account and global last updated indexes\n        uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;\n        uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();\n        Balances.Account storage accountBalance = balances[account];\n\n        // if this user has no positions, bring them in sync\n        if (accountBalance.position.base == 0) {\n            // set to the last fully established index\n            accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n        } else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {\n            // Only settle account if its last updated index was before the last established\n            // global index this is since we reference the last global index\n            // Get current and global funding statuses\n            uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;\n            // Note: global rates reference the last fully established rate (hence the -1), and not\n            // the current global rate. User rates reference the last saved user rate\n            Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);\n            Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);\n\n            Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(\n                lastEstablishedIndex\n            );\n\n            Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(\n                accountLastUpdatedIndex\n            );\n\n            // settle the account\n            Balances.Account storage insuranceBalance = balances[address(insuranceContract)];\n\n            accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);\n\n            // Update account gas price\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n\n            if (accountBalance.totalLeveragedValue > 0) {\n                (Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(\n                    accountBalance.position,\n                    insuranceBalance.position,\n                    currInsuranceGlobalRate,\n                    currInsuranceUserRate,\n                    accountBalance.totalLeveragedValue\n                );\n\n                balances[account].position = newUserPos;\n                balances[(address(insuranceContract))].position = newInsurancePos;\n            }\n\n            // Update account index\n            accountBalance.lastUpdatedIndex = lastEstablishedIndex;\n            require(userMarginIsValid(account), \"TCR: Target under-margined\");\n            emit Settled(account, accountBalance.position.quote);\n        }\n    }\n\n    /**\n     * @notice Checks if a given accounts margin is valid\n     * @param account The address of the account whose margin is to be checked\n     * @return true if the margin is valid or false otherwise\n     */\n    function userMarginIsValid(address account) public view returns (bool) {\n        Balances.Account memory accountBalance = balances[account];\n        return\n            Balances.marginIsValid(\n                accountBalance.position,\n                accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            );\n    }\n\n    /**\n     * @notice Withdraws the fees taken on trades, and sends them to the designated\n     *         fee receiver (set by the owner of the market)\n     * @dev Anyone can call this function, but fees are transferred to the fee receiver.\n     *      Fees is also subtracted from the total value locked in the market because\n     *      fees are taken out of trades that result in users' quotes being modified, and\n     *      don't otherwise get subtracted from the tvl of the market\n     */\n    function withdrawFees() external override {\n        uint256 tempFees = fees;\n        fees = 0;\n        tvl = tvl - tempFees;\n\n        // Withdraw from the account\n        IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);\n        emit FeeWithdrawn(feeReceiver, tempFees);\n    }\n\n    function getBalance(address account) external view override returns (Balances.Account memory) {\n        return balances[account];\n    }\n\n    function setLiquidationContract(address _liquidationContract) external override onlyOwner {\n        require(_liquidationContract != address(0), \"address(0) given\");\n        liquidationContract = _liquidationContract;\n    }\n\n    function setInsuranceContract(address insurance) external override onlyOwner {\n        require(insurance != address(0), \"address(0) given\");\n        insuranceContract = IInsurance(insurance);\n    }\n\n    function setPricingContract(address pricing) external override onlyOwner {\n        require(pricing != address(0), \"address(0) given\");\n        pricingContract = IPricing(pricing);\n    }\n\n    function setGasOracle(address _gasOracle) external override onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasPriceOracle = _gasOracle;\n    }\n\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address(0) given\");\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    function setFeeRate(uint256 _feeRate) external override onlyOwner {\n        feeRate = _feeRate;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {\n        maxLeverage = _maxLeverage;\n    }\n\n    function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {\n        fundingRateSensitivity = _fundingRateSensitivity;\n    }\n\n    function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {\n        deleveragingCliff = _deleveragingCliff;\n    }\n\n    function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {\n        lowestMaxLeverage = _lowestMaxLeverage;\n    }\n\n    function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {\n        require(newOwner != address(0), \"address(0) given\");\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice allows the owner of a market to set the whitelisting of a trading interface address\n     * @dev a permissioned interface may call the matchOrders function.\n     * @param tradingContract the contract to have its whitelisting permissions set\n     * @param whitelisted the permission of the contract. If true this contract make call makeOrder\n     */\n    function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {\n        tradingWhitelist[tradingContract] = whitelisted;\n    }\n\n    // Modifier such that only the set liquidation contract can call a function\n    modifier onlyLiquidation() {\n        require(msg.sender == liquidationContract, \"TCR: Sender not liquidation\");\n        _;\n    }\n\n    // Modifier such that only a whitelisted trader can call a function\n    modifier onlyWhitelisted() {\n        require(tradingWhitelist[msg.sender], \"TCR: Contract not whitelisted\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Pricing.sol",
            "TracerPerpetualSwaps.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "maxLeverage",
                    "insurancePoolSwitchStage",
                    "lowestMaxLeverage",
                    "fundingRateSensitivity",
                    "feeRate",
                    "deleveragingCliff"
                ],
                "Type": " Missing events for critical parameter changing operations by owner",
                "Description": "\nThe owner of TracerPerpetualSwaps contract, who is potentially untrusted as per specification, can change the market critical parameters such as the addresses of the Liquidation/Pricing/Insurance/GasOracle/FeeReceiver and also critical values such as  feeRate, maxLeverage, fundingRateSensitivity, deleveragingCliff, lowestMaxLeverage, insurancePoolSwitchStage and whitelisting.\n\nNone of these setter functions emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.\n\nThe impact of this is that, if a malicious owner changes the critical addresses or values that significantly change the security posture/perception of the protocol. No events are emitted and users lose funds/confidence. The protocol takes a reputation hit.\n\nSee similar high-severity finding in OpenZeppelin\u2019s Audit of Audius(https://blog.openzeppelin.com/audius-contracts-audit/#high) and medium-severity finding OpenZeppelin\u2019s Audit of UMA Phase 4(https://blog.openzeppelin.com/uma-audit-phase-4/).\n\n",
                "Repair": "Recommend to consider emitting events when these addresses/values are updated. This will be more transparent and it will make it easier to keep track of the status of the system.\n\nraymogg (Tracer) marked as duplicate of another (confirmed issue)(https://github.com/code-423n4/2021-06-tracer-findings/issues/64#issuecomment-873760825):\n  Duplicate of #66\n\ncemozerr (Judge) reopened and removed duplicate label(https://github.com/code-423n4/2021-06-tracer-findings/issues/64#issuecomment-882106845):\n  Opening this issue as the event emission seems to be separate from the arbitrarily changing of the values.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./InsurancePoolToken.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport \"./lib/LibInsurance.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract Insurance is IInsurance {\n    using LibMath for uint256;\n    using LibMath for int256;\n    ITracerPerpetualsFactory public perpsFactory;\n\n    address public collateralAsset; // Address of collateral asset\n    uint256 public override publicCollateralAmount; // amount of underlying collateral in public pool, in WAD format\n    uint256 public override bufferCollateralAmount; // amount of collateral in buffer pool, in WAD format\n    address public token; // token representation of a users holding in the pool\n\n    ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool\n\n    event InsuranceDeposit(address indexed market, address indexed user, uint256 indexed amount);\n    event InsuranceWithdraw(address indexed market, address indexed user, uint256 indexed amount);\n    event InsurancePoolDeployed(address indexed market, address indexed asset);\n\n    constructor(address _tracer) {\n        tracer = ITracerPerpetualSwaps(_tracer);\n        InsurancePoolToken _token = new InsurancePoolToken(\"Tracer Pool Token\", \"TPT\");\n        token = address(_token);\n        collateralAsset = tracer.tracerQuoteToken();\n\n        emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());\n    }\n\n    /**\n     * @notice Allows a user to deposit to a given tracer market insurance pool\n     * @dev Mints amount of the pool token to the user\n     * @param amount the amount of tokens to deposit. Provided in WAD format\n     */\n    function deposit(uint256 amount) external override {\n        IERC20 collateralToken = IERC20(collateralAsset);\n\n        // convert token amount to WAD\n        uint256 quoteTokenDecimals = tracer.quoteTokenDecimals();\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        collateralToken.transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // amount in wad format after being converted from token format\n        uint256 wadAmount = uint256(Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount));\n\n        // Update pool balances and user\n        updatePoolAmount();\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to mint = (pool token supply / collateral holdings) * collateral amount to stake\n        uint256 tokensToMint = LibInsurance.calcMintAmount(poolToken.totalSupply(), publicCollateralAmount, wadAmount);\n\n        // mint pool tokens, hold collateral tokens\n        poolToken.mint(msg.sender, tokensToMint);\n        publicCollateralAmount = publicCollateralAmount + wadAmount;\n        emit InsuranceDeposit(address(tracer), msg.sender, wadAmount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw their assets from a given insurance pool\n     * @dev burns amount of tokens from the pool token\n     * @param amount the amount of pool tokens to burn. Provided in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        updatePoolAmount();\n        uint256 balance = getPoolUserBalance(msg.sender);\n        require(balance >= amount, \"INS: balance < amount\");\n\n        IERC20 collateralToken = IERC20(collateralAsset);\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to return = (collateral holdings / pool token supply) * amount of pool tokens to withdraw\n        uint256 wadTokensToSend = LibInsurance.calcWithdrawAmount(\n            poolToken.totalSupply(),\n            publicCollateralAmount,\n            amount\n        );\n\n        // convert token amount to raw amount from WAD\n        uint256 rawTokenAmount = Balances.wadToToken(tracer.quoteTokenDecimals(), wadTokensToSend);\n\n        // pool amount is always in WAD format\n        publicCollateralAmount = publicCollateralAmount - wadTokensToSend;\n\n        // burn pool tokens, return collateral tokens\n        poolToken.burnFrom(msg.sender, amount);\n        collateralToken.transfer(msg.sender, rawTokenAmount);\n\n        emit InsuranceWithdraw(address(tracer), msg.sender, wadTokensToSend);\n    }\n\n    /**\n     * @notice Internally updates a given tracer's pool amount according to the tracer contract\n     * @dev Withdraws from tracer, and adds amount to the pool's amount field.\n     */\n    function updatePoolAmount() public override {\n        uint256 quote = uint256((tracer.getBalance(address(this))).position.quote);\n\n        tracer.withdraw(quote);\n\n        if (publicCollateralAmount > 0) {\n            // Amount to pay to public is the ratio of public collateral amount to total funds\n            uint256 payToPublic = PRBMathUD60x18.mul(\n                quote,\n                PRBMathUD60x18.div(publicCollateralAmount, getPoolHoldings())\n            );\n\n            publicCollateralAmount = publicCollateralAmount + payToPublic;\n\n            // Amount to pay to buffer is the remainder\n            bufferCollateralAmount = bufferCollateralAmount + quote - payToPublic;\n        } else {\n            // Pay to buffer if nothing in public insurance\n            bufferCollateralAmount = bufferCollateralAmount + quote;\n        }\n    }\n\n    /**\n     * @notice Deposits some of the insurance pool's amount into the tracer contract\n     * @dev If amount is greater than the insurance pool's balance, deposit total balance.\n     *      This was done because in such an emergency situation, we want to recover as much as possible\n     * @param amount The desired amount to take from the insurance pool\n     */\n    function drainPool(uint256 amount) external override onlyLiquidation() {\n        IERC20 tracerMarginToken = IERC20(tracer.tracerQuoteToken());\n\n        uint256 poolHoldings = getPoolHoldings();\n\n        if (amount >= poolHoldings) {\n            // If public collateral left after draining is less than 1 token, we want to keep it at 1 token\n            if (publicCollateralAmount > 10**18) {\n                // Leave 1 token for the public pool\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                amount = bufferCollateralAmount;\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else if (amount > bufferCollateralAmount) {\n            if (publicCollateralAmount < 10**18) {\n                // If there's not enough public collateral for there to be 1 token, cap amount being drained at the buffer\n                amount = bufferCollateralAmount;\n            } else if (poolHoldings - amount < 10**18) {\n                // If the amount of collateral left in the public insurance would be less than 1 token, cap amount being drained\n                // from the public insurance such that 1 token is left in the public buffer\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                // Take out what you need from the public pool; there's enough for there to be >= 1 token left\n                publicCollateralAmount = publicCollateralAmount - (amount - bufferCollateralAmount);\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else {\n            // Only need to take part of buffer pool out\n            bufferCollateralAmount = bufferCollateralAmount - amount;\n        }\n\n        tracerMarginToken.approve(address(tracer), amount);\n        tracer.deposit(amount);\n    }\n\n    /**\n     * @notice gets a users balance in a given insurance pool\n     * @param user the user whose balance is being retrieved\n     */\n    function getPoolUserBalance(address user) public view override returns (uint256) {\n        return InsurancePoolToken(token).balanceOf(user);\n    }\n\n    /**\n     * @notice Get total holdings of the insurance pool (= public + buffer collateral)\n     */\n    function getPoolHoldings() public view override returns (uint256) {\n        return bufferCollateralAmount + publicCollateralAmount;\n    }\n\n    /**\n     * @notice Gets the target fund amount for a given insurance pool\n     * @dev The target amount is 1% of the leveraged notional value of the tracer being insured.\n     */\n    function getPoolTarget() public view override returns (uint256) {\n        return tracer.leveragedNotionalValue() / 100;\n    }\n\n    /**\n     * @notice Gets the 8 hour funding rate for an insurance pool\n     * @dev the funding rate is represented as\n     *      0.0036523 * (insurance_fund_target - insurance_fund_holdings) / leveraged_notional_value)\n     */\n    function getPoolFundingRate() external view override returns (uint256) {\n        // 0.0036523 as a WAD = 36523 * (10**11)\n        uint256 multiplyFactor = 36523 * (10**11);\n\n        uint256 levNotionalValue = tracer.leveragedNotionalValue();\n\n        // Traders only pay the insurance funding rate if the market has leverage\n        if (levNotionalValue == 0) {\n            return 0;\n        }\n\n        uint256 poolHoldings = getPoolHoldings();\n        uint256 poolTarget = getPoolTarget();\n\n        // If the pool is above the target, we don't pay the insurance funding rate\n        if (poolTarget <= poolHoldings) {\n            return 0;\n        }\n\n        uint256 ratio = PRBMathUD60x18.div(poolTarget - poolHoldings, levNotionalValue);\n\n        return PRBMathUD60x18.mul(multiplyFactor, ratio);\n    }\n\n    modifier onlyLiquidation() {\n        require(msg.sender == tracer.liquidationContract(), \"INS: sender not LIQ contract\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/SafetyWithdraw.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport {Types} from \"./Interfaces/Types.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant override LIQUIDATION_GAS_COST = 63516;\n    address public immutable override tracerQuoteToken;\n    uint256 public immutable override quoteTokenDecimals;\n    bytes32 public immutable override marketId;\n    IPricing public pricingContract;\n    IInsurance public insuranceContract;\n    address public override liquidationContract;\n    uint256 public override feeRate;\n    uint256 public override fees;\n    address public override feeReceiver;\n\n    /* Config variables */\n    // The price of gas in gwei\n    address public override gasPriceOracle;\n    // The maximum ratio of notionalValue to margin\n    uint256 public override maxLeverage;\n    // WAD value. sensitivity of 1 = 1*10^18\n    uint256 public override fundingRateSensitivity;\n    // WAD value. The percentage for insurance pool holdings/pool target where deleveraging begins\n    uint256 public override deleveragingCliff;\n    /* The percentage of insurance holdings to target at which the insurance pool\n       funding rate changes, and lowestMaxLeverage is reached */\n    uint256 public override insurancePoolSwitchStage;\n    // The lowest value that maxLeverage can be, if insurance pool is empty.\n    uint256 public override lowestMaxLeverage;\n\n    // Account State Variables\n    mapping(address => Balances.Account) public balances;\n    uint256 public tvl;\n    uint256 public override leveragedNotionalValue;\n\n    // Trading interfaces whitelist\n    mapping(address => bool) public override tradingWhitelist;\n\n    event FeeReceiverUpdated(address indexed receiver);\n    event FeeWithdrawn(address indexed receiver, uint256 feeAmount);\n    event Deposit(address indexed user, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed amount);\n    event Settled(address indexed account, int256 margin);\n    event MatchedOrders(\n        address indexed long,\n        address indexed short,\n        uint256 amount,\n        uint256 price,\n        bytes32 longOrderId,\n        bytes32 shortOrderId\n    );\n    event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);\n\n    /**\n     * @notice Creates a new tracer market and sets the initial funding rate of the market. Anyone\n     *         will be able to purchase and trade tracers after this deployment.\n     * @param _marketId the id of the market, given as BASE/QUOTE\n     * @param _tracerQuoteToken the address of the token used for margin accounts (i.e. The margin token)\n     * @param _tokenDecimals the number of decimal places the quote token supports\n     * @param _gasPriceOracle the address of the contract implementing gas price oracle\n     * @param _maxLeverage the max leverage of the market represented as a WAD value.\n     * @param _fundingRateSensitivity the affect funding rate changes have on funding paid; u60.18-decimal fixed-point number (WAD value)\n     * @param _feeRate the fee taken on trades; WAD value. e.g. 2% fee = 0.02 * 10^18 = 2 * 10^16\n     * @param _feeReceiver the address of the person who can withdraw the fees from trades in this market\n     * @param _deleveragingCliff The percentage for insurance pool holdings/pool target where deleveraging begins.\n     *                           WAD value. e.g. 20% = 20*10^18\n     * @param _lowestMaxLeverage The lowest value that maxLeverage can be, if insurance pool is empty.\n     * @param _insurancePoolSwitchStage The percentage of insurance holdings to target at which the insurance pool\n     *                                  funding rate changes, and lowestMaxLeverage is reached\n     */\n    constructor(\n        bytes32 _marketId,\n        address _tracerQuoteToken,\n        uint256 _tokenDecimals,\n        address _gasPriceOracle,\n        uint256 _maxLeverage,\n        uint256 _fundingRateSensitivity,\n        uint256 _feeRate,\n        address _feeReceiver,\n        uint256 _deleveragingCliff,\n        uint256 _lowestMaxLeverage,\n        uint256 _insurancePoolSwitchStage\n    ) Ownable() {\n        // don't convert to interface as we don't need to interact with the contract\n        tracerQuoteToken = _tracerQuoteToken;\n        quoteTokenDecimals = _tokenDecimals;\n        gasPriceOracle = _gasPriceOracle;\n        marketId = _marketId;\n        feeRate = _feeRate;\n        maxLeverage = _maxLeverage;\n        fundingRateSensitivity = _fundingRateSensitivity;\n        feeReceiver = _feeReceiver;\n        deleveragingCliff = _deleveragingCliff;\n        lowestMaxLeverage = _lowestMaxLeverage;\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    /**\n     * @notice Adjust the max leverage as insurance pool slides from 100% of target to 0% of target\n     */\n    function trueMaxLeverage() public view override returns (uint256) {\n        IInsurance insurance = IInsurance(insuranceContract);\n\n        return\n            Perpetuals.calculateTrueMaxLeverage(\n                insurance.getPoolHoldings(),\n                insurance.getPoolTarget(),\n                maxLeverage,\n                lowestMaxLeverage,\n                deleveragingCliff,\n                insurancePoolSwitchStage\n            );\n    }\n\n    /**\n     * @notice Allows a user to deposit into their margin account\n     * @dev this contract must be an approved spender of the markets quote token on behalf of the depositer.\n     * @param amount The amount of quote tokens to be deposited into the Tracer Market account. This amount\n     * should be given in WAD format.\n     */\n    function deposit(uint256 amount) external override {\n        Balances.Account storage userBalance = balances[msg.sender];\n        // settle outstanding payments\n        settle(msg.sender);\n\n        // convert the WAD amount to the correct token amount to transfer\n        // cast is safe since amount is a uint, and wadToToken can only\n        // scale down the value\n        uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());\n        IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // this prevents dust from being added to the user account\n        // eg 10^18 -> 10^8 -> 10^18 will remove lower order bits\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        // update user state\n        userBalance.position.quote = userBalance.position.quote + convertedWadAmount;\n        _updateAccountLeverage(msg.sender);\n\n        // update market TVL\n        tvl = tvl + uint256(convertedWadAmount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw from their margin account\n     * @dev Ensures that the users margin percent is valid after withdraw\n     * @param amount The amount of margin tokens to be withdrawn from the tracer market account. This amount\n     * should be given in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        // settle outstanding payments\n        settle(msg.sender);\n\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        Balances.Account storage userBalance = balances[msg.sender];\n        int256 newQuote = userBalance.position.quote - convertedWadAmount;\n\n        // this may be able to be optimised\n        Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);\n\n        require(\n            Balances.marginIsValid(\n                newPosition,\n                userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ),\n            \"TCR: Withdraw below valid Margin\"\n        );\n\n        // update user state\n        userBalance.position.quote = newQuote;\n        _updateAccountLeverage(msg.sender);\n\n        // Safemath will throw if tvl < amount\n        tvl = tvl - amount;\n\n        // perform transfer\n        IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);\n        emit Withdraw(msg.sender, uint256(convertedWadAmount));\n    }\n\n    /**\n     * @notice Attempt to match two orders that exist on-chain against each other\n     * @dev Emits a FailedOrders or MatchedOrders event based on whether the\n     *      orders were successfully able to be matched\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount Amount that the two orders are being filled for\n     * @return Whether the two orders were able to be matched successfully\n     */\n    function matchOrders(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount\n    ) external override onlyWhitelisted returns (bool) {\n        bytes32 order1Id = Perpetuals.orderId(order1);\n        bytes32 order2Id = Perpetuals.orderId(order2);\n        uint256 filled1 = ITrader(msg.sender).filled(order1Id);\n        uint256 filled2 = ITrader(msg.sender).filled(order2Id);\n\n        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);\n\n        // settle accounts\n        // note: this can revert and hence no order events will be emitted\n        settle(order1.maker);\n        settle(order2.maker);\n\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(\n            order1,\n            order2,\n            fillAmount,\n            executionPrice\n        );\n        // validate orders can match, and outcome state is valid\n        if (\n            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||\n            !Balances.marginIsValid(\n                newPos1,\n                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ) ||\n            !Balances.marginIsValid(\n                newPos2,\n                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            )\n        ) {\n            // emit failed to match event and return false\n            if (order1.side == Perpetuals.Side.Long) {\n                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);\n            } else {\n                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);\n            }\n            return false;\n        }\n\n        // update account states\n        balances[order1.maker].position = newPos1;\n        balances[order2.maker].position = newPos2;\n\n        // update fees\n        fees =\n            fees +\n            // add 2 * fees since getFeeRate returns the fee rate for a single\n            // side of the order. Both users were charged fees\n            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);\n\n        // update leverage\n        _updateAccountLeverage(order1.maker);\n        _updateAccountLeverage(order2.maker);\n\n        // Update internal trade state\n        pricingContract.recordTrade(executionPrice);\n\n        if (order1.side == Perpetuals.Side.Long) {\n            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);\n        } else {\n            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Updates account states of two accounts given two orders that are being executed\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount The amount that the two ordered are being filled for\n     * @param executionPrice The execution price of the trades\n     * @return The new balances of the two accounts after the trade\n     */\n    function _executeTrade(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount,\n        uint256 executionPrice\n    ) internal view returns (Balances.Position memory, Balances.Position memory) {\n        // Retrieve account state\n        Balances.Account memory account1 = balances[order1.maker];\n        Balances.Account memory account2 = balances[order2.maker];\n\n        // Construct `Trade` types suitable for use with LibBalances\n        (Balances.Trade memory trade1, Balances.Trade memory trade2) = (\n            Balances.Trade(executionPrice, fillAmount, order1.side),\n            Balances.Trade(executionPrice, fillAmount, order2.side)\n        );\n\n        // Calculate new account state\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = (\n            Balances.applyTrade(account1.position, trade1, feeRate),\n            Balances.applyTrade(account2.position, trade2, feeRate)\n        );\n\n        // return new account state\n        return (newPos1, newPos2);\n    }\n\n    /**\n     * @notice internal function for updating leverage. Called within the Account contract. Also\n     *         updates the total leveraged notional value for the tracer market itself.\n     */\n    function _updateAccountLeverage(address account) internal {\n        Balances.Account memory userBalance = balances[account];\n        uint256 originalLeverage = userBalance.totalLeveragedValue;\n        uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());\n        balances[account].totalLeveragedValue = newLeverage;\n\n        // Update market leveraged notional value\n        _updateTracerLeverage(newLeverage, originalLeverage);\n    }\n\n    /**\n     * @notice Updates the global leverage value given an accounts new leveraged value and old leveraged value\n     * @param accountNewLeveragedNotional The future notional value of the account\n     * @param accountOldLeveragedNotional The stored notional value of the account\n     */\n    function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {\n        leveragedNotionalValue = Prices.globalLeverage(\n            leveragedNotionalValue,\n            accountOldLeveragedNotional,\n            accountNewLeveragedNotional\n        );\n    }\n\n    /**\n     * @notice When a liquidation occurs, Liquidation.sol needs to push this contract to update\n     *         account states as necessary.\n     * @param liquidator Address of the account that called liquidate(...)\n     * @param liquidatee Address of the under-margined account getting liquidated\n     * @param liquidatorQuoteChange Amount the liquidator's quote is changing\n     * @param liquidatorBaseChange Amount the liquidator's base is changing\n     * @param liquidateeQuoteChange Amount the liquidated account's quote is changing\n     * @param liquidateeBaseChange Amount the liquidated account's base is changing\n     * @param amountToEscrow The amount the liquidator has to put into escrow\n     */\n    function updateAccountsOnLiquidation(\n        address liquidator,\n        address liquidatee,\n        int256 liquidatorQuoteChange,\n        int256 liquidatorBaseChange,\n        int256 liquidateeQuoteChange,\n        int256 liquidateeBaseChange,\n        uint256 amountToEscrow\n    ) external override onlyLiquidation {\n        // Limits the gas use when liquidating\n        uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();\n        // Update liquidators last updated gas price\n        Balances.Account storage liquidatorBalance = balances[liquidator];\n        Balances.Account storage liquidateeBalance = balances[liquidatee];\n\n        // update liquidators balance\n        liquidatorBalance.lastUpdatedGasPrice = gasPrice;\n        liquidatorBalance.position.quote =\n            liquidatorBalance.position.quote +\n            liquidatorQuoteChange -\n            amountToEscrow.toInt256();\n        liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;\n\n        // update liquidatee balance\n        liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;\n        liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;\n\n        // Checks if the liquidator is in a valid position to process the liquidation\n        require(userMarginIsValid(liquidator), \"TCR: Liquidator under min margin\");\n    }\n\n    /**\n     * @notice When a liquidation receipt is claimed by the liquidator (i.e. they experienced slippage),\n               Liquidation.sol needs to tell the market to update its balance and the balance of the\n               liquidated agent.\n     * @dev Gives the leftover amount from the receipt to the liquidated agent\n     * @param claimant The liquidator, who has experienced slippage selling the liquidated position\n     * @param amountToGiveToClaimant The amount the liquidator is owe based off slippage\n     * @param liquidatee The account that originally got liquidated\n     * @param amountToGiveToLiquidatee Amount owed to the liquidated account\n     * @param amountToTakeFromInsurance Amount that needs to be taken from the insurance pool\n                                        in order to cover liquidation\n     */\n    function updateAccountsOnClaim(\n        address claimant,\n        int256 amountToGiveToClaimant,\n        address liquidatee,\n        int256 amountToGiveToLiquidatee,\n        int256 amountToTakeFromInsurance\n    ) external override onlyLiquidation {\n        address insuranceAddr = address(insuranceContract);\n        balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;\n        balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;\n        balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;\n        require(balances[insuranceAddr].position.quote >= 0, \"TCR: Insurance not funded enough\");\n    }\n\n    /**\n     * @notice settles an account. Compares current global rate with the users last updated rate\n     *         Updates the accounts margin balance accordingly.\n     * @dev Ensures the account remains in a valid margin position. Will throw if account is under margin\n     *      and the account must then be liquidated.\n     * @param account the address to settle.\n     * @dev This function aggregates data to feed into account.sols settle function which sets\n     */\n    function settle(address account) public override {\n        // Get account and global last updated indexes\n        uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;\n        uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();\n        Balances.Account storage accountBalance = balances[account];\n\n        // if this user has no positions, bring them in sync\n        if (accountBalance.position.base == 0) {\n            // set to the last fully established index\n            accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n        } else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {\n            // Only settle account if its last updated index was before the last established\n            // global index this is since we reference the last global index\n            // Get current and global funding statuses\n            uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;\n            // Note: global rates reference the last fully established rate (hence the -1), and not\n            // the current global rate. User rates reference the last saved user rate\n            Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);\n            Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);\n\n            Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(\n                lastEstablishedIndex\n            );\n\n            Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(\n                accountLastUpdatedIndex\n            );\n\n            // settle the account\n            Balances.Account storage insuranceBalance = balances[address(insuranceContract)];\n\n            accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);\n\n            // Update account gas price\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n\n            if (accountBalance.totalLeveragedValue > 0) {\n                (Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(\n                    accountBalance.position,\n                    insuranceBalance.position,\n                    currInsuranceGlobalRate,\n                    currInsuranceUserRate,\n                    accountBalance.totalLeveragedValue\n                );\n\n                balances[account].position = newUserPos;\n                balances[(address(insuranceContract))].position = newInsurancePos;\n            }\n\n            // Update account index\n            accountBalance.lastUpdatedIndex = lastEstablishedIndex;\n            require(userMarginIsValid(account), \"TCR: Target under-margined\");\n            emit Settled(account, accountBalance.position.quote);\n        }\n    }\n\n    /**\n     * @notice Checks if a given accounts margin is valid\n     * @param account The address of the account whose margin is to be checked\n     * @return true if the margin is valid or false otherwise\n     */\n    function userMarginIsValid(address account) public view returns (bool) {\n        Balances.Account memory accountBalance = balances[account];\n        return\n            Balances.marginIsValid(\n                accountBalance.position,\n                accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            );\n    }\n\n    /**\n     * @notice Withdraws the fees taken on trades, and sends them to the designated\n     *         fee receiver (set by the owner of the market)\n     * @dev Anyone can call this function, but fees are transferred to the fee receiver.\n     *      Fees is also subtracted from the total value locked in the market because\n     *      fees are taken out of trades that result in users' quotes being modified, and\n     *      don't otherwise get subtracted from the tvl of the market\n     */\n    function withdrawFees() external override {\n        uint256 tempFees = fees;\n        fees = 0;\n        tvl = tvl - tempFees;\n\n        // Withdraw from the account\n        IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);\n        emit FeeWithdrawn(feeReceiver, tempFees);\n    }\n\n    function getBalance(address account) external view override returns (Balances.Account memory) {\n        return balances[account];\n    }\n\n    function setLiquidationContract(address _liquidationContract) external override onlyOwner {\n        require(_liquidationContract != address(0), \"address(0) given\");\n        liquidationContract = _liquidationContract;\n    }\n\n    function setInsuranceContract(address insurance) external override onlyOwner {\n        require(insurance != address(0), \"address(0) given\");\n        insuranceContract = IInsurance(insurance);\n    }\n\n    function setPricingContract(address pricing) external override onlyOwner {\n        require(pricing != address(0), \"address(0) given\");\n        pricingContract = IPricing(pricing);\n    }\n\n    function setGasOracle(address _gasOracle) external override onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasPriceOracle = _gasOracle;\n    }\n\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address(0) given\");\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    function setFeeRate(uint256 _feeRate) external override onlyOwner {\n        feeRate = _feeRate;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {\n        maxLeverage = _maxLeverage;\n    }\n\n    function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {\n        fundingRateSensitivity = _fundingRateSensitivity;\n    }\n\n    function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {\n        deleveragingCliff = _deleveragingCliff;\n    }\n\n    function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {\n        lowestMaxLeverage = _lowestMaxLeverage;\n    }\n\n    function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {\n        require(newOwner != address(0), \"address(0) given\");\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice allows the owner of a market to set the whitelisting of a trading interface address\n     * @dev a permissioned interface may call the matchOrders function.\n     * @param tradingContract the contract to have its whitelisting permissions set\n     * @param whitelisted the permission of the contract. If true this contract make call makeOrder\n     */\n    function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {\n        tradingWhitelist[tradingContract] = whitelisted;\n    }\n\n    // Modifier such that only the set liquidation contract can call a function\n    modifier onlyLiquidation() {\n        require(msg.sender == liquidationContract, \"TCR: Sender not liquidation\");\n        _;\n    }\n\n    // Modifier such that only a whitelisted trader can call a function\n    modifier onlyWhitelisted() {\n        require(tradingWhitelist[msg.sender], \"TCR: Contract not whitelisted\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibLiquidation.sol\";\nimport \"./lib/LibBalances.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/ILiquidation.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/IInsurance.sol\";\n\n/**\n * Each call enforces that the contract calling the account is only updating the balance\n * of the account for that contract.\n */\ncontract Liquidation is ILiquidation, Ownable {\n    using LibMath for uint256;\n    using LibMath for int256;\n\n    uint256 public override currentLiquidationId;\n    uint256 public override maxSlippage;\n    uint256 public override releaseTime = 15 minutes;\n    uint256 public override minimumLeftoverGasCostMultiplier = 10;\n    IPricing public pricing;\n    ITracerPerpetualSwaps public tracer;\n    address public insuranceContract;\n    address public fastGasOracle;\n\n    // Receipt ID => LiquidationReceipt\n    mapping(uint256 => LibLiquidation.LiquidationReceipt) public liquidationReceipts;\n\n    event ClaimedReceipts(address indexed liquidator, address indexed market, uint256 indexed receiptId);\n    event ClaimedEscrow(address indexed liquidatee, address indexed market, uint256 indexed id);\n    event Liquidate(\n        address indexed account,\n        address indexed liquidator,\n        int256 liquidationAmount,\n        Perpetuals.Side side,\n        address indexed market,\n        uint256 liquidationId\n    );\n    event InvalidClaimOrder(uint256 indexed receiptId);\n\n    /**\n     * @param _pricing Pricing.sol contract address\n     * @param _tracer TracerPerpetualSwaps.sol contract address\n     * @param _insuranceContract Insurance.sol contract address\n     * @param _fastGasOracle Address of the contract that implements the IOracle.sol interface\n     * @param _maxSlippage The maximum slippage percentage that is allowed on selling a\n                           liquidated position. Given as a decimal WAD. e.g 5% = 0.05*10^18\n     */\n    constructor(\n        address _pricing,\n        address _tracer,\n        address _insuranceContract,\n        address _fastGasOracle,\n        uint256 _maxSlippage\n    ) Ownable() {\n        pricing = IPricing(_pricing);\n        tracer = ITracerPerpetualSwaps(_tracer);\n        insuranceContract = _insuranceContract;\n        fastGasOracle = _fastGasOracle;\n        maxSlippage = _maxSlippage;\n    }\n\n    /**\n     * @notice Creates a liquidation receipt for a given trader\n     * @param liquidator the account executing the liquidation\n     * @param liquidatee the account being liquidated\n     * @param price the price at which this liquidation event occurred\n     * @param escrowedAmount the amount of funds required to be locked into escrow\n     *                       by the liquidator\n     * @param amountLiquidated the amount of positions that were liquidated\n     * @param liquidationSide the side of the positions being liquidated. true for long\n     *                        false for short.\n     */\n    function submitLiquidation(\n        address liquidator,\n        address liquidatee,\n        uint256 price,\n        uint256 escrowedAmount,\n        int256 amountLiquidated,\n        Perpetuals.Side liquidationSide\n    ) internal {\n        liquidationReceipts[currentLiquidationId] = LibLiquidation.LiquidationReceipt({\n            tracer: address(tracer),\n            liquidator: liquidator,\n            liquidatee: liquidatee,\n            price: price,\n            time: block.timestamp,\n            escrowedAmount: escrowedAmount,\n            releaseTime: block.timestamp + releaseTime,\n            amountLiquidated: amountLiquidated,\n            escrowClaimed: false,\n            liquidationSide: liquidationSide,\n            liquidatorRefundClaimed: false\n        });\n        currentLiquidationId += 1;\n    }\n\n    /**\n     * @notice Allows a trader to claim escrowed funds after the escrow period has expired\n     * @param receiptId The ID number of the insurance receipt from which funds are being claimed from\n     */\n    function claimEscrow(uint256 receiptId) public override {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(!receipt.escrowClaimed, \"LIQ: Escrow claimed\");\n        require(block.timestamp > receipt.releaseTime, \"LIQ: Not released\");\n\n        // Mark as claimed\n        liquidationReceipts[receiptId].escrowClaimed = true;\n\n        // Update balance\n        int256 amountToReturn = receipt.escrowedAmount.toInt256();\n        emit ClaimedEscrow(receipt.liquidatee, receipt.tracer, receiptId);\n        tracer.updateAccountsOnClaim(address(0), 0, receipt.liquidatee, amountToReturn, 0);\n    }\n\n    /**\n     * @notice Returns liquidation receipt data for a given receipt id.\n     * @param id the receipt id to get data for\n     */\n    function getLiquidationReceipt(uint256 id)\n        external\n        view\n        override\n        returns (LibLiquidation.LiquidationReceipt memory)\n    {\n        return liquidationReceipts[id];\n    }\n\n    /**\n     * @notice Verify that a Liquidation is valid; submits liquidation receipt if it is\n     * @dev Reverts if the liquidation is invalid\n     * @param base Amount of base in the account to be liquidated (denominated in base tokens)\n     * @param price Fair price of the asset (denominated in quote/base)\n     * @param quote Amount of quote in the account to be liquidated (denominated in quote tokens)\n     * @param amount Amount of tokens to be liquidated\n     * @param gasPrice Current gas price, denominated in gwei\n     * @param account Account to be liquidated\n     * @return Amount to be escrowed for the liquidation\n     */\n    function verifyAndSubmitLiquidation(\n        int256 base,\n        uint256 price,\n        int256 quote,\n        int256 amount,\n        uint256 gasPrice,\n        address account\n    ) internal returns (uint256) {\n        require(amount > 0, \"LIQ: Liquidation amount <= 0\");\n        require(tx.gasprice <= IOracle(fastGasOracle).latestAnswer(), \"LIQ: GasPrice > FGasPrice\");\n\n        Balances.Position memory pos = Balances.Position(quote, base);\n        uint256 gasCost = gasPrice * tracer.LIQUIDATION_GAS_COST();\n\n        int256 currentMargin = Balances.margin(pos, price);\n        require(\n            currentMargin <= 0 ||\n                uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            \"LIQ: Account above margin\"\n        );\n        require(amount <= base.abs(), \"LIQ: Liquidate Amount > Position\");\n\n        // calc funds to liquidate and move to Escrow\n        uint256 amountToEscrow = LibLiquidation.calcEscrowLiquidationAmount(\n            Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            currentMargin,\n            amount,\n            base\n        );\n\n        // create a liquidation receipt\n        Perpetuals.Side side = base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long;\n        submitLiquidation(msg.sender, account, price, amountToEscrow, amount, side);\n        return amountToEscrow;\n    }\n\n    /**\n     * @return true if the margin is greater than 10x liquidation gas cost (in quote tokens)\n     * @param updatedPosition The agent's position after being liquidated\n     * @param lastUpdatedGasPrice The last updated gas price of the account to be liquidated\n     */\n    function checkPartialLiquidation(Balances.Position memory updatedPosition, uint256 lastUpdatedGasPrice)\n        public\n        view\n        returns (bool)\n    {\n        uint256 liquidationGasCost = tracer.LIQUIDATION_GAS_COST();\n        uint256 price = pricing.fairPrice();\n\n        return\n            LibLiquidation.partialLiquidationIsValid(\n                updatedPosition,\n                lastUpdatedGasPrice,\n                liquidationGasCost,\n                price,\n                minimumLeftoverGasCostMultiplier\n            );\n    }\n\n    /**\n     * @notice Liquidates the margin account of a particular user. A deposit is needed from the liquidator.\n     *         Generates a liquidation receipt for the liquidator to use should they need a refund.\n     * @param amount The amount of tokens to be liquidated\n     * @param account The account that is to be liquidated.\n     */\n    function liquidate(int256 amount, address account) external override {\n        /* Liquidated account's balance */\n        Balances.Account memory liquidatedBalance = tracer.getBalance(account);\n\n        uint256 amountToEscrow = verifyAndSubmitLiquidation(\n            liquidatedBalance.position.base,\n            pricing.fairPrice(),\n            liquidatedBalance.position.quote,\n            amount,\n            liquidatedBalance.lastUpdatedGasPrice,\n            account\n        );\n\n        (\n            int256 liquidatorQuoteChange,\n            int256 liquidatorBaseChange,\n            int256 liquidateeQuoteChange,\n            int256 liquidateeBaseChange\n        ) = LibLiquidation.liquidationBalanceChanges(\n            liquidatedBalance.position.base,\n            liquidatedBalance.position.quote,\n            amount\n        );\n\n        Balances.Position memory updatedPosition = Balances.Position(\n            liquidatedBalance.position.quote + liquidateeQuoteChange,\n            liquidatedBalance.position.base + liquidateeBaseChange\n        );\n\n        require(\n            checkPartialLiquidation(updatedPosition, liquidatedBalance.lastUpdatedGasPrice),\n            \"LIQ: leaves too little left over\"\n        );\n\n        tracer.updateAccountsOnLiquidation(\n            msg.sender,\n            account,\n            liquidatorQuoteChange,\n            liquidatorBaseChange,\n            liquidateeQuoteChange,\n            liquidateeBaseChange,\n            amountToEscrow\n        );\n\n        emit Liquidate(\n            account,\n            msg.sender,\n            amount,\n            (liquidatedBalance.position.base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long),\n            address(tracer),\n            currentLiquidationId - 1\n        );\n    }\n\n    /**\n     * @notice Calculates the number of units sold and the average price of those units by a trader\n     *         given multiple order\n     * @param orders a list of orders for which the units sold is being calculated from\n     * @param traderContract The trader contract with which the orders were made\n     * @param receiptId the id of the liquidation receipt the orders are being claimed against\n     */\n    function calcUnitsSold(\n        Perpetuals.Order[] memory orders,\n        address traderContract,\n        uint256 receiptId\n    ) public override returns (uint256, uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        uint256 unitsSold;\n        uint256 avgPrice;\n        for (uint256 i; i < orders.length; i++) {\n            Perpetuals.Order memory order = ITrader(traderContract).getOrder(orders[i]);\n\n            if (\n                order.created < receipt.time || // Order made before receipt\n                order.maker != receipt.liquidator || // Order made by someone who isn't liquidator\n                order.side == receipt.liquidationSide // Order is in same direction as liquidation\n                /* Order should be the opposite to the position acquired on liquidation */\n            ) {\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            if (\n                (receipt.liquidationSide == Perpetuals.Side.Long && order.price >= receipt.price) ||\n                (receipt.liquidationSide == Perpetuals.Side.Short && order.price <= receipt.price)\n            ) {\n                // Liquidation position was long\n                // Price went up, so not a slippage order\n                // or\n                // Liquidation position was short\n                // Price went down, so not a slippage order\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            uint256 orderFilled = ITrader(traderContract).filledAmount(order);\n            uint256 averageExecutionPrice = ITrader(traderContract).getAverageExecutionPrice(order);\n\n            /* order.created >= receipt.time\n             * && order.maker == receipt.liquidator\n             * && order.side != receipt.liquidationSide */\n            unitsSold = unitsSold + orderFilled;\n            avgPrice = avgPrice + (averageExecutionPrice * orderFilled);\n        }\n\n        // Avoid divide by 0 if no orders sold\n        if (unitsSold == 0) {\n            return (0, 0);\n        }\n        return (unitsSold, avgPrice / unitsSold);\n    }\n\n    /**\n     * @notice Marks receipts as claimed and returns the refund amount\n     * @param escrowId the id of the receipt created during the liquidation event\n     * @param orders the orders that sell the liquidated positions\n     * @param traderContract the address of the trader contract the selling orders were made by\n     */\n    function calcAmountToReturn(\n        uint256 escrowId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) public override returns (uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[escrowId];\n        // Validate the escrowed order was fully sold\n        (uint256 unitsSold, uint256 avgPrice) = calcUnitsSold(orders, traderContract, escrowId);\n        require(unitsSold <= uint256(receipt.amountLiquidated.abs()), \"LIQ: Unit mismatch\");\n\n        uint256 amountToReturn = LibLiquidation.calculateSlippage(unitsSold, maxSlippage, avgPrice, receipt);\n        return amountToReturn;\n    }\n\n    /**\n     * @notice Drains a certain amount from insurance pool to cover excess slippage not covered by escrow\n     * @param amountWantedFromInsurance How much we want to drain\n     * @param receipt The liquidation receipt for which we are calling on the insurance pool to cover\n     */\n    function drainInsurancePoolOnLiquidation(\n        uint256 amountWantedFromInsurance,\n        LibLiquidation.LiquidationReceipt memory receipt\n    ) internal returns (uint256 _amountTakenFromInsurance, uint256 _amountToGiveToClaimant) {\n        /*\n         * If there was not enough escrowed, we want to call the insurance pool to help out.\n         * First, check the margin of the insurance Account. If this is enough, just drain from there.\n         * If this is not enough, call Insurance.drainPool to get some tokens from the insurance pool.\n         * If drainPool is able to drain enough, drain from the new margin.\n         * If the margin still does not have enough after calling drainPool, we are not able to fully\n         * claim the receipt, only up to the amount the insurance pool allows for.\n         */\n\n        Balances.Account memory insuranceBalance = tracer.getBalance(insuranceContract);\n        if (insuranceBalance.position.quote >= amountWantedFromInsurance.toInt256()) {\n            // We don't need to drain insurance contract. The balance is already in the market contract\n            _amountTakenFromInsurance = amountWantedFromInsurance;\n        } else {\n            // insuranceBalance.quote < amountWantedFromInsurance\n            if (insuranceBalance.position.quote <= 0) {\n                // attempt to drain entire balance that is needed from the pool\n                IInsurance(insuranceContract).drainPool(amountWantedFromInsurance);\n            } else {\n                // attempt to drain the required balance taking into account the insurance balance in the account contract\n                IInsurance(insuranceContract).drainPool(\n                    amountWantedFromInsurance - uint256(insuranceBalance.position.quote)\n                );\n            }\n            Balances.Account memory updatedInsuranceBalance = tracer.getBalance(insuranceContract);\n            if (updatedInsuranceBalance.position.quote < amountWantedFromInsurance.toInt256()) {\n                // Still not enough\n                _amountTakenFromInsurance = uint256(updatedInsuranceBalance.position.quote);\n            } else {\n                _amountTakenFromInsurance = amountWantedFromInsurance;\n            }\n        }\n\n        _amountToGiveToClaimant = receipt.escrowedAmount + _amountTakenFromInsurance;\n        // Don't add any to liquidatee\n    }\n\n    /**\n     * @notice Allows a liquidator to submit a single liquidation receipt and multiple order ids. If the\n     *         liquidator experienced slippage, will refund them a proportional amount of their deposit.\n     * @param receiptId Used to identify the receipt that will be claimed\n     * @param orders The orders that sold the liquidated position\n     */\n    function claimReceipt(\n        uint256 receiptId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) external override {\n        // Claim the receipts from the escrow system, get back amount to return\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(receipt.liquidator == msg.sender, \"LIQ: Liquidator mismatch\");\n        // Mark refund as claimed\n        require(!receipt.liquidatorRefundClaimed, \"LIQ: Already claimed\");\n        liquidationReceipts[receiptId].liquidatorRefundClaimed = true;\n        liquidationReceipts[receiptId].escrowClaimed = true;\n        require(block.timestamp < receipt.releaseTime, \"LIQ: claim time passed\");\n        require(tracer.tradingWhitelist(traderContract), \"LIQ: Trader is not whitelisted\");\n\n        uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            liquidationReceipts[receiptId].escrowedAmount = 0;\n        } else {\n            liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;\n        }\n\n        // Keep track of how much was actually taken out of insurance\n        uint256 amountTakenFromInsurance;\n        uint256 amountToGiveToClaimant;\n        uint256 amountToGiveToLiquidatee;\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            // Need to cover some loses with the insurance contract\n            // Whatever is the remainder that can't be covered from escrow\n            uint256 amountWantedFromInsurance = amountToReturn - receipt.escrowedAmount;\n            (amountTakenFromInsurance, amountToGiveToClaimant) = drainInsurancePoolOnLiquidation(\n                amountWantedFromInsurance,\n                receipt\n            );\n        } else {\n            amountToGiveToClaimant = amountToReturn;\n            amountToGiveToLiquidatee = receipt.escrowedAmount - amountToReturn;\n        }\n\n        tracer.updateAccountsOnClaim(\n            receipt.liquidator,\n            amountToGiveToClaimant.toInt256(),\n            receipt.liquidatee,\n            amountToGiveToLiquidatee.toInt256(),\n            amountTakenFromInsurance.toInt256()\n        );\n        emit ClaimedReceipts(msg.sender, address(tracer), receiptId);\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ILiquidation) onlyOwner {\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Modifies the release time\n     * @param _releaseTime new release time\n     */\n    function setReleaseTime(uint256 _releaseTime) external onlyOwner() {\n        releaseTime = _releaseTime;\n    }\n\n    /**\n     * @notice Modifies the value to multiply the liquidation cost by in determining\n     *         the minimum leftover margin on partial liquidation\n     * @param _minimumLeftoverGasCostMultiplier The new multiplier\n     */\n    function setMinimumLeftoverGasCostMultiplier(uint256 _minimumLeftoverGasCostMultiplier) external onlyOwner() {\n        minimumLeftoverGasCostMultiplier = _minimumLeftoverGasCostMultiplier;\n    }\n\n    /**\n     * @notice Modifies the max slippage\n     * @param _maxSlippage new max slippage\n     */\n    function setMaxSlippage(uint256 _maxSlippage) public override onlyOwner() {\n        maxSlippage = _maxSlippage;\n    }\n}\n\n\n",
        "CodeNames": [
            "Insurance.sol",
            "TracerPerpetualSwaps.sol",
            "Liquidation.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "//solidity\nif (accountBalance.position.base == 0) {\n    // set to the last fully established index\n    // @audit shouldn't this be global 1 like below?\n    accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n    accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n}\n"
                ],
                "Type": " Wrong funding index in settle when no base?",
                "Description": "\nThe TracerPerpetualSwaps.settle function updates the user's last index to currentGlobalFundingIndex, however a comment states:\n\n \"// Note: global rates reference the last fully established rate (hence the -1), and not the current global rate. User rates reference the last saved user rate\"\n\nThe code for the else branch also updates the last index to currentGlobalFundingIndex 1 instead of currentGlobalFundingIndex.\n\nsolidity\nif (accountBalance.position.base == 0) {\n    // set to the last fully established index\n    // @audit shouldn't this be global 1 like below?\n    accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n    accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n}\n\n\nThe impact is that it might be possible for first-time depositors to skip having to pay the first funding rate period as the accountLastUpdatedIndex + 1 < currentGlobalFundingIndex check will still return false when the funding rates are updated the next time.\n\n",
                "Repair": "Recommend to check if setting it to currentGlobalFundingIndex or to currentGlobalFundingIndex 1 is correct.\n\nraymogg (Tracer) confirmed but disagreed with severity(https://github.com/code-423n4/2021-06-tracer-findings/issues/106)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/SafetyWithdraw.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport {Types} from \"./Interfaces/Types.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant override LIQUIDATION_GAS_COST = 63516;\n    address public immutable override tracerQuoteToken;\n    uint256 public immutable override quoteTokenDecimals;\n    bytes32 public immutable override marketId;\n    IPricing public pricingContract;\n    IInsurance public insuranceContract;\n    address public override liquidationContract;\n    uint256 public override feeRate;\n    uint256 public override fees;\n    address public override feeReceiver;\n\n    /* Config variables */\n    // The price of gas in gwei\n    address public override gasPriceOracle;\n    // The maximum ratio of notionalValue to margin\n    uint256 public override maxLeverage;\n    // WAD value. sensitivity of 1 = 1*10^18\n    uint256 public override fundingRateSensitivity;\n    // WAD value. The percentage for insurance pool holdings/pool target where deleveraging begins\n    uint256 public override deleveragingCliff;\n    /* The percentage of insurance holdings to target at which the insurance pool\n       funding rate changes, and lowestMaxLeverage is reached */\n    uint256 public override insurancePoolSwitchStage;\n    // The lowest value that maxLeverage can be, if insurance pool is empty.\n    uint256 public override lowestMaxLeverage;\n\n    // Account State Variables\n    mapping(address => Balances.Account) public balances;\n    uint256 public tvl;\n    uint256 public override leveragedNotionalValue;\n\n    // Trading interfaces whitelist\n    mapping(address => bool) public override tradingWhitelist;\n\n    event FeeReceiverUpdated(address indexed receiver);\n    event FeeWithdrawn(address indexed receiver, uint256 feeAmount);\n    event Deposit(address indexed user, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed amount);\n    event Settled(address indexed account, int256 margin);\n    event MatchedOrders(\n        address indexed long,\n        address indexed short,\n        uint256 amount,\n        uint256 price,\n        bytes32 longOrderId,\n        bytes32 shortOrderId\n    );\n    event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);\n\n    /**\n     * @notice Creates a new tracer market and sets the initial funding rate of the market. Anyone\n     *         will be able to purchase and trade tracers after this deployment.\n     * @param _marketId the id of the market, given as BASE/QUOTE\n     * @param _tracerQuoteToken the address of the token used for margin accounts (i.e. The margin token)\n     * @param _tokenDecimals the number of decimal places the quote token supports\n     * @param _gasPriceOracle the address of the contract implementing gas price oracle\n     * @param _maxLeverage the max leverage of the market represented as a WAD value.\n     * @param _fundingRateSensitivity the affect funding rate changes have on funding paid; u60.18-decimal fixed-point number (WAD value)\n     * @param _feeRate the fee taken on trades; WAD value. e.g. 2% fee = 0.02 * 10^18 = 2 * 10^16\n     * @param _feeReceiver the address of the person who can withdraw the fees from trades in this market\n     * @param _deleveragingCliff The percentage for insurance pool holdings/pool target where deleveraging begins.\n     *                           WAD value. e.g. 20% = 20*10^18\n     * @param _lowestMaxLeverage The lowest value that maxLeverage can be, if insurance pool is empty.\n     * @param _insurancePoolSwitchStage The percentage of insurance holdings to target at which the insurance pool\n     *                                  funding rate changes, and lowestMaxLeverage is reached\n     */\n    constructor(\n        bytes32 _marketId,\n        address _tracerQuoteToken,\n        uint256 _tokenDecimals,\n        address _gasPriceOracle,\n        uint256 _maxLeverage,\n        uint256 _fundingRateSensitivity,\n        uint256 _feeRate,\n        address _feeReceiver,\n        uint256 _deleveragingCliff,\n        uint256 _lowestMaxLeverage,\n        uint256 _insurancePoolSwitchStage\n    ) Ownable() {\n        // don't convert to interface as we don't need to interact with the contract\n        tracerQuoteToken = _tracerQuoteToken;\n        quoteTokenDecimals = _tokenDecimals;\n        gasPriceOracle = _gasPriceOracle;\n        marketId = _marketId;\n        feeRate = _feeRate;\n        maxLeverage = _maxLeverage;\n        fundingRateSensitivity = _fundingRateSensitivity;\n        feeReceiver = _feeReceiver;\n        deleveragingCliff = _deleveragingCliff;\n        lowestMaxLeverage = _lowestMaxLeverage;\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    /**\n     * @notice Adjust the max leverage as insurance pool slides from 100% of target to 0% of target\n     */\n    function trueMaxLeverage() public view override returns (uint256) {\n        IInsurance insurance = IInsurance(insuranceContract);\n\n        return\n            Perpetuals.calculateTrueMaxLeverage(\n                insurance.getPoolHoldings(),\n                insurance.getPoolTarget(),\n                maxLeverage,\n                lowestMaxLeverage,\n                deleveragingCliff,\n                insurancePoolSwitchStage\n            );\n    }\n\n    /**\n     * @notice Allows a user to deposit into their margin account\n     * @dev this contract must be an approved spender of the markets quote token on behalf of the depositer.\n     * @param amount The amount of quote tokens to be deposited into the Tracer Market account. This amount\n     * should be given in WAD format.\n     */\n    function deposit(uint256 amount) external override {\n        Balances.Account storage userBalance = balances[msg.sender];\n        // settle outstanding payments\n        settle(msg.sender);\n\n        // convert the WAD amount to the correct token amount to transfer\n        // cast is safe since amount is a uint, and wadToToken can only\n        // scale down the value\n        uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());\n        IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // this prevents dust from being added to the user account\n        // eg 10^18 -> 10^8 -> 10^18 will remove lower order bits\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        // update user state\n        userBalance.position.quote = userBalance.position.quote + convertedWadAmount;\n        _updateAccountLeverage(msg.sender);\n\n        // update market TVL\n        tvl = tvl + uint256(convertedWadAmount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw from their margin account\n     * @dev Ensures that the users margin percent is valid after withdraw\n     * @param amount The amount of margin tokens to be withdrawn from the tracer market account. This amount\n     * should be given in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        // settle outstanding payments\n        settle(msg.sender);\n\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        Balances.Account storage userBalance = balances[msg.sender];\n        int256 newQuote = userBalance.position.quote - convertedWadAmount;\n\n        // this may be able to be optimised\n        Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);\n\n        require(\n            Balances.marginIsValid(\n                newPosition,\n                userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ),\n            \"TCR: Withdraw below valid Margin\"\n        );\n\n        // update user state\n        userBalance.position.quote = newQuote;\n        _updateAccountLeverage(msg.sender);\n\n        // Safemath will throw if tvl < amount\n        tvl = tvl - amount;\n\n        // perform transfer\n        IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);\n        emit Withdraw(msg.sender, uint256(convertedWadAmount));\n    }\n\n    /**\n     * @notice Attempt to match two orders that exist on-chain against each other\n     * @dev Emits a FailedOrders or MatchedOrders event based on whether the\n     *      orders were successfully able to be matched\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount Amount that the two orders are being filled for\n     * @return Whether the two orders were able to be matched successfully\n     */\n    function matchOrders(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount\n    ) external override onlyWhitelisted returns (bool) {\n        bytes32 order1Id = Perpetuals.orderId(order1);\n        bytes32 order2Id = Perpetuals.orderId(order2);\n        uint256 filled1 = ITrader(msg.sender).filled(order1Id);\n        uint256 filled2 = ITrader(msg.sender).filled(order2Id);\n\n        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);\n\n        // settle accounts\n        // note: this can revert and hence no order events will be emitted\n        settle(order1.maker);\n        settle(order2.maker);\n\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(\n            order1,\n            order2,\n            fillAmount,\n            executionPrice\n        );\n        // validate orders can match, and outcome state is valid\n        if (\n            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||\n            !Balances.marginIsValid(\n                newPos1,\n                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ) ||\n            !Balances.marginIsValid(\n                newPos2,\n                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            )\n        ) {\n            // emit failed to match event and return false\n            if (order1.side == Perpetuals.Side.Long) {\n                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);\n            } else {\n                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);\n            }\n            return false;\n        }\n\n        // update account states\n        balances[order1.maker].position = newPos1;\n        balances[order2.maker].position = newPos2;\n\n        // update fees\n        fees =\n            fees +\n            // add 2 * fees since getFeeRate returns the fee rate for a single\n            // side of the order. Both users were charged fees\n            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);\n\n        // update leverage\n        _updateAccountLeverage(order1.maker);\n        _updateAccountLeverage(order2.maker);\n\n        // Update internal trade state\n        pricingContract.recordTrade(executionPrice);\n\n        if (order1.side == Perpetuals.Side.Long) {\n            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);\n        } else {\n            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Updates account states of two accounts given two orders that are being executed\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount The amount that the two ordered are being filled for\n     * @param executionPrice The execution price of the trades\n     * @return The new balances of the two accounts after the trade\n     */\n    function _executeTrade(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount,\n        uint256 executionPrice\n    ) internal view returns (Balances.Position memory, Balances.Position memory) {\n        // Retrieve account state\n        Balances.Account memory account1 = balances[order1.maker];\n        Balances.Account memory account2 = balances[order2.maker];\n\n        // Construct `Trade` types suitable for use with LibBalances\n        (Balances.Trade memory trade1, Balances.Trade memory trade2) = (\n            Balances.Trade(executionPrice, fillAmount, order1.side),\n            Balances.Trade(executionPrice, fillAmount, order2.side)\n        );\n\n        // Calculate new account state\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = (\n            Balances.applyTrade(account1.position, trade1, feeRate),\n            Balances.applyTrade(account2.position, trade2, feeRate)\n        );\n\n        // return new account state\n        return (newPos1, newPos2);\n    }\n\n    /**\n     * @notice internal function for updating leverage. Called within the Account contract. Also\n     *         updates the total leveraged notional value for the tracer market itself.\n     */\n    function _updateAccountLeverage(address account) internal {\n        Balances.Account memory userBalance = balances[account];\n        uint256 originalLeverage = userBalance.totalLeveragedValue;\n        uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());\n        balances[account].totalLeveragedValue = newLeverage;\n\n        // Update market leveraged notional value\n        _updateTracerLeverage(newLeverage, originalLeverage);\n    }\n\n    /**\n     * @notice Updates the global leverage value given an accounts new leveraged value and old leveraged value\n     * @param accountNewLeveragedNotional The future notional value of the account\n     * @param accountOldLeveragedNotional The stored notional value of the account\n     */\n    function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {\n        leveragedNotionalValue = Prices.globalLeverage(\n            leveragedNotionalValue,\n            accountOldLeveragedNotional,\n            accountNewLeveragedNotional\n        );\n    }\n\n    /**\n     * @notice When a liquidation occurs, Liquidation.sol needs to push this contract to update\n     *         account states as necessary.\n     * @param liquidator Address of the account that called liquidate(...)\n     * @param liquidatee Address of the under-margined account getting liquidated\n     * @param liquidatorQuoteChange Amount the liquidator's quote is changing\n     * @param liquidatorBaseChange Amount the liquidator's base is changing\n     * @param liquidateeQuoteChange Amount the liquidated account's quote is changing\n     * @param liquidateeBaseChange Amount the liquidated account's base is changing\n     * @param amountToEscrow The amount the liquidator has to put into escrow\n     */\n    function updateAccountsOnLiquidation(\n        address liquidator,\n        address liquidatee,\n        int256 liquidatorQuoteChange,\n        int256 liquidatorBaseChange,\n        int256 liquidateeQuoteChange,\n        int256 liquidateeBaseChange,\n        uint256 amountToEscrow\n    ) external override onlyLiquidation {\n        // Limits the gas use when liquidating\n        uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();\n        // Update liquidators last updated gas price\n        Balances.Account storage liquidatorBalance = balances[liquidator];\n        Balances.Account storage liquidateeBalance = balances[liquidatee];\n\n        // update liquidators balance\n        liquidatorBalance.lastUpdatedGasPrice = gasPrice;\n        liquidatorBalance.position.quote =\n            liquidatorBalance.position.quote +\n            liquidatorQuoteChange -\n            amountToEscrow.toInt256();\n        liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;\n\n        // update liquidatee balance\n        liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;\n        liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;\n\n        // Checks if the liquidator is in a valid position to process the liquidation\n        require(userMarginIsValid(liquidator), \"TCR: Liquidator under min margin\");\n    }\n\n    /**\n     * @notice When a liquidation receipt is claimed by the liquidator (i.e. they experienced slippage),\n               Liquidation.sol needs to tell the market to update its balance and the balance of the\n               liquidated agent.\n     * @dev Gives the leftover amount from the receipt to the liquidated agent\n     * @param claimant The liquidator, who has experienced slippage selling the liquidated position\n     * @param amountToGiveToClaimant The amount the liquidator is owe based off slippage\n     * @param liquidatee The account that originally got liquidated\n     * @param amountToGiveToLiquidatee Amount owed to the liquidated account\n     * @param amountToTakeFromInsurance Amount that needs to be taken from the insurance pool\n                                        in order to cover liquidation\n     */\n    function updateAccountsOnClaim(\n        address claimant,\n        int256 amountToGiveToClaimant,\n        address liquidatee,\n        int256 amountToGiveToLiquidatee,\n        int256 amountToTakeFromInsurance\n    ) external override onlyLiquidation {\n        address insuranceAddr = address(insuranceContract);\n        balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;\n        balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;\n        balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;\n        require(balances[insuranceAddr].position.quote >= 0, \"TCR: Insurance not funded enough\");\n    }\n\n    /**\n     * @notice settles an account. Compares current global rate with the users last updated rate\n     *         Updates the accounts margin balance accordingly.\n     * @dev Ensures the account remains in a valid margin position. Will throw if account is under margin\n     *      and the account must then be liquidated.\n     * @param account the address to settle.\n     * @dev This function aggregates data to feed into account.sols settle function which sets\n     */\n    function settle(address account) public override {\n        // Get account and global last updated indexes\n        uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;\n        uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();\n        Balances.Account storage accountBalance = balances[account];\n\n        // if this user has no positions, bring them in sync\n        if (accountBalance.position.base == 0) {\n            // set to the last fully established index\n            accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n        } else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {\n            // Only settle account if its last updated index was before the last established\n            // global index this is since we reference the last global index\n            // Get current and global funding statuses\n            uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;\n            // Note: global rates reference the last fully established rate (hence the -1), and not\n            // the current global rate. User rates reference the last saved user rate\n            Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);\n            Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);\n\n            Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(\n                lastEstablishedIndex\n            );\n\n            Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(\n                accountLastUpdatedIndex\n            );\n\n            // settle the account\n            Balances.Account storage insuranceBalance = balances[address(insuranceContract)];\n\n            accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);\n\n            // Update account gas price\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n\n            if (accountBalance.totalLeveragedValue > 0) {\n                (Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(\n                    accountBalance.position,\n                    insuranceBalance.position,\n                    currInsuranceGlobalRate,\n                    currInsuranceUserRate,\n                    accountBalance.totalLeveragedValue\n                );\n\n                balances[account].position = newUserPos;\n                balances[(address(insuranceContract))].position = newInsurancePos;\n            }\n\n            // Update account index\n            accountBalance.lastUpdatedIndex = lastEstablishedIndex;\n            require(userMarginIsValid(account), \"TCR: Target under-margined\");\n            emit Settled(account, accountBalance.position.quote);\n        }\n    }\n\n    /**\n     * @notice Checks if a given accounts margin is valid\n     * @param account The address of the account whose margin is to be checked\n     * @return true if the margin is valid or false otherwise\n     */\n    function userMarginIsValid(address account) public view returns (bool) {\n        Balances.Account memory accountBalance = balances[account];\n        return\n            Balances.marginIsValid(\n                accountBalance.position,\n                accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            );\n    }\n\n    /**\n     * @notice Withdraws the fees taken on trades, and sends them to the designated\n     *         fee receiver (set by the owner of the market)\n     * @dev Anyone can call this function, but fees are transferred to the fee receiver.\n     *      Fees is also subtracted from the total value locked in the market because\n     *      fees are taken out of trades that result in users' quotes being modified, and\n     *      don't otherwise get subtracted from the tvl of the market\n     */\n    function withdrawFees() external override {\n        uint256 tempFees = fees;\n        fees = 0;\n        tvl = tvl - tempFees;\n\n        // Withdraw from the account\n        IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);\n        emit FeeWithdrawn(feeReceiver, tempFees);\n    }\n\n    function getBalance(address account) external view override returns (Balances.Account memory) {\n        return balances[account];\n    }\n\n    function setLiquidationContract(address _liquidationContract) external override onlyOwner {\n        require(_liquidationContract != address(0), \"address(0) given\");\n        liquidationContract = _liquidationContract;\n    }\n\n    function setInsuranceContract(address insurance) external override onlyOwner {\n        require(insurance != address(0), \"address(0) given\");\n        insuranceContract = IInsurance(insurance);\n    }\n\n    function setPricingContract(address pricing) external override onlyOwner {\n        require(pricing != address(0), \"address(0) given\");\n        pricingContract = IPricing(pricing);\n    }\n\n    function setGasOracle(address _gasOracle) external override onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasPriceOracle = _gasOracle;\n    }\n\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address(0) given\");\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    function setFeeRate(uint256 _feeRate) external override onlyOwner {\n        feeRate = _feeRate;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {\n        maxLeverage = _maxLeverage;\n    }\n\n    function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {\n        fundingRateSensitivity = _fundingRateSensitivity;\n    }\n\n    function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {\n        deleveragingCliff = _deleveragingCliff;\n    }\n\n    function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {\n        lowestMaxLeverage = _lowestMaxLeverage;\n    }\n\n    function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {\n        require(newOwner != address(0), \"address(0) given\");\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice allows the owner of a market to set the whitelisting of a trading interface address\n     * @dev a permissioned interface may call the matchOrders function.\n     * @param tradingContract the contract to have its whitelisting permissions set\n     * @param whitelisted the permission of the contract. If true this contract make call makeOrder\n     */\n    function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {\n        tradingWhitelist[tradingContract] = whitelisted;\n    }\n\n    // Modifier such that only the set liquidation contract can call a function\n    modifier onlyLiquidation() {\n        require(msg.sender == liquidationContract, \"TCR: Sender not liquidation\");\n        _;\n    }\n\n    // Modifier such that only a whitelisted trader can call a function\n    modifier onlyWhitelisted() {\n        require(tradingWhitelist[msg.sender], \"TCR: Contract not whitelisted\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibLiquidation.sol\";\nimport \"./lib/LibBalances.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/ILiquidation.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/IInsurance.sol\";\n\n/**\n * Each call enforces that the contract calling the account is only updating the balance\n * of the account for that contract.\n */\ncontract Liquidation is ILiquidation, Ownable {\n    using LibMath for uint256;\n    using LibMath for int256;\n\n    uint256 public override currentLiquidationId;\n    uint256 public override maxSlippage;\n    uint256 public override releaseTime = 15 minutes;\n    uint256 public override minimumLeftoverGasCostMultiplier = 10;\n    IPricing public pricing;\n    ITracerPerpetualSwaps public tracer;\n    address public insuranceContract;\n    address public fastGasOracle;\n\n    // Receipt ID => LiquidationReceipt\n    mapping(uint256 => LibLiquidation.LiquidationReceipt) public liquidationReceipts;\n\n    event ClaimedReceipts(address indexed liquidator, address indexed market, uint256 indexed receiptId);\n    event ClaimedEscrow(address indexed liquidatee, address indexed market, uint256 indexed id);\n    event Liquidate(\n        address indexed account,\n        address indexed liquidator,\n        int256 liquidationAmount,\n        Perpetuals.Side side,\n        address indexed market,\n        uint256 liquidationId\n    );\n    event InvalidClaimOrder(uint256 indexed receiptId);\n\n    /**\n     * @param _pricing Pricing.sol contract address\n     * @param _tracer TracerPerpetualSwaps.sol contract address\n     * @param _insuranceContract Insurance.sol contract address\n     * @param _fastGasOracle Address of the contract that implements the IOracle.sol interface\n     * @param _maxSlippage The maximum slippage percentage that is allowed on selling a\n                           liquidated position. Given as a decimal WAD. e.g 5% = 0.05*10^18\n     */\n    constructor(\n        address _pricing,\n        address _tracer,\n        address _insuranceContract,\n        address _fastGasOracle,\n        uint256 _maxSlippage\n    ) Ownable() {\n        pricing = IPricing(_pricing);\n        tracer = ITracerPerpetualSwaps(_tracer);\n        insuranceContract = _insuranceContract;\n        fastGasOracle = _fastGasOracle;\n        maxSlippage = _maxSlippage;\n    }\n\n    /**\n     * @notice Creates a liquidation receipt for a given trader\n     * @param liquidator the account executing the liquidation\n     * @param liquidatee the account being liquidated\n     * @param price the price at which this liquidation event occurred\n     * @param escrowedAmount the amount of funds required to be locked into escrow\n     *                       by the liquidator\n     * @param amountLiquidated the amount of positions that were liquidated\n     * @param liquidationSide the side of the positions being liquidated. true for long\n     *                        false for short.\n     */\n    function submitLiquidation(\n        address liquidator,\n        address liquidatee,\n        uint256 price,\n        uint256 escrowedAmount,\n        int256 amountLiquidated,\n        Perpetuals.Side liquidationSide\n    ) internal {\n        liquidationReceipts[currentLiquidationId] = LibLiquidation.LiquidationReceipt({\n            tracer: address(tracer),\n            liquidator: liquidator,\n            liquidatee: liquidatee,\n            price: price,\n            time: block.timestamp,\n            escrowedAmount: escrowedAmount,\n            releaseTime: block.timestamp + releaseTime,\n            amountLiquidated: amountLiquidated,\n            escrowClaimed: false,\n            liquidationSide: liquidationSide,\n            liquidatorRefundClaimed: false\n        });\n        currentLiquidationId += 1;\n    }\n\n    /**\n     * @notice Allows a trader to claim escrowed funds after the escrow period has expired\n     * @param receiptId The ID number of the insurance receipt from which funds are being claimed from\n     */\n    function claimEscrow(uint256 receiptId) public override {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(!receipt.escrowClaimed, \"LIQ: Escrow claimed\");\n        require(block.timestamp > receipt.releaseTime, \"LIQ: Not released\");\n\n        // Mark as claimed\n        liquidationReceipts[receiptId].escrowClaimed = true;\n\n        // Update balance\n        int256 amountToReturn = receipt.escrowedAmount.toInt256();\n        emit ClaimedEscrow(receipt.liquidatee, receipt.tracer, receiptId);\n        tracer.updateAccountsOnClaim(address(0), 0, receipt.liquidatee, amountToReturn, 0);\n    }\n\n    /**\n     * @notice Returns liquidation receipt data for a given receipt id.\n     * @param id the receipt id to get data for\n     */\n    function getLiquidationReceipt(uint256 id)\n        external\n        view\n        override\n        returns (LibLiquidation.LiquidationReceipt memory)\n    {\n        return liquidationReceipts[id];\n    }\n\n    /**\n     * @notice Verify that a Liquidation is valid; submits liquidation receipt if it is\n     * @dev Reverts if the liquidation is invalid\n     * @param base Amount of base in the account to be liquidated (denominated in base tokens)\n     * @param price Fair price of the asset (denominated in quote/base)\n     * @param quote Amount of quote in the account to be liquidated (denominated in quote tokens)\n     * @param amount Amount of tokens to be liquidated\n     * @param gasPrice Current gas price, denominated in gwei\n     * @param account Account to be liquidated\n     * @return Amount to be escrowed for the liquidation\n     */\n    function verifyAndSubmitLiquidation(\n        int256 base,\n        uint256 price,\n        int256 quote,\n        int256 amount,\n        uint256 gasPrice,\n        address account\n    ) internal returns (uint256) {\n        require(amount > 0, \"LIQ: Liquidation amount <= 0\");\n        require(tx.gasprice <= IOracle(fastGasOracle).latestAnswer(), \"LIQ: GasPrice > FGasPrice\");\n\n        Balances.Position memory pos = Balances.Position(quote, base);\n        uint256 gasCost = gasPrice * tracer.LIQUIDATION_GAS_COST();\n\n        int256 currentMargin = Balances.margin(pos, price);\n        require(\n            currentMargin <= 0 ||\n                uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            \"LIQ: Account above margin\"\n        );\n        require(amount <= base.abs(), \"LIQ: Liquidate Amount > Position\");\n\n        // calc funds to liquidate and move to Escrow\n        uint256 amountToEscrow = LibLiquidation.calcEscrowLiquidationAmount(\n            Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            currentMargin,\n            amount,\n            base\n        );\n\n        // create a liquidation receipt\n        Perpetuals.Side side = base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long;\n        submitLiquidation(msg.sender, account, price, amountToEscrow, amount, side);\n        return amountToEscrow;\n    }\n\n    /**\n     * @return true if the margin is greater than 10x liquidation gas cost (in quote tokens)\n     * @param updatedPosition The agent's position after being liquidated\n     * @param lastUpdatedGasPrice The last updated gas price of the account to be liquidated\n     */\n    function checkPartialLiquidation(Balances.Position memory updatedPosition, uint256 lastUpdatedGasPrice)\n        public\n        view\n        returns (bool)\n    {\n        uint256 liquidationGasCost = tracer.LIQUIDATION_GAS_COST();\n        uint256 price = pricing.fairPrice();\n\n        return\n            LibLiquidation.partialLiquidationIsValid(\n                updatedPosition,\n                lastUpdatedGasPrice,\n                liquidationGasCost,\n                price,\n                minimumLeftoverGasCostMultiplier\n            );\n    }\n\n    /**\n     * @notice Liquidates the margin account of a particular user. A deposit is needed from the liquidator.\n     *         Generates a liquidation receipt for the liquidator to use should they need a refund.\n     * @param amount The amount of tokens to be liquidated\n     * @param account The account that is to be liquidated.\n     */\n    function liquidate(int256 amount, address account) external override {\n        /* Liquidated account's balance */\n        Balances.Account memory liquidatedBalance = tracer.getBalance(account);\n\n        uint256 amountToEscrow = verifyAndSubmitLiquidation(\n            liquidatedBalance.position.base,\n            pricing.fairPrice(),\n            liquidatedBalance.position.quote,\n            amount,\n            liquidatedBalance.lastUpdatedGasPrice,\n            account\n        );\n\n        (\n            int256 liquidatorQuoteChange,\n            int256 liquidatorBaseChange,\n            int256 liquidateeQuoteChange,\n            int256 liquidateeBaseChange\n        ) = LibLiquidation.liquidationBalanceChanges(\n            liquidatedBalance.position.base,\n            liquidatedBalance.position.quote,\n            amount\n        );\n\n        Balances.Position memory updatedPosition = Balances.Position(\n            liquidatedBalance.position.quote + liquidateeQuoteChange,\n            liquidatedBalance.position.base + liquidateeBaseChange\n        );\n\n        require(\n            checkPartialLiquidation(updatedPosition, liquidatedBalance.lastUpdatedGasPrice),\n            \"LIQ: leaves too little left over\"\n        );\n\n        tracer.updateAccountsOnLiquidation(\n            msg.sender,\n            account,\n            liquidatorQuoteChange,\n            liquidatorBaseChange,\n            liquidateeQuoteChange,\n            liquidateeBaseChange,\n            amountToEscrow\n        );\n\n        emit Liquidate(\n            account,\n            msg.sender,\n            amount,\n            (liquidatedBalance.position.base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long),\n            address(tracer),\n            currentLiquidationId - 1\n        );\n    }\n\n    /**\n     * @notice Calculates the number of units sold and the average price of those units by a trader\n     *         given multiple order\n     * @param orders a list of orders for which the units sold is being calculated from\n     * @param traderContract The trader contract with which the orders were made\n     * @param receiptId the id of the liquidation receipt the orders are being claimed against\n     */\n    function calcUnitsSold(\n        Perpetuals.Order[] memory orders,\n        address traderContract,\n        uint256 receiptId\n    ) public override returns (uint256, uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        uint256 unitsSold;\n        uint256 avgPrice;\n        for (uint256 i; i < orders.length; i++) {\n            Perpetuals.Order memory order = ITrader(traderContract).getOrder(orders[i]);\n\n            if (\n                order.created < receipt.time || // Order made before receipt\n                order.maker != receipt.liquidator || // Order made by someone who isn't liquidator\n                order.side == receipt.liquidationSide // Order is in same direction as liquidation\n                /* Order should be the opposite to the position acquired on liquidation */\n            ) {\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            if (\n                (receipt.liquidationSide == Perpetuals.Side.Long && order.price >= receipt.price) ||\n                (receipt.liquidationSide == Perpetuals.Side.Short && order.price <= receipt.price)\n            ) {\n                // Liquidation position was long\n                // Price went up, so not a slippage order\n                // or\n                // Liquidation position was short\n                // Price went down, so not a slippage order\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            uint256 orderFilled = ITrader(traderContract).filledAmount(order);\n            uint256 averageExecutionPrice = ITrader(traderContract).getAverageExecutionPrice(order);\n\n            /* order.created >= receipt.time\n             * && order.maker == receipt.liquidator\n             * && order.side != receipt.liquidationSide */\n            unitsSold = unitsSold + orderFilled;\n            avgPrice = avgPrice + (averageExecutionPrice * orderFilled);\n        }\n\n        // Avoid divide by 0 if no orders sold\n        if (unitsSold == 0) {\n            return (0, 0);\n        }\n        return (unitsSold, avgPrice / unitsSold);\n    }\n\n    /**\n     * @notice Marks receipts as claimed and returns the refund amount\n     * @param escrowId the id of the receipt created during the liquidation event\n     * @param orders the orders that sell the liquidated positions\n     * @param traderContract the address of the trader contract the selling orders were made by\n     */\n    function calcAmountToReturn(\n        uint256 escrowId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) public override returns (uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[escrowId];\n        // Validate the escrowed order was fully sold\n        (uint256 unitsSold, uint256 avgPrice) = calcUnitsSold(orders, traderContract, escrowId);\n        require(unitsSold <= uint256(receipt.amountLiquidated.abs()), \"LIQ: Unit mismatch\");\n\n        uint256 amountToReturn = LibLiquidation.calculateSlippage(unitsSold, maxSlippage, avgPrice, receipt);\n        return amountToReturn;\n    }\n\n    /**\n     * @notice Drains a certain amount from insurance pool to cover excess slippage not covered by escrow\n     * @param amountWantedFromInsurance How much we want to drain\n     * @param receipt The liquidation receipt for which we are calling on the insurance pool to cover\n     */\n    function drainInsurancePoolOnLiquidation(\n        uint256 amountWantedFromInsurance,\n        LibLiquidation.LiquidationReceipt memory receipt\n    ) internal returns (uint256 _amountTakenFromInsurance, uint256 _amountToGiveToClaimant) {\n        /*\n         * If there was not enough escrowed, we want to call the insurance pool to help out.\n         * First, check the margin of the insurance Account. If this is enough, just drain from there.\n         * If this is not enough, call Insurance.drainPool to get some tokens from the insurance pool.\n         * If drainPool is able to drain enough, drain from the new margin.\n         * If the margin still does not have enough after calling drainPool, we are not able to fully\n         * claim the receipt, only up to the amount the insurance pool allows for.\n         */\n\n        Balances.Account memory insuranceBalance = tracer.getBalance(insuranceContract);\n        if (insuranceBalance.position.quote >= amountWantedFromInsurance.toInt256()) {\n            // We don't need to drain insurance contract. The balance is already in the market contract\n            _amountTakenFromInsurance = amountWantedFromInsurance;\n        } else {\n            // insuranceBalance.quote < amountWantedFromInsurance\n            if (insuranceBalance.position.quote <= 0) {\n                // attempt to drain entire balance that is needed from the pool\n                IInsurance(insuranceContract).drainPool(amountWantedFromInsurance);\n            } else {\n                // attempt to drain the required balance taking into account the insurance balance in the account contract\n                IInsurance(insuranceContract).drainPool(\n                    amountWantedFromInsurance - uint256(insuranceBalance.position.quote)\n                );\n            }\n            Balances.Account memory updatedInsuranceBalance = tracer.getBalance(insuranceContract);\n            if (updatedInsuranceBalance.position.quote < amountWantedFromInsurance.toInt256()) {\n                // Still not enough\n                _amountTakenFromInsurance = uint256(updatedInsuranceBalance.position.quote);\n            } else {\n                _amountTakenFromInsurance = amountWantedFromInsurance;\n            }\n        }\n\n        _amountToGiveToClaimant = receipt.escrowedAmount + _amountTakenFromInsurance;\n        // Don't add any to liquidatee\n    }\n\n    /**\n     * @notice Allows a liquidator to submit a single liquidation receipt and multiple order ids. If the\n     *         liquidator experienced slippage, will refund them a proportional amount of their deposit.\n     * @param receiptId Used to identify the receipt that will be claimed\n     * @param orders The orders that sold the liquidated position\n     */\n    function claimReceipt(\n        uint256 receiptId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) external override {\n        // Claim the receipts from the escrow system, get back amount to return\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(receipt.liquidator == msg.sender, \"LIQ: Liquidator mismatch\");\n        // Mark refund as claimed\n        require(!receipt.liquidatorRefundClaimed, \"LIQ: Already claimed\");\n        liquidationReceipts[receiptId].liquidatorRefundClaimed = true;\n        liquidationReceipts[receiptId].escrowClaimed = true;\n        require(block.timestamp < receipt.releaseTime, \"LIQ: claim time passed\");\n        require(tracer.tradingWhitelist(traderContract), \"LIQ: Trader is not whitelisted\");\n\n        uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            liquidationReceipts[receiptId].escrowedAmount = 0;\n        } else {\n            liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;\n        }\n\n        // Keep track of how much was actually taken out of insurance\n        uint256 amountTakenFromInsurance;\n        uint256 amountToGiveToClaimant;\n        uint256 amountToGiveToLiquidatee;\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            // Need to cover some loses with the insurance contract\n            // Whatever is the remainder that can't be covered from escrow\n            uint256 amountWantedFromInsurance = amountToReturn - receipt.escrowedAmount;\n            (amountTakenFromInsurance, amountToGiveToClaimant) = drainInsurancePoolOnLiquidation(\n                amountWantedFromInsurance,\n                receipt\n            );\n        } else {\n            amountToGiveToClaimant = amountToReturn;\n            amountToGiveToLiquidatee = receipt.escrowedAmount - amountToReturn;\n        }\n\n        tracer.updateAccountsOnClaim(\n            receipt.liquidator,\n            amountToGiveToClaimant.toInt256(),\n            receipt.liquidatee,\n            amountToGiveToLiquidatee.toInt256(),\n            amountTakenFromInsurance.toInt256()\n        );\n        emit ClaimedReceipts(msg.sender, address(tracer), receiptId);\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ILiquidation) onlyOwner {\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Modifies the release time\n     * @param _releaseTime new release time\n     */\n    function setReleaseTime(uint256 _releaseTime) external onlyOwner() {\n        releaseTime = _releaseTime;\n    }\n\n    /**\n     * @notice Modifies the value to multiply the liquidation cost by in determining\n     *         the minimum leftover margin on partial liquidation\n     * @param _minimumLeftoverGasCostMultiplier The new multiplier\n     */\n    function setMinimumLeftoverGasCostMultiplier(uint256 _minimumLeftoverGasCostMultiplier) external onlyOwner() {\n        minimumLeftoverGasCostMultiplier = _minimumLeftoverGasCostMultiplier;\n    }\n\n    /**\n     * @notice Modifies the max slippage\n     * @param _maxSlippage new max slippage\n     */\n    function setMaxSlippage(uint256 _maxSlippage) public override onlyOwner() {\n        maxSlippage = _maxSlippage;\n    }\n}\n\n\n",
        "CodeNames": [
            "TracerPerpetualSwaps.sol",
            "Liquidation.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [
                    "//solidity\nfunction executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {\n",
                    "//solidity\nfunction claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {\n"
                ],
                "Type": " Claim liquidation escrow",
                "Description": "\nA liquidator can always claim the liquidation escrow in the following way:\ncreate a second account\nsetup a complimentary trade in that second account, which will result in a large slippage when executed\ncall executeTrade (which everyone can call), to execute a trade between his own two accounts with a large slippage\nthe slippage doesn't hurt because the liquidator owns both accounts\ncall claimReceipt with the receiptId of the executed order, within the required period (e.g. 15 minutes)\n\nL67(https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67)\nsolidity\nfunction executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {\n\nL394(https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394)\nsolidity\nfunction claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {\n\n\n",
                "Repair": "Recommend to perhaps limit who can call executeTrade.\n\nraymogg (Tracer) acknowledged and confirmed(https://github.com/code-423n4/2021-06-tracer-findings/issues/2#issuecomment-873774429):\n  Valid issue which would allow someone to get reimbursed for slippage against themselves.\n\n The Trader contract will have whitelisted relayers added to prevent issues like this (similar to #119)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./InsurancePoolToken.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport \"./lib/LibInsurance.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract Insurance is IInsurance {\n    using LibMath for uint256;\n    using LibMath for int256;\n    ITracerPerpetualsFactory public perpsFactory;\n\n    address public collateralAsset; // Address of collateral asset\n    uint256 public override publicCollateralAmount; // amount of underlying collateral in public pool, in WAD format\n    uint256 public override bufferCollateralAmount; // amount of collateral in buffer pool, in WAD format\n    address public token; // token representation of a users holding in the pool\n\n    ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool\n\n    event InsuranceDeposit(address indexed market, address indexed user, uint256 indexed amount);\n    event InsuranceWithdraw(address indexed market, address indexed user, uint256 indexed amount);\n    event InsurancePoolDeployed(address indexed market, address indexed asset);\n\n    constructor(address _tracer) {\n        tracer = ITracerPerpetualSwaps(_tracer);\n        InsurancePoolToken _token = new InsurancePoolToken(\"Tracer Pool Token\", \"TPT\");\n        token = address(_token);\n        collateralAsset = tracer.tracerQuoteToken();\n\n        emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());\n    }\n\n    /**\n     * @notice Allows a user to deposit to a given tracer market insurance pool\n     * @dev Mints amount of the pool token to the user\n     * @param amount the amount of tokens to deposit. Provided in WAD format\n     */\n    function deposit(uint256 amount) external override {\n        IERC20 collateralToken = IERC20(collateralAsset);\n\n        // convert token amount to WAD\n        uint256 quoteTokenDecimals = tracer.quoteTokenDecimals();\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        collateralToken.transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // amount in wad format after being converted from token format\n        uint256 wadAmount = uint256(Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount));\n\n        // Update pool balances and user\n        updatePoolAmount();\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to mint = (pool token supply / collateral holdings) * collateral amount to stake\n        uint256 tokensToMint = LibInsurance.calcMintAmount(poolToken.totalSupply(), publicCollateralAmount, wadAmount);\n\n        // mint pool tokens, hold collateral tokens\n        poolToken.mint(msg.sender, tokensToMint);\n        publicCollateralAmount = publicCollateralAmount + wadAmount;\n        emit InsuranceDeposit(address(tracer), msg.sender, wadAmount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw their assets from a given insurance pool\n     * @dev burns amount of tokens from the pool token\n     * @param amount the amount of pool tokens to burn. Provided in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        updatePoolAmount();\n        uint256 balance = getPoolUserBalance(msg.sender);\n        require(balance >= amount, \"INS: balance < amount\");\n\n        IERC20 collateralToken = IERC20(collateralAsset);\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to return = (collateral holdings / pool token supply) * amount of pool tokens to withdraw\n        uint256 wadTokensToSend = LibInsurance.calcWithdrawAmount(\n            poolToken.totalSupply(),\n            publicCollateralAmount,\n            amount\n        );\n\n        // convert token amount to raw amount from WAD\n        uint256 rawTokenAmount = Balances.wadToToken(tracer.quoteTokenDecimals(), wadTokensToSend);\n\n        // pool amount is always in WAD format\n        publicCollateralAmount = publicCollateralAmount - wadTokensToSend;\n\n        // burn pool tokens, return collateral tokens\n        poolToken.burnFrom(msg.sender, amount);\n        collateralToken.transfer(msg.sender, rawTokenAmount);\n\n        emit InsuranceWithdraw(address(tracer), msg.sender, wadTokensToSend);\n    }\n\n    /**\n     * @notice Internally updates a given tracer's pool amount according to the tracer contract\n     * @dev Withdraws from tracer, and adds amount to the pool's amount field.\n     */\n    function updatePoolAmount() public override {\n        uint256 quote = uint256((tracer.getBalance(address(this))).position.quote);\n\n        tracer.withdraw(quote);\n\n        if (publicCollateralAmount > 0) {\n            // Amount to pay to public is the ratio of public collateral amount to total funds\n            uint256 payToPublic = PRBMathUD60x18.mul(\n                quote,\n                PRBMathUD60x18.div(publicCollateralAmount, getPoolHoldings())\n            );\n\n            publicCollateralAmount = publicCollateralAmount + payToPublic;\n\n            // Amount to pay to buffer is the remainder\n            bufferCollateralAmount = bufferCollateralAmount + quote - payToPublic;\n        } else {\n            // Pay to buffer if nothing in public insurance\n            bufferCollateralAmount = bufferCollateralAmount + quote;\n        }\n    }\n\n    /**\n     * @notice Deposits some of the insurance pool's amount into the tracer contract\n     * @dev If amount is greater than the insurance pool's balance, deposit total balance.\n     *      This was done because in such an emergency situation, we want to recover as much as possible\n     * @param amount The desired amount to take from the insurance pool\n     */\n    function drainPool(uint256 amount) external override onlyLiquidation() {\n        IERC20 tracerMarginToken = IERC20(tracer.tracerQuoteToken());\n\n        uint256 poolHoldings = getPoolHoldings();\n\n        if (amount >= poolHoldings) {\n            // If public collateral left after draining is less than 1 token, we want to keep it at 1 token\n            if (publicCollateralAmount > 10**18) {\n                // Leave 1 token for the public pool\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                amount = bufferCollateralAmount;\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else if (amount > bufferCollateralAmount) {\n            if (publicCollateralAmount < 10**18) {\n                // If there's not enough public collateral for there to be 1 token, cap amount being drained at the buffer\n                amount = bufferCollateralAmount;\n            } else if (poolHoldings - amount < 10**18) {\n                // If the amount of collateral left in the public insurance would be less than 1 token, cap amount being drained\n                // from the public insurance such that 1 token is left in the public buffer\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                // Take out what you need from the public pool; there's enough for there to be >= 1 token left\n                publicCollateralAmount = publicCollateralAmount - (amount - bufferCollateralAmount);\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else {\n            // Only need to take part of buffer pool out\n            bufferCollateralAmount = bufferCollateralAmount - amount;\n        }\n\n        tracerMarginToken.approve(address(tracer), amount);\n        tracer.deposit(amount);\n    }\n\n    /**\n     * @notice gets a users balance in a given insurance pool\n     * @param user the user whose balance is being retrieved\n     */\n    function getPoolUserBalance(address user) public view override returns (uint256) {\n        return InsurancePoolToken(token).balanceOf(user);\n    }\n\n    /**\n     * @notice Get total holdings of the insurance pool (= public + buffer collateral)\n     */\n    function getPoolHoldings() public view override returns (uint256) {\n        return bufferCollateralAmount + publicCollateralAmount;\n    }\n\n    /**\n     * @notice Gets the target fund amount for a given insurance pool\n     * @dev The target amount is 1% of the leveraged notional value of the tracer being insured.\n     */\n    function getPoolTarget() public view override returns (uint256) {\n        return tracer.leveragedNotionalValue() / 100;\n    }\n\n    /**\n     * @notice Gets the 8 hour funding rate for an insurance pool\n     * @dev the funding rate is represented as\n     *      0.0036523 * (insurance_fund_target - insurance_fund_holdings) / leveraged_notional_value)\n     */\n    function getPoolFundingRate() external view override returns (uint256) {\n        // 0.0036523 as a WAD = 36523 * (10**11)\n        uint256 multiplyFactor = 36523 * (10**11);\n\n        uint256 levNotionalValue = tracer.leveragedNotionalValue();\n\n        // Traders only pay the insurance funding rate if the market has leverage\n        if (levNotionalValue == 0) {\n            return 0;\n        }\n\n        uint256 poolHoldings = getPoolHoldings();\n        uint256 poolTarget = getPoolTarget();\n\n        // If the pool is above the target, we don't pay the insurance funding rate\n        if (poolTarget <= poolHoldings) {\n            return 0;\n        }\n\n        uint256 ratio = PRBMathUD60x18.div(poolTarget - poolHoldings, levNotionalValue);\n\n        return PRBMathUD60x18.mul(multiplyFactor, ratio);\n    }\n\n    modifier onlyLiquidation() {\n        require(msg.sender == tracer.liquidationContract(), \"INS: sender not LIQ contract\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/SafetyWithdraw.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport {Types} from \"./Interfaces/Types.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant override LIQUIDATION_GAS_COST = 63516;\n    address public immutable override tracerQuoteToken;\n    uint256 public immutable override quoteTokenDecimals;\n    bytes32 public immutable override marketId;\n    IPricing public pricingContract;\n    IInsurance public insuranceContract;\n    address public override liquidationContract;\n    uint256 public override feeRate;\n    uint256 public override fees;\n    address public override feeReceiver;\n\n    /* Config variables */\n    // The price of gas in gwei\n    address public override gasPriceOracle;\n    // The maximum ratio of notionalValue to margin\n    uint256 public override maxLeverage;\n    // WAD value. sensitivity of 1 = 1*10^18\n    uint256 public override fundingRateSensitivity;\n    // WAD value. The percentage for insurance pool holdings/pool target where deleveraging begins\n    uint256 public override deleveragingCliff;\n    /* The percentage of insurance holdings to target at which the insurance pool\n       funding rate changes, and lowestMaxLeverage is reached */\n    uint256 public override insurancePoolSwitchStage;\n    // The lowest value that maxLeverage can be, if insurance pool is empty.\n    uint256 public override lowestMaxLeverage;\n\n    // Account State Variables\n    mapping(address => Balances.Account) public balances;\n    uint256 public tvl;\n    uint256 public override leveragedNotionalValue;\n\n    // Trading interfaces whitelist\n    mapping(address => bool) public override tradingWhitelist;\n\n    event FeeReceiverUpdated(address indexed receiver);\n    event FeeWithdrawn(address indexed receiver, uint256 feeAmount);\n    event Deposit(address indexed user, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed amount);\n    event Settled(address indexed account, int256 margin);\n    event MatchedOrders(\n        address indexed long,\n        address indexed short,\n        uint256 amount,\n        uint256 price,\n        bytes32 longOrderId,\n        bytes32 shortOrderId\n    );\n    event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);\n\n    /**\n     * @notice Creates a new tracer market and sets the initial funding rate of the market. Anyone\n     *         will be able to purchase and trade tracers after this deployment.\n     * @param _marketId the id of the market, given as BASE/QUOTE\n     * @param _tracerQuoteToken the address of the token used for margin accounts (i.e. The margin token)\n     * @param _tokenDecimals the number of decimal places the quote token supports\n     * @param _gasPriceOracle the address of the contract implementing gas price oracle\n     * @param _maxLeverage the max leverage of the market represented as a WAD value.\n     * @param _fundingRateSensitivity the affect funding rate changes have on funding paid; u60.18-decimal fixed-point number (WAD value)\n     * @param _feeRate the fee taken on trades; WAD value. e.g. 2% fee = 0.02 * 10^18 = 2 * 10^16\n     * @param _feeReceiver the address of the person who can withdraw the fees from trades in this market\n     * @param _deleveragingCliff The percentage for insurance pool holdings/pool target where deleveraging begins.\n     *                           WAD value. e.g. 20% = 20*10^18\n     * @param _lowestMaxLeverage The lowest value that maxLeverage can be, if insurance pool is empty.\n     * @param _insurancePoolSwitchStage The percentage of insurance holdings to target at which the insurance pool\n     *                                  funding rate changes, and lowestMaxLeverage is reached\n     */\n    constructor(\n        bytes32 _marketId,\n        address _tracerQuoteToken,\n        uint256 _tokenDecimals,\n        address _gasPriceOracle,\n        uint256 _maxLeverage,\n        uint256 _fundingRateSensitivity,\n        uint256 _feeRate,\n        address _feeReceiver,\n        uint256 _deleveragingCliff,\n        uint256 _lowestMaxLeverage,\n        uint256 _insurancePoolSwitchStage\n    ) Ownable() {\n        // don't convert to interface as we don't need to interact with the contract\n        tracerQuoteToken = _tracerQuoteToken;\n        quoteTokenDecimals = _tokenDecimals;\n        gasPriceOracle = _gasPriceOracle;\n        marketId = _marketId;\n        feeRate = _feeRate;\n        maxLeverage = _maxLeverage;\n        fundingRateSensitivity = _fundingRateSensitivity;\n        feeReceiver = _feeReceiver;\n        deleveragingCliff = _deleveragingCliff;\n        lowestMaxLeverage = _lowestMaxLeverage;\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    /**\n     * @notice Adjust the max leverage as insurance pool slides from 100% of target to 0% of target\n     */\n    function trueMaxLeverage() public view override returns (uint256) {\n        IInsurance insurance = IInsurance(insuranceContract);\n\n        return\n            Perpetuals.calculateTrueMaxLeverage(\n                insurance.getPoolHoldings(),\n                insurance.getPoolTarget(),\n                maxLeverage,\n                lowestMaxLeverage,\n                deleveragingCliff,\n                insurancePoolSwitchStage\n            );\n    }\n\n    /**\n     * @notice Allows a user to deposit into their margin account\n     * @dev this contract must be an approved spender of the markets quote token on behalf of the depositer.\n     * @param amount The amount of quote tokens to be deposited into the Tracer Market account. This amount\n     * should be given in WAD format.\n     */\n    function deposit(uint256 amount) external override {\n        Balances.Account storage userBalance = balances[msg.sender];\n        // settle outstanding payments\n        settle(msg.sender);\n\n        // convert the WAD amount to the correct token amount to transfer\n        // cast is safe since amount is a uint, and wadToToken can only\n        // scale down the value\n        uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());\n        IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // this prevents dust from being added to the user account\n        // eg 10^18 -> 10^8 -> 10^18 will remove lower order bits\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        // update user state\n        userBalance.position.quote = userBalance.position.quote + convertedWadAmount;\n        _updateAccountLeverage(msg.sender);\n\n        // update market TVL\n        tvl = tvl + uint256(convertedWadAmount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw from their margin account\n     * @dev Ensures that the users margin percent is valid after withdraw\n     * @param amount The amount of margin tokens to be withdrawn from the tracer market account. This amount\n     * should be given in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        // settle outstanding payments\n        settle(msg.sender);\n\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        Balances.Account storage userBalance = balances[msg.sender];\n        int256 newQuote = userBalance.position.quote - convertedWadAmount;\n\n        // this may be able to be optimised\n        Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);\n\n        require(\n            Balances.marginIsValid(\n                newPosition,\n                userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ),\n            \"TCR: Withdraw below valid Margin\"\n        );\n\n        // update user state\n        userBalance.position.quote = newQuote;\n        _updateAccountLeverage(msg.sender);\n\n        // Safemath will throw if tvl < amount\n        tvl = tvl - amount;\n\n        // perform transfer\n        IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);\n        emit Withdraw(msg.sender, uint256(convertedWadAmount));\n    }\n\n    /**\n     * @notice Attempt to match two orders that exist on-chain against each other\n     * @dev Emits a FailedOrders or MatchedOrders event based on whether the\n     *      orders were successfully able to be matched\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount Amount that the two orders are being filled for\n     * @return Whether the two orders were able to be matched successfully\n     */\n    function matchOrders(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount\n    ) external override onlyWhitelisted returns (bool) {\n        bytes32 order1Id = Perpetuals.orderId(order1);\n        bytes32 order2Id = Perpetuals.orderId(order2);\n        uint256 filled1 = ITrader(msg.sender).filled(order1Id);\n        uint256 filled2 = ITrader(msg.sender).filled(order2Id);\n\n        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);\n\n        // settle accounts\n        // note: this can revert and hence no order events will be emitted\n        settle(order1.maker);\n        settle(order2.maker);\n\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(\n            order1,\n            order2,\n            fillAmount,\n            executionPrice\n        );\n        // validate orders can match, and outcome state is valid\n        if (\n            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||\n            !Balances.marginIsValid(\n                newPos1,\n                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ) ||\n            !Balances.marginIsValid(\n                newPos2,\n                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            )\n        ) {\n            // emit failed to match event and return false\n            if (order1.side == Perpetuals.Side.Long) {\n                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);\n            } else {\n                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);\n            }\n            return false;\n        }\n\n        // update account states\n        balances[order1.maker].position = newPos1;\n        balances[order2.maker].position = newPos2;\n\n        // update fees\n        fees =\n            fees +\n            // add 2 * fees since getFeeRate returns the fee rate for a single\n            // side of the order. Both users were charged fees\n            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);\n\n        // update leverage\n        _updateAccountLeverage(order1.maker);\n        _updateAccountLeverage(order2.maker);\n\n        // Update internal trade state\n        pricingContract.recordTrade(executionPrice);\n\n        if (order1.side == Perpetuals.Side.Long) {\n            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);\n        } else {\n            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Updates account states of two accounts given two orders that are being executed\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount The amount that the two ordered are being filled for\n     * @param executionPrice The execution price of the trades\n     * @return The new balances of the two accounts after the trade\n     */\n    function _executeTrade(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount,\n        uint256 executionPrice\n    ) internal view returns (Balances.Position memory, Balances.Position memory) {\n        // Retrieve account state\n        Balances.Account memory account1 = balances[order1.maker];\n        Balances.Account memory account2 = balances[order2.maker];\n\n        // Construct `Trade` types suitable for use with LibBalances\n        (Balances.Trade memory trade1, Balances.Trade memory trade2) = (\n            Balances.Trade(executionPrice, fillAmount, order1.side),\n            Balances.Trade(executionPrice, fillAmount, order2.side)\n        );\n\n        // Calculate new account state\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = (\n            Balances.applyTrade(account1.position, trade1, feeRate),\n            Balances.applyTrade(account2.position, trade2, feeRate)\n        );\n\n        // return new account state\n        return (newPos1, newPos2);\n    }\n\n    /**\n     * @notice internal function for updating leverage. Called within the Account contract. Also\n     *         updates the total leveraged notional value for the tracer market itself.\n     */\n    function _updateAccountLeverage(address account) internal {\n        Balances.Account memory userBalance = balances[account];\n        uint256 originalLeverage = userBalance.totalLeveragedValue;\n        uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());\n        balances[account].totalLeveragedValue = newLeverage;\n\n        // Update market leveraged notional value\n        _updateTracerLeverage(newLeverage, originalLeverage);\n    }\n\n    /**\n     * @notice Updates the global leverage value given an accounts new leveraged value and old leveraged value\n     * @param accountNewLeveragedNotional The future notional value of the account\n     * @param accountOldLeveragedNotional The stored notional value of the account\n     */\n    function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {\n        leveragedNotionalValue = Prices.globalLeverage(\n            leveragedNotionalValue,\n            accountOldLeveragedNotional,\n            accountNewLeveragedNotional\n        );\n    }\n\n    /**\n     * @notice When a liquidation occurs, Liquidation.sol needs to push this contract to update\n     *         account states as necessary.\n     * @param liquidator Address of the account that called liquidate(...)\n     * @param liquidatee Address of the under-margined account getting liquidated\n     * @param liquidatorQuoteChange Amount the liquidator's quote is changing\n     * @param liquidatorBaseChange Amount the liquidator's base is changing\n     * @param liquidateeQuoteChange Amount the liquidated account's quote is changing\n     * @param liquidateeBaseChange Amount the liquidated account's base is changing\n     * @param amountToEscrow The amount the liquidator has to put into escrow\n     */\n    function updateAccountsOnLiquidation(\n        address liquidator,\n        address liquidatee,\n        int256 liquidatorQuoteChange,\n        int256 liquidatorBaseChange,\n        int256 liquidateeQuoteChange,\n        int256 liquidateeBaseChange,\n        uint256 amountToEscrow\n    ) external override onlyLiquidation {\n        // Limits the gas use when liquidating\n        uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();\n        // Update liquidators last updated gas price\n        Balances.Account storage liquidatorBalance = balances[liquidator];\n        Balances.Account storage liquidateeBalance = balances[liquidatee];\n\n        // update liquidators balance\n        liquidatorBalance.lastUpdatedGasPrice = gasPrice;\n        liquidatorBalance.position.quote =\n            liquidatorBalance.position.quote +\n            liquidatorQuoteChange -\n            amountToEscrow.toInt256();\n        liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;\n\n        // update liquidatee balance\n        liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;\n        liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;\n\n        // Checks if the liquidator is in a valid position to process the liquidation\n        require(userMarginIsValid(liquidator), \"TCR: Liquidator under min margin\");\n    }\n\n    /**\n     * @notice When a liquidation receipt is claimed by the liquidator (i.e. they experienced slippage),\n               Liquidation.sol needs to tell the market to update its balance and the balance of the\n               liquidated agent.\n     * @dev Gives the leftover amount from the receipt to the liquidated agent\n     * @param claimant The liquidator, who has experienced slippage selling the liquidated position\n     * @param amountToGiveToClaimant The amount the liquidator is owe based off slippage\n     * @param liquidatee The account that originally got liquidated\n     * @param amountToGiveToLiquidatee Amount owed to the liquidated account\n     * @param amountToTakeFromInsurance Amount that needs to be taken from the insurance pool\n                                        in order to cover liquidation\n     */\n    function updateAccountsOnClaim(\n        address claimant,\n        int256 amountToGiveToClaimant,\n        address liquidatee,\n        int256 amountToGiveToLiquidatee,\n        int256 amountToTakeFromInsurance\n    ) external override onlyLiquidation {\n        address insuranceAddr = address(insuranceContract);\n        balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;\n        balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;\n        balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;\n        require(balances[insuranceAddr].position.quote >= 0, \"TCR: Insurance not funded enough\");\n    }\n\n    /**\n     * @notice settles an account. Compares current global rate with the users last updated rate\n     *         Updates the accounts margin balance accordingly.\n     * @dev Ensures the account remains in a valid margin position. Will throw if account is under margin\n     *      and the account must then be liquidated.\n     * @param account the address to settle.\n     * @dev This function aggregates data to feed into account.sols settle function which sets\n     */\n    function settle(address account) public override {\n        // Get account and global last updated indexes\n        uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;\n        uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();\n        Balances.Account storage accountBalance = balances[account];\n\n        // if this user has no positions, bring them in sync\n        if (accountBalance.position.base == 0) {\n            // set to the last fully established index\n            accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n        } else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {\n            // Only settle account if its last updated index was before the last established\n            // global index this is since we reference the last global index\n            // Get current and global funding statuses\n            uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;\n            // Note: global rates reference the last fully established rate (hence the -1), and not\n            // the current global rate. User rates reference the last saved user rate\n            Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);\n            Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);\n\n            Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(\n                lastEstablishedIndex\n            );\n\n            Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(\n                accountLastUpdatedIndex\n            );\n\n            // settle the account\n            Balances.Account storage insuranceBalance = balances[address(insuranceContract)];\n\n            accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);\n\n            // Update account gas price\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n\n            if (accountBalance.totalLeveragedValue > 0) {\n                (Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(\n                    accountBalance.position,\n                    insuranceBalance.position,\n                    currInsuranceGlobalRate,\n                    currInsuranceUserRate,\n                    accountBalance.totalLeveragedValue\n                );\n\n                balances[account].position = newUserPos;\n                balances[(address(insuranceContract))].position = newInsurancePos;\n            }\n\n            // Update account index\n            accountBalance.lastUpdatedIndex = lastEstablishedIndex;\n            require(userMarginIsValid(account), \"TCR: Target under-margined\");\n            emit Settled(account, accountBalance.position.quote);\n        }\n    }\n\n    /**\n     * @notice Checks if a given accounts margin is valid\n     * @param account The address of the account whose margin is to be checked\n     * @return true if the margin is valid or false otherwise\n     */\n    function userMarginIsValid(address account) public view returns (bool) {\n        Balances.Account memory accountBalance = balances[account];\n        return\n            Balances.marginIsValid(\n                accountBalance.position,\n                accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            );\n    }\n\n    /**\n     * @notice Withdraws the fees taken on trades, and sends them to the designated\n     *         fee receiver (set by the owner of the market)\n     * @dev Anyone can call this function, but fees are transferred to the fee receiver.\n     *      Fees is also subtracted from the total value locked in the market because\n     *      fees are taken out of trades that result in users' quotes being modified, and\n     *      don't otherwise get subtracted from the tvl of the market\n     */\n    function withdrawFees() external override {\n        uint256 tempFees = fees;\n        fees = 0;\n        tvl = tvl - tempFees;\n\n        // Withdraw from the account\n        IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);\n        emit FeeWithdrawn(feeReceiver, tempFees);\n    }\n\n    function getBalance(address account) external view override returns (Balances.Account memory) {\n        return balances[account];\n    }\n\n    function setLiquidationContract(address _liquidationContract) external override onlyOwner {\n        require(_liquidationContract != address(0), \"address(0) given\");\n        liquidationContract = _liquidationContract;\n    }\n\n    function setInsuranceContract(address insurance) external override onlyOwner {\n        require(insurance != address(0), \"address(0) given\");\n        insuranceContract = IInsurance(insurance);\n    }\n\n    function setPricingContract(address pricing) external override onlyOwner {\n        require(pricing != address(0), \"address(0) given\");\n        pricingContract = IPricing(pricing);\n    }\n\n    function setGasOracle(address _gasOracle) external override onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasPriceOracle = _gasOracle;\n    }\n\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address(0) given\");\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    function setFeeRate(uint256 _feeRate) external override onlyOwner {\n        feeRate = _feeRate;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {\n        maxLeverage = _maxLeverage;\n    }\n\n    function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {\n        fundingRateSensitivity = _fundingRateSensitivity;\n    }\n\n    function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {\n        deleveragingCliff = _deleveragingCliff;\n    }\n\n    function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {\n        lowestMaxLeverage = _lowestMaxLeverage;\n    }\n\n    function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {\n        require(newOwner != address(0), \"address(0) given\");\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice allows the owner of a market to set the whitelisting of a trading interface address\n     * @dev a permissioned interface may call the matchOrders function.\n     * @param tradingContract the contract to have its whitelisting permissions set\n     * @param whitelisted the permission of the contract. If true this contract make call makeOrder\n     */\n    function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {\n        tradingWhitelist[tradingContract] = whitelisted;\n    }\n\n    // Modifier such that only the set liquidation contract can call a function\n    modifier onlyLiquidation() {\n        require(msg.sender == liquidationContract, \"TCR: Sender not liquidation\");\n        _;\n    }\n\n    // Modifier such that only a whitelisted trader can call a function\n    modifier onlyWhitelisted() {\n        require(tradingWhitelist[msg.sender], \"TCR: Contract not whitelisted\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\n\ncontract Pricing is IPricing {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n\n    address public tracer;\n    IInsurance public insurance;\n    IOracle public oracle;\n\n    // pricing metrics\n    Prices.PriceInstant[24] internal hourlyTracerPrices;\n    Prices.PriceInstant[24] internal hourlyOraclePrices;\n\n    // funding index => funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public fundingRates;\n\n    // funding index => insurance funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;\n\n    // market's time value\n    int256 public override timeValue;\n\n    // funding index\n    uint256 public override currentFundingIndex;\n\n    // timing variables\n    uint256 public startLastHour;\n    uint256 public startLast24Hours;\n    uint8 public override currentHour;\n\n    event HourlyPriceUpdated(uint256 price, uint256 currentHour);\n    event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);\n    event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);\n\n    /**\n     * @dev Set tracer perps factory\n     * @dev ensure that oracle contract is returning WAD values. This may be done\n     *      by wrapping the raw oracle in an adapter (see contracts/oracle)\n     * @param _tracer The address of the tracer this pricing contract links too\n     */\n    constructor(\n        address _tracer,\n        address _insurance,\n        address _oracle\n    ) {\n        tracer = _tracer;\n        insurance = IInsurance(_insurance);\n        oracle = IOracle(_oracle);\n        startLastHour = block.timestamp;\n        startLast24Hours = block.timestamp;\n    }\n\n    /**\n     * @notice Updates pricing information given a trade of a certain volume at\n     *         a set price\n     * @param tradePrice the price the trade executed at\n     */\n    function recordTrade(uint256 tradePrice) external override onlyTracer {\n        uint256 currentOraclePrice = oracle.latestAnswer();\n        if (startLastHour <= block.timestamp - 1 hours) {\n            // emit the old hourly average\n            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);\n            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);\n\n            // update funding rate for the previous hour\n            updateFundingRate();\n\n            // update the time value\n            if (startLast24Hours <= block.timestamp - 24 hours) {\n                // Update the interest rate every 24 hours\n                updateTimeValue();\n                startLast24Hours = block.timestamp;\n            }\n\n            // update time metrics after all other state\n            startLastHour = block.timestamp;\n\n            // Check current hour and loop around if need be\n            if (currentHour == 23) {\n                currentHour = 0;\n            } else {\n                currentHour = currentHour + 1;\n            }\n\n            // add new pricing entry for new hour\n            updatePrice(tradePrice, currentOraclePrice, true);\n        } else {\n            // Update old pricing entry\n            updatePrice(tradePrice, currentOraclePrice, false);\n        }\n    }\n\n    /**\n     * @notice Updates both the latest market price and the latest underlying asset price (from an oracle) for a given tracer market given a tracer price\n     *         and an oracle price.\n     * @param marketPrice The price that a tracer was bought at, returned by the TracerPerpetualSwaps.sol contract when an order is filled\n     * @param oraclePrice The price of the underlying asset that the Tracer is based upon as returned by a Chainlink Oracle\n     * @param newRecord Bool that decides if a new hourly record should be started (true) or if a current hour should be updated (false)\n     */\n    function updatePrice(\n        uint256 marketPrice,\n        uint256 oraclePrice,\n        bool newRecord\n    ) internal {\n        // Price records entries updated every hour\n        if (newRecord) {\n            // Make new hourly record, total = marketprice, numtrades set to 1;\n            Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);\n            hourlyTracerPrices[currentHour] = newHourly;\n            // As above but with Oracle price\n            Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);\n            hourlyOraclePrices[currentHour] = oracleHour;\n        } else {\n            // If an update is needed, add the market price to a running total and increment number of trades\n            hourlyTracerPrices[currentHour].cumulativePrice =\n                hourlyTracerPrices[currentHour].cumulativePrice +\n                marketPrice;\n            hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;\n            // As above but with oracle price\n            hourlyOraclePrices[currentHour].cumulativePrice =\n                hourlyOraclePrices[currentHour].cumulativePrice +\n                oraclePrice;\n            hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;\n        }\n    }\n\n    /**\n     * @notice Updates the funding rate and the insurance funding rate\n     */\n    function updateFundingRate() internal {\n        // Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable\n        ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);\n        Prices.TWAP memory twapPrices = getTWAPs(currentHour);\n        int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();\n        uint256 underlyingTWAP = twapPrices.underlying;\n        uint256 derivativeTWAP = twapPrices.derivative;\n\n        int256 newFundingRate = PRBMathSD59x18.mul(\n            derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,\n            _tracer.fundingRateSensitivity().toInt256()\n        );\n\n        // Create variable with value of new funding rate value\n        int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;\n\n        // as above but with insurance funding rate value\n        int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;\n\n        // Call setter functions on calculated variables\n        setFundingRate(newFundingRate, cumulativeFundingRate);\n        emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);\n        setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);\n        emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);\n        // increment funding index\n        currentFundingIndex = currentFundingIndex + 1;\n    }\n\n    /**\n     * @notice Given the address of a tracer market this function will get the current fair price for that market\n     */\n    function fairPrice() external view override returns (uint256) {\n        return Prices.fairPrice(oracle.latestAnswer(), timeValue);\n    }\n\n    ////////////////////////////\n    ///  SETTER FUNCTIONS   ///\n    //////////////////////////\n\n    /**\n     * @notice Calculates and then updates the time Value for a tracer market\n     */\n    function updateTimeValue() internal {\n        (uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();\n\n        timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct\n     * @param fundingRate The funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        fundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct for a particular Tracer Marker\n     * @param fundingRate The insurance funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    // todo by using public variables lots of these can be removed\n    /**\n     * @return each variable of the fundingRate struct of a particular tracer at a particular funding rate index\n     */\n    function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return fundingRates[index];\n    }\n\n    /**\n     * @return all of the variables in the funding rate struct (insurance rate) from a particular tracer market\n     */\n    function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return insuranceFundingRates[index];\n    }\n\n    /**\n     * @notice Gets an 8 hour time weighted avg price for a given tracer, at a particular hour. More recent prices are weighted more heavily.\n     * @param hour An integer representing what hour of the day to collect from (0-24)\n     * @return the time weighted average price for both the oraclePrice (derivative price) and the Tracer Price\n     */\n    function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {\n        return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);\n    }\n\n    /**\n     * @notice Gets a 24 hour tracer and oracle price for a given tracer market\n     * @return the average price over a 24 hour period for oracle and Tracer price\n     */\n    function get24HourPrices() public view override returns (uint256, uint256) {\n        return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));\n    }\n\n    /**\n     * @notice Gets the average tracer price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     * @return the average price of the tracer for a particular hour\n     */\n    function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {\n        return Prices.averagePrice(hourlyTracerPrices[hour]);\n    }\n\n    /**\n     * @notice Gets the average oracle price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     */\n    function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {\n        return Prices.averagePrice(hourlyOraclePrices[hour]);\n    }\n\n    /**\n     * @dev Used when only valid tracers are allowed\n     */\n    modifier onlyTracer() {\n        require(msg.sender == tracer, \"PRC: Only Tracer\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Insurance.sol",
            "TracerPerpetualSwaps.sol",
            "Pricing.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "getPoolFundingRate",
                    "updateFundingRate",
                    "recordTrade",
                    "poolTarget",
                    "updateFundingRate()",
                    "setInsuranceFundingRate",
                    "matchOrders",
                    "deposit",
                    "executeTrade"
                ],
                "Type": " avoid paying insurance",
                "Description": "\nIt's possible to avoid paying insurance in the following way:\n\nonce per hour (at the right moment), do the following:\n1. using a flash loan, or with a large amount of tokens, call deposit of Insurance.sol to make sure that the pool is sufficiently filled (poolHoldings  poolTarget)\n2. call the function executeTrade of Trader.sol with a minimal trade (possibly of value 0, see finding \"executeTrade with same trades\")\n3. executeTrade calls matchOrders, which calls recordTrade\n4. recordTrade calls updateFundingRate();   (once per hour, so you have to be sure you do it in time before other trades trigger this)\n5. updateFundingRate calls getPoolFundingRate\n6. getPoolFundingRate determines the insurance rate, but because the insurance pool is sufficiently full (due to the flash loan), the rate is 0\n7. updateFundingRate stores the 0 rate via setInsuranceFundingRate  (which is used later on to calculate the amounts for the insurances)\n8. withdraw from the Insurance and pay back the flash loan\n\nThe insurance rates are 0 now and no-one pays insurance. The gas costs relative to the insurance costs + the flash loan fees determine if this is an economically viable attack. Otherwise it is still a grief attack.\nThis will probably be detected pretty soon because the insurance pool will stay empty. However its difficult to prevent.\n\nSee issue page for code referenced in proof of concept.\n\n",
                "Repair": "Recommend setting a timelock on withdrawing insurance.\n\nraymogg (Tracer) confirmed but disagreed with severity(https://github.com/code-423n4/2021-06-tracer-findings/issues/30#issuecomment-873763520):\n  Really like this exploit idea. Currently this is possible since the Trader is not whitelisted (eg there is no whitelisted relayer address). With this added, this exploit is no longer possible as only off chain relayers can place orders with the trader.\n\n Disagree with the severity mainly due to the fact that executing this exploit once would only cause insurance funding to not be paid for a single hour. For insurance funding to never be paid, you would have to time this transaction as the first transaction on each and every hour. This would quickly be noticed. The only affect on this would be insurance depositors miss interest payments for a few periods.\n\ncemozerr (Judge) commented(https://github.com/code-423n4/2021-06-tracer-findings/issues/30#issuecomment-882109332):\n  Marking this as medium risk as a front-runner could keep doing this for not paying any funding using a bot.\n\n\n"
            }
        ]
    }
]