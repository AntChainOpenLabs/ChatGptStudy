[
    {
        "Code": "// SPDX-License-Identifier: None\n// Copyright (c) 2022 Trader Joe - All rights reserved\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent is Ownable {\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public PHASE_ONE_DURATION;\n    uint256 public PHASE_ONE_NO_FEE_DURATION;\n    uint256 public PHASE_TWO_DURATION;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20Metadata public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool private initialized;\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of wavax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 private wavaxAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev wavaxReserve is the exact amount of WAVAX that needs to be kept inside the contract in order to send everyone's\n    /// WAVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private wavaxReserve;\n\n    event IssuingTokenDeposited(address indexed token, uint256 amount);\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(address indexed user, uint256 avaxAmount);\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Receive AVAX from the WAVAX contract\n    /// @dev Needed for withdrawing from WAVAX contract\n    receive() external payable {\n        require(\n            msg.sender == address(WAVAX),\n            \"LaunchEvent: you can't send AVAX directly to this contract\"\n        );\n    }\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        uint256 phase3Start = auctionStart +\n            PHASE_ONE_DURATION +\n            PHASE_TWO_DURATION;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n        _;\n    }\n\n    /// @notice Initialise the launch event with needed paramaters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(!initialized, \"LaunchEvent: already initialized\");\n\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();\n        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();\n        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();\n\n        token = IERC20Metadata(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n        initialized = true;\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (block.timestamp < auctionStart || auctionStart == 0) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp <\n            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    /// @dev Checks are done in the `_depositWAVAX` function\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Burn tokens and update allocation.\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        wavaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        WAVAX.deposit{value: msg.value}();\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) public isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        wavaxReserve -= _amount;\n\n        WAVAX.withdraw(_amount);\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        require(\n            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||\n                IJoePair(\n                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)\n                ).totalSupply() ==\n                0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(wavaxReserve > 0, \"LaunchEvent: no wavax balance\");\n\n        uint256 tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (\n            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated\n        ) {\n            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        WAVAX.approve(address(router), wavaxReserve);\n        token.approve(address(router), tokenAllocated);\n\n        /// We can't trust the output cause of reflect tokens\n        (, , lpSupply) = router.addLiquidity(\n            wavaxAddress, // tokenA\n            tokenAddress, // tokenB\n            wavaxReserve, // amountADesired\n            tokenAllocated, // amountBDesired\n            wavaxReserve, // amountAMin\n            tokenAllocated, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));\n        wavaxAllocated = wavaxReserve;\n        wavaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            wavaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnPair,\n            \"LaunchEvent: liquidity already withdrawn\"\n        );\n\n        uint256 balance = pairBalance(msg.sender);\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            balance = lpSupply / 2;\n\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n\n            if (tokenReserve > 0) {\n                uint256 amount = tokenReserve;\n                tokenReserve = 0;\n                token.transfer(msg.sender, amount);\n            }\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external isStopped(false) {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnIncentives,\n            \"LaunchEvent: incentives already withdrawn\"\n        );\n\n        user.hasWithdrawnIncentives = true;\n        uint256 amount;\n\n        if (msg.sender == issuer) {\n            amount = tokenIncentiveIssuerRefund;\n        } else {\n            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;\n        }\n\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        tokenIncentivesBalance -= amount;\n\n        token.transfer(msg.sender, amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (msg.sender != issuer) {\n            UserInfo storage user = getUserInfo[msg.sender];\n            require(\n                user.balance > 0,\n                \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n            );\n\n            uint256 balance = user.balance;\n            user.balance = 0;\n            wavaxReserve -= balance;\n            WAVAX.withdraw(balance);\n\n            _safeTransferAVAX(msg.sender, balance);\n\n            emit AvaxEmergencyWithdraw(msg.sender, balance);\n        } else {\n            uint256 balance = tokenReserve + tokenIncentivesBalance;\n            tokenReserve = 0;\n            tokenIncentivesBalance = 0;\n            token.transfer(issuer, balance);\n            emit TokenEmergencyWithdraw(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.transfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;\n        if (excessWavax > 0) {\n            WAVAX.transfer(penaltyCollector, excessWavax);\n        }\n\n        uint256 excessAvax = address(this).balance;\n        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {\n            return 0;\n        } else if (timeElapsed < PHASE_ONE_DURATION) {\n            return\n                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *\n                    maxWithdrawPenalty) /\n                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the current balance of the pool\n    /// @return The balances of WAVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return _avaxAmount * rJoePerAvax;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        return (user.balance * lpSupply) / wavaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier.\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        if (_phase == Phase.NotStarted) {\n            require(\n                currentPhase() == Phase.NotStarted,\n                \"LaunchEvent: not in not started\"\n            );\n        } else if (_phase == Phase.PhaseOne) {\n            require(\n                currentPhase() == Phase.PhaseOne,\n                \"LaunchEvent: not in phase one\"\n            );\n        } else if (_phase == Phase.PhaseTwo) {\n            require(\n                currentPhase() == Phase.PhaseTwo,\n                \"LaunchEvent: not in phase two\"\n            );\n        } else if (_phase == Phase.PhaseThree) {\n            require(\n                currentPhase() == Phase.PhaseThree,\n                \"LaunchEvent: not in phase three\"\n            );\n        } else {\n            revert(\"LaunchEvent: unknown state\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "LaunchEvent.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "lpSupply",
                    "allowEmergencyWithdraw()",
                    "emergencyWithdraw",
                    "createPair()",
                    "wavaxReserve = 0"
                ],
                "Type": " Users can lose value in emergency state",
                "Description": "\nImagine the following sequence of events:\n\n*   LaunchEvent.createPair() is called which sets wavaxReserve = 0, adds liquidity to the pair and receives lpSupply LP tokens.\n*   LaunchEvent.allowEmergencyWithdraw() is called which enters emergency / paused mode and disallows normal withdrawals.\n*   Users can only call LaunchEvent.emergencyWithdraw which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.\n\n",
                "Repair": "\nConsider paying out LP tokens in emergencyWithdraw.\n\ncryptofish7 (Trader Joe) confirmed and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/199#issuecomment-1035418911):\n  Fix: https://github.com/traderjoe-xyz/rocket-joe/pull/99\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n// @audit should be wavaxReserve * 1e18 / floorPrice\ntokenAllocated = (wavaxReserve * 10token.decimals()) / floorPrice;\n"
                ],
                "Type": " Wrong token allocation computation for token decimals != 18 if floor price not reached",
                "Description": "\nIn LaunchEvent.createPair, when the floor price is not reached (floorPrice  wavaxReserve * 1e18 / tokenAllocated), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.\n\nNote that the floorPrice is supposed to have a precision of 18:\n\n /// @param _floorPrice Price of each token in AVAX, scaled to 1e18\n\nThe floorPrice  (wavaxReserve * 1e18) / tokenAllocated check is correct but the tokenAllocated computation involves the token decimals:\n\nsolidity\n// @audit should be wavaxReserve * 1e18 / floorPrice\ntokenAllocated = (wavaxReserve * 10token.decimals()) / floorPrice;\n\n\nThis computation does not work for tokens that don't have 18 decimals.\n\n\nAssume I want to sell 1.0 wBTC = 1e8 wBTC (8 decimals) at 2,000.0 AVAX = 2,000 * 1e18 AVAX.\nThe floorPrice is 2000e18 * 1e18 / 1e8 = 2e31\n\nAssume the Launch event only raised 1,000.0 AVAX half of the floor price for the issued token amount of 1.0 WBTC (it should therefore allocate only half a WBTC) and the token amount will be reduced as: floorPrice = 2e31  1000e18 * 1e18 / 1e8 = 1e31 = actualPrice.\nThen, tokenAllocated = 1000e18 * 1e8 / 2e31 = 1e29 / 2e31 = 0 and no tokens would be allocated, instead of 0.5 WBTC = 0.5e8 WBTC.\n\nThe computation should be tokenAllocated = wavaxReserve * 1e18 / floorPrice = 1000e18 * 1e18 / 2e31 = 1e39 / 2e31 = 10e38 / 2e31 = 5e7 = 0.5e8.\n\n",
                "Repair": "\nThe new tokenAllocated computation should be tokenAllocated = wavaxReserve * 1e18 / floorPrice;.\n\ncryptofish7 (Trader Joe) confirmed and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/193#issuecomment-1035433466):\n  Fix: https://github.com/traderjoe-xyz/rocket-joe/pull/76\n\n\n\n*\n\n \n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "withdrawIncentives()",
                    "withdrawLiquidity()",
                    "pair",
                    "createPair()",
                    "totalSupply"
                ],
                "Type": " Owner of LaunchEvent token has the ability to DOS attack the event",
                "Description": "\nThe owner of the token for which the LaunchEvent was created, has the ability to DOS attack the event. They can prevent the LaunchEvent from creating a JoePair which in turn limits the access to the following two functions: withdrawLiquidity() & withdrawIncentives(). Thus, stopping anybody from withdrawing their LP tokens.\n\nThe owner of the RocketJoe platform has the ability to enable the emergency withdrawal allowing the depositors to take back their AVAX. But, they lose their burned rJOE tokens and the gas fees.\n\nThe dev team might use this attack vector if they think the price of their token is too low. In that case, they can DOS attack the LaunchEvent. If the RocketJoe owner enables the emergency withdrawal, the dev team is able to take back their initial deposit. Thus, they don't lose anything but their reputation.\n\n\nWhen createPair() is called, the function checks whether a pair already exists. If it does, the transaction is reverted: <https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L382-L389\n\nAnybody is able to create a new JoePair using the existing TraderJoe contracts. If someone owns both AVAX and the LaunchEvent token, they are able to create a new pair and deposit a small amount of liquidity. Thus, the totalSupply will be  0. Meaning, at that point, the call to createPair() fails. Per design, the LaunchEvent will be used to issue a token to the public market. So only the dev team and its trusted parties have access to the necessary tokens to create a pair and provide liquidity.\n\n<https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/traderjoe/JoeFactory.sol#L30\n\n<https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/traderjoe/JoePair.sol#L133\n\nSince createPair() can't be executed the pair state variable is never initialized: <https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L422\n\nThus, the following two functions are not reachable any more: <https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L439\n\n<https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L469\n\nIf the emergency withdrawal is enabled, the token issuer can take back their deposit: <https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L510-L516\n\n",
                "Repair": "\nIf a LaunchEvent for a token has started, only the LaunchEvent contract should be able to create a JoePair for that token. But, this change has to be made to the contracts that are not in the scope of this audit. I don't think there's a possibility to fix this issue within the RocketJoe contracts.\n\ncryptofish7 (Trader Joe) acknowledged(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/121)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction _safeTransferAVAX(address _to, uint256 _value) internal {\n    (bool success, ) = _to.call{value: _value}(new bytes(0));\n    require(success, \"LaunchEvent: avax transfer failed\");\n}\n"
                ],
                "Type": " Failed transfer with low level call could be overlooked",
                "Description": "\nIn LaunchEvent.sol, the function _safeTransferAVAX is as follows:\nsolidity\nfunction _safeTransferAVAX(address _to, uint256 _value) internal {\n    (bool success, ) = _to.call{value: _value}(new bytes(0));\n    require(success, \"LaunchEvent: avax transfer failed\");\n}\n\n\nThis function is utilized in a few different places in the contract. According to the Solidity docs(https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions)), \"The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed\".\n\nAs a result, it is possible that this call will fail, but _safeTransferAVAX will not notice anything went wrong. In particular, it is possible that the address rocketJoeFactory.penaltyCollector() is a deleted contract (perhaps a security flaw was found and selfdestruct was called so that users know to use an updated smart contract), but _safeTransferAVAX will not revert. If rocketJoeFactory.penaltyCollector() is indeed a non-existent contract, it would be better for _safeTransferAVAX to revert until an admin can manually correct the penaltyCollector in the factory.\n\nFor reference, see a similar high severity reported in a Uniswap audit here (report # 9): <https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf\n\n\nSee _safeTransferAVAX here(https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L620). See how this function is called with _to as rocketJoeFactory.penaltyCollector() here(https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L371), but this contract's existence is not verified, which is a problem as described above.\n\n",
                "Repair": "\nCheck for contract existence on low-level calls, so that failures are not missed.\n\ncryptofish7 (Trader Joe) acknowledged(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/170)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "allowEmergencyWithdraw()",
                    "WAVAX",
                    "true",
                    "stopped",
                    "isStopped(false)",
                    "token"
                ],
                "Type": " LP Tokens May Be Locked in Contract Due to  allowEmergencyWithdraw()  in Stage 3",
                "Description": "\nThe function allowEmergencyWithdraw()(https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L520) may be called by the rocketJoeFactory.owner() at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.\n\n\nIf allowEmergencyWithdraw()  is called stopped is set to true. As a result functions withdrawIncentives()(https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L468) and withdrawLiquidity()(https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L438) will revert due to the isStopped(false) modifier reverting.\n\nAdditionally, emergencyWithdraw()(https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L494) will revert since all the WAVAX and token balances have been transferred to the liquidity pool.\n\nThus, depositors and issuers will have no methods of removing their LP tokens or incentives.\n\n",
                "Repair": "\nConsider adding the requirement require(address(pair) != address(0), \"LaunchEvent: pair not created\"); to the function allowEmergencyWithdraw().\n\ncryptofish7 (Trader Joe) confirmed and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/169#issuecomment-1026365132):\n  To fix, we allow withdrawal of LP in emergencyWithdraw(): https://github.com/traderjoe-xyz/rocket-joe/commit/8a93c43e9972a2cf7c8ee04ccf263a405ecfcecc\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [
                    "createPair()"
                ],
                "Type": "  createPair()  expects zero slippage",
                "Description": "\nThe LaunchEvent.sol createPair() function calls router.addLiquidity() with a amountADesired == amountAMin and amountBDesired == amountBMin. Because there is no allowance for slippage, if the zero slippage requirement is not met then the addLiquidity() function will revert(https://github.com/traderjoe-xyz/joe-core/blob/5c2ca96c3835e7f2660f2904a1224bb7c8f3b7a7/contracts/traderjoe/JoeRouter02.sol#L52-L57) and prevent users from using the createPair() function. This could be caused either by frontrunning the createPair call or in a situation where the liquidity pool exists but does not allow for zero slippage with the assets it is holding.\n\n\nThe zero slippage addLiquidity call is found in LaunchEvent.sol(https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L411). This code may have been written with the assumption that only Rocket Joe will have a balance of the new token, so no other user could call the addLiquidity function with both assets, since the whitepaper states \"Rocket Joe liquidity launch will complete before launchpad public sale release any tokens to the public\". However, the new token contract should be considered untrusted and Rocket Joe cannot guarantee where all the new tokens are before phase 3 of the Rocket Joe launch event, which is when createPair() is called. The token creator who has control over the token allocation is not controlled by Trader Joe, so an attacker who has early access to the new token can break the outlined assumptions.\n\n",
                "Repair": "\nConsider how the launch event functions may break if the new token is launched by an attacker who doesn't follow the assumptions outlined. One solution for this createPair() issue is to add an input parameter to the function to handle a slippage allowance.\n\ncryptofish7 (Trader Joe) acknowledged(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/146)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-12",
                "Location": [
                    "//solidity\nfunction createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n    (address wavaxAddress, address tokenAddress) = (\n        address(WAVAX),\n        address(token)\n    );\n    // @audit grief: anyone can create pair\n    require(\n        factory.getPair(wavaxAddress, tokenAddress) == address(0),\n        \"LaunchEvent: pair already created\"\n    );\n\n    // ...\n}\n"
                ],
                "Type": " Pair creation can be denied",
                "Description": "\nThe LaunchEvent.createPair requires that no previous pool was created for the WAVAX < _token pair.\n\nsolidity\nfunction createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n    (address wavaxAddress, address tokenAddress) = (\n        address(WAVAX),\n        address(token)\n    );\n    // @audit grief: anyone can create pair\n    require(\n        factory.getPair(wavaxAddress, tokenAddress) == address(0),\n        \"LaunchEvent: pair already created\"\n    );\n\n    // ...\n}\n\n\nA griefer can create a pool for the WAVAX < _token pair by calling JoeFactory.createPair(WAVAX, _token)(https://snowtrace.io/address/0x9ad6c38be94206ca50bb0d90783181662f0cfa10#contracts) while the launch event phase 1 or 2 is running.\nNo liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.\n\n",
                "Repair": "\nIt must be assumed that the pool is already created and even initialized as pool creation and liquidity provisioning is permissionless.\nSpecial attention must be paid if the pool is already initialized with liquidity at a different price than the launch event price.\n\nIt would be enough to have a standard min. LP return \"slippage\" check (using parameter values for amountAMin/amountBMin instead of the hardcoded ones in router.addLiquidity) in LaunchEvent.createPair().\nThe function must then be callable with special privileges only, for example, by the issuer.\nAlternatively, the slippage check can be hardcoded as a percentage of the raised amounts (amountADesired = 0.95 * wavaxReserve, amountBDesired = 0.95 * tokenAllocated).\n\nThis will prevent attacks that try to provide LP at a bad pool price as the transaction will revert when receiving less than the slippage parameter.\nIf the pool is already initialized, it should just get arbitraged to the auction token price and liquidity can then be provided at the expected rate again.\n\ncryptofish7 (Trader Joe) confirmed, but disagreed with High severity and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/197#issuecomment-1035423645):\n  Fix: https://github.com/traderjoe-xyz/rocket-joe/pull/81\n \n \n Should be 2 (Medium).\n\nLSDan (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/197#issuecomment-1047839788):\n  This issue would not put assets at risk. but would impact the availability of the protocol for certain pairs.\n \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "false",
                    "ERC"
                ],
                "Type": " ERC20 return values not checked",
                "Description": "\nThe ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success. This parameter needs to be checked for success.\nSome tokens do not revert if the transfer failed but return false instead.\nTokens that don't actually perform the transfer and return false are still counted as a correct transfer.\n\n",
                "Repair": "\nAs the Launch event token can be any token, all interactions with it should follow correct EIP20 checks.\nWe recommend checking the success boolean of all .transfer and .transferFrom calls for the unknown token contract.\n\n*   LaunchEvent.withdrawLiquidity: token.transfer(msg.sender, amount);\n*   LaunchEvent.withdrawIncentives: token.transfer(msg.sender, amount);\n*   LaunchEvent.emergencyWithdraw: token.transfer(msg.sender, amount);\n*   LaunchEvent.skim: token.transfer(msg.sender, amount);\n*   RocketJoeFactory.createRJLaunchEvent: IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);\n\ncryptofish7 (Trader Joe) confirmed and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/198):\n  Fix: https://github.com/traderjoe-xyz/rocket-joe/commit/dbd19cc4\n\nLSDan (judge) commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/198#issuecomment-1048134672):\n  Given external factors, this could result in a loss of funds.\n \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./RocketJoeToken.sol\";\n\n/// @title Rocket Joe Staking\n/// @author Trader Joe\n/// @notice Stake JOE to earn rJOE\ncontract RocketJoeStaking is Initializable, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct UserInfo {\n        uint256 amount; // How many JOE tokens the user has provided\n        uint256 rewardDebt; // Reward debt. See explanation below\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of JOEs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * accRJoePerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. `accRJoePerShare` (and `lastRewardTimestamp`) gets updated\n        //   2. User receives the pending reward sent to his/her address\n        //   3. User's `amount` gets updated\n        //   4. User's `rewardDebt` gets updated\n    }\n\n    IERC20Upgradeable public joe;\n    uint256 public lastRewardTimestamp;\n\n    /// @dev Accumulated rJOE per share, times PRECISION. See above\n    uint256 public accRJoePerShare;\n    /// @notice Precision of accRJoePerShare\n    uint256 private PRECISION;\n\n    RocketJoeToken public rJoe;\n    uint256 public rJoePerSec;\n\n    /// @dev Info of each user that stakes LP tokens\n    mapping(address => UserInfo) public userInfo;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);\n\n    /// @notice Initialize with needed parameters\n    /// @param _joe Address of the JOE token contract\n    /// @param _rJoe Address of the rJOE token contract\n    /// @param _rJoePerSec Number of rJOE tokens created per second\n    /// @param _startTime Timestamp at which rJOE rewards starts\n    function initialize(\n        IERC20Upgradeable _joe,\n        RocketJoeToken _rJoe,\n        uint256 _rJoePerSec,\n        uint256 _startTime\n    ) public initializer {\n        __Ownable_init();\n\n        require(\n            _startTime > block.timestamp,\n            \"RocketJoeStaking: rJOE minting needs to start after the current timestamp\"\n        );\n\n        PRECISION = 1e18;\n\n        joe = _joe;\n        rJoe = _rJoe;\n        rJoePerSec = _rJoePerSec;\n        lastRewardTimestamp = _startTime;\n    }\n\n    /// @notice Get pending rJoe for a given `_user`\n    /// @param _user The user to lookup\n    /// @return The number of pending rJOE tokens for `_user`\n    function pendingRJoe(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 joeSupply = joe.balanceOf(address(this));\n        uint256 _accRJoePerShare = accRJoePerShare;\n\n        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {\n            uint256 multiplier = block.timestamp - lastRewardTimestamp;\n            uint256 rJoeReward = multiplier * rJoePerSec;\n            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;\n        }\n        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;\n    }\n\n    /// @notice Deposit joe to RocketJoeStaking for rJoe allocation\n    /// @param _amount Amount of JOE to deposit\n    function deposit(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n\n        updatePool();\n\n        if (user.amount > 0) {\n            uint256 pending = (user.amount * accRJoePerShare) /\n                PRECISION -\n                user.rewardDebt;\n            _safeRJoeTransfer(msg.sender, pending);\n        }\n        user.amount = user.amount + _amount;\n        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n        joe.safeTransferFrom(address(msg.sender), address(this), _amount);\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw JOE and accumulated rJOE from RocketJoeStaking\n    /// @param _amount Amount of JOE to withdraw\n    function withdraw(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n        require(\n            user.amount >= _amount,\n            \"RocketJoeStaking: withdraw amount exceeds balance\"\n        );\n\n        updatePool();\n\n        uint256 pending = (user.amount * accRJoePerShare) /\n            PRECISION -\n            user.rewardDebt;\n\n        user.amount = user.amount - _amount;\n        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n        _safeRJoeTransfer(msg.sender, pending);\n        joe.safeTransfer(address(msg.sender), _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY\n    function emergencyWithdraw() external {\n        UserInfo storage user = userInfo[msg.sender];\n\n        uint256 _amount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        joe.safeTransfer(address(msg.sender), _amount);\n        emit EmergencyWithdraw(msg.sender, _amount);\n    }\n\n    /// @notice Update emission rate\n    /// @param _rJoePerSec The new value for rJoePerSec\n    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {\n        updatePool();\n        rJoePerSec = _rJoePerSec;\n        emit UpdateEmissionRate(msg.sender, _rJoePerSec);\n    }\n\n    /// @notice Update reward variables of the given pool with latest data\n    function updatePool() public {\n        if (block.timestamp <= lastRewardTimestamp) {\n            return;\n        }\n        uint256 joeSupply = joe.balanceOf(address(this));\n        if (joeSupply == 0) {\n            lastRewardTimestamp = block.timestamp;\n            return;\n        }\n        uint256 multiplier = block.timestamp - lastRewardTimestamp;\n        uint256 rJoeReward = multiplier * rJoePerSec;\n        accRJoePerShare =\n            accRJoePerShare +\n            (rJoeReward * PRECISION) /\n            joeSupply;\n        lastRewardTimestamp = block.timestamp;\n\n        rJoe.mint(address(this), rJoeReward);\n    }\n\n    /// @notice Safe rJoe transfer function, just in case if rounding error causes pool to not have enough JOEs\n    /// @param _to Address that wil receive rJoe\n    /// @param _amount The amount to send\n    function _safeRJoeTransfer(address _to, uint256 _amount) internal {\n        uint256 rJoeBal = rJoe.balanceOf(address(this));\n        if (_amount > rJoeBal) {\n            rJoe.transfer(_to, rJoeBal);\n        } else {\n            rJoe.transfer(_to, _amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "RocketJoeStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {\n    updatePool();\n    rJoePerSec = _rJoePerSec;\n    emit UpdateEmissionRate(msg.sender, _rJoePerSec);\n}\n"
                ],
                "Type": " Improper Upper Bound Definition on the Fee",
                "Description": "\nThe rJoePerSec does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.\n\n\n<https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L151\nsolidity\nfunction updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {\n    updatePool();\n    rJoePerSec = _rJoePerSec;\n    emit UpdateEmissionRate(msg.sender, _rJoePerSec);\n}\n\n\n\nRemix\n\n",
                "Repair": "\nConsider define  upper and lower bounds on the _rJoePerSec.\n\ncryptofish7 (Trader Joe) confirmed, but disagreed with severity and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/255#issuecomment-1026262137):\n  Confirming issue but disagree with severity.\n \n Fix: https://github.com/traderjoe-xyz/rocket-joe/pull/112\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\n// Copyright (c) 2022 Trader Joe - All rights reserved\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/ILaunchEvent.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\n\n/// @title Rocket Joe Factory\n/// @author Trader Joe\n/// @notice Factory that creates Rocket Joe events\ncontract RocketJoeFactory is IRocketJoeFactory, Ownable {\n    address public override penaltyCollector;\n    address public override eventImplementation;\n\n    address public override rJoe;\n    uint256 public override rJoePerAvax;\n    address public override wavax;\n    address public override router;\n    address public override factory;\n\n    uint256 public override PHASE_ONE_DURATION = 2 days;\n    uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days;\n    uint256 public override PHASE_TWO_DURATION = 1 days;\n\n    mapping(address => address) public override getRJLaunchEvent;\n    mapping(address => bool) public override isRJLaunchEvent;\n    address[] public override allRJLaunchEvents;\n\n    /// @notice Creates the launch event factory\n    /// @dev Uses clone factory pattern to save space\n    /// @param _eventImplementation Implementation of launch event contract\n    /// @param _rJoe rJOE token address\n    /// @param _wavax WAVAX token address\n    /// @param _penaltyCollector Address that collects all withdrawal penalties\n    /// @param _router Router used to create LP on Trader Joe AMM\n    /// @param _factory Factory used to get info of JoePairs\n    constructor(\n        address _eventImplementation,\n        address _rJoe,\n        address _wavax,\n        address _penaltyCollector,\n        address _router,\n        address _factory\n    ) {\n        require(\n            _eventImplementation != address(0) &&\n                _rJoe != address(0) &&\n                _wavax != address(0) &&\n                _penaltyCollector != address(0) &&\n                _router != address(0) &&\n                _factory != address(0),\n            \"RJFactory: Addresses can't be null address\"\n        );\n        IRocketJoeToken(_rJoe).initialize();\n\n        eventImplementation = _eventImplementation;\n        rJoe = _rJoe;\n\n        wavax = _wavax;\n        penaltyCollector = _penaltyCollector;\n        router = _router;\n        factory = _factory;\n        rJoePerAvax = 100;\n    }\n\n    /// @notice Returns the number of launch events\n    /// @return The number of launch events ever created\n    function numLaunchEvents() external view override returns (uint256) {\n        return allRJLaunchEvents.length;\n    }\n\n    /// @notice Creates a launch event contract\n    /// @param _issuer Address of the project issuing tokens for auction\n    /// @param _phaseOneStartTime Timestamp of when launch event will start\n    /// @param _token Token that will be issued through this launch event\n    /// @param _tokenAmount Amount of tokens that will be issued\n    /// @param _tokenIncentivesPercent Additional tokens that will be given as\n    /// incentive for locking up LPs during phase 3 expressed as a percentage\n    /// of the issuing tokens for sale, scaled to 1e18\n    /// @param _floorPrice Price of each token in AVAX, scaled to 1e18\n    /// @param _maxWithdrawPenalty Maximum withdrawal penalty that can be met\n    /// during phase 1\n    /// @param _fixedWithdrawPenalty Withdrawal penalty during phase 2\n    /// @param _maxAllocation Maximum number of AVAX each participant can commit\n    /// @param _userTimelock Amount of time users' LPs will be locked for\n    /// during phase 3\n    /// @param _issuerTimelock Amount of time issuer's LP will be locked for\n    /// during phase 3\n    /// @return Address of launch event contract\n    function createRJLaunchEvent(\n        address _issuer,\n        uint256 _phaseOneStartTime,\n        address _token,\n        uint256 _tokenAmount,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external override returns (address) {\n        require(\n            getRJLaunchEvent[_token] == address(0),\n            \"RJFactory: token has already been issued\"\n        );\n        require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");\n        require(_token != address(0), \"RJFactory: token can't be 0 address\");\n        require(_token != wavax, \"RJFactory: token can't be wavax\");\n        require(\n            _tokenAmount > 0,\n            \"RJFactory: token amount needs to be greater than 0\"\n        );\n        require(\n            IJoeFactory(factory).getPair(_token, wavax) == address(0) ||\n                IJoePair(IJoeFactory(factory).getPair(_token, wavax))\n                    .totalSupply() ==\n                0,\n            \"RJFactory: liquid pair already exists\"\n        );\n\n        address launchEvent = Clones.clone(eventImplementation);\n\n        // msg.sender needs to approve RocketJoeFactory\n        IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);\n\n        ILaunchEvent(payable(launchEvent)).initialize(\n            _issuer,\n            _phaseOneStartTime,\n            _token,\n            _tokenIncentivesPercent,\n            _floorPrice,\n            _maxWithdrawPenalty,\n            _fixedWithdrawPenalty,\n            _maxAllocation,\n            _userTimelock,\n            _issuerTimelock\n        );\n\n        getRJLaunchEvent[_token] = launchEvent;\n        isRJLaunchEvent[launchEvent] = true;\n        allRJLaunchEvents.push(launchEvent);\n\n        _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);\n\n        return launchEvent;\n    }\n\n    /// @notice Set rJOE address\n    /// @param _rJoe New rJOE address\n    function setRJoe(address _rJoe) external override onlyOwner {\n        IRocketJoeToken(_rJoe).initialize();\n        rJoe = _rJoe;\n        emit SetRJoe(_rJoe);\n    }\n\n    /// @notice Set address to collect withdrawal penalties\n    /// @param _penaltyCollector New penalty collector address\n    function setPenaltyCollector(address _penaltyCollector)\n        external\n        override\n        onlyOwner\n    {\n        penaltyCollector = _penaltyCollector;\n        emit SetPenaltyCollector(_penaltyCollector);\n    }\n\n    /// @notice Set JoeRouter address\n    /// @param _router New router address\n    function setRouter(address _router) external override onlyOwner {\n        router = _router;\n        emit SetRouter(_router);\n    }\n\n    /// @notice Set JoeFactory address\n    /// @param _factory New factory address\n    function setFactory(address _factory) external override onlyOwner {\n        factory = _factory;\n        emit SetFactory(_factory);\n    }\n\n    /// @notice Set amount of rJOE required to deposit 1 AVAX into launch event\n    /// @dev Configured by team between launch events to control inflation\n    function setRJoePerAvax(uint256 _rJoePerAvax) external override onlyOwner {\n        rJoePerAvax = _rJoePerAvax;\n        emit SetRJoePerAvax(_rJoePerAvax);\n    }\n\n    /// @notice Set duration of each of the three phases\n    /// @param _phaseNumber Can be only 1 or 2\n    /// @param _duration Duration of phase in seconds\n    function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)\n        external\n        override\n        onlyOwner\n    {\n        if (_phaseNumber == 1) {\n            require(\n                _duration > PHASE_ONE_NO_FEE_DURATION,\n                \"RJFactory: phase one duration lower than no fee duration\"\n            );\n            PHASE_ONE_DURATION = _duration;\n        } else if (_phaseNumber == 2) {\n            PHASE_TWO_DURATION = _duration;\n        }\n    }\n\n    /// @notice Set the no fee duration of phase 1\n    /// @param _noFeeDuration Duration of no fee phase\n    function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _noFeeDuration < PHASE_ONE_DURATION,\n            \"RJFactory: no fee duration bigger than phase one duration\"\n        );\n        PHASE_ONE_NO_FEE_DURATION = _noFeeDuration;\n    }\n\n    /// @dev This function emits an event after a new launch event has been created\n    /// It is only seperated out due to `createRJLaunchEvent` having too many local variables\n    function _emitLaunchedEvent(\n        address _issuer,\n        address _token,\n        uint256 _phaseOneStartTime\n    ) internal {\n        uint256 _phaseTwoStartTime = _phaseOneStartTime + PHASE_ONE_DURATION;\n        uint256 _phaseThreeStartTime = _phaseTwoStartTime + PHASE_TWO_DURATION;\n\n        emit RJLaunchEventCreated(\n            _issuer,\n            _token,\n            _phaseOneStartTime,\n            _phaseTwoStartTime,\n            _phaseThreeStartTime,\n            rJoe,\n            rJoePerAvax\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: None\n// Copyright (c) 2022 Trader Joe - All rights reserved\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent is Ownable {\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public PHASE_ONE_DURATION;\n    uint256 public PHASE_ONE_NO_FEE_DURATION;\n    uint256 public PHASE_TWO_DURATION;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20Metadata public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool private initialized;\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of wavax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 private wavaxAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev wavaxReserve is the exact amount of WAVAX that needs to be kept inside the contract in order to send everyone's\n    /// WAVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private wavaxReserve;\n\n    event IssuingTokenDeposited(address indexed token, uint256 amount);\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(address indexed user, uint256 avaxAmount);\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Receive AVAX from the WAVAX contract\n    /// @dev Needed for withdrawing from WAVAX contract\n    receive() external payable {\n        require(\n            msg.sender == address(WAVAX),\n            \"LaunchEvent: you can't send AVAX directly to this contract\"\n        );\n    }\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        uint256 phase3Start = auctionStart +\n            PHASE_ONE_DURATION +\n            PHASE_TWO_DURATION;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n        _;\n    }\n\n    /// @notice Initialise the launch event with needed paramaters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(!initialized, \"LaunchEvent: already initialized\");\n\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();\n        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();\n        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();\n\n        token = IERC20Metadata(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n        initialized = true;\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (block.timestamp < auctionStart || auctionStart == 0) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp <\n            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    /// @dev Checks are done in the `_depositWAVAX` function\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Burn tokens and update allocation.\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        wavaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        WAVAX.deposit{value: msg.value}();\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) public isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        wavaxReserve -= _amount;\n\n        WAVAX.withdraw(_amount);\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        require(\n            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||\n                IJoePair(\n                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)\n                ).totalSupply() ==\n                0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(wavaxReserve > 0, \"LaunchEvent: no wavax balance\");\n\n        uint256 tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (\n            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated\n        ) {\n            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        WAVAX.approve(address(router), wavaxReserve);\n        token.approve(address(router), tokenAllocated);\n\n        /// We can't trust the output cause of reflect tokens\n        (, , lpSupply) = router.addLiquidity(\n            wavaxAddress, // tokenA\n            tokenAddress, // tokenB\n            wavaxReserve, // amountADesired\n            tokenAllocated, // amountBDesired\n            wavaxReserve, // amountAMin\n            tokenAllocated, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));\n        wavaxAllocated = wavaxReserve;\n        wavaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            wavaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnPair,\n            \"LaunchEvent: liquidity already withdrawn\"\n        );\n\n        uint256 balance = pairBalance(msg.sender);\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            balance = lpSupply / 2;\n\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n\n            if (tokenReserve > 0) {\n                uint256 amount = tokenReserve;\n                tokenReserve = 0;\n                token.transfer(msg.sender, amount);\n            }\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external isStopped(false) {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnIncentives,\n            \"LaunchEvent: incentives already withdrawn\"\n        );\n\n        user.hasWithdrawnIncentives = true;\n        uint256 amount;\n\n        if (msg.sender == issuer) {\n            amount = tokenIncentiveIssuerRefund;\n        } else {\n            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;\n        }\n\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        tokenIncentivesBalance -= amount;\n\n        token.transfer(msg.sender, amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (msg.sender != issuer) {\n            UserInfo storage user = getUserInfo[msg.sender];\n            require(\n                user.balance > 0,\n                \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n            );\n\n            uint256 balance = user.balance;\n            user.balance = 0;\n            wavaxReserve -= balance;\n            WAVAX.withdraw(balance);\n\n            _safeTransferAVAX(msg.sender, balance);\n\n            emit AvaxEmergencyWithdraw(msg.sender, balance);\n        } else {\n            uint256 balance = tokenReserve + tokenIncentivesBalance;\n            tokenReserve = 0;\n            tokenIncentivesBalance = 0;\n            token.transfer(issuer, balance);\n            emit TokenEmergencyWithdraw(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.transfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;\n        if (excessWavax > 0) {\n            WAVAX.transfer(penaltyCollector, excessWavax);\n        }\n\n        uint256 excessAvax = address(this).balance;\n        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {\n            return 0;\n        } else if (timeElapsed < PHASE_ONE_DURATION) {\n            return\n                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *\n                    maxWithdrawPenalty) /\n                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the current balance of the pool\n    /// @return The balances of WAVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return _avaxAmount * rJoePerAvax;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        return (user.balance * lpSupply) / wavaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier.\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        if (_phase == Phase.NotStarted) {\n            require(\n                currentPhase() == Phase.NotStarted,\n                \"LaunchEvent: not in not started\"\n            );\n        } else if (_phase == Phase.PhaseOne) {\n            require(\n                currentPhase() == Phase.PhaseOne,\n                \"LaunchEvent: not in phase one\"\n            );\n        } else if (_phase == Phase.PhaseTwo) {\n            require(\n                currentPhase() == Phase.PhaseTwo,\n                \"LaunchEvent: not in phase two\"\n            );\n        } else if (_phase == Phase.PhaseThree) {\n            require(\n                currentPhase() == Phase.PhaseThree,\n                \"LaunchEvent: not in phase three\"\n            );\n        } else {\n            revert(\"LaunchEvent: unknown state\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "RocketJoeFactory.sol",
            "LaunchEvent.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nfunction createRJLaunchEvent(\n    address _issuer,\n    uint256 _phaseOneStartTime,\n    address _token,\n    uint256 _tokenAmount,\n    uint256 _tokenIncentivesPercent,\n    uint256 _floorPrice,\n    uint256 _maxWithdrawPenalty,\n    uint256 _fixedWithdrawPenalty,\n    uint256 _maxAllocation,\n    uint256 _userTimelock,\n    uint256 _issuerTimelock\n) external override returns (address) {\n    require(\n        getRJLaunchEvent[_token] == address(0),\n        \"RJFactory: token has already been issued\"\n    );\n    require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");\n    require(_token != address(0), \"RJFactory: token can't be 0 address\");\n    require(_token != wavax, \"RJFactory: token can't be wavax\");\n    require(\n        _tokenAmount  0,\n        \"RJFactory: token amount needs to be greater than 0\"\n    );\n    require(\n        IJoeFactory(factory).getPair(_token, wavax) == address(0) ||\n            IJoePair(IJoeFactory(factory).getPair(_token, wavax))\n                .totalSupply() ==\n            0,\n        \"RJFactory: liquid pair already exists\"\n    );\n\n    address launchEvent = Clones.clone(eventImplementation);\n\n    // msg.sender needs to approve RocketJoeFactory\n    IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);\n"
                ],
                "Type": "  createRJLaunchEvent()  can be called by anyone with 1 Wei of  _token  and stop others from creating RJLaunchEvent with the same token anymore",
                "Description": "\n<https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L132\n\nsolidity\nfunction createRJLaunchEvent(\n    address _issuer,\n    uint256 _phaseOneStartTime,\n    address _token,\n    uint256 _tokenAmount,\n    uint256 _tokenIncentivesPercent,\n    uint256 _floorPrice,\n    uint256 _maxWithdrawPenalty,\n    uint256 _fixedWithdrawPenalty,\n    uint256 _maxAllocation,\n    uint256 _userTimelock,\n    uint256 _issuerTimelock\n) external override returns (address) {\n    require(\n        getRJLaunchEvent[_token] == address(0),\n        \"RJFactory: token has already been issued\"\n    );\n    require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");\n    require(_token != address(0), \"RJFactory: token can't be 0 address\");\n    require(_token != wavax, \"RJFactory: token can't be wavax\");\n    require(\n        _tokenAmount  0,\n        \"RJFactory: token amount needs to be greater than 0\"\n    );\n    require(\n        IJoeFactory(factory).getPair(_token, wavax) == address(0) ||\n            IJoePair(IJoeFactory(factory).getPair(_token, wavax))\n                .totalSupply() ==\n            0,\n        \"RJFactory: liquid pair already exists\"\n    );\n\n    address launchEvent = Clones.clone(eventImplementation);\n\n    // msg.sender needs to approve RocketJoeFactory\n    IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);\n\n\nIn the current implementation, RocketJoeFactory.sol#createRJLaunchEvent() can be called by anyone with at least 1 Wei of _token.\n\nThis allows a malicious user or attacker to call createRJLaunchEvent() with minimal cost and stop others, especially the platform itself or the rightful issuer of the token from creating the RJLaunchEvent.\n\n",
                "Repair": "\nConsider making createRJLaunchEvent() only callable by the owner of RocketJoeFactory.\n\ncryptofish7 (Trader Joe) acknowledged and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/247#issuecomment-1034972822):\n  That\u2019s the spirit, not a single token should be in circulation.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: None\n// Copyright (c) 2022 Trader Joe - All rights reserved\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent is Ownable {\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public PHASE_ONE_DURATION;\n    uint256 public PHASE_ONE_NO_FEE_DURATION;\n    uint256 public PHASE_TWO_DURATION;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20Metadata public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool private initialized;\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of wavax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 private wavaxAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev wavaxReserve is the exact amount of WAVAX that needs to be kept inside the contract in order to send everyone's\n    /// WAVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private wavaxReserve;\n\n    event IssuingTokenDeposited(address indexed token, uint256 amount);\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(address indexed user, uint256 avaxAmount);\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Receive AVAX from the WAVAX contract\n    /// @dev Needed for withdrawing from WAVAX contract\n    receive() external payable {\n        require(\n            msg.sender == address(WAVAX),\n            \"LaunchEvent: you can't send AVAX directly to this contract\"\n        );\n    }\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        uint256 phase3Start = auctionStart +\n            PHASE_ONE_DURATION +\n            PHASE_TWO_DURATION;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n        _;\n    }\n\n    /// @notice Initialise the launch event with needed paramaters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(!initialized, \"LaunchEvent: already initialized\");\n\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();\n        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();\n        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();\n\n        token = IERC20Metadata(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n        initialized = true;\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (block.timestamp < auctionStart || auctionStart == 0) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp <\n            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    /// @dev Checks are done in the `_depositWAVAX` function\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Burn tokens and update allocation.\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        wavaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        WAVAX.deposit{value: msg.value}();\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) public isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        wavaxReserve -= _amount;\n\n        WAVAX.withdraw(_amount);\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        require(\n            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||\n                IJoePair(\n                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)\n                ).totalSupply() ==\n                0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(wavaxReserve > 0, \"LaunchEvent: no wavax balance\");\n\n        uint256 tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (\n            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated\n        ) {\n            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        WAVAX.approve(address(router), wavaxReserve);\n        token.approve(address(router), tokenAllocated);\n\n        /// We can't trust the output cause of reflect tokens\n        (, , lpSupply) = router.addLiquidity(\n            wavaxAddress, // tokenA\n            tokenAddress, // tokenB\n            wavaxReserve, // amountADesired\n            tokenAllocated, // amountBDesired\n            wavaxReserve, // amountAMin\n            tokenAllocated, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));\n        wavaxAllocated = wavaxReserve;\n        wavaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            wavaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnPair,\n            \"LaunchEvent: liquidity already withdrawn\"\n        );\n\n        uint256 balance = pairBalance(msg.sender);\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            balance = lpSupply / 2;\n\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n\n            if (tokenReserve > 0) {\n                uint256 amount = tokenReserve;\n                tokenReserve = 0;\n                token.transfer(msg.sender, amount);\n            }\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external isStopped(false) {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnIncentives,\n            \"LaunchEvent: incentives already withdrawn\"\n        );\n\n        user.hasWithdrawnIncentives = true;\n        uint256 amount;\n\n        if (msg.sender == issuer) {\n            amount = tokenIncentiveIssuerRefund;\n        } else {\n            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;\n        }\n\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        tokenIncentivesBalance -= amount;\n\n        token.transfer(msg.sender, amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (msg.sender != issuer) {\n            UserInfo storage user = getUserInfo[msg.sender];\n            require(\n                user.balance > 0,\n                \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n            );\n\n            uint256 balance = user.balance;\n            user.balance = 0;\n            wavaxReserve -= balance;\n            WAVAX.withdraw(balance);\n\n            _safeTransferAVAX(msg.sender, balance);\n\n            emit AvaxEmergencyWithdraw(msg.sender, balance);\n        } else {\n            uint256 balance = tokenReserve + tokenIncentivesBalance;\n            tokenReserve = 0;\n            tokenIncentivesBalance = 0;\n            token.transfer(issuer, balance);\n            emit TokenEmergencyWithdraw(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.transfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;\n        if (excessWavax > 0) {\n            WAVAX.transfer(penaltyCollector, excessWavax);\n        }\n\n        uint256 excessAvax = address(this).balance;\n        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {\n            return 0;\n        } else if (timeElapsed < PHASE_ONE_DURATION) {\n            return\n                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *\n                    maxWithdrawPenalty) /\n                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the current balance of the pool\n    /// @return The balances of WAVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return _avaxAmount * rJoePerAvax;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        return (user.balance * lpSupply) / wavaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier.\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        if (_phase == Phase.NotStarted) {\n            require(\n                currentPhase() == Phase.NotStarted,\n                \"LaunchEvent: not in not started\"\n            );\n        } else if (_phase == Phase.PhaseOne) {\n            require(\n                currentPhase() == Phase.PhaseOne,\n                \"LaunchEvent: not in phase one\"\n            );\n        } else if (_phase == Phase.PhaseTwo) {\n            require(\n                currentPhase() == Phase.PhaseTwo,\n                \"LaunchEvent: not in phase two\"\n            );\n        } else if (_phase == Phase.PhaseThree) {\n            require(\n                currentPhase() == Phase.PhaseThree,\n                \"LaunchEvent: not in phase three\"\n            );\n        } else {\n            revert(\"LaunchEvent: unknown state\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n\n\n// SPDX-License-Identifier: None\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./RocketJoeToken.sol\";\n\n/// @title Rocket Joe Staking\n/// @author Trader Joe\n/// @notice Stake JOE to earn rJOE\ncontract RocketJoeStaking is Initializable, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct UserInfo {\n        uint256 amount; // How many JOE tokens the user has provided\n        uint256 rewardDebt; // Reward debt. See explanation below\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of JOEs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * accRJoePerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. `accRJoePerShare` (and `lastRewardTimestamp`) gets updated\n        //   2. User receives the pending reward sent to his/her address\n        //   3. User's `amount` gets updated\n        //   4. User's `rewardDebt` gets updated\n    }\n\n    IERC20Upgradeable public joe;\n    uint256 public lastRewardTimestamp;\n\n    /// @dev Accumulated rJOE per share, times PRECISION. See above\n    uint256 public accRJoePerShare;\n    /// @notice Precision of accRJoePerShare\n    uint256 private PRECISION;\n\n    RocketJoeToken public rJoe;\n    uint256 public rJoePerSec;\n\n    /// @dev Info of each user that stakes LP tokens\n    mapping(address => UserInfo) public userInfo;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);\n\n    /// @notice Initialize with needed parameters\n    /// @param _joe Address of the JOE token contract\n    /// @param _rJoe Address of the rJOE token contract\n    /// @param _rJoePerSec Number of rJOE tokens created per second\n    /// @param _startTime Timestamp at which rJOE rewards starts\n    function initialize(\n        IERC20Upgradeable _joe,\n        RocketJoeToken _rJoe,\n        uint256 _rJoePerSec,\n        uint256 _startTime\n    ) public initializer {\n        __Ownable_init();\n\n        require(\n            _startTime > block.timestamp,\n            \"RocketJoeStaking: rJOE minting needs to start after the current timestamp\"\n        );\n\n        PRECISION = 1e18;\n\n        joe = _joe;\n        rJoe = _rJoe;\n        rJoePerSec = _rJoePerSec;\n        lastRewardTimestamp = _startTime;\n    }\n\n    /// @notice Get pending rJoe for a given `_user`\n    /// @param _user The user to lookup\n    /// @return The number of pending rJOE tokens for `_user`\n    function pendingRJoe(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 joeSupply = joe.balanceOf(address(this));\n        uint256 _accRJoePerShare = accRJoePerShare;\n\n        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {\n            uint256 multiplier = block.timestamp - lastRewardTimestamp;\n            uint256 rJoeReward = multiplier * rJoePerSec;\n            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;\n        }\n        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;\n    }\n\n    /// @notice Deposit joe to RocketJoeStaking for rJoe allocation\n    /// @param _amount Amount of JOE to deposit\n    function deposit(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n\n        updatePool();\n\n        if (user.amount > 0) {\n            uint256 pending = (user.amount * accRJoePerShare) /\n                PRECISION -\n                user.rewardDebt;\n            _safeRJoeTransfer(msg.sender, pending);\n        }\n        user.amount = user.amount + _amount;\n        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n        joe.safeTransferFrom(address(msg.sender), address(this), _amount);\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw JOE and accumulated rJOE from RocketJoeStaking\n    /// @param _amount Amount of JOE to withdraw\n    function withdraw(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n        require(\n            user.amount >= _amount,\n            \"RocketJoeStaking: withdraw amount exceeds balance\"\n        );\n\n        updatePool();\n\n        uint256 pending = (user.amount * accRJoePerShare) /\n            PRECISION -\n            user.rewardDebt;\n\n        user.amount = user.amount - _amount;\n        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n        _safeRJoeTransfer(msg.sender, pending);\n        joe.safeTransfer(address(msg.sender), _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY\n    function emergencyWithdraw() external {\n        UserInfo storage user = userInfo[msg.sender];\n\n        uint256 _amount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        joe.safeTransfer(address(msg.sender), _amount);\n        emit EmergencyWithdraw(msg.sender, _amount);\n    }\n\n    /// @notice Update emission rate\n    /// @param _rJoePerSec The new value for rJoePerSec\n    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {\n        updatePool();\n        rJoePerSec = _rJoePerSec;\n        emit UpdateEmissionRate(msg.sender, _rJoePerSec);\n    }\n\n    /// @notice Update reward variables of the given pool with latest data\n    function updatePool() public {\n        if (block.timestamp <= lastRewardTimestamp) {\n            return;\n        }\n        uint256 joeSupply = joe.balanceOf(address(this));\n        if (joeSupply == 0) {\n            lastRewardTimestamp = block.timestamp;\n            return;\n        }\n        uint256 multiplier = block.timestamp - lastRewardTimestamp;\n        uint256 rJoeReward = multiplier * rJoePerSec;\n        accRJoePerShare =\n            accRJoePerShare +\n            (rJoeReward * PRECISION) /\n            joeSupply;\n        lastRewardTimestamp = block.timestamp;\n\n        rJoe.mint(address(this), rJoeReward);\n    }\n\n    /// @notice Safe rJoe transfer function, just in case if rounding error causes pool to not have enough JOEs\n    /// @param _to Address that wil receive rJoe\n    /// @param _amount The amount to send\n    function _safeRJoeTransfer(address _to, uint256 _amount) internal {\n        uint256 rJoeBal = rJoe.balanceOf(address(this));\n        if (_amount > rJoeBal) {\n            rJoe.transfer(_to, rJoeBal);\n        } else {\n            rJoe.transfer(_to, _amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "LaunchEvent.sol",
            "RocketJoeStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\nfunction updatePool() public {\n    if (block.timestamp <= lastRewardTimestamp) {\n        return;\n    }\n    uint256 joeSupply = joe.balanceOf(address(this));\n\n    // @audit lastRewardTimestamp is not initialized. can send 1 Joe to this contract directly = lots of rJoe minted to this contract\n    if (joeSupply == 0) {\n        lastRewardTimestamp = block.timestamp;\n        return;\n    }\n    uint256 multiplier = block.timestamp lastRewardTimestamp;\n    uint256 rJoeReward = multiplier * rJoePerSec;\n    accRJoePerShare =\n        accRJoePerShare +\n        (rJoeReward * PRECISION) /\n        joeSupply;\n    lastRewardTimestamp = block.timestamp;\n\n    rJoe.mint(address(this), rJoeReward);\n}\n"
                ],
                "Type": " Uninitialized  RocketJoeStaking.lastRewardTimestamp  can inflate  rJoe  supply",
                "Description": "\nThe RocketJoeStaking.lastRewardTimestamp is initialized to zero. Usually, this does not matter as updatePool is called before the first deposit and when joeSupply = joe.balanceOf(address(this)) == 0, it is set to the current time.\n\nsolidity\nfunction updatePool() public {\n    if (block.timestamp <= lastRewardTimestamp) {\n        return;\n    }\n    uint256 joeSupply = joe.balanceOf(address(this));\n\n    // @audit lastRewardTimestamp is not initialized. can send 1 Joe to this contract directly = lots of rJoe minted to this contract\n    if (joeSupply == 0) {\n        lastRewardTimestamp = block.timestamp;\n        return;\n    }\n    uint256 multiplier = block.timestamp lastRewardTimestamp;\n    uint256 rJoeReward = multiplier * rJoePerSec;\n    accRJoePerShare =\n        accRJoePerShare +\n        (rJoeReward * PRECISION) /\n        joeSupply;\n    lastRewardTimestamp = block.timestamp;\n\n    rJoe.mint(address(this), rJoeReward);\n}\n\n\nHowever, if a user first directly transfers Joe tokens to the contract before the first updatePool call, the block.timestamp lastRewardTimestamp = block.timestamp will be a large timestamp value and lots of rJoe will be minted (but not distributed to users).\nEven though they are not distributed to the users, inflating the rJoe total supply might not be desired.\n\n",
                "Repair": "\nConsider tracking the actual total deposits in a storage variable and using this value instead of the current balance for joeSupply.\nThis way, transferring tokens to the contract has no influence and depositing through deposit first calls updatePool and initializes lastRewardTimestamp.\n\ncryptofish7 (Trader Joe) confirmed and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/202#issuecomment-1035413421):\n  Fix: https://github.com/traderjoe-xyz/rocket-joe/pull/76\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-11",
                "Location": [
                    "//solidity\nif (user.amount  0) {\n    uint256 pending = (user.amount * accRJoePerShare) /\n        PRECISION -\n        user.rewardDebt;\n    _safeRJoeTransfer(msg.sender, pending);\n}\nuser.amount = user.amount + _amount;\nuser.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n"
                ],
                "Type": " Re-enterable Code When Making a Deposit to Stake",
                "Description": "\nNote: this attack requires rJoe to relinquish control during tranfer() which under the current RocketJoeToken(https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol) it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.\n\nThis vulnerability would allow the entire rJoe balance to be drained from the contract.\n\n\nThe function deposit()(https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L96) would be vulnerable to reentrancy if rJoe relinquished control flow.\n\nThe following lines show the reward calculations in variable pending. These calculations use two state variables user.amount and user.rewardDebt. Each of these are updated after _safeRJoeTransfer().\n\nThus if an attacker was able to get control flow during the rJoe::tranfer() function they would be able to reenter deposit() and the value calculated for pendingwould be the same as the previous iteration hence they would again be transferred pending rJoe tokens. During the rJoe transfer the would again gain control of the execution and call deposit() again. The process could be repeated until the entire rJoe balance of the contract has been transferred to the attacker.\n\nsolidity\nif (user.amount  0) {\n    uint256 pending = (user.amount * accRJoePerShare) /\n        PRECISION -\n        user.rewardDebt;\n    _safeRJoeTransfer(msg.sender, pending);\n}\nuser.amount = user.amount + _amount;\nuser.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;\n\n\n",
                "Repair": "\nThere are two possible mitigations. First is to use the openzeppelin reentrancy guard(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) over the deposit() function which will prevent multiple deposits being made simultaneously.\n\nThe second mitigation is to follow the checks-effects-interactions(https://docs.soliditylang.org/en/v0.8.11/security-considerations.html#re-entrancy) pattern. This would involve updating all state variables before making any external calls.\n\ncryptofish7 (Trader Joe) confirmed, but disagreed with severity and commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/127#issuecomment-1026161071):\n  Disagree with severity\n \n Fix: https://github.com/traderjoe-xyz/rocket-joe/pull/142\n\nLSDan (judge) commented(https://github.com/code-423n4/2022-01-trader-joe-findings/issues/127#issuecomment-1047788682):\n  I agree with the warden's assessment of risk on this one. Leaving it unaddressed would represent a potential future compromise if it was forgotten about by the team.\n\n\n\n*\n\n\n"
            }
        ]
    }
]