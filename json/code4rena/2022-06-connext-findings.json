[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortal_swapFailed();\n  error PortalFacet__repayAavePortalFor_notSupportedAsset();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a router executed a manual repayment to Aave Portal\n   * @param router - The router that execute the repayment\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRouterRepayment(address indexed router, address asset, uint256 amount, uint256 fee);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwner {\n    s.aavePool = _aavePool;\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner {\n    if (_aavePortalFeeNumerator > s.LIQUIDITY_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function\n   * @param _local The local asset (what router stores liquidity in)\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   * @dev Should always be paying in the backing asset for the aave loan\n   * @param _router Router who took out the credit\n   * @param _adopted Address of the adopted asset (asset backing the loan)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function repayAavePortalFor(\n    address _router,\n    address _adopted,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    bytes32 _transferId\n  ) external payable {\n    address adopted = _adopted == address(0) ? address(s.wrapper) : _adopted;\n    // Ensure the asset is whitelisted\n    ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[adopted];\n    if (canonical.id == bytes32(0)) {\n      revert PortalFacet__repayAavePortalFor_notSupportedAsset();\n    }\n\n    // Transfer funds to the contract\n    uint256 total = _backingAmount + _feeAmount;\n    if (total == 0) revert PortalFacet__repayAavePortalFor_zeroAmount();\n\n    (, uint256 amount) = AssetLogic.handleIncomingAsset(_adopted, total, 0);\n\n    // If this was a fee on transfer token, reduce the total\n    if (amount < total) {\n      uint256 missing = total - amount;\n      if (missing < _feeAmount) {\n        // Debit fee amount\n        _feeAmount -= missing;\n      } else {\n        // Debit backing amount\n        missing -= _feeAmount;\n        _feeAmount = 0;\n        _backingAmount -= missing;\n      }\n    }\n\n    // No need to swap because this is the adopted asset. Simply\n    // repay the loan\n    _backLoan(adopted, _backingAmount, _feeAmount, _transferId);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Calls backUnbacked on the aave contracts\n   * @dev Assumes funds in adopted asset are already on contract\n   * @param _asset Address of the adopted asset (asset backing the loan)\n   * @param _backing Amount of principle to repay\n   * @param _fee Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function _backLoan(\n    address _asset,\n    uint256 _backing,\n    uint256 _fee,\n    bytes32 _transferId\n  ) internal {\n    // reduce debt\n    s.portalDebt[_transferId] -= _backing;\n    s.portalFeeDebt[_transferId] -= _fee;\n\n    // increase allowance\n    SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_asset), s.aavePool, _backing + _fee);\n\n    // back loan\n    IAavePool(s.aavePool).backUnbacked(_asset, _backing, _fee);\n\n    // emit event\n    emit AavePortalRouterRepayment(msg.sender, _asset, _backing, _fee);\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {Home} from \"../../../nomad-core/contracts/Home.sol\";\n\nimport {AppStorage} from \"../libraries/LibConnextStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\n\ncontract BaseConnextFacet {\n  AppStorage internal s;\n\n  // ========== Properties ===========\n  uint256 internal constant _NOT_ENTERED = 1;\n  uint256 internal constant _ENTERED = 2;\n\n  // Contains hash of empty bytes\n  bytes32 internal constant EMPTY = hex\"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n\n  // ========== Custom Errors ===========\n\n  error BaseConnextFacet__onlyRemoteRouter_notRemoteRouter();\n  error BaseConnextFacet__onlyReplica_notReplica();\n  error BaseConnextFacet__onlyOwner_notOwner();\n  error BaseConnextFacet__onlyProposed_notProposedOwner();\n  error BaseConnextFacet__whenNotPaused_paused();\n\n  // ============ Modifiers ============\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(s._status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    s._status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    s._status = _NOT_ENTERED;\n  }\n\n  /**\n   * @notice Only accept messages from a remote Router contract\n   * @param _origin The domain the message is coming from\n   * @param _router The address the message is coming from\n   */\n  modifier onlyRemoteRouter(uint32 _origin, bytes32 _router) {\n    if (!_isRemoteRouter(_origin, _router)) revert BaseConnextFacet__onlyRemoteRouter_notRemoteRouter();\n    _;\n  }\n\n  /**\n   * @notice Only accept messages from an Nomad Replica contract\n   */\n  modifier onlyReplica() {\n    if (!_isReplica(msg.sender)) revert BaseConnextFacet__onlyReplica_notReplica();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    if (LibDiamond.contractOwner() != msg.sender) revert BaseConnextFacet__onlyOwner_notOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the proposed owner.\n   */\n  modifier onlyProposed() {\n    if (s._proposed != msg.sender) revert BaseConnextFacet__onlyProposed_notProposedOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if all functionality is paused\n   */\n  modifier whenNotPaused() {\n    if (s._paused) revert BaseConnextFacet__whenNotPaused_paused();\n    _;\n  }\n\n  // ============ Internal functions ============\n  /**\n   * @notice Indicates if the ownership of the router whitelist has\n   * been renounced\n   */\n  function _isRouterOwnershipRenounced() internal view returns (bool) {\n    return LibDiamond.contractOwner() == address(0) || s._routerOwnershipRenounced;\n  }\n\n  /**\n   * @notice Indicates if the ownership of the asset whitelist has\n   * been renounced\n   */\n  function _isAssetOwnershipRenounced() internal view returns (bool) {\n    return LibDiamond.contractOwner() == address(0) || s._assetOwnershipRenounced;\n  }\n\n  /**\n   * @notice Return true if the given domain / router is the address of a remote xApp Router\n   * @param _domain The domain of the potential remote xApp Router\n   * @param _router The address of the potential remote xApp Router\n   */\n  function _isRemoteRouter(uint32 _domain, bytes32 _router) internal view returns (bool) {\n    return s.remotes[_domain] == _router;\n  }\n\n  /**\n   * @notice Assert that the given domain has a xApp Router registered and return its address\n   * @param _domain The domain of the chain for which to get the xApp Router\n   * @return _remote The address of the remote xApp Router on _domain\n   */\n  function _mustHaveRemote(uint32 _domain) internal view returns (bytes32 _remote) {\n    _remote = s.remotes[_domain];\n    require(_remote != bytes32(0), \"!remote\");\n  }\n\n  /**\n   * @notice Get the local Home contract from the xAppConnectionManager\n   * @return The local Home contract\n   */\n  function _home() internal view returns (Home) {\n    return s.xAppConnectionManager.home();\n  }\n\n  /**\n   * @notice Determine whether _potentialReplcia is an enrolled Replica from the xAppConnectionManager\n   * @return True if _potentialReplica is an enrolled Replica\n   */\n  function _isReplica(address _potentialReplica) internal view returns (bool) {\n    return s.xAppConnectionManager.isReplica(_potentialReplica);\n  }\n\n  /**\n   * @notice Get the local domain from the xAppConnectionManager\n   * @return The local domain\n   */\n  function _localDomain() internal view virtual returns (uint32) {\n    return s.xAppConnectionManager.localDomain();\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n",
        "CodeNames": [
            "PortalFacet.sol",
            "BaseConnextFacet.sol",
            "BridgeFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "sol\n// Relevant code sections:\n\n// PortalFacet.sol\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n// AssetLogic.sol\n  function swapFromLocalAssetIfNeededForExactOut(\n    address _asset,\n    uint256 _amount,\n    uint256 _maxIn\n  )\n    internal\n    returns (\n      bool,\n      uint256,\n      address\n    )\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (true, _amount, _asset);\n    }\n\n    return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);\n  }\n",
                    "sol\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n",
                    "sol\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (true, _amount, _asset);\n    }\n",
                    "sol\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n",
                    "sol\n// PortalFacet.t.sol\n\n  function test_PortalFacet_underflow() public {\n    s.routerPermissionInfo.approvedForPortalRouters[router] = true;\n\n    uint backing = 2 ether;\n    uint fee = 10000;\n    uint init = 1 ether;\n\n    s.routerBalances[router][_local] = init;\n    s.portalDebt[_id] = backing;\n    s.portalFeeDebt[_id] = fee;\n\n    vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));\n    vm.prank(router);\n    this.repayAavePortal(_local, backing, fee, init 0.5 ether, _id);\n\n    // balance  init = underflow\n    require(s.routerBalances[router][_local]  init);\n  }\n"
                ],
                "Type": "  PortcalFacet.repayAavePortal()  can trigger an underflow of  routerBalances ",
                "Description": "\nPortalFacet.sol#L80-L113(https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80-L113)<br\n\nThe caller of repayAavePortal() can trigger an underflow to arbitrarily increase the caller's balance through an underflow.\n\n\nsol\n// Relevant code sections:\n\n// PortalFacet.sol\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact totalRepayAmount of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n// AssetLogic.sol\n  function swapFromLocalAssetIfNeededForExactOut(\n    address _asset,\n    uint256 _amount,\n    uint256 _maxIn\n  )\n    internal\n    returns (\n      bool,\n      uint256,\n      address\n    )\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (true, _amount, _asset);\n    }\n\n    return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);\n  }\n\n\nFirst, call repayAavePortal() where _backingAmount + _feeAmount  s.routerBalances[msg.sender][_local] && _maxIn  s.routerBalances[msg.sender][_local]. That will trigger the call to the AssetLogic contract:\n\nsol\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n\nBy setting _local to the same value as the adopted asset, you trigger the following edge case:\n\nsol\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (true, _amount, _asset);\n    }\n\n\nSo the amountIn value returned by swapFromLocalAssetIfNeededForExactOut() is the totalAmount value that was passed to it. And totalAmount == _backingAmount + _feeAmount.\n\nMeaning the amountIn value is user-specified for this edge case. Finally, we reach the following line:\n\nsol\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n\namountIn (user-specified) is subtracted from the routerBalances in an unchecked block. Thus, the attacker is able to trigger an underflow and increase their balance arbitrarily high. The repayAavePortal() function only verifies that routerBalance < _maxIn.\n\nHere's a test as PoC:\n\nsol\n// PortalFacet.t.sol\n\n  function test_PortalFacet_underflow() public {\n    s.routerPermissionInfo.approvedForPortalRouters[router] = true;\n\n    uint backing = 2 ether;\n    uint fee = 10000;\n    uint init = 1 ether;\n\n    s.routerBalances[router][_local] = init;\n    s.portalDebt[_id] = backing;\n    s.portalFeeDebt[_id] = fee;\n\n    vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));\n    vm.prank(router);\n    this.repayAavePortal(_local, backing, fee, init 0.5 ether, _id);\n\n    // balance  init = underflow\n    require(s.routerBalances[router][_local]  init);\n  }\n\n\n",
                "Repair": "\nAfter the call to swapFromLocalAssetIfNeededForExactOut() you should add the following check:\n\nsol\nif (_local == adopted) {\n  require(routerBalance = amountIn);\n}\n\n\nLayneHaber (Connext) confirmed and resolved(https://github.com/code-423n4/2022-06-connext-findings/issues/68#issuecomment-1167501711):\n  connext/nxtp@ac95c1b(https://github.com/connext/nxtp/pull/1450/commits/ac95c1b987c34862e106fc7d643fb8bb7ebb053e)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/68#issuecomment-1202020574):\n  This is entirely valid and a really severe issue. If the local asset is the adopted asset, AssetLogic.swapFromLocalAssetIfNeededForExactOut() will return amountIn == totalAmount. So in order to overflow routerBalances, the router just needs to provide _backingAmount + _feeAmount inputs that sum to exceed the router's current balance.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {AmplificationUtils, SwapUtils} from \"../libraries/AmplificationUtils.sol\";\nimport {LPToken} from \"../helpers/LPToken.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\n\ncontract StableSwapFacet is BaseConnextFacet {\n  using SwapUtils for SwapUtils.Swap;\n  using AmplificationUtils for SwapUtils.Swap;\n\n  // ========== Custom Errors ===========\n  error StableSwapFacet__deadlineCheck_deadlineNotMet();\n  error StableSwapFacet__initializeSwap_alreadyInitialized();\n  error StableSwapFacet__initializeSwap_invalidPooledTokens();\n  error StableSwapFacet__initializeSwap_decimalsMismatch();\n  error StableSwapFacet__initializeSwap_duplicateTokens();\n  error StableSwapFacet__initializeSwap_zeroTokenAddress();\n  error StableSwapFacet__initializeSwap_tokenDecimalsExceedMax();\n  error StableSwapFacet__initializeSwap_aExceedMax();\n  error StableSwapFacet__initializeSwap_feeExceedMax();\n  error StableSwapFacet__initializeSwap_adminFeeExceedMax();\n  error StableSwapFacet__initializeSwap_failedInitLpTokenClone();\n  error StableSwapFacet__getSwapToken_outOfRange();\n  error StableSwapFacet__getSwapTokenIndex_notExist();\n  error StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n\n  // ============ Properties ============\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Modifier to check deadline against current timestamp\n   * @param deadline latest timestamp to accept this transaction\n   */\n  modifier deadlineCheck(uint256 deadline) {\n    if (block.timestamp > deadline) revert StableSwapFacet__deadlineCheck_deadlineNotMet();\n    _;\n  }\n\n  // ============ View Functions ============\n  /**\n   * @notice Return Stable swap storage\n   * @param canonicalId the canonical token id\n   * @return SwapUtils.Swap\n   */\n  function getSwapStorage(bytes32 canonicalId) external view returns (SwapUtils.Swap memory) {\n    return s.swapStorages[canonicalId];\n  }\n\n  /**\n   * @notice Return LP token for canonical Id\n   * @param canonicalId the canonical token id\n   * @return LPToken\n   */\n  function getSwapLPToken(bytes32 canonicalId) external view returns (address) {\n    return address(s.swapStorages[canonicalId].lpToken);\n  }\n\n  /**\n   * @notice Return A, the amplification coefficient * n * (n - 1)\n   * @dev See the StableSwap paper for details\n   * @param canonicalId the canonical token id\n   * @return A parameter\n   */\n  function getSwapA(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getA();\n  }\n\n  /**\n   * @notice Return A in its raw precision form\n   * @dev See the StableSwap paper for details\n   * @param canonicalId the canonical token id\n   * @return A parameter in its raw precision form\n   */\n  function getSwapAPrecise(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getAPrecise();\n  }\n\n  /**\n   * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n   * @param canonicalId the canonical token id\n   * @param index the index of the token\n   * @return address of the token at given index\n   */\n  function getSwapToken(bytes32 canonicalId, uint8 index) public view returns (IERC20) {\n    if (index >= s.swapStorages[canonicalId].pooledTokens.length) revert StableSwapFacet__getSwapToken_outOfRange();\n    return s.swapStorages[canonicalId].pooledTokens[index];\n  }\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param canonicalId the canonical token id\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getSwapTokenIndex(bytes32 canonicalId, address tokenAddress) public view returns (uint8) {\n    uint8 index = s.tokenIndexes[canonicalId][tokenAddress];\n    if (address(getSwapToken(canonicalId, index)) != tokenAddress) revert StableSwapFacet__getSwapTokenIndex_notExist();\n    return index;\n  }\n\n  /**\n   * @notice Return current balance of the pooled token at given index\n   * @param canonicalId the canonical token id\n   * @param index the index of the token\n   * @return current balance of the pooled token at given index with token's native precision\n   */\n  function getSwapTokenBalance(bytes32 canonicalId, uint8 index) external view returns (uint256) {\n    if (index >= s.swapStorages[canonicalId].balances.length)\n      revert StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n    return s.swapStorages[canonicalId].balances[index];\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param canonicalId the canonical token id\n   * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n   */\n  function getSwapVirtualPrice(bytes32 canonicalId) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getVirtualPrice();\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param canonicalId the canonical token id\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell. If the token charges\n   * a fee on transfers, use the amount that gets transferred after the fee.\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256) {\n    return s.swapStorages[canonicalId].calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param canonicalId the canonical token id\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return token amount the user will receive\n   */\n  function calculateSwapTokenAmount(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    bool deposit\n  ) external view returns (uint256) {\n    return s.swapStorages[canonicalId].calculateTokenAmount(amounts, deposit);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of LP tokens\n   * @param canonicalId the canonical token id\n   * @param amount the amount of LP tokens that would be burned on withdrawal\n   * @return array of token balances that the user will receive\n   */\n  function calculateRemoveSwapLiquidity(bytes32 canonicalId, uint256 amount) external view returns (uint256[] memory) {\n    return s.swapStorages[canonicalId].calculateRemoveLiquidity(amount);\n  }\n\n  /**\n   * @notice Calculate the amount of underlying token available to withdraw\n   * when withdrawing via only single token\n   * @param canonicalId the canonical token id\n   * @param tokenAmount the amount of LP token to burn\n   * @param tokenIndex index of which token will be withdrawn\n   * @return availableTokenAmount calculated amount of underlying token\n   * available to withdraw\n   */\n  function calculateRemoveSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount) {\n    return s.swapStorages[canonicalId].calculateWithdrawOneToken(tokenAmount, tokenIndex);\n  }\n\n  /**\n   * @notice This function reads the accumulated amount of admin fees of the token with given index\n   * @param canonicalId the canonical token id\n   * @param index Index of the pooled token\n   * @return admin's token balance in the token's precision\n   */\n  function getSwapAdminBalance(bytes32 canonicalId, uint256 index) external view returns (uint256) {\n    return s.swapStorages[canonicalId].getAdminBalance(index);\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param tokenIndexFrom the token the user wants to swap from\n   * @param tokenIndexTo the token the user wants to swap to\n   * @param dx the amount of tokens the user wants to swap from\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @param deadline latest timestamp to accept this transaction\n   */\n  function swap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountIn the amount of tokens the user wants to swap from\n   */\n  function swapExact(\n    bytes32 canonicalId,\n    uint256 amountIn,\n    address assetIn,\n    address assetOut,\n    uint256 minAmountOut,\n    uint256 deadline\n  ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return\n      s.swapStorages[canonicalId].swap(\n        getSwapTokenIndex(canonicalId, assetIn),\n        getSwapTokenIndex(canonicalId, assetOut),\n        amountIn,\n        minAmountOut\n      );\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param canonicalId the canonical token id\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountOut the amount of tokens the user wants to swap to\n   */\n  function swapExactOut(\n    bytes32 canonicalId,\n    uint256 amountOut,\n    address assetIn,\n    address assetOut,\n    uint256 maxAmountIn,\n    uint256 deadline\n  ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) {\n    return\n      s.swapStorages[canonicalId].swapOut(\n        getSwapTokenIndex(canonicalId, assetIn),\n        getSwapTokenIndex(canonicalId, assetOut),\n        amountOut,\n        maxAmountIn\n      );\n  }\n\n  /**\n   * @notice Add liquidity to the pool with the given amounts of tokens\n   * @param canonicalId the canonical token id\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP token user minted and received\n   */\n  function addSwapLiquidity(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) returns (uint256) {\n    return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param canonicalId the canonical token id\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   *        acceptable for this burn. Useful as a front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amounts of tokens user received\n   */\n  function removeSwapLiquidity(\n    bytes32 canonicalId,\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256[] memory) {\n    return s.swapStorages[canonicalId].removeLiquidity(amount, minAmounts);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param canonicalId the canonical token id\n   * @param tokenAmount the amount of the token you want to receive\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of chosen token user received\n   */\n  function removeSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param canonicalId the canonical token id\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP tokens burned\n   */\n  function removeSwapLiquidityImbalance(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[canonicalId].removeLiquidityImbalance(amounts, maxBurnAmount);\n  }\n\n  /*** ADMIN FUNCTIONS ***/\n  /**\n   * @notice Initializes this Swap contract with the given parameters.\n   * This will also clone a LPToken contract that represents users'\n   * LP positions. The owner of LPToken will be this contract - which means\n   * only this contract is allowed to mint/burn tokens.\n   *\n   * @param _canonicalId the canonical token id\n   * @param _pooledTokens an array of ERC20s this pool will accept\n   * @param decimals the decimals to use for each pooled token,\n   * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n   * @param lpTokenName the long-form name of the token to be deployed\n   * @param lpTokenSymbol the short symbol for the token to be deployed\n   * @param _a the amplification coefficient * n * (n - 1). See the\n   * StableSwap paper for details\n   * @param _fee default swap fee to be initialized with\n   * @param _adminFee default adminFee to be initialized with\n   * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n   */\n  function initializeSwap(\n    bytes32 _canonicalId,\n    IERC20[] memory _pooledTokens,\n    uint8[] memory decimals,\n    string memory lpTokenName,\n    string memory lpTokenSymbol,\n    uint256 _a,\n    uint256 _fee,\n    uint256 _adminFee,\n    address lpTokenTargetAddress\n  ) external onlyOwner {\n    if (s.swapStorages[_canonicalId].pooledTokens.length != 0)\n      revert StableSwapFacet__initializeSwap_alreadyInitialized();\n\n    // Check _pooledTokens and precisions parameter\n    if (_pooledTokens.length <= 1 || _pooledTokens.length > 32)\n      revert StableSwapFacet__initializeSwap_invalidPooledTokens();\n\n    if (_pooledTokens.length != decimals.length) revert StableSwapFacet__initializeSwap_decimalsMismatch();\n\n    uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n    for (uint8 i = 0; i < _pooledTokens.length; i++) {\n      if (i > 0) {\n        // Check if index is already used. Check if 0th element is a duplicate.\n        if (s.tokenIndexes[_canonicalId][address(_pooledTokens[i])] != 0 || _pooledTokens[0] == _pooledTokens[i])\n          revert StableSwapFacet__initializeSwap_duplicateTokens();\n      }\n      if (address(_pooledTokens[i]) == address(0)) revert StableSwapFacet__initializeSwap_zeroTokenAddress();\n\n      if (decimals[i] > SwapUtils.POOL_PRECISION_DECIMALS)\n        revert StableSwapFacet__initializeSwap_tokenDecimalsExceedMax();\n\n      precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]);\n      s.tokenIndexes[_canonicalId][address(_pooledTokens[i])] = i;\n    }\n\n    // Check _a, _fee, _adminFee, _withdrawFee parameters\n    if (_a >= AmplificationUtils.MAX_A) revert StableSwapFacet__initializeSwap_aExceedMax();\n    if (_fee >= SwapUtils.MAX_SWAP_FEE) revert StableSwapFacet__initializeSwap_feeExceedMax();\n    if (_adminFee >= SwapUtils.MAX_ADMIN_FEE) revert StableSwapFacet__initializeSwap_adminFeeExceedMax();\n\n    // Initialize a LPToken contract\n    LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n    if (!lpToken.initialize(lpTokenName, lpTokenSymbol))\n      revert StableSwapFacet__initializeSwap_failedInitLpTokenClone();\n\n    // Initialize swapStorage struct\n    s.swapStorages[_canonicalId] = SwapUtils.Swap({\n      initialA: _a * AmplificationUtils.A_PRECISION,\n      futureA: _a * AmplificationUtils.A_PRECISION,\n      swapFee: _fee,\n      adminFee: _adminFee,\n      lpToken: lpToken,\n      pooledTokens: _pooledTokens,\n      tokenPrecisionMultipliers: precisionMultipliers,\n      balances: new uint256[](_pooledTokens.length),\n      adminFees: new uint256[](_pooledTokens.length),\n      initialATime: 0,\n      futureATime: 0\n    });\n  }\n\n  /**\n   * @notice Withdraw all admin fees to the contract owner\n   * @param canonicalId the canonical token id\n   */\n  function withdrawSwapAdminFees(bytes32 canonicalId) external onlyOwner {\n    s.swapStorages[canonicalId].withdrawAdminFees(msg.sender);\n  }\n\n  /**\n   * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n   * @param canonicalId the canonical token id\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setSwapAdminFee(bytes32 canonicalId, uint256 newAdminFee) external onlyOwner {\n    s.swapStorages[canonicalId].setAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice Update the swap fee to be applied on swaps\n   * @param canonicalId the canonical token id\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(bytes32 canonicalId, uint256 newSwapFee) external onlyOwner {\n    s.swapStorages[canonicalId].setSwapFee(newSwapFee);\n  }\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA and futureTime\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param canonicalId the canonical token id\n   * @param futureA the new A to ramp towards\n   * @param futureTime timestamp when the new A should be reached\n   */\n  function rampA(\n    bytes32 canonicalId,\n    uint256 futureA,\n    uint256 futureTime\n  ) external onlyOwner {\n    s.swapStorages[canonicalId].rampA(futureA, futureTime);\n  }\n\n  /**\n   * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n   * @param canonicalId the canonical token id\n   */\n  function stopRampA(bytes32 canonicalId) external onlyOwner {\n    s.swapStorages[canonicalId].stopRampA();\n  }\n}\n\n\n",
        "CodeNames": [
            "StableSwapFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction withdrawAdminFees(Swap storage self, address to) internal {\n  IERC20[] memory pooledTokens = self.pooledTokens;\n  for (uint256 i = 0; i < pooledTokens.length; i++) {\n    IERC20 token = pooledTokens[i];\n    uint256 balance = self.adminFees[i];\n    if (balance != 0) {\n      token.safeTransfer(to, balance);\n    }\n  }\n}\n"
                ],
                "Type": " Wrong implementation of  withdrawAdminFees()  can cause the  adminFees  to be charged multiple times and therefore cause users' fund loss",
                "Description": "\nSwapUtils.sol#L1053-L1062(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L1053-L1062)<br\n\nsolidity\nfunction withdrawAdminFees(Swap storage self, address to) internal {\n  IERC20[] memory pooledTokens = self.pooledTokens;\n  for (uint256 i = 0; i < pooledTokens.length; i++) {\n    IERC20 token = pooledTokens[i];\n    uint256 balance = self.adminFees[i];\n    if (balance != 0) {\n      token.safeTransfer(to, balance);\n    }\n  }\n}\n\n\nself.adminFees[i] should be reset to 0 every time it's withdrawn. Otherwise, the adminFees can be withdrawn multiple times.\n\nThe admin may just be unaware of this issue and casualty withdrawAdminFees() from time to time, and rug all the users slowly.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction withdrawAdminFees(Swap storage self, address to) internal {\n  IERC20[] memory pooledTokens = self.pooledTokens;\n  for (uint256 i = 0; i < pooledTokens.length; i++) {\n    IERC20 token = pooledTokens[i];\n    uint256 balance = self.adminFees[i];\n    if (balance != 0) {\n      self.adminFees[i] = 0;\n      token.safeTransfer(to, balance);\n    }\n  }\n}\n\n\nLayneHaber (Connext) confirmed and resolved(https://github.com/code-423n4/2022-06-connext-findings/issues/202#issuecomment-1167495532):\n  connext/nxtp@8eef974(https://github.com/connext/nxtp/pull/1450/commits/8eef974724bf2b9cdd506a1a63d8cc869303c3e5)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/202#issuecomment-1206907050):\n  Completely agree with the validity of this finding. Even if the admin was _not_ malicious, the bug will still continue to withdraw additional fees which were not included as part of the swap calculations. LPs would lose considerable value as a result.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n",
        "CodeNames": [
            "BridgeFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "execute",
                    "_reconcile"
                ],
                "Type": " Router Owner Could Steal All The Funds Within  SponsorVault ",
                "Description": "\nBridgeFacet.sol#L541(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L541)<br\nSponsorVault.sol#L196(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/SponsorVault.sol#L196)<br\n\nAssume the following:\n\n*   For simplicity sake, only two (2) routers exist within Connext. Gas, relayer, callback fees and slippage are ignored.\n*   An attacker owns Router A. Router A has 1,000,000 oUSDC on Optimism Domain/Chain\n*   Router B has only 100 oUSDC on Optimism Domain/Chain\n*   The liquidity fee is 5% for fast transfer service\n*   SponserVault will reimbursed 50% of the liquidity fee incurred by the users\n\nAt this point, attacker balances are as follows (2,000,000 USDC in total)\n\n Attacker's wallet in Ethereum = 1,000,000 USDC\n\n Attacker's wallet in Optimism = 0 oUSDC\n\n Attacker's router in Optimism = 1,000,000 oUSDC\n\nFirst, the attacker attempts to transfer an extremely large amount 1,000,000 USDC from attacker's address in Ethereum to attacker's address in Optimism Chain. The transfer amount should be much larger than the rest of the router's liquidity so that only attacker's router is capable of providing the liqudity.\n\nIn our example, since Router B does not have sufficient liquidity to faciliate the fast transfer, Router B will not be selected by the Sequencer. Since only Router A has sufficient liquidity, Router A, which is owned by the attacker, will faciliate the fast transfer and selected by the Sequencer.\n\nSince the liquidity fee is 5%, Router A only need to supply 950,000 oUSDC on execute. The Sponsor will then reimburse 50% of the liquidity fee, which is25,000 oUSDC in total. The final amount of oUSDC send to the attacker's wallet address in Optimism will be 975,000 oUSDC.\n\nAt this point, attacker balances are as follows (1,025,000 USDC in total)\n\n Attacker's wallet in Ethereum = 0 USDC\n\n Attacker's wallet in Optimism = 975,000 oUSDC\n\n Attacker's router in Optimism = 50,000 oUSDC\n\nWhen the nomad message arrives, the attacker will be reimbursed 1,000,000 oUSDC when BridgeFacet._reconcile(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L541) is triggered.\n\nAt this point, attacker balances are as follows (2,025,000 USDC in total)\n\n Attacker's wallet in Ethereum = 0 USDC\n\n Attacker's wallet in Optimism = 975,000 oUSDC\n\n Attacker's router in Optimism = 50,000 + 1,000,000 oUSDC\n\nAttacker earned 25,000 USDC, and SponsorVault lost 25,000 USDC.\n\n\nRouter owner can intentionally perform many large transfer between their own wallets in two different domain to siphon all the funds from the SponsorVault, and then proceed to withdraw all liquidity from his router.\n\n",
                "Repair": "\nAlthough having a sponsor to subside the liqudity fee to encourage users to use sponsor's chain, this subsidy can be gamed by malicious actors for their own benefits. It is recommended to reconsider the need of having a sponsor in Connext as extreme care have to be taken in its design to ensure that it will not be exploited.\n\nLayneHaber (Connext) acknowledged and commented(https://github.com/code-423n4/2022-06-connext-findings/issues/145#issuecomment-1166343703):\n  The SponsorVault is not mandatory for the bridge flow, and the entire point of the vault option is to allow domains to subsidize fees for users transferring funds there. This is incredibly useful for new domains, that have no default bridge and want to remove any friction for users to get to their chain. Sponsor vault funders should be informed there is no way to enforce only legitimate users get the funds and it is inherently vulnerable to sybil attacks. In our conversations with potential sponsors, they are aware of these issues and are still willing to fund sponsor vaults to a limited capacity.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/145#issuecomment-1214222883):\n  It seems that it would be easy for routers to sybil attack the protocol and continuously drain the sponsor vault of all its funds. While I understand this might not be an issue when the set of routers is trusted, however, as the protocol continues to become more decentralized, this would be a likely path of attack. I also agree with the current risk even though users' funds aren't at direct risk, the functionality of the sponsor vault is rendered useless and the router profits from this attack.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "_handleExecuteLiquidity()",
                    "ExecuteArgs",
                    "tokenId",
                    "transferId",
                    "handle",
                    "amount",
                    "_reconcile()",
                    "xcall",
                    "detailsHash",
                    "execute",
                    "swapToLocalAssetIfNeeded()",
                    "repayAavePortal",
                    "bridgedAmt",
                    "xcall()",
                    "message = _formatMessage(_args, bridged, transferId, bridgedAmt)",
                    "execute()"
                ],
                "Type": " In  execute()  the amount routers pay is what user signed, but in  _reconcile()  the amount routers get is what nomad sends and these two amounts are not necessary equal because of slippage in original domain",
                "Description": "\nBridgeFacet.sol#L526-L616(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L526-L616)<br\nBridgeFacet.sol#L753-L803(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L753-L803)<br\nBridgeFacet.sol#L398-L428(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L398-L428)<br\nBridgeFacet.sol#L345-L351(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L345-L351)<br\n\nRouters pay for transaction in destination domain then nomad messages come and routers get paid again. but the amount routers pay in execute() are what transaction sender signed and the amount routers receive is what nomad sends and handles in _reconcile() but this two amount can be different because of slippage and swap that happens in xcall() because the amount sent in nomad message is the result of swapToLocalAssetIfNeeded().<br\nSo it's possible for routers to lose funds if some slippage happens in that swap.\n\n\nThis is xcall() code:\n\n      function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n        // Sanity checks.\n        {\n          // Correct origin domain.\n          if (_args.params.originDomain != s.domain) {\n            revert BridgeFacet__xcall_wrongDomain();\n          }\n\n          // Recipient is defined.\n          if (_args.params.to == address(0)) {\n            revert BridgeFacet__xcall_emptyTo();\n          }\n\n          // If callback address is not set, callback fee should be 0.\n          if (_args.params.callback == address(0) && _args.params.callbackFee  0) {\n            revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n          }\n\n          // Callback is contract if supplied.\n          if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n            revert BridgeFacet__xcall_callbackNotAContract();\n          }\n        }\n\n        bytes32 transferId;\n        bytes memory message;\n        XCalledEventArgs memory eventArgs;\n        {\n          // Get the remote BridgeRouter address; revert if not found.\n          bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n          // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n          address transactingAssetId = _args.transactingAssetId == address(0)\n            ? address(s.wrapper)\n            : _args.transactingAssetId;\n\n          // Check that the asset is supported -can be either adopted or local.\n          ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n          if (canonical.id == bytes32(0)) {\n            // Here, the asset is *not* the adopted asset. The only other valid option\n            // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n            // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n            // the canonical domain, where it is *also* the adopted asset.\n            if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n              // revert, using a token of local origin that is not registered as adopted\n              revert BridgeFacet__xcall_notSupportedAsset();\n            }\n\n            (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n            canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n          }\n\n          transferId = _getTransferId(_args, canonical);\n          s.nonce += 1;\n\n          // Store the relayer fee\n          s.relayerFees[transferId] = _args.params.relayerFee;\n\n          // Transfer funds of transacting asset to the contract from the user.\n          // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n          (, uint256 amount) = AssetLogic.handleIncomingAsset(\n            _args.transactingAssetId,\n            _args.amount,\n            _args.params.relayerFee + _args.params.callbackFee\n          );\n\n          // Swap to the local asset from adopted if applicable.\n          (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n            canonical,\n            transactingAssetId,\n            amount,\n            _args.params.slippageTol\n          );\n\n          // Transfer callback fee to PromiseRouter if set\n          if (_args.params.callbackFee != 0) {\n            s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n          }\n\n          message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n          s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n          // Format arguments for XCalled event that will be emitted below.\n          eventArgs = XCalledEventArgs({\n            transactingAssetId: transactingAssetId,\n            amount: amount,\n            bridgedAmt: bridgedAmt,\n            bridged: bridged\n          });\n        }\n\n        // emit event\n        emit XCalled(transferId, _args, eventArgs, s.nonce 1, message, msg.sender);\n\n        return transferId;\n      }\n\nAs you can see it swaps what user sent to LoccalAsset which the amount is bridgedAmt and then send value of bridgedAmt to nomad bridge message = _formatMessage(_args, bridged, transferId, bridgedAmt).<br\nBut the amount user signed in _args.amount is different and that what user sends to contract.<br\nThe reasons that bridgedAmt could be different than _args.amount is:<br\n1deflationary tokens in transferring from user.<br\n2slippage in swap to local token.<br\nThis is _reconcile() code:\n\n      function _reconcile(uint32 _origin, bytes memory _message) internal {\n        // Parse tokenId and action from the message.\n        bytes29 msg_ = _message.ref(0).mustBeMessage();\n        bytes29 tokenId = msg_.tokenId();\n        bytes29 action = msg_.action();\n\n        // Assert that the action is valid.\n        if (!action.isTransfer()) {\n          revert BridgeFacet__reconcile_invalidAction();\n        }\n\n        // Load the transferId.\n        bytes32 transferId = action.transferId();\n\n        // Ensure the transaction has not already been handled (i.e. previously reconciled).\n        if (s.reconciledTransfers[transferId]) {\n          revert BridgeFacet__reconcile_alreadyReconciled();\n        }\n\n        // NOTE: tokenId and amount must be in plaintext in the message so funds can *only* be minted by\n        // handle. They are both used in the generation of the transferId so routers must provide them\n        // correctly to be reimbursed.\n\n        // Get the appropriate local token contract for the given tokenId on this chain.\n        // NOTE: If the token is of remote origin and there is no existing representation token contract,\n        // the TokenRegistry will deploy a new one.\n        address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n        // Load amount once.\n        uint256 amount = action.amnt();\n\n        // Mint tokens if the asset is of remote origin (i.e. is representational).\n        // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n        // in escrow in this contract (from previous xcalls).\n        if (!s.tokenRegistry.isLocalOrigin(token)) {\n          IBridgeToken(token).mint(address(this), amount);\n\n          // Update the recorded detailsHash for the token (name, symbol, decimals).\n          // TODO: do we need to keep this\n          bytes32 details = action.detailsHash();\n          IBridgeToken(token).setDetailsHash(details);\n        }\n\n        // Mark the transfer as reconciled.\n        s.reconciledTransfers[transferId] = true;\n\n        // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n        // to the participating routers.\n        // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n        // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent execute call).\n        address[] memory routers = s.routedTransfers[transferId];\n\n        // If fast transfer was made using portal liquidity, we need to repay\n        // FIXME: routers can repay any-amount out-of-band using the repayAavePortal method\n        // or by interacting with the aave contracts directly\n        uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n        uint256 toDistribute = amount;\n        uint256 pathLen = routers.length;\n        if (portalTransferAmount != 0) {\n          // ensure a router took on credit risk\n          if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n          toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n        }\n\n        if (pathLen != 0) {\n          // fast liquidity path\n          // Credit each router that provided liquidity their due 'share' of the asset.\n          uint256 routerAmt = toDistribute / pathLen;\n          for (uint256 i; i < pathLen; ) {\n            s.routerBalances[routers[i]][token] += routerAmt;\n            unchecked {\n              i++;\n            }\n          }\n        }\n\n        emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n      }\n\nAs you can see it uses amount in message to calculate what router should receive.<br\nThis is _handleExecuteLiquidity() code which is used in execute():\n\n      function _handleExecuteLiquidity(\n        bytes32 _transferId,\n        bool _isFast,\n        ExecuteArgs calldata _args\n      ) private returns (uint256, address) {\n        uint256 toSwap = _args.amount;\n\n        // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n        // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n        // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n        // (since the amount is hashed in the transfer ID itself) thus, no updates are required.\n        if (_isFast) {\n          uint256 pathLen = _args.routers.length;\n\n          // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n          toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n          // Save the addressess of all routers providing liquidity for this transfer.\n          s.routedTransfers[_transferId] = _args.routers;\n\n          // If router does not have enough liquidity, try to use Aave Portals.\n          // only one router should be responsible for taking on this credit risk, and it should only\n          // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n          if (\n            !_args.params.receiveLocal &&\n            pathLen == 1 &&\n            s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n            s.aavePool != address(0)\n          ) {\n            if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n              revert BridgeFacet__execute_notApprovedForPortals();\n\n            // Portal provides the adopted asset so we early return here\n            return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n          } else {\n            // for each router, assert they are approved, and deduct liquidity\n            uint256 routerAmount = toSwap / pathLen;\n            for (uint256 i; i < pathLen; ) {\n              // decrement routers liquidity\n              s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n              unchecked {\n                i++;\n              }\n            }\n          }\n        }\n\nAs you can see it uses the amount defined in ExecuteArgs to see how much routers should pay.\n\nBecause of these two issues (deflationary tokens and swap slippage) attacker could fool protocol to spend more than what he transferred to protocol. This could be seen as two bugs.\n\n\nVIM\n\n",
                "Repair": "\nUpdate spending amount based on  (deflationary tokens and swap slippage).\n\nLayneHaber (Connext) disputed and commented(https://github.com/code-423n4/2022-06-connext-findings/issues/222#issuecomment-1166334184):\n  I think there is a misunderstanding here -the user takes on the slippage risk both into and out of the local assets, and the router has consistent returns on what was bridged.\n \n On xcall, the user swaps the amount put in for the local asset. This incurs some slippage, and only the amount of the local asset is bridged directly. It is the bridged amount that the router should supply liquidity for, and take fees on. Once the router supplies liquidity in execute (bridged amount minus the fees), then it is swapped for the local asset and sent to the user. The user may get some different amount here, but it is the user who is impacted by this slippage. On handle, the router is credited the bridged amount.\n \n However, there was a separate bug where the transferId was generated with the wrong amount on execute, so that could be where the confusion is coming from.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/222#issuecomment-1214224150):\n  I actually agree with the warden here, it seems that they're right about the issue but they just failed to mention the main reason why its an issue is because transferId is calculated using _args.amount which does not necessarily equal bridgedAmt due to slippage. Therefore, routers may end up fronting too much liquidity and receive considerably less when the bridge transfer is eventually reconciled. This seems rather severe as the user will receive the full transfer amount without slippage. This could be abused to drain routers on low liquidity tokens.\n\nLayneHaber (Connext) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/222#issuecomment-1218136485):\n  Right -I agree that the problems outlined here would be the true consequences for a mismatched transferId. If the question is to take the action outlined here(https://github.com/code-423n4/2022-06-connext-findings/issues/227#issuecomment-1214224706) -specifically to keep this open and downgrade #227 as a QA -that would work with me.\n\nLayneHaber (Connext) resolved(https://github.com/code-423n4/2022-06-connext-findings/issues/222):\n  connext/nxtp@f41a156(https://github.com/connext/nxtp/commit/f41a156b55a01837c8f57a77e52781f74406e1cd)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {ITokenRegistry} from \"../interfaces/ITokenRegistry.sol\";\n\ncontract AssetFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error AssetFacet__setWrapper_invalidWrapper();\n  error AssetFacet__setTokenRegistry_invalidTokenRegistry();\n  error AssetFacet__addAssetId_alreadyAdded();\n  error AssetFacet__removeAssetId_notAdded();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when the wrapper variable is updated\n   * @param oldWrapper - The wrapper old value\n   * @param newWrapper - The wrapper new value\n   * @param caller - The account that called the function\n   */\n  event WrapperUpdated(address oldWrapper, address newWrapper, address caller);\n\n  /**\n   * @notice Emitted when the tokenRegistry variable is updated\n   * @param oldTokenRegistry - The tokenRegistry old value\n   * @param newTokenRegistry - The tokenRegistry new value\n   * @param caller - The account that called the function\n   */\n  event TokenRegistryUpdated(address oldTokenRegistry, address newTokenRegistry, address caller);\n\n  /**\n   * @notice Emitted when a new stable-swap AMM is added for the local <> adopted token\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param swapPool - The address of the AMM\n   * @param caller - The account that called the function\n   */\n  event StableSwapAdded(bytes32 canonicalId, uint32 domain, address swapPool, address caller);\n\n  /**\n   * @notice Emitted when a new asset is added\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param adoptedAsset - The address of the adopted (user-expected) asset\n   * @param supportedAsset - The address of the whitelisted asset. If the native asset is to be whitelisted,\n   * the address of the wrapped version will be stored\n   * @param caller - The account that called the function\n   */\n  event AssetAdded(bytes32 canonicalId, uint32 domain, address adoptedAsset, address supportedAsset, address caller);\n\n  /**\n   * @notice Emitted when an asset is removed from whitelists\n   * @param canonicalId - The canonical identifier of the token removed\n   * @param caller - The account that called the function\n   */\n  event AssetRemoved(bytes32 canonicalId, address caller);\n\n  // ============ Getters ============\n\n  function canonicalToAdopted(bytes32 _canonicalId) public view returns (address) {\n    return s.canonicalToAdopted[_canonicalId];\n  }\n\n  function adoptedToCanonical(address _adopted) public view returns (ConnextMessage.TokenId memory) {\n    ConnextMessage.TokenId memory canonical = ConnextMessage.TokenId(\n      s.adoptedToCanonical[_adopted].domain,\n      s.adoptedToCanonical[_adopted].id\n    );\n    return canonical;\n  }\n\n  function approvedAssets(bytes32 _asset) public view returns (bool) {\n    return s.approvedAssets[_asset];\n  }\n\n  function adoptedToLocalPools(bytes32 _adopted) public view returns (IStableSwap) {\n    return s.adoptedToLocalPools[_adopted];\n  }\n\n  function wrapper() public view returns (IWrapped) {\n    return s.wrapper;\n  }\n\n  function tokenRegistry() public view returns (ITokenRegistry) {\n    return s.tokenRegistry;\n  }\n\n  // ============ Admin functions ============\n\n  /**\n   * @notice Updates the native-asset wrapper interface\n   * @param _wrapper The address of the new wrapper\n   */\n  function setWrapper(address _wrapper) external onlyOwner {\n    address old = address(s.wrapper);\n    if (old == _wrapper || !Address.isContract(_wrapper)) revert AssetFacet__setWrapper_invalidWrapper();\n\n    s.wrapper = IWrapped(_wrapper);\n    emit WrapperUpdated(old, _wrapper, msg.sender);\n  }\n\n  /**\n   * @notice Updates the token registry\n   * @param _tokenRegistry The new token registry address\n   */\n  function setTokenRegistry(address _tokenRegistry) external onlyOwner {\n    address old = address(s.tokenRegistry);\n    if (old == _tokenRegistry || !Address.isContract(_tokenRegistry))\n      revert AssetFacet__setTokenRegistry_invalidTokenRegistry();\n\n    s.tokenRegistry = ITokenRegistry(_tokenRegistry);\n    emit TokenRegistryUpdated(old, _tokenRegistry, msg.sender);\n  }\n\n  /**\n   * @notice Used to add supported assets. This is an admin only function\n   * @dev When whitelisting the canonical asset, all representational assets would be\n   * whitelisted as well. In the event you have a different adopted asset (i.e. PoS USDC\n   * on polygon), you should *not* whitelist the adopted asset. The stable swap pool\n   * address used should allow you to swap between the local <> adopted asset\n   * @param _canonical - The canonical asset to add by id and domain. All representations\n   * will be whitelisted as well\n   * @param _adoptedAssetId - The used asset id for this domain (i.e. PoS USDC for\n   * polygon)\n   */\n  function setupAsset(\n    ConnextMessage.TokenId calldata _canonical,\n    address _adoptedAssetId,\n    address _stableSwapPool\n  ) external onlyOwner {\n    // Sanity check: needs approval\n    if (s.approvedAssets[_canonical.id]) revert AssetFacet__addAssetId_alreadyAdded();\n\n    // Update approved assets mapping\n    s.approvedAssets[_canonical.id] = true;\n\n    address supported = _adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId;\n\n    // Update the adopted mapping\n    s.adoptedToCanonical[supported].domain = _canonical.domain;\n    s.adoptedToCanonical[supported].id = _canonical.id;\n\n    // Update the canonical mapping\n    s.canonicalToAdopted[_canonical.id] = supported;\n\n    // Emit event\n    emit AssetAdded(_canonical.id, _canonical.domain, _adoptedAssetId, supported, msg.sender);\n\n    // Add the swap pool\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Adds a stable swap pool for the local <> adopted asset.\n   */\n  function addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwapPool) external onlyOwner {\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Used to remove assets from the whitelist\n   * @param _canonicalId - Token id to remove\n   * @param _adoptedAssetId - Corresponding adopted asset to remove\n   */\n  function removeAssetId(bytes32 _canonicalId, address _adoptedAssetId) external onlyOwner {\n    // Sanity check: already approval\n    if (!s.approvedAssets[_canonicalId]) revert AssetFacet__removeAssetId_notAdded();\n\n    // Delete from approved assets mapping\n    delete s.approvedAssets[_canonicalId];\n\n    // Delete from pools\n    delete s.adoptedToLocalPools[_canonicalId];\n\n    // Delete from adopted mapping\n    delete s.adoptedToCanonical[_adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId];\n\n    // Delete from canonical mapping\n    delete s.canonicalToAdopted[_canonicalId];\n\n    // Emit event\n    emit AssetRemoved(_canonicalId, msg.sender);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Used to add an AMM for adopted <> local assets\n   * @param _canonical - The canonical TokenId to add (domain and id)\n   * @param _stableSwap - The address of the amm to add\n   */\n  function _addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwap) internal {\n    // Update the pool mapping\n    s.adoptedToLocalPools[_canonical.id] = IStableSwap(_stableSwap);\n\n    emit StableSwapAdded(_canonical.id, _canonical.domain, _stableSwap, msg.sender);\n  }\n}\n\n\n",
        "CodeNames": [
            "BridgeFacet.sol",
            "AssetFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "swapFromLocalAssetIfNeededForExactOut",
                    "_reconcile",
                    "_amount",
                    "handle",
                    "return (_amount amountIn)",
                    "_reconcileProcessPortal",
                    "repayAavePortal",
                    "amount"
                ],
                "Type": " Routers are not Enforced to Repay AAVE Portal Loan",
                "Description": "\nBridgeFacet.sol#L984(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984)<br\n\n\n\nAAVE portal provides a trusted credit line that allows bridges to take on an unbacked position, and Connext intents to use this credit line to provide fast-liquidity for its users in the event the routers do not have sufficient liquidity.\n\nConnext will assign one (1) router to be responsible for taking on credit risk of borrowing an unbacked position from AAVE portal as per Source Code(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L777).\n\nUnder normal circumstance, the BridgeFacet._reconcile function will automatically repay back the loan to AAVE portal when the nomad message arrives. However, if the repayment fails for certain reason, Connext expects that the router will use the repayAavePortal(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) function out-of-band to help Connext to repay the loan.\n\nUltimately, it is Connext that take on the credit risk because AAVE portal only provides a trusted credit line to Connext, but not to the individual routers.\n\n\nWhen nomad message arrives, it will call BridgeFacet.handle function, which will in turn trigger the internal _reconcile function. Note that the handle or _reconcile function cannot be reverted under any circumstances because nomad message cannot be reprocessed on the nomad side.\n\n\n1.  Alice transfers 1,000,000 DAI from Ethereum domain to Polygon domain\n\n2.  None of the existing routers have sufficient liquidity, thus the sequencer decided that AAVE Portal should be used\n\n3.  Bob's router has been selected to take on the credit risk for the unbacked position, and Connext proceeds to borrow 1,000,000 DAI from AAVE Portal and send the 1,000,000 DAI to Alice's wallet on Polygon domain\n\n4.  When slow nomad message arrives, BridgeFacet._reconcile function is triggered to attempt to repay back the loan to AAVE portal. This function will in turn trigger the BridgeFacet._reconcileProcessPortal(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984) function where the portal repayment logic resides.\n\n5.  Within the BridgeFacet._reconcileProcessPortal, notice that if the AssetLogic.swapFromLocalAssetIfNeededForExactOut swap fails, it will return _amount(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L1022).\n\n6.  Within the BridgeFacet._reconcileProcessPortal, notice that if the AavaPool.backUnbackedexternal repayment call fails, it will setamountIn = 0  , and then return  return (_amount amountIn) (https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L1061) , which is basically the same as  _amount.\n\n7.  When the _reconcileProcessPortal function call returned at Line 603(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L603), it will set the  toDistribute   to the amount. amount in this example is 1,000,000 DAI.\n\n8.  Next, at Line 611(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L611), the contract will increase Bob's router balance by 1,000,000 DAI\n\n9.  Bob notices that his router balance has increased by 1,000,000 DAI, and he could not resist the tempation of 1,000,000 DAI. Therefore, instead of helping Connext to repay the loan via repayAavePortal function out-of-band, he decided to quickly withdraws all his liquidty from his router.\n\n10. Bob gained 1,000,000 DAI, while Connext still owns AAVE portal 1,000,000 DAI\n\n\nIf routers decided not to repay the loan, Connext will incur large amount of debt from AAVE portal.\n\n",
                "Repair": "\nUnderstood that there is a whitelist for routers that can use portals to ensure that only trusted routers could use this feature. In this case, the trust entirely depends on the integrity of the router owner and the assumption that the owner will not act against Connext and its community. However, as seen in many of the past security incidents, trusted actor or even own protocol team member might turn rogue when dealing with significant gain. In the above example, 1,000,000 DAI. It is common to see even larger amount of funds transferring across the bridge.\n\nTherefore, to overcome the above-mentioned risk, some protocol would implement  m-of-n   multisig or validation, which help to mitigate the risk of a single trusted actor from turning rogue and perform malicious action.\n\nTherefore, it is recommended to reconsider such design and explore other alternatives. One such alternative would be as follows:\n\n Assuming that the AAVE portal interest rate is fixed, therefore, the amount of repayment is deterministic, and Connext can compute the amount of repayment that needs to be repaid at any point of time.\n\n When the BridgeFacet._reconcileProcessPortal swap or AavaPool.backUnbacked fails, do not immediately credit the Bob's router balance. Instead, escrow the amount  (1,000,000 DAI) received from nomad in an Escrow contract. Implement a function called settleAAVEPortalLoan within the Escrow contract, which contains the logic to perform the necessary actions to repay AAVE portal loan. In this case, Bob is responsible for triggering the Escrow.settleAAVEPortalLoan to kick start the out-of-band repayment process. If the repayment is sucessful, Bob's router will be credited with the earning for taking on credit risk.\n\n One positive side effect of this approach is that Bob will be incentivize to make the repayment as fast as possible because the longer he delays, the higher the interest rate, and thus less earning for him.\n\n This approach is quite similar to the withdrawal pattern.\n\nLayneHaber (Connext) acknowledged and commented(https://github.com/code-423n4/2022-06-connext-findings/issues/143#issuecomment-1167461057):\n  This is correct, and using an escrow contract would be helpful, but in general the router has no incentive ever to repay aave loans (even with this fix). This eliminates the possibility of a router profiting from the mishandling of reconcile, but doesn't address the root of the trustedness, which is embedded at the aave layer (by being able to take out unbacked loans).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {XAppConnectionManager} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {RelayerFeeRouter} from \"../../relayer-fee/RelayerFeeRouter.sol\";\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {ITokenRegistry} from \"../interfaces/ITokenRegistry.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\nimport {ConnextMessage} from \"./ConnextMessage.sol\";\nimport {SwapUtils} from \"./SwapUtils.sol\";\n\n// ============= Structs =============\n\n/**\n * @notice These are the call parameters that will remain constant between the\n * two chains. They are supplied on `xcall` and should be asserted on `execute`\n * @property to - The account that receives funds, in the event of a crosschain call,\n * will receive funds if the call fails.\n * @param to - The address you are sending funds (and potentially data) to\n * @param callData - The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\n * @param originDomain - The originating domain (i.e. where `xcall` is called). Must match nomad domain schema\n * @param destinationDomain - The final domain (i.e. where `execute` / `reconcile` are called). Must match nomad domain schema\n * @param agent - An address who can execute txs on behalf of `to`, in addition to allowing relayers\n * @param recovery - The address to send funds to if your `Executor.execute call` fails\n * @param callback - The address on the origin domain of the callback contract\n * @param callbackFee - The relayer fee to execute the callback\n * @param forceSlow - If true, will take slow liquidity path even if it is not a permissioned call\n * @param receiveLocal - If true, will use the local nomad asset on the destination instead of adopted.\n * @param relayerFee - The amount of relayer fee the tx called xcall with\n * @param slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n */\nstruct CallParams {\n  address to;\n  bytes callData;\n  uint32 originDomain;\n  uint32 destinationDomain;\n  address agent;\n  address recovery;\n  address callback;\n  uint256 callbackFee;\n  uint256 relayerFee;\n  bool forceSlow;\n  bool receiveLocal;\n  uint256 slippageTol;\n}\n\n/**\n * @notice The arguments you supply to the `xcall` function called by user on origin domain\n * @param params - The CallParams. These are consistent across sending and receiving chains\n * @param transactingAssetId - The asset the caller sent with the transfer. Can be the adopted, canonical,\n * or the representational asset\n * @param amount - The amount of transferring asset the tx called xcall with\n */\nstruct XCallArgs {\n  CallParams params;\n  address transactingAssetId; // Could be adopted, local, or wrapped\n  uint256 amount;\n}\n\n/**\n * @notice\n * @param params - The CallParams. These are consistent across sending and receiving chains\n * @param local - The local asset for the transfer, will be swapped to the adopted asset if\n * appropriate\n * @param routers - The routers who you are sending the funds on behalf of\n * @param amount - The amount of liquidity the router provided or the bridge forwarded, depending on\n * if fast liquidity was used\n * @param nonce - The nonce used to generate transfer id\n * @param originSender - The msg.sender of the xcall on origin domain\n */\nstruct ExecuteArgs {\n  CallParams params;\n  address local; // local representation of canonical token\n  address[] routers;\n  bytes[] routerSignatures;\n  uint256 amount;\n  uint256 nonce;\n  address originSender;\n}\n\n/**\n * @notice Contains RouterFacet related state\n * @param approvedRouters - Mapping of whitelisted router addresses\n * @param routerRecipients - Mapping of router withdraw recipient addresses.\n * If set, all liquidity is withdrawn only to this address. Must be set by routerOwner\n * (if configured) or the router itself\n * @param routerOwners - Mapping of router owners\n * If set, can update the routerRecipient\n * @param proposedRouterOwners - Mapping of proposed router owners\n * Must wait timeout to set the\n * @param proposedRouterTimestamp - Mapping of proposed router owners timestamps\n * When accepting a proposed owner, must wait for delay to elapse\n */\nstruct RouterPermissionsManagerInfo {\n  mapping(address => bool) approvedRouters;\n  mapping(address => bool) approvedForPortalRouters;\n  mapping(address => address) routerRecipients;\n  mapping(address => address) routerOwners;\n  mapping(address => address) proposedRouterOwners;\n  mapping(address => uint256) proposedRouterTimestamp;\n}\n\nstruct AppStorage {\n  bool initialized;\n  //\n  // ConnextHandler\n  //\n  // 0\n  uint256 LIQUIDITY_FEE_NUMERATOR;\n  // 1\n  uint256 LIQUIDITY_FEE_DENOMINATOR;\n  // The local nomad relayer fee router\n  // 2\n  RelayerFeeRouter relayerFeeRouter;\n  // The local nomad promise callback router\n  // 3\n  PromiseRouter promiseRouter;\n  // /**\n  // * @notice The address of the wrapper for the native asset on this domain\n  // * @dev Needed because the nomad only handles ERC20 assets\n  // */\n  // 4\n  IWrapped wrapper;\n  // /**\n  // * @notice Nonce for the contract, used to keep unique transfer ids.\n  // * @dev Assigned at first interaction (xcall on origin domain);\n  // */\n  // 5\n  uint256 nonce;\n  // /**\n  // * @notice The external contract that will execute crosschain calldata\n  // */\n  // 6\n  IExecutor executor;\n  // /**\n  // * @notice The domain this contract exists on\n  // * @dev Must match the nomad domain, which is distinct from the \"chainId\"\n  // */\n  // 7\n  uint256 domain;\n  // /**\n  // * @notice The local nomad token registry\n  // */\n  // 8\n  ITokenRegistry tokenRegistry;\n  // /**\n  // * @notice Mapping holding the AMMs for swapping in and out of local assets\n  // * @dev Swaps for an adopted asset <> nomad local asset (i.e. POS USDC <> madUSDC on polygon)\n  // */\n  // 9\n  mapping(bytes32 => IStableSwap) adoptedToLocalPools;\n  // /**\n  // * @notice Mapping of whitelisted assets on same domain as contract\n  // * @dev Mapping is keyed on the canonical token identifier matching what is stored in the token\n  // * registry\n  // */\n  // 10\n  mapping(bytes32 => bool) approvedAssets;\n  // /**\n  // * @notice Mapping of canonical to adopted assets on this domain\n  // * @dev If the adopted asset is the native asset, the keyed address will\n  // * be the wrapped asset address\n  // */\n  // 11\n  mapping(address => ConnextMessage.TokenId) adoptedToCanonical;\n  // /**\n  // * @notice Mapping of adopted to canonical on this domain\n  // * @dev If the adopted asset is the native asset, the stored address will be the\n  // * wrapped asset address\n  // */\n  // 12\n  mapping(bytes32 => address) canonicalToAdopted;\n  // /**\n  // * @notice Mapping to determine if transfer is reconciled\n  // */\n  // 13\n  mapping(bytes32 => bool) reconciledTransfers;\n  // /**\n  // * @notice Mapping holding router address that provided fast liquidity\n  // */\n  // 14\n  mapping(bytes32 => address[]) routedTransfers;\n  // /**\n  // * @notice Mapping of router to available balance of an asset\n  // * @dev Routers should always store liquidity that they can expect to receive via the bridge on\n  // * this domain (the nomad local asset)\n  // */\n  // 15\n  mapping(address => mapping(address => uint256)) routerBalances;\n  // /**\n  // * @notice Mapping of approved relayers\n  // * @dev Send relayer fee if msg.sender is approvedRelayer. otherwise revert()\n  // */\n  // 16\n  mapping(address => bool) approvedRelayers;\n  // /**\n  // * @notice Stores the relayer fee for a transfer. Updated on origin domain when a user calls xcall or bump\n  // * @dev This will track all of the relayer fees assigned to a transfer by id, including any bumps made by the relayer\n  // */\n  // 17\n  mapping(bytes32 => uint256) relayerFees;\n  // /**\n  // * @notice Stores the relayer of a transfer. Updated on the destination domain when a relayer calls execute\n  // * for transfer\n  // * @dev When relayer claims, must check that the msg.sender has forwarded transfer\n  // */\n  // 18\n  mapping(bytes32 => address) transferRelayer;\n  // /**\n  // * @notice The max amount of routers a payment can be routed through\n  // */\n  // 19\n  uint256 maxRoutersPerTransfer;\n  // /**\n  //  * @notice The Vault used for sponsoring fees\n  //  */\n  // 20\n  ISponsorVault sponsorVault;\n  //\n  // Router\n  //\n  // 21\n  mapping(uint32 => bytes32) remotes;\n  //\n  // XAppConnectionClient\n  //\n  // 22\n  XAppConnectionManager xAppConnectionManager;\n  //\n  // ProposedOwnable\n  //\n  // 23\n  address _proposed;\n  // 24\n  uint256 _proposedOwnershipTimestamp;\n  // 25\n  bool _routerOwnershipRenounced;\n  // 26\n  uint256 _routerOwnershipTimestamp;\n  // 27\n  bool _assetOwnershipRenounced;\n  // 28\n  uint256 _assetOwnershipTimestamp;\n  //\n  // RouterFacet\n  //\n  // 29\n  RouterPermissionsManagerInfo routerPermissionInfo;\n  //\n  // ReentrancyGuard\n  //\n  // 30\n  uint256 _status;\n  //\n  // StableSwap\n  //\n  /**\n   * @notice Mapping holding the AMM storages for swapping in and out of local assets\n   * @dev Swaps for an adopted asset <> nomad local asset (i.e. POS USDC <> madUSDC on polygon)\n   * Struct storing data responsible for automatic market maker functionalities. In order to\n   * access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\n   */\n  // 31\n  mapping(bytes32 => SwapUtils.Swap) swapStorages;\n  /**\n   * @notice Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\n   * @dev getTokenIndex function also relies on this mapping to retrieve token index.\n   */\n  // 32\n  mapping(bytes32 => mapping(address => uint8)) tokenIndexes;\n  /**\n   * @notice Stores whether or not briding, AMMs, have been paused\n   */\n  // 33\n  bool _paused;\n  //\n  // AavePortals\n  //\n  /**\n   * @notice Address of Aave Pool contract\n   */\n  address aavePool;\n  /**\n   * @notice Fee percentage numerator for using Portal liquidity\n   * @dev Assumes the same basis points as the liquidity fee\n   */\n  uint256 aavePortalFeeNumerator;\n  /**\n   * @notice Mapping to store the transfer liquidity amount provided by Aave Portals\n   */\n  mapping(bytes32 => uint256) portalDebt;\n  /**\n   * @notice Mapping to store the transfer liquidity amount provided by Aave Portals\n   */\n  mapping(bytes32 => uint256) portalFeeDebt;\n  //\n  // BridgeFacet (cont.) TODO: can we move this\n  //\n  /**\n   * @notice Stores whether a transfer has had `receiveLocal` overrides forced\n   */\n  // 34\n  mapping(bytes32 => bool) receiveLocalOverrides;\n}\n\nlibrary LibConnextStorage {\n  function connextStorage() internal pure returns (AppStorage storage ds) {\n    assembly {\n      ds.slot := 0\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only\n      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n      if (\n        !_args.params.receiveLocal &&\n        pathLen == 1 &&\n        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n        s.aavePool != address(0)\n      ) {\n        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n          revert BridgeFacet__execute_notApprovedForPortals();\n\n        // Portal provides the adopted asset so we early return here\n        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n      } else {\n        // for each router, assert they are approved, and deduct liquidity\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen; ) {\n          // decrement routers liquidity\n          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n          unchecked {\n            i++;\n          }\n        }\n      }\n    }\n\n    // if the local asset is specified, or the adopted asset was overridden (i.e. when\n    // user facing slippage conditions outside of their boundaries), exit\n    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {\n      return (toSwap, _args.local);\n    }\n\n    // swap out of mad* asset into adopted asset if needed\n    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amount,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // If the domain if sponsored\n    if (address(s.sponsorVault) != address(0)) {\n      // fast liquidity path\n      if (!_reconciled) {\n        // Vault will return the amount of the fee they sponsored in the native fee\n        // NOTE: some considerations here around fee on transfer tokens and ensuring\n        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n        // balance read about it\n\n        uint256 starting = IERC20(_asset).balanceOf(address(this));\n        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);\n\n        // Validate correct amounts are transferred\n        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n        }\n\n        _amount = _amount + sponsored;\n      }\n\n      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n      // then the vault should just pay out the configured constant\n      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);\n    }\n\n    // execute the the transaction\n    if (keccak256(_args.params.callData) == EMPTY) {\n      // no call data, send funds to the user\n      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);\n    } else {\n      // execute calldata w/funds\n      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);\n      (bool success, bytes memory returnData) = s.executor.execute(\n        IExecutor.ExecutorArgs(\n          _transferId,\n          _amount,\n          _args.params.to,\n          _args.params.recovery,\n          _asset,\n          _reconciled\n            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)\n            : LibCrossDomainProperty.EMPTY_BYTES,\n          _args.params.callData\n        )\n      );\n\n      // If callback address is not zero, send on the PromiseRouter\n      if (_args.params.callback != address(0)) {\n        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);\n      }\n    }\n\n    return _amount;\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    uint256 _fastTransferAmount,\n    address _local,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));\n\n    // Store principle debt\n    s.portalDebt[_transferId] = userAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * userAmount) / s.LIQUIDITY_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, userAmount);\n\n    return (userAmount, adopted);\n  }\n\n  /**\n   * @notice Parses the message and process the transfer\n   * @dev Will mint the tokens if the token originates on a remote origin\n   * @return The message amount\n   * @return The message token\n   * @return The message transfer id\n   */\n  function _reconcileProcessMessage(bytes memory _message)\n    internal\n    returns (\n      uint256,\n      address,\n      bytes32\n    )\n  {\n    // parse tokenId and action from message\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // load the transferId\n    bytes32 transferId = action.transferId();\n\n    // ensure the transaction has not been handled\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // assert the action is valid\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // get the token contract for the given tokenId on this chain\n    // (if the token is of remote origin and there is\n    // no existing representation token contract, the TokenRegistry will\n    // deploy a new one)\n    bytes32 canonical = tokenId.id();\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), canonical);\n\n    // load amount once\n    uint256 amount = action.amnt();\n\n    // NOTE: tokenId + amount must be in plaintext in message so funds can\n    // *only* be minted by `handle`. They are still used in the generation of\n    // the transferId so routers must provide them correctly to be reimbursed\n\n    bytes32 details = action.detailsHash();\n\n    // if the token is of remote origin, mint the tokens. will either\n    // - be credited to router (fast liquidity)\n    // - be reserved for execution (slow liquidity)\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n      // Tell the token what its detailsHash is\n      IBridgeToken(token).setDetailsHash(details);\n    }\n    // NOTE: if the token is of local origin, it means it was escrowed\n    // in this contract at xcall\n\n    // mark the transfer as reconciled\n    s.reconciledTransfers[transferId] = true;\n\n    return (amount, token, transferId);\n  }\n\n  /**\n   * @notice Repays to Aave Portal if the transfer was executed with fast path using Portal liquidity\n   * @param _amount - The amount passed through bridge\n   * @param _local - The local  asset\n   * @param _router - The router who took on portal risk\n   * @param _transferId - The transfer identifier\n   * @return The amount to distribute amongst the routers after repayment\n   */\n  function _reconcileProcessPortal(\n    uint256 _amount,\n    address _local,\n    address _router,\n    bytes32 _transferId\n  ) private returns (uint256) {\n    // When repaying a portal, should use available liquidity if there is not enough balance from\n    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly\n    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt\n    // repayment back into local asset to credit routers\n\n    // Calculates the amount to be repaid to the portal in adopted asset\n    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(\n      _amount,\n      _transferId,\n      _local\n    );\n\n    // Update the debt amounts before swapping\n    s.portalDebt[_transferId] -= backUnbackedAmount;\n    s.portalFeeDebt[_transferId] -= portalFee;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount\n    // as the slippage ceiling\n    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)\n    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us\n    // handle the case where slippage was hit\n    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalRepayAmount,\n      _amount\n    );\n    if (!swapSuccess) {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n      // Emit debt event of full portal value and exit\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n      return (_amount);\n    }\n\n    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.\n    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.\n    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?\n    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n    (bool success, ) = s.aavePool.call(\n      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)\n    );\n\n    if (success) {\n      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);\n    } else {\n      // Reset values\n      s.portalDebt[_transferId] += backUnbackedAmount;\n      s.portalFeeDebt[_transferId] += portalFee;\n\n      // Decrease the allowance\n      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);\n\n      // Update the amount repaid to 0, so the amount is credited to the router\n      amountIn = 0;\n      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);\n    }\n\n    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.\n    // Someone can repay more than it should, so then a the moment of calling backUnbacked()\n    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned\n    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121\n    // If we wanted to handle this difference, we should check the balance before and after calling\n    // `backUnbacked` and credit the difference to the router\n\n    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)\n    // where router has gained extra because of the AMM, these funds should be distributed.\n    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be\n    // <= _amount (i.e. this will be +ive)\n    return (_amount - amountIn);\n  }\n\n  /**\n   * @notice Calculates the amount to be repaid to Aave Portal in adopted asset. If there is no enough amount to repay\n   * the unbacked and the fee, it will partially repay prioritizing the unbacked amount.\n   * @dev Assumes the fee is proportional to the unbackedAmount.\n   * @param _localAmount - The available balance for a repayment\n   * @param _transferId - The unique identifier of the crosschain transaction\n   * @param _local - The address of the adopted asset that needs to be backed\n   * @return The total amount to be repaid\n   * @return The unbacked amount to be backed\n   * @return The fee amount to be paid\n   */\n  function _calculatePortalRepayment(\n    uint256 _localAmount,\n    bytes32 _transferId,\n    address _local\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 portalFee = s.portalFeeDebt[_transferId];\n    uint256 backUnbackedAmount = s.portalDebt[_transferId];\n    uint256 totalRepayAmount = backUnbackedAmount + portalFee;\n    // see how much of local asset you would have available post-swap\n    (uint256 availableAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _localAmount);\n\n    // If not enough funds to repay the transfer + fees\n    // try to repay as much as unbacked as possible\n    if (totalRepayAmount > availableAmount) {\n      uint256 backUnbackedDebt = backUnbackedAmount;\n      uint256 portalFeeDebt = portalFee;\n\n      if (availableAmount > backUnbackedAmount) {\n        // Repay the whole transfer and a partial amount of fees\n        portalFee = availableAmount - backUnbackedAmount;\n\n        backUnbackedDebt = 0;\n        portalFeeDebt -= portalFee;\n      } else {\n        // Repay a partial amount of the transfer and no fees\n        backUnbackedAmount = availableAmount;\n        portalFee = 0;\n\n        backUnbackedDebt -= backUnbackedAmount;\n      }\n\n      totalRepayAmount = backUnbackedAmount + portalFee;\n\n      emit AavePortalRepaymentDebt(_transferId, adopted, backUnbackedDebt, portalFeeDebt);\n    }\n\n    return (totalRepayAmount, backUnbackedAmount, portalFee);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {ITokenRegistry} from \"../interfaces/ITokenRegistry.sol\";\n\ncontract AssetFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error AssetFacet__setWrapper_invalidWrapper();\n  error AssetFacet__setTokenRegistry_invalidTokenRegistry();\n  error AssetFacet__addAssetId_alreadyAdded();\n  error AssetFacet__removeAssetId_notAdded();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when the wrapper variable is updated\n   * @param oldWrapper - The wrapper old value\n   * @param newWrapper - The wrapper new value\n   * @param caller - The account that called the function\n   */\n  event WrapperUpdated(address oldWrapper, address newWrapper, address caller);\n\n  /**\n   * @notice Emitted when the tokenRegistry variable is updated\n   * @param oldTokenRegistry - The tokenRegistry old value\n   * @param newTokenRegistry - The tokenRegistry new value\n   * @param caller - The account that called the function\n   */\n  event TokenRegistryUpdated(address oldTokenRegistry, address newTokenRegistry, address caller);\n\n  /**\n   * @notice Emitted when a new stable-swap AMM is added for the local <> adopted token\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param swapPool - The address of the AMM\n   * @param caller - The account that called the function\n   */\n  event StableSwapAdded(bytes32 canonicalId, uint32 domain, address swapPool, address caller);\n\n  /**\n   * @notice Emitted when a new asset is added\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param adoptedAsset - The address of the adopted (user-expected) asset\n   * @param supportedAsset - The address of the whitelisted asset. If the native asset is to be whitelisted,\n   * the address of the wrapped version will be stored\n   * @param caller - The account that called the function\n   */\n  event AssetAdded(bytes32 canonicalId, uint32 domain, address adoptedAsset, address supportedAsset, address caller);\n\n  /**\n   * @notice Emitted when an asset is removed from whitelists\n   * @param canonicalId - The canonical identifier of the token removed\n   * @param caller - The account that called the function\n   */\n  event AssetRemoved(bytes32 canonicalId, address caller);\n\n  // ============ Getters ============\n\n  function canonicalToAdopted(bytes32 _canonicalId) public view returns (address) {\n    return s.canonicalToAdopted[_canonicalId];\n  }\n\n  function adoptedToCanonical(address _adopted) public view returns (ConnextMessage.TokenId memory) {\n    ConnextMessage.TokenId memory canonical = ConnextMessage.TokenId(\n      s.adoptedToCanonical[_adopted].domain,\n      s.adoptedToCanonical[_adopted].id\n    );\n    return canonical;\n  }\n\n  function approvedAssets(bytes32 _asset) public view returns (bool) {\n    return s.approvedAssets[_asset];\n  }\n\n  function adoptedToLocalPools(bytes32 _adopted) public view returns (IStableSwap) {\n    return s.adoptedToLocalPools[_adopted];\n  }\n\n  function wrapper() public view returns (IWrapped) {\n    return s.wrapper;\n  }\n\n  function tokenRegistry() public view returns (ITokenRegistry) {\n    return s.tokenRegistry;\n  }\n\n  // ============ Admin functions ============\n\n  /**\n   * @notice Updates the native-asset wrapper interface\n   * @param _wrapper The address of the new wrapper\n   */\n  function setWrapper(address _wrapper) external onlyOwner {\n    address old = address(s.wrapper);\n    if (old == _wrapper || !Address.isContract(_wrapper)) revert AssetFacet__setWrapper_invalidWrapper();\n\n    s.wrapper = IWrapped(_wrapper);\n    emit WrapperUpdated(old, _wrapper, msg.sender);\n  }\n\n  /**\n   * @notice Updates the token registry\n   * @param _tokenRegistry The new token registry address\n   */\n  function setTokenRegistry(address _tokenRegistry) external onlyOwner {\n    address old = address(s.tokenRegistry);\n    if (old == _tokenRegistry || !Address.isContract(_tokenRegistry))\n      revert AssetFacet__setTokenRegistry_invalidTokenRegistry();\n\n    s.tokenRegistry = ITokenRegistry(_tokenRegistry);\n    emit TokenRegistryUpdated(old, _tokenRegistry, msg.sender);\n  }\n\n  /**\n   * @notice Used to add supported assets. This is an admin only function\n   * @dev When whitelisting the canonical asset, all representational assets would be\n   * whitelisted as well. In the event you have a different adopted asset (i.e. PoS USDC\n   * on polygon), you should *not* whitelist the adopted asset. The stable swap pool\n   * address used should allow you to swap between the local <> adopted asset\n   * @param _canonical - The canonical asset to add by id and domain. All representations\n   * will be whitelisted as well\n   * @param _adoptedAssetId - The used asset id for this domain (i.e. PoS USDC for\n   * polygon)\n   */\n  function setupAsset(\n    ConnextMessage.TokenId calldata _canonical,\n    address _adoptedAssetId,\n    address _stableSwapPool\n  ) external onlyOwner {\n    // Sanity check: needs approval\n    if (s.approvedAssets[_canonical.id]) revert AssetFacet__addAssetId_alreadyAdded();\n\n    // Update approved assets mapping\n    s.approvedAssets[_canonical.id] = true;\n\n    address supported = _adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId;\n\n    // Update the adopted mapping\n    s.adoptedToCanonical[supported].domain = _canonical.domain;\n    s.adoptedToCanonical[supported].id = _canonical.id;\n\n    // Update the canonical mapping\n    s.canonicalToAdopted[_canonical.id] = supported;\n\n    // Emit event\n    emit AssetAdded(_canonical.id, _canonical.domain, _adoptedAssetId, supported, msg.sender);\n\n    // Add the swap pool\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Adds a stable swap pool for the local <> adopted asset.\n   */\n  function addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwapPool) external onlyOwner {\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Used to remove assets from the whitelist\n   * @param _canonicalId - Token id to remove\n   * @param _adoptedAssetId - Corresponding adopted asset to remove\n   */\n  function removeAssetId(bytes32 _canonicalId, address _adoptedAssetId) external onlyOwner {\n    // Sanity check: already approval\n    if (!s.approvedAssets[_canonicalId]) revert AssetFacet__removeAssetId_notAdded();\n\n    // Delete from approved assets mapping\n    delete s.approvedAssets[_canonicalId];\n\n    // Delete from pools\n    delete s.adoptedToLocalPools[_canonicalId];\n\n    // Delete from adopted mapping\n    delete s.adoptedToCanonical[_adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId];\n\n    // Delete from canonical mapping\n    delete s.canonicalToAdopted[_canonicalId];\n\n    // Emit event\n    emit AssetRemoved(_canonicalId, msg.sender);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Used to add an AMM for adopted <> local assets\n   * @param _canonical - The canonical TokenId to add (domain and id)\n   * @param _stableSwap - The address of the amm to add\n   */\n  function _addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwap) internal {\n    // Update the pool mapping\n    s.adoptedToLocalPools[_canonical.id] = IStableSwap(_stableSwap);\n\n    emit StableSwapAdded(_canonical.id, _canonical.domain, _stableSwap, msg.sender);\n  }\n}\n\n\n",
        "CodeNames": [
            "LibConnextStorage.sol",
            "BridgeFacet.sol",
            "AssetFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\nstruct ExecuteArgs {\n  CallParams params;\n  address local; // local representation of canonical token\n  address[] routers;\n  bytes[] routerSignatures;\n  uint256 amount;\n  uint256 nonce;\n  address originSender;\n}\n",
                    "//solidity\n// Derive transfer ID based on given arguments.\nbytes32 transferId = _getTransferId(_args);\n",
                    "//solidity\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n"
                ],
                "Type": " Malicious Relayer can Replay Execute Calldata on Different Chains Causing Double-Spend Issue",
                "Description": "\nBridgeFacet.sol#L411(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411)<br\n\n This issue is only applicable for fast-transfer. Slow transfer would not have this issue because of the built-in fraud-proof mechanism in Nomad.\n\nFirst, the attacker will attempt to use Connext to send 1000 USDC from Ethereum domain to Optimism domain.\n\nAssume that the attacker happens to be a relayer on the relayer network utilised by Connext, and the attacker's relayer happens to be tasked to relay the above execute calldata to the Optimism's Connext BridgeFacet.execute(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function.\n\nOptimism's Connext BridgeFacet.execute received the execute calldata and observed within the calldata that it is a fast-transfer and Router A is responsible for providing the liquidity. It will then check that the router signature is valid, and proceed to transfer 1000 oUSDC to attacker wallet (0x123456) in Optimism.\n\nNext, attacker will update the ExecuteArgs.local within the execute calldata to a valid local representation of canonical token (USDC) used within Polygon. Attacker will then send the modified execute calldata to Polygon's Connext BridgeFacet.execute function. Assume that the same Router A is also providing liquidity in Polygon. The BridgeFacet.execute function checks that the router signature is valid, and proceed to transfer 1000 POS-USDC to atttack wallet (0x123456) in Polygon.\n\nAt this point, the attacker has 1000 oUSDC and 1000 POS-USDC in his wallets. When the nomad message arrives at Optimism, Router A can claim the 1000 oUSDC back from Connext. However, Router A is not able to claim back any fund in Polygon.\n\nNote that same wallet address exists on different chains. For instance, the wallet address on Etherum and Polygon is the same.\n\n\nThis is because the router signature is generated from the transferId + pathLength only, and these data are stored within the CallParams params within the ExecuteArgs struct.\n\nLibConnextStorage.sol#L77(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77)<br\n\nsolidity\nstruct ExecuteArgs {\n  CallParams params;\n  address local; // local representation of canonical token\n  address[] routers;\n  bytes[] routerSignatures;\n  uint256 amount;\n  uint256 nonce;\n  address originSender;\n}\n\n\nWithin the BridgeFacet._executeSanityChecks(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function, it will attempt to rebuild to transferId by calling the following code:\n\nsolidity\n// Derive transfer ID based on given arguments.\nbytes32 transferId = _getTransferId(_args);\n\n\nWithin the BridgeFacet._getTransferId(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719) function, we can see that the s.tokenRegistry.getTokenId(_args.local) will always return the canonical tokenDomain and tokenId. In our example, it will be Ethereum and  USDC. Therefore, as long as the attacker specify a valid local representation of canonical token on a chain, the transferId returned by s.tokenRegistry.getTokenId(_args.local) will always be the same across all domains. Thus, this allows the attacker to modify the ExecuteArgs.local and yet he could pass the router signature check.\n\n  BridgeFacet.sol#L719(https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719)<br\n\nsolidity\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n\n\nRouter liquidity would be drained by attacker, and affected router owner could not claim back their liquidity.\n\n",
                "Repair": "\nThe security of the current Connext design depends on how secure or reliable the relayer is. If the relayer turns rouge or acts against Connext, many serious consequences can happen.\n\nThe root cause is that the current design places enormous trust on the relayers to accurately and reliably to deliver calldata to the bridge in various domains. For instance, delivering of execute call data to execute function. There is an attempt to prevent message replay on a single domain, however, it does not prevent message replay across multiple domains. Most importantly, the Connext's bridge appears to have full trust on the calldata delivered by the relayer. However, the fact is that the calldata can always be altered by the relayer.\n\nConsider a classic 0x off-chain ordering book protocol. A user will sign his order with his private key, and attach the signature to the order, and send the order (with signature) to the relayer network. If the relayer attempts to tamper the order message or signature, the decoded address will be different from the signer's address and this will be detected by 0x's Smart contract on-chain when processing the order. This ensures that the integrity of the message and signer can be enforced.\n\nPer good security practice, relayer network should always be considered as a hostile environment/network. Therefore, it is recommended that similar approach could be taken with regards to passing execute calldata across domains/chains.\n\nFor instance, at a high level, the sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. This will ensure the intergrity of the execute calldata and prevent any issue that arise due to unauthorised modification of calldata.\n\nAdditionally, the execute calldata should also have a field that correspond to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains. This also helps to prevent the attack mentioned earlier where same execute calldata can be accepted in different domains.\n\nLayneHaber (Connext) confirmed and commented(https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1166344934):\n  Agree that this is an issue, but disagree with the framing and mitigation.\n \n The calldata is included in the generation of the transferId via the CallParams, so it cannot be easily manipulated by the relayer network once signed by routers. However, because you are not validating the s.domain against the CallParams.destinationDomain you can use the same transfer data across multiple chains, which is a big problem.\n\nLayneHaber (Connext) resolved(https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1167499043):\n  connext/nxtp@bc241f8(https://github.com/connext/nxtp/pull/1450/commits/bc241f8d9ca5ca7d9598c7b40affa9a416580cc6)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1214813364):\n  This seems like the most severe finding of the entire contest. Kudos to the warden on a great find!\n \n Because transfer data is replicated across multiple chains, relayers are also able to execute data on each chain. If _executeSanityChecks does not check that the message's destination chain matches s.domain, then transfers could be spent on all available chains.\n\n  Interestingly, because the remote router is included in the message, only the correct destination chain will be able to reconcile the transfer and reimburse routers for providing liquidity. Hence, the issue is only prevalent on other chains if routers readily bid on incoming transfers, which seems possible because signatures can be replayed on other chains. So if the same set of routers have sufficient liquidity on another chain, the relayer can execute this message again to create a double spend issue.\n\n  Another point to add, this issue would only be prevalent on chains which have its local asset pointing to the same address as this is what the bridge will attempt to transfer to the recipient. Additionally, in order for the relayer to replay a router's signature, the transferId must exactly match the transferId on the intended destination chain. This is only possible if TokenRegistry.getTokenId returns the same canonical domain and ID values.\n\n  It would be good to confirm this. Is it possible for a local asset to be registered to the same canonical domain and ID on multiple chains?\n\nLayneHaber (Connext) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1218305324):\n   Is it possible for a local asset to be registered to the same canonical domain and ID on multiple chains?\n \n Yes, that is actually the purpose of the canonicalId and canonicalDomain -there should only be one canonical (locked) token that maps to any number of local (minted) instances.\n \n This issue is valid, and enforcing in _executeSanityChecks it is only executed on the destination domain should prevent this attack, correct?\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1218349487):\n Okay great! Because local assets map to the same canonical domain and ID on each chain, I think this issue is most definitely valid. _args.local is not used to calculate transferId, hence the representation for each asset may differ on each chain but the TokenRegistry.getTokenId should return the correct information.\n \n I can confirm that the enforcing check in _executeSanityChecks should ensure that transfer data is only executed on the intended destination domain.\n\n\n\n*\n \n\n"
            }
        ]
    }
]