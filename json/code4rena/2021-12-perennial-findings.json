[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../utils/unstructured/UReentrancyGuard.sol\";\nimport \"../factory/UFactoryProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UFactoryProvider, UReentrancyGuard {\n    using UFixed18Lib for UFixed18;\n    using Token18Lib for Token18;\n    using OptimisticLedgerLib for OptimisticLedger;\n\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public token;\n\n    /// @dev Fee on maintenance for liquidation\n    UFixed18 public liquidationFee;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the contract state\n     * @param factory_ Factory contract address\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    function initialize(IFactory factory_, Token18 token_) external {\n        UFactoryProvider__initialize(factory_);\n        UReentrancyGuard__initialize();\n\n        token = token_;\n        liquidationFee = UFixed18Lib.ratio(50, 100);\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    notPaused\n    collateralInvariant(account, product)\n    external {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `account`\n     * @param account Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address account, IProduct product, UFixed18 amount)\n    notPaused\n    collateralInvariant(msg.sender, product)\n    maintenanceInvariant(msg.sender, product)\n    external {\n        _products[product].debitAccount(msg.sender, amount);\n        token.push(account, amount);\n\n        emit Withdrawal(msg.sender, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product) notPaused nonReentrant external {\n        // settle\n        product.settle();\n        product.settleAccount(account);\n\n        // liquidate\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, totalMaintenance.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        address protocolTreasury = factory().treasury();\n        address productTreasury = factory().treasury(product);\n\n        UFixed18 protocolFee = amount.mul(factory().fee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) public view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) public view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) notPaused external {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() notPaused external {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /**\n     * @notice Updates the liquidation fee\n     * @param newLiquidationFee New liquidation fee\n     */\n    function updateLiquidationFee(UFixed18 newLiquidationFee) onlyOwner external {\n        liquidationFee = newLiquidationFee;\n        emit LiquidationFeeUpdated(newLiquidationFee);\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the account is either empty or above the collateral minimum\n    modifier collateralInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 accountCollateral = collateral(account, product);\n        if (!accountCollateral.isZero() && accountCollateral.lt(factory().minCollateral()))\n            revert CollateralUnderLimitError();\n    }\n}\n\n\n",
        "CodeNames": [
            "Collateral.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\ninternal returns (UFixed18 shortfall) {\n    Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n    if (newBalance.sign() == -1) {\n        shortfall = self.shortfall.add(newBalance.abs());\n        newBalance = Fixed18Lib.ZERO;\n    }\n\n    self.balances[account] = newBalance.abs();\n    self.shortfall = self.shortfall.add(shortfall);\n}\n",
                    "js\nawait collateral.connect(productSigner).settleAccount(userB.address, -50)\n"
                ],
                "Type": " Wrong shortfall calculation",
                "Description": "\nEvery time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.\n\n\nLoss of funds: users won't be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.\n\n\nWe can see in the settleAccount of OptimisticLedger that self.shortfall ends up being self.shortfall+self.shortfall+newShortfall: (Code ref)(https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/types/OptimisticLedger.sol#L63:#L74)\n\nsolidity\nfunction settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\ninternal returns (UFixed18 shortfall) {\n    Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n    if (newBalance.sign() == -1) {\n        shortfall = self.shortfall.add(newBalance.abs());\n        newBalance = Fixed18Lib.ZERO;\n    }\n\n    self.balances[account] = newBalance.abs();\n    self.shortfall = self.shortfall.add(shortfall);\n}\n\n\nAdditionally, you can add the following line to the \"shortfall reverts if depleted\" test in Collateral.test.js, line 190:\n\njs\nawait collateral.connect(productSigner).settleAccount(userB.address, -50)\n\n\nPreviously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.\n\n",
                "Repair": "\nMove the setting of self.shortfall to inside the if function and change the line to:\n\n    self.shortfall = shortfall\n \n\nkbrizzle (Perennial) confirmed(https://github.com/code-423n4/2021-12-perennial-findings/issues/18#issuecomment-995416504):\n  Excellent find \ud83d\ude4f \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/18#issuecomment-1001280292):\n  Agree with the finding shortfall = self.shortfall.add(newBalance.abs()); is already shortfal + newBalance.abs()\n So performing line 73 self.shortfall = self.shortfall.add(shortfall); is adding\u00a0shortfall again\n\n\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction withdrawTo(address account, IProduct product, UFixed18 amount)\nnotPaused\ncollateralInvariant(msg.sender, product)\nmaintenanceInvariant(msg.sender, product)\nexternal {\n    _products[product].debitAccount(msg.sender, amount);\n    token.push(account, amount);\n\n    emit Withdrawal(msg.sender, product, amount);\n}\n",
                    "//solidity\nmodifier maintenanceInvariant(address account, IProduct product) {\n    _;\n\n    UFixed18 maintenance = product.maintenance(account);\n    UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n    if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n        revert CollateralInsufficientCollateralError();\n}\n",
                    "//solidity\nfunction maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {\n    Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());\n    UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();\n    return notionalMax.mul(provider.maintenance());\n}\n"
                ],
                "Type": "  withdrawTo  Does Not Sync Before Checking A Position's Margin Requirements",
                "Description": "\n\nThe maintenanceInvariant modifier in Collateral aims to check if a user meets the margin requirements to withdraw collateral by checking its current and next maintenance. maintenanceInvariant inevitably calls AccountPosition.maintenance which uses the oracle's price to calculate the margin requirements for a given position. Hence, if the oracle has not synced in a long time, maintenanceInvariant may end up utilising an outdated price for a withdrawal. This may allow a user to withdraw collateral on an undercollaterized position.\n\n\n<https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L67-L76\n\nsolidity\nfunction withdrawTo(address account, IProduct product, UFixed18 amount)\nnotPaused\ncollateralInvariant(msg.sender, product)\nmaintenanceInvariant(msg.sender, product)\nexternal {\n    _products[product].debitAccount(msg.sender, amount);\n    token.push(account, amount);\n\n    emit Withdrawal(msg.sender, product, amount);\n}\n\n<https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L233-L241\nsolidity\nmodifier maintenanceInvariant(address account, IProduct product) {\n    _;\n\n    UFixed18 maintenance = product.maintenance(account);\n    UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n    if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n        revert CollateralInsufficientCollateralError();\n}\n\n<https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/types/position/AccountPosition.sol#L71-L75\nsolidity\nfunction maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {\n    Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());\n    UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();\n    return notionalMax.mul(provider.maintenance());\n}\n\n\nManual code review.\n\n",
                "Repair": "\nConsider adding settleForAccount(msg.sender) to the Collateral.withdrawTo function to ensure the most up to date oracle price is used when assessing an account's margin requirements.\n\nkbrizzle (Perennial) confirmed(https://github.com/code-423n4/2021-12-perennial-findings/issues/74#issuecomment-996589429):\n  Great catch \ud83d\ude4f \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/74#issuecomment-1001590562):\n  With most onChain protocols where there is potential for undercollateralized positions and liquidations, it is very important to accrue a user position before making any changes to their balance.\n \n The warden identified a potential way for a user to withdraw funds while their account is below margin requirements.\n \n Because this impacts the core functionality functionality of the protocol (accounting), I'm raising the severity to high\n \n Mitigation seems to be straightforward\n\n\n\n \n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "product"
                ],
                "Type": " No checks if given product is created by the factory",
                "Description": "\nAn attacker can create a fake product. Collateral contract does not check whether the given product is created by the factory. A malicious product can return arbitrary maintenance amounts, therefore they can make any deposit to fake product stuck (simply return collateral 1 as maintenance) and fake product owner can change the maintenance and liquidate whenever wanted and claim full collateral.\n\nThis is a serious attack vector, since by only interacting with Collateral contract the user can lose funds. Furthermore, this vulnerability poses big risks in combination web vulnerabilities. Users always have to check the product address to avoid getting scammed, but likely most users will only check the contract address.\n\nFurthermore, if another protocol would want to add perennial protocol for its use case, the other protocol has to be careful with this behaviour and keep track of whitelisted products. This complicates adoption of perennial protocol, since whitelist has to be managed manually or else this vulnerability will likely be exploitable.\n\n\nAdd a mapping inside Collateral, which verifies whether a product is created by factory or not. This mapping should get updated by the factory. This will add a little bit gas cost, but will eliminate a serious attack vector.\n\nOr less gas efficient option is directly call a function from factory to verify.\n\nkbrizzle (Perennial) disagreed with severity(https://github.com/code-423n4/2021-12-perennial-findings/issues/63#issuecomment-997158601):\n  Good find \ud83d\ude4f \n \n On severity: In general there's a whole plethora of ways a Product owner could create a product that harmful a user which choses to take part in it. The design model of Perennial is to give the Product owners the *freedom* to create risky products, but to segregate that risk to only those products, and this issue does not break this segregation of risk. This is especially important during our gated-beta phase while we learn which levers are worth it to lock down. \n \n That being said this is low hanging fruit to correct, so we think it should still be 2 (Medium) severity.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/63#issuecomment-1001284165):\n  Given the extensible nature of the Collateral contract, users can call the contract with any user input for product this could be used maliciously against the users as the warden highlighted.\n \n This can definitely happen, but is contingent on a set of external factors, so I think medium severity is more appropriate\n\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-02",
                "Location": [
                    "initialize"
                ],
                "Type": " Multiple initialization of Collateral contract",
                "Description": "\n\nThe attacker can initialize the contract, take malicious actions, and allow it to be re-initialized by the project without any error being noticed.\n\n\nThe initialize method of the  Collateral  contract does not contain the initializer modifier, it delegates this process to check if the factory is different from address(0) in the  UFactoryProvider__initialize  call, however the  factory_  is other than address(0), so an attacker could use front-running by listening to the memory pool, initialize the contract with a factory=address(0), perform malicious actions, and still allow it to be started later by the I draft the contract without noticing any error.\n\nSource reference:\n\n*   Collateral.initialize\n\n\nManual review\n\n",
                "Repair": "\nUse initializer modifier\n\nkbrizzle (Perennial) marked as duplicate(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-995339471):\n  Duplicate of: https://github.com/code-423n4/2021-12-perennial-findings/issues/71\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-1001284802):\n  Disagree with sponsor that this is duplicate of #73 \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-1001285612):\n  The finding mentions that initialize can be called multiple times, specifically by first having factory set to address(0) and then setting it to it's final value.\n \n This is true.\n \n Calling initialize multiple times could allow to set certain values up with a different token, then change to another token and set the factory. This could be used to trick the protocol accounting to later take advantage of other depositors.\n \n \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-1001285964):\n  The specific vulnerability is the lack of the  initializer modifier on initialize, the consequences  can be problematic only if a malicious actor were to set the contracts up.\n \n Because this can be done, and it's reliant on a specific setup, I'll mark the finding as medium severity, mitigation is straightforward\n\nkbrizzle (Perennial) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-1001294139):\n  My understanding of these is that:\n \n #73 would allow an attacker to front-run the initialization of a contract to gain admin, but the subsequent legitimate attempt to initialize would revert.\n #13 would allow an attacker to front-run the initialization of a contract to gain admin, and the subsequent legitimate attempt to initialize would still work (thereby possibly going unnoticed).\n \n If we want to tag these as separate issues, I think that makes sense as the effects are slightly different. Both are ultimately a documentation issue though solved by this remediation(https://github.com/code-423n4/2021-12-perennial-findings/issues/71#issuecomment-995343823), so I'm wondering why one is tagged as 0 (Non-critical) and the other 2 (Medium).\n \n Is that correct, or is there an issue here even *with* proper atomic deploy-and-initialize usage with OZ's upgrades plugin? Just want to make sure we're not missing something else here. Also we do not have an initializer modifier available in the code base, so the remediation suggestion was a little confusing.\n \n \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-1001296121):\n  @kbrizzle Yes, this is something that can still be done, arguably only by your deployer\n \n You could deploy and initialize the contract with factory set to 0, use that to perform operations with a token you created (so it has no cost to you), then initialize again with factory set to the proper value\n \n Because certain functions do not check for the product being created by the factory, this can be done as a way to lay the ground for a rug against future depositors\n \n So to my eyes this finding highlights the consequences of a lack of the initializer modifier, while the other is the usual initializer can be frontrun non critical finding\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-1001299037):\n  @kbrizzle to clarify: you won't be frontrun with your deployment as the deploy + initialize is done in one tx.\n But the Collateral\u00a0 not having initializer can be used by the deployer for malicious purposes because what was perceived as an unchangeable token can actually be changed if you set up initialize with the factory address set to 0\n\nkbrizzle (Perennial) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-1001301453):\n  @Alex the Entreprenerd I see, that makes sense from the perspective of the token seeming like it should be immutable \ud83d\udc4d \n \n FWIW in this scenario the deployer would have to run the risk of someone else initializing and taking admin for the duration that the malicious initial token was active so I'm not sure how feasible that would be.\n \n That being said, I think a UInitializable would be a great addition to our lib anyways, so let's go this route since this does seem like a solution with better guarantees. Thanks for the explanation!\n \n \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/13#issuecomment-1001304373):\n  The attack is dependent upon external conditions (malicious deployer, nobody else calling initialize, setting up malicious accounting), for that reason (as per the docs) I believe medium severity to be proper.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../utils/types/UFixed18.sol\";\nimport \"../utils/unstructured/UOwnable.sol\";\n\n/**\n * @title ChainlinkOracle\n * @notice Chainlink implementation of the IOracle interface.\n * @dev One instance per Chainlink price feed should be deployed. Multiple products may use the same\n *      ChainlinkOracle instance if their payoff functions are based on the same underlying oracle.\n */\ncontract ChainlinkOracle is IOracle, UOwnable {\n\n    event MinDelayUpdated(uint256 newMinDelay);\n\n    /// @dev Chainlink price feed to read from\n    IChainlinkFeed public feed;\n\n    /// @dev Mapping of historical price at each oracle version\n    Fixed18[] public priceAtVersion;\n\n    /// @dev Mapping of historical timestamp at each oracle version\n    uint256[] public timestampAtVersion;\n\n    /// @dev Decimal offset used to normalize chainlink price to 18 decimals\n    uint256 private _decimalOffset;\n\n    /// @dev Minimum timestamp delay before committed a new version\n    uint256 public minDelay;\n\n    /**\n     * @notice Initializes the contract state\n     * @param feed_ Chainlink price feed\n     */\n    constructor(IChainlinkFeed feed_) {\n        feed = feed_;\n        _decimalOffset = 10 ** feed_.decimals();\n        minDelay = 30 minutes;\n\n        sync();\n        UOwnable__initialize();\n    }\n\n    /**\n     * @notice Checks for a new price and updates the oracle version if one is found\n     */\n    function sync() public {\n        (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();\n        Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));\n\n        if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {\n            priceAtVersion.push(price);\n            timestampAtVersion.push(timestamp);\n\n            emit Version(currentVersion(), timestamp, price);\n        }\n    }\n\n    /**\n     * @notice Returns the current oracle version\n     * @return Current oracle version\n     */\n    function currentVersion() public view returns (uint256) {\n        return priceAtVersion.length - 1;\n    }\n\n    /**\n     * @notice Updates the minimum delay before a new version can be committed\n     * @param newMinDelay New minimum delay\n     */\n    function updateMinDelay(uint256 newMinDelay) onlyOwner external {\n        minDelay = newMinDelay;\n        emit MinDelayUpdated(newMinDelay);\n    }\n}\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestRoundData() external view returns (\n        uint80 roundID,\n        int price,\n        uint startedAt,\n        uint timeStamp,\n        uint80 answeredInRound\n    );\n}\n\n\n",
        "CodeNames": [
            "ChainlinkOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nfunction sync() public {\n    (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();\n    Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));\n\n    if (priceAtVersion.length == 0 || timestamp  timestampAtVersion[currentVersion()] + minDelay) {\n        priceAtVersion.push(price);\n        timestampAtVersion.push(timestamp);\n\n        emit Version(currentVersion(), timestamp, price);\n    }\n}\n"
                ],
                "Type": " Chainlink's  latestRoundData  might return stale or incorrect results",
                "Description": "\n<https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60\n\nsolidity\nfunction sync() public {\n    (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();\n    Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));\n\n    if (priceAtVersion.length == 0 || timestamp  timestampAtVersion[currentVersion()] + minDelay) {\n        priceAtVersion.push(price);\n        timestampAtVersion.push(timestamp);\n\n        emit Version(currentVersion(), timestamp, price);\n    }\n}\n\n\nOn ChainlinkOracle.sol, we are using latestRoundData, but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:\n\n*   <https://docs.chain.link/docs/historical-price-data/#historical-rounds\n*   <https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round\n\n",
                "Repair": "\nConsider adding missing checks for stale data.\n\nFor example:\n\nsolidity\n(uint80 roundID, int256 feedPrice, , uint256 timestamp, uint80 answeredInRound) = feed.latestRoundData();\nrequire(feedPrice  0, \"Chainlink price <= 0\"); \nrequire(answeredInRound = roundID, \"Stale price\");\nrequire(timestamp != 0, \"Round not complete\");\n\n\nkbrizzle (Perennial) confirmed(https://github.com/code-423n4/2021-12-perennial-findings/issues/24)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-12-perennial-findings/issues/24#issuecomment-1001295232):\n  Agree with the finding, while you can get started with Chainlink's feed can be used with one line of code, in a production environment it is best to ensure that the data is fresh and within rational bounds\n\n\n"
            }
        ]
    }
]