[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Generic Swap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for swapping through ANY DEX\n * @dev Uses calldata to execute arbitrary methods on DEXs\n */\ncontract GenericSwapFacet is ILiFi, Swapper {\n    /* ========== Public Functions ========== */\n\n    /**\n     * @notice Performs a swap and that's it\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     */\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Anyswap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n */\ncontract AnyswapFacet is ILiFi, Swapper {\n    /* ========== Types ========== */\n\n    struct AnyswapData {\n        address token;\n        address router;\n        uint256 amount;\n        address recipient;\n        uint256 toChainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _anyswapData data specific to Anyswap\n     */\n    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n            require(\n                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _anyswapData data specific to Anyswap\n     */\n    function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Anyswap\n     * @param _anyswapData data specific to Anyswap\n     */\n    function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n            return;\n        }\n\n        if (_anyswapData.token != address(0)) {\n            // Has underlying token?\n            if (underlyingToken != address(0)) {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            } else {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOut(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "GenericSwapFacet.sol",
            "AnyswapFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "receivingAssetId",
                    "swapTokensGeneric()",
                    "SwapData",
                    "executeSwaps()"
                ],
                "Type": " Reliance on  lifiData.receivingAssetId  can cause loss of funds",
                "Description": "\nGenericSwapFacet.sol#L23-L30(https://github.com/code-423n4/2022-03-lifinance/blob/699c2305fcfb6fe8862b75b26d1d8a2f46a551e6/src/Facets/GenericSwapFacet.sol#L23-L30)<br\n\nIn the swapTokensGeneric() function, an arbitrary number of swaps can be performed from and to various tokens. However, the final balance that is sent to the user relies on _lifiData.receivingAssetId which has no use in the swapping functionality. LifiData is claimed to be used purely for analytical reasons per the comments to this function. If this value is input incorrectly, the swapped tokens will simply sit in the contract and be lost to the user.\n\n\nImagine a call to swapTokensGeneric() with the following parameters (excluding unnecessary parameters for this example):\n\n*   LifiData.receivingAssetId = '0xUSDC_ADDRESS'\n\nSingle SwapData array:\n\n*   LibSwap.SwapData.sendingAssetId = '0xWETH_ADDRESS'\n*   LibSwap.SwapData.receivingAssetId = '0xDAI_ADDRESS'\n\nSince the receivingAssetId from SwapData does not match the receivingAssetId from LifiData, the final funds will not be sent to the user after the swap is complete, based on the following lines of code:\n\n    uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n     _executeSwaps(_lifiData, _swapData);\n\n     uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) receivingAssetIdBalance;\n\n     LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\nLines 1, 3, and 4 reference LifiData.receivingAssetId and handle the transfer of funds following the swaps. Line 2 performs the swap, referencing SwapData.receivingAssetId as can be seen in the executeSwaps() function definition:\n\n    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {\n            // Swap\n            for (uint8 i; i < _swapData.length; i++) {\n                require(\n                    ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,\n                    \"Contract call not allowed!\"\n                );\n\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n        }\n\n",
                "Repair": "\nI recommend adding a check that _lifiData.receivingAssetId equals the receivingAssetId of the last index of the SwapData array, or simply use the receivingAssetId of the last index of the SwapData array for sending the final tokens to the user.\n\nH3xept (Li.Fi) commented(https://github.com/code-423n4/2022-03-lifinance-findings/issues/75#issuecomment-1088830379):\n  Fixed in lifinance/lifi-contracts@52aa2b8ea3bc51de3e60784c00201e29103fe250\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-03-lifinance-findings/issues/75#issuecomment-1100703191):\n  Sponsor confirmed with fix.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "swap()",
                    "swapTokensGeneric()"
                ],
                "Type": " All swapping functions lack checks for returned tokens",
                "Description": "\nGenericSwapFacet.sol#L23-L30(https://github.com/code-423n4/2022-03-lifinance/blob/699c2305fcfb6fe8862b75b26d1d8a2f46a551e6/src/Facets/GenericSwapFacet.sol#L23-L30)<br\nLibSwap.sol#L48(https://github.com/code-423n4/2022-03-lifinance/blob/699c2305fcfb6fe8862b75b26d1d8a2f46a551e6/src/Libraries/LibSwap.sol#L48)<br\n\nEvery function that stems from the GenericSwapFacet lacks checks to ensure that some tokens have been returned via the swaps. In LibSwap.sol in the swap() function, the swap call is sent to the target DEX. A return of success is required, otherwise the operation will revert.\n\nEach \"inner\" swap via LibSwap.sol lacks output checks and also the \"outer\" swapTokensGeneric() via GenericSwapFacet.sol lacks a final check as well.\n\nThere is a possibility that the calldata is accidently populated with a function in the target router that is not actually performing any swapping functionality, getAmountsOut() for example. The function will return true, but no new returned tokens will be present in the contract. Meanwhile, the contract has already received the user's fromTokens directly.\n\n",
                "Repair": "\nThis would be a potential use case of using function signature whitelists as opposed to contract address whitelists, as noted as a possibility by the LiFi team.\n\nOtherwise, the following require statement in swapTokensGeneric() would ensure that at least a single token was received:\n\nrequire(LibAsset.getOwnBalance(_swapData.receivingAssetId) toAmount)  0, \"No tokens received\")\n\nH3xept (Li.Fi) resolved and commented(https://github.com/code-423n4/2022-03-lifinance-findings/issues/76#issuecomment-1094953222):\n  Fixed in lifinance/lifi-contracts@3a42484dda8bafcfd122c8aa3b61d3766d545bf9\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-03-lifinance-findings/issues/76#issuecomment-1100703542):\n  Sponsor confirmed with fix.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]