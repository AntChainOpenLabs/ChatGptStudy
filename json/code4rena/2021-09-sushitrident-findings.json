[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nITridentCallee(msg.sender).tridentSwapCallback(context);\n// @dev Check Trident router has sent `amountIn` for skim into pool.\nunchecked { // @dev This is safe from under/overflow only logged amounts handled.\n    require(_balance(tokenIn) = amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n    inRecord.reserve += uint120(amountIn);\n    outRecord.reserve -= uint120(amountOut);\n}\n_transfer(tokenOut, amountOut, recipient, unwrapBento);\n"
                ],
                "Type": " Flash swap call back prior to transferring tokens in  indexPool ",
                "Description": "\nIn the IndexPool contract, flashSwap does not work.\nThe callback function is called prior to token transfer. The sender won't receive tokens in the callBack function.\nITridentCallee(msg.sender).tridentSwapCallback(context);\n\nFlashswap is not implemented correctly. It may need a migration to redeploy all indexPools if the issue is found after main-net launch.\nI consider this a high-risk issue.\n\nIndexPool.sol#L196-L223(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L196-L223)\n\nsolidity\nITridentCallee(msg.sender).tridentSwapCallback(context);\n// @dev Check Trident router has sent amountIn for skim into pool.\nunchecked { // @dev This is safe from under/overflow only logged amounts handled.\n    require(_balance(tokenIn) = amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n    inRecord.reserve += uint120(amountIn);\n    outRecord.reserve -= uint120(amountOut);\n}\n_transfer(tokenOut, amountOut, recipient, unwrapBento);\n\n\n",
                "Repair": "solidity\n_transfer(tokenOut, amountOut, recipient, unwrapBento);\nITridentCallee(msg.sender).tridentSwapCallback(context);\n// @dev Check Trident router has sent amountIn for skim into pool.\nunchecked { // @dev This is safe from under/overflow only logged amounts handled.\n    require(_balance(tokenIn) = amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n    inRecord.reserve += uint120(amountIn);\n    outRecord.reserve -= uint120(amountOut);\n}\n\n\nmaxsam4 (Sushi) commented(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/26#issuecomment-952521402):\n  Duplicate of\n https://github.com/code-423n4/2021-09-sushitrident-findings/issues/157\n and\n https://github.com/code-423n4/2021-09-sushitrident-findings/issues/80\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n  output = n % 2 != 0 ? a : BASE;\n  for (n /= 2; n != 0; n /= 2) a = a * a;\n  if (n % 2 != 0) output = output * a;\n}\n",
                    "python\ndeployed_code = encode_abi([\"address[]\",\"uint136[]\",\"uint256\"], \n    (link.address, dai.address),\n    (2*1018,  1018),\n    1013\n])\n",
                    "python\n# (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn)\nprevious_balance = bento.functions.balanceOf(dai.address, admin).call()\nswap_amount =  1018\n\nbento.functions.transfer(link.address, admin, pool.address, swap_amount).transact()\npool.functions.swap(\n    encode_abi(\n        'address', 'address', 'address', 'bool', 'uint256'],\n        link.address, dai.address, admin, False, swap_amount]\n    )\n).transact()\ncurrent_balance = bento.functions.balanceOf(dai.address, admin).call()\ntoken_received = current_balance previous_balance\n# always = 0\nprint(token_received)\n"
                ],
                "Type": " Index Pool always swap to Zero",
                "Description": "\nWhen an Index pool is initiated with two tokens A: B and the weight rate = 1:2, then no user can buy token A with token B.\n\nThe root cause is the error in pow. It seems like the dev tries to implement Exponentiation by squaring(https://en.wikipedia.org/wiki/Exponentiation_by_squaring).\nIndexPool.sol#L286-L291(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L286-L291)\n\nsolidity\nfunction _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n  output = n % 2 != 0 ? a : BASE;\n  for (n /= 2; n != 0; n /= 2) a = a * a;\n  if (n % 2 != 0) output = output * a;\n}\n\n\nThere's no bracket for for.\n\nThe IndexPool is not functional. I consider this is a high-risk issue.\n\nWhen we initiated the pool with 2:1.\n\npython\ndeployed_code = encode_abi([\"address[]\",\"uint136[]\",\"uint256\"], \n    (link.address, dai.address),\n    (2*1018,  1018),\n    1013\n])\n\n\nNo one can buy dai with link.\n\npython\n# (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn)\nprevious_balance = bento.functions.balanceOf(dai.address, admin).call()\nswap_amount =  1018\n\nbento.functions.transfer(link.address, admin, pool.address, swap_amount).transact()\npool.functions.swap(\n    encode_abi(\n        'address', 'address', 'address', 'bool', 'uint256'],\n        link.address, dai.address, admin, False, swap_amount]\n    )\n).transact()\ncurrent_balance = bento.functions.balanceOf(dai.address, admin).call()\ntoken_received = current_balance previous_balance\n# always = 0\nprint(token_received)\n\n\n",
                "Repair": "The brackets of for were missed.\n\nsolidity\nfunction _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n    output = n % 2 != 0 ? a : BASE;\n    for (n /= 2; n != 0; n /= 2) {\n        a = a * a;\n        if (n % 2 != 0) output = output * a;\n    }\n}\n\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "python\ndeployed_code = encode_abi([\"address[]\",\"uint136[]\",\"uint256\"], \n    (link.address, dai.address),\n    (1018, 10 * 1018),\n    1013\n])\ntx_hash = master_deployer.functions.deployPool(index_pool_factory.address, deployed_code).transact()\n"
                ],
                "Type": "  IndexPool  pow overflows when  weightRatio  > 10.",
                "Description": "\nIn the IndexPool contract, pow is used in calculating price. ([IndexPool.sol L255-L266(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L255-L266)).\nHowever, Pow is easy to cause overflow. If the weightRatio is large (e.g. 10), there's always overflow.\n\nLp providers can still provide liquidity to the pool where no one can swap. All pools need to redeploy. I consider this a high-risk issue.\n\nIt's easy to trigger this bug by deploying a 1:10 IndexPool.\n\npython\ndeployed_code = encode_abi([\"address[]\",\"uint136[]\",\"uint256\"], \n    (link.address, dai.address),\n    (1018, 10 * 1018),\n    1013\n])\ntx_hash = master_deployer.functions.deployPool(index_pool_factory.address, deployed_code).transact()\n\n\nTransactions would be reverted when buying link with dai.\n\n",
                "Repair": "The weightRatio is an 18 decimals number. It should be divided by (BASE)^exp. The scale in the contract is not consistent. Recommend the dev to check all the scales/ decimals.\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/28)\n\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "python\ndeposit_amount = 1018\nbento.functions.transfer(link.address, admin, pool.address, deposit_amount).transact()\nbento.functions.transfer(dai.address, admin, pool.address, deposit_amount).transact()\npool.functions.mint(encode_abi(\n    'address', 'uint256'],\n    admin, 108] # minimum\n)).transact()\npool.functions.mint(encode_abi(\n    'address', 'uint256'],\n    admin, 10000000000009999 * 10 20]\n)).transact()\n",
                    "python\ndeposit_amount = 1018\nbento.functions.transfer(link.address, admin, pool.address, deposit_amount).transact()\nbento.functions.transfer(dai.address, admin, pool.address, deposit_amount).transact()\npool.functions.mint(encode_abi(\n    'address', 'uint256'],\n    admin, deposit_amount * 100]\n)).transact()\n"
                ],
                "Type": " IndexPool's  INIT_POOL_SUPPLY  is not fair.",
                "Description": "\nThe indexPool mint INIT_POOL_SUPPLY to address 0 in the constructor. However, the value of the burned lp is decided by the first lp provider. According to the formula in IndexPool.sol L106(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L106).\n\nAmountIn = first_lp_amount / INIT_POOL_SUPPLY and the burned lp worth = AmountIn * (INIT_POOL_SUPPLY) / (first_lp_amount + INIT_POOL_SUPPLY).\nIf a pool is not initialized with optimal parameters, it would be a great number of tokens been burn. All lp providers in the pool would receive less profit.\n\nThe optimal parameter is 108. It's likely no one would initialize with 108 wei in most pools. I consider this is a high-risk issue.\n\nThere are two scenarios that the first lp provider can do. The lp provider provides the same amount of token in both cases. However, in the first scenario, he gets about 10  18 * 1018 lp while in the other scenario he gets 100 * 1018 lp.\n\npython\ndeposit_amount = 1018\nbento.functions.transfer(link.address, admin, pool.address, deposit_amount).transact()\nbento.functions.transfer(dai.address, admin, pool.address, deposit_amount).transact()\npool.functions.mint(encode_abi(\n    'address', 'uint256'],\n    admin, 108] # minimum\n)).transact()\npool.functions.mint(encode_abi(\n    'address', 'uint256'],\n    admin, 10000000000009999 * 10 20]\n)).transact()\n\n\npython\ndeposit_amount = 1018\nbento.functions.transfer(link.address, admin, pool.address, deposit_amount).transact()\nbento.functions.transfer(dai.address, admin, pool.address, deposit_amount).transact()\npool.functions.mint(encode_abi(\n    'address', 'uint256'],\n    admin, deposit_amount * 100]\n)).transact()\n\n\n",
                "Repair": "Recommend to handle INIT_POOL_SUPPLY in uniswap-v2's way. Determine an optimized parameter for the user would be a better UX design.\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [],
                "Type": " hybrid pool uses wrong  non_optimal_mint_fee ",
                "Description": "\nWhen an lp provider deposits an imbalance amount of token, a swap fee is applied. HybridPool uses the same _nonOptimalMintFee as constantProductPool; however, since two pools use different AMM curve, the ideal balance is not the same.  ref: StableSwap3Pool.vy L322-L337(https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)\n\nStable swap Pools are designed for 1B+ TVL. Any issue related to pricing/fee is serious. I consider this is a high-risk issue\n\nStableSwap3Pool.vy#L322-L337(https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)\nHybridPool.sol#L425-L441(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L425-L441)\n\n\n",
                "Repair": "Calculate the swapping fee based on the stable swap curve. refer to StableSwap3Pool.vy#L322-L337(https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337).\n\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/31)\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [],
                "Type": "  IndexPool :  Poor conversion from Balancer V1's corresponding functions",
                "Description": "\nA number of functions suffer from the erroneous conversion of Balancer V1's implementation.\n\n*   _compute() (equivalent to Balancer's bpow()(https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol#L108-L126))\n    *   if (remain == 0) output = wholePow; when a return statement should be used instead.\n*   _computeSingleOutGivenPoolIn() (equivalent to Balancer's _calcSingleOutGivenPoolIn()(https://github.com/balancer-labs/balancer-core/blob/master/contracts/BMath.sol#L195-L224))\n    *   tokenOutRatio should be calculated with _compute() instead of _pow()\n    *   zaz should be calculated with _mul() instead of the native *\n*   _pow() (equivalent to Balancer's bpowi()(https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol#L89-L103))\n    *   Missing brackets {} for the for loop causes a different interpretation\n    *   _mul should be used instead of the native *\n\n",
                "Repair": "The fixed implementation is provided below.\n\njsx\nfunction _computeSingleOutGivenPoolIn(\n  uint256 tokenOutBalance,\n  uint256 tokenOutWeight,\n  uint256 _totalSupply,\n  uint256 _totalWeight,\n  uint256 toBurn,\n  uint256 _swapFee\n) internal pure returns (uint256 amountOut) {\n    uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n    uint256 newPoolSupply = _totalSupply toBurn;\n    uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n    uint256 tokenOutRatio = _compute(poolRatio, _div(BASE, normalizedWeight));\n    uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n    uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance newBalanceOut;\n    uint256 zaz = _mul(BASE normalizedWeight, _swapFee);\n    amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE zaz));\n}\n\nfunction _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {\n  require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, \"INVALID_BASE\");\n\n  uint256 whole = (exp / BASE) * BASE;\n  uint256 remain = exp whole;\n  uint256 wholePow = _pow(base, whole / BASE);\n\n  if (remain == 0) return wholePow;\n\n  uint256 partialResult = _powApprox(base, remain, POW_PRECISION);\n  output = _mul(wholePow, partialResult);\n}\n\nfunction _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n  output = n % 2 != 0 ? a : BASE;\n  for (n /= 2; n != 0; n /= 2) {\n\t\ta = _mul(a, a);\n    if (n % 2 != 0) output = _mul(output, a);\n\t}\n}\n\n\nmaxsam4 (Sushi) acknowledged(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/40)\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [
                    "//solidity\n/// @dev Mints LP tokens should be called via the router after transferring `bento` tokens.\n/// The router must ensure that sufficient LP tokens are minted by using the return value.\nfunction mint(bytes calldata data) public override lock returns (uint256 liquidity) {\n    (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));\n\n    uint120 ratio = uint120(_div(toMint, totalSupply));\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n        address tokenIn = tokens[i];\n        uint120 reserve = records[tokenIn].reserve;\n        // @dev If token balance is '0', initialize with `ratio`.\n        uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;\n        require(amountIn = MIN_BALANCE, \"MIN_BALANCE\");\n        // @dev Check Trident router has sent `amountIn` for skim into pool.\n        unchecked {\n            // @dev This is safe from overflow only logged amounts handled.\n            require(_balance(tokenIn) = amountIn + reserve, \"NOT_RECEIVED\");\n            records[tokenIn].reserve += amountIn;\n        }\n        emit Mint(msg.sender, tokenIn, amountIn, recipient);\n    }\n    _mint(recipient, toMint);\n    liquidity = toMint;\n}\n"
                ],
                "Type": "  IndexPool.mint  The first liquidity provider is forced to supply assets in the same amount, which may cause a significant amount of fund loss",
                "Description": "\nWhen reserve == 0, amountIn for all the tokens will be set to the same amount: ratio, regardless of the weights, decimals and market prices of the assets.\n\nThe first liquidity provider may not be aware of this so that it may create an arbitrage opportunity for flashbots to take a significant portion of the value of The first liquidity provider's liquidity.\n\n\nIndexPool.sol#L93 L105(https://github.com/sushiswap/trident/blob/6bd4c053b6213ffc612987eb565aa3813d5f0d13/contracts/pool/IndexPool.sol#L93-L105)\nsolidity\n/// @dev Mints LP tokens should be called via the router after transferring bento tokens.\n/// The router must ensure that sufficient LP tokens are minted by using the return value.\nfunction mint(bytes calldata data) public override lock returns (uint256 liquidity) {\n    (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));\n\n    uint120 ratio = uint120(_div(toMint, totalSupply));\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n        address tokenIn = tokens[i];\n        uint120 reserve = records[tokenIn].reserve;\n        // @dev If token balance is '0', initialize with ratio.\n        uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;\n        require(amountIn = MIN_BALANCE, \"MIN_BALANCE\");\n        // @dev Check Trident router has sent amountIn for skim into pool.\n        unchecked {\n            // @dev This is safe from overflow only logged amounts handled.\n            require(_balance(tokenIn) = amountIn + reserve, \"NOT_RECEIVED\");\n            records[tokenIn].reserve += amountIn;\n        }\n        emit Mint(msg.sender, tokenIn, amountIn, recipient);\n    }\n    _mint(recipient, toMint);\n    liquidity = toMint;\n}\n\n\nGiven:\n\n*   A IndexPool of 99% USDT and 1% WBTC;\n*   Alice is the first liquidity provider.\n\n1.  Alice transfers 1e18 WBTC and 1e18 USDT to mint 100e18 of liquidity;\n2.  Bob can use 100e18 USDT (~$100) to swap out most of the balance of WBTC.\n\nA significant portion (90% in the case above) of the user's funds can be lost due to arbitrage.\n\n",
                "Repair": "Consider allowing the first liquidity provider to use custom amountIn values for each token or always takes the MIN_BALANCE of each token.\n\n\n"
            },
            {
                "Name": "H-08",
                "Location": [],
                "Type": "  HybridPool 's reserve is converted to \"amount\" twice",
                "Description": "\nThe HybridPool's reserves are stored as Bento \"amounts\" (not Bento shares) in _updateReserves because _balance() converts the current share balance to amount balances.\nHowever, when retrieving the reserve0/1 storage fields in _getReserves, they are converted to amounts a second time.\n\nThe HybridPool returns wrong reserves which affects all minting/burning and swap functions.\nThey all return wrong results making the pool eventually economically exploitable or leading to users receiving less tokens than they should.\n\nImagine the current Bento amount / share price being 1.5.\nThe pool's Bento *share* balance being 1000.\n_updateReserves will store a reserve of 1.5 * 1000 = 1500.\nWhen anyone trades using the swap function, _getReserves() is called and multiplies it by 1.5 again, leading to using a reserve of 2250 instead of 1500.\nA higher reserve for the output token leads to receiving more tokens as the swap output.\nThus the pool lost tokens and the LPs suffer this loss.\n\n",
                "Repair": "Make sure that the reserves are in the correct amounts.\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/101)\n\n\n"
            },
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\nuint120 ratio = uint120(_div(toMint, totalSupply));\n"
                ],
                "Type": " Unsafe cast in  IndexPool  mint leads to attack",
                "Description": "\nThe IndexPool.mint function performs an unsafe cast of ratio to the uint120 type:\n\nsolidity\nuint120 ratio = uint120(_div(toMint, totalSupply));\n\n\nNote that toMint is chosen by the caller and when choosing toMint = 2120 * totalSupply / BASE, the ratio variable will be 2120 and then truncated to 0 due to the cast.\n\nThis allows an attacker to mint LP tokens for free.\nThey just need to choose the ratio such that the amountIn = ratio * reserve / BASE variable passes the require(amountIn = MIN_BALANCE, \"MIN_BALANCE\"); check.\nFor example, when choosing ratio = 2120 * totalSupply / BASE + 1e16, an attacker has to pay 1/100th of the current reserves but heavily inflates the LP token supply.\n\nThey can then use the inflated LP tokens they received in burn to withdraw the entire pool reserves.\n\nI created this POC(https://gist.github.com/MrToph/0c8b6b5ffac0673b2f72412cf4b0b099) that implements a hardhat test and shows how to steal the pool tokens:\n\nAn attacker can inflate the LP token pool supply and mint themselves a lot of LP tokens by providing almost no tokens themselves.\nThe entire pool tokens can be stolen.\n\n",
                "Repair": "Even though Solidity 0.8.x is used, type casts do not throw an error.\nA SafeCast library(https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeCast) must be used everywhere a typecast is done.\n\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/126)\n\n\n"
            },
            {
                "Name": "H-10",
                "Location": [],
                "Type": "  IndexPool  initial LP supply computation is wrong",
                "Description": "\nThe IndexPool.constructor function already mints INIT_POOL_SUPPLY = 100 * 1e18 = 1e20 LP tokens to the zero address.\n\nWhen trying to use the pool, someone has to provide the actual initial reserve tokens in mint.\nOn the first mint, the pool reserves are zero and the token amount required to mint is just this ratio itself: uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;\n\nNote that the amountIn is independent of the token which does not make much sense.\nThis implies that all tokens must be provided in equal \"raw amounts\", regardless of their decimals and value.\n\n\n\nImagine I want to create a DAI/WBTC pool.\nIf I want to initialize the pool with 100$ of DAI, amountIn = ratio needs to be 100*1e18=1e20 as DAI has 18 decimals.\nHowever, I now also need to supply 1e20 of WBTC (which has 8 decimals) and I'd need to pay 1e20/1e8 * priceOfBTC, over a quadrillion dollars to match it with the 100$ of DAI.\n\n\nEven in a pool where all tokens have the same decimals and the same value, like USDC < USDT, it leads to issues:\n\n*   Initial minter calls mint with toMint = 1e20 which sets ratio = 1e20 * 1e18 / 1e20 = 1e18 and thus amountIn = 1e18 as well. The total supply increases to 2e20.\n*   Second minter needs to pay less tokens to receive the same amount of 1e18 LP tokens as the first minter. This should never be the case. toMint = 1e20 = ratio = 1e20 * 1e18 / 2e20 = 0.5e18. Then amountIn = ratio * reserve / 1e18 = 0.5*reserve = 0.5e18. They only pay half of what the first LP provider had to pay.\n\n\nIt's unclear why it's assumed that the pool's tokens are all in equal value this is *not* a StableSwap-like pool.\n\nAny pool that uses tokens that don't have the same value and share the same decimals cannot be used because initial liquidity cannot be provided in an economically justifiable way.\n\nIt also leads to issues where the second LP supplier has to pay less tokens to receive the exact same amount of LP tokens that the initial minter receives. They can steal from the initial LP provider by burning these tokens again.\n\n",
                "Repair": "Do not mint the initial token supply to the zero address in the constructor.\n\nDo it like Uniswap/Balancer and let the first liquidity provider provide arbitrary token amounts, then mint the initial pool supply.\nIf reserve == 0, amountIn should just take the pool balances that were transferred to this account.\n\nIn case the initial mint to the zero address in the constructor was done to prevent the \"Uniswap-attack\" where the price of a single wei of LP token can be very high and price out LPs, send a small fraction of this initial LP supply (~1000) to the zero address after it was minted to the first supplier in mint.\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/78)\n\n\n"
            },
            {
                "Name": "H-11",
                "Location": [
                    "//solidity\namount1 += _getAmountOut(amount0, _reserve0 amount0, _reserve1 amount1);\n"
                ],
                "Type": "  ConstantProductPool.burnSingle  swap amount computations should use balance",
                "Description": "\nThe ConstantProductPool.burnSingle function is basically a burn followed by a swap and must therefore act the same way as calling these two functions sequentially.\n\nThe token amounts to redeem (amount0, amount1) are computed on the balance (not the reserve).\nHowever, the swap amount is then computed on the reserves and not the balance.\nThe burn function would have updated the reserve to the balances and therefore balance should be used here:\n\nsolidity\namount1 += _getAmountOut(amount0, _reserve0 amount0, _reserve1 amount1);\n\n\n \u26a0\ufe0f The same issue occurs in the HybridPool.burnSingle.\n\nFor a burn, usually the reserve should equal the balance, however if any new tokens are sent to the contract and balance  reserve, this function will return slightly less swap amounts.\n\n",
                "Repair": "Call _getAmountOut with the balances instead of the reserves: _getAmountOut(amount0, balance0 amount0, balance1 amount1)\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/96#issuecomment-947608322):\n  Please bump this to High sev. This bug can actually lead to loss of funds from the pool. The author found the right issue but failed to analyze the full impact. Regardless, I think they deserve \"High\" for pointing this out.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/96#issuecomment-950561090):\n  This is what we come to C4 for :clap: :clap: :clap:\n\n\n"
            },
            {
                "Name": "H-12",
                "Location": [
                    "//solidity\nunchecked {\n    if (a  b) {\n        diff = a b;\n    }\n    else {\n        diff = b a;\n    }\n}\n"
                ],
                "Type": " absolute difference is not calculated properly when a > b in MathUtils",
                "Description": "\nthe difference is computed incorrectly when a  b. MathUtils.sol L22(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/libraries/MathUtils.sol#L22)\n\nAs it only used in within1 function, scope narrows down to where difference(a, b) <= 1; is exploitable.\n\ncases where difference(a, b) <= 1 should be true but is reported false:\n\n*   where b = a-1 (returned value is type(uint256).max)\n\ncases where difference(a, b) <= 1 should be false but is reported true:\n\n*   where a = type(uint256).max and b = 0, it returns 1 but it should ideally return type(uint256).max\n\nwithin1 is used at the following locations:\n*   HybridPool.sol L359(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L359)\n*   HybridPool.sol L383(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L383)\n*   HybridPool.sol L413(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L413)\n\nIt is possible to decrease the denominator and increase the value of the numerator (when calculating y) using constants and input to make within1 fail\n\nMitigation:\n\nAdd else condition to mitigate it.\nsolidity\nunchecked {\n    if (a  b) {\n        diff = a b;\n    }\n    else {\n        diff = b a;\n    }\n}\n\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/139)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-13",
                "Location": [],
                "Type": " Overflow in the  mint  function of  IndexPool  causes LPs' funds to be stolen",
                "Description": "\nIt is possible to overflow the addition in the balance check (i.e., _balance(tokenIn) = amountIn + reserve) in the mint function by setting the amountIn to a large amount. As a result, the attacker could gain a large number of LP tokens by not even providing any liquidity. The attacker's liquidity would be much greater than any other LPs, causing him could effectively steal others' funds by burning his liquidity (since the funds he receives are proportional to his liquidity).\n\nmint_overflow.js(https://gist.github.com/x9453/7a423aef223c1b86442206e3248d318c)\n\nReferenced code:\nIndexPool.sol L110(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L110)\n\n",
                "Repair": "Consider removing the uncheck statement to prevent integer overflows from happening.\n\nmaxsam4 (Sushi) acknowledged(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/163#issuecomment-935750061):\n  FWIW The problem here isn't that we used unchecked but that we didn't cast amountIn to uint256. It's possible to overflow uint120 but not uint256.\n\n\n"
            },
            {
                "Name": "H-14",
                "Location": [],
                "Type": " Incorrect usage of  _pow  in  _computeSingleOutGivenPoolIn  of  IndexPool ",
                "Description": "\nThe _computeSingleOutGivenPoolIn function of IndexPool uses the _pow function to calculate tokenOutRatio with the exponent in WAD (i.e., in 18 decimals of precision). However, the _pow function assumes that the given exponent n is not in WAD. (for example, _pow(5, BASE) returns 5  (10  18) instead of 5  1). The misuse of the _pow function could causes an integer overflow in the _computeSingleOutGivenPoolIn function and thus prevent any function from calling it.\n\nReferenced code:\nIndexPool.sol#L279(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L279)\n\n",
                "Repair": "Change the _pow function to the _compute function, which supports exponents in WAD.\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/165)\n\n\n"
            },
            {
                "Name": "H-15",
                "Location": [],
                "Type": " Incorrect multiplication in  _computeSingleOutGivenPoolIn  of  IndexPool ",
                "Description": "\nThe _computeSingleOutGivenPoolIn function of IndexPool uses the raw multiplication (i.e., *) to calculate the zaz variable. However, since both (BASE normalizedWeight) and _swapFee are in WAD, the _mul function should be used instead to calculate the correct value of zaz. Otherwise, zaz would be 10  18 times larger than the expected value and causes an integer underflow when calculating amountOut. The incorrect usage of multiplication prevents anyone from calling the function successfully.\n\nReferenced code:\nIndexPool.sol#L282(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L282)\n\n",
                "Repair": "Change (BASE normalizedWeight) * _swapFee to _mul((BASE normalizedWeight), _swapFee).\n\n maxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/166)\n\n\n"
            },
            {
                "Name": "H-16",
                "Location": [],
                "Type": " Funds in the pool could be stolen by exploiting  flashSwap  in  HybridPool ",
                "Description": "\nAn attacker can call the bento.harvest function during the callback function of a flash swap of the HybridPool to reduce the number of input tokens that he has to pay to the pool, as long as there is any unrealized profit in the strategy contract of the underlying asset.\n\n1.  The HybridPool accounts for the reserve and balance of the pool using the bento.toAmount function, which represents the actual amount of assets that the pool owns instead of the relative share. The value of toAmount could increase or decrease if the bento.harvest function is called (by anyone), depending on whether the strategy contract earns or loses money.\n2.  Supposing that the DAI strategy contract of Bento has a profit not accounted for yet. To account for the profit, anyone could call harvest on Bento with the corresponding parameters, which, as a result, increases the elastic of the DAI token.\n3.  Now, an attacker wants to utilize the unrealized profit to steal funds from a DAI-WETH hybrid pool. He calls flashSwap to initiate a flash swap from WETH to DAI. First, the pool transfers the corresponding amount of DAI to him, calls the tridentSwapCallback function on the attacker's contract, and expects that enough DAI is received at the end.\n4.  During the tridentSwapCallback function, the attacker calls bento.harvest to realize the profit of DAI. As a result, the pool's bento.toAmount increases, and the amount of DAI that the attacker has to pay to the pool is decreased. The attacker could get the same amount of ETH but paying less DAI by exploiting this bug.\n\nReferenced code:\n* HybridPool.sol L218-L220(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L218-L220)\n* HybridPool.sol L249-L250(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L249-L250)\n* HybridPool.sol L272-L285(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L272-L285)\n* BentoBoxV1Flat.sol L1105(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L1105)\n* BentoBoxV1Flat.sol L786-L792(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L786-L792)\n* BentoBoxV1Flat.sol L264-L277(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L264-L277)\n\n",
                "Repair": "Consider not using bento.toAmount to track the reservers and balances, but use balanceOf instead (as done in the other two pools).\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/167#issuecomment-935717783):\n  Stableswap needs to use toAmount balances rather shares to work. This issue allows skimming yield profits from the pool. There's no user funds at risk but still an issue.\n\n We plan on resolving this by using a fixed toElastic ratio during the whole swap.\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [],
                "Type": " No bar fees for  IndexPools ?",
                "Description": "\nIndexPool doesn't collect fees for barFeeTo. Since this Pool contains also a method updateBarFee(), probably this is an unintended behavior.\nAlso without a fee, liquidity providers would probably ditch ConstantProductPool in favor of IndexPool (using the same two tokens with equal weights), since they get all the rewards. This would constitute an issue for the ecosystem.\n\n",
                "Repair": "Add a way to send barFees to barFeeTo, same as the other pools.\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/181)\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [],
                "Type": "  ConstantProductPool  &  HybridPool : Adding and removing unbalanced liquidity yields slightly more tokens than swap",
                "Description": "\nA mint fee is applied whenever unbalanced liquidity is added, because it is akin to swapping the excess token amount for the other token.\n\nHowever, the current implementation distributes the minted fee to the minter as well (when he should be excluded). It therefore acts as a rebate of sorts.\n\nAs a result, it makes adding and removing liquidity as opposed to swapping directly (negligibly) more desirable. An example is given below using the Constant Product Pool to illustrate this point. The Hybrid pool exhibits similar behaviour.\n\n1.  Initialize the pool with ETH-USDC sushi pool amounts. As of the time of writing, there is roughly 53586.556 ETH and 165143020.5295 USDC.\n2.  Mint unbalanced LP with 5 ETH (& 0 USDC). This gives the user 138573488720892 / 1e18 LP tokens.\n3.  Burn the minted LP tokens, giving the user 2.4963 ETH and 7692.40 USDC. This is therefore equivalent to swapping 5 2.4963 = 2.5037 ETH for 7692.4044 USDC.\n4.  If the user were to swap the 2.5037 ETH directly, he would receive 7692.369221 (0.03 USDC lesser).\n\n",
                "Repair": "The mint fee should be distributed to existing LPs first, by incrementing _reserve0 and _reserve1 with the fee amounts. The rest of the calculations follow after.\n\nConstantProductPool\n\njsx\n(uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\n// increment reserve amounts with fees\n_reserve0 += uint112(fee0);\n_reserve1 += uint112(fee1);\nunchecked {\n    _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);\n}\nuint256 computed = TridentMath.sqrt(balance0 * balance1);\n...\nkLast = computed;\n\n\nHybridPool\n\njsx\n(uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\n// increment reserve amounts with fees\n_reserve0 += uint112(fee0);\n_reserve1 += uint112(fee1);\nuint256 newLiq = _computeLiquidity(balance0, balance1);\n...\n\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/34)\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": " Router would fail when adding liquidity to index Pool",
                "Description": "\nTridentRouter is easy to fail when trying to provide liquidity to an index pool.\n\nUsers would not get extra lp if they are not providing lp at the pool's spot price. It's the same design as uniswap v2. However, uniswap's v2 handle's the dirty part.\n\nUsers would not lose tokens if they use the router ([UniswapV2Router02.sol L61-L76(https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)).\n\nHowever, the router wouldn't stop users from transferring extra tokens ([TridentRouter.sol L168-L190(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)).\n\nSecond, the price would possibly change when the transaction is confirmed. This would be reverted in the index pool.\n\nUsers would either transfer extra tokens or fail. I consider this is a medium-risk issue.\n\nTridentRouter.sol#L168-L190(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)\n\nA possible scenario:\n\nThere's a BTC/USD pool. BTC = 50000 USD.\n\n1.  A user sends a transaction to transfer 1 BTC and 50000 USD.\n2.  After the user send a transaction, a random bot buying BTC with USD.\n3.  The transaction at step 1 is mined. Since the BTC price is not 50000 USD, the transaction fails.\n\n",
                "Repair": "Please refer to the uniswap v2 router in UniswapV2Router02.sol L61-L76(https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)\n\nThe router should calculate the optimal parameters for users.\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/68)\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\nfor (uint256 i; i < params.percentagePath.length; i++) {\n    uint256 balanceShares = bento.balanceOf(params.percentagePath[i].tokenIn, address(this));\n    uint256 transferShares = (balanceShares * params.percentagePath[i].balancePercentage) / uint256(10)8;\n    bento.transfer(params.percentagePath[i].tokenIn, address(this), params.percentagePath[i].pool, transferShares);\n    isWhiteListed(params.percentagePath[i].pool);\n    IPool(params.percentagePath[i].pool).swap(params.percentagePath[i].data);\n}\n"
                ],
                "Type": " Router's  complexPath  percentagePaths don't work as expected",
                "Description": "\nThe TridentRouter.complexPath function allows splitting a trade result into several buckets and trade them in a different pool each.\nThe distribution is defined by the params.percentagePath[i].balancePercentage values:\n\nsolidity\nfor (uint256 i; i < params.percentagePath.length; i++) {\n    uint256 balanceShares = bento.balanceOf(params.percentagePath[i].tokenIn, address(this));\n    uint256 transferShares = (balanceShares * params.percentagePath[i].balancePercentage) / uint256(10)8;\n    bento.transfer(params.percentagePath[i].tokenIn, address(this), params.percentagePath[i].pool, transferShares);\n    isWhiteListed(params.percentagePath[i].pool);\n    IPool(params.percentagePath[i].pool).swap(params.percentagePath[i].data);\n}\n\n\nHowever, the base value bento.balanceOf(params.percentagePath[i].tokenIn, address(this)); is recomputed after each iteration instead of caching it before the loop.\n\nThis leads to not all tokens being used even though the percentages add up to 100%.\n\nAssume I want to trade 50% DAI to WETH and the other 50% DAI to WBTC.\nIn the first iteration, balanceShares is computed and then 50% of it is swapped in the first pool.\n\nHowever, in the second iteration, balanceShares is updated again, and only 50% of the remaining (instead of the total) balance, i.e. 25%, is traded.\n\nThe final 25% are lost and can be skimmed by anyone afterwards.\n\nUsers can lose their funds using complexPath.\n\n",
                "Repair": "Cache the balanceShares value once before the second for loop starts.\n\nsarangparikh22 (Sushi) disputed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/87#issuecomment-934546115):\n  This is not the correct way to calculate the complexPath swap parameters.\n For instance, if we need to swap 50% DAI to WETH and the other 50% DAI to WBTC, we would keep percentages as 50 and 100, instead of 50-50 as described above. If the user enters wrong percentages, they would loose funds.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/87#issuecomment-950522743):\n  The format for entering the percentages is not documented. Sustained as Sev 2 as the lack of documentation on this parameter could lead to loss of funds.\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [],
                "Type": "  _depositToBentoBox  sometimes uses both ETH and WETH",
                "Description": "\nThe TridentRouter._depositToBentoBox function only uses the ETH in the contract if it's higher then the desired underlyingAmount (address(this).balance = underlyingAmount)).\n\nOtherwise, the ETH is ignored and the function uses WETH from the user.\n\nNote that the underlyingAmount = bento.toAmount(wETH, amount, true) is computed from the Bento share price and it might happen that it increases from the time the transaction was submitted to the time the transaction is included in a block.\nIn that case, it might completely ignore the sent ETH balance from the user and in addition transfer the same amount of WETH from the user.\n\nThe user can lose their ETH deposit in the contract.\n\n",
                "Repair": "Each batch must use refundETH at the end.\n\nFurthermore, we recommend still depositing address(this).balance ETH into Bento and if it's less than underlyingAmount use WETH only for the remaining token difference.\n\nmaxsam4 (Sushi) acknowledged(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/89)\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction withdrawFromWETH(uint256 amount) internal {\n    // @audit WETH.withdraw returns nothing, data.length always zero. this always reverts\n    require(success && data.length = 32, \"WITHDRAW_FROM_WETH_FAILED\");\n}\n"
                ],
                "Type": "  withdrawFromWETH  always reverts ",
                "Description": "\nThe TridentHelper.withdrawFromWETH (used in TridentRouter.unwrapWETH) function performs a low-level call to WETH.withdraw(amount).\n\nIt then checks if the return data length is more or equal to 32 bytes, however WETH.withdraw returns void and has a return value of 0.\nThus, the function always reverts even if success == true.\n\nsolidity\nfunction withdrawFromWETH(uint256 amount) internal {\n    // @audit WETH.withdraw returns nothing, data.length always zero. this always reverts\n    require(success && data.length = 32, \"WITHDRAW_FROM_WETH_FAILED\");\n}\n\n\nThe unwrapWETH function is broken and makes all transactions revert.\nBatch calls to the router cannot perform any unwrapping of WETH.\n\n",
                "Repair": "Remove the data.length = 32 from the require and only check if success is true.\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/90)\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [],
                "Type": "  HybridPool 's  flashSwap  sends entire fee to  barFeeTo ",
                "Description": "\nThe HybridPool.flashSwap function sends the entire trade fees fee to the barFeeTo.\nIt should only send barFee * fee to the barFeeTo address.\n\nLPs are not getting paid at all when this function is used.\nThere is no incentive to provide liquidity.\n\n",
                "Repair": "The flashSwap function should use the same fee mechanism as swap and only send barFee * fee / MAX_FEE to the barFeeTo. See _handleFee function.\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/99)\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [],
                "Type": " Rounding errors will occur for tokens without decimals",
                "Description": "\nSome rare tokens have 0 decimals: https://etherscan.io/token/0xcc8fa225d80b9c7d42f96e9570156c65d6caaa25\n\nFor these tokens, small losses of precision will be amplified by the lack of decimals.\n\nConsider a constant product pool with 1000 of token0 (with no decimals), and 1000 of token1 (also with no decimals). Suppose I swap n= 1,2,3,4 of token0 to token1. Then my output amount of token1 will be 0,1,2,3.\n\nIf token0/1 are valuable than I will be losing 100%, 50%, 33%, 25% of my trade to rounding.\nCurrently there is no valuable token with 0 decimals, but there may be in the future.\n\nRounding the final getAmountOut division upwards would fix this.\n\nmaxsam4 (Sushi) commented(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/152#issuecomment-946648813):\n  Acceptable risk. We can't do anything if the token itself doesn't have decimals. We don't create synthetic assets and fractionalize such tokens ourselves.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-09",
                "Location": [],
                "Type": " Approximations may finish with inaccurate values",
                "Description": "\nIn HybridPool.sol, functions _computeLiquidityFromAdjustedBalances, _getY and _getYD may finish before approximation converge, since it's limited by MAX_LOOP_LIMIT iterations.\nIn this situation the final estimated value will still be treated as correct, even though it could be relatively inaccurate.\n\n",
                "Repair": "Consider reverting the transactions if this doesn't occur.\nSee https://blog.openzeppelin.com/saddle-contracts-audit/ issue [M03], with their relative fix.\n\n\n"
            },
            {
                "Name": "M-10",
                "Location": [],
                "Type": " Users are susceptible to back-running when depositing ETH to  TridenRouter ",
                "Description": "\nThe _depositToBentoBox and _depositFromUserToBentoBox allow users to provide ETH to the router, which is later deposited to the bento contract for swapping other assets or providing liquidity. However, in these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation.\n\n1.  A user wants to swap ETH to DAI. He calls exactInputSingleWithNativeToken on the router with the corresponding parameters and params.amountIn being 10. Before calling the function, he calculates bento.toAmount(wETH, 10, true) = 15 and thus send 15 ETH to the router.\n2.  However, at the time when his transaction is executed, bento.toAmount(wETH, amount, true) becomes to 14, which could happen if someone calls harvest on bento to update the elastic value of the wETH token.\n3.  As a result, only 14 ETH is transferred to the pool, and 1 ETH is left in the router. Anyone could back-run the user's transaction to retrieve the remaining 1 ETH from the router by calling the refundETH function.\n\nReferenced code: TridentRouter.sol#L318-L351(https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L318-L351)\n\n",
                "Repair": "Directly push the remaining ETH to the sender to prevent any ETH left in the router.\n\nmaxsam4 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/179#issuecomment-934388751):\n  I think it's low risk because it's basically arbitrage and we have protection for the user in terms of \"minOutputAmount\". I will be reworking ETH handling to avoid this issue completely.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-findings/issues/179#issuecomment-950567287):\n  It's a loss of funds, not arbitrage. It should be prevented or documented. Sustained.\n\n\n"
            }
        ]
    }
]