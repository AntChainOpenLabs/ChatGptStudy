[
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport {FixedStablecoins, FixedGTokens} from \"./common/FixedContracts.sol\";\nimport \"./common/Whitelist.sol\";\n\nimport \"./interfaces/IBuoy.sol\";\nimport \"./interfaces/IChainPrice.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IInsurance.sol\";\nimport \"./interfaces/ILifeGuard.sol\";\nimport \"./interfaces/IPnL.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/// @notice The main hub for Gro protocol - The controller links up the other contracts,\n///     and acts a route for the other contracts to call one another. It holds global states\n///     such as paused and emergency. Contracts that depend on the controller implement\n///     Controllable.\n///\n///     *****************************************************************************\n///     System tokens - GTokens:\n///     gvt - high yield, uninsured\n///     pwrd - insured by gvt, pays part of its yield to gvt (depending on utilisation)\n///\n///     Tokens order is DAI, USDC, USDT.\n///     Index 0 - DAI, 1 - USDC, 2 - USDT\n///\n///     System vaults:\n///     Stablecoin vaults: One per stablecoin\n///     Curve vault: Vault for LP (liquidity pool) token\ncontract Controller is Pausable, Ownable, Whitelist, FixedStablecoins, FixedGTokens, IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public override curveVault; // LP token vault\n\n    bool public preventSmartContracts = false;\n\n    address public override insurance; // Insurance logic\n    address public override pnl; // Profit and loss calculations\n    address public override lifeGuard; // Asset swapping\n    address public override buoy; // Oracle\n    address public override depositHandler;\n    address public override withdrawHandler;\n    address public override emergencyHandler;\n\n    uint256 public override deadCoin = 99;\n    bool public override emergencyState;\n    // Lower bound for how many gvt can be burned before getting to close to the utilisation ratio\n    uint256 public utilisationRatioLimitGvt;\n    uint256 public utilisationRatioLimitPwrd;\n\n    /// Limits for what deposits/withdrawals that are considered 'large', and thus will be handled with\n    ///     a different logic - limits are checked against total assets locked in etiher of the two tokens (pwrd, gvt)\n    uint256 public bigFishThreshold = 100; // %Basis Points limit\n    uint256 public bigFishAbsoluteThreshold = 0; // Absolute limit\n    address public override reward;\n\n    mapping(address => bool) public safeAddresses; // Some integrations need to be exempt from flashloan checks\n    mapping(uint256 => address) public override underlyingVaults; // Protocol stablecoin vaults\n    mapping(address => uint256) public vaultIndexes;\n\n    mapping(address => address) public override referrals;\n\n    // Pwrd (true) and gvt (false) mapped to respective withdrawal fee\n    mapping(bool => uint256) public override withdrawalFee;\n\n    event LogNewWithdrawHandler(address tokens);\n    event LogNewDepositHandler(address tokens);\n    event LogNewVault(uint256 index, address vault);\n    event LogNewCurveVault(address curveVault);\n    event LogNewLifeguard(address lifeguard);\n    event LogNewInsurance(address insurance);\n    event LogNewPnl(address pnl);\n    event LogNewBigFishThreshold(uint256 percent, uint256 absolute);\n    event LogFlashSwitchUpdated(bool status);\n    event LogNewSafeAddress(address account);\n    event LogNewRewardsContract(address reward);\n    event LogNewUtilLimit(bool indexed pwrd, uint256 limit);\n    event LogNewCurveToStableDistribution(uint256 amount, uint256[N_COINS] amounts, uint256[N_COINS] delta);\n    event LogNewWithdrawalFee(address user, bool pwrd, uint256 newFee);\n\n    constructor(\n        address pwrd,\n        address gvt,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals\n    ) public FixedStablecoins(_tokens, _decimals) FixedGTokens(pwrd, gvt) {}\n\n    function pause() external onlyWhitelist {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {\n        require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");\n        withdrawHandler = _withdrawHandler;\n        emergencyHandler = _emergencyHandler;\n        emit LogNewWithdrawHandler(_withdrawHandler);\n    }\n\n    function setDepositHandler(address _depositHandler) external onlyOwner {\n        require(_depositHandler != address(0), \"setDepositHandler: 0x\");\n        depositHandler = _depositHandler;\n        emit LogNewDepositHandler(_depositHandler);\n    }\n\n    function stablecoins() external view override returns (address[N_COINS] memory) {\n        return underlyingTokens();\n    }\n\n    /// @notice Returns amount to skim of larger deposits for alternative vault (Curve)\n    function getSkimPercent() external view override returns (uint256) {\n        return IInsurance(insurance).calcSkim();\n    }\n\n    /// @notice Returns list of all the underling protocol vaults\n    function vaults() external view override returns (address[N_COINS] memory) {\n        address[N_COINS] memory result;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = underlyingVaults[i];\n        }\n        return result;\n    }\n\n    /// @notice Set system vaults, vault index should match its underlying token\n    function setVault(uint256 index, address vault) external onlyOwner {\n        require(vault != address(0), \"setVault: 0x\");\n        require(index < N_COINS, \"setVault: !index\");\n        underlyingVaults[index] = vault;\n        vaultIndexes[vault] = index + 1;\n        emit LogNewVault(index, vault);\n    }\n\n    function setCurveVault(address _curveVault) external onlyOwner {\n        require(_curveVault != address(0), \"setCurveVault: 0x\");\n        curveVault = _curveVault;\n        vaultIndexes[_curveVault] = N_COINS + 1;\n        emit LogNewCurveVault(_curveVault);\n    }\n\n    function setLifeGuard(address _lifeGuard) external onlyOwner {\n        require(_lifeGuard != address(0), \"setLifeGuard: 0x\");\n        lifeGuard = _lifeGuard;\n        buoy = ILifeGuard(_lifeGuard).getBuoy();\n        emit LogNewLifeguard(_lifeGuard);\n    }\n\n    function setInsurance(address _insurance) external onlyOwner {\n        require(_insurance != address(0), \"setInsurance: 0x\");\n        insurance = _insurance;\n        emit LogNewInsurance(_insurance);\n    }\n\n    function setPnL(address _pnl) external onlyOwner {\n        require(_pnl != address(0), \"setPnl: 0x\");\n        pnl = _pnl;\n        emit LogNewPnl(_pnl);\n    }\n\n    function addSafeAddress(address account) external onlyOwner {\n        safeAddresses[account] = true;\n        emit LogNewSafeAddress(account);\n    }\n\n    function switchEoaOnly(bool check) external onlyOwner {\n        preventSmartContracts = check;\n    }\n\n    /// @notice Set limit for when a deposit will be rerouted for alternative logic\n    /// @param _percent %BP limit\n    /// @param _absolute Absolute limit\n    /// @dev The two limits should be used as an upper and lower bound - the % limit\n    ///     considers the current TVL in the token interacted with (gvt or pwrd) and will\n    ///     act as the upper bound when the TVL is low. The absolute value will be the lower bound,\n    ///     ensuring that small deposits won't suffer higher gas costs.\n    function setBigFishThreshold(uint256 _percent, uint256 _absolute) external onlyOwner {\n        require(_percent > 0, \"_whaleLimit is 0\");\n        bigFishThreshold = _percent;\n        bigFishAbsoluteThreshold = _absolute;\n        emit LogNewBigFishThreshold(_percent, _absolute);\n    }\n\n    function setReward(address _reward) external onlyOwner {\n        require(_reward != address(0), \"setReward: 0x\");\n        reward = _reward;\n        emit LogNewRewardsContract(_reward);\n    }\n\n    function addReferral(address account, address referral) external override {\n        require(msg.sender == depositHandler, \"!depositHandler\");\n        if (account != address(0) && referral != address(0) && referrals[account] == address(0)) {\n            referrals[account] = referral;\n        }\n    }\n\n    /// @notice Set withdrawal fee for token\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param newFee New token fee\n    function setWithdrawalFee(bool pwrd, uint256 newFee) external onlyOwner {\n        withdrawalFee[pwrd] = newFee;\n        emit LogNewWithdrawalFee(msg.sender, pwrd, newFee);\n    }\n\n    /// @notice Calculate system total assets\n    function totalAssets() external view override returns (uint256) {\n        return emergencyState ? _totalAssetsEmergency() : _totalAssets();\n    }\n\n    /// @notice Calculate pwrd/gro vault total assets\n    function gTokenTotalAssets() public view override returns (uint256) {\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        if (msg.sender == address(gvt)) {\n            return gvtAssets;\n        }\n        if (msg.sender == address(pwrd)) {\n            return pwrdAssets;\n        }\n        return 0;\n    }\n\n    function gToken(bool isPWRD) external view override returns (address) {\n        return isPWRD ? address(pwrd) : address(gvt);\n    }\n\n    /// @notice Check if the deposit/withdrawal needs to go through alternate logic\n    /// @param amount USD amount of deposit/withdrawal\n    /// @dev Larger deposits are handled differently than small deposits in order\n    ///     to guarantee that the system isn't overexposed to any one stablecoin\n    function isValidBigFish(\n        bool pwrd,\n        bool deposit,\n        uint256 amount\n    ) external view override returns (bool) {\n        if (deposit && pwrd) {\n            require(validGTokenIncrease(amount), \"isBigFish: !validGTokenIncrease\");\n        } else if (!pwrd && !deposit) {\n            require(validGTokenDecrease(amount), \"isBigFish: !validGTokenDecrease\");\n        }\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        uint256 assets = pwrdAssets.add(gvtAssets);\n        if (amount < bigFishAbsoluteThreshold) {\n            return false;\n        } else if (amount > assets) {\n            return true;\n        } else {\n            return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);\n        }\n    }\n\n    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist {\n        uint256[N_COINS] memory amounts = ILifeGuard(lifeGuard).distributeCurveVault(amount, delta);\n        emit LogNewCurveToStableDistribution(amount, amounts, delta);\n    }\n\n    /// @notice Block if not an EOA or whitelisted\n    /// @param sender Address of contract to check\n    function eoaOnly(address sender) public override {\n        if (preventSmartContracts && !safeAddresses[tx.origin]) {\n            require(sender == tx.origin, \"EOA only\");\n        }\n    }\n\n    /// @notice TotalAssets = lifeguard + stablecoin vaults + LP vault\n    function _totalAssets() private view returns (uint256) {\n        require(IBuoy(buoy).safetyCheck(), \"!buoy.safetyCheck\");\n        uint256[N_COINS] memory lgAssets = ILifeGuard(lifeGuard).getAssets();\n        uint256[N_COINS] memory vaultAssets;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            vaultAssets[i] = lgAssets[i].add(IVault(underlyingVaults[i]).totalAssets());\n        }\n        uint256 totalLp = IVault(curveVault).totalAssets();\n        totalLp = totalLp.add(IBuoy(buoy).stableToLp(vaultAssets, true));\n        uint256 vp = IBuoy(buoy).getVirtualPrice();\n\n        return totalLp.mul(vp).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    /// @notice Same as _totalAssets function, but excluding curve vault + 1 stablecoin\n    ///             and uses chianlink as a price oracle\n    function _totalAssetsEmergency() private view returns (uint256) {\n        IChainPrice chainPrice = IChainPrice(buoy);\n        uint256 total;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (i != deadCoin) {\n                address tokenAddress = getToken(i);\n                uint256 decimals = getDecimal(i);\n                IERC20 token = IERC20(tokenAddress);\n                uint256 price = chainPrice.getPriceFeed(i);\n                uint256 assets = IVault(underlyingVaults[i]).totalAssets().add(token.balanceOf(lifeGuard));\n                assets = assets.mul(price).div(CHAINLINK_PRICE_DECIMAL_FACTOR);\n                assets = assets.mul(DEFAULT_DECIMALS_FACTOR).div(decimals);\n                total = total.add(assets);\n            }\n        }\n        return total;\n    }\n\n    /// @notice Set protocol into emergency mode, disabling the use of a give stablecoin.\n    ///             This state assumes:\n    ///                 - Stablecoin of excessively of peg\n    ///                 - Curve3Pool has failed\n    ///             Swapping wil be disabled and the allocation target will be set to\n    ///             100 % for the disabled stablecoin, effectively stopping the system from\n    ///             returning any to the user. Deposit are disable in this mode.\n    /// @param coin Stable coin to disable\n    function emergency(uint256 coin) external onlyWhitelist {\n        require(coin < N_COINS, \"invalid coin\");\n        if (!paused()) {\n            _pause();\n        }\n        deadCoin = coin;\n        emergencyState = true;\n\n        uint256 percent;\n        for (uint256 i; i < N_COINS; i++) {\n            if (i == coin) {\n                percent = 10000;\n            } else {\n                percent = 0;\n            }\n            IInsurance(insurance).setUnderlyingTokenPercent(i, percent);\n        }\n        IPnL(pnl).emergencyPnL();\n    }\n\n    /// @notice Recover the system after emergency mode -\n    /// @param allocations New system target allocations\n    /// @dev Will recalculate system assets and atempt to give back any\n    ///     recovered assets to the GVT side\n    function restart(uint256[] calldata allocations) external onlyOwner whenPaused {\n        _unpause();\n        deadCoin = 99;\n        emergencyState = false;\n\n        for (uint256 i; i < N_COINS; i++) {\n            IInsurance(insurance).setUnderlyingTokenPercent(i, allocations[i]);\n        }\n        IPnL(pnl).recover();\n    }\n\n    /// @notice Distribute any gains or losses generated from a harvest\n    /// @param gain harvset gains\n    /// @param loss harvest losses\n    function distributeStrategyGainLoss(uint256 gain, uint256 loss) external override {\n        uint256 index = vaultIndexes[msg.sender];\n        require(index > 0 || index <= N_COINS + 1, \"!VaultAdaptor\");\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        uint256 gainUsd;\n        uint256 lossUsd;\n        index = index - 1;\n        if (index < N_COINS) {\n            if (gain > 0) {\n                gainUsd = ibuoy.singleStableToUsd(gain, index);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.singleStableToUsd(loss, index);\n            }\n        } else {\n            if (gain > 0) {\n                gainUsd = ibuoy.lpToUsd(gain);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.lpToUsd(loss);\n            }\n        }\n        ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);\n        // Check if curve spot price within tollerance, if so update them\n        if (ibuoy.updateRatios()) {\n            // If the curve ratios were successfully updated, realize system price changes\n            ipnl.distributePriceChange(_totalAssets());\n        }\n    }\n\n    function realizePriceChange(uint256 tolerance) external onlyOwner {\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        if (emergencyState) {\n            ipnl.distributePriceChange(_totalAssetsEmergency());\n        } else {\n            // Check if curve spot price within tollerance, if so update them\n            if (ibuoy.updateRatiosWithTolerance(tolerance)) {\n                // If the curve ratios were successfully updated, realize system price changes\n                ipnl.distributePriceChange(_totalAssets());\n            }\n        }\n    }\n\n    function burnGToken(\n        bool pwrd,\n        bool all,\n        address account,\n        uint256 amount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == withdrawHandler || msg.sender == emergencyHandler, \"burnGToken: !withdrawHandler\");\n        IToken gt = gTokens(pwrd);\n        if (!all) {\n            gt.burn(account, gt.factor(), amount);\n        } else {\n            gt.burnAll(account);\n        }\n        // Update underlying assets held in pwrd/gvt\n        IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount, bonus);\n    }\n\n    function mintGToken(\n        bool pwrd,\n        address account,\n        uint256 amount\n    ) external override {\n        require(msg.sender == depositHandler, \"burnGToken: !depositHandler\");\n        IToken gt = gTokens(pwrd);\n        gt.mint(account, gt.factor(), amount);\n        IPnL(pnl).increaseGTokenLastAmount(pwrd, amount);\n    }\n\n    /// @notice Calcualte withdrawal value when withdrawing all\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param account User account\n    function getUserAssets(bool pwrd, address account) external view override returns (uint256 deductUsd) {\n        IToken gt = gTokens(pwrd);\n        deductUsd = gt.getAssets(account);\n        require(deductUsd > 0, \"!minAmount\");\n    }\n\n    /// @notice Check if it's OK to mint the specified amount of tokens, this affects\n    ///     pwrds, as they have an upper bound set by the amount of gvt\n    /// @param amount Amount of token to mint\n    function validGTokenIncrease(uint256 amount) private view returns (bool) {\n        return\n            gTokens(false).totalAssets().mul(utilisationRatioLimitPwrd).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            amount.add(gTokens(true).totalAssets());\n    }\n\n    /// @notice Check if it's OK to burn the specified amount of tokens, this affects\n    ///     gvt, as they have a lower bound set by the amount of pwrds\n    /// @param amount Amount of token to burn\n    function validGTokenDecrease(uint256 amount) public view override returns (bool) {\n        return\n            gTokens(false).totalAssets().sub(amount).mul(utilisationRatioLimitGvt).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            gTokens(true).totalAssets();\n    }\n\n    /// @notice Set the lower bound for when to stop accepting deposits for pwrd - this allows for a bit of legroom\n    ///     for gvt to be sold (if this limit is reached, this contract only accepts deposits for gvt)\n    /// @param _utilisationRatioLimitPwrd Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitPwrd(uint256 _utilisationRatioLimitPwrd) external onlyOwner {\n        utilisationRatioLimitPwrd = _utilisationRatioLimitPwrd;\n        emit LogNewUtilLimit(true, _utilisationRatioLimitPwrd);\n    }\n\n    /// @notice Set the lower bound for when to stop accepting gvt withdrawals\n    /// @param _utilisationRatioLimitGvt Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitGvt(uint256 _utilisationRatioLimitGvt) external onlyOwner {\n        utilisationRatioLimitGvt = _utilisationRatioLimitGvt;\n        emit LogNewUtilLimit(false, _utilisationRatioLimitGvt);\n    }\n\n    function getStrategiesTargetRatio() external view override returns (uint256[] memory) {\n        uint256 utilRatio = IPnL(pnl).utilisationRatio();\n        return IInsurance(insurance).getStrategiesTargetRatio(utilRatio);\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction sortVaultsByDelta(..)\n..\n    for (uint256 i = 0; i < N_COINS; i++) {\n        // Get difference between vault current assets and vault target\n        int256 delta = int256(unifiedAssets[i] unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result\n",
                    "//solidity\n function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)...\n..\n emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result\n",
                    "//solidity\nfunction safetyCheck() external view override returns (bool) {\n    ...\n        _ratio = abs(int256(_ratio lastRatio[i])); // underflow in intermediate result\n"
                ],
                "Type": " implicit underflows",
                "Description": "\nThere are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert.\n* int256(a-b) where a and b are uint: For example, if a=1 and b=2, then the intermediate result would be uint(-1) == 2256-1\n* int256(-x) where x is a uint. For example, if x=1, then the intermediate result would be uint(-1) == 2256-1\n\nIt's better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x.\n\nFrom Exposure.sol L178(https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178):\nsolidity\nfunction sortVaultsByDelta(..)\n..\n    for (uint256 i = 0; i < N_COINS; i++) {\n        // Get difference between vault current assets and vault target\n        int256 delta = int256(unifiedAssets[i] unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result\n\n\nFrom PnL.sol L112(https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112):\nsolidity\n function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)...\n..\n emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result\n\n\nFrom Buoy3Pool.sol L87(https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87):\nsolidity\nfunction safetyCheck() external view override returns (bool) {\n    ...\n        _ratio = abs(int256(_ratio lastRatio[i])); // underflow in intermediate result\n\n\n",
                "Repair": "Recommend replacing int256(a-b) with int256(a)-int256(b), and replacing int256(-x) with -int256(x)\n\nkristian-gro (Gro) confirmed but disagreed with severity(https://github.com/code-423n4/2021-06-gro-findings/issues/6#issuecomment-886260551):\n Confirmed and We've mitigated this issue in our release version.\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-06-gro-findings/issues/6#issuecomment-886260551):\n  Majority of overflow listed above seems low risk with one exception of safetyCheck. Underflow is a real risk here.safetyCheck is run every time a deposit is made. Ratios can change and the change does not need to be substantial for it to overflow. For that reason it's a high risk.\n\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "Buoy"
                ],
                "Type": " Usage of deprecated ChainLink API in  Buoy3Pool ",
                "Description": "\nThe Chainlink API (latestAnswer) used in the Buoy3Pool oracle wrappers is deprecated:\n\n This API is deprecated. Please see API Reference for the latest Price Feed API. Chainlink Docs(https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/#latestanswer)\n\nIt seems like the old API can return stale data. Checks similar to that of the new API using latestTimestamp and latestRoundare are needed, as this could lead to stale prices according to the Chainlink documentation:\n* under current notifications: \"if answeredInRound < roundId could indicate stale data.\"(https://docs.chain.link/docs/developer-communications#current-notifications)\n* under historical price data: \"A timestamp with zero value means the round is not complete and should not be used.\"(https://docs.chain.link/docs/historical-price-data#solidity)\n\n",
                "Repair": "Recommend adding checks similar to latestTimestamp and latestRoundare\n\nsolidity\n(\n    uint80 roundID,\n    int256 price,\n    ,\n    uint256 timeStamp,\n    uint80 answeredInRound\n) = chainlink.latestRoundData();\nrequire(\n    timeStamp != 0,\n    \u201cChainlinkOracle::getLatestAnswer: round is not complete\u201d\n);\nrequire(\n    answeredInRound = roundID,\n    \u201cChainlinkOracle::getLatestAnswer: stale data\u201d\n);\nrequire(price != 0, \"Chainlink Malfunction\u201d);\n\n\nkristian-gro (Gro) confirmed(https://github.com/code-423n4/2021-06-gro-findings/issues/106)\n Confirmed and Fix has been implemented in release version.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "addSafeAddress()",
                    "eoaOnly()"
                ],
                "Type": " Safe addresses can only be added but not removed",
                "Description": "\n\nThe addSafeAddress()  takes an address and adds it to a \u201csafe list\". This is used in eoaOnly() to give exemption to safe addresses that are trusted smart contracts, when all other smart contacts are prevented from protocol interaction. The stated purpose is to allow only such partner/trusted smart contract integrations (project rep mentioned Argent wallet as the only one for now but that may change) an exemption from potential flash loan threats. But if there is a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern.\n\nScenario: A trusted integration/partner address is added to the safe list. But that wallet/protocol/DApp is later manipulated (by the project, its users or an attacker) to somehow launch a flash loan attack on the protocol. However, its address cannot be removed from the safe list and the protocol cannot prevent flash loan manipulations from that source because of its exemption. Contract/project will have to be redeployed.\n\n",
                "Repair": "Recommend changing addSafeAddress() to isSafeAddress() with an additional bool parameter to allow both the enabling _AND_ disabling of safe addresses.\n\nkristian-gro (Gro) confirmed but disagreed with severity(https://github.com/code-423n4/2021-06-gro-findings/issues/51#issuecomment-880043980):\n low risk Made specifically for one partner in beta period, and planned to be removed. We added the removal function for sanity.\n \n Confirmed and Fix has been implemented in release version.\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-06-gro-findings/issues/51#issuecomment-886327301):\n  I'll keep medium risk because this could put the protocol into a one way street and not being able to remove safe addresses is quite dangerous. Medium risk.\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "switchEoaOnly()",
                    "preventSmartContracts"
                ],
                "Type": " Flash loan risk mitigation is optional and not robust enough",
                "Description": "\nThe switchEoaOnly() allows the owner to disable preventSmartContracts (the project\u2019s plan apparently is to do so after the beta-period) which will allow any smart contract to interact with the protocol and potentially exploit any underlying flash loan vulnerabilities which are specified as an area of critical concern.\n\nThe current mitigation is to optionally prevent contracts, except whitelisted partner ones, from interacting with the protocol to prevent any flash loan manipulations. A more robust approach would be to add logic preventing multiple txs to the protocol from the same address/tx.origin within the same block when smart contracts are allowed. This will avoid any reliance on trust with integrating partners/protocols.\n\n",
                "Repair": "Recommend adding logic that prevents multiple txs to the protocol from the same address and within the same block.\n\nkristian-gro (Gro) acknowledged but disagreed with severity(https://github.com/code-423n4/2021-06-gro-findings/issues/52#issuecomment-880041099):\n Low-severity: This is a temporary blocker to not let SCs interact with gro-protocol, planned to be removed after beta as it might potentially stop other integrations (as per issue 51)\n \n Acknowledged, this is just a temporary block, and is planned to be removed in future releases other protection exists to protect the system from flash loan manipulations.\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-06-gro-findings/issues/52#issuecomment-886701698):\n  It looks like a low risk issue since it's a future problem and not something that is an immediate issue, however, it's not clear how the protocol will protect itself against flash loans after this temporary blocker is off. One of the critical protocol's concerns are flash loans manipulations therefore I think medium risk is justified here.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport {FixedStablecoins, FixedGTokens} from \"./common/FixedContracts.sol\";\nimport \"./common/Whitelist.sol\";\n\nimport \"./interfaces/IBuoy.sol\";\nimport \"./interfaces/IChainPrice.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IInsurance.sol\";\nimport \"./interfaces/ILifeGuard.sol\";\nimport \"./interfaces/IPnL.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/// @notice The main hub for Gro protocol - The controller links up the other contracts,\n///     and acts a route for the other contracts to call one another. It holds global states\n///     such as paused and emergency. Contracts that depend on the controller implement\n///     Controllable.\n///\n///     *****************************************************************************\n///     System tokens - GTokens:\n///     gvt - high yield, uninsured\n///     pwrd - insured by gvt, pays part of its yield to gvt (depending on utilisation)\n///\n///     Tokens order is DAI, USDC, USDT.\n///     Index 0 - DAI, 1 - USDC, 2 - USDT\n///\n///     System vaults:\n///     Stablecoin vaults: One per stablecoin\n///     Curve vault: Vault for LP (liquidity pool) token\ncontract Controller is Pausable, Ownable, Whitelist, FixedStablecoins, FixedGTokens, IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public override curveVault; // LP token vault\n\n    bool public preventSmartContracts = false;\n\n    address public override insurance; // Insurance logic\n    address public override pnl; // Profit and loss calculations\n    address public override lifeGuard; // Asset swapping\n    address public override buoy; // Oracle\n    address public override depositHandler;\n    address public override withdrawHandler;\n    address public override emergencyHandler;\n\n    uint256 public override deadCoin = 99;\n    bool public override emergencyState;\n    // Lower bound for how many gvt can be burned before getting to close to the utilisation ratio\n    uint256 public utilisationRatioLimitGvt;\n    uint256 public utilisationRatioLimitPwrd;\n\n    /// Limits for what deposits/withdrawals that are considered 'large', and thus will be handled with\n    ///     a different logic - limits are checked against total assets locked in etiher of the two tokens (pwrd, gvt)\n    uint256 public bigFishThreshold = 100; // %Basis Points limit\n    uint256 public bigFishAbsoluteThreshold = 0; // Absolute limit\n    address public override reward;\n\n    mapping(address => bool) public safeAddresses; // Some integrations need to be exempt from flashloan checks\n    mapping(uint256 => address) public override underlyingVaults; // Protocol stablecoin vaults\n    mapping(address => uint256) public vaultIndexes;\n\n    mapping(address => address) public override referrals;\n\n    // Pwrd (true) and gvt (false) mapped to respective withdrawal fee\n    mapping(bool => uint256) public override withdrawalFee;\n\n    event LogNewWithdrawHandler(address tokens);\n    event LogNewDepositHandler(address tokens);\n    event LogNewVault(uint256 index, address vault);\n    event LogNewCurveVault(address curveVault);\n    event LogNewLifeguard(address lifeguard);\n    event LogNewInsurance(address insurance);\n    event LogNewPnl(address pnl);\n    event LogNewBigFishThreshold(uint256 percent, uint256 absolute);\n    event LogFlashSwitchUpdated(bool status);\n    event LogNewSafeAddress(address account);\n    event LogNewRewardsContract(address reward);\n    event LogNewUtilLimit(bool indexed pwrd, uint256 limit);\n    event LogNewCurveToStableDistribution(uint256 amount, uint256[N_COINS] amounts, uint256[N_COINS] delta);\n    event LogNewWithdrawalFee(address user, bool pwrd, uint256 newFee);\n\n    constructor(\n        address pwrd,\n        address gvt,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals\n    ) public FixedStablecoins(_tokens, _decimals) FixedGTokens(pwrd, gvt) {}\n\n    function pause() external onlyWhitelist {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {\n        require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");\n        withdrawHandler = _withdrawHandler;\n        emergencyHandler = _emergencyHandler;\n        emit LogNewWithdrawHandler(_withdrawHandler);\n    }\n\n    function setDepositHandler(address _depositHandler) external onlyOwner {\n        require(_depositHandler != address(0), \"setDepositHandler: 0x\");\n        depositHandler = _depositHandler;\n        emit LogNewDepositHandler(_depositHandler);\n    }\n\n    function stablecoins() external view override returns (address[N_COINS] memory) {\n        return underlyingTokens();\n    }\n\n    /// @notice Returns amount to skim of larger deposits for alternative vault (Curve)\n    function getSkimPercent() external view override returns (uint256) {\n        return IInsurance(insurance).calcSkim();\n    }\n\n    /// @notice Returns list of all the underling protocol vaults\n    function vaults() external view override returns (address[N_COINS] memory) {\n        address[N_COINS] memory result;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = underlyingVaults[i];\n        }\n        return result;\n    }\n\n    /// @notice Set system vaults, vault index should match its underlying token\n    function setVault(uint256 index, address vault) external onlyOwner {\n        require(vault != address(0), \"setVault: 0x\");\n        require(index < N_COINS, \"setVault: !index\");\n        underlyingVaults[index] = vault;\n        vaultIndexes[vault] = index + 1;\n        emit LogNewVault(index, vault);\n    }\n\n    function setCurveVault(address _curveVault) external onlyOwner {\n        require(_curveVault != address(0), \"setCurveVault: 0x\");\n        curveVault = _curveVault;\n        vaultIndexes[_curveVault] = N_COINS + 1;\n        emit LogNewCurveVault(_curveVault);\n    }\n\n    function setLifeGuard(address _lifeGuard) external onlyOwner {\n        require(_lifeGuard != address(0), \"setLifeGuard: 0x\");\n        lifeGuard = _lifeGuard;\n        buoy = ILifeGuard(_lifeGuard).getBuoy();\n        emit LogNewLifeguard(_lifeGuard);\n    }\n\n    function setInsurance(address _insurance) external onlyOwner {\n        require(_insurance != address(0), \"setInsurance: 0x\");\n        insurance = _insurance;\n        emit LogNewInsurance(_insurance);\n    }\n\n    function setPnL(address _pnl) external onlyOwner {\n        require(_pnl != address(0), \"setPnl: 0x\");\n        pnl = _pnl;\n        emit LogNewPnl(_pnl);\n    }\n\n    function addSafeAddress(address account) external onlyOwner {\n        safeAddresses[account] = true;\n        emit LogNewSafeAddress(account);\n    }\n\n    function switchEoaOnly(bool check) external onlyOwner {\n        preventSmartContracts = check;\n    }\n\n    /// @notice Set limit for when a deposit will be rerouted for alternative logic\n    /// @param _percent %BP limit\n    /// @param _absolute Absolute limit\n    /// @dev The two limits should be used as an upper and lower bound - the % limit\n    ///     considers the current TVL in the token interacted with (gvt or pwrd) and will\n    ///     act as the upper bound when the TVL is low. The absolute value will be the lower bound,\n    ///     ensuring that small deposits won't suffer higher gas costs.\n    function setBigFishThreshold(uint256 _percent, uint256 _absolute) external onlyOwner {\n        require(_percent > 0, \"_whaleLimit is 0\");\n        bigFishThreshold = _percent;\n        bigFishAbsoluteThreshold = _absolute;\n        emit LogNewBigFishThreshold(_percent, _absolute);\n    }\n\n    function setReward(address _reward) external onlyOwner {\n        require(_reward != address(0), \"setReward: 0x\");\n        reward = _reward;\n        emit LogNewRewardsContract(_reward);\n    }\n\n    function addReferral(address account, address referral) external override {\n        require(msg.sender == depositHandler, \"!depositHandler\");\n        if (account != address(0) && referral != address(0) && referrals[account] == address(0)) {\n            referrals[account] = referral;\n        }\n    }\n\n    /// @notice Set withdrawal fee for token\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param newFee New token fee\n    function setWithdrawalFee(bool pwrd, uint256 newFee) external onlyOwner {\n        withdrawalFee[pwrd] = newFee;\n        emit LogNewWithdrawalFee(msg.sender, pwrd, newFee);\n    }\n\n    /// @notice Calculate system total assets\n    function totalAssets() external view override returns (uint256) {\n        return emergencyState ? _totalAssetsEmergency() : _totalAssets();\n    }\n\n    /// @notice Calculate pwrd/gro vault total assets\n    function gTokenTotalAssets() public view override returns (uint256) {\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        if (msg.sender == address(gvt)) {\n            return gvtAssets;\n        }\n        if (msg.sender == address(pwrd)) {\n            return pwrdAssets;\n        }\n        return 0;\n    }\n\n    function gToken(bool isPWRD) external view override returns (address) {\n        return isPWRD ? address(pwrd) : address(gvt);\n    }\n\n    /// @notice Check if the deposit/withdrawal needs to go through alternate logic\n    /// @param amount USD amount of deposit/withdrawal\n    /// @dev Larger deposits are handled differently than small deposits in order\n    ///     to guarantee that the system isn't overexposed to any one stablecoin\n    function isValidBigFish(\n        bool pwrd,\n        bool deposit,\n        uint256 amount\n    ) external view override returns (bool) {\n        if (deposit && pwrd) {\n            require(validGTokenIncrease(amount), \"isBigFish: !validGTokenIncrease\");\n        } else if (!pwrd && !deposit) {\n            require(validGTokenDecrease(amount), \"isBigFish: !validGTokenDecrease\");\n        }\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        uint256 assets = pwrdAssets.add(gvtAssets);\n        if (amount < bigFishAbsoluteThreshold) {\n            return false;\n        } else if (amount > assets) {\n            return true;\n        } else {\n            return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);\n        }\n    }\n\n    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist {\n        uint256[N_COINS] memory amounts = ILifeGuard(lifeGuard).distributeCurveVault(amount, delta);\n        emit LogNewCurveToStableDistribution(amount, amounts, delta);\n    }\n\n    /// @notice Block if not an EOA or whitelisted\n    /// @param sender Address of contract to check\n    function eoaOnly(address sender) public override {\n        if (preventSmartContracts && !safeAddresses[tx.origin]) {\n            require(sender == tx.origin, \"EOA only\");\n        }\n    }\n\n    /// @notice TotalAssets = lifeguard + stablecoin vaults + LP vault\n    function _totalAssets() private view returns (uint256) {\n        require(IBuoy(buoy).safetyCheck(), \"!buoy.safetyCheck\");\n        uint256[N_COINS] memory lgAssets = ILifeGuard(lifeGuard).getAssets();\n        uint256[N_COINS] memory vaultAssets;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            vaultAssets[i] = lgAssets[i].add(IVault(underlyingVaults[i]).totalAssets());\n        }\n        uint256 totalLp = IVault(curveVault).totalAssets();\n        totalLp = totalLp.add(IBuoy(buoy).stableToLp(vaultAssets, true));\n        uint256 vp = IBuoy(buoy).getVirtualPrice();\n\n        return totalLp.mul(vp).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    /// @notice Same as _totalAssets function, but excluding curve vault + 1 stablecoin\n    ///             and uses chianlink as a price oracle\n    function _totalAssetsEmergency() private view returns (uint256) {\n        IChainPrice chainPrice = IChainPrice(buoy);\n        uint256 total;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (i != deadCoin) {\n                address tokenAddress = getToken(i);\n                uint256 decimals = getDecimal(i);\n                IERC20 token = IERC20(tokenAddress);\n                uint256 price = chainPrice.getPriceFeed(i);\n                uint256 assets = IVault(underlyingVaults[i]).totalAssets().add(token.balanceOf(lifeGuard));\n                assets = assets.mul(price).div(CHAINLINK_PRICE_DECIMAL_FACTOR);\n                assets = assets.mul(DEFAULT_DECIMALS_FACTOR).div(decimals);\n                total = total.add(assets);\n            }\n        }\n        return total;\n    }\n\n    /// @notice Set protocol into emergency mode, disabling the use of a give stablecoin.\n    ///             This state assumes:\n    ///                 - Stablecoin of excessively of peg\n    ///                 - Curve3Pool has failed\n    ///             Swapping wil be disabled and the allocation target will be set to\n    ///             100 % for the disabled stablecoin, effectively stopping the system from\n    ///             returning any to the user. Deposit are disable in this mode.\n    /// @param coin Stable coin to disable\n    function emergency(uint256 coin) external onlyWhitelist {\n        require(coin < N_COINS, \"invalid coin\");\n        if (!paused()) {\n            _pause();\n        }\n        deadCoin = coin;\n        emergencyState = true;\n\n        uint256 percent;\n        for (uint256 i; i < N_COINS; i++) {\n            if (i == coin) {\n                percent = 10000;\n            } else {\n                percent = 0;\n            }\n            IInsurance(insurance).setUnderlyingTokenPercent(i, percent);\n        }\n        IPnL(pnl).emergencyPnL();\n    }\n\n    /// @notice Recover the system after emergency mode -\n    /// @param allocations New system target allocations\n    /// @dev Will recalculate system assets and atempt to give back any\n    ///     recovered assets to the GVT side\n    function restart(uint256[] calldata allocations) external onlyOwner whenPaused {\n        _unpause();\n        deadCoin = 99;\n        emergencyState = false;\n\n        for (uint256 i; i < N_COINS; i++) {\n            IInsurance(insurance).setUnderlyingTokenPercent(i, allocations[i]);\n        }\n        IPnL(pnl).recover();\n    }\n\n    /// @notice Distribute any gains or losses generated from a harvest\n    /// @param gain harvset gains\n    /// @param loss harvest losses\n    function distributeStrategyGainLoss(uint256 gain, uint256 loss) external override {\n        uint256 index = vaultIndexes[msg.sender];\n        require(index > 0 || index <= N_COINS + 1, \"!VaultAdaptor\");\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        uint256 gainUsd;\n        uint256 lossUsd;\n        index = index - 1;\n        if (index < N_COINS) {\n            if (gain > 0) {\n                gainUsd = ibuoy.singleStableToUsd(gain, index);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.singleStableToUsd(loss, index);\n            }\n        } else {\n            if (gain > 0) {\n                gainUsd = ibuoy.lpToUsd(gain);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.lpToUsd(loss);\n            }\n        }\n        ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);\n        // Check if curve spot price within tollerance, if so update them\n        if (ibuoy.updateRatios()) {\n            // If the curve ratios were successfully updated, realize system price changes\n            ipnl.distributePriceChange(_totalAssets());\n        }\n    }\n\n    function realizePriceChange(uint256 tolerance) external onlyOwner {\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        if (emergencyState) {\n            ipnl.distributePriceChange(_totalAssetsEmergency());\n        } else {\n            // Check if curve spot price within tollerance, if so update them\n            if (ibuoy.updateRatiosWithTolerance(tolerance)) {\n                // If the curve ratios were successfully updated, realize system price changes\n                ipnl.distributePriceChange(_totalAssets());\n            }\n        }\n    }\n\n    function burnGToken(\n        bool pwrd,\n        bool all,\n        address account,\n        uint256 amount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == withdrawHandler || msg.sender == emergencyHandler, \"burnGToken: !withdrawHandler\");\n        IToken gt = gTokens(pwrd);\n        if (!all) {\n            gt.burn(account, gt.factor(), amount);\n        } else {\n            gt.burnAll(account);\n        }\n        // Update underlying assets held in pwrd/gvt\n        IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount, bonus);\n    }\n\n    function mintGToken(\n        bool pwrd,\n        address account,\n        uint256 amount\n    ) external override {\n        require(msg.sender == depositHandler, \"burnGToken: !depositHandler\");\n        IToken gt = gTokens(pwrd);\n        gt.mint(account, gt.factor(), amount);\n        IPnL(pnl).increaseGTokenLastAmount(pwrd, amount);\n    }\n\n    /// @notice Calcualte withdrawal value when withdrawing all\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param account User account\n    function getUserAssets(bool pwrd, address account) external view override returns (uint256 deductUsd) {\n        IToken gt = gTokens(pwrd);\n        deductUsd = gt.getAssets(account);\n        require(deductUsd > 0, \"!minAmount\");\n    }\n\n    /// @notice Check if it's OK to mint the specified amount of tokens, this affects\n    ///     pwrds, as they have an upper bound set by the amount of gvt\n    /// @param amount Amount of token to mint\n    function validGTokenIncrease(uint256 amount) private view returns (bool) {\n        return\n            gTokens(false).totalAssets().mul(utilisationRatioLimitPwrd).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            amount.add(gTokens(true).totalAssets());\n    }\n\n    /// @notice Check if it's OK to burn the specified amount of tokens, this affects\n    ///     gvt, as they have a lower bound set by the amount of pwrds\n    /// @param amount Amount of token to burn\n    function validGTokenDecrease(uint256 amount) public view override returns (bool) {\n        return\n            gTokens(false).totalAssets().sub(amount).mul(utilisationRatioLimitGvt).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            gTokens(true).totalAssets();\n    }\n\n    /// @notice Set the lower bound for when to stop accepting deposits for pwrd - this allows for a bit of legroom\n    ///     for gvt to be sold (if this limit is reached, this contract only accepts deposits for gvt)\n    /// @param _utilisationRatioLimitPwrd Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitPwrd(uint256 _utilisationRatioLimitPwrd) external onlyOwner {\n        utilisationRatioLimitPwrd = _utilisationRatioLimitPwrd;\n        emit LogNewUtilLimit(true, _utilisationRatioLimitPwrd);\n    }\n\n    /// @notice Set the lower bound for when to stop accepting gvt withdrawals\n    /// @param _utilisationRatioLimitGvt Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitGvt(uint256 _utilisationRatioLimitGvt) external onlyOwner {\n        utilisationRatioLimitGvt = _utilisationRatioLimitGvt;\n        emit LogNewUtilLimit(false, _utilisationRatioLimitGvt);\n    }\n\n    function getStrategiesTargetRatio() external view override returns (uint256[] memory) {\n        uint256 utilRatio = IPnL(pnl).utilisationRatio();\n        return IInsurance(insurance).getStrategiesTargetRatio(utilRatio);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"../interfaces/ICurve.sol\";\nimport \"./MockERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./MockLPToken.sol\";\n\n// Mock curve 3pool for deposit/withdrawal\ncontract MockCurveDeposit is ICurve3Deposit {\n    using SafeERC20 for IERC20;\n\n    address[] public coins;\n    uint256 N_COINS = 3;\n    uint256[] public PRECISION_MUL = [1, 1000000000000, 1000000000000];\n    uint256[] public decimals = [18, 6, 6];\n    uint256[] public rates = [1001835600000000000, 999482, 999069];\n    uint256 constant vp = 1005530723799997871;\n    uint256[] vpSingle = [996343755718242128, 994191500557422927, 993764724471177721];\n    uint256[] desired_ratio = [250501710687927000, 386958750403203000, 362539538908870000];\n    uint256[] poolratio = [20, 40, 40];\n    uint256 Fee = 4000;\n    MockLPToken PoolToken;\n\n    constructor(address[] memory _tokens, address _PoolToken) public {\n        coins = _tokens;\n        PoolToken = MockLPToken(_PoolToken);\n    }\n\n    function setTokens(\n        address[] calldata _tokens,\n        uint256[] calldata _precisions,\n        uint256[] calldata _rates\n    ) external {\n        coins = _tokens;\n        N_COINS = _tokens.length;\n        PRECISION_MUL = _precisions;\n        rates = _rates;\n    }\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external override {\n        i;\n        j;\n        dx;\n        min_dy;\n    }\n\n    function add_liquidity(uint256[3] calldata uamounts, uint256 min_mint_amount) external override {\n        uint256 amount;\n        for (uint256 i; i < N_COINS; i++) {\n            IERC20 token = IERC20(coins[i]);\n            token.safeTransferFrom(msg.sender, address(this), uamounts[i]);\n            amount = ((uamounts[i] * (10**(18 - decimals[i]))) * vpSingle[i]) / (10**18);\n        }\n        PoolToken.mint(msg.sender, min_mint_amount);\n    }\n\n    function remove_liquidity(uint256 amount, uint256[3] calldata min_uamounts) external override {\n        require(PoolToken.balanceOf(msg.sender) > amount, \"remove_liquidity: !balance\");\n        PoolToken.burn(msg.sender, amount);\n        for (uint256 i; i < N_COINS; i++) {\n            IERC20 token = IERC20(coins[i]);\n            token.transfer(msg.sender, min_uamounts[i]);\n        }\n    }\n\n    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external override {\n        require(PoolToken.balanceOf(msg.sender) > max_burn_amount, \"remove_liquidity: !balance\");\n        PoolToken.burn(msg.sender, max_burn_amount);\n        for (uint256 i; i < N_COINS; i++) {\n            IERC20 token = IERC20(coins[i]);\n            if (amounts[i] > 0) {\n                token.safeTransfer(msg.sender, amounts[i]);\n            }\n        }\n    }\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external override {\n        min_amount;\n        require(PoolToken.balanceOf(msg.sender) > _token_amount, \"remove_liquidity: !balance\");\n        uint256 outAmount = ((_token_amount * (10**18)) / vpSingle[uint256(i)]) / PRECISION_MUL[uint256(i)];\n        PoolToken.burn(msg.sender, _token_amount);\n        IERC20 token = IERC20(coins[uint256(i)]);\n        token.safeTransfer(msg.sender, outAmount);\n    }\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view override returns (uint256) {\n        uint256 x = rates[uint256(i)] * dx * PRECISION_MUL[uint256(i)];\n        uint256 y = rates[uint256(j)] * PRECISION_MUL[uint256(j)];\n        return x / y;\n    }\n\n    function calc_token_amount(uint256[3] calldata inAmounts, bool deposit) external view returns (uint256) {\n        deposit;\n        uint256 totalAmount;\n        for (uint256 i = 0; i < vpSingle.length; i++) {\n            totalAmount += (inAmounts[i] * vpSingle[i]) / (10**decimals[i]);\n        }\n        return totalAmount;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {FixedStablecoins} from \"contracts/common/FixedContracts.sol\";\nimport {ICurve3Pool} from \"contracts/interfaces/ICurve.sol\";\n\nimport \"contracts/common/Controllable.sol\";\n\nimport \"contracts/interfaces/IBuoy.sol\";\nimport \"contracts/interfaces/IChainPrice.sol\";\nimport \"contracts/interfaces/IChainlinkAggregator.sol\";\nimport \"contracts/interfaces/IERC20Detailed.sol\";\n\n/// @notice Contract for calculating prices of underlying assets and LP tokens in Curve pool. Also\n///     used to sanity check pool against external oracle, to ensure that pools underlying coin ratios\n///     are within a specific range (measued in BP) of the external oracles coin price ratios.\n///     Sanity check:\n///         The Buoy checks previously recorded (cached) curve coin dy, which it compares against current curve dy,\n///         blocking any interaction that is outside a certain tolerance (BASIS_POINTS). When updting the cached\n///         value, the buoy uses chainlink to ensure that curves prices arent off peg.\ncontract Buoy3Pool is FixedStablecoins, Controllable, IBuoy, IChainPrice {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 TIME_LIMIT = 3000;\n    uint256 public BASIS_POINTS = 20;\n    uint256 constant CHAIN_FACTOR = 100;\n\n    ICurve3Pool public immutable override curvePool;\n    IERC20 public immutable lpToken;\n\n    mapping(uint256 => uint256) lastRatio;\n\n    // Chianlink price feed\n    address public immutable daiUsdAgg;\n    address public immutable usdcUsdAgg;\n    address public immutable usdtUsdAgg;\n\n    mapping(address => mapping(address => uint256)) public tokenRatios;\n\n    event LogNewBasisPointLimit(uint256 oldLimit, uint256 newLimit);\n\n    constructor(\n        address _crv3pool,\n        address poolToken,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals,\n        address[N_COINS] memory aggregators\n    ) public FixedStablecoins(_tokens, _decimals) {\n        curvePool = ICurve3Pool(_crv3pool);\n        lpToken = IERC20(poolToken);\n        daiUsdAgg = aggregators[0];\n        usdcUsdAgg = aggregators[1];\n        usdtUsdAgg = aggregators[2];\n    }\n\n    /// @notice Set limit for how much Curve pool and external oracle is allowed\n    ///     to deviate before failing transactions\n    /// @param newLimit New limit in BP\n    function setBasisPointsLmit(uint256 newLimit) external onlyOwner {\n        uint256 oldLimit = BASIS_POINTS;\n        BASIS_POINTS = newLimit;\n        emit LogNewBasisPointLimit(oldLimit, newLimit);\n    }\n\n    /// @notice Check the health of the Curve pool:\n    ///     Ratios are checked by the following heuristic:\n    ///     Orcale A - Curve\n    ///     Oracle B - External oracle\n    ///     Both oracles establish ratios for a set of stable coins\n    ///         (a, b, c)\n    ///     and product the following set of ratios:\n    ///         (a/a, a/b, a/c), (b/b, b/a, b/c), (c/c, c/a, c/b)\n    ///     It's simply to reduce the number of comparisons to be made\n    ///     in order to have complete coverage of the system ratios:\n    ///         1) ratios between a stable coin and itself can be discarded\n    ///         2) inverted ratios, a/b bs b/a, while producing different results\n    ///             should both reflect the same change in any one of the two\n    ///             underlying assets, but in opposite directions\n    ///     This mean that the following set should provide the necessary coverage checks\n    ///     to establish that the coins pricing is healthy:\n    ///         (a/b, a/c)\n    function safetyCheck() external view override returns (bool) {\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            _ratio = abs(int256(_ratio - lastRatio[i]));\n            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Updated cached curve value with a custom tolerance towards chainlink\n    /// @param tolerance How much difference between curve and chainlink can be tolerated\n    function updateRatiosWithTolerance(uint256 tolerance) external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatiosWithTolerance: !authorized\");\n        return _updateRatios(tolerance);\n    }\n\n    /// @notice Updated cached curve values\n    function updateRatios() external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatios: !authorized\");\n        return _updateRatios(BASIS_POINTS);\n    }\n\n    /// @notice Get USD value for a specific input amount of tokens, slippage included\n    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToUsd(inAmounts, deposit);\n    }\n\n    /// @notice Get estimate USD price of a stablecoin amount\n    /// @param inAmount Token amount\n    /// @param i Index of token\n    function singleStableToUsd(uint256 inAmount, uint256 i) external view override returns (uint256) {\n        uint256[N_COINS] memory inAmounts;\n        inAmounts[i] = inAmount;\n        return _stableToUsd(inAmounts, true);\n    }\n\n    /// @notice Get LP token value of input amount of tokens\n    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToLp(tokenAmounts, deposit);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromUsd(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(_usdToLp(inAmount), i);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromLp(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(inAmount, i);\n    }\n\n    /// @notice Get USD price of LP tokens you receive for a specific input amount of tokens, slippage included\n    function lpToUsd(uint256 inAmount) external view override returns (uint256) {\n        return _lpToUsd(inAmount);\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function usdToLp(uint256 inAmount) external view override returns (uint256) {\n        return _usdToLp(inAmount);\n    }\n\n    /// @notice Split LP token amount to balance of pool tokens\n    /// @param inAmount Amount of LP tokens\n    /// @param totalBalance Total balance of pool\n    function poolBalances(uint256 inAmount, uint256 totalBalance)\n        internal\n        view\n        returns (uint256[N_COINS] memory balances)\n    {\n        uint256[N_COINS] memory _balances;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _balances[i] = (IERC20(getToken(i)).balanceOf(address(curvePool)).mul(inAmount)).div(totalBalance);\n        }\n        balances = _balances;\n    }\n\n    function getVirtualPrice() external view override returns (uint256) {\n        return curvePool.get_virtual_price();\n    }\n\n    // Internal functions\n    function _lpToUsd(uint256 inAmount) internal view returns (uint256) {\n        return inAmount.mul(curvePool.get_virtual_price()).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {\n        require(tokenAmounts.length == N_COINS, \"deposit: !length\");\n        uint256[N_COINS] memory _tokenAmounts;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _tokenAmounts[i] = tokenAmounts[i];\n        }\n        uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);\n        return _lpToUsd(lpAmount);\n    }\n\n    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {\n        require(tokenAmounts.length == N_COINS, \"deposit: !length\");\n        uint256[N_COINS] memory _tokenAmounts;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _tokenAmounts[i] = tokenAmounts[i];\n        }\n        return curvePool.calc_token_amount(_tokenAmounts, deposit);\n    }\n\n    function _singleStableFromLp(uint256 inAmount, int128 i) internal view returns (uint256) {\n        uint256 result = curvePool.calc_withdraw_one_coin(inAmount, i);\n        return result;\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function _usdToLp(uint256 inAmount) internal view returns (uint256) {\n        return inAmount.mul(DEFAULT_DECIMALS_FACTOR).div(curvePool.get_virtual_price());\n    }\n\n    /// @notice Calculate price ratios for stablecoins\n    ///     Get USD price data for stablecoin\n    /// @param i Stablecoin to get USD price for\n    function getPriceFeed(uint256 i) external view override returns (uint256 _price) {\n        _price = uint256(IChainlinkAggregator(getAggregator(i)).latestAnswer());\n    }\n\n    /// @notice Fetch chainlink token ratios\n    /// @param i Token in\n    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) {\n        uint256[3] memory _prices;\n        _prices[0] = uint256(IChainlinkAggregator(getAggregator(0)).latestAnswer());\n        _prices[1] = uint256(IChainlinkAggregator(getAggregator(1)).latestAnswer());\n        _prices[2] = uint256(IChainlinkAggregator(getAggregator(2)).latestAnswer());\n        for (uint256 j = 0; j < 3; j++) {\n            if (i == j) {\n                _ratios[i] = CHAINLINK_PRICE_DECIMAL_FACTOR;\n            } else {\n                _ratios[j] = _prices[i].mul(CHAINLINK_PRICE_DECIMAL_FACTOR).div(_prices[j]);\n            }\n        }\n        return _ratios;\n    }\n\n    function getAggregator(uint256 index) private view returns (address) {\n        if (index == 0) {\n            return daiUsdAgg;\n        } else if (index == 1) {\n            return usdcUsdAgg;\n        } else {\n            return usdtUsdAgg;\n        }\n    }\n\n    /// @notice Get absolute value\n    function abs(int256 x) private pure returns (uint256) {\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n\n    function _updateRatios(uint256 tolerance) private returns (bool) {\n        uint256[N_COINS] memory chainRatios = getTokenRatios(0);\n        uint256[N_COINS] memory newRatios;\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            uint256 check = abs(int256(_ratio) - int256(chainRatios[i].div(CHAIN_FACTOR)));\n            if (check.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > tolerance) {\n                return false;\n            } else {\n                newRatios[i] = _ratio;\n            }\n        }\n        for (uint256 i = 1; i < N_COINS; i++) {\n            lastRatio[i] = newRatios[i];\n        }\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol",
            "MockCurveDeposit.sol",
            "Buoy3Pool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "a/b",
                    "BASIS_POINTS",
                    "b/a",
                    "a/c",
                    "b/c",
                    "safetyCheck",
                    "_ratio",
                    "_updateRatios",
                    "Buoy",
                    "lastRatio"
                ],
                "Type": "  Buoy3Pool.safetyCheck  is not precise and has some assumptions",
                "Description": "\nThe safetyCheck function has several issues that impact how precise the checks are:\n\n1. Only checks if the a/b and a/c ratios are within BASIS_POINTS.\nBy transitivity, b/c is only within 2 * BASIS_POINTS if a/b and a/c are in range.\nFor a more precise check whether both USDC and USDT are within range, b/c must be checked as well.\n\n2. If a/b is within range, this does not imply that b/a is within range.\n*  \"inverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions\"\n\n* Example: lastRatio = 1.0\nratio: a = 1.0, b = 0.8 = a/b = 1.25, b/a = 0.8\nIf a/b was used with a 20% range, it'd be out of range, but b/a is in range.\n\n3. The NatSpec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both _ratio and lastRatio are only from Curve. Only _updateRatios checks the oracle.\n\nTo address this issue, it is recommended to check if b/c is within BASIS_POINTS .\n\nkristian-gro (Gro) confirmed but disagreed with severity(https://github.com/code-423n4/2021-06-gro-findings/issues/104#issuecomment-880192089):\n  Makes strong assumption about the range of possible values small differences between a and b will result in small differences between a/b and b/a Extreme cases are handled by emergency. Agree on b/c check\n\nkristian-gro (Gro) commented(https://github.com/code-423n4/2021-06-gro-findings/issues/104#issuecomment-880192847):\n  medium severity will only cause stop of deposits/withdrawals against curve, work around to put in emergency mode\n\nkristian-gro (Gro) commented:\n Acknowledged, but the differences between variables are in basis points, we've simulated flash loan manipulations of curve and come to the conclusion that this approximation has a sufficiently small error margin to not cause issues.\n The B/C check (usdc/usdt) has been added in release version.\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-06-gro-findings/issues/104#issuecomment-886346641):\n  A possibility of stopping deposits or withdrawals deserves high risk.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport {FixedStablecoins, FixedGTokens} from \"./common/FixedContracts.sol\";\nimport \"./common/Whitelist.sol\";\n\nimport \"./interfaces/IBuoy.sol\";\nimport \"./interfaces/IChainPrice.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IInsurance.sol\";\nimport \"./interfaces/ILifeGuard.sol\";\nimport \"./interfaces/IPnL.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/// @notice The main hub for Gro protocol - The controller links up the other contracts,\n///     and acts a route for the other contracts to call one another. It holds global states\n///     such as paused and emergency. Contracts that depend on the controller implement\n///     Controllable.\n///\n///     *****************************************************************************\n///     System tokens - GTokens:\n///     gvt - high yield, uninsured\n///     pwrd - insured by gvt, pays part of its yield to gvt (depending on utilisation)\n///\n///     Tokens order is DAI, USDC, USDT.\n///     Index 0 - DAI, 1 - USDC, 2 - USDT\n///\n///     System vaults:\n///     Stablecoin vaults: One per stablecoin\n///     Curve vault: Vault for LP (liquidity pool) token\ncontract Controller is Pausable, Ownable, Whitelist, FixedStablecoins, FixedGTokens, IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public override curveVault; // LP token vault\n\n    bool public preventSmartContracts = false;\n\n    address public override insurance; // Insurance logic\n    address public override pnl; // Profit and loss calculations\n    address public override lifeGuard; // Asset swapping\n    address public override buoy; // Oracle\n    address public override depositHandler;\n    address public override withdrawHandler;\n    address public override emergencyHandler;\n\n    uint256 public override deadCoin = 99;\n    bool public override emergencyState;\n    // Lower bound for how many gvt can be burned before getting to close to the utilisation ratio\n    uint256 public utilisationRatioLimitGvt;\n    uint256 public utilisationRatioLimitPwrd;\n\n    /// Limits for what deposits/withdrawals that are considered 'large', and thus will be handled with\n    ///     a different logic - limits are checked against total assets locked in etiher of the two tokens (pwrd, gvt)\n    uint256 public bigFishThreshold = 100; // %Basis Points limit\n    uint256 public bigFishAbsoluteThreshold = 0; // Absolute limit\n    address public override reward;\n\n    mapping(address => bool) public safeAddresses; // Some integrations need to be exempt from flashloan checks\n    mapping(uint256 => address) public override underlyingVaults; // Protocol stablecoin vaults\n    mapping(address => uint256) public vaultIndexes;\n\n    mapping(address => address) public override referrals;\n\n    // Pwrd (true) and gvt (false) mapped to respective withdrawal fee\n    mapping(bool => uint256) public override withdrawalFee;\n\n    event LogNewWithdrawHandler(address tokens);\n    event LogNewDepositHandler(address tokens);\n    event LogNewVault(uint256 index, address vault);\n    event LogNewCurveVault(address curveVault);\n    event LogNewLifeguard(address lifeguard);\n    event LogNewInsurance(address insurance);\n    event LogNewPnl(address pnl);\n    event LogNewBigFishThreshold(uint256 percent, uint256 absolute);\n    event LogFlashSwitchUpdated(bool status);\n    event LogNewSafeAddress(address account);\n    event LogNewRewardsContract(address reward);\n    event LogNewUtilLimit(bool indexed pwrd, uint256 limit);\n    event LogNewCurveToStableDistribution(uint256 amount, uint256[N_COINS] amounts, uint256[N_COINS] delta);\n    event LogNewWithdrawalFee(address user, bool pwrd, uint256 newFee);\n\n    constructor(\n        address pwrd,\n        address gvt,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals\n    ) public FixedStablecoins(_tokens, _decimals) FixedGTokens(pwrd, gvt) {}\n\n    function pause() external onlyWhitelist {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {\n        require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");\n        withdrawHandler = _withdrawHandler;\n        emergencyHandler = _emergencyHandler;\n        emit LogNewWithdrawHandler(_withdrawHandler);\n    }\n\n    function setDepositHandler(address _depositHandler) external onlyOwner {\n        require(_depositHandler != address(0), \"setDepositHandler: 0x\");\n        depositHandler = _depositHandler;\n        emit LogNewDepositHandler(_depositHandler);\n    }\n\n    function stablecoins() external view override returns (address[N_COINS] memory) {\n        return underlyingTokens();\n    }\n\n    /// @notice Returns amount to skim of larger deposits for alternative vault (Curve)\n    function getSkimPercent() external view override returns (uint256) {\n        return IInsurance(insurance).calcSkim();\n    }\n\n    /// @notice Returns list of all the underling protocol vaults\n    function vaults() external view override returns (address[N_COINS] memory) {\n        address[N_COINS] memory result;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = underlyingVaults[i];\n        }\n        return result;\n    }\n\n    /// @notice Set system vaults, vault index should match its underlying token\n    function setVault(uint256 index, address vault) external onlyOwner {\n        require(vault != address(0), \"setVault: 0x\");\n        require(index < N_COINS, \"setVault: !index\");\n        underlyingVaults[index] = vault;\n        vaultIndexes[vault] = index + 1;\n        emit LogNewVault(index, vault);\n    }\n\n    function setCurveVault(address _curveVault) external onlyOwner {\n        require(_curveVault != address(0), \"setCurveVault: 0x\");\n        curveVault = _curveVault;\n        vaultIndexes[_curveVault] = N_COINS + 1;\n        emit LogNewCurveVault(_curveVault);\n    }\n\n    function setLifeGuard(address _lifeGuard) external onlyOwner {\n        require(_lifeGuard != address(0), \"setLifeGuard: 0x\");\n        lifeGuard = _lifeGuard;\n        buoy = ILifeGuard(_lifeGuard).getBuoy();\n        emit LogNewLifeguard(_lifeGuard);\n    }\n\n    function setInsurance(address _insurance) external onlyOwner {\n        require(_insurance != address(0), \"setInsurance: 0x\");\n        insurance = _insurance;\n        emit LogNewInsurance(_insurance);\n    }\n\n    function setPnL(address _pnl) external onlyOwner {\n        require(_pnl != address(0), \"setPnl: 0x\");\n        pnl = _pnl;\n        emit LogNewPnl(_pnl);\n    }\n\n    function addSafeAddress(address account) external onlyOwner {\n        safeAddresses[account] = true;\n        emit LogNewSafeAddress(account);\n    }\n\n    function switchEoaOnly(bool check) external onlyOwner {\n        preventSmartContracts = check;\n    }\n\n    /// @notice Set limit for when a deposit will be rerouted for alternative logic\n    /// @param _percent %BP limit\n    /// @param _absolute Absolute limit\n    /// @dev The two limits should be used as an upper and lower bound - the % limit\n    ///     considers the current TVL in the token interacted with (gvt or pwrd) and will\n    ///     act as the upper bound when the TVL is low. The absolute value will be the lower bound,\n    ///     ensuring that small deposits won't suffer higher gas costs.\n    function setBigFishThreshold(uint256 _percent, uint256 _absolute) external onlyOwner {\n        require(_percent > 0, \"_whaleLimit is 0\");\n        bigFishThreshold = _percent;\n        bigFishAbsoluteThreshold = _absolute;\n        emit LogNewBigFishThreshold(_percent, _absolute);\n    }\n\n    function setReward(address _reward) external onlyOwner {\n        require(_reward != address(0), \"setReward: 0x\");\n        reward = _reward;\n        emit LogNewRewardsContract(_reward);\n    }\n\n    function addReferral(address account, address referral) external override {\n        require(msg.sender == depositHandler, \"!depositHandler\");\n        if (account != address(0) && referral != address(0) && referrals[account] == address(0)) {\n            referrals[account] = referral;\n        }\n    }\n\n    /// @notice Set withdrawal fee for token\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param newFee New token fee\n    function setWithdrawalFee(bool pwrd, uint256 newFee) external onlyOwner {\n        withdrawalFee[pwrd] = newFee;\n        emit LogNewWithdrawalFee(msg.sender, pwrd, newFee);\n    }\n\n    /// @notice Calculate system total assets\n    function totalAssets() external view override returns (uint256) {\n        return emergencyState ? _totalAssetsEmergency() : _totalAssets();\n    }\n\n    /// @notice Calculate pwrd/gro vault total assets\n    function gTokenTotalAssets() public view override returns (uint256) {\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        if (msg.sender == address(gvt)) {\n            return gvtAssets;\n        }\n        if (msg.sender == address(pwrd)) {\n            return pwrdAssets;\n        }\n        return 0;\n    }\n\n    function gToken(bool isPWRD) external view override returns (address) {\n        return isPWRD ? address(pwrd) : address(gvt);\n    }\n\n    /// @notice Check if the deposit/withdrawal needs to go through alternate logic\n    /// @param amount USD amount of deposit/withdrawal\n    /// @dev Larger deposits are handled differently than small deposits in order\n    ///     to guarantee that the system isn't overexposed to any one stablecoin\n    function isValidBigFish(\n        bool pwrd,\n        bool deposit,\n        uint256 amount\n    ) external view override returns (bool) {\n        if (deposit && pwrd) {\n            require(validGTokenIncrease(amount), \"isBigFish: !validGTokenIncrease\");\n        } else if (!pwrd && !deposit) {\n            require(validGTokenDecrease(amount), \"isBigFish: !validGTokenDecrease\");\n        }\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        uint256 assets = pwrdAssets.add(gvtAssets);\n        if (amount < bigFishAbsoluteThreshold) {\n            return false;\n        } else if (amount > assets) {\n            return true;\n        } else {\n            return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);\n        }\n    }\n\n    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist {\n        uint256[N_COINS] memory amounts = ILifeGuard(lifeGuard).distributeCurveVault(amount, delta);\n        emit LogNewCurveToStableDistribution(amount, amounts, delta);\n    }\n\n    /// @notice Block if not an EOA or whitelisted\n    /// @param sender Address of contract to check\n    function eoaOnly(address sender) public override {\n        if (preventSmartContracts && !safeAddresses[tx.origin]) {\n            require(sender == tx.origin, \"EOA only\");\n        }\n    }\n\n    /// @notice TotalAssets = lifeguard + stablecoin vaults + LP vault\n    function _totalAssets() private view returns (uint256) {\n        require(IBuoy(buoy).safetyCheck(), \"!buoy.safetyCheck\");\n        uint256[N_COINS] memory lgAssets = ILifeGuard(lifeGuard).getAssets();\n        uint256[N_COINS] memory vaultAssets;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            vaultAssets[i] = lgAssets[i].add(IVault(underlyingVaults[i]).totalAssets());\n        }\n        uint256 totalLp = IVault(curveVault).totalAssets();\n        totalLp = totalLp.add(IBuoy(buoy).stableToLp(vaultAssets, true));\n        uint256 vp = IBuoy(buoy).getVirtualPrice();\n\n        return totalLp.mul(vp).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    /// @notice Same as _totalAssets function, but excluding curve vault + 1 stablecoin\n    ///             and uses chianlink as a price oracle\n    function _totalAssetsEmergency() private view returns (uint256) {\n        IChainPrice chainPrice = IChainPrice(buoy);\n        uint256 total;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (i != deadCoin) {\n                address tokenAddress = getToken(i);\n                uint256 decimals = getDecimal(i);\n                IERC20 token = IERC20(tokenAddress);\n                uint256 price = chainPrice.getPriceFeed(i);\n                uint256 assets = IVault(underlyingVaults[i]).totalAssets().add(token.balanceOf(lifeGuard));\n                assets = assets.mul(price).div(CHAINLINK_PRICE_DECIMAL_FACTOR);\n                assets = assets.mul(DEFAULT_DECIMALS_FACTOR).div(decimals);\n                total = total.add(assets);\n            }\n        }\n        return total;\n    }\n\n    /// @notice Set protocol into emergency mode, disabling the use of a give stablecoin.\n    ///             This state assumes:\n    ///                 - Stablecoin of excessively of peg\n    ///                 - Curve3Pool has failed\n    ///             Swapping wil be disabled and the allocation target will be set to\n    ///             100 % for the disabled stablecoin, effectively stopping the system from\n    ///             returning any to the user. Deposit are disable in this mode.\n    /// @param coin Stable coin to disable\n    function emergency(uint256 coin) external onlyWhitelist {\n        require(coin < N_COINS, \"invalid coin\");\n        if (!paused()) {\n            _pause();\n        }\n        deadCoin = coin;\n        emergencyState = true;\n\n        uint256 percent;\n        for (uint256 i; i < N_COINS; i++) {\n            if (i == coin) {\n                percent = 10000;\n            } else {\n                percent = 0;\n            }\n            IInsurance(insurance).setUnderlyingTokenPercent(i, percent);\n        }\n        IPnL(pnl).emergencyPnL();\n    }\n\n    /// @notice Recover the system after emergency mode -\n    /// @param allocations New system target allocations\n    /// @dev Will recalculate system assets and atempt to give back any\n    ///     recovered assets to the GVT side\n    function restart(uint256[] calldata allocations) external onlyOwner whenPaused {\n        _unpause();\n        deadCoin = 99;\n        emergencyState = false;\n\n        for (uint256 i; i < N_COINS; i++) {\n            IInsurance(insurance).setUnderlyingTokenPercent(i, allocations[i]);\n        }\n        IPnL(pnl).recover();\n    }\n\n    /// @notice Distribute any gains or losses generated from a harvest\n    /// @param gain harvset gains\n    /// @param loss harvest losses\n    function distributeStrategyGainLoss(uint256 gain, uint256 loss) external override {\n        uint256 index = vaultIndexes[msg.sender];\n        require(index > 0 || index <= N_COINS + 1, \"!VaultAdaptor\");\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        uint256 gainUsd;\n        uint256 lossUsd;\n        index = index - 1;\n        if (index < N_COINS) {\n            if (gain > 0) {\n                gainUsd = ibuoy.singleStableToUsd(gain, index);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.singleStableToUsd(loss, index);\n            }\n        } else {\n            if (gain > 0) {\n                gainUsd = ibuoy.lpToUsd(gain);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.lpToUsd(loss);\n            }\n        }\n        ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);\n        // Check if curve spot price within tollerance, if so update them\n        if (ibuoy.updateRatios()) {\n            // If the curve ratios were successfully updated, realize system price changes\n            ipnl.distributePriceChange(_totalAssets());\n        }\n    }\n\n    function realizePriceChange(uint256 tolerance) external onlyOwner {\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        if (emergencyState) {\n            ipnl.distributePriceChange(_totalAssetsEmergency());\n        } else {\n            // Check if curve spot price within tollerance, if so update them\n            if (ibuoy.updateRatiosWithTolerance(tolerance)) {\n                // If the curve ratios were successfully updated, realize system price changes\n                ipnl.distributePriceChange(_totalAssets());\n            }\n        }\n    }\n\n    function burnGToken(\n        bool pwrd,\n        bool all,\n        address account,\n        uint256 amount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == withdrawHandler || msg.sender == emergencyHandler, \"burnGToken: !withdrawHandler\");\n        IToken gt = gTokens(pwrd);\n        if (!all) {\n            gt.burn(account, gt.factor(), amount);\n        } else {\n            gt.burnAll(account);\n        }\n        // Update underlying assets held in pwrd/gvt\n        IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount, bonus);\n    }\n\n    function mintGToken(\n        bool pwrd,\n        address account,\n        uint256 amount\n    ) external override {\n        require(msg.sender == depositHandler, \"burnGToken: !depositHandler\");\n        IToken gt = gTokens(pwrd);\n        gt.mint(account, gt.factor(), amount);\n        IPnL(pnl).increaseGTokenLastAmount(pwrd, amount);\n    }\n\n    /// @notice Calcualte withdrawal value when withdrawing all\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param account User account\n    function getUserAssets(bool pwrd, address account) external view override returns (uint256 deductUsd) {\n        IToken gt = gTokens(pwrd);\n        deductUsd = gt.getAssets(account);\n        require(deductUsd > 0, \"!minAmount\");\n    }\n\n    /// @notice Check if it's OK to mint the specified amount of tokens, this affects\n    ///     pwrds, as they have an upper bound set by the amount of gvt\n    /// @param amount Amount of token to mint\n    function validGTokenIncrease(uint256 amount) private view returns (bool) {\n        return\n            gTokens(false).totalAssets().mul(utilisationRatioLimitPwrd).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            amount.add(gTokens(true).totalAssets());\n    }\n\n    /// @notice Check if it's OK to burn the specified amount of tokens, this affects\n    ///     gvt, as they have a lower bound set by the amount of pwrds\n    /// @param amount Amount of token to burn\n    function validGTokenDecrease(uint256 amount) public view override returns (bool) {\n        return\n            gTokens(false).totalAssets().sub(amount).mul(utilisationRatioLimitGvt).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            gTokens(true).totalAssets();\n    }\n\n    /// @notice Set the lower bound for when to stop accepting deposits for pwrd - this allows for a bit of legroom\n    ///     for gvt to be sold (if this limit is reached, this contract only accepts deposits for gvt)\n    /// @param _utilisationRatioLimitPwrd Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitPwrd(uint256 _utilisationRatioLimitPwrd) external onlyOwner {\n        utilisationRatioLimitPwrd = _utilisationRatioLimitPwrd;\n        emit LogNewUtilLimit(true, _utilisationRatioLimitPwrd);\n    }\n\n    /// @notice Set the lower bound for when to stop accepting gvt withdrawals\n    /// @param _utilisationRatioLimitGvt Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitGvt(uint256 _utilisationRatioLimitGvt) external onlyOwner {\n        utilisationRatioLimitGvt = _utilisationRatioLimitGvt;\n        emit LogNewUtilLimit(false, _utilisationRatioLimitGvt);\n    }\n\n    function getStrategiesTargetRatio() external view override returns (uint256[] memory) {\n        uint256 utilRatio = IPnL(pnl).utilisationRatio();\n        return IInsurance(insurance).getStrategiesTargetRatio(utilRatio);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IPnL.sol\";\nimport \"../common/Controllable.sol\";\nimport \"../interfaces/IPnL.sol\";\nimport \"../common/Constants.sol\";\nimport {FixedGTokens} from \"../common/FixedContracts.sol\";\n\n/// @notice Contract for calculating protocol profit and loss. The PnL contract stores snapshots\n///     of total assets in pwrd and gvt, which are used to calculate utilisation ratio and establish\n///     changes in underling pwrd and gvt factors. The protocol will allow these values to drift as long\n///     as they stay within a certain threshold of protocol actuals, or large amounts of assets are being\n///     deposited or withdrawn from the protocol. The PnL contract ensures that any profits are distributed\n///     between pwrd and gvt based on the utilisation ratio - as this ratio movese towards 1, a larger\n///     amount of the pwrd profit is shifted to gvt. Protocol losses are on the other hand soaked up\n///     by gvt, ensuring that pwrd never lose value.\n///\n///     ###############################################\n///     PnL variables and calculations\n///     ###############################################\n///\n///     yield - system gains and losses from assets invested into strategies are realised once\n///         a harvest is run. Yield is ditributed to pwrd and gvt based on the utilisation ratio of the\n///         two tokens (see _calcProfit).\n///\n///     PerformanceFee - The performance fee is deducted from any yield profits, and is used to\n///         buy back and distribute governance tokens to users.\n///\n///     hodler Fee - Withdrawals experience a hodler fee that is socialized to all other holders.\n///         Like other gains, this isn't realised on withdrawal, but rather when a critical amount\n///         has amassed in the system (totalAssetsPercentThreshold).\n///\n///     ###############################################\n///     PnL Actions\n///     ###############################################\n///\n///     Pnl has two trigger mechanisms:\n///         - Harvest:\n///             - It will realize any loss/profit from the strategy\n///             - It will atempt to update lastest cached curve stable coin dy\n///                 - if successfull, it will try to realize any price changes (pre tvl vs current)\n///         - Withdrawals\n///             - Any user withdrawals are distributing the holder fee to the other users\ncontract PnL is Controllable, Constants, FixedGTokens, IPnL {\n    using SafeMath for uint256;\n\n    uint256 public override lastGvtAssets;\n    uint256 public override lastPwrdAssets;\n    bool public rebase = true;\n\n    uint256 public performanceFee; // Amount of gains to use to buy back and distribute gov tokens\n\n    event LogRebaseSwitch(bool status);\n    event LogNewPerfromanceFee(uint256 fee);\n    event LogNewGtokenChange(bool pwrd, int256 change);\n    event LogPnLExecution(\n        uint256 deductedAssets,\n        int256 totalPnL,\n        int256 investPnL,\n        int256 pricePnL,\n        uint256 withdrawalBonus,\n        uint256 performanceBonus,\n        uint256 beforeGvtAssets,\n        uint256 beforePwrdAssets,\n        uint256 afterGvtAssets,\n        uint256 afterPwrdAssets\n    );\n\n    constructor(\n        address pwrd,\n        address gvt,\n        uint256 pwrdAssets,\n        uint256 gvtAssets\n    ) public FixedGTokens(pwrd, gvt) {\n        lastPwrdAssets = pwrdAssets;\n        lastGvtAssets = gvtAssets;\n    }\n\n    /// @notice Turn pwrd rebasing on/off - This stops yield/ hodler bonuses to be distributed to the pwrd\n    ///     token, which effectively stops it from rebasing any further.\n    function setRebase(bool _rebase) external onlyOwner {\n        rebase = _rebase;\n        emit LogRebaseSwitch(_rebase);\n    }\n\n    /// @notice Fee taken from gains to be redistributed to users who stake their tokens\n    /// @param _performanceFee Amount to remove from gains (%BP)\n    function setPerformanceFee(uint256 _performanceFee) external onlyOwner {\n        performanceFee = _performanceFee;\n        emit LogNewPerfromanceFee(_performanceFee);\n    }\n\n    /// @notice Increase previously recorded GToken assets by specific amount\n    /// @param pwrd pwrd/gvt\n    /// @param dollarAmount Amount to increase by\n    function increaseGTokenLastAmount(bool pwrd, uint256 dollarAmount) external override {\n        require(msg.sender == controller, \"increaseGTokenLastAmount: !controller\");\n        if (!pwrd) {\n            lastGvtAssets = lastGvtAssets.add(dollarAmount);\n        } else {\n            lastPwrdAssets = lastPwrdAssets.add(dollarAmount);\n        }\n        emit LogNewGtokenChange(pwrd, int256(dollarAmount));\n    }\n\n    /// @notice Decrease previously recorded GToken assets by specific amount\n    /// @param pwrd pwrd/gvt\n    /// @param dollarAmount Amount to decrease by\n    /// @param bonus hodler bonus\n    function decreaseGTokenLastAmount(\n        bool pwrd,\n        uint256 dollarAmount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == controller, \"decreaseGTokenLastAmount: !controller\");\n        uint256 lastGA = lastGvtAssets;\n        uint256 lastPA = lastPwrdAssets;\n        if (!pwrd) {\n            lastGA = dollarAmount > lastGA ? 0 : lastGA.sub(dollarAmount);\n        } else {\n            lastPA = dollarAmount > lastPA ? 0 : lastPA.sub(dollarAmount);\n        }\n        if (bonus > 0) {\n            uint256 preGABeforeBonus = lastGA;\n            uint256 prePABeforeBonus = lastPA;\n            uint256 preTABeforeBonus = preGABeforeBonus.add(prePABeforeBonus);\n            if (rebase) {\n                lastGA = preGABeforeBonus.add(bonus.mul(preGABeforeBonus).div(preTABeforeBonus));\n                lastPA = prePABeforeBonus.add(bonus.mul(prePABeforeBonus).div(preTABeforeBonus));\n            } else {\n                lastGA = preGABeforeBonus.add(bonus);\n            }\n            emit LogPnLExecution(0, int256(bonus), 0, 0, bonus, 0, preGABeforeBonus, prePABeforeBonus, lastGA, lastPA);\n        }\n\n        lastGvtAssets = lastGA;\n        lastPwrdAssets = lastPA;\n        emit LogNewGtokenChange(pwrd, int256(-dollarAmount));\n    }\n\n    /// @notice Return latest system asset states\n    function calcPnL() external view override returns (uint256, uint256) {\n        return (lastGvtAssets, lastPwrdAssets);\n    }\n\n    /// @notice Calculate utilisation ratio between gvt and pwrd\n    function utilisationRatio() external view override returns (uint256) {\n        return lastGvtAssets != 0 ? lastPwrdAssets.mul(PERCENTAGE_DECIMAL_FACTOR).div(lastGvtAssets) : 0;\n    }\n\n    /// @notice Update assets after entering emergency state\n    function emergencyPnL() external override {\n        require(msg.sender == controller, \"emergencyPnL: !controller\");\n        forceDistribute();\n    }\n\n    /// @notice Recover system from emergency state\n    function recover() external override {\n        require(msg.sender == controller, \"recover: !controller\");\n        forceDistribute();\n    }\n\n    /// @notice Distribute yield based on utilisation ratio\n    /// @param gvtAssets Total gvt assets\n    /// @param pwrdAssets Total pwrd assets\n    /// @param profit Amount of profit to distribute\n    /// @param reward Rewards contract\n    function handleInvestGain(\n        uint256 gvtAssets,\n        uint256 pwrdAssets,\n        uint256 profit,\n        address reward\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 performanceBonus;\n        if (performanceFee > 0 && reward != address(0)) {\n            performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);\n            profit = profit.sub(performanceBonus);\n        }\n        if (rebase) {\n            uint256 totalAssets = gvtAssets.add(pwrdAssets);\n            uint256 gvtProfit = profit.mul(gvtAssets).div(totalAssets);\n            uint256 pwrdProfit = profit.mul(pwrdAssets).div(totalAssets);\n\n            uint256 factor = pwrdAssets.mul(10000).div(gvtAssets);\n            if (factor > 10000) factor = 10000;\n            if (factor < 8000) {\n                factor = factor.mul(3).div(8).add(3000);\n            } else {\n                factor = factor.sub(8000).mul(2).add(6000);\n            }\n\n            uint256 portionFromPwrdProfit = pwrdProfit.mul(factor).div(10000);\n            gvtAssets = gvtAssets.add(gvtProfit.add(portionFromPwrdProfit));\n            pwrdAssets = pwrdAssets.add(pwrdProfit.sub(portionFromPwrdProfit));\n        } else {\n            gvtAssets = gvtAssets.add(profit);\n        }\n        return (gvtAssets, pwrdAssets, performanceBonus);\n    }\n\n    /// @notice Distribute losses\n    /// @param gvtAssets Total gvt assets\n    /// @param pwrdAssets Total pwrd assets\n    /// @param loss Amount of loss to distribute\n    function handleLoss(\n        uint256 gvtAssets,\n        uint256 pwrdAssets,\n        uint256 loss\n    ) private pure returns (uint256, uint256) {\n        uint256 maxGvtLoss = gvtAssets.sub(DEFAULT_DECIMALS_FACTOR);\n        if (loss > maxGvtLoss) {\n            gvtAssets = DEFAULT_DECIMALS_FACTOR;\n            pwrdAssets = pwrdAssets.sub(loss.sub(maxGvtLoss));\n        } else {\n            gvtAssets = gvtAssets - loss;\n        }\n        return (gvtAssets, pwrdAssets);\n    }\n\n    function forceDistribute() private {\n        uint256 total = _controller().totalAssets();\n\n        if (total > lastPwrdAssets.add(DEFAULT_DECIMALS_FACTOR)) {\n            lastGvtAssets = total - lastPwrdAssets;\n        } else {\n            lastGvtAssets = DEFAULT_DECIMALS_FACTOR;\n            lastPwrdAssets = total.sub(DEFAULT_DECIMALS_FACTOR);\n        }\n    }\n\n    function distributeStrategyGainLoss(\n        uint256 gain,\n        uint256 loss,\n        address reward\n    ) external override {\n        require(msg.sender == controller, \"!Controller\");\n        uint256 lastGA = lastGvtAssets;\n        uint256 lastPA = lastPwrdAssets;\n        uint256 performanceBonus;\n        uint256 gvtAssets;\n        uint256 pwrdAssets;\n        int256 investPnL;\n        if (gain > 0) {\n            (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);\n            if (performanceBonus > 0) {\n                gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);\n                gvtAssets = gvtAssets.add(performanceBonus);\n            }\n\n            lastGvtAssets = gvtAssets;\n            lastPwrdAssets = pwrdAssets;\n            investPnL = int256(gain);\n        } else if (loss > 0) {\n            (lastGvtAssets, lastPwrdAssets) = handleLoss(lastGA, lastPA, loss);\n            investPnL = -int256(loss);\n        }\n\n        emit LogPnLExecution(\n            0,\n            investPnL,\n            investPnL,\n            0,\n            0,\n            performanceBonus,\n            lastGA,\n            lastPA,\n            lastGvtAssets,\n            lastPwrdAssets\n        );\n    }\n\n    function distributePriceChange(uint256 currentTotalAssets) external override {\n        require(msg.sender == controller, \"!Controller\");\n        uint256 gvtAssets = lastGvtAssets;\n        uint256 pwrdAssets = lastPwrdAssets;\n        uint256 totalAssets = gvtAssets.add(pwrdAssets);\n\n        if (currentTotalAssets > totalAssets) {\n            lastGvtAssets = gvtAssets.add(currentTotalAssets.sub(totalAssets));\n        } else if (currentTotalAssets < totalAssets) {\n            (lastGvtAssets, lastPwrdAssets) = handleLoss(gvtAssets, pwrdAssets, totalAssets.sub(currentTotalAssets));\n        }\n        int256 priceChange = int256(currentTotalAssets) - int256(totalAssets);\n\n        emit LogPnLExecution(\n            0,\n            priceChange,\n            0,\n            priceChange,\n            0,\n            0,\n            gvtAssets,\n            pwrdAssets,\n            lastGvtAssets,\n            lastPwrdAssets\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol",
            "PnL.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);",
                    "distributeStrategyGainLoss()",
                    "ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);",
                    "performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);",
                    "index <= N_COINS + 1",
                    "gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN);",
                    "<= N_COINS + 1",
                    "(gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);",
                    "require()",
                    "(uint"
                ],
                "Type": " Incorrect use of operator leads to arbitrary minting of GVT tokens",
                "Description": "\nThe distributeStrategyGainLoss() function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on msg.sender by checking that vaultIndexes[msg.sender] is a valid index range 1-4. However, the operator used in the require() is || instead of &&, which allows an arbitrary msg.sender, i.e. attacker, to bypass the check.\n\nScenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in vaultIndexes[msg.sender], which will fail the  0 check, but pass the <= N_COINS + 1 check (N_COINS = 3) because 0 <= 4 which will allow control to go past this check.\n\nFurthermore, on L362, index=0 will underflow the -1 decrement (due to lack of SafeMath.sub and use of < 0.8.0 solc) and the index will be set to (uint256_MAX 1). This will allow execution to proceed to the \"else\" part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.\n\nThe attack control flow:\n* - Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0)\n* - index = 0 passes check for the index <= N_COINS + 1 part of predicate on L357 in Controller.sol\n* - index = uint256_MAX after L362\n* - gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN); on L371 in Controller.sol\n* - ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward); on L376 in Controller.sol\n* - (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward); on L254 in PnL.sol\n* - performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR); on L186 of PnL.sol\n* -  gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus); on L256 in PnL.sol\n\n\n",
                "Repair": "Recommend changing || to && in require() on L357 of Controller.sol to prevent arbitrary addresses from going past this check. Or, consider exercising explicit access control for the authorized vault adaptors.\n\nkristian-gro (Gro) confirmed(https://github.com/code-423n4/2021-06-gro-findings/issues/69)\n Confirmed and Fix has been implemented in release version.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../common/StructDefinitions.sol\";\nimport \"../common/Constants.sol\";\nimport \"../common/Controllable.sol\";\nimport \"../common/Whitelist.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../interfaces/ILifeGuard.sol\";\nimport \"../interfaces/IExposure.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IBuoy.sol\";\n\n/// @notice Contract for calculating current protocol exposures on a stablecoin and\n///     protocol level. This contract can be upgraded if the systems underlying protocols\n///     or tokens have changed. Protocol exposure are calculated at a high level, as any\n///     additional exposures from underlying protocol exposures should at most be equal to\n///     the high level exposure.\n///     For example: harvest finance stablecoin vaults (fTokens)\n///         - High level exposure\n///             - Harvest finance\n///         - Low level exposures (from fToken investments):\n///             - Compound\n///             - Idle finance\n///     Neither of these two low level exposures should matter as long as there arent\n///     additional exposure to these protocol elsewhere. So by desing, the protocols\n///     are given indexes based on the strategies in the stablecoin vaults, which need\n///     to be symetrical for this to work - e.g. all vaults needs to have the same exposure\n///     profile, and non of these exposure profiles can overlap. In the case where the\n///     additional exposure needs to be taken into account (maker has USDC collateral,\n///     Curve adds exposure to all stablecoins in a liquidity pool), they will be calculated\n///     and added ontop of the base exposure from vaults and strategies.\n///\n///     --------------------------------------------------------\n///     Current protocol setup:\n///     --------------------------------------------------------\n///     Stablecoins: DAI, USDC, USDT\n///     LP tokens: 3Crv\n///     Vaults: DAIVault, USDCVault, USDTVault, 3Crv vault\n///     Strategy (exposures):\n///         - Compound\n///         - Idle finance\n///         - Yearn Generic Lender:\n///             - Cream\n///         - CurveXpool:\n///             - Curve3Pool\n///             - CurveMetaPool\n///             - Yearn\ncontract Exposure is Constants, Controllable, Whitelist, IExposure {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public protocolCount;\n    uint256 public makerUSDCExposure;\n\n    event LogNewProtocolCount(uint256 count);\n    event LogNewMakerExposure(uint256 exposure);\n\n    /// @notice Add protocol for the exposure calculations\n    /// @dev Currently set to:\n    ///     1 - Harvest finance\n    ///     2 - Cream\n    ///     Curve exposure is calculated separately as it has wider system impact\n    function setProtocolCount(uint256 _protocolCount) external onlyOwner {\n        protocolCount = _protocolCount;\n        emit LogNewProtocolCount(_protocolCount);\n    }\n\n    /// @notice Specify additional USDC exposure to Maker\n    /// @param _makerUSDCExposure Exposure amount to Maker\n    function setMakerUSDCExposure(uint256 _makerUSDCExposure) external onlyOwner {\n        makerUSDCExposure = _makerUSDCExposure;\n        emit LogNewMakerExposure(_makerUSDCExposure);\n    }\n\n    function getExactRiskExposure(SystemState calldata sysState)\n        external\n        view\n        override\n        returns (ExposureState memory expState)\n    {\n        expState = _calcRiskExposure(sysState, false);\n        ILifeGuard lifeguard = ILifeGuard(_controller().lifeGuard());\n        IBuoy buoy = IBuoy(_controller().buoy());\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 assets = lifeguard.assets(i);\n            uint256 assetsUsd = buoy.singleStableToUsd(assets, i);\n            expState.stablecoinExposure[i] = expState.stablecoinExposure[i].add(\n                assetsUsd.mul(PERCENTAGE_DECIMAL_FACTOR).div(sysState.totalCurrentAssetsUsd)\n            );\n        }\n    }\n\n    /// @notice Calculate stablecoin and protocol level risk exposure\n    /// @param sysState Struct holding info about systems current state\n    /// @dev This loops through all the vaults, checks the amount of assets in them\n    ///     and their underlying strategies to understand stablecoin exposure\n    ///     - Any assets invested in Curve or similar AMM will have additional stablecoin exposure.\n    ///     The protocol exposure is calculated by assessing the amount of assets each\n    ///     vault has invested in a strategy.\n    function calcRiskExposure(SystemState calldata sysState)\n        external\n        view\n        override\n        returns (ExposureState memory expState)\n    {\n        expState = _calcRiskExposure(sysState, true);\n\n        // Establish if any stablecoin/protocol is over exposed\n        (expState.stablecoinExposed, expState.protocolExposed) = isExposed(\n            sysState.rebalanceThreshold,\n            expState.stablecoinExposure,\n            expState.protocolExposure,\n            expState.curveExposure\n        );\n    }\n\n    /// @notice Do a rough USD dollar calculation by treating every stablecoin as\n    ///     worth 1 USD and set all Decimals to 18\n    function getUnifiedAssets(address[N_COINS] calldata vaults)\n        public\n        view\n        override\n        returns (uint256 unifiedTotalAssets, uint256[N_COINS] memory unifiedAssets)\n    {\n        // unify all assets to 18 decimals, treat each stablecoin as being worth 1 USD\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 assets = IVault(vaults[i]).totalAssets();\n            unifiedAssets[i] = assets.mul(DEFAULT_DECIMALS_FACTOR).div(\n                uint256(10)**IERC20Detailed(IVault(vaults[i]).token()).decimals()\n            );\n            unifiedTotalAssets = unifiedTotalAssets.add(unifiedAssets[i]);\n        }\n    }\n\n    /// @notice Rough delta calculation - assumes each stablecoin is priced at 1 USD,\n    ///     and looks at differences between current allocations and target allocations\n    /// @param targets Stable coin allocation targest\n    /// @param vaults Stablecoin vaults\n    /// @param withdrawUsd USD value of withdrawals\n    function calcRoughDelta(\n        uint256[N_COINS] calldata targets,\n        address[N_COINS] calldata vaults,\n        uint256 withdrawUsd\n    ) external view override returns (uint256[N_COINS] memory delta) {\n        (uint256 totalAssets, uint256[N_COINS] memory vaultTotalAssets) = getUnifiedAssets(vaults);\n\n        require(totalAssets > withdrawUsd, \"totalAssets < withdrawalUsd\");\n        totalAssets = totalAssets.sub(withdrawUsd);\n        uint256 totalDelta;\n        for (uint256 i; i < N_COINS; i++) {\n            uint256 target = totalAssets.mul(targets[i]).div(PERCENTAGE_DECIMAL_FACTOR);\n            if (vaultTotalAssets[i] > target) {\n                delta[i] = vaultTotalAssets[i].sub(target);\n                totalDelta = totalDelta.add(delta[i]);\n            }\n        }\n        uint256 percent = PERCENTAGE_DECIMAL_FACTOR;\n        for (uint256 i; i < N_COINS - 1; i++) {\n            if (delta[i] > 0) {\n                delta[i] = delta[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(totalDelta);\n                percent = percent.sub(delta[i]);\n            }\n        }\n        delta[N_COINS - 1] = percent;\n        return delta;\n    }\n\n    /// @notice Sort vaults by the delta of target asset - current asset,\n    ///     only support 3 vaults now\n    /// @param bigFirst Return array order most exposed -> least exposed\n    /// @param unifiedTotalAssets Estimated system USD assets\n    /// @param unifiedAssets Estimated vault USD assets\n    /// @param targetPercents Vault target percent array\n    function sortVaultsByDelta(\n        bool bigFirst,\n        uint256 unifiedTotalAssets,\n        uint256[N_COINS] calldata unifiedAssets,\n        uint256[N_COINS] calldata targetPercents\n    ) external pure override returns (uint256[N_COINS] memory vaultIndexes) {\n        uint256 maxIndex;\n        uint256 minIndex;\n        int256 maxDelta;\n        int256 minDelta;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            // Get difference between vault current assets and vault target\n            int256 delta = int256(\n                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)\n            );\n            // Establish order\n            if (delta > maxDelta) {\n                maxDelta = delta;\n                maxIndex = i;\n            } else if (delta < minDelta) {\n                minDelta = delta;\n                minIndex = i;\n            }\n        }\n        if (bigFirst) {\n            vaultIndexes[0] = maxIndex;\n            vaultIndexes[2] = minIndex;\n        } else {\n            vaultIndexes[0] = minIndex;\n            vaultIndexes[2] = maxIndex;\n        }\n        vaultIndexes[1] = N_COINS - maxIndex - minIndex;\n    }\n\n    /// @notice Calculate what percentage of system total assets the assets in a strategy make up\n    /// @param vault Address of target vault that holds the strategy\n    /// @param index Index of strategy\n    /// @param vaultAssetsPercent Percentage of system assets\n    /// @param vaultAssets Total assets in vaults\n    function calculatePercentOfSystem(\n        address vault,\n        uint256 index,\n        uint256 vaultAssetsPercent,\n        uint256 vaultAssets\n    ) private view returns (uint256 percentOfSystem) {\n        if (vaultAssets == 0) return 0;\n        uint256 strategyAssetsPercent = IVault(vault).getStrategyAssets(index).mul(PERCENTAGE_DECIMAL_FACTOR).div(\n            vaultAssets\n        );\n\n        percentOfSystem = vaultAssetsPercent.mul(strategyAssetsPercent).div(PERCENTAGE_DECIMAL_FACTOR);\n    }\n\n    /// @notice Calculate the net stablecoin exposure\n    /// @param directlyExposure Amount of stablecoin in vault+strategies\n    /// @param curveExposure Percent of assets in Curve\n    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure)\n        private\n        view\n        returns (uint256[N_COINS] memory stableCoinExposure)\n    {\n        uint256 maker = directlyExposure[0].mul(makerUSDCExposure).div(PERCENTAGE_DECIMAL_FACTOR);\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 indirectExposure = curveExposure;\n            if (i == 1) {\n                indirectExposure = indirectExposure.add(maker);\n            }\n            stableCoinExposure[i] = directlyExposure[i].add(indirectExposure);\n        }\n    }\n\n    /// @notice Determine if an assets or protocol is overexposed\n    /// @param rebalanceThreshold Threshold for triggering a rebalance due to overexposure\n    /// @param stableCoinExposure Current stable coin exposures\n    /// @param protocolExposure Current prtocol exposures\n    /// @param curveExposure Current Curve exposure\n    function isExposed(\n        uint256 rebalanceThreshold,\n        uint256[N_COINS] memory stableCoinExposure,\n        uint256[] memory protocolExposure,\n        uint256 curveExposure\n    ) private pure returns (bool stablecoinExposed, bool protocolExposed) {\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (stableCoinExposure[i] > rebalanceThreshold) {\n                stablecoinExposed = true;\n                break;\n            }\n        }\n        for (uint256 i = 0; i < protocolExposure.length; i++) {\n            if (protocolExposure[i] > rebalanceThreshold) {\n                protocolExposed = true;\n                break;\n            }\n        }\n        if (!protocolExposed && curveExposure > rebalanceThreshold) protocolExposed = true;\n        return (stablecoinExposed, protocolExposed);\n    }\n\n    function _calcRiskExposure(SystemState memory sysState, bool treatLifeguardAsCurve)\n        private\n        view\n        returns (ExposureState memory expState)\n    {\n        address[N_COINS] memory vaults = _controller().vaults();\n        uint256 pCount = protocolCount;\n        expState.protocolExposure = new uint256[](pCount);\n        if (sysState.totalCurrentAssetsUsd == 0) {\n            return expState;\n        }\n        // Stablecoin exposure\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 vaultAssetsPercent = sysState.vaultCurrentAssetsUsd[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(\n                sysState.totalCurrentAssetsUsd\n            );\n            expState.stablecoinExposure[i] = vaultAssetsPercent;\n            // Protocol exposure\n            for (uint256 j = 0; j < pCount; j++) {\n                uint256 percentOfSystem = calculatePercentOfSystem(\n                    vaults[i],\n                    j,\n                    vaultAssetsPercent,\n                    sysState.vaultCurrentAssets[i]\n                );\n                expState.protocolExposure[j] = expState.protocolExposure[j].add(percentOfSystem);\n            }\n        }\n        if (treatLifeguardAsCurve) {\n            // Curve exposure is calculated by adding the Curve vaults total assets and any\n            // assets in the lifeguard which are poised to be invested into the Curve vault\n            expState.curveExposure = sysState.curveCurrentAssetsUsd.add(sysState.lifeguardCurrentAssetsUsd);\n        } else {\n            expState.curveExposure = sysState.curveCurrentAssetsUsd;\n        }\n        expState.curveExposure = expState.curveExposure.mul(PERCENTAGE_DECIMAL_FACTOR).div(\n            sysState.totalCurrentAssetsUsd\n        );\n\n        // Calculate stablecoin exposures\n        expState.stablecoinExposure = calculateStableCoinExposure(expState.stablecoinExposure, expState.curveExposure);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport {FixedStablecoins, FixedGTokens} from \"./common/FixedContracts.sol\";\nimport \"./common/Whitelist.sol\";\n\nimport \"./interfaces/IBuoy.sol\";\nimport \"./interfaces/IChainPrice.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IInsurance.sol\";\nimport \"./interfaces/ILifeGuard.sol\";\nimport \"./interfaces/IPnL.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/// @notice The main hub for Gro protocol - The controller links up the other contracts,\n///     and acts a route for the other contracts to call one another. It holds global states\n///     such as paused and emergency. Contracts that depend on the controller implement\n///     Controllable.\n///\n///     *****************************************************************************\n///     System tokens - GTokens:\n///     gvt - high yield, uninsured\n///     pwrd - insured by gvt, pays part of its yield to gvt (depending on utilisation)\n///\n///     Tokens order is DAI, USDC, USDT.\n///     Index 0 - DAI, 1 - USDC, 2 - USDT\n///\n///     System vaults:\n///     Stablecoin vaults: One per stablecoin\n///     Curve vault: Vault for LP (liquidity pool) token\ncontract Controller is Pausable, Ownable, Whitelist, FixedStablecoins, FixedGTokens, IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public override curveVault; // LP token vault\n\n    bool public preventSmartContracts = false;\n\n    address public override insurance; // Insurance logic\n    address public override pnl; // Profit and loss calculations\n    address public override lifeGuard; // Asset swapping\n    address public override buoy; // Oracle\n    address public override depositHandler;\n    address public override withdrawHandler;\n    address public override emergencyHandler;\n\n    uint256 public override deadCoin = 99;\n    bool public override emergencyState;\n    // Lower bound for how many gvt can be burned before getting to close to the utilisation ratio\n    uint256 public utilisationRatioLimitGvt;\n    uint256 public utilisationRatioLimitPwrd;\n\n    /// Limits for what deposits/withdrawals that are considered 'large', and thus will be handled with\n    ///     a different logic - limits are checked against total assets locked in etiher of the two tokens (pwrd, gvt)\n    uint256 public bigFishThreshold = 100; // %Basis Points limit\n    uint256 public bigFishAbsoluteThreshold = 0; // Absolute limit\n    address public override reward;\n\n    mapping(address => bool) public safeAddresses; // Some integrations need to be exempt from flashloan checks\n    mapping(uint256 => address) public override underlyingVaults; // Protocol stablecoin vaults\n    mapping(address => uint256) public vaultIndexes;\n\n    mapping(address => address) public override referrals;\n\n    // Pwrd (true) and gvt (false) mapped to respective withdrawal fee\n    mapping(bool => uint256) public override withdrawalFee;\n\n    event LogNewWithdrawHandler(address tokens);\n    event LogNewDepositHandler(address tokens);\n    event LogNewVault(uint256 index, address vault);\n    event LogNewCurveVault(address curveVault);\n    event LogNewLifeguard(address lifeguard);\n    event LogNewInsurance(address insurance);\n    event LogNewPnl(address pnl);\n    event LogNewBigFishThreshold(uint256 percent, uint256 absolute);\n    event LogFlashSwitchUpdated(bool status);\n    event LogNewSafeAddress(address account);\n    event LogNewRewardsContract(address reward);\n    event LogNewUtilLimit(bool indexed pwrd, uint256 limit);\n    event LogNewCurveToStableDistribution(uint256 amount, uint256[N_COINS] amounts, uint256[N_COINS] delta);\n    event LogNewWithdrawalFee(address user, bool pwrd, uint256 newFee);\n\n    constructor(\n        address pwrd,\n        address gvt,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals\n    ) public FixedStablecoins(_tokens, _decimals) FixedGTokens(pwrd, gvt) {}\n\n    function pause() external onlyWhitelist {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {\n        require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");\n        withdrawHandler = _withdrawHandler;\n        emergencyHandler = _emergencyHandler;\n        emit LogNewWithdrawHandler(_withdrawHandler);\n    }\n\n    function setDepositHandler(address _depositHandler) external onlyOwner {\n        require(_depositHandler != address(0), \"setDepositHandler: 0x\");\n        depositHandler = _depositHandler;\n        emit LogNewDepositHandler(_depositHandler);\n    }\n\n    function stablecoins() external view override returns (address[N_COINS] memory) {\n        return underlyingTokens();\n    }\n\n    /// @notice Returns amount to skim of larger deposits for alternative vault (Curve)\n    function getSkimPercent() external view override returns (uint256) {\n        return IInsurance(insurance).calcSkim();\n    }\n\n    /// @notice Returns list of all the underling protocol vaults\n    function vaults() external view override returns (address[N_COINS] memory) {\n        address[N_COINS] memory result;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = underlyingVaults[i];\n        }\n        return result;\n    }\n\n    /// @notice Set system vaults, vault index should match its underlying token\n    function setVault(uint256 index, address vault) external onlyOwner {\n        require(vault != address(0), \"setVault: 0x\");\n        require(index < N_COINS, \"setVault: !index\");\n        underlyingVaults[index] = vault;\n        vaultIndexes[vault] = index + 1;\n        emit LogNewVault(index, vault);\n    }\n\n    function setCurveVault(address _curveVault) external onlyOwner {\n        require(_curveVault != address(0), \"setCurveVault: 0x\");\n        curveVault = _curveVault;\n        vaultIndexes[_curveVault] = N_COINS + 1;\n        emit LogNewCurveVault(_curveVault);\n    }\n\n    function setLifeGuard(address _lifeGuard) external onlyOwner {\n        require(_lifeGuard != address(0), \"setLifeGuard: 0x\");\n        lifeGuard = _lifeGuard;\n        buoy = ILifeGuard(_lifeGuard).getBuoy();\n        emit LogNewLifeguard(_lifeGuard);\n    }\n\n    function setInsurance(address _insurance) external onlyOwner {\n        require(_insurance != address(0), \"setInsurance: 0x\");\n        insurance = _insurance;\n        emit LogNewInsurance(_insurance);\n    }\n\n    function setPnL(address _pnl) external onlyOwner {\n        require(_pnl != address(0), \"setPnl: 0x\");\n        pnl = _pnl;\n        emit LogNewPnl(_pnl);\n    }\n\n    function addSafeAddress(address account) external onlyOwner {\n        safeAddresses[account] = true;\n        emit LogNewSafeAddress(account);\n    }\n\n    function switchEoaOnly(bool check) external onlyOwner {\n        preventSmartContracts = check;\n    }\n\n    /// @notice Set limit for when a deposit will be rerouted for alternative logic\n    /// @param _percent %BP limit\n    /// @param _absolute Absolute limit\n    /// @dev The two limits should be used as an upper and lower bound - the % limit\n    ///     considers the current TVL in the token interacted with (gvt or pwrd) and will\n    ///     act as the upper bound when the TVL is low. The absolute value will be the lower bound,\n    ///     ensuring that small deposits won't suffer higher gas costs.\n    function setBigFishThreshold(uint256 _percent, uint256 _absolute) external onlyOwner {\n        require(_percent > 0, \"_whaleLimit is 0\");\n        bigFishThreshold = _percent;\n        bigFishAbsoluteThreshold = _absolute;\n        emit LogNewBigFishThreshold(_percent, _absolute);\n    }\n\n    function setReward(address _reward) external onlyOwner {\n        require(_reward != address(0), \"setReward: 0x\");\n        reward = _reward;\n        emit LogNewRewardsContract(_reward);\n    }\n\n    function addReferral(address account, address referral) external override {\n        require(msg.sender == depositHandler, \"!depositHandler\");\n        if (account != address(0) && referral != address(0) && referrals[account] == address(0)) {\n            referrals[account] = referral;\n        }\n    }\n\n    /// @notice Set withdrawal fee for token\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param newFee New token fee\n    function setWithdrawalFee(bool pwrd, uint256 newFee) external onlyOwner {\n        withdrawalFee[pwrd] = newFee;\n        emit LogNewWithdrawalFee(msg.sender, pwrd, newFee);\n    }\n\n    /// @notice Calculate system total assets\n    function totalAssets() external view override returns (uint256) {\n        return emergencyState ? _totalAssetsEmergency() : _totalAssets();\n    }\n\n    /// @notice Calculate pwrd/gro vault total assets\n    function gTokenTotalAssets() public view override returns (uint256) {\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        if (msg.sender == address(gvt)) {\n            return gvtAssets;\n        }\n        if (msg.sender == address(pwrd)) {\n            return pwrdAssets;\n        }\n        return 0;\n    }\n\n    function gToken(bool isPWRD) external view override returns (address) {\n        return isPWRD ? address(pwrd) : address(gvt);\n    }\n\n    /// @notice Check if the deposit/withdrawal needs to go through alternate logic\n    /// @param amount USD amount of deposit/withdrawal\n    /// @dev Larger deposits are handled differently than small deposits in order\n    ///     to guarantee that the system isn't overexposed to any one stablecoin\n    function isValidBigFish(\n        bool pwrd,\n        bool deposit,\n        uint256 amount\n    ) external view override returns (bool) {\n        if (deposit && pwrd) {\n            require(validGTokenIncrease(amount), \"isBigFish: !validGTokenIncrease\");\n        } else if (!pwrd && !deposit) {\n            require(validGTokenDecrease(amount), \"isBigFish: !validGTokenDecrease\");\n        }\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        uint256 assets = pwrdAssets.add(gvtAssets);\n        if (amount < bigFishAbsoluteThreshold) {\n            return false;\n        } else if (amount > assets) {\n            return true;\n        } else {\n            return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);\n        }\n    }\n\n    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist {\n        uint256[N_COINS] memory amounts = ILifeGuard(lifeGuard).distributeCurveVault(amount, delta);\n        emit LogNewCurveToStableDistribution(amount, amounts, delta);\n    }\n\n    /// @notice Block if not an EOA or whitelisted\n    /// @param sender Address of contract to check\n    function eoaOnly(address sender) public override {\n        if (preventSmartContracts && !safeAddresses[tx.origin]) {\n            require(sender == tx.origin, \"EOA only\");\n        }\n    }\n\n    /// @notice TotalAssets = lifeguard + stablecoin vaults + LP vault\n    function _totalAssets() private view returns (uint256) {\n        require(IBuoy(buoy).safetyCheck(), \"!buoy.safetyCheck\");\n        uint256[N_COINS] memory lgAssets = ILifeGuard(lifeGuard).getAssets();\n        uint256[N_COINS] memory vaultAssets;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            vaultAssets[i] = lgAssets[i].add(IVault(underlyingVaults[i]).totalAssets());\n        }\n        uint256 totalLp = IVault(curveVault).totalAssets();\n        totalLp = totalLp.add(IBuoy(buoy).stableToLp(vaultAssets, true));\n        uint256 vp = IBuoy(buoy).getVirtualPrice();\n\n        return totalLp.mul(vp).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    /// @notice Same as _totalAssets function, but excluding curve vault + 1 stablecoin\n    ///             and uses chianlink as a price oracle\n    function _totalAssetsEmergency() private view returns (uint256) {\n        IChainPrice chainPrice = IChainPrice(buoy);\n        uint256 total;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (i != deadCoin) {\n                address tokenAddress = getToken(i);\n                uint256 decimals = getDecimal(i);\n                IERC20 token = IERC20(tokenAddress);\n                uint256 price = chainPrice.getPriceFeed(i);\n                uint256 assets = IVault(underlyingVaults[i]).totalAssets().add(token.balanceOf(lifeGuard));\n                assets = assets.mul(price).div(CHAINLINK_PRICE_DECIMAL_FACTOR);\n                assets = assets.mul(DEFAULT_DECIMALS_FACTOR).div(decimals);\n                total = total.add(assets);\n            }\n        }\n        return total;\n    }\n\n    /// @notice Set protocol into emergency mode, disabling the use of a give stablecoin.\n    ///             This state assumes:\n    ///                 - Stablecoin of excessively of peg\n    ///                 - Curve3Pool has failed\n    ///             Swapping wil be disabled and the allocation target will be set to\n    ///             100 % for the disabled stablecoin, effectively stopping the system from\n    ///             returning any to the user. Deposit are disable in this mode.\n    /// @param coin Stable coin to disable\n    function emergency(uint256 coin) external onlyWhitelist {\n        require(coin < N_COINS, \"invalid coin\");\n        if (!paused()) {\n            _pause();\n        }\n        deadCoin = coin;\n        emergencyState = true;\n\n        uint256 percent;\n        for (uint256 i; i < N_COINS; i++) {\n            if (i == coin) {\n                percent = 10000;\n            } else {\n                percent = 0;\n            }\n            IInsurance(insurance).setUnderlyingTokenPercent(i, percent);\n        }\n        IPnL(pnl).emergencyPnL();\n    }\n\n    /// @notice Recover the system after emergency mode -\n    /// @param allocations New system target allocations\n    /// @dev Will recalculate system assets and atempt to give back any\n    ///     recovered assets to the GVT side\n    function restart(uint256[] calldata allocations) external onlyOwner whenPaused {\n        _unpause();\n        deadCoin = 99;\n        emergencyState = false;\n\n        for (uint256 i; i < N_COINS; i++) {\n            IInsurance(insurance).setUnderlyingTokenPercent(i, allocations[i]);\n        }\n        IPnL(pnl).recover();\n    }\n\n    /// @notice Distribute any gains or losses generated from a harvest\n    /// @param gain harvset gains\n    /// @param loss harvest losses\n    function distributeStrategyGainLoss(uint256 gain, uint256 loss) external override {\n        uint256 index = vaultIndexes[msg.sender];\n        require(index > 0 || index <= N_COINS + 1, \"!VaultAdaptor\");\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        uint256 gainUsd;\n        uint256 lossUsd;\n        index = index - 1;\n        if (index < N_COINS) {\n            if (gain > 0) {\n                gainUsd = ibuoy.singleStableToUsd(gain, index);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.singleStableToUsd(loss, index);\n            }\n        } else {\n            if (gain > 0) {\n                gainUsd = ibuoy.lpToUsd(gain);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.lpToUsd(loss);\n            }\n        }\n        ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);\n        // Check if curve spot price within tollerance, if so update them\n        if (ibuoy.updateRatios()) {\n            // If the curve ratios were successfully updated, realize system price changes\n            ipnl.distributePriceChange(_totalAssets());\n        }\n    }\n\n    function realizePriceChange(uint256 tolerance) external onlyOwner {\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        if (emergencyState) {\n            ipnl.distributePriceChange(_totalAssetsEmergency());\n        } else {\n            // Check if curve spot price within tollerance, if so update them\n            if (ibuoy.updateRatiosWithTolerance(tolerance)) {\n                // If the curve ratios were successfully updated, realize system price changes\n                ipnl.distributePriceChange(_totalAssets());\n            }\n        }\n    }\n\n    function burnGToken(\n        bool pwrd,\n        bool all,\n        address account,\n        uint256 amount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == withdrawHandler || msg.sender == emergencyHandler, \"burnGToken: !withdrawHandler\");\n        IToken gt = gTokens(pwrd);\n        if (!all) {\n            gt.burn(account, gt.factor(), amount);\n        } else {\n            gt.burnAll(account);\n        }\n        // Update underlying assets held in pwrd/gvt\n        IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount, bonus);\n    }\n\n    function mintGToken(\n        bool pwrd,\n        address account,\n        uint256 amount\n    ) external override {\n        require(msg.sender == depositHandler, \"burnGToken: !depositHandler\");\n        IToken gt = gTokens(pwrd);\n        gt.mint(account, gt.factor(), amount);\n        IPnL(pnl).increaseGTokenLastAmount(pwrd, amount);\n    }\n\n    /// @notice Calcualte withdrawal value when withdrawing all\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param account User account\n    function getUserAssets(bool pwrd, address account) external view override returns (uint256 deductUsd) {\n        IToken gt = gTokens(pwrd);\n        deductUsd = gt.getAssets(account);\n        require(deductUsd > 0, \"!minAmount\");\n    }\n\n    /// @notice Check if it's OK to mint the specified amount of tokens, this affects\n    ///     pwrds, as they have an upper bound set by the amount of gvt\n    /// @param amount Amount of token to mint\n    function validGTokenIncrease(uint256 amount) private view returns (bool) {\n        return\n            gTokens(false).totalAssets().mul(utilisationRatioLimitPwrd).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            amount.add(gTokens(true).totalAssets());\n    }\n\n    /// @notice Check if it's OK to burn the specified amount of tokens, this affects\n    ///     gvt, as they have a lower bound set by the amount of pwrds\n    /// @param amount Amount of token to burn\n    function validGTokenDecrease(uint256 amount) public view override returns (bool) {\n        return\n            gTokens(false).totalAssets().sub(amount).mul(utilisationRatioLimitGvt).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            gTokens(true).totalAssets();\n    }\n\n    /// @notice Set the lower bound for when to stop accepting deposits for pwrd - this allows for a bit of legroom\n    ///     for gvt to be sold (if this limit is reached, this contract only accepts deposits for gvt)\n    /// @param _utilisationRatioLimitPwrd Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitPwrd(uint256 _utilisationRatioLimitPwrd) external onlyOwner {\n        utilisationRatioLimitPwrd = _utilisationRatioLimitPwrd;\n        emit LogNewUtilLimit(true, _utilisationRatioLimitPwrd);\n    }\n\n    /// @notice Set the lower bound for when to stop accepting gvt withdrawals\n    /// @param _utilisationRatioLimitGvt Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitGvt(uint256 _utilisationRatioLimitGvt) external onlyOwner {\n        utilisationRatioLimitGvt = _utilisationRatioLimitGvt;\n        emit LogNewUtilLimit(false, _utilisationRatioLimitGvt);\n    }\n\n    function getStrategiesTargetRatio() external view override returns (uint256[] memory) {\n        uint256 utilRatio = IPnL(pnl).utilisationRatio();\n        return IInsurance(insurance).getStrategiesTargetRatio(utilRatio);\n    }\n}\n\n\n",
        "CodeNames": [
            "Exposure.sol",
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nvaultIndexes[0] = maxIndex = 0\nvaultIndexes[2] = minIndex = 0\nvaultIndexes[1] = N_COINS maxIndex minIndex = 3-0-0 = 3\n",
                    "//solidity\nfunction sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {\n        uint256 maxIndex;\n        uint256 minIndex;\n        int256 maxDelta;\n        int256 minDelta;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            // Get difference between vault current assets and vault target\n            int256 delta = int256(\n                unifiedAssets[i] unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)\n            );\n            // Establish order\n            if (delta  maxDelta) {\n                maxDelta = delta;\n                maxIndex = i;\n            } else if (delta < minDelta) {\n                minDelta = delta;\n                minIndex = i;\n            }\n        }\n        if (bigFirst) {\n            vaultIndexes[0] = maxIndex;\n            vaultIndexes[2] = minIndex;\n        } else {\n            vaultIndexes[0] = minIndex;\n            vaultIndexes[2] = maxIndex;\n        }\n        vaultIndexes[1] = N_COINS maxIndex minIndex;\n    }\n"
                ],
                "Type": "  sortVaultsByDelta  doesn't work as expected",
                "Description": "\nThe function sortVaultsByDelta doesn't always work as expected.\n\nSuppose all the delta's are positive, and delta1 = delta2 = delta3  0. Then maxIndex = 0. And (delta < minDelta (==0) ) is never true, so minIndex = 0.\n\nThen (assuming bigFirst==true):\n\nsolidity\nvaultIndexes[0] = maxIndex = 0\nvaultIndexes[2] = minIndex = 0\nvaultIndexes[1] = N_COINS maxIndex minIndex = 3-0-0 = 3\n\n\nThis is clearly not what is wanted, all vaultIndexes should be different and should be in the range 0..2]. This is due to the fact that maxDelta and minDelta are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because vaultIndexes[1]  is out of range).\n\nExposure.sol L178(https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178):\nsolidity\nfunction sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {\n        uint256 maxIndex;\n        uint256 minIndex;\n        int256 maxDelta;\n        int256 minDelta;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            // Get difference between vault current assets and vault target\n            int256 delta = int256(\n                unifiedAssets[i] unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)\n            );\n            // Establish order\n            if (delta  maxDelta) {\n                maxDelta = delta;\n                maxIndex = i;\n            } else if (delta < minDelta) {\n                minDelta = delta;\n                minIndex = i;\n            }\n        }\n        if (bigFirst) {\n            vaultIndexes[0] = maxIndex;\n            vaultIndexes[2] = minIndex;\n        } else {\n            vaultIndexes[0] = minIndex;\n            vaultIndexes[2] = maxIndex;\n        }\n        vaultIndexes[1] = N_COINS maxIndex minIndex;\n    }\n\n\n",
                "Repair": "Recommend the following\n1. Initializing maxDelta and minDelta:\nsolidity\n        int256 maxDelta = -2255; // or type(int256).min when using a newer solidity version\n        int256 minDelta  = 2255; // or type(int256).max when using a newer solidity version\n\n2. Check that maxIndex and minIndex are not the same\n3. require (maxIndex != minIndex);\n\nkristian-gro (Gro) confirmed:\n Confirmed and Fix has been implemented in release version.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/vaults/yearnv2/v032/IYearnV2Vault.sol\";\nimport \"../common/Controllable.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../common/Constants.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../common/Whitelist.sol\";\n\n/// @notice Base contract for gro protocol vault adaptors - Vault adaptors act as a\n///     layer between the protocol and any yield aggregator vault. They provides additional\n///     functionality needed by the protocol, and allow the protocol to be agnostic\n///     to the type of underlying vault it interacts with.\n///\n///     ###############################################\n///     Base Vault Adaptor specifications\n///     ###############################################\n///\n///     Any deposit/withdrawal into the system will always attempt to interact with the\n///     appropriate vault adaptor (depending on token).\n///     - Deposit: A deposit will move assets into the vault adaptor, which will be\n///         available for investment into the underlying vault once a large enough amount\n///         of assets has amassed in the vault adaptor.\n///     - Withdrawal: A withdrawal will always attempt to pull from the vaultAdaptor if possible,\n///         if the assets in the adaptor fail to cover the withdrawal, the adaptor will\n///         attempt to withdraw assets from the underlying vaults strategies. The latter will\n///         also depend on whether pwrd or gvt is being withdrawn, as strategy assets affect\n///         system exposure levels.\n///     - Invest: Once a significant amount of assets have amassed in the vault adaptor, the\n///         invest trigger will signal that the adaptor is ready to invest assets. The adaptor\n///         always aims to hold a percent of total assets as univested assets (vaultReserve).\n///         This allows for smaller withdrawals to be cheaper as they dont have to interact with\n///         the underlying strategies.\n///     - Debt ratios: Ratio in %BP of assets to invest in the underlying strategies of a vault\nabstract contract BaseVaultAdaptor is Controllable, Constants, Whitelist, IVault {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 constant MAX_STRATS = 20;\n\n    // Underlying token\n    address public immutable override token;\n    uint256 public immutable decimals;\n    // Underlying vault\n    address public immutable override vault;\n    // Number of strategies\n    uint256 public strategiesLength;\n    // Used to determine if its OK to invest assets to underlying vault\n    uint256 public investThreshold;\n    // Used to establish if the strategy debt ratios need to be updated\n    uint256 public strategyRatioBuffer;\n    // How much of total assets should be held in the vault adaptor (%BP)\n    uint256 public vaultReserve;\n\n    event LogAdaptorToken(address token);\n    event LogAdaptorVault(address vault);\n    event LogAdaptorReserve(uint256 reserve);\n    event LogAdaptorStrategies(uint256 length);\n    event LogNewAdaptorInvestThreshold(uint256 threshold);\n    event LogNewAdaptorStrategyBuffer(uint256 buffer);\n    event LogNewDebtRatios(uint256[] strategyRetios);\n    event LogMigrate(address parent, address child, uint256 amount);\n\n    /// @notice Only the underlying vault is allowed to call\n    modifier onlyVault() {\n        require(msg.sender == vault);\n        _;\n    }\n\n    constructor(address _vault, address _token) public {\n        vault = _vault;\n        token = _token;\n        decimals = IERC20Detailed(_token).decimals();\n        IERC20(_token).safeApprove(address(_vault), 0);\n        IERC20(_token).safeApprove(address(_vault), type(uint256).max);\n    }\n\n    function setVaultReserve(uint256 reserve) external onlyOwner {\n        require(reserve <= PERCENTAGE_DECIMAL_FACTOR);\n        vaultReserve = reserve;\n        emit LogAdaptorReserve(reserve);\n    }\n\n    function setStrategiesLength(uint256 _strategiesLength) external onlyOwner {\n        strategiesLength = _strategiesLength;\n        emit LogAdaptorStrategies(_strategiesLength);\n    }\n\n    function setInvestThreshold(uint256 _investThreshold) external onlyOwner {\n        investThreshold = _investThreshold;\n        emit LogNewAdaptorInvestThreshold(_investThreshold);\n    }\n\n    function setStrategyRatioBuffer(uint256 _strategyRatioBuffer) external onlyOwner {\n        strategyRatioBuffer = _strategyRatioBuffer;\n        emit LogNewAdaptorStrategyBuffer(_strategyRatioBuffer);\n    }\n\n    /// @notice Determine if assets should be moved from the vault adaptors into the underlying vault\n    function investTrigger() external view override returns (bool) {\n        uint256 vaultHold = _totalAssets().mul(vaultReserve).div(PERCENTAGE_DECIMAL_FACTOR);\n        uint256 _investThreshold = investThreshold.mul(uint256(10)**decimals);\n        uint256 balance = IERC20(token).balanceOf(address(this));\n\n        if (balance < _investThreshold) {\n            return false;\n        } else if (balance.sub(_investThreshold) > vaultHold) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Move assets from vault adaptor into the underlying vault\n    function invest() external override onlyWhitelist {\n        uint256 vaultHold = _totalAssets().mul(vaultReserve).div(PERCENTAGE_DECIMAL_FACTOR);\n        uint256 _investThreshold = investThreshold.mul(uint256(10)**decimals);\n        uint256 balance = IERC20(token).balanceOf(address(this));\n\n        if (balance <= vaultHold) return;\n\n        if (balance.sub(vaultHold) > _investThreshold) {\n            depositToUnderlyingVault(balance.sub(vaultHold));\n        }\n\n        // Check and update strategies debt ratio\n        if (strategiesLength > 1) {\n            // Only for stablecoin vaults\n            uint256[] memory targetRatios = _controller().getStrategiesTargetRatio();\n            uint256[] memory currentRatios = getStrategiesDebtRatio();\n            bool update;\n            for (uint256 i; i < strategiesLength; i++) {\n                if (currentRatios[i] < targetRatios[i] && targetRatios[i].sub(currentRatios[i]) > strategyRatioBuffer) {\n                    update = true;\n                    break;\n                }\n\n                if (currentRatios[i] > targetRatios[i] && currentRatios[i].sub(targetRatios[i]) > strategyRatioBuffer) {\n                    update = true;\n                    break;\n                }\n            }\n            if (update) {\n                updateStrategiesDebtRatio(targetRatios);\n            }\n        }\n    }\n\n    /// @notice Calculate system total assets\n    function totalAssets() external view override returns (uint256) {\n        return _totalAssets();\n    }\n\n    /// @notice Get number of strategies in underlying vault\n    function getStrategiesLength() external view override returns (uint256) {\n        return strategiesLength;\n    }\n\n    /// @notice Withdraw assets from underlying vault\n    /// @param amount Amount to withdraw\n    /// @dev Sends assets to msg.sender\n    function withdraw(uint256 amount) external override {\n        require(msg.sender == _controller().lifeGuard(), \"withdraw: !lifeguard\");\n        if (!_withdrawFromAdapter(amount, msg.sender)) {\n            amount = _withdraw(calculateShare(amount), msg.sender);\n        }\n    }\n\n    /// @notice Withdraw assets from underlying vault\n    /// @param amount Amount to withdraw\n    /// @param recipient Target recipient\n    /// @dev Will try to pull assets from adaptor before moving on to pull\n    ///     assets from unerlying vault/strategies\n    function withdraw(uint256 amount, address recipient) external override {\n        require(msg.sender == _controller().insurance(), \"withdraw: !insurance\");\n        if (!_withdrawFromAdapter(amount, recipient)) {\n            amount = _withdraw(calculateShare(amount), recipient);\n        }\n    }\n\n    /// @notice Withdraw assets from vault to vault adaptor\n    /// @param amount Amount to withdraw\n    function withdrawToAdapter(uint256 amount) external onlyOwner {\n        amount = _withdraw(calculateShare(amount), address(this));\n    }\n\n    /// @notice Withdraw assets from underlying vault, but do so in a specific strategy order\n    /// @param amount Amount to withdraw\n    /// @param recipient Target recipient\n    /// @param reversed reverse strategy order\n    /// @dev This is an addaptation for yearn v2 vaults - these vaults have a defined withdraw\n    ///     order. Gro protocol needs to respect prtocol exposure, and thus might have to withdraw\n    ///     from different strategies depending on if pwrd or gvts are withdrawn.\n    function withdrawByStrategyOrder(\n        uint256 amount,\n        address recipient,\n        bool reversed\n    ) external override {\n        IController ctrl = _controller();\n        require(\n            msg.sender == ctrl.withdrawHandler() ||\n                msg.sender == ctrl.insurance() ||\n                msg.sender == ctrl.emergencyHandler(),\n            \"withdraw: !withdrawHandler/insurance\"\n        );\n        if (!_withdrawFromAdapter(amount, recipient)) {\n            amount = _withdrawByStrategyOrder(calculateShare(amount), recipient, reversed);\n        }\n    }\n\n    /// @notice Withdraw assets from underlying vault, but do so from a specific strategy\n    /// @param amount Amount to withdraw\n    /// @param recipient Target recipient\n    /// @param strategyIndex Index of target strategy\n    /// @dev Same as for withdrawByStrategyOrder, but now we withdraw from a specific strategy.\n    ///     This functionality exists to be able to move assets from overExposed strategies.\n    function withdrawByStrategyIndex(\n        uint256 amount,\n        address recipient,\n        uint256 strategyIndex\n    ) external override {\n        require(msg.sender == _controller().insurance(), \"withdraw: !withdrawHandler/insurance\");\n        if (!_withdrawFromAdapter(amount, recipient)) {\n            amount = _withdrawByStrategyIndex(calculateShare(amount), recipient, strategyIndex);\n        }\n    }\n\n    /// @notice Withdraw assets from the vault adaptor itself\n    /// @param amount Amount to withdraw\n    /// @param recipient Target recipient\n    function _withdrawFromAdapter(uint256 amount, address recipient) private returns (bool _success) {\n        uint256 adapterAmount = IERC20(token).balanceOf(address(this));\n        if (adapterAmount >= amount) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Get total amount invested in strategy\n    /// @param index Index of strategy\n    function getStrategyAssets(uint256 index) external view override returns (uint256 amount) {\n        return getStrategyTotalAssets(index);\n    }\n\n    /// @notice Deposit assets into the vault adaptor\n    /// @param amount Deposit amount\n    function deposit(uint256 amount) external override {\n        require(msg.sender == _controller().lifeGuard(), \"withdraw: !lifeguard\");\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @notice Set new strategy debt ratios\n    /// @param strategyRatios Array of new debt ratios\n    function updateStrategyRatio(uint256[] calldata strategyRatios) external override {\n        require(\n            msg.sender == _controller().insurance() || msg.sender == owner(),\n            \"!updateStrategyRatio: !owner/insurance\"\n        );\n        updateStrategiesDebtRatio(strategyRatios);\n        emit LogNewDebtRatios(strategyRatios);\n    }\n\n    /// @notice Check if underlying strategy needs to be harvested\n    /// @param index Index of stratey\n    /// @param callCost Cost of harvest\n    function strategyHarvestTrigger(uint256 index, uint256 callCost) external view override returns (bool harvested) {\n        require(index < strategiesLength, \"invalid index\");\n        return _strategyHarvestTrigger(index, callCost);\n    }\n\n    /// @notice Harvest underlying strategy\n    /// @param index Index of strategy\n    function strategyHarvest(uint256 index) external override onlyWhitelist returns (bool harvested) {\n        require(index < strategiesLength, \"invalid index\");\n        uint256 beforeAssets = vaultTotalAssets();\n        _strategyHarvest(index);\n        uint256 afterAssets = vaultTotalAssets();\n        if (afterAssets > beforeAssets) {\n            _controller().distributeStrategyGainLoss(afterAssets.sub(beforeAssets), 0);\n        } else if (afterAssets < beforeAssets) {\n            _controller().distributeStrategyGainLoss(0, beforeAssets.sub(afterAssets));\n        }\n        harvested = true;\n    }\n\n    /// @notice Migrate assets to new vault\n    /// @param child target for migration\n    function migrate(address child) external onlyOwner {\n        require(child != address(0), \"migrate: child == 0x\");\n        IERC20 _token = IERC20(token);\n        uint256 balance = _token.balanceOf(address(this));\n        _token.safeTransfer(child, balance);\n        emit LogMigrate(address(this), child, balance);\n    }\n\n    // Virtual functions\n    function _strategyHarvest(uint256 index) internal virtual;\n\n    function updateStrategiesDebtRatio(uint256[] memory ratios) internal virtual;\n\n    function getStrategiesDebtRatio() internal view virtual returns (uint256[] memory);\n\n    /// @notice Deposit from vault adaptors to underlying vaults\n    function depositToUnderlyingVault(uint256 amount) internal virtual;\n\n    function _withdraw(uint256 share, address recipient) internal virtual returns (uint256);\n\n    function _withdrawByStrategyOrder(\n        uint256 share,\n        address recipient,\n        bool reversed\n    ) internal virtual returns (uint256);\n\n    function _withdrawByStrategyIndex(\n        uint256 share,\n        address recipient,\n        uint256 index\n    ) internal virtual returns (uint256);\n\n    function _strategyHarvestTrigger(uint256 index, uint256 callCost) internal view virtual returns (bool);\n\n    function getStrategyEstimatedTotalAssets(uint256 index) internal view virtual returns (uint256);\n\n    function getStrategyTotalAssets(uint256 index) internal view virtual returns (uint256);\n\n    function vaultTotalAssets() internal view virtual returns (uint256);\n\n    function _totalAssets() internal view returns (uint256) {\n        uint256 total = IERC20(token).balanceOf(address(this)).add(vaultTotalAssets());\n        return total;\n    }\n\n    function calculateShare(uint256 amount) private view returns (uint256 share) {\n        uint256 sharePrice = _getVaultSharePrice();\n        share = amount.mul(uint256(10)**decimals).div(sharePrice);\n        uint256 balance = IERC20(vault).balanceOf(address(this));\n        share = share < balance ? share : balance;\n    }\n\n    /// @notice Calculate system total assets including estimated profits\n    function totalEstimatedAssets() external view returns (uint256) {\n        uint256 total = IERC20(token).balanceOf(address(this)).add(IERC20(token).balanceOf(address(vault)));\n        for (uint256 i = 0; i < strategiesLength; i++) {\n            total = total.add(getStrategyEstimatedTotalAssets(i));\n        }\n        return total;\n    }\n\n    function _getVaultSharePrice() internal view virtual returns (uint256);\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IYearnV2Strategy.sol\";\nimport \"../../BaseVaultAdaptor.sol\";\n\n/// @notice YearnV2Vault adaptor - Implementation of the gro protocol vault adaptor used to\n///     interact with Yearn v2 vaults. Gro protocol uses a modified version of the yearnV2Vault\n///     to accomodate for additional functionality (see Vault.vy):\n///         - Adaptor modifier:\n///             Withdraw/Deposit methods can only be accessed by the vaultAdaptor\n///         - Withdraw by StrategyOrder/Index:\n///             In order to be able to ensure that protocol exposures are within given thresholds\n///             inside the vault, the vault can now withdraw from the vault (underlying strategies)\n///             by a specific strategy or order of strategies. The orginal yearnV2Vault has a set\n///             withdrawalQueue.\n///         - The vault adaptor now acts as the first withdraw layer. This means that the adaptor,\n///             will always try to maintain a set amount of loose assets to make withdrawals cheaper.\n///             The underlying yearn vault on the other hand will always have a total debt ratio of\n///             100%, meaning that it will atempt to always have all its assets invested in the\n///             underlying strategies.\n///         - Asset availability:\n///             - VaultAdaptor:\n///                 - vaultReserve (%BP - see BaseVaultAdaptor)\n///             - Vault:\n///                 - target debt ratio => 100% (10000)\n///                 - loose assets cannot be guranteed\n///                     - after a vaultAdaptor invest action assets will be available\n///                     - after each strategy has called harvest no assets should be available\ncontract VaultAdaptorYearnV2_032 is BaseVaultAdaptor {\n    constructor(address _vault, address _token) public BaseVaultAdaptor(_vault, _token) {}\n\n    /// @notice Withdraw from vault adaptor, if withdrawal amount exceeds adaptors\n    ///     total available assets, withdraw from underlying vault, using a specific\n    ///     strategy order for withdrawal -> the withdrawal order dictates which strategy\n    ///     to withdraw from first, if this strategies assets are exhausted before the\n    ///     withdraw amount has been covered, the ramainder will be withdrawn from the next\n    ///     strategy in the list.\n    /// @param share Number of shares to withdraw (yVault shares)\n    /// @param recipient Recipient of withdrawal\n    /// @param pwrd Pwrd or gvt\n    function _withdrawByStrategyOrder(\n        uint256 share,\n        address recipient,\n        bool pwrd\n    ) internal override returns (uint256) {\n        if (pwrd) {\n            address[MAX_STRATS] memory _strategies;\n            for (uint256 i = strategiesLength; i > 0; i--) {\n                _strategies[i - 1] = IYearnV2Vault(vault).withdrawalQueue((strategiesLength - i));\n            }\n            return IYearnV2Vault(vault).withdrawByStrategy(_strategies, share, recipient, 1);\n        } else {\n            return _withdraw(share, recipient);\n        }\n    }\n\n    /// @notice Withdraw from vault adaptor, if withdrawal amount exceeds adaptors,\n    ///     withdraw from a specific strategy\n    /// @param share Number of shares to withdraw (yVault shares)\n    /// @param recipient Recipient of withdrawal\n    /// @param index Index of strategy\n    function _withdrawByStrategyIndex(\n        uint256 share,\n        address recipient,\n        uint256 index\n    ) internal override returns (uint256) {\n        if (index != 0) {\n            address[MAX_STRATS] memory _strategies;\n            uint256 strategyIndex = 0;\n            _strategies[strategyIndex] = IYearnV2Vault(vault).withdrawalQueue(index);\n            for (uint256 i = 0; i < strategiesLength; i++) {\n                if (i == index) {\n                    continue;\n                }\n                strategyIndex++;\n                _strategies[strategyIndex] = IYearnV2Vault(vault).withdrawalQueue(i);\n            }\n            return IYearnV2Vault(vault).withdrawByStrategy(_strategies, share, recipient, 0);\n        } else {\n            return _withdraw(share, recipient);\n        }\n    }\n\n    /// @notice Deposit from vault adaptors to underlying vaults\n    /// @param _amount Amount to deposit\n    function depositToUnderlyingVault(uint256 _amount) internal override {\n        if (_amount > 0) {\n            IYearnV2Vault(vault).deposit(_amount, address(this));\n        }\n    }\n\n    function _strategyHarvest(uint256 index) internal override {\n        IYearnV2Vault yearnVault = IYearnV2Vault(vault);\n        IYearnV2Strategy(yearnVault.withdrawalQueue(index)).harvest();\n    }\n\n    /// @notice Set debt ratio of underlying strategies to 0\n    function resetStrategyDeltaRatio() private {\n        IYearnV2Vault yearnVault = IYearnV2Vault(vault);\n        for (uint256 i = 0; i < strategiesLength; i++) {\n            yearnVault.updateStrategyDebtRatio(yearnVault.withdrawalQueue(i), 0);\n        }\n    }\n\n    function updateStrategiesDebtRatio(uint256[] memory ratios) internal override {\n        uint256 ratioTotal = 0;\n        for (uint256 i = 0; i < ratios.length; i++) {\n            ratioTotal = ratioTotal.add(ratios[i]);\n        }\n        require(ratioTotal <= 10**4, \"The total of ratios is more than 10000\");\n\n        resetStrategyDeltaRatio();\n\n        IYearnV2Vault yearnVault = IYearnV2Vault(vault);\n        for (uint256 i = 0; i < ratios.length; i++) {\n            yearnVault.updateStrategyDebtRatio(yearnVault.withdrawalQueue(i), ratios[i]);\n        }\n    }\n\n    /// @notice Return debt ratio of underlying strategies\n    function getStrategiesDebtRatio() internal view override returns (uint256[] memory ratios) {\n        ratios = new uint256[](strategiesLength);\n        IYearnV2Vault yearnVault = IYearnV2Vault(vault);\n        StrategyParams memory strategyParam;\n        for (uint256 i; i < strategiesLength; i++) {\n            strategyParam = yearnVault.strategies(yearnVault.withdrawalQueue(i));\n            ratios[i] = strategyParam.debtRatio;\n        }\n    }\n\n    function _strategyHarvestTrigger(uint256 index, uint256 callCost) internal view override returns (bool) {\n        IYearnV2Vault yearnVault = IYearnV2Vault(vault);\n        return IYearnV2Strategy(yearnVault.withdrawalQueue(index)).harvestTrigger(callCost);\n    }\n\n    function getStrategyEstimatedTotalAssets(uint256 index) internal view override returns (uint256) {\n        IYearnV2Vault yearnVault = IYearnV2Vault(vault);\n        return IYearnV2Strategy(yearnVault.withdrawalQueue(index)).estimatedTotalAssets();\n    }\n\n    function getStrategyTotalAssets(uint256 index) internal view override returns (uint256) {\n        IYearnV2Vault yearnVault = IYearnV2Vault(vault);\n        StrategyParams memory strategyParam = yearnVault.strategies(yearnVault.withdrawalQueue(index));\n        return strategyParam.totalDebt;\n    }\n\n    function _withdraw(uint256 share, address recipient) internal override returns (uint256 withdrawalAmount) {\n        (, , withdrawalAmount, ) = IYearnV2Vault(vault).withdraw(share, recipient, 1);\n    }\n\n    function vaultTotalAssets() internal view override returns (uint256) {\n        return IYearnV2Vault(vault).totalAssets();\n    }\n\n    function _getVaultSharePrice() internal view override returns (uint256) {\n        return IYearnV2Vault(vault).pricePerShare();\n    }\n}\n\n\n",
        "CodeNames": [
            "BaseVaultAdaptor.sol",
            "VaultAdaptorYearnV2_032.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nuint256 sharePrice = _getVaultSharePrice();\n// amount is in \"token\" decimals, share should be in \"vault\" decimals\nshare = amount.mul(uint256(10)decimals).div(sharePrice);\n"
                ],
                "Type": "  BaseVaultAdaptor  assumes  sharePrice  is always in underlying decimals",
                "Description": "\nThe two BaseVaultAdaptor.calculateShare functions compute share = amount.mul(uint256(10)decimals).div(sharePrice)\n\nsolidity\nuint256 sharePrice = _getVaultSharePrice();\n// amount is in \"token\" decimals, share should be in \"vault\" decimals\nshare = amount.mul(uint256(10)decimals).div(sharePrice);\n\n\nThis assumes that the sharePrice is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.\n\nBoth these assumptions happen to be correct for Yearn vaults, but that will not necessarily be the case for other protocols.\nAs this functionality is in the BaseVaultAdaptor, and not in the specific VaultAdaptorYearnV2_032, consider generalizing the conversion.\n\nIntegrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.\n\nBecause the conversion seems highly protocol-specific, it is recommended that calculateShare should be an abstract function (like _getVaultSharePrice) that is implemented in the specific adaptors.\n\nkristian-gro (Gro) confirmed(https://github.com/code-423n4/2021-06-gro-findings/issues/114)\n Confirmed and shares have been removed from release version.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport {FixedStablecoins, FixedGTokens} from \"./common/FixedContracts.sol\";\nimport \"./common/Whitelist.sol\";\n\nimport \"./interfaces/IBuoy.sol\";\nimport \"./interfaces/IChainPrice.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IInsurance.sol\";\nimport \"./interfaces/ILifeGuard.sol\";\nimport \"./interfaces/IPnL.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/// @notice The main hub for Gro protocol - The controller links up the other contracts,\n///     and acts a route for the other contracts to call one another. It holds global states\n///     such as paused and emergency. Contracts that depend on the controller implement\n///     Controllable.\n///\n///     *****************************************************************************\n///     System tokens - GTokens:\n///     gvt - high yield, uninsured\n///     pwrd - insured by gvt, pays part of its yield to gvt (depending on utilisation)\n///\n///     Tokens order is DAI, USDC, USDT.\n///     Index 0 - DAI, 1 - USDC, 2 - USDT\n///\n///     System vaults:\n///     Stablecoin vaults: One per stablecoin\n///     Curve vault: Vault for LP (liquidity pool) token\ncontract Controller is Pausable, Ownable, Whitelist, FixedStablecoins, FixedGTokens, IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public override curveVault; // LP token vault\n\n    bool public preventSmartContracts = false;\n\n    address public override insurance; // Insurance logic\n    address public override pnl; // Profit and loss calculations\n    address public override lifeGuard; // Asset swapping\n    address public override buoy; // Oracle\n    address public override depositHandler;\n    address public override withdrawHandler;\n    address public override emergencyHandler;\n\n    uint256 public override deadCoin = 99;\n    bool public override emergencyState;\n    // Lower bound for how many gvt can be burned before getting to close to the utilisation ratio\n    uint256 public utilisationRatioLimitGvt;\n    uint256 public utilisationRatioLimitPwrd;\n\n    /// Limits for what deposits/withdrawals that are considered 'large', and thus will be handled with\n    ///     a different logic - limits are checked against total assets locked in etiher of the two tokens (pwrd, gvt)\n    uint256 public bigFishThreshold = 100; // %Basis Points limit\n    uint256 public bigFishAbsoluteThreshold = 0; // Absolute limit\n    address public override reward;\n\n    mapping(address => bool) public safeAddresses; // Some integrations need to be exempt from flashloan checks\n    mapping(uint256 => address) public override underlyingVaults; // Protocol stablecoin vaults\n    mapping(address => uint256) public vaultIndexes;\n\n    mapping(address => address) public override referrals;\n\n    // Pwrd (true) and gvt (false) mapped to respective withdrawal fee\n    mapping(bool => uint256) public override withdrawalFee;\n\n    event LogNewWithdrawHandler(address tokens);\n    event LogNewDepositHandler(address tokens);\n    event LogNewVault(uint256 index, address vault);\n    event LogNewCurveVault(address curveVault);\n    event LogNewLifeguard(address lifeguard);\n    event LogNewInsurance(address insurance);\n    event LogNewPnl(address pnl);\n    event LogNewBigFishThreshold(uint256 percent, uint256 absolute);\n    event LogFlashSwitchUpdated(bool status);\n    event LogNewSafeAddress(address account);\n    event LogNewRewardsContract(address reward);\n    event LogNewUtilLimit(bool indexed pwrd, uint256 limit);\n    event LogNewCurveToStableDistribution(uint256 amount, uint256[N_COINS] amounts, uint256[N_COINS] delta);\n    event LogNewWithdrawalFee(address user, bool pwrd, uint256 newFee);\n\n    constructor(\n        address pwrd,\n        address gvt,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals\n    ) public FixedStablecoins(_tokens, _decimals) FixedGTokens(pwrd, gvt) {}\n\n    function pause() external onlyWhitelist {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {\n        require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");\n        withdrawHandler = _withdrawHandler;\n        emergencyHandler = _emergencyHandler;\n        emit LogNewWithdrawHandler(_withdrawHandler);\n    }\n\n    function setDepositHandler(address _depositHandler) external onlyOwner {\n        require(_depositHandler != address(0), \"setDepositHandler: 0x\");\n        depositHandler = _depositHandler;\n        emit LogNewDepositHandler(_depositHandler);\n    }\n\n    function stablecoins() external view override returns (address[N_COINS] memory) {\n        return underlyingTokens();\n    }\n\n    /// @notice Returns amount to skim of larger deposits for alternative vault (Curve)\n    function getSkimPercent() external view override returns (uint256) {\n        return IInsurance(insurance).calcSkim();\n    }\n\n    /// @notice Returns list of all the underling protocol vaults\n    function vaults() external view override returns (address[N_COINS] memory) {\n        address[N_COINS] memory result;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = underlyingVaults[i];\n        }\n        return result;\n    }\n\n    /// @notice Set system vaults, vault index should match its underlying token\n    function setVault(uint256 index, address vault) external onlyOwner {\n        require(vault != address(0), \"setVault: 0x\");\n        require(index < N_COINS, \"setVault: !index\");\n        underlyingVaults[index] = vault;\n        vaultIndexes[vault] = index + 1;\n        emit LogNewVault(index, vault);\n    }\n\n    function setCurveVault(address _curveVault) external onlyOwner {\n        require(_curveVault != address(0), \"setCurveVault: 0x\");\n        curveVault = _curveVault;\n        vaultIndexes[_curveVault] = N_COINS + 1;\n        emit LogNewCurveVault(_curveVault);\n    }\n\n    function setLifeGuard(address _lifeGuard) external onlyOwner {\n        require(_lifeGuard != address(0), \"setLifeGuard: 0x\");\n        lifeGuard = _lifeGuard;\n        buoy = ILifeGuard(_lifeGuard).getBuoy();\n        emit LogNewLifeguard(_lifeGuard);\n    }\n\n    function setInsurance(address _insurance) external onlyOwner {\n        require(_insurance != address(0), \"setInsurance: 0x\");\n        insurance = _insurance;\n        emit LogNewInsurance(_insurance);\n    }\n\n    function setPnL(address _pnl) external onlyOwner {\n        require(_pnl != address(0), \"setPnl: 0x\");\n        pnl = _pnl;\n        emit LogNewPnl(_pnl);\n    }\n\n    function addSafeAddress(address account) external onlyOwner {\n        safeAddresses[account] = true;\n        emit LogNewSafeAddress(account);\n    }\n\n    function switchEoaOnly(bool check) external onlyOwner {\n        preventSmartContracts = check;\n    }\n\n    /// @notice Set limit for when a deposit will be rerouted for alternative logic\n    /// @param _percent %BP limit\n    /// @param _absolute Absolute limit\n    /// @dev The two limits should be used as an upper and lower bound - the % limit\n    ///     considers the current TVL in the token interacted with (gvt or pwrd) and will\n    ///     act as the upper bound when the TVL is low. The absolute value will be the lower bound,\n    ///     ensuring that small deposits won't suffer higher gas costs.\n    function setBigFishThreshold(uint256 _percent, uint256 _absolute) external onlyOwner {\n        require(_percent > 0, \"_whaleLimit is 0\");\n        bigFishThreshold = _percent;\n        bigFishAbsoluteThreshold = _absolute;\n        emit LogNewBigFishThreshold(_percent, _absolute);\n    }\n\n    function setReward(address _reward) external onlyOwner {\n        require(_reward != address(0), \"setReward: 0x\");\n        reward = _reward;\n        emit LogNewRewardsContract(_reward);\n    }\n\n    function addReferral(address account, address referral) external override {\n        require(msg.sender == depositHandler, \"!depositHandler\");\n        if (account != address(0) && referral != address(0) && referrals[account] == address(0)) {\n            referrals[account] = referral;\n        }\n    }\n\n    /// @notice Set withdrawal fee for token\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param newFee New token fee\n    function setWithdrawalFee(bool pwrd, uint256 newFee) external onlyOwner {\n        withdrawalFee[pwrd] = newFee;\n        emit LogNewWithdrawalFee(msg.sender, pwrd, newFee);\n    }\n\n    /// @notice Calculate system total assets\n    function totalAssets() external view override returns (uint256) {\n        return emergencyState ? _totalAssetsEmergency() : _totalAssets();\n    }\n\n    /// @notice Calculate pwrd/gro vault total assets\n    function gTokenTotalAssets() public view override returns (uint256) {\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        if (msg.sender == address(gvt)) {\n            return gvtAssets;\n        }\n        if (msg.sender == address(pwrd)) {\n            return pwrdAssets;\n        }\n        return 0;\n    }\n\n    function gToken(bool isPWRD) external view override returns (address) {\n        return isPWRD ? address(pwrd) : address(gvt);\n    }\n\n    /// @notice Check if the deposit/withdrawal needs to go through alternate logic\n    /// @param amount USD amount of deposit/withdrawal\n    /// @dev Larger deposits are handled differently than small deposits in order\n    ///     to guarantee that the system isn't overexposed to any one stablecoin\n    function isValidBigFish(\n        bool pwrd,\n        bool deposit,\n        uint256 amount\n    ) external view override returns (bool) {\n        if (deposit && pwrd) {\n            require(validGTokenIncrease(amount), \"isBigFish: !validGTokenIncrease\");\n        } else if (!pwrd && !deposit) {\n            require(validGTokenDecrease(amount), \"isBigFish: !validGTokenDecrease\");\n        }\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        uint256 assets = pwrdAssets.add(gvtAssets);\n        if (amount < bigFishAbsoluteThreshold) {\n            return false;\n        } else if (amount > assets) {\n            return true;\n        } else {\n            return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);\n        }\n    }\n\n    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist {\n        uint256[N_COINS] memory amounts = ILifeGuard(lifeGuard).distributeCurveVault(amount, delta);\n        emit LogNewCurveToStableDistribution(amount, amounts, delta);\n    }\n\n    /// @notice Block if not an EOA or whitelisted\n    /// @param sender Address of contract to check\n    function eoaOnly(address sender) public override {\n        if (preventSmartContracts && !safeAddresses[tx.origin]) {\n            require(sender == tx.origin, \"EOA only\");\n        }\n    }\n\n    /// @notice TotalAssets = lifeguard + stablecoin vaults + LP vault\n    function _totalAssets() private view returns (uint256) {\n        require(IBuoy(buoy).safetyCheck(), \"!buoy.safetyCheck\");\n        uint256[N_COINS] memory lgAssets = ILifeGuard(lifeGuard).getAssets();\n        uint256[N_COINS] memory vaultAssets;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            vaultAssets[i] = lgAssets[i].add(IVault(underlyingVaults[i]).totalAssets());\n        }\n        uint256 totalLp = IVault(curveVault).totalAssets();\n        totalLp = totalLp.add(IBuoy(buoy).stableToLp(vaultAssets, true));\n        uint256 vp = IBuoy(buoy).getVirtualPrice();\n\n        return totalLp.mul(vp).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    /// @notice Same as _totalAssets function, but excluding curve vault + 1 stablecoin\n    ///             and uses chianlink as a price oracle\n    function _totalAssetsEmergency() private view returns (uint256) {\n        IChainPrice chainPrice = IChainPrice(buoy);\n        uint256 total;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (i != deadCoin) {\n                address tokenAddress = getToken(i);\n                uint256 decimals = getDecimal(i);\n                IERC20 token = IERC20(tokenAddress);\n                uint256 price = chainPrice.getPriceFeed(i);\n                uint256 assets = IVault(underlyingVaults[i]).totalAssets().add(token.balanceOf(lifeGuard));\n                assets = assets.mul(price).div(CHAINLINK_PRICE_DECIMAL_FACTOR);\n                assets = assets.mul(DEFAULT_DECIMALS_FACTOR).div(decimals);\n                total = total.add(assets);\n            }\n        }\n        return total;\n    }\n\n    /// @notice Set protocol into emergency mode, disabling the use of a give stablecoin.\n    ///             This state assumes:\n    ///                 - Stablecoin of excessively of peg\n    ///                 - Curve3Pool has failed\n    ///             Swapping wil be disabled and the allocation target will be set to\n    ///             100 % for the disabled stablecoin, effectively stopping the system from\n    ///             returning any to the user. Deposit are disable in this mode.\n    /// @param coin Stable coin to disable\n    function emergency(uint256 coin) external onlyWhitelist {\n        require(coin < N_COINS, \"invalid coin\");\n        if (!paused()) {\n            _pause();\n        }\n        deadCoin = coin;\n        emergencyState = true;\n\n        uint256 percent;\n        for (uint256 i; i < N_COINS; i++) {\n            if (i == coin) {\n                percent = 10000;\n            } else {\n                percent = 0;\n            }\n            IInsurance(insurance).setUnderlyingTokenPercent(i, percent);\n        }\n        IPnL(pnl).emergencyPnL();\n    }\n\n    /// @notice Recover the system after emergency mode -\n    /// @param allocations New system target allocations\n    /// @dev Will recalculate system assets and atempt to give back any\n    ///     recovered assets to the GVT side\n    function restart(uint256[] calldata allocations) external onlyOwner whenPaused {\n        _unpause();\n        deadCoin = 99;\n        emergencyState = false;\n\n        for (uint256 i; i < N_COINS; i++) {\n            IInsurance(insurance).setUnderlyingTokenPercent(i, allocations[i]);\n        }\n        IPnL(pnl).recover();\n    }\n\n    /// @notice Distribute any gains or losses generated from a harvest\n    /// @param gain harvset gains\n    /// @param loss harvest losses\n    function distributeStrategyGainLoss(uint256 gain, uint256 loss) external override {\n        uint256 index = vaultIndexes[msg.sender];\n        require(index > 0 || index <= N_COINS + 1, \"!VaultAdaptor\");\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        uint256 gainUsd;\n        uint256 lossUsd;\n        index = index - 1;\n        if (index < N_COINS) {\n            if (gain > 0) {\n                gainUsd = ibuoy.singleStableToUsd(gain, index);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.singleStableToUsd(loss, index);\n            }\n        } else {\n            if (gain > 0) {\n                gainUsd = ibuoy.lpToUsd(gain);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.lpToUsd(loss);\n            }\n        }\n        ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);\n        // Check if curve spot price within tollerance, if so update them\n        if (ibuoy.updateRatios()) {\n            // If the curve ratios were successfully updated, realize system price changes\n            ipnl.distributePriceChange(_totalAssets());\n        }\n    }\n\n    function realizePriceChange(uint256 tolerance) external onlyOwner {\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        if (emergencyState) {\n            ipnl.distributePriceChange(_totalAssetsEmergency());\n        } else {\n            // Check if curve spot price within tollerance, if so update them\n            if (ibuoy.updateRatiosWithTolerance(tolerance)) {\n                // If the curve ratios were successfully updated, realize system price changes\n                ipnl.distributePriceChange(_totalAssets());\n            }\n        }\n    }\n\n    function burnGToken(\n        bool pwrd,\n        bool all,\n        address account,\n        uint256 amount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == withdrawHandler || msg.sender == emergencyHandler, \"burnGToken: !withdrawHandler\");\n        IToken gt = gTokens(pwrd);\n        if (!all) {\n            gt.burn(account, gt.factor(), amount);\n        } else {\n            gt.burnAll(account);\n        }\n        // Update underlying assets held in pwrd/gvt\n        IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount, bonus);\n    }\n\n    function mintGToken(\n        bool pwrd,\n        address account,\n        uint256 amount\n    ) external override {\n        require(msg.sender == depositHandler, \"burnGToken: !depositHandler\");\n        IToken gt = gTokens(pwrd);\n        gt.mint(account, gt.factor(), amount);\n        IPnL(pnl).increaseGTokenLastAmount(pwrd, amount);\n    }\n\n    /// @notice Calcualte withdrawal value when withdrawing all\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param account User account\n    function getUserAssets(bool pwrd, address account) external view override returns (uint256 deductUsd) {\n        IToken gt = gTokens(pwrd);\n        deductUsd = gt.getAssets(account);\n        require(deductUsd > 0, \"!minAmount\");\n    }\n\n    /// @notice Check if it's OK to mint the specified amount of tokens, this affects\n    ///     pwrds, as they have an upper bound set by the amount of gvt\n    /// @param amount Amount of token to mint\n    function validGTokenIncrease(uint256 amount) private view returns (bool) {\n        return\n            gTokens(false).totalAssets().mul(utilisationRatioLimitPwrd).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            amount.add(gTokens(true).totalAssets());\n    }\n\n    /// @notice Check if it's OK to burn the specified amount of tokens, this affects\n    ///     gvt, as they have a lower bound set by the amount of pwrds\n    /// @param amount Amount of token to burn\n    function validGTokenDecrease(uint256 amount) public view override returns (bool) {\n        return\n            gTokens(false).totalAssets().sub(amount).mul(utilisationRatioLimitGvt).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            gTokens(true).totalAssets();\n    }\n\n    /// @notice Set the lower bound for when to stop accepting deposits for pwrd - this allows for a bit of legroom\n    ///     for gvt to be sold (if this limit is reached, this contract only accepts deposits for gvt)\n    /// @param _utilisationRatioLimitPwrd Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitPwrd(uint256 _utilisationRatioLimitPwrd) external onlyOwner {\n        utilisationRatioLimitPwrd = _utilisationRatioLimitPwrd;\n        emit LogNewUtilLimit(true, _utilisationRatioLimitPwrd);\n    }\n\n    /// @notice Set the lower bound for when to stop accepting gvt withdrawals\n    /// @param _utilisationRatioLimitGvt Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitGvt(uint256 _utilisationRatioLimitGvt) external onlyOwner {\n        utilisationRatioLimitGvt = _utilisationRatioLimitGvt;\n        emit LogNewUtilLimit(false, _utilisationRatioLimitGvt);\n    }\n\n    function getStrategiesTargetRatio() external view override returns (uint256[] memory) {\n        uint256 utilRatio = IPnL(pnl).utilisationRatio();\n        return IInsurance(insurance).getStrategiesTargetRatio(utilRatio);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"contracts/interfaces/IChainlinkAggregator.sol\";\n\ncontract MockAggregator is IChainlinkAggregator {\n    uint80 public roundId_;\n    int256 public answer_;\n    uint256 public startedAt_;\n    uint256 public updatedAt_;\n    uint80 public answeredInRound_;\n\n    constructor(int256 latestPrice) public {\n        roundId_ = 1;\n        answer_ = latestPrice;\n        startedAt_ = block.timestamp;\n        updatedAt_ = block.timestamp;\n        answeredInRound_ = 1;\n    }\n\n    function setPrice(int256 newPrice) external {\n        answer_ = newPrice;\n        updatedAt_ = block.timestamp;\n        answeredInRound_ = answeredInRound_ + 1;\n        roundId_ = roundId_ + 1;\n    }\n\n    function latestRound() external view override returns (uint256) {\n        return uint256(roundId_);\n    }\n\n    function latestAnswer() external view override returns (int256) {\n        return answer_;\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol",
            "MockAggregator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "Buoy",
                    "latestAnswer"
                ],
                "Type": " Use of deprecated Chainlink function  latestAnswer ",
                "Description": "\nAccording to Chainlink's documentation ([Deprecated API Reference(https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/), Migration Instructions(https://docs.chain.link/docs/migrating-to-flux-aggregator/#3-use-the-new-functions), and API Reference(https://docs.chain.link/docs/price-feeds-api-reference/)), the latestAnswer function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, causing an incorrect price to be fed to the Buoy3Pool. See Buoy3Pool.sol L207(https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L207) and\nL214-L216(https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L214-L216).\n\n",
                "Repair": "Recommend using the latestRoundData function to get the price instead. Also recommend adding checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:\n\nsolidity\n(uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = oracle.latestRoundData();\nrequire(answeredInRound = roundID, \"...\");\nrequire(timeStamp != 0, \"...\");\n\n\nkristian-gro (Gro) disagreed with severity(https://github.com/code-423n4/2021-06-gro-findings/issues/126#issuecomment-879972199):\n disagree with severity (Low risk)\n Issue would cause deposits and withdrawals to stop, no funds lost\n\nkristian-gro (Gro) confirmed:\n Confirmed and shares have been removed from release version.\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-06-gro-findings/issues/126#issuecomment-886824919):\n  In my opinion halting the protocol deserves medium risk. While no funds are lost, from brand perspective it's a second worst thing. Keeping as medium risk.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"./GERC20.sol\";\nimport \"../common/Constants.sol\";\nimport \"../common/Whitelist.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../interfaces/IToken.sol\";\n\n/// @notice Base contract for gro protocol tokens - The Gro token specifies some additional functionality\n///     shared by both tokens (Rebasing, NonRebasing).\n///     - Factor:\n///         The GToken factor. The two tokens are associated with a factor that controls their price (NonRebasing),\n///         or their amount (Rebasing). The factor is defined by the totalSupply / total assets lock in token.\n///     - Base:\n///         The base amount of minted tokens, this affects the Rebasing token as the totalSupply is defined by:\n///         BASE amount / factor\n///     - Total assets:\n///         Total assets is the dollarvalue of the underlying assets used to mint Gtokens. The Gtoken\n///         depends on an external contract (Controller.sol) to get this value (retrieved from PnL calculations)\nabstract contract GToken is GERC20, Constants, Whitelist, IToken {\n    uint256 public constant BASE = DEFAULT_DECIMALS_FACTOR;\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IController public ctrl;\n\n    constructor(string memory name, string memory symbol) public GERC20(name, symbol, DEFAULT_DECIMALS) {}\n\n    function setController(address controller) external onlyOwner {\n        ctrl = IController(controller);\n    }\n\n    function factor() public view override returns (uint256) {\n        return factor(totalAssets());\n    }\n\n    function applyFactor(\n        uint256 a,\n        uint256 b,\n        bool base\n    ) internal pure returns (uint256 resultant) {\n        uint256 _BASE = BASE;\n        uint256 diff;\n        if (base) {\n            diff = a.mul(b) % _BASE;\n            resultant = a.mul(b).div(_BASE);\n        } else {\n            diff = a.mul(_BASE) % b;\n            resultant = a.mul(_BASE).div(b);\n        }\n        if (diff >= 5E17) {\n            resultant = resultant.add(1);\n        }\n    }\n\n    function factor(uint256 totalAssets) public view override returns (uint256) {\n        if (totalSupplyBase() == 0) {\n            return getInitialBase();\n        }\n\n        if (totalAssets > 0) {\n            return totalSupplyBase().mul(BASE).div(totalAssets);\n        }\n\n        // This case is totalSupply > 0 && totalAssets == 0, and only occurs on system loss\n        return 0;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return ctrl.gTokenTotalAssets();\n    }\n\n    function getInitialBase() internal pure virtual returns (uint256) {\n        return BASE;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport {FixedStablecoins, FixedGTokens} from \"./common/FixedContracts.sol\";\nimport \"./common/Whitelist.sol\";\n\nimport \"./interfaces/IBuoy.sol\";\nimport \"./interfaces/IChainPrice.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IInsurance.sol\";\nimport \"./interfaces/ILifeGuard.sol\";\nimport \"./interfaces/IPnL.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/// @notice The main hub for Gro protocol - The controller links up the other contracts,\n///     and acts a route for the other contracts to call one another. It holds global states\n///     such as paused and emergency. Contracts that depend on the controller implement\n///     Controllable.\n///\n///     *****************************************************************************\n///     System tokens - GTokens:\n///     gvt - high yield, uninsured\n///     pwrd - insured by gvt, pays part of its yield to gvt (depending on utilisation)\n///\n///     Tokens order is DAI, USDC, USDT.\n///     Index 0 - DAI, 1 - USDC, 2 - USDT\n///\n///     System vaults:\n///     Stablecoin vaults: One per stablecoin\n///     Curve vault: Vault for LP (liquidity pool) token\ncontract Controller is Pausable, Ownable, Whitelist, FixedStablecoins, FixedGTokens, IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public override curveVault; // LP token vault\n\n    bool public preventSmartContracts = false;\n\n    address public override insurance; // Insurance logic\n    address public override pnl; // Profit and loss calculations\n    address public override lifeGuard; // Asset swapping\n    address public override buoy; // Oracle\n    address public override depositHandler;\n    address public override withdrawHandler;\n    address public override emergencyHandler;\n\n    uint256 public override deadCoin = 99;\n    bool public override emergencyState;\n    // Lower bound for how many gvt can be burned before getting to close to the utilisation ratio\n    uint256 public utilisationRatioLimitGvt;\n    uint256 public utilisationRatioLimitPwrd;\n\n    /// Limits for what deposits/withdrawals that are considered 'large', and thus will be handled with\n    ///     a different logic - limits are checked against total assets locked in etiher of the two tokens (pwrd, gvt)\n    uint256 public bigFishThreshold = 100; // %Basis Points limit\n    uint256 public bigFishAbsoluteThreshold = 0; // Absolute limit\n    address public override reward;\n\n    mapping(address => bool) public safeAddresses; // Some integrations need to be exempt from flashloan checks\n    mapping(uint256 => address) public override underlyingVaults; // Protocol stablecoin vaults\n    mapping(address => uint256) public vaultIndexes;\n\n    mapping(address => address) public override referrals;\n\n    // Pwrd (true) and gvt (false) mapped to respective withdrawal fee\n    mapping(bool => uint256) public override withdrawalFee;\n\n    event LogNewWithdrawHandler(address tokens);\n    event LogNewDepositHandler(address tokens);\n    event LogNewVault(uint256 index, address vault);\n    event LogNewCurveVault(address curveVault);\n    event LogNewLifeguard(address lifeguard);\n    event LogNewInsurance(address insurance);\n    event LogNewPnl(address pnl);\n    event LogNewBigFishThreshold(uint256 percent, uint256 absolute);\n    event LogFlashSwitchUpdated(bool status);\n    event LogNewSafeAddress(address account);\n    event LogNewRewardsContract(address reward);\n    event LogNewUtilLimit(bool indexed pwrd, uint256 limit);\n    event LogNewCurveToStableDistribution(uint256 amount, uint256[N_COINS] amounts, uint256[N_COINS] delta);\n    event LogNewWithdrawalFee(address user, bool pwrd, uint256 newFee);\n\n    constructor(\n        address pwrd,\n        address gvt,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals\n    ) public FixedStablecoins(_tokens, _decimals) FixedGTokens(pwrd, gvt) {}\n\n    function pause() external onlyWhitelist {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {\n        require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");\n        withdrawHandler = _withdrawHandler;\n        emergencyHandler = _emergencyHandler;\n        emit LogNewWithdrawHandler(_withdrawHandler);\n    }\n\n    function setDepositHandler(address _depositHandler) external onlyOwner {\n        require(_depositHandler != address(0), \"setDepositHandler: 0x\");\n        depositHandler = _depositHandler;\n        emit LogNewDepositHandler(_depositHandler);\n    }\n\n    function stablecoins() external view override returns (address[N_COINS] memory) {\n        return underlyingTokens();\n    }\n\n    /// @notice Returns amount to skim of larger deposits for alternative vault (Curve)\n    function getSkimPercent() external view override returns (uint256) {\n        return IInsurance(insurance).calcSkim();\n    }\n\n    /// @notice Returns list of all the underling protocol vaults\n    function vaults() external view override returns (address[N_COINS] memory) {\n        address[N_COINS] memory result;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = underlyingVaults[i];\n        }\n        return result;\n    }\n\n    /// @notice Set system vaults, vault index should match its underlying token\n    function setVault(uint256 index, address vault) external onlyOwner {\n        require(vault != address(0), \"setVault: 0x\");\n        require(index < N_COINS, \"setVault: !index\");\n        underlyingVaults[index] = vault;\n        vaultIndexes[vault] = index + 1;\n        emit LogNewVault(index, vault);\n    }\n\n    function setCurveVault(address _curveVault) external onlyOwner {\n        require(_curveVault != address(0), \"setCurveVault: 0x\");\n        curveVault = _curveVault;\n        vaultIndexes[_curveVault] = N_COINS + 1;\n        emit LogNewCurveVault(_curveVault);\n    }\n\n    function setLifeGuard(address _lifeGuard) external onlyOwner {\n        require(_lifeGuard != address(0), \"setLifeGuard: 0x\");\n        lifeGuard = _lifeGuard;\n        buoy = ILifeGuard(_lifeGuard).getBuoy();\n        emit LogNewLifeguard(_lifeGuard);\n    }\n\n    function setInsurance(address _insurance) external onlyOwner {\n        require(_insurance != address(0), \"setInsurance: 0x\");\n        insurance = _insurance;\n        emit LogNewInsurance(_insurance);\n    }\n\n    function setPnL(address _pnl) external onlyOwner {\n        require(_pnl != address(0), \"setPnl: 0x\");\n        pnl = _pnl;\n        emit LogNewPnl(_pnl);\n    }\n\n    function addSafeAddress(address account) external onlyOwner {\n        safeAddresses[account] = true;\n        emit LogNewSafeAddress(account);\n    }\n\n    function switchEoaOnly(bool check) external onlyOwner {\n        preventSmartContracts = check;\n    }\n\n    /// @notice Set limit for when a deposit will be rerouted for alternative logic\n    /// @param _percent %BP limit\n    /// @param _absolute Absolute limit\n    /// @dev The two limits should be used as an upper and lower bound - the % limit\n    ///     considers the current TVL in the token interacted with (gvt or pwrd) and will\n    ///     act as the upper bound when the TVL is low. The absolute value will be the lower bound,\n    ///     ensuring that small deposits won't suffer higher gas costs.\n    function setBigFishThreshold(uint256 _percent, uint256 _absolute) external onlyOwner {\n        require(_percent > 0, \"_whaleLimit is 0\");\n        bigFishThreshold = _percent;\n        bigFishAbsoluteThreshold = _absolute;\n        emit LogNewBigFishThreshold(_percent, _absolute);\n    }\n\n    function setReward(address _reward) external onlyOwner {\n        require(_reward != address(0), \"setReward: 0x\");\n        reward = _reward;\n        emit LogNewRewardsContract(_reward);\n    }\n\n    function addReferral(address account, address referral) external override {\n        require(msg.sender == depositHandler, \"!depositHandler\");\n        if (account != address(0) && referral != address(0) && referrals[account] == address(0)) {\n            referrals[account] = referral;\n        }\n    }\n\n    /// @notice Set withdrawal fee for token\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param newFee New token fee\n    function setWithdrawalFee(bool pwrd, uint256 newFee) external onlyOwner {\n        withdrawalFee[pwrd] = newFee;\n        emit LogNewWithdrawalFee(msg.sender, pwrd, newFee);\n    }\n\n    /// @notice Calculate system total assets\n    function totalAssets() external view override returns (uint256) {\n        return emergencyState ? _totalAssetsEmergency() : _totalAssets();\n    }\n\n    /// @notice Calculate pwrd/gro vault total assets\n    function gTokenTotalAssets() public view override returns (uint256) {\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        if (msg.sender == address(gvt)) {\n            return gvtAssets;\n        }\n        if (msg.sender == address(pwrd)) {\n            return pwrdAssets;\n        }\n        return 0;\n    }\n\n    function gToken(bool isPWRD) external view override returns (address) {\n        return isPWRD ? address(pwrd) : address(gvt);\n    }\n\n    /// @notice Check if the deposit/withdrawal needs to go through alternate logic\n    /// @param amount USD amount of deposit/withdrawal\n    /// @dev Larger deposits are handled differently than small deposits in order\n    ///     to guarantee that the system isn't overexposed to any one stablecoin\n    function isValidBigFish(\n        bool pwrd,\n        bool deposit,\n        uint256 amount\n    ) external view override returns (bool) {\n        if (deposit && pwrd) {\n            require(validGTokenIncrease(amount), \"isBigFish: !validGTokenIncrease\");\n        } else if (!pwrd && !deposit) {\n            require(validGTokenDecrease(amount), \"isBigFish: !validGTokenDecrease\");\n        }\n        (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();\n        uint256 assets = pwrdAssets.add(gvtAssets);\n        if (amount < bigFishAbsoluteThreshold) {\n            return false;\n        } else if (amount > assets) {\n            return true;\n        } else {\n            return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);\n        }\n    }\n\n    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist {\n        uint256[N_COINS] memory amounts = ILifeGuard(lifeGuard).distributeCurveVault(amount, delta);\n        emit LogNewCurveToStableDistribution(amount, amounts, delta);\n    }\n\n    /// @notice Block if not an EOA or whitelisted\n    /// @param sender Address of contract to check\n    function eoaOnly(address sender) public override {\n        if (preventSmartContracts && !safeAddresses[tx.origin]) {\n            require(sender == tx.origin, \"EOA only\");\n        }\n    }\n\n    /// @notice TotalAssets = lifeguard + stablecoin vaults + LP vault\n    function _totalAssets() private view returns (uint256) {\n        require(IBuoy(buoy).safetyCheck(), \"!buoy.safetyCheck\");\n        uint256[N_COINS] memory lgAssets = ILifeGuard(lifeGuard).getAssets();\n        uint256[N_COINS] memory vaultAssets;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            vaultAssets[i] = lgAssets[i].add(IVault(underlyingVaults[i]).totalAssets());\n        }\n        uint256 totalLp = IVault(curveVault).totalAssets();\n        totalLp = totalLp.add(IBuoy(buoy).stableToLp(vaultAssets, true));\n        uint256 vp = IBuoy(buoy).getVirtualPrice();\n\n        return totalLp.mul(vp).div(DEFAULT_DECIMALS_FACTOR);\n    }\n\n    /// @notice Same as _totalAssets function, but excluding curve vault + 1 stablecoin\n    ///             and uses chianlink as a price oracle\n    function _totalAssetsEmergency() private view returns (uint256) {\n        IChainPrice chainPrice = IChainPrice(buoy);\n        uint256 total;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (i != deadCoin) {\n                address tokenAddress = getToken(i);\n                uint256 decimals = getDecimal(i);\n                IERC20 token = IERC20(tokenAddress);\n                uint256 price = chainPrice.getPriceFeed(i);\n                uint256 assets = IVault(underlyingVaults[i]).totalAssets().add(token.balanceOf(lifeGuard));\n                assets = assets.mul(price).div(CHAINLINK_PRICE_DECIMAL_FACTOR);\n                assets = assets.mul(DEFAULT_DECIMALS_FACTOR).div(decimals);\n                total = total.add(assets);\n            }\n        }\n        return total;\n    }\n\n    /// @notice Set protocol into emergency mode, disabling the use of a give stablecoin.\n    ///             This state assumes:\n    ///                 - Stablecoin of excessively of peg\n    ///                 - Curve3Pool has failed\n    ///             Swapping wil be disabled and the allocation target will be set to\n    ///             100 % for the disabled stablecoin, effectively stopping the system from\n    ///             returning any to the user. Deposit are disable in this mode.\n    /// @param coin Stable coin to disable\n    function emergency(uint256 coin) external onlyWhitelist {\n        require(coin < N_COINS, \"invalid coin\");\n        if (!paused()) {\n            _pause();\n        }\n        deadCoin = coin;\n        emergencyState = true;\n\n        uint256 percent;\n        for (uint256 i; i < N_COINS; i++) {\n            if (i == coin) {\n                percent = 10000;\n            } else {\n                percent = 0;\n            }\n            IInsurance(insurance).setUnderlyingTokenPercent(i, percent);\n        }\n        IPnL(pnl).emergencyPnL();\n    }\n\n    /// @notice Recover the system after emergency mode -\n    /// @param allocations New system target allocations\n    /// @dev Will recalculate system assets and atempt to give back any\n    ///     recovered assets to the GVT side\n    function restart(uint256[] calldata allocations) external onlyOwner whenPaused {\n        _unpause();\n        deadCoin = 99;\n        emergencyState = false;\n\n        for (uint256 i; i < N_COINS; i++) {\n            IInsurance(insurance).setUnderlyingTokenPercent(i, allocations[i]);\n        }\n        IPnL(pnl).recover();\n    }\n\n    /// @notice Distribute any gains or losses generated from a harvest\n    /// @param gain harvset gains\n    /// @param loss harvest losses\n    function distributeStrategyGainLoss(uint256 gain, uint256 loss) external override {\n        uint256 index = vaultIndexes[msg.sender];\n        require(index > 0 || index <= N_COINS + 1, \"!VaultAdaptor\");\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        uint256 gainUsd;\n        uint256 lossUsd;\n        index = index - 1;\n        if (index < N_COINS) {\n            if (gain > 0) {\n                gainUsd = ibuoy.singleStableToUsd(gain, index);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.singleStableToUsd(loss, index);\n            }\n        } else {\n            if (gain > 0) {\n                gainUsd = ibuoy.lpToUsd(gain);\n            } else if (loss > 0) {\n                lossUsd = ibuoy.lpToUsd(loss);\n            }\n        }\n        ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);\n        // Check if curve spot price within tollerance, if so update them\n        if (ibuoy.updateRatios()) {\n            // If the curve ratios were successfully updated, realize system price changes\n            ipnl.distributePriceChange(_totalAssets());\n        }\n    }\n\n    function realizePriceChange(uint256 tolerance) external onlyOwner {\n        IPnL ipnl = IPnL(pnl);\n        IBuoy ibuoy = IBuoy(buoy);\n        if (emergencyState) {\n            ipnl.distributePriceChange(_totalAssetsEmergency());\n        } else {\n            // Check if curve spot price within tollerance, if so update them\n            if (ibuoy.updateRatiosWithTolerance(tolerance)) {\n                // If the curve ratios were successfully updated, realize system price changes\n                ipnl.distributePriceChange(_totalAssets());\n            }\n        }\n    }\n\n    function burnGToken(\n        bool pwrd,\n        bool all,\n        address account,\n        uint256 amount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == withdrawHandler || msg.sender == emergencyHandler, \"burnGToken: !withdrawHandler\");\n        IToken gt = gTokens(pwrd);\n        if (!all) {\n            gt.burn(account, gt.factor(), amount);\n        } else {\n            gt.burnAll(account);\n        }\n        // Update underlying assets held in pwrd/gvt\n        IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount, bonus);\n    }\n\n    function mintGToken(\n        bool pwrd,\n        address account,\n        uint256 amount\n    ) external override {\n        require(msg.sender == depositHandler, \"burnGToken: !depositHandler\");\n        IToken gt = gTokens(pwrd);\n        gt.mint(account, gt.factor(), amount);\n        IPnL(pnl).increaseGTokenLastAmount(pwrd, amount);\n    }\n\n    /// @notice Calcualte withdrawal value when withdrawing all\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    /// @param account User account\n    function getUserAssets(bool pwrd, address account) external view override returns (uint256 deductUsd) {\n        IToken gt = gTokens(pwrd);\n        deductUsd = gt.getAssets(account);\n        require(deductUsd > 0, \"!minAmount\");\n    }\n\n    /// @notice Check if it's OK to mint the specified amount of tokens, this affects\n    ///     pwrds, as they have an upper bound set by the amount of gvt\n    /// @param amount Amount of token to mint\n    function validGTokenIncrease(uint256 amount) private view returns (bool) {\n        return\n            gTokens(false).totalAssets().mul(utilisationRatioLimitPwrd).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            amount.add(gTokens(true).totalAssets());\n    }\n\n    /// @notice Check if it's OK to burn the specified amount of tokens, this affects\n    ///     gvt, as they have a lower bound set by the amount of pwrds\n    /// @param amount Amount of token to burn\n    function validGTokenDecrease(uint256 amount) public view override returns (bool) {\n        return\n            gTokens(false).totalAssets().sub(amount).mul(utilisationRatioLimitGvt).div(PERCENTAGE_DECIMAL_FACTOR) >=\n            gTokens(true).totalAssets();\n    }\n\n    /// @notice Set the lower bound for when to stop accepting deposits for pwrd - this allows for a bit of legroom\n    ///     for gvt to be sold (if this limit is reached, this contract only accepts deposits for gvt)\n    /// @param _utilisationRatioLimitPwrd Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitPwrd(uint256 _utilisationRatioLimitPwrd) external onlyOwner {\n        utilisationRatioLimitPwrd = _utilisationRatioLimitPwrd;\n        emit LogNewUtilLimit(true, _utilisationRatioLimitPwrd);\n    }\n\n    /// @notice Set the lower bound for when to stop accepting gvt withdrawals\n    /// @param _utilisationRatioLimitGvt Lower limit for pwrd (%BP)\n    function setUtilisationRatioLimitGvt(uint256 _utilisationRatioLimitGvt) external onlyOwner {\n        utilisationRatioLimitGvt = _utilisationRatioLimitGvt;\n        emit LogNewUtilLimit(false, _utilisationRatioLimitGvt);\n    }\n\n    function getStrategiesTargetRatio() external view override returns (uint256[] memory) {\n        uint256 utilRatio = IPnL(pnl).utilisationRatio();\n        return IInsurance(insurance).getStrategiesTargetRatio(utilRatio);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {FixedStablecoins, FixedVaults} from \"./common/FixedContracts.sol\";\nimport \"./common/Controllable.sol\";\n\nimport \"./interfaces/IBuoy.sol\";\nimport \"./interfaces/IDepositHandler.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IInsurance.sol\";\nimport \"./interfaces/ILifeGuard.sol\";\n\n/// @notice Entry point for deposits into Gro protocol - User deposits can be done with one or\n///     multiple assets, being more expensive gas wise for each additional asset that is deposited.\n///     The deposits are treated differently depending on size:\n///         1) sardine - the smallest type of deposit, deemed to not affect the system exposure, and\n///            is deposited directly into the system - Curve vault is used to price the deposit (buoy)\n///         2) tuna - mid sized deposits, will be swapped to least exposed vault asset using Curve's\n///            exchange function (lifeguard). Targeting the desired asset (single sided deposit\n///            against the least exposed stablecoin) minimizes slippage as it doesn't need to perform\n///            any exchanges in the Curve pool\n///         3) whale - the largest deposits - deposit will be distributed across all stablecoin vaults\n///\n///     Tuna and Whale deposits will go through the lifeguard, which in turn will perform all\n///     necessary asset swaps.\ncontract DepositHandler is Controllable, FixedStablecoins, FixedVaults, IDepositHandler {\n    IController public ctrl;\n    ILifeGuard public lg;\n    IBuoy public buoy;\n    IInsurance public insurance;\n\n    mapping(uint256 => bool) public feeToken; // (USDT might have a fee)\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    event LogNewFeeToken(address indexed token, uint256 index);\n    event LogNewDependencies(address controller, address lifeguard, address buoy, address insurance);\n    event LogNewDeposit(\n        address indexed user,\n        address indexed referral,\n        bool pwrd,\n        uint256 usdAmount,\n        uint256[N_COINS] tokens\n    );\n\n    constructor(\n        uint256 _feeToken,\n        address[N_COINS] memory _vaults,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals\n    ) public FixedStablecoins(_tokens, _decimals) FixedVaults(_vaults) {\n        feeToken[_feeToken] = true;\n    }\n\n    /// @notice Update protocol dependencies\n    function setDependencies() external onlyOwner {\n        ctrl = _controller();\n        lg = ILifeGuard(ctrl.lifeGuard());\n        buoy = IBuoy(lg.getBuoy());\n        insurance = IInsurance(ctrl.insurance());\n        emit LogNewDependencies(address(ctrl), address(lg), address(buoy), address(insurance));\n    }\n\n    /// @notice Some tokens might have fees associated with them (e.g. USDT)\n    /// @param index Index (of system tokens) that could have fees\n    function setFeeToken(uint256 index) external onlyOwner {\n        address token = ctrl.stablecoins()[index];\n        require(token != address(0), \"setFeeToken: !invalid token\");\n        feeToken[index] = true;\n        emit LogNewFeeToken(token, index);\n    }\n\n    /// @notice Entry when depositing for pwrd\n    /// @param inAmounts Amount of each stablecoin deposited\n    /// @param minAmount Minimum ammount to expect in return for deposit\n    /// @param _referral Referral address (only useful for first deposit)\n    function depositPwrd(\n        uint256[N_COINS] memory inAmounts,\n        uint256 minAmount,\n        address _referral\n    ) external override whenNotPaused {\n        depositGToken(inAmounts, minAmount, _referral, true);\n    }\n\n    /// @notice Entry when depositing for gvt\n    /// @param inAmounts Amount of each stablecoin deposited\n    /// @param minAmount Minimum ammount to expect in return for deposit\n    /// @param _referral Referral address (only useful for first deposit)\n    function depositGvt(\n        uint256[N_COINS] memory inAmounts,\n        uint256 minAmount,\n        address _referral\n    ) external override whenNotPaused {\n        depositGToken(inAmounts, minAmount, _referral, false);\n    }\n\n    /// @notice Deposit logic\n    /// @param inAmounts Amount of each stablecoin deposited\n    /// @param minAmount Minimum amount to expect in return for deposit\n    /// @param _referral Referral address (only useful for first deposit)\n    /// @param pwrd Pwrd or gvt (pwrd/gvt)\n    function depositGToken(\n        uint256[N_COINS] memory inAmounts,\n        uint256 minAmount,\n        address _referral,\n        bool pwrd\n    ) private {\n        ctrl.eoaOnly(msg.sender);\n        require(minAmount > 0, \"minAmount is 0\");\n        require(buoy.safetyCheck(), \"!safetyCheck\");\n        ctrl.addReferral(msg.sender, _referral);\n\n        uint256 roughUsd = roughUsd(inAmounts);\n        uint256 dollarAmount = _deposit(pwrd, roughUsd, minAmount, inAmounts);\n        ctrl.mintGToken(pwrd, msg.sender, dollarAmount);\n        // Update underlying assets held in pwrd/gvt\n        emit LogNewDeposit(msg.sender, ctrl.referrals(msg.sender), pwrd, dollarAmount, inAmounts);\n    }\n\n    /// @notice Determine the size of the deposit, and route it accordingly:\n    ///     sardine (small) - gets sent directly to the vault adapter\n    ///     tuna (middle) - tokens get routed through lifeguard and exchanged to\n    ///             target token (based on current vault exposure)\n    ///     whale (large) - tokens get deposited into lifeguard Curve pool, withdraw\n    ///             into target amounts and deposited across all vaults\n    /// @param roughUsd Estimated USD value of deposit, used to determine size\n    /// @param minAmount Minimum amount to return (in Curve LP tokens)\n    /// @param inAmounts Input token amounts\n    function _deposit(\n        bool pwrd,\n        uint256 roughUsd,\n        uint256 minAmount,\n        uint256[N_COINS] memory inAmounts\n    ) private returns (uint256 dollarAmount) {\n        // If a large fish, transfer assets to lifeguard before determening what to do with them\n        if (ctrl.isValidBigFish(pwrd, true, roughUsd)) {\n            for (uint256 i = 0; i < N_COINS; i++) {\n                // Transfer token to target (lifeguard)\n                if (inAmounts[i] > 0) {\n                    IERC20 token = IERC20(getToken(i));\n                    if (feeToken[i]) {\n                        // Separate logic for USDT\n                        uint256 current = token.balanceOf(address(lg));\n                        token.safeTransferFrom(msg.sender, address(lg), inAmounts[i]);\n                        inAmounts[i] = token.balanceOf(address(lg)).sub(current);\n                    } else {\n                        token.safeTransferFrom(msg.sender, address(lg), inAmounts[i]);\n                    }\n                }\n            }\n            dollarAmount = _invest(inAmounts, roughUsd);\n        } else {\n            // If sardine, send the assets directly to the vault adapter\n            for (uint256 i = 0; i < N_COINS; i++) {\n                if (inAmounts[i] > 0) {\n                    // Transfer token to vaultadaptor\n                    IERC20 token = IERC20(getToken(i));\n                    address _vault = getVault(i);\n                    if (feeToken[i]) {\n                        // Seperate logic for USDT\n                        uint256 current = token.balanceOf(_vault);\n                        token.safeTransferFrom(msg.sender, _vault, inAmounts[i]);\n                        inAmounts[i] = token.balanceOf(_vault).sub(current);\n                    } else {\n                        token.safeTransferFrom(msg.sender, _vault, inAmounts[i]);\n                    }\n                }\n            }\n            // Establish USD vault of deposit\n            dollarAmount = buoy.stableToUsd(inAmounts, true);\n        }\n        require(dollarAmount >= buoy.lpToUsd(minAmount), \"!minAmount\");\n    }\n\n    /// @notice Determine how to handle the deposit - get stored vault deltas and indexes,\n    ///     and determine if the deposit will be a tuna (deposits into least exposed vaults)\n    ///        or a whale (spread across all three vaults)\n    ///     Tuna - Deposit swaps all overexposed assets into least exposed asset before investing,\n    ///         deposited assets into the two least exposed vaults\n    ///     Whale - Deposits all assets into the lifeguard Curve pool, and withdraws\n    ///         them in target allocation (insurance underlyingTokensPercents) amounts before\n    ///        investing them into all vaults\n    /// @param _inAmounts Input token amounts\n    /// @param roughUsd Estimated rough USD value of deposit\n    function _invest(uint256[N_COINS] memory _inAmounts, uint256 roughUsd) internal returns (uint256 dollarAmount) {\n        // Calculate asset distribution - for large deposits, we will want to spread the\n        // assets across all stablecoin vaults to avoid overexposure, otherwise we only\n        // ensure that the deposit doesn't target the most overexposed vault\n        (, uint256[N_COINS] memory vaultIndexes, uint256 _vaults) = insurance.getVaultDeltaForDeposit(roughUsd);\n        if (_vaults < N_COINS) {\n            dollarAmount = lg.investSingle(_inAmounts, vaultIndexes[0], vaultIndexes[1]);\n        } else {\n            uint256 outAmount = lg.deposit();\n            uint256[N_COINS] memory delta = insurance.calculateDepositDeltasOnAllVaults();\n            dollarAmount = lg.invest(outAmount, delta);\n        }\n    }\n\n    /// @notice Give a USD estimate of the deposit - this is purely used to determine deposit size\n    ///     and does not impact amount of tokens minted\n    /// @param inAmounts Amount of tokens deposited\n    function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) {\n        for (uint256 i; i < N_COINS; i++) {\n            if (inAmounts[i] > 0) {\n                usdAmount = usdAmount.add(inAmounts[i].mul(10**18).div(getDecimal(i)));\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20MinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n *\n * ################### GERC20 additions to IERC20 ###################\n *      _burn: Added paramater - burnAmount added to take rebased amount into account,\n *          affects the Transfer event\n *      _mint: Added paramater - mintAmount added to take rebased amount into account,\n *          affects the Transfer event\n *      _transfer: Added paramater - transferAmount added to take rebased amount into account,\n *          affects the Transfer event\n *      _decreaseApproved: Added function - internal function to allowed override of transferFrom\n *\n */\nabstract contract GERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupplyBase() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOfBase(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *      GERC20 addition - transferAmount added to take rebased amount into account\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 transferAmount,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, transferAmount);\n\n        _balances[sender] = _balances[sender].sub(transferAmount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(transferAmount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *      GERC20 addition - mintAmount added to take rebased amount into account\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(\n        address account,\n        uint256 mintAmount,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, mintAmount);\n\n        _totalSupply = _totalSupply.add(mintAmount);\n        _balances[account] = _balances[account].add(mintAmount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *      GERC20 addition - burnAmount added to take rebased amount into account\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(\n        address account,\n        uint256 burnAmount,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), burnAmount);\n\n        _balances[account] = _balances[account].sub(burnAmount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(burnAmount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _decreaseApproved(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = _allowances[owner][spender].sub(amount);\n        emit Approval(owner, spender, _allowances[owner][spender]);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n",
        "CodeNames": [
            "GToken.sol",
            "Controller.sol",
            "DepositHandler.sol",
            "GERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "ctrl.mintGToken(pwrd, msg.sender,",
                    "dollarAmount =",
                    "getInitialBase() =",
                    "factor",
                    "depositGToken",
                    "totalSupplyBase().mul(BASE).div(totalAssets) =",
                    "factor()",
                    "gt.mint(account, gt.factor(), amount="
                ],
                "Type": " Early user can break minting",
                "Description": "\nThe protocol computes a factor when minting (and burning) tokens, which is the exchange rate of rebase to base tokens (base supply / total assets value), see GToken.factor().\nThe first user can manipulate this factor such that it always returns 0.\n\nExample:\nAttacker deposits 100.0 DAI and mints 100 * 1e18 PWRD: DepositHandler.depositGToken with dollarAmount = 100.0 = 100 * 1e18, then ctrl.mintGToken(pwrd, msg.sender, 1e18)\ncalls gt.mint(account, gt.factor(), amount=1e18) where gt.factor() returns getInitialBase() = 1e18 because the person is the first minter and it mints amount * factor / _BASE = 1e18\nThe ctrl.mintGToken call also increases total assets: pnl.increaseGTokenLastAmount(...)\nThe attacker now burns (withdraws) all minted tokens again except a single wei using one of the withdrawal functions in WithdrawHandler. Because of the withdrawal fee the total assets are only decreased by the post-fee amount (IPnL(pnl).decreaseGTokenLastAmount(pwrd, amount=userBalance 1, bonus=fee);), i.e., with a 2% withdrawal fee the total assets stay at 2% of 100$ = 2 * 1e18.\nThe result is that GToken.factor() always returns totalSupplyBase().mul(BASE).div(totalAssets) = 1 * 1e18 / (2 * 1e18) = 0\n\nThe resulting factor is 0 and thus any user-deposits by depositGToken will mint 0 base tokens to the depositor.\nThis means all deposits and future value accrues to the attacker who holds the only base tokens.\n\nAn attacker could even front-run the first minter to steal their deposit this way.\n\nUniswap solves a similar problem by sending the first 1000 tokens to the zero address which makes the attack 1000x more expensive. The same should work here, i.e., on first mint (total base supply == 0), lock some of the first minter's tokens by minting ~1% of the initial amount to the zero address instead of to the first minter.\n\nkristian-gro (Gro) acknowledged but disagreed with severity(https://github.com/code-423n4/2021-06-gro-findings/issues/107#issuecomment-879991211):\n  Known issue which will be handled by ops low risk as gro protocol is the first depositor\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-06-gro-findings/issues/107#issuecomment-886829344):\n  Even though it's a known issue its consequences are significant. Only because it can be mitigated by ops quite easily, I'll degrade it to medium level.\n\n\n",
                "Repair": ""
            }
        ]
    }
]