[
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the tokens of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsGuild is\n    IForgottenRunesWarriorsGuild,\n    Ownable,\n    ReentrancyGuard,\n    ERC721\n{\n    using Strings for uint256;\n\n    /// @notice The maximum number of Warriors\n    uint256 public constant MAX_WARRIORS = 16000;\n\n    /// @notice Counter to track the number minted so far\n    uint256 public numMinted = 0;\n\n    /// @notice Address of the minter\n    address public minter;\n\n    /// @notice The base URI for the metadata of the tokens\n    string public baseTokenURI;\n\n    string public constant R =\n        \"Old men forget: yet all shall be forgot, But he'll remember with advantages What feats he did that day: then shall our names Familiar in his mouth as household words. This story shall the good man teach his son From this day to the ending of the world\";\n\n    /// @notice The provenance hash\n    string public METADATA_PROVENANCE_HASH = '';\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param baseURI string the initial base URI for the token metadata URL\n     */\n    constructor(string memory baseURI)\n        ERC721('ForgottenRunesWarriorsGuild', 'WARRIORS')\n    {\n        setBaseURI(baseURI);\n    }\n\n    /**\n     * @dev Convenient way to initialize the contract\n     * @param newMinter address of the minter contract\n     */\n    function initialize(address newMinter) public onlyOwner {\n        setMinter(newMinter);\n    }\n\n    /**\n     * @dev Returns the URL of a given tokenId\n     * @param tokenId uint256 ID of the token to be minted\n     * @return string the URL of a given tokenId\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            'ERC721Metadata: URI query for nonexistent token'\n        );\n\n        return string(abi.encodePacked(baseTokenURI, tokenId.toString()));\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    /**\n     * @dev Returns if the token exists\n     * @param tokenId uint256 the id of the token\n     * @return exists bool if it exists\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /**\n     * @dev Mint the next token\n     * @param recipient address representing the owner of the new tokenId\n     * @return tokenId uint256 the new tokenId\n     */\n    function mint(address recipient)\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');\n        require(_msgSender() == minter, 'Not a minter');\n        uint256 tokenId = numMinted;\n        _safeMint(recipient, tokenId);\n        numMinted += 1;\n        return tokenId;\n    }\n\n    /**\n     * @notice I wouldn't if I were you\n     * @dev Burns the token\n     * @param tokenId uint256 representing the tokenId\n     */\n    function burn(uint256 tokenId) public virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721Burnable: caller is not owner nor approved'\n        );\n        _burn(tokenId);\n    }\n\n    /**\n     * Only the owner can do these things\n     */\n\n    /**\n     * @dev Sets a new base URI\n     * @param newBaseURI string the new token base URI\n     */\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseTokenURI = newBaseURI;\n    }\n\n    /**\n     * @dev Sets a new primary minter address\n     * @param newMinter address of the new minter\n     */\n    function setMinter(address newMinter) public onlyOwner {\n        minter = newMinter;\n    }\n\n    /**\n     * @dev Sets provenance hash\n     * @param newHash string of the new minter\n     */\n    function setProvenanceHash(string memory newHash) public onlyOwner {\n        METADATA_PROVENANCE_HASH = newHash;\n    }\n\n    /**\n     * @dev Adds calldata on chain for the images. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadImage(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev Adds calldata on chain for the attributes. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadAttributes(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev ETH should not be sent to this contract, but in the case that it is\n     * sent by accident, this function allows the owner to withdraw it.\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(payable(msg.sender).send(address(this).balance));\n    }\n\n    /**\n     * @dev Again, ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ForgottenRunesWarriorsGuild.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\n    function withdrawAll() public payable onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(address(this).balance));\n    }\n"
                ],
                "Type": " Contract may not have enough fund to cover refund",
                "Description": "\nOwner of the contract can call withdrawAll before the refund process is done to send all ETH to the vault. Since there are no payable receive function in ForgottenRunesWarriorsMinter, the owner won't be able to replenish the contract for the refund process.\n\n\nForgottenRunesWarriorsMinter.sol#L616-L619(https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L616-L619)<br\n\nsolidity\n    function withdrawAll() public payable onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(address(this).balance));\n    }\n\n\n",
                "Repair": "\nOnly allow owner to call withdrawAll after refund period.\n\ncryppadotta (Forgotten Runes) confirmed and commented(https://github.com/code-423n4/2022-05-runes-findings/issues/187#issuecomment-1119768097):\n  This is a great point. It would be annoying to accidentally do this and have to make a new contract for refunds.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-05-runes-findings/issues/187#issuecomment-1159518087):\n  Sponsor confirmed, submitted by contest judge.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: ForgottenRunesWarriorsGuild.sol\n52:     function initialize(address newMinter) public onlyOwner { \n53:         setMinter(newMinter);\n54:     }\n...\n137:     function setMinter(address newMinter) public onlyOwner {\n138:         minter = newMinter;\n139:     }\n"
                ],
                "Type": " Unnecessary  initialize()  function",
                "Description": "\nThe initialize() function isn't an initializer. It just calls setMinter(), which has the same visibility and authorization level as initialize():\n\nsolidity\nFile: ForgottenRunesWarriorsGuild.sol\n52:     function initialize(address newMinter) public onlyOwner { \n53:         setMinter(newMinter);\n54:     }\n...\n137:     function setMinter(address newMinter) public onlyOwner {\n138:         minter = newMinter;\n139:     }\n\n\nIt could even be called repeatedly.\n\nAs the initialize() function is not needed, I suggest deleting it and directly calling setMinter() to \"Conveniently initialize the contract\".\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\ncontracts/ForgottenRunesWarriorsGuild.sol:\n  173      function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n  174:         require(address(msg.sender) != address(0)); //@audit gas: there's the onlyOwner modifier: msg.sender can't be address(0)\n  175          token.transfer(msg.sender, amount);\n  176      }\n\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  627      function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n  628:         require(address(msg.sender) != address(0)); //@audit gas: there's the onlyOwner modifier: msg.sender can't be address(0)\n  629          token.transfer(msg.sender, amount);\n  630      }\n"
                ],
                "Type": "  ForgottenRunesWarriorsGuild.forwardERC20s()  and  ForgottenRunesWarriorsMinter.forwardERC20s() : Unnecessary require statements",
                "Description": "\nHere, as the onlyOwner modifier is applied, the address(0) checks are not needed here:\n\nsolidity\ncontracts/ForgottenRunesWarriorsGuild.sol:\n  173      function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n  174:         require(address(msg.sender) != address(0)); //@audit gas: there's the onlyOwner modifier: msg.sender can't be address(0)\n  175          token.transfer(msg.sender, amount);\n  176      }\n\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  627      function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n  628:         require(address(msg.sender) != address(0)); //@audit gas: there's the onlyOwner modifier: msg.sender can't be address(0)\n  629          token.transfer(msg.sender, amount);\n  630      }\n\n\nI suggest removing these checks.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-09",
                "Location": [
                    "//solidity\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  140          require(\n  141:             numWarriors  0 && numWarriors <= 20,\n  142              'You can summon no more than 20 Warriors at a time'\n  143          );\n\n  210          require(\n  211:             numWarriors  0 && numWarriors <= 20,\n  212              'You can summon no more than 20 Warriors at a time'\n  213          );\n"
                ],
                "Type": " Splitting  require()  statements that use  &&  saves gas",
                "Description": "\nIf you're using the Optimizer at 200, instead of using the && operator in a single require statement to check multiple conditions, I suggest using multiple require statements with 1 condition per require statement:\n\nsolidity\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  140          require(\n  141:             numWarriors  0 && numWarriors <= 20,\n  142              'You can summon no more than 20 Warriors at a time'\n  143          );\n\n  210          require(\n  211:             numWarriors  0 && numWarriors <= 20,\n  212              'You can summon no more than 20 Warriors at a time'\n  213          );\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-11",
                "Location": [
                    "//solidity\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\nForgottenRunesWarriorsMinter.sol:355:        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n",
                    "//solidity\nfor (uint256 i; i < numIterations; i++) {  \n // ...  \n}  \n",
                    "//solidity\nfor (uint256 i; i < numIterations;) {  \n // ...  \n unchecked { ++i; }  \n}  \n"
                ],
                "Type": " Increments can be unchecked",
                "Description": "\nIn Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\nethereum/solidity#10695(https://github.com/ethereum/solidity/issues/10695)\n\nInstances include:\n\nsolidity\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\nForgottenRunesWarriorsMinter.sol:355:        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n\n\nThe code would go from:\n\nsolidity\nfor (uint256 i; i < numIterations; i++) {  \n // ...  \n}  \n\n\nto:\n\nsolidity\nfor (uint256 i; i < numIterations;) {  \n // ...  \n unchecked { ++i; }  \n}  \n\n\nThe risk of overflow is inexistant for a uint256 here.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-15",
                "Location": [
                    "//solidity\nfunction _msgSender() internal view virtual returns (address payable) {\n  return msg.sender;\n}\n",
                    "//solidity\nForgottenRunesWarriorsGuild.sol:101:        require(_msgSender() == minter, 'Not a minter');\nForgottenRunesWarriorsGuild.sol:115:            _isApprovedOrOwner(_msgSender(), tokenId),\n",
                    "//solidity\nForgottenRunesWarriorsGuild.sol:164:        require(payable(msg.sender).send(address(this).balance));\nForgottenRunesWarriorsGuild.sol:174:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsGuild.sol:175:        token.transfer(msg.sender, amount);\nForgottenRunesWarriorsMinter.sol:113:        setVaultAddress(msg.sender);\nForgottenRunesWarriorsMinter.sol:151:        daMinters.push(msg.sender);\nForgottenRunesWarriorsMinter.sol:152:        daAmountPaid[msg.sender] += msg.value;\nForgottenRunesWarriorsMinter.sol:153:        daNumMinted[msg.sender] += numWarriors;\nForgottenRunesWarriorsMinter.sol:163:            _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:183:        mintlistMinted[msg.sender] = true;\nForgottenRunesWarriorsMinter.sol:186:        bytes32 node = keccak256(abi.encodePacked(msg.sender));\nForgottenRunesWarriorsMinter.sol:194:        _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:221:            _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\nForgottenRunesWarriorsMinter.sol:239:        claimlistMinted[msg.sender] = true;\nForgottenRunesWarriorsMinter.sol:242:        bytes32 node = keccak256(abi.encodePacked(msg.sender));\nForgottenRunesWarriorsMinter.sol:249:        _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:373:        _refundAddress(msg.sender);\nForgottenRunesWarriorsMinter.sol:628:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsMinter.sol:629:        token.transfer(msg.sender, amount);\n"
                ],
                "Type": " Use  msg.sender  instead of OpenZeppelin's  _msgSender()  when meta-transactions capabilities aren't used",
                "Description": "\nmsg.sender costs 2 gas (CALLER opcode).\n_msgSender() represents the following:\n\nsolidity\nfunction _msgSender() internal view virtual returns (address payable) {\n  return msg.sender;\n}\n\n\nWhen no meta-transactions capabilities are used: msg.sender is enough.\n\nSee <https://docs.openzeppelin.com/contracts/2.x/gsn for more information about GSN capabilities.\n\nConsider replacing _msgSender() with msg.sender here:\n\nsolidity\nForgottenRunesWarriorsGuild.sol:101:        require(_msgSender() == minter, 'Not a minter');\nForgottenRunesWarriorsGuild.sol:115:            _isApprovedOrOwner(_msgSender(), tokenId),\n\n\nIn the solution, msg.sender is used everywhere else:\n\nsolidity\nForgottenRunesWarriorsGuild.sol:164:        require(payable(msg.sender).send(address(this).balance));\nForgottenRunesWarriorsGuild.sol:174:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsGuild.sol:175:        token.transfer(msg.sender, amount);\nForgottenRunesWarriorsMinter.sol:113:        setVaultAddress(msg.sender);\nForgottenRunesWarriorsMinter.sol:151:        daMinters.push(msg.sender);\nForgottenRunesWarriorsMinter.sol:152:        daAmountPaid[msg.sender] += msg.value;\nForgottenRunesWarriorsMinter.sol:153:        daNumMinted[msg.sender] += numWarriors;\nForgottenRunesWarriorsMinter.sol:163:            _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:183:        mintlistMinted[msg.sender] = true;\nForgottenRunesWarriorsMinter.sol:186:        bytes32 node = keccak256(abi.encodePacked(msg.sender));\nForgottenRunesWarriorsMinter.sol:194:        _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:221:            _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\nForgottenRunesWarriorsMinter.sol:239:        claimlistMinted[msg.sender] = true;\nForgottenRunesWarriorsMinter.sol:242:        bytes32 node = keccak256(abi.encodePacked(msg.sender));\nForgottenRunesWarriorsMinter.sol:249:        _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:373:        _refundAddress(msg.sender);\nForgottenRunesWarriorsMinter.sol:628:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsMinter.sol:629:        token.transfer(msg.sender, amount);\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the minter of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsMinter is Ownable, Pausable, ReentrancyGuard {\n    /// @notice The start timestamp for the Dutch Auction (DA) sale and price\n    uint256 public daStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for mintlisters\n    /// @dev This is the end of DA phase. No more DA bids when this is hit\n    uint256 public mintlistStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the public sale\n    uint256 public publicStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the claims\n    uint256 public claimsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for self refunds\n    uint256 public selfRefundsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The main Merkle root\n    bytes32 public mintlist1MerkleRoot;\n\n    /// @notice The secondary Merkle root\n    /// @dev Having a backup merkle root lets us atomically update the merkletree without downtime on the frontend\n    bytes32 public mintlist2MerkleRoot;\n\n    /// @notice The claimslist Merkle root\n    bytes32 public claimlistMerkleRoot;\n\n    /// @notice The address of the Warriors contract\n    IForgottenRunesWarriorsGuild public warriors;\n\n    /// @notice The address of the vault\n    address public vault;\n\n    /// @notice The address of the WETH contract\n    address public weth;\n\n    /// @notice The start price of the DA\n    uint256 public startPrice = 2.5 ether;\n\n    /// @notice The lowest price of the DA\n    uint256 public lowestPrice = 0.6 ether;\n\n    /// @notice The length of time for the price curve in the DA\n    uint256 public daPriceCurveLength = 380 minutes;\n\n    /// @notice The interval of time in which the price steps down\n    uint256 public daDropInterval = 10 minutes;\n\n    /// @notice The final price of the DA. Will be updated when DA is over and then used for subsequent phases\n    uint256 public finalPrice = 2.5 ether;\n\n    /// @notice An array of the addresses of the DA minters\n    /// @dev An entry is created for every da minting tx, so the same minter address is quite likely to appear more than once\n    address[] public daMinters;\n\n    /// @notice Tracks the total amount paid by a given address in the DA\n    mapping(address => uint256) public daAmountPaid;\n\n    /// @notice Tracks the total amount refunded to a given address for the DA\n    mapping(address => uint256) public daAmountRefunded;\n\n    /// @notice Tracks the total count of NFTs minted by a given address in the DA\n    mapping(address => uint256) public daNumMinted;\n\n    /// @notice Tracks if a given address minted in the mintlist\n    mapping(address => bool) public mintlistMinted;\n\n    /// @notice Tracks the total count of NFTs claimed by a given address\n    mapping(address => bool) public claimlistMinted;\n\n    /// @notice The total number of tokens reserved for the DA phase\n    uint256 public maxDaSupply = 8000;\n\n    /// @notice Tracks the total count of NFTs sold (vs. freebies)\n    uint256 public numSold;\n\n    /// @notice Tracks the total count of NFTs for sale\n    uint256 public maxForSale = 14190;\n\n    /// @notice Tracks the total count of NFTs claimed for free\n    uint256 public numClaimed;\n\n    /// @notice Tracks the total count of NFTs that can be claimed\n    /// @dev While we will have a merkle root set for this group, putting a hard cap helps limit the damage of any problems with an overly-generous merkle tree\n    uint256 public maxForClaim = 1100;\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param _warriors address the initial warriors contract address\n     */\n    constructor(IForgottenRunesWarriorsGuild _warriors, address _weth) {\n        setWarriorsAddress(_warriors);\n        setWethAddress(_weth);\n        setVaultAddress(msg.sender);\n    }\n\n    /*\n     * Timeline:\n     *\n     * bidSummon       : |------------|\n     * mintlistSummon  :              |------------|-------------------------------------|\n     * publicSummon    :                           |------------|------------------------|\n     * claimSummon     :                                        |------------|-----------|\n     * teamSummon      : |---------------------------------------------------------------|\n     */\n\n    /**\n     * @notice Mint a Warrior in the Dutch Auction phase\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function bidSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxDaSupply, 'Auction sold out');\n        require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\n        require(daStarted(), 'Auction not started');\n        require(!mintlistStarted(), 'Auction phase over');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n\n        uint256 currentPrice = currentDaPrice();\n        require(\n            msg.value >= (currentPrice * numWarriors),\n            'Ether value sent is not sufficient'\n        );\n\n        daMinters.push(msg.sender);\n        daAmountPaid[msg.sender] += msg.value;\n        daNumMinted[msg.sender] += numWarriors;\n        numSold += numWarriors;\n\n        if (numSold == maxDaSupply) {\n            // optimistic: save gas by not setting on every mint, but will\n            // require manual `setFinalPrice` before refunds if da falls short\n            finalPrice = currentPrice;\n        }\n\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @notice Mint a Warrior in the mintlist phase (paid)\n     * @param _merkleProof bytes32[] your proof of being able to mint\n     */\n    function mintlistSummon(bytes32[] calldata _merkleProof)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(mintlistStarted(), 'Mintlist phase not started');\n        require(msg.value == finalPrice, 'Ether value incorrect');\n\n        // verify didn't already mint\n        require(mintlistMinted[msg.sender] == false, 'Already minted');\n        mintlistMinted[msg.sender] = true;\n\n        // verify mintlist merkle\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, mintlist1MerkleRoot, node) ||\n                MerkleProof.verify(_merkleProof, mintlist2MerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numSold += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior in the Public phase (paid)\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function publicSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\n        require(publicStarted(), 'Public sale not started');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n        require(\n            msg.value == (finalPrice * numWarriors),\n            'Ether value sent is incorrect'\n        );\n\n        numSold += numWarriors;\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @dev claim a warrior for free if you're in the claimlist\n     * @param _merkleProof bytes32[] the proof that you're eligible to mint here\n     */\n    function claimSummon(bytes32[] calldata _merkleProof)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        require(numClaimed < maxForClaim, 'No more claims');\n        require(claimsStarted(), 'Claim phase not started');\n\n        // verify didn't already claim\n        require(claimlistMinted[msg.sender] == false, 'Already claimed');\n        claimlistMinted[msg.sender] = true;\n\n        // verify claimlist\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, claimlistMerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numClaimed += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior (owner only)\n     * @param recipient address the address of the recipient\n     * @param count uint256 of the number of warriors you're trying to mint\n     */\n    function teamSummon(address recipient, uint256 count) external onlyOwner {\n        require(address(recipient) != address(0), 'address req');\n        for (uint256 i = 0; i < count; i++) {\n            _mint(recipient);\n        }\n    }\n\n    function _mint(address recipient) private {\n        warriors.mint(recipient);\n    }\n\n    /*\n     * View utilities\n     */\n\n    /**\n     * @notice returns the current dutch auction price\n     */\n    function currentDaPrice() public view returns (uint256) {\n        if (!daStarted()) {\n            return startPrice;\n        }\n        if (block.timestamp >= daStartTime + daPriceCurveLength) {\n            // end of the curve\n            return lowestPrice;\n        }\n\n        uint256 dropPerStep = (startPrice - lowestPrice) /\n            (daPriceCurveLength / daDropInterval);\n\n        uint256 elapsed = block.timestamp - daStartTime;\n        uint256 steps = elapsed / daDropInterval;\n        uint256 stepDeduction = steps * dropPerStep;\n\n        // don't go negative in the next step\n        if (stepDeduction > startPrice) {\n            return lowestPrice;\n        }\n        uint256 currentPrice = startPrice - stepDeduction;\n        return currentPrice > lowestPrice ? currentPrice : lowestPrice;\n    }\n\n    /**\n     * @notice returns whether the dutch auction has started\n     */\n    function daStarted() public view returns (bool) {\n        return block.timestamp > daStartTime;\n    }\n\n    /**\n     * @notice returns whether the mintlist has started\n     */\n    function mintlistStarted() public view returns (bool) {\n        return block.timestamp > mintlistStartTime;\n    }\n\n    /**\n     * @notice returns whether the public mint has started\n     */\n    function publicStarted() public view returns (bool) {\n        return block.timestamp > publicStartTime;\n    }\n\n    /**\n     * @notice returns whether the claims phase has started\n     */\n    function claimsStarted() public view returns (bool) {\n        return block.timestamp > claimsStartTime;\n    }\n\n    /**\n     * @notice returns whether self refunds phase has started\n     */\n    function selfRefundsStarted() public view returns (bool) {\n        return block.timestamp > selfRefundsStartTime;\n    }\n\n    /**\n     * @notice returns the number of minter addresses in the DA phase (includes duplicates)\n     */\n    function numDaMinters() public view returns (uint256) {\n        return daMinters.length;\n    }\n\n    /*\n     * Refund logic\n     */\n\n    /**\n     * @notice issues refunds for the accounts in minters between startIdx and endIdx inclusive\n     * @param startIdx uint256 the starting index of daMinters\n     * @param endIdx uint256 the ending index of daMinters, inclusive\n     */\n    function issueRefunds(uint256 startIdx, uint256 endIdx)\n        public\n        onlyOwner\n        nonReentrant\n    {\n        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n            _refundAddress(daMinters[i]);\n        }\n    }\n\n    /**\n     * @notice issues a refund for the address\n     * @param minter address the address to refund\n     */\n    function refundAddress(address minter) public onlyOwner nonReentrant {\n        _refundAddress(minter);\n    }\n\n    /**\n     * @notice refunds msg.sender what they're owed\n     */\n    function selfRefund() public nonReentrant {\n        require(selfRefundsStarted(), 'Self refund period not started');\n        _refundAddress(msg.sender);\n    }\n\n    function _refundAddress(address minter) private {\n        uint256 owed = refundOwed(minter);\n        if (owed > 0) {\n            daAmountRefunded[minter] += owed;\n            _safeTransferETHWithFallback(minter, owed);\n        }\n    }\n\n    /**\n     * @notice returns the amount owed the address\n     * @param minter address the address of the account that wants a refund\n     */\n    function refundOwed(address minter) public view returns (uint256) {\n        uint256 totalCostOfMints = finalPrice * daNumMinted[minter];\n        uint256 refundsPaidAlready = daAmountRefunded[minter];\n        return daAmountPaid[minter] - totalCostOfMints - refundsPaidAlready;\n    }\n\n    /**\n     * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.\n     * @param to account who to send the ETH or WETH to\n     * @param amount uint256 how much ETH or WETH to send\n     */\n    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n        if (!_safeTransferETH(to, amount)) {\n            IWETH(weth).deposit{value: amount}();\n            IERC20(weth).transfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer ETH and return the success status.\n     * @dev This function only forwards 30,000 gas to the callee.\n     * @param to account who to send the ETH to\n     * @param value uint256 how much ETH to send\n     */\n    function _safeTransferETH(address to, uint256 value)\n        internal\n        returns (bool)\n    {\n        (bool success, ) = to.call{value: value, gas: 30_000}(new bytes(0));\n        return success;\n    }\n\n    /*\n     * Only the owner can do these things\n     */\n\n    /**\n     * @notice pause the contract\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice unpause the contract\n     */\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice set the dutch auction start timestamp\n     */\n    function setDaStartTime(uint256 _newTime) public onlyOwner {\n        daStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the mintlist start timestamp\n     */\n    function setMintlistStartTime(uint256 _newTime) public onlyOwner {\n        mintlistStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the public sale start timestamp\n     */\n    function setPublicStartTime(uint256 _newTime) public onlyOwner {\n        publicStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the claims phase start timestamp\n     */\n    function setClaimsStartTime(uint256 _newTime) public onlyOwner {\n        claimsStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the self refund phase start timestamp\n     */\n    function setSelfRefundsStartTime(uint256 _newTime) public onlyOwner {\n        selfRefundsStartTime = _newTime;\n    }\n\n    /**\n     * @notice A convenient way to set all phase times at once\n     * @param newDaStartTime uint256 the dutch auction start time\n     * @param newMintlistStartTime uint256 the mintlst phase start time\n     * @param newPublicStartTime uint256 the public phase start time\n     * @param newClaimsStartTime uint256 the claims phase start time\n     */\n    function setPhaseTimes(\n        uint256 newDaStartTime,\n        uint256 newMintlistStartTime,\n        uint256 newPublicStartTime,\n        uint256 newClaimsStartTime\n    ) public onlyOwner {\n        // we put these checks here instead of in the setters themselves\n        // because they're just guardrails of the typical case\n        require(\n            newPublicStartTime >= newMintlistStartTime,\n            'Set public after mintlist'\n        );\n        require(\n            newClaimsStartTime >= newPublicStartTime,\n            'Set claims after public'\n        );\n        setDaStartTime(newDaStartTime);\n        setMintlistStartTime(newMintlistStartTime);\n        setPublicStartTime(newPublicStartTime);\n        setClaimsStartTime(newClaimsStartTime);\n    }\n\n    /**\n     * @notice set the merkle root for the mintlist phase\n     */\n    function setMintlist1MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist1MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the alternate merkle root for the mintlist phase\n     * @dev we have two because it lets us idempotently update the website without downtime\n     */\n    function setMintlist2MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist2MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the merkle root for the claimslist phase\n     */\n    function setClaimlistMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        claimlistMerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the vault address where the funds are withdrawn\n     */\n    function setVaultAddress(address _newVaultAddress) public onlyOwner {\n        vault = _newVaultAddress;\n    }\n\n    /**\n     * @notice set the warriors token address\n     */\n    function setWarriorsAddress(\n        IForgottenRunesWarriorsGuild _newWarriorsAddress\n    ) public onlyOwner {\n        warriors = _newWarriorsAddress;\n    }\n\n    /**\n     * @notice set the weth token address\n     */\n    function setWethAddress(address _newWethAddress) public onlyOwner {\n        weth = _newWethAddress;\n    }\n\n    /**\n     * @notice set the dutch auction start price\n     */\n    function setStartPrice(uint256 _newPrice) public onlyOwner {\n        startPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the dutch auction lowest price\n     */\n    function setLowestPrice(uint256 _newPrice) public onlyOwner {\n        lowestPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the length of time the dutch auction price should change\n     */\n    function setDaPriceCurveLength(uint256 _newTime) public onlyOwner {\n        daPriceCurveLength = _newTime;\n    }\n\n    /**\n     * @notice set how long it takes for the dutch auction to step down in price\n     */\n    function setDaDropInterval(uint256 _newTime) public onlyOwner {\n        daDropInterval = _newTime;\n    }\n\n    /**\n     * @notice set \"final\" price of the dutch auction\n     * @dev this is set automatically if the dutch-auction sells out, but needs to be set manually if the DA fails to sell out\n     */\n    function setFinalPrice(uint256 _newPrice) public onlyOwner {\n        finalPrice = _newPrice;\n    }\n\n    /**\n     * @notice the max supply available in the dutch auction\n     */\n    function setMaxDaSupply(uint256 _newSupply) public onlyOwner {\n        maxDaSupply = _newSupply;\n    }\n\n    /**\n     * @notice the total max supply available for sale in any phase\n     */\n    function setMaxForSale(uint256 _newSupply) public onlyOwner {\n        maxForSale = _newSupply;\n    }\n\n    /**\n     * @notice the max supply available in the claimlist\n     */\n    function setMaxForClaim(uint256 _newSupply) public onlyOwner {\n        maxForClaim = _newSupply;\n    }\n\n    /**\n     * @notice Withdraw funds to the vault\n     * @param _amount uint256 the amount to withdraw\n     */\n    function withdraw(uint256 _amount) public onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(_amount));\n    }\n\n    /**\n     * @notice Withdraw all funds to the vault\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(address(this).balance));\n    }\n\n    /**\n     * @dev ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ForgottenRunesWarriorsMinter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "javascript\nuint256 dropPerStep = (startPrice lowestPrice) / (daPriceCurveLength / daDropInterval);\n\nuint256 elapsed = block.timestamp daStartTime;\nuint256 steps = elapsed / daDropInterval;\nuint256 stepDeduction = steps * dropPerStep;\n\n// don't go negative in the next step\nif (stepDeduction  startPrice) {\n    return lowestPrice;\n}\nuint256 currentPrice = startPrice stepDeduction;\n"
                ],
                "Type": " Many unbounded and under-constrained variables in the system can lead to unfair price or DoS",
                "Description": "\nUnbounded and under-constrained variables.\n\n\n1.  dsStartTime | daPriceCurveLength | daDropInterval\n\nThe team can change the above variables during sale. It will either increase or decrease the price of an NFT. Or it can make currentDaPrice() revert.\n\njavascript\nuint256 dropPerStep = (startPrice lowestPrice) / (daPriceCurveLength / daDropInterval);\n\nuint256 elapsed = block.timestamp daStartTime;\nuint256 steps = elapsed / daDropInterval;\nuint256 stepDeduction = steps * dropPerStep;\n\n// don't go negative in the next step\nif (stepDeduction  startPrice) {\n    return lowestPrice;\n}\nuint256 currentPrice = startPrice stepDeduction;\n\n\nForgottenRunesWarriorsMinter.sol#L275-L297(https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L275-L297)<br\n\n2.  dsStartTime | mintlistStartTime | publicStartTime | claimsStartTime  selfRefundsStartTime\n\nThe team can change the above variables. It can result in the wrong sale phases order. For example, the public sale can end up being before every other phase due to accidentally setting it to 0.\n\n",
                "Repair": "\nPossible mitigation:\n\n1.  Bound and constrain variables.<br\nFor example, daDropInterval should be less than daPriceCurveLength<br\nAnother example: The total sum of each supply phase should not be bigger than MAX_SUPPLY in the NFT smart contract.\n\nwagmiwiz (Forgotten Runes) commented(https://github.com/code-423n4/2022-05-runes-findings/issues/27#issuecomment-1118375680):\n  This is true but is a low operational risk and can be undone.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-05-runes-findings/issues/27#issuecomment-1159534380):\n  Decided to consolidate all issues regarding missing validation of the listed variables here (M-04).\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-08",
                "Location": [
                    "//solidity\nForgottenRunesWarriorsMinter.sol:296:        return currentPrice  lowestPrice ? currentPrice : lowestPrice;\n",
                    "//solidity\nForgottenRunesWarriorsMinter.sol:296:        return currentPrice = lowestPrice ? currentPrice : lowestPrice;\n"
                ],
                "Type": "  ForgottenRunesWarriorsMinter.currentDaPrice() :  >  should be  >= ",
                "Description": "\nThe return statement is as follows:\n\nsolidity\nForgottenRunesWarriorsMinter.sol:296:        return currentPrice  lowestPrice ? currentPrice : lowestPrice;\n\n\nStrict inequalities () are more expensive than non-strict ones (=). This is due to some supplementary checks (ISZERO, 3 gas)\nFurthermore, lowestPrice is read from storage while currentPrice is read from memory.\n\nTherefore, it's possible to always save 3 gas and sometimes further save 1 SLOAD (when currentPrice == lowestPrice) by replacing the code to:\n\nsolidity\nForgottenRunesWarriorsMinter.sol:296:        return currentPrice = lowestPrice ? currentPrice : lowestPrice;\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-10",
                "Location": [
                    "//solidity\nuint i = 1;  \ni++; // == 1 but i == 2  \n",
                    "//solidity\nuint i = 1;  \n++i; // == 2 and i == 2 too, so no need for a temporary variable  \n",
                    "//solidity\nForgottenRunesWarriorsGuild.sol:104:        numMinted += 1;\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:193:        numSold += 1;\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:248:        numClaimed += 1;\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\nForgottenRunesWarriorsMinter.sol:355:        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n"
                ],
                "Type": "  ++i  costs less gas compared to  i++  or  i += 1 ",
                "Description": "\n++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.\n\ni++ increments i and returns the initial value of i. Which means:\n\nsolidity\nuint i = 1;  \ni++; // == 1 but i == 2  \n\n\nBut ++i returns the actual incremented value:\n\nsolidity\nuint i = 1;  \n++i; // == 2 and i == 2 too, so no need for a temporary variable  \n\n\nIn the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2\n\nInstances include:\n\nsolidity\nForgottenRunesWarriorsGuild.sol:104:        numMinted += 1;\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:193:        numSold += 1;\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:248:        numClaimed += 1;\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\nForgottenRunesWarriorsMinter.sol:355:        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n\n\nI suggest using ++i instead of i++ to increment the value of an uint variable.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [],
                "Type": " Use of  .send()  May Revert if The Recipient's Fallback Function Consumes More Than 2300 Gas",
                "Description": "\nForgottenRunesWarriorsMinter.sol#L610(https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L610)<br\nForgottenRunesWarriorsMinter.sol#L618(https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L618)<br\nForgottenRunesWarriorsGuild.sol#L164(https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsGuild.sol#L164)<br\n\nThe .send() function intends to transfer an ETH amount with a fixed amount of 2300 gas. This function is not equipped to handle changes in the underlying .send() and .transfer() functions which may supply different amounts of gas in the future. Additionally, if the recipient implements a fallback function containing some sort of logic, this may inevitably revert, meaning the vault and owner of the contract will never be able to call certain sensitive functions.\n\n",
                "Repair": "\nConsider using .call() instead with the checks-effects-interactions pattern implemented correctly. Careful consideration needs to be made to prevent reentrancy.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-05-runes-findings/issues/254#issuecomment-1159542053):\n  Determined the stake is high here and therefore Medium Risk.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "3",
                "Location": [
                    "\nAll Contracts\n"
                ],
                "Type": " Pragma Version",
                "Description": "\nIn the contracts, floating pragmas should not be used. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\n\nhttps://swcregistry.io/docs/SWC-103\n\n\nAll Contracts\n\n\n",
                "Repair": "Lock the pragma version: delete pragma solidity 0.8.10 in favor of pragma solidity 0.8.10.\n\n\n"
            },
            {
                "Name": "6",
                "Location": [
                    "\nyarn install\nyarn list @openzeppelin/contracts\n\n"
                ],
                "Type": " Bump OZ packages to ^4.5.0.",
                "Description": "\nLine Reference: package.json#L68(https://github.com/code-423n4/2022-05-runes/blob/main/package.json#L68)\n\n\nI can verify that the installed version is 4.2.0 by executing the following commands:\n\n\nyarn install\nyarn list @openzeppelin/contracts\n\n\n\n",
                "Repair": "\nUpdate the versions of @openzeppelin/contracts and @openzeppelin/contracts-upgradeable to be the latest in package.json. I also recommend double checking the versions of other dependencies as a precaution, as they may include important bug fixes.\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\ncontracts/ForgottenRunesWarriorsGuild.sol:\n  100:         require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');  //@audit gas: numMinted SLOAD 1 (should declare tokenId earlier and use it instead)\n  102:         uint256 tokenId = numMinted; //@audit gas: numMinted SLOAD 2 (should be declared earlier)\n  104:         numMinted += 1;  //@audit gas: numMinted SLOAD 3 (should be numMinted = tokenId + 1)\n\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  136:         require(numSold < maxDaSupply, 'Auction sold out'); //@audit gas: numSold SLOAD 1, maxDaSupply SLOAD 1\n  137:         require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining'); //@audit gas: numSold SLOAD 2, maxDaSupply SLOAD 2\n  154:         numSold += numWarriors; //@audit gas: numSold SLOAD 3 (equivalent to numSold = numSold + numWarriors)\n  156:         if (numSold == maxDaSupply) { //@audit gas: numSold SLOAD 4, maxDaSupply SLOAD 3\n  177:         require(numSold < maxForSale, 'Sold out'); //@audit gas: numSold SLOAD 1\n  193:         numSold += 1; //@audit gas: numSold SLOAD 2 (equivalent to numSold = numSold + 1)\n  207:         require(numSold < maxForSale, 'Sold out'); //@audit gas: numSold SLOAD 1, maxDaSupply SLOAD 1\n  208:         require(numSold + numWarriors <= maxForSale, 'Not enough remaining'); //@audit gas: numSold SLOAD 2, maxDaSupply SLOAD 2\n  219:         numSold += numWarriors; //@audit gas: numSold SLOAD 3 (equivalent to numSold = numSold + numWarriors)\n  234:         require(numClaimed < maxForClaim, 'No more claims'); //@audit gas: numSold SLOAD 1\n  248:         numClaimed += 1; //@audit gas: numSold SLOAD 2 (equivalent to numSold = numSold + 1)\n  279:         if (block.timestamp = daStartTime + daPriceCurveLength) {//@audit gas: daStartTime SLOAD 1, daPriceCurveLength SLOAD 1\n  284:         uint256 dropPerStep = (startPrice lowestPrice) / //@audit gas: startPrice SLOAD 1, lowestPrice SLOAD 1\n  285:             (daPriceCurveLength / daDropInterval); //@audit gas: daPriceCurveLength SLOAD 2, daDropInterval SLOAD 1\n  287:         uint256 elapsed = block.timestamp daStartTime;//@audit gas: daStartTime SLOAD 2\n  288:         uint256 steps = elapsed / daDropInterval; //@audit gas: daDropInterval SLOAD 2\n  292:         if (stepDeduction  startPrice) { //@audit gas: startPrice SLOAD 2\n  293:             return lowestPrice; //@audit gas: lowestPrice SLOAD 2\n  295:         uint256 currentPrice = startPrice stepDeduction; //@audit gas: startPrice SLOAD 3\n  296:         return currentPrice  lowestPrice ? currentPrice : lowestPrice;  //@audit gas: lowestPrice SLOAD 2 & 3\n  401:             IWETH(weth).deposit{value: amount}(); //@audit gas: weth SLOAD 1\n  402:             IERC20(weth).transfer(to, amount); //@audit gas: weth SLOAD 2\n  609:         require(address(vault) != address(0), 'no vault'); //@audit gas: vault SLOAD 1\n  610:         require(payable(vault).send(_amount)); //@audit gas: vault SLOAD 2\n  617:         require(address(vault) != address(0), 'no vault'); //@audit gas: vault SLOAD 1\n  618:         require(payable(vault).send(address(this).balance)); //@audit gas: vault SLOAD 2\n"
                ],
                "Type": " Caching storage values in memory",
                "Description": "\nThe code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, storage values should get cached in memory (see the @audit tags for further details):\n\nsolidity\ncontracts/ForgottenRunesWarriorsGuild.sol:\n  100:         require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');  //@audit gas: numMinted SLOAD 1 (should declare tokenId earlier and use it instead)\n  102:         uint256 tokenId = numMinted; //@audit gas: numMinted SLOAD 2 (should be declared earlier)\n  104:         numMinted += 1;  //@audit gas: numMinted SLOAD 3 (should be numMinted = tokenId + 1)\n\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  136:         require(numSold < maxDaSupply, 'Auction sold out'); //@audit gas: numSold SLOAD 1, maxDaSupply SLOAD 1\n  137:         require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining'); //@audit gas: numSold SLOAD 2, maxDaSupply SLOAD 2\n  154:         numSold += numWarriors; //@audit gas: numSold SLOAD 3 (equivalent to numSold = numSold + numWarriors)\n  156:         if (numSold == maxDaSupply) { //@audit gas: numSold SLOAD 4, maxDaSupply SLOAD 3\n  177:         require(numSold < maxForSale, 'Sold out'); //@audit gas: numSold SLOAD 1\n  193:         numSold += 1; //@audit gas: numSold SLOAD 2 (equivalent to numSold = numSold + 1)\n  207:         require(numSold < maxForSale, 'Sold out'); //@audit gas: numSold SLOAD 1, maxDaSupply SLOAD 1\n  208:         require(numSold + numWarriors <= maxForSale, 'Not enough remaining'); //@audit gas: numSold SLOAD 2, maxDaSupply SLOAD 2\n  219:         numSold += numWarriors; //@audit gas: numSold SLOAD 3 (equivalent to numSold = numSold + numWarriors)\n  234:         require(numClaimed < maxForClaim, 'No more claims'); //@audit gas: numSold SLOAD 1\n  248:         numClaimed += 1; //@audit gas: numSold SLOAD 2 (equivalent to numSold = numSold + 1)\n  279:         if (block.timestamp = daStartTime + daPriceCurveLength) {//@audit gas: daStartTime SLOAD 1, daPriceCurveLength SLOAD 1\n  284:         uint256 dropPerStep = (startPrice lowestPrice) / //@audit gas: startPrice SLOAD 1, lowestPrice SLOAD 1\n  285:             (daPriceCurveLength / daDropInterval); //@audit gas: daPriceCurveLength SLOAD 2, daDropInterval SLOAD 1\n  287:         uint256 elapsed = block.timestamp daStartTime;//@audit gas: daStartTime SLOAD 2\n  288:         uint256 steps = elapsed / daDropInterval; //@audit gas: daDropInterval SLOAD 2\n  292:         if (stepDeduction  startPrice) { //@audit gas: startPrice SLOAD 2\n  293:             return lowestPrice; //@audit gas: lowestPrice SLOAD 2\n  295:         uint256 currentPrice = startPrice stepDeduction; //@audit gas: startPrice SLOAD 3\n  296:         return currentPrice  lowestPrice ? currentPrice : lowestPrice;  //@audit gas: lowestPrice SLOAD 2 & 3\n  401:             IWETH(weth).deposit{value: amount}(); //@audit gas: weth SLOAD 1\n  402:             IERC20(weth).transfer(to, amount); //@audit gas: weth SLOAD 2\n  609:         require(address(vault) != address(0), 'no vault'); //@audit gas: vault SLOAD 1\n  610:         require(payable(vault).send(_amount)); //@audit gas: vault SLOAD 2\n  617:         require(address(vault) != address(0), 'no vault'); //@audit gas: vault SLOAD 1\n  618:         require(payable(vault).send(address(this).balance)); //@audit gas: vault SLOAD 2\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: ForgottenRunesWarriorsMinter.sol\n291:         // don't go negative in the next step\n292:         if (stepDeduction  startPrice) {\n293:             return lowestPrice;\n294:         }\n295:         uint256 currentPrice = startPrice stepDeduction; //@audit gas: should be unchecked due to L292-L293\n"
                ],
                "Type": " Unchecking arithmetics operations that can't underflow/overflow",
                "Description": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic\n\nI suggest wrapping L295 with an unchecked block (see @audit):\n\nsolidity\nFile: ForgottenRunesWarriorsMinter.sol\n291:         // don't go negative in the next step\n292:         if (stepDeduction  startPrice) {\n293:             return lowestPrice;\n294:         }\n295:         uint256 currentPrice = startPrice stepDeduction; //@audit gas: should be unchecked due to L292-L293\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-12",
                "Location": [
                    "//solidity\ninitialize(address) should be declared external:\n ForgottenRunesWarriorsGuild.initialize(address) (contracts/ForgottenRunesWarriorsGuild.sol#52-54)\nexists(uint256) should be declared external:\n ForgottenRunesWarriorsGuild.exists(uint256) (contracts/ForgottenRunesWarriorsGuild.sol#85-87)\nsetProvenanceHash(string) should be declared external:\n ForgottenRunesWarriorsGuild.setProvenanceHash(string) (contracts/ForgottenRunesWarriorsGuild.sol#145-147)\nwithdrawAll() should be declared external:\n ForgottenRunesWarriorsGuild.withdrawAll() (contracts/ForgottenRunesWarriorsGuild.sol#163-165)\nforwardERC20s(IERC20,uint256) should be declared external:\n ForgottenRunesWarriorsGuild.forwardERC20s(IERC20,uint256) (contracts/ForgottenRunesWarriorsGuild.sol#173-176)\nnumDaMinters() should be declared external:\n ForgottenRunesWarriorsMinter.numDaMinters() (contracts/ForgottenRunesWarriorsMinter.sol#337-339)\nissueRefunds(uint256,uint256) should be declared external:\n ForgottenRunesWarriorsMinter.issueRefunds(uint256,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#350-358)\nrefundAddress(address) should be declared external:\n ForgottenRunesWarriorsMinter.refundAddress(address) (contracts/ForgottenRunesWarriorsMinter.sol#364-366)\nselfRefund() should be declared external:\n ForgottenRunesWarriorsMinter.selfRefund() (contracts/ForgottenRunesWarriorsMinter.sol#371-374)\npause() should be declared external:\n ForgottenRunesWarriorsMinter.pause() (contracts/ForgottenRunesWarriorsMinter.sol#427-429)\nunpause() should be declared external:\n ForgottenRunesWarriorsMinter.unpause() (contracts/ForgottenRunesWarriorsMinter.sol#434-436)\nsetSelfRefundsStartTime(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setSelfRefundsStartTime(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#469-471)\nsetPhaseTimes(uint256,uint256,uint256,uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setPhaseTimes(uint256,uint256,uint256,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#480-500)\nsetMintlist1MerkleRoot(bytes32) should be declared external:\n ForgottenRunesWarriorsMinter.setMintlist1MerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#505-507)\nsetMintlist2MerkleRoot(bytes32) should be declared external:\n ForgottenRunesWarriorsMinter.setMintlist2MerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#513-515)\nsetClaimlistMerkleRoot(bytes32) should be declared external:\n ForgottenRunesWarriorsMinter.setClaimlistMerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#520-522)\nsetStartPrice(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setStartPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#550-552)\nsetLowestPrice(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setLowestPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#557-559)\nsetDaPriceCurveLength(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setDaPriceCurveLength(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#564-566)\nsetDaDropInterval(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setDaDropInterval(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#571-573)\nsetFinalPrice(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setFinalPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#579-581)\nsetMaxDaSupply(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setMaxDaSupply(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#586-588)\nsetMaxForSale(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setMaxForSale(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#593-595)\nsetMaxForClaim(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setMaxForClaim(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#600-602)\nwithdraw(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.withdraw(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#608-611)\nwithdrawAll() should be declared external:\n ForgottenRunesWarriorsMinter.withdrawAll() (contracts/ForgottenRunesWarriorsMinter.sol#616-619)\nforwardERC20s(IERC20,uint256) should be declared external:\n ForgottenRunesWarriorsMinter.forwardERC20s(IERC20,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#627-630)\n"
                ],
                "Type": " Public functions to external",
                "Description": "\nThe following functions could be set external to save gas and improve code quality.\nExternal call cost is less expensive than of public functions.\n\nsolidity\ninitialize(address) should be declared external:\n ForgottenRunesWarriorsGuild.initialize(address) (contracts/ForgottenRunesWarriorsGuild.sol#52-54)\nexists(uint256) should be declared external:\n ForgottenRunesWarriorsGuild.exists(uint256) (contracts/ForgottenRunesWarriorsGuild.sol#85-87)\nsetProvenanceHash(string) should be declared external:\n ForgottenRunesWarriorsGuild.setProvenanceHash(string) (contracts/ForgottenRunesWarriorsGuild.sol#145-147)\nwithdrawAll() should be declared external:\n ForgottenRunesWarriorsGuild.withdrawAll() (contracts/ForgottenRunesWarriorsGuild.sol#163-165)\nforwardERC20s(IERC20,uint256) should be declared external:\n ForgottenRunesWarriorsGuild.forwardERC20s(IERC20,uint256) (contracts/ForgottenRunesWarriorsGuild.sol#173-176)\nnumDaMinters() should be declared external:\n ForgottenRunesWarriorsMinter.numDaMinters() (contracts/ForgottenRunesWarriorsMinter.sol#337-339)\nissueRefunds(uint256,uint256) should be declared external:\n ForgottenRunesWarriorsMinter.issueRefunds(uint256,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#350-358)\nrefundAddress(address) should be declared external:\n ForgottenRunesWarriorsMinter.refundAddress(address) (contracts/ForgottenRunesWarriorsMinter.sol#364-366)\nselfRefund() should be declared external:\n ForgottenRunesWarriorsMinter.selfRefund() (contracts/ForgottenRunesWarriorsMinter.sol#371-374)\npause() should be declared external:\n ForgottenRunesWarriorsMinter.pause() (contracts/ForgottenRunesWarriorsMinter.sol#427-429)\nunpause() should be declared external:\n ForgottenRunesWarriorsMinter.unpause() (contracts/ForgottenRunesWarriorsMinter.sol#434-436)\nsetSelfRefundsStartTime(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setSelfRefundsStartTime(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#469-471)\nsetPhaseTimes(uint256,uint256,uint256,uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setPhaseTimes(uint256,uint256,uint256,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#480-500)\nsetMintlist1MerkleRoot(bytes32) should be declared external:\n ForgottenRunesWarriorsMinter.setMintlist1MerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#505-507)\nsetMintlist2MerkleRoot(bytes32) should be declared external:\n ForgottenRunesWarriorsMinter.setMintlist2MerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#513-515)\nsetClaimlistMerkleRoot(bytes32) should be declared external:\n ForgottenRunesWarriorsMinter.setClaimlistMerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#520-522)\nsetStartPrice(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setStartPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#550-552)\nsetLowestPrice(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setLowestPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#557-559)\nsetDaPriceCurveLength(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setDaPriceCurveLength(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#564-566)\nsetDaDropInterval(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setDaDropInterval(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#571-573)\nsetFinalPrice(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setFinalPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#579-581)\nsetMaxDaSupply(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setMaxDaSupply(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#586-588)\nsetMaxForSale(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setMaxForSale(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#593-595)\nsetMaxForClaim(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.setMaxForClaim(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#600-602)\nwithdraw(uint256) should be declared external:\n ForgottenRunesWarriorsMinter.withdraw(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#608-611)\nwithdrawAll() should be declared external:\n ForgottenRunesWarriorsMinter.withdrawAll() (contracts/ForgottenRunesWarriorsMinter.sol#616-619)\nforwardERC20s(IERC20,uint256) should be declared external:\n ForgottenRunesWarriorsMinter.forwardERC20s(IERC20,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#627-630)\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-14",
                "Location": [
                    "jsx\nForgottenRunesWarriorsGuild.sol:1:pragma //solidity ^0.8.0;\nForgottenRunesWarriorsMinter.sol:1:pragma //solidity ^0.8.0;\n"
                ],
                "Type": " Upgrade pragma to at least 0.8.4",
                "Description": "\nUsing newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.\n\nThe advantages here are:\n\n*   Low level inliner (= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions).\n*   Optimizer improvements in packed structs (= 0.8.3)\n*   Custom errors (= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.\n\nConsider upgrading pragma to at least 0.8.4:\n\njsx\nForgottenRunesWarriorsGuild.sol:1:pragma solidity ^0.8.0;\nForgottenRunesWarriorsMinter.sol:1:pragma solidity ^0.8.0;\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-16",
                "Location": [
                    "//solidity\nForgottenRunesWarriorsGuild.sol:68:        require(\nForgottenRunesWarriorsGuild.sol:100:        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');\nForgottenRunesWarriorsGuild.sol:101:        require(_msgSender() == minter, 'Not a minter');\nForgottenRunesWarriorsGuild.sol:114:        require(\nForgottenRunesWarriorsGuild.sol:164:        require(payable(msg.sender).send(address(this).balance));\nForgottenRunesWarriorsGuild.sol:174:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsMinter.sol:136:        require(numSold < maxDaSupply, 'Auction sold out');\nForgottenRunesWarriorsMinter.sol:137:        require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\nForgottenRunesWarriorsMinter.sol:138:        require(daStarted(), 'Auction not started');\nForgottenRunesWarriorsMinter.sol:139:        require(!mintlistStarted(), 'Auction phase over');\nForgottenRunesWarriorsMinter.sol:140:        require(\nForgottenRunesWarriorsMinter.sol:146:        require(\nForgottenRunesWarriorsMinter.sol:177:        require(numSold < maxForSale, 'Sold out');\nForgottenRunesWarriorsMinter.sol:178:        require(mintlistStarted(), 'Mintlist phase not started');\nForgottenRunesWarriorsMinter.sol:179:        require(msg.value == finalPrice, 'Ether value incorrect');\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:187:        require(\nForgottenRunesWarriorsMinter.sol:207:        require(numSold < maxForSale, 'Sold out');\nForgottenRunesWarriorsMinter.sol:208:        require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\nForgottenRunesWarriorsMinter.sol:209:        require(publicStarted(), 'Public sale not started');\nForgottenRunesWarriorsMinter.sol:210:        require(\nForgottenRunesWarriorsMinter.sol:214:        require(\nForgottenRunesWarriorsMinter.sol:234:        require(numClaimed < maxForClaim, 'No more claims');\nForgottenRunesWarriorsMinter.sol:235:        require(claimsStarted(), 'Claim phase not started');\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\nForgottenRunesWarriorsMinter.sol:243:        require(\nForgottenRunesWarriorsMinter.sol:258:        require(address(recipient) != address(0), 'address req');\nForgottenRunesWarriorsMinter.sol:372:        require(selfRefundsStarted(), 'Self refund period not started');\nForgottenRunesWarriorsMinter.sol:488:        require(\nForgottenRunesWarriorsMinter.sol:492:        require(\nForgottenRunesWarriorsMinter.sol:609:        require(address(vault) != address(0), 'no vault');\nForgottenRunesWarriorsMinter.sol:610:        require(payable(vault).send(_amount));\nForgottenRunesWarriorsMinter.sol:617:        require(address(vault) != address(0), 'no vault');\nForgottenRunesWarriorsMinter.sol:618:        require(payable(vault).send(address(this).balance));\nForgottenRunesWarriorsMinter.sol:628:        require(address(msg.sender) != address(0));\n"
                ],
                "Type": " Use Custom Errors instead of Revert Strings to save Gas",
                "Description": "\nCustom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)\n\nSource: <https://blog.soliditylang.org/2021/04/21/custom-errors/:\n\n Starting from Solidity v0.8.4(https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.\n\nCustom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).\n\nInstances include:\n\nsolidity\nForgottenRunesWarriorsGuild.sol:68:        require(\nForgottenRunesWarriorsGuild.sol:100:        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');\nForgottenRunesWarriorsGuild.sol:101:        require(_msgSender() == minter, 'Not a minter');\nForgottenRunesWarriorsGuild.sol:114:        require(\nForgottenRunesWarriorsGuild.sol:164:        require(payable(msg.sender).send(address(this).balance));\nForgottenRunesWarriorsGuild.sol:174:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsMinter.sol:136:        require(numSold < maxDaSupply, 'Auction sold out');\nForgottenRunesWarriorsMinter.sol:137:        require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\nForgottenRunesWarriorsMinter.sol:138:        require(daStarted(), 'Auction not started');\nForgottenRunesWarriorsMinter.sol:139:        require(!mintlistStarted(), 'Auction phase over');\nForgottenRunesWarriorsMinter.sol:140:        require(\nForgottenRunesWarriorsMinter.sol:146:        require(\nForgottenRunesWarriorsMinter.sol:177:        require(numSold < maxForSale, 'Sold out');\nForgottenRunesWarriorsMinter.sol:178:        require(mintlistStarted(), 'Mintlist phase not started');\nForgottenRunesWarriorsMinter.sol:179:        require(msg.value == finalPrice, 'Ether value incorrect');\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:187:        require(\nForgottenRunesWarriorsMinter.sol:207:        require(numSold < maxForSale, 'Sold out');\nForgottenRunesWarriorsMinter.sol:208:        require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\nForgottenRunesWarriorsMinter.sol:209:        require(publicStarted(), 'Public sale not started');\nForgottenRunesWarriorsMinter.sol:210:        require(\nForgottenRunesWarriorsMinter.sol:214:        require(\nForgottenRunesWarriorsMinter.sol:234:        require(numClaimed < maxForClaim, 'No more claims');\nForgottenRunesWarriorsMinter.sol:235:        require(claimsStarted(), 'Claim phase not started');\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\nForgottenRunesWarriorsMinter.sol:243:        require(\nForgottenRunesWarriorsMinter.sol:258:        require(address(recipient) != address(0), 'address req');\nForgottenRunesWarriorsMinter.sol:372:        require(selfRefundsStarted(), 'Self refund period not started');\nForgottenRunesWarriorsMinter.sol:488:        require(\nForgottenRunesWarriorsMinter.sol:492:        require(\nForgottenRunesWarriorsMinter.sol:609:        require(address(vault) != address(0), 'no vault');\nForgottenRunesWarriorsMinter.sol:610:        require(payable(vault).send(_amount));\nForgottenRunesWarriorsMinter.sol:617:        require(address(vault) != address(0), 'no vault');\nForgottenRunesWarriorsMinter.sol:618:        require(payable(vault).send(address(this).balance));\nForgottenRunesWarriorsMinter.sol:628:        require(address(msg.sender) != address(0));\n\n\nI suggest replacing revert strings with custom errors.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-05-runes-findings/issues/177#issuecomment-1160705332):\n  Most are valid, except:\n  ForgottenRunesWarriorsMinter.currentDaPrice():  should be =\n \n Strict is cheaper since there is no opcode for non-strict comparison in evm.\n \n  No need to explicitly initialize variables with default values\n \n Yes, but I don't think it saves gas in for loop with optimizer enabled.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the tokens of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsGuild is\n    IForgottenRunesWarriorsGuild,\n    Ownable,\n    ReentrancyGuard,\n    ERC721\n{\n    using Strings for uint256;\n\n    /// @notice The maximum number of Warriors\n    uint256 public constant MAX_WARRIORS = 16000;\n\n    /// @notice Counter to track the number minted so far\n    uint256 public numMinted = 0;\n\n    /// @notice Address of the minter\n    address public minter;\n\n    /// @notice The base URI for the metadata of the tokens\n    string public baseTokenURI;\n\n    string public constant R =\n        \"Old men forget: yet all shall be forgot, But he'll remember with advantages What feats he did that day: then shall our names Familiar in his mouth as household words. This story shall the good man teach his son From this day to the ending of the world\";\n\n    /// @notice The provenance hash\n    string public METADATA_PROVENANCE_HASH = '';\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param baseURI string the initial base URI for the token metadata URL\n     */\n    constructor(string memory baseURI)\n        ERC721('ForgottenRunesWarriorsGuild', 'WARRIORS')\n    {\n        setBaseURI(baseURI);\n    }\n\n    /**\n     * @dev Convenient way to initialize the contract\n     * @param newMinter address of the minter contract\n     */\n    function initialize(address newMinter) public onlyOwner {\n        setMinter(newMinter);\n    }\n\n    /**\n     * @dev Returns the URL of a given tokenId\n     * @param tokenId uint256 ID of the token to be minted\n     * @return string the URL of a given tokenId\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            'ERC721Metadata: URI query for nonexistent token'\n        );\n\n        return string(abi.encodePacked(baseTokenURI, tokenId.toString()));\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    /**\n     * @dev Returns if the token exists\n     * @param tokenId uint256 the id of the token\n     * @return exists bool if it exists\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /**\n     * @dev Mint the next token\n     * @param recipient address representing the owner of the new tokenId\n     * @return tokenId uint256 the new tokenId\n     */\n    function mint(address recipient)\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');\n        require(_msgSender() == minter, 'Not a minter');\n        uint256 tokenId = numMinted;\n        _safeMint(recipient, tokenId);\n        numMinted += 1;\n        return tokenId;\n    }\n\n    /**\n     * @notice I wouldn't if I were you\n     * @dev Burns the token\n     * @param tokenId uint256 representing the tokenId\n     */\n    function burn(uint256 tokenId) public virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721Burnable: caller is not owner nor approved'\n        );\n        _burn(tokenId);\n    }\n\n    /**\n     * Only the owner can do these things\n     */\n\n    /**\n     * @dev Sets a new base URI\n     * @param newBaseURI string the new token base URI\n     */\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseTokenURI = newBaseURI;\n    }\n\n    /**\n     * @dev Sets a new primary minter address\n     * @param newMinter address of the new minter\n     */\n    function setMinter(address newMinter) public onlyOwner {\n        minter = newMinter;\n    }\n\n    /**\n     * @dev Sets provenance hash\n     * @param newHash string of the new minter\n     */\n    function setProvenanceHash(string memory newHash) public onlyOwner {\n        METADATA_PROVENANCE_HASH = newHash;\n    }\n\n    /**\n     * @dev Adds calldata on chain for the images. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadImage(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev Adds calldata on chain for the attributes. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadAttributes(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev ETH should not be sent to this contract, but in the case that it is\n     * sent by accident, this function allows the owner to withdraw it.\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(payable(msg.sender).send(address(this).balance));\n    }\n\n    /**\n     * @dev Again, ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the minter of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsMinter is Ownable, Pausable, ReentrancyGuard {\n    /// @notice The start timestamp for the Dutch Auction (DA) sale and price\n    uint256 public daStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for mintlisters\n    /// @dev This is the end of DA phase. No more DA bids when this is hit\n    uint256 public mintlistStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the public sale\n    uint256 public publicStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the claims\n    uint256 public claimsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for self refunds\n    uint256 public selfRefundsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The main Merkle root\n    bytes32 public mintlist1MerkleRoot;\n\n    /// @notice The secondary Merkle root\n    /// @dev Having a backup merkle root lets us atomically update the merkletree without downtime on the frontend\n    bytes32 public mintlist2MerkleRoot;\n\n    /// @notice The claimslist Merkle root\n    bytes32 public claimlistMerkleRoot;\n\n    /// @notice The address of the Warriors contract\n    IForgottenRunesWarriorsGuild public warriors;\n\n    /// @notice The address of the vault\n    address public vault;\n\n    /// @notice The address of the WETH contract\n    address public weth;\n\n    /// @notice The start price of the DA\n    uint256 public startPrice = 2.5 ether;\n\n    /// @notice The lowest price of the DA\n    uint256 public lowestPrice = 0.6 ether;\n\n    /// @notice The length of time for the price curve in the DA\n    uint256 public daPriceCurveLength = 380 minutes;\n\n    /// @notice The interval of time in which the price steps down\n    uint256 public daDropInterval = 10 minutes;\n\n    /// @notice The final price of the DA. Will be updated when DA is over and then used for subsequent phases\n    uint256 public finalPrice = 2.5 ether;\n\n    /// @notice An array of the addresses of the DA minters\n    /// @dev An entry is created for every da minting tx, so the same minter address is quite likely to appear more than once\n    address[] public daMinters;\n\n    /// @notice Tracks the total amount paid by a given address in the DA\n    mapping(address => uint256) public daAmountPaid;\n\n    /// @notice Tracks the total amount refunded to a given address for the DA\n    mapping(address => uint256) public daAmountRefunded;\n\n    /// @notice Tracks the total count of NFTs minted by a given address in the DA\n    mapping(address => uint256) public daNumMinted;\n\n    /// @notice Tracks if a given address minted in the mintlist\n    mapping(address => bool) public mintlistMinted;\n\n    /// @notice Tracks the total count of NFTs claimed by a given address\n    mapping(address => bool) public claimlistMinted;\n\n    /// @notice The total number of tokens reserved for the DA phase\n    uint256 public maxDaSupply = 8000;\n\n    /// @notice Tracks the total count of NFTs sold (vs. freebies)\n    uint256 public numSold;\n\n    /// @notice Tracks the total count of NFTs for sale\n    uint256 public maxForSale = 14190;\n\n    /// @notice Tracks the total count of NFTs claimed for free\n    uint256 public numClaimed;\n\n    /// @notice Tracks the total count of NFTs that can be claimed\n    /// @dev While we will have a merkle root set for this group, putting a hard cap helps limit the damage of any problems with an overly-generous merkle tree\n    uint256 public maxForClaim = 1100;\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param _warriors address the initial warriors contract address\n     */\n    constructor(IForgottenRunesWarriorsGuild _warriors, address _weth) {\n        setWarriorsAddress(_warriors);\n        setWethAddress(_weth);\n        setVaultAddress(msg.sender);\n    }\n\n    /*\n     * Timeline:\n     *\n     * bidSummon       : |------------|\n     * mintlistSummon  :              |------------|-------------------------------------|\n     * publicSummon    :                           |------------|------------------------|\n     * claimSummon     :                                        |------------|-----------|\n     * teamSummon      : |---------------------------------------------------------------|\n     */\n\n    /**\n     * @notice Mint a Warrior in the Dutch Auction phase\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function bidSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxDaSupply, 'Auction sold out');\n        require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\n        require(daStarted(), 'Auction not started');\n        require(!mintlistStarted(), 'Auction phase over');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n\n        uint256 currentPrice = currentDaPrice();\n        require(\n            msg.value >= (currentPrice * numWarriors),\n            'Ether value sent is not sufficient'\n        );\n\n        daMinters.push(msg.sender);\n        daAmountPaid[msg.sender] += msg.value;\n        daNumMinted[msg.sender] += numWarriors;\n        numSold += numWarriors;\n\n        if (numSold == maxDaSupply) {\n            // optimistic: save gas by not setting on every mint, but will\n            // require manual `setFinalPrice` before refunds if da falls short\n            finalPrice = currentPrice;\n        }\n\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @notice Mint a Warrior in the mintlist phase (paid)\n     * @param _merkleProof bytes32[] your proof of being able to mint\n     */\n    function mintlistSummon(bytes32[] calldata _merkleProof)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(mintlistStarted(), 'Mintlist phase not started');\n        require(msg.value == finalPrice, 'Ether value incorrect');\n\n        // verify didn't already mint\n        require(mintlistMinted[msg.sender] == false, 'Already minted');\n        mintlistMinted[msg.sender] = true;\n\n        // verify mintlist merkle\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, mintlist1MerkleRoot, node) ||\n                MerkleProof.verify(_merkleProof, mintlist2MerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numSold += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior in the Public phase (paid)\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function publicSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\n        require(publicStarted(), 'Public sale not started');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n        require(\n            msg.value == (finalPrice * numWarriors),\n            'Ether value sent is incorrect'\n        );\n\n        numSold += numWarriors;\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @dev claim a warrior for free if you're in the claimlist\n     * @param _merkleProof bytes32[] the proof that you're eligible to mint here\n     */\n    function claimSummon(bytes32[] calldata _merkleProof)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        require(numClaimed < maxForClaim, 'No more claims');\n        require(claimsStarted(), 'Claim phase not started');\n\n        // verify didn't already claim\n        require(claimlistMinted[msg.sender] == false, 'Already claimed');\n        claimlistMinted[msg.sender] = true;\n\n        // verify claimlist\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, claimlistMerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numClaimed += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior (owner only)\n     * @param recipient address the address of the recipient\n     * @param count uint256 of the number of warriors you're trying to mint\n     */\n    function teamSummon(address recipient, uint256 count) external onlyOwner {\n        require(address(recipient) != address(0), 'address req');\n        for (uint256 i = 0; i < count; i++) {\n            _mint(recipient);\n        }\n    }\n\n    function _mint(address recipient) private {\n        warriors.mint(recipient);\n    }\n\n    /*\n     * View utilities\n     */\n\n    /**\n     * @notice returns the current dutch auction price\n     */\n    function currentDaPrice() public view returns (uint256) {\n        if (!daStarted()) {\n            return startPrice;\n        }\n        if (block.timestamp >= daStartTime + daPriceCurveLength) {\n            // end of the curve\n            return lowestPrice;\n        }\n\n        uint256 dropPerStep = (startPrice - lowestPrice) /\n            (daPriceCurveLength / daDropInterval);\n\n        uint256 elapsed = block.timestamp - daStartTime;\n        uint256 steps = elapsed / daDropInterval;\n        uint256 stepDeduction = steps * dropPerStep;\n\n        // don't go negative in the next step\n        if (stepDeduction > startPrice) {\n            return lowestPrice;\n        }\n        uint256 currentPrice = startPrice - stepDeduction;\n        return currentPrice > lowestPrice ? currentPrice : lowestPrice;\n    }\n\n    /**\n     * @notice returns whether the dutch auction has started\n     */\n    function daStarted() public view returns (bool) {\n        return block.timestamp > daStartTime;\n    }\n\n    /**\n     * @notice returns whether the mintlist has started\n     */\n    function mintlistStarted() public view returns (bool) {\n        return block.timestamp > mintlistStartTime;\n    }\n\n    /**\n     * @notice returns whether the public mint has started\n     */\n    function publicStarted() public view returns (bool) {\n        return block.timestamp > publicStartTime;\n    }\n\n    /**\n     * @notice returns whether the claims phase has started\n     */\n    function claimsStarted() public view returns (bool) {\n        return block.timestamp > claimsStartTime;\n    }\n\n    /**\n     * @notice returns whether self refunds phase has started\n     */\n    function selfRefundsStarted() public view returns (bool) {\n        return block.timestamp > selfRefundsStartTime;\n    }\n\n    /**\n     * @notice returns the number of minter addresses in the DA phase (includes duplicates)\n     */\n    function numDaMinters() public view returns (uint256) {\n        return daMinters.length;\n    }\n\n    /*\n     * Refund logic\n     */\n\n    /**\n     * @notice issues refunds for the accounts in minters between startIdx and endIdx inclusive\n     * @param startIdx uint256 the starting index of daMinters\n     * @param endIdx uint256 the ending index of daMinters, inclusive\n     */\n    function issueRefunds(uint256 startIdx, uint256 endIdx)\n        public\n        onlyOwner\n        nonReentrant\n    {\n        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n            _refundAddress(daMinters[i]);\n        }\n    }\n\n    /**\n     * @notice issues a refund for the address\n     * @param minter address the address to refund\n     */\n    function refundAddress(address minter) public onlyOwner nonReentrant {\n        _refundAddress(minter);\n    }\n\n    /**\n     * @notice refunds msg.sender what they're owed\n     */\n    function selfRefund() public nonReentrant {\n        require(selfRefundsStarted(), 'Self refund period not started');\n        _refundAddress(msg.sender);\n    }\n\n    function _refundAddress(address minter) private {\n        uint256 owed = refundOwed(minter);\n        if (owed > 0) {\n            daAmountRefunded[minter] += owed;\n            _safeTransferETHWithFallback(minter, owed);\n        }\n    }\n\n    /**\n     * @notice returns the amount owed the address\n     * @param minter address the address of the account that wants a refund\n     */\n    function refundOwed(address minter) public view returns (uint256) {\n        uint256 totalCostOfMints = finalPrice * daNumMinted[minter];\n        uint256 refundsPaidAlready = daAmountRefunded[minter];\n        return daAmountPaid[minter] - totalCostOfMints - refundsPaidAlready;\n    }\n\n    /**\n     * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.\n     * @param to account who to send the ETH or WETH to\n     * @param amount uint256 how much ETH or WETH to send\n     */\n    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n        if (!_safeTransferETH(to, amount)) {\n            IWETH(weth).deposit{value: amount}();\n            IERC20(weth).transfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer ETH and return the success status.\n     * @dev This function only forwards 30,000 gas to the callee.\n     * @param to account who to send the ETH to\n     * @param value uint256 how much ETH to send\n     */\n    function _safeTransferETH(address to, uint256 value)\n        internal\n        returns (bool)\n    {\n        (bool success, ) = to.call{value: value, gas: 30_000}(new bytes(0));\n        return success;\n    }\n\n    /*\n     * Only the owner can do these things\n     */\n\n    /**\n     * @notice pause the contract\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice unpause the contract\n     */\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice set the dutch auction start timestamp\n     */\n    function setDaStartTime(uint256 _newTime) public onlyOwner {\n        daStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the mintlist start timestamp\n     */\n    function setMintlistStartTime(uint256 _newTime) public onlyOwner {\n        mintlistStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the public sale start timestamp\n     */\n    function setPublicStartTime(uint256 _newTime) public onlyOwner {\n        publicStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the claims phase start timestamp\n     */\n    function setClaimsStartTime(uint256 _newTime) public onlyOwner {\n        claimsStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the self refund phase start timestamp\n     */\n    function setSelfRefundsStartTime(uint256 _newTime) public onlyOwner {\n        selfRefundsStartTime = _newTime;\n    }\n\n    /**\n     * @notice A convenient way to set all phase times at once\n     * @param newDaStartTime uint256 the dutch auction start time\n     * @param newMintlistStartTime uint256 the mintlst phase start time\n     * @param newPublicStartTime uint256 the public phase start time\n     * @param newClaimsStartTime uint256 the claims phase start time\n     */\n    function setPhaseTimes(\n        uint256 newDaStartTime,\n        uint256 newMintlistStartTime,\n        uint256 newPublicStartTime,\n        uint256 newClaimsStartTime\n    ) public onlyOwner {\n        // we put these checks here instead of in the setters themselves\n        // because they're just guardrails of the typical case\n        require(\n            newPublicStartTime >= newMintlistStartTime,\n            'Set public after mintlist'\n        );\n        require(\n            newClaimsStartTime >= newPublicStartTime,\n            'Set claims after public'\n        );\n        setDaStartTime(newDaStartTime);\n        setMintlistStartTime(newMintlistStartTime);\n        setPublicStartTime(newPublicStartTime);\n        setClaimsStartTime(newClaimsStartTime);\n    }\n\n    /**\n     * @notice set the merkle root for the mintlist phase\n     */\n    function setMintlist1MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist1MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the alternate merkle root for the mintlist phase\n     * @dev we have two because it lets us idempotently update the website without downtime\n     */\n    function setMintlist2MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist2MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the merkle root for the claimslist phase\n     */\n    function setClaimlistMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        claimlistMerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the vault address where the funds are withdrawn\n     */\n    function setVaultAddress(address _newVaultAddress) public onlyOwner {\n        vault = _newVaultAddress;\n    }\n\n    /**\n     * @notice set the warriors token address\n     */\n    function setWarriorsAddress(\n        IForgottenRunesWarriorsGuild _newWarriorsAddress\n    ) public onlyOwner {\n        warriors = _newWarriorsAddress;\n    }\n\n    /**\n     * @notice set the weth token address\n     */\n    function setWethAddress(address _newWethAddress) public onlyOwner {\n        weth = _newWethAddress;\n    }\n\n    /**\n     * @notice set the dutch auction start price\n     */\n    function setStartPrice(uint256 _newPrice) public onlyOwner {\n        startPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the dutch auction lowest price\n     */\n    function setLowestPrice(uint256 _newPrice) public onlyOwner {\n        lowestPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the length of time the dutch auction price should change\n     */\n    function setDaPriceCurveLength(uint256 _newTime) public onlyOwner {\n        daPriceCurveLength = _newTime;\n    }\n\n    /**\n     * @notice set how long it takes for the dutch auction to step down in price\n     */\n    function setDaDropInterval(uint256 _newTime) public onlyOwner {\n        daDropInterval = _newTime;\n    }\n\n    /**\n     * @notice set \"final\" price of the dutch auction\n     * @dev this is set automatically if the dutch-auction sells out, but needs to be set manually if the DA fails to sell out\n     */\n    function setFinalPrice(uint256 _newPrice) public onlyOwner {\n        finalPrice = _newPrice;\n    }\n\n    /**\n     * @notice the max supply available in the dutch auction\n     */\n    function setMaxDaSupply(uint256 _newSupply) public onlyOwner {\n        maxDaSupply = _newSupply;\n    }\n\n    /**\n     * @notice the total max supply available for sale in any phase\n     */\n    function setMaxForSale(uint256 _newSupply) public onlyOwner {\n        maxForSale = _newSupply;\n    }\n\n    /**\n     * @notice the max supply available in the claimlist\n     */\n    function setMaxForClaim(uint256 _newSupply) public onlyOwner {\n        maxForClaim = _newSupply;\n    }\n\n    /**\n     * @notice Withdraw funds to the vault\n     * @param _amount uint256 the amount to withdraw\n     */\n    function withdraw(uint256 _amount) public onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(_amount));\n    }\n\n    /**\n     * @notice Withdraw all funds to the vault\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(address(this).balance));\n    }\n\n    /**\n     * @dev ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ForgottenRunesWarriorsGuild.sol",
            "ForgottenRunesWarriorsMinter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: ForgottenRunesWarriorsMinter.sol\n130:     function bidSummon(uint256 numWarriors)\n131:         external\n132:         payable\n133:         nonReentrant\n134:         whenNotPaused\n135:     {\n136:         require(numSold < maxDaSupply, 'Auction sold out');\n137:         require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\n138:         require(daStarted(), 'Auction not started');\n139:         require(!mintlistStarted(), 'Auction phase over');\n140:         require(\n141:             numWarriors  0 && numWarriors <= 20,\n142:             'You can summon no more than 20 Warriors at a time'\n143:         );\n...\n201:     function publicSummon(uint256 numWarriors)\n202:         external\n203:         payable\n204:         nonReentrant\n205:         whenNotPaused\n206:     {\n207:         require(numSold < maxForSale, 'Sold out');\n208:         require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\n209:         require(publicStarted(), 'Public sale not started');\n210:         require(\n211:             numWarriors  0 && numWarriors <= 20,\n212:             'You can summon no more than 20 Warriors at a time'\n213:         );\n"
                ],
                "Type": "  ForgottenRunesWarriorsMinter :  bidSummon() and  publicSummon() : Unnecessary require statement",
                "Description": "\nThe code is as such:\n\nsolidity\nFile: ForgottenRunesWarriorsMinter.sol\n130:     function bidSummon(uint256 numWarriors)\n131:         external\n132:         payable\n133:         nonReentrant\n134:         whenNotPaused\n135:     {\n136:         require(numSold < maxDaSupply, 'Auction sold out');\n137:         require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\n138:         require(daStarted(), 'Auction not started');\n139:         require(!mintlistStarted(), 'Auction phase over');\n140:         require(\n141:             numWarriors  0 && numWarriors <= 20,\n142:             'You can summon no more than 20 Warriors at a time'\n143:         );\n...\n201:     function publicSummon(uint256 numWarriors)\n202:         external\n203:         payable\n204:         nonReentrant\n205:         whenNotPaused\n206:     {\n207:         require(numSold < maxForSale, 'Sold out');\n208:         require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\n209:         require(publicStarted(), 'Public sale not started');\n210:         require(\n211:             numWarriors  0 && numWarriors <= 20,\n212:             'You can summon no more than 20 Warriors at a time'\n213:         );\n\n\nLogically speaking, numSold + numWarriors <= maxForSale could only reach the edge-case if numWarriors == 0, but that's prevented with the condition that follows in both functions: numWarriors  0 && numWarriors <= 20.\nMeaning that, with numSold + numWarriors <= maxForSale and numWarriors  0, we don't need to check if numSold < maxForSale as it just can't happen.\n\nI suggest removing the 2 require(numSold < maxDaSupply) checks L136 and L207.\n\nFurthermore, notice that 'Not enough remaining' and 'Sold out' kinda mean the same thing, so the additionnal require statement might not be justified.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\n"
                ],
                "Type": " Boolean comparisons",
                "Description": "\nComparing to a constant (true or false) is a bit more expensive than directly checking the returned boolean value.\nI suggest using if(!directValue) instead of if(directValue == false) here:\n\nsolidity\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [
                    "//solidity\nForgottenRunesWarriorsMinter.sol:141:            numWarriors  0 && numWarriors <= 20,\nForgottenRunesWarriorsMinter.sol:211:            numWarriors  0 && numWarriors <= 20,\n"
                ],
                "Type": "  > 0  is less efficient than  != 0  for unsigned integers (with proof)",
                "Description": "\n!= 0 costs less gas compared to  0 for unsigned integers in require statements with the optimizer enabled (6 gas)\n\nProof: While it may seem that  0 is cheaper than !=, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a require statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706\n\nI suggest changing  0 with != 0 here:\n\nsolidity\nForgottenRunesWarriorsMinter.sol:141:            numWarriors  0 && numWarriors <= 20,\nForgottenRunesWarriorsMinter.sol:211:            numWarriors  0 && numWarriors <= 20,\n\n\nAlso, please enable the Optimizer.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-13",
                "Location": [
                    "//solidity\nForgottenRunesWarriorsGuild.sol:24:    uint256 public numMinted = 0;\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\n"
                ],
                "Type": " No need to explicitly initialize variables with default values",
                "Description": "\nIf a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.\n\nAs an example: for (uint256 i = 0; i < numIterations; ++i) { should be replaced with for (uint256 i; i < numIterations; ++i) {\n\nInstances include:\n\nsolidity\nForgottenRunesWarriorsGuild.sol:24:    uint256 public numMinted = 0;\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\n\n\nI suggest removing explicit initializations for default values.\n\n\n",
                "Repair": ""
            }
        ]
    }
]