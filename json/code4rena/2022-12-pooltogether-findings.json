[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [],
                "Type": " An attacker can make users unable to cancel their L1 calls on Ethereum To Arbitrum",
                "Description": "*Submitted by ktg(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60), also found by 0x52(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/94)*\n\nEthereumToArbitrumRelayer.sol#L118-#L127(https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-#L127)<br\n\nWhen someone wants to make  calls to Arbitrum from Ethereum, first they call relayCalls to fingerprint their data and then anyone else can call processCalls to process the calls. According to the doc in Inbox source code <https://github.com/OffchainLabs/nitro/blob/1f32bec6b9b228bb2fab4bfa02867716f65d0c5c/contracts/src/bridge/Inbox.sol#L427, function createRetryableTicket has one parameter called callValueRefundAddress and this is the address that is granted the option to cancel a Retryable. In EthereumToArbitrumRelayer.sol it's currently set as msg.sender (5th parameter) which is whoever make the call to  function processCall:\n\n    uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(\n          address(executor),\n          0,\n          _maxSubmissionCost,\n          msg.sender,\n          msg.sender,\n          _gasLimit,\n          _gasPriceBid,\n          _data\n        );\n\nThis implementation allows an attacker to remove the possibility of a user to cancel their calls, which is an important mechanism to be properly implemented. This scenario demonstrates how this could happen:\n\n*   User A call relayCalls to fingerprint their calls\n*   User B call processCalls to process user A's calls.\n*   User A now changes his mind and wants to cancel his calls but he's unable to since  callValueRefundAddress is set to user B's address, now user B is the one who decides whether to cancel user A's calls or not, which should be user A's option.\n*   Another common case is when users's calls failed, anyone can try to redeem it, according to the doc <https://developer.arbitrum.io/arbos/l1-to-l2-messaging. So if a someone calls processCalls to process others's calls and it fails, the owner of the calls now cannot cancel their calls and anyone else can redeem (reexecute) them.\n\nIt should be noted here that EthereumToArbitrumRelayer.sol provides no other functionality to cancel users's calls, but it seems to rely only on Arbitrum's Retryable cancel mechanism to do so.\n\n",
                "Repair": "\nCurrently, anyone can process others's calls by calling processCalls functions and I think this does not pose any security risk as long as the user who actually fingerprinted these calls can reserve their rights to cancel it if they want to. Therefore, I recommend changing callValueRefundAddress in createRetryableTicket to _sender, this combines with event ProcessedCalls(_nonce, msg.sender, _ticketID) emitted at the end of processCalls function will allow a user to be notified if their calls has been processed by anyone else and they can cancel it in L2 using _ticketID.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60#issuecomment-1345665985):\n  Relayer has privilege to cancel arbitrum txs, I think there may be a similar finding, but for now will keep separate.\n\nPierrickGT (PoolTogether) confirmed and commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60#issuecomment-1352223144):\n  Very nice find! I've fixed the issue in the following PR: https://github.com/pooltogether/ERC5164/pull/10\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60#issuecomment-1365451144):\n  Worth flagging that allowing the caller to pass an arbitrary address may not solve, as I'd argue the only address that would rationally prevent the grief is the _sender, not fully sure if that is sufficient though.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60#issuecomment-1365451641):\n  The Warden has shown a specific scenario in which Arbitrum tickets, which are meant to be cancellable by the caller / the sender, can be griefed.\n \n Because this breaks the expectations of the code, and denies a functionality which was explicitly added, I agree with Medium Severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @param destAddr destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress maxgas x gasprice execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param gasPriceBid price bid for L2 execution\n     * @param data ABI encoded data of L2 message\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n     */\n    function createRetryableTicket(\n        address destAddr,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n",
                    "//solidity\n    uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(\n      address(executor),\n      0,\n      _maxSubmissionCost,\n      msg.sender,   // @audit : excessFeeRefundAddress\n      msg.sender,  // @audit: callValueRefundAddress\n      _gasLimit,\n      _gasPriceBid,\n      _data\n    );\n",
                    "\nIf the Retryable Ticket is cancelled or expires before it is redeemed, Callvalue is credited to Beneficiary.\n\n"
                ],
                "Type": " When a smart contract calls  CrossChainRelayerArbitrum.processCalls , excess submission fees may be lost",
                "Description": "*Submitted by cccz(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63), also found by joestakey(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/223), enckrish(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/197), and Chom(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/42)*\n\nWhen the user calls CrossChainRelayerArbitrum.processCalls, ETH is sent as the submission fee.\n\nAccording to the documentation : <https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md#retryable-transaction-lifecycle\n\n    Credit-Back Address: Address to which all excess gas is credited on L2; i.e., excess ETH for base submission cost (MaxSubmissionCost ActualSubmissionCostPaid) and excess ETH provided for L2 execution ( (GasPrice x MaxGas) ActualETHSpentInExecution).\n    ...\n    Submission fee is collected: submission fee is deducted from the sender\u2019s L2 account; MaxSubmissionCost submission fee is credited to Credit-Back Address.\n\nThe excess submission fee is refunded to the address on L2 of the excessFeeRefundAddress provided when calling createRetryableTicket.\n\nsolidity\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @param destAddr destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress maxgas x gasprice execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param gasPriceBid price bid for L2 execution\n     * @param data ABI encoded data of L2 message\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n     */\n    function createRetryableTicket(\n        address destAddr,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n\n\nIn CrossChainRelayerArbitrum.processCalls, excessFeeRefundAddress == msg.sender.\n\nsolidity\n    uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(\n      address(executor),\n      0,\n      _maxSubmissionCost,\n      msg.sender,   // @audit : excessFeeRefundAddress\n      msg.sender,  // @audit: callValueRefundAddress\n      _gasLimit,\n      _gasPriceBid,\n      _data\n    );\n\n\nFor EOA accounts, the excess submission fees are correctly refunded to their address on L2.\nHowever, for smart contracts, since there may not exist a corresponding address on L2, these excess submission fees will be lost.\n\nAlso, since the callValueRefundAddress is also msg.sender, according to the documentation, if the Retryable Ticket is cancelled or expired, then the smart contract caller may lose all the submission fees\n\n\nIf the Retryable Ticket is cancelled or expires before it is redeemed, Callvalue is credited to Beneficiary.\n\n\n\n\n<https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-L127\n\n<https://github.com/OffchainLabs/arbitrum/blob/master/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L333-L354\n\n",
                "Repair": "\nConsider allowing the user to specify excessFeeRefundAddress and callValueRefundAddress when calling CrossChainRelayerArbitrum.processCalls.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1345650911):\n  Making primary for quality of info.\n \n Ultimately boils down to the idea that contracts won't get a refund. Will have to think about whether this Med (submitted as such), or Low (self-inflicted).\n\nPierrickGT (PoolTogether) confirmed and commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1350288109):\n  Fixed in this PR: https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63\n \n The processCalls function was intended to be called by an EOA only but it's true that a contract may want to call it while providing the required _gasLimit, _maxSubmissionCost and _gasPriceBid by an EOA.<br\n Passing a refundAddress variable will allow a contract to refund the EOA that called it.\n \n Regarding the severity, I think 2 (Med Risk) is appropriate since the contract would leak value.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1365313747):\n  Agree with finding, am conflicted on severity:\n Low - User sends more than necessary\n Med - Behaviour, is inconsistent to expected / intended functionality\n \n Will think about it further.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1365317980):\n  More specifically, the fact that the system wants to allow refunds and has a bug that prevents that, which would qualify as Medium. (We care if you send more, we will send it back, but because of bug we cannot)\n \n While the pre-condition, in case of a less sophisticated system, would most likely be Low (we don't care if you send more, don't send more)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1365508732):\n  The Warden has shown an incorrect implementation, which can cause excess fees to be lost.\n \n While the loss of excess fees could be considered Low Severity (self-inflicted), the integration mistake is worth flagging and warrants the increased severity. \n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\ncontract Foo {\n    function bar() public {\n        for(uint256 i; ; i++) {}\n    }\n}\n",
                    "//solidity\ncontract Foo {\n    function bar() public {\n        revert();\n    }\n}\n"
                ],
                "Type": "  CrossChainExecutor  contracts do not update the necessary states for failing transactions",
                "Description": "*Submitted by AkshaySrivastav(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166), also found by ladboy233(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/160), hihen(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/49), and csanuragjain(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/18)*\n\nEthereumToOptimismExecutor.sol#L45-L59(https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-optimism/EthereumToOptimismExecutor.sol#L45-L59)<br\nEthereumToArbitrumExecutor.sol#L31-L45(https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumExecutor.sol#L31-L45)\n\nThe CrossChainExecutorArbitrum and CrossChainExecutorOptimism contracts both use CallLib library to invoke Calls on external contract. As per the CallLib library implementation, any failing Call results in the entire transaction getting reverted.\n\nThe CrossChainExecutor contracts does not store whether the calls in CallLib.Call[] were already attempted which failed.\n\nThis creates several issues for CrossChainExecutor contracts.\n\n1.  Offchain components can be tricked to submit failing Call[]s again and again. This can be used to drain the offchain component of gas.\n\n2.  Once a failing Call[] was invoked (which failed) and if again the same Call[] is invoked, the transaction should revert with CallsAlreadyExecuted error but it reverts with CallFailure error.\n\n3.  It is difficult to determine whether a to-be executed Call[] is pending or the invocation was already tried but failed.\n\nPoCs for the above issues are listed below.\n\n\n\nsolidity\ncontract Foo {\n    function bar() public {\n        for(uint256 i; ; i++) {}\n    }\n}\n\n\n*   The attacker relays the Foo.bar() call in the CrossChainRelayer contract with maxGasLimit as the _gasLimit parameter.\n*   The transport layer tries to invoke the Foo.bar() call by calling the CrossChainExecutor.executeCalls(). This transaction reverts costing the transport layer client maxGasLimit gas.\n*   Since no state updates were performed in CrossChainExecutor, the transport layer still assumes the relayed call as pending which needs to be executed. The transport layer client again tries to execute the pending relayed call which reverts again.\n*   Repeated execution of the above steps can deplete the gas reserves of transport layer client.\n\n\nsolidity\ncontract Foo {\n    function bar() public {\n        revert();\n    }\n}\n\n\n*   The attacker relays the Foo.bar() call in the CrossChainRelayer contract.\n*   The transport layer tries to invoke the Foo.bar() call by calling the CrossChainExecutor.executeCalls(). This transaction gets reverted.\n*   Since the relayed calls still seems as pending, the transport layer tries to invoke the Foo.bar() call again. This call should get reverted with CallsAlreadyExecuted error but it gets reverted with CallFailure error.\n\n",
                "Repair": "\nThe CrossChainExecutor contract should store whether a relayed call was attempted to be executed to make sure the execution cannot be tried again.\n\nThe CallLib library can be changed to not completely revert the transaction when any individual Call gets failed.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1339843628):\n  Not convinced by High Severity but the fact that you cannot determine whether calls were already attempted seems valid.\n\nPierrickGT (PoolTogether) confirmed, but disagreed with severity and commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1353499958):\n  Indeed, in the current implementation, it's pretty difficult to know which calls succeeded and which calls failed.\n \n So we've added two events:\n event CallSuccess(uint256 callIndex, bytes successData);\n event CallFailure(uint256 callIndex, bytes errorData);\n \n When a Call fails, we emit the CallFailure event and exit early the loop going through the batch calls.\n CallLib.executeCalls will return false and then the transaction will revert with the custom error ExecuteCallsFailed.\n \n If all calls have executed successfully, CallLib.executeCalls will return true and then the ExecutedCalls event will be emitted.\n \n This way, it's possible to know which calls succeeded and which didn't.<br\n If one Call fails, the entire transaction must revert cause the user may have intended to execute all the calls in one transaction and maybe some calls depends on others to succeed.\n \n I think this issue should be labeled as 2 (Med Risk) since it would indeed have been difficult for the transport layer client to figure out why the transaction failed and if it was worth replaying in the future.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1364420621):\n  I think the finding was well thought out and can tell it helped shaped the protocol.\n \n I believe Medium severity could be reasonably marked, however I think Low Severity to be the most appropriate one.\n \n Specifically:\n No loss of funds (beside gas happens)\n Similar architectures (e.g Chainlink Keepers), share the similar \"cannot tell if failed or not\"\n The responsibility for determining if the tx will fail is on the caller (relayer)\n \n For those reasons I believe QA Low (Notable finding for Relayer / Service Operators) to be the most appropriate.\n \n I will flag this during triage to get more opinions.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1365455690):\n  Some additional thinking I'm having is that a failed tx could remain un-broadcasted for an indefinite amount of time, and this could create issues for the receiving contract if / when the contract is made to not revert.\n\n  Specifically the fact that a failed tx can be relayed in the future (no expiration) seems to create a risk that can cause loss of value, which leads to me believe there is a valid argument for Medium Severity.\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1365508555):\n  After further thinking, I believe the most appropriate severity is Medium.\n \n The Warden has shown how the code allows the execution of old failed txs, while that is fine, I believe the lack of expiry can create situations in which a old message could be broadcasted and the broadcasting of it could cause a non idempotent behavior.\n \n The simplest example I can think of would be an unpause tx, that fails up until a set of contracts are paused, which would put a paused system (probably because of an exploit or the need for immediate stop) back into the unpaused state.\n \n While the externalities are multiple, I believe because:\n The general nature of the system\n The lack of expiration for old calls\n \n That Medium Severity is the most appropriate.\n \n Personally I would recommend considering a way to make calls expire after some time to avoid potential gotchas (or integrators may want to verify that via a nonce system or similar)\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 4 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/140) by 0xSmartContract received the top score from the judge.\n\n*The following wardens also submitted reports: cryptonue(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/204), ladboy233(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/112), and gzeon(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/79).*\n\n## Summary\n\n### Low Risk Issues List\n| Number |Issues Details|Context|\n|:--:|:-------|:--:|\n|[L-01]| Hard-coding the maxGasLimit variable may cause problems in the future | 3 |\n\nTotal 1 issue\n\n### Non-Critical Issues List\n| Number |Issues Details|Context|\n|:--:|:-------|:--:|\n| N-01]|For functions, follow Solidity standard naming conventions|4|\n| N-02] |Use a more recent version of Solidity |All contracts|\n| N-03] |For modern and more readable code; update import usages| 6 |\n| N-04] |Use of bytes.concat() instead of abi.encodePacked(,) | 1|\n| N-05] |Missing Event for critical parameters change | 4 |\n\nTotal 5 issues\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\n\n3 results 3 files\n\nsrc/ethereum-arbitrum/EthereumToArbitrumRelayer.sol:\n  36    /// @notice Gas limit provided for free on Arbitrum.\n  37:   uint256 public immutable maxGasLimit;\n  38  \n\nsrc/ethereum-optimism/EthereumToOptimismRelayer.sol:\n  25    /// @notice Gas limit provided for free on Optimism.\n  26:   uint256 public immutable maxGasLimit;\n  27  \n\nsrc/ethereum-polygon/EthereumToPolygonRelayer.sol:\n  19    /// @notice Gas limit provided for free on Polygon.\n  20:   uint256 public immutable maxGasLimit;\n"
                ],
                "Type": " Hard-coding the  maxGasLimit  variable may cause problems in the future",
                "Description": "\nThe variable maxGasLimit is defined as immutable and its value is assigned in constructor but cannot be changed later\n\nEVM-Based blockchains are hardforked and there is no such thing as Gas Limit etc. values may change, this has happened in the past, so it is recommended to have this value updated in the future\n\nsolidity\n\n3 results 3 files\n\nsrc/ethereum-arbitrum/EthereumToArbitrumRelayer.sol:\n  36    /// @notice Gas limit provided for free on Arbitrum.\n  37:   uint256 public immutable maxGasLimit;\n  38  \n\nsrc/ethereum-optimism/EthereumToOptimismRelayer.sol:\n  25    /// @notice Gas limit provided for free on Optimism.\n  26:   uint256 public immutable maxGasLimit;\n  27  \n\nsrc/ethereum-polygon/EthereumToPolygonRelayer.sol:\n  19    /// @notice Gas limit provided for free on Polygon.\n  20:   uint256 public immutable maxGasLimit;\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\n\n4 results 4 files\n\nsrc/ethereum-arbitrum/EthereumToArbitrumRelayer.sol:\n  40:   uint256 internal nonce;\n\nsrc/ethereum-optimism/EthereumToOptimismRelayer.sol:\n  29:   uint256 internal nonce;\n\nsrc/ethereum-polygon/EthereumToPolygonRelayer.sol:\n  23:   uint256 internal nonce;\n\nsrc/libraries/CallLib.sol:\n  48     */\n  49:   function executeCalls(\n  50:     uint256 _nonce,\n  51:     address _sender,\n  52:     Call[] memory _calls,\n  53:     bool _executedNonce\n  54:   ) internal {\n\n"
                ],
                "Type": " For functions, follow Solidity standard naming conventions",
                "Description": "\nContext:\n\nsolidity\n\n4 results 4 files\n\nsrc/ethereum-arbitrum/EthereumToArbitrumRelayer.sol:\n  40:   uint256 internal nonce;\n\nsrc/ethereum-optimism/EthereumToOptimismRelayer.sol:\n  29:   uint256 internal nonce;\n\nsrc/ethereum-polygon/EthereumToPolygonRelayer.sol:\n  23:   uint256 internal nonce;\n\nsrc/libraries/CallLib.sol:\n  48     */\n  49:   function executeCalls(\n  50:     uint256 _nonce,\n  51:     address _sender,\n  52:     Call[] memory _calls,\n  53:     bool _executedNonce\n  54:   ) internal {\n\n\n\nThe above codes don't follow Solidity's standard naming convention,\n\ninternal and private functions : the mixedCase format starting with an underscore (_mixedCase starting with an underscore)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\n6 results 5 files\n\nsrc/ethereum-arbitrum/EthereumToArbitrumExecutor.sol:\n  7: import \"../interfaces/ICrossChainExecutor.sol\";\n  8: import \"../libraries/CallLib.sol\";\n\nsrc/ethereum-arbitrum/EthereumToArbitrumRelayer.sol:\n  9: import \"../libraries/CallLib.sol\";\n\nsrc/ethereum-optimism/EthereumToOptimismRelayer.sol:\n  9: import \"../libraries/CallLib.sol\";\n\nsrc/ethereum-polygon/EthereumToPolygonExecutor.sol:\n  7: import \"../libraries/CallLib.sol\";\n\nsrc/ethereum-polygon/EthereumToPolygonRelayer.sol:\n  9: import \"../libraries/CallLib.sol\";\n\n",
                    "js\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n"
                ],
                "Type": " For modern and more readable code; update import usages",
                "Description": "\nContext:\n\nsolidity\n6 results 5 files\n\nsrc/ethereum-arbitrum/EthereumToArbitrumExecutor.sol:\n  7: import \"../interfaces/ICrossChainExecutor.sol\";\n  8: import \"../libraries/CallLib.sol\";\n\nsrc/ethereum-arbitrum/EthereumToArbitrumRelayer.sol:\n  9: import \"../libraries/CallLib.sol\";\n\nsrc/ethereum-optimism/EthereumToOptimismRelayer.sol:\n  9: import \"../libraries/CallLib.sol\";\n\nsrc/ethereum-polygon/EthereumToPolygonExecutor.sol:\n  7: import \"../libraries/CallLib.sol\";\n\nsrc/ethereum-polygon/EthereumToPolygonRelayer.sol:\n  9: import \"../libraries/CallLib.sol\";\n\n\n\nDescription:<br\nSolidity code is also cleaner in another way that might not be noticeable: the struct Point. We were importing it previously with global import but not using it. The Point struct polluted the source code with an unnecessary object we were not using because we did not need it.<br\nThis was breaking the rule of modularity and modular programming: only import what you need Specific imports with curly braces allow us to apply this rule better.\n\nRecommendation:<br\nimport {contract1 , contract2} from \"filename.sol\";\n\nA good example from the ArtGobblers project;\njs\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\n\nsrc/libraries/CallLib.sol:\n  62        Call memory _call = _calls[_callIndex];\n  63: \n  64:       (bool _success, bytes memory _returnData) = _call.target.call(\n  65:         abi.encodePacked(_call.data, _nonce, _sender)\n  66:       );\n\n"
                ],
                "Type": " Use of  bytes.concat()  instead of  abi.encodePacked(,) ",
                "Description": "\nsolidity\n\nsrc/libraries/CallLib.sol:\n  62        Call memory _call = _calls[_callIndex];\n  63: \n  64:       (bool _success, bytes memory _returnData) = _call.target.call(\n  65:         abi.encodePacked(_call.data, _nonce, _sender)\n  66:       );\n\n\nRather than using abi.encodePacked for appending bytes, since version 0.8.4, bytes.concat() is enabled\n\nSince version 0.8.4 for appending bytes, bytes.concat() can be used instead of abi.encodePacked(,).\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nsrc/ethereum-arbitrum/EthereumToArbitrumExecutor.sol:\n  51     */\n  52:   function setRelayer(ICrossChainRelayer _relayer) external {\n  53:     require(address(relayer) == address(0), \"Executor/relayer-already-set\");\n  54:     relayer = _relayer;\n  55:   }\n  56  \n\nsrc/ethereum-optimism/EthereumToOptimismExecutor.sol:\n  65     */\n  66:   function setRelayer(ICrossChainRelayer _relayer) external {\n  67:     require(address(relayer) == address(0), \"Executor/relayer-already-set\");\n  68:     relayer = _relayer;\n  69:   }\n  70 \n\nsrc/ethereum-arbitrum/EthereumToArbitrumRelayer.sol:\n  138     */\n  139:   function setExecutor(ICrossChainExecutor _executor) external {\n  140:     require(address(executor) == address(0), \"Relayer/executor-already-set\");\n  141:     executor = _executor;\n  142:   }\n  143  \n\nsrc/ethereum-optimism/EthereumToOptimismRelayer.sol:\n  84     */\n  85:   function setExecutor(ICrossChainExecutor _executor) external {\n  86:     require(address(executor) == address(0), \"Relayer/executor-already-set\");\n  87:     executor = _executor;\n  88:   }\n  89  }\n\n"
                ],
                "Type": " Missing Event for critical parameters change",
                "Description": "\nsolidity\nsrc/ethereum-arbitrum/EthereumToArbitrumExecutor.sol:\n  51     */\n  52:   function setRelayer(ICrossChainRelayer _relayer) external {\n  53:     require(address(relayer) == address(0), \"Executor/relayer-already-set\");\n  54:     relayer = _relayer;\n  55:   }\n  56  \n\nsrc/ethereum-optimism/EthereumToOptimismExecutor.sol:\n  65     */\n  66:   function setRelayer(ICrossChainRelayer _relayer) external {\n  67:     require(address(relayer) == address(0), \"Executor/relayer-already-set\");\n  68:     relayer = _relayer;\n  69:   }\n  70 \n\nsrc/ethereum-arbitrum/EthereumToArbitrumRelayer.sol:\n  138     */\n  139:   function setExecutor(ICrossChainExecutor _executor) external {\n  140:     require(address(executor) == address(0), \"Relayer/executor-already-set\");\n  141:     executor = _executor;\n  142:   }\n  143  \n\nsrc/ethereum-optimism/EthereumToOptimismRelayer.sol:\n  84     */\n  85:   function setExecutor(ICrossChainExecutor _executor) external {\n  86:     require(address(executor) == address(0), \"Relayer/executor-already-set\");\n  87:     executor = _executor;\n  88:   }\n  89  }\n\n\n\nDescription:<br\nEvents help non-contract tools to track changes, and events prevent users from being surprised by changes.\n\nRecommendation:<br\nAdd Event-Emit.\n\nPierrickGT (PoolTogether) confirmed and commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/140#issuecomment-1352512123):\n  I've confirmed the issue because some suggestions have been fixed.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/140#issuecomment-1365492604):\n  L-01] | Hard-coding the maxGasLimit variable may cause problems in the future | 3<br\n Low\n \n N-01] | For functions, follow Solidity standard naming conventions | 4<br\n Refactoring\n \n N-02] | Use a more recent version of Solidity | All contracts<br\n Non-Critical\n \n N-03] | For modern and more readable code; update import usages | 6<br\n Refactoring\n \n N-04] | Use of bytes.concat() instead of abi.encodePacked(,) | 1<br\n Non-Critical\n \n N-05] | Missing Event for critical parameters change<br\n Non-Critical\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 8 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/179) by Tricko received the top score from the judge.\n\n*The following wardens also submitted reports: adriro(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/214), cryptonue(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/210), Madalad(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/195), AkshaySrivastav(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/177), Rolezn(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/102), neko_nyaa(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/32), and 0x4non(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/22).*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "javascript\nmapping(uint256 = uint256) public executed;\n\n//setting executed nonce value to true\nuint256 baseIndex = _nonce / 256;\nuint256 index = _nonce (256 * baseIndex); \nuint256 mask = 1 << index;\nexecuted[baseIndex] |= mask;\n\n//getting the executed bool flag for a specific nonce\nuint256 baseIndex = _nonce / 256;\nuint256 index = _nonce (256 * baseIndex); \nuint256 mask = 1 << index;\nbool _executedNonce = (executed[baseIndex] & mask) != 0\n",
                    "diff\ndiff --git a/EthereumToArbitrumExecutor.sol.orig b/EthereumToArbitrumExecutor.sol\nindex bfee411..cbe299b 100644\n--a/EthereumToArbitrumExecutor.sol.orig\n+++ b/EthereumToArbitrumExecutor.sol\n@@ -23,7 +23,7 @@ contract CrossChainExecutorArbitrum is ICrossChainExecutor {\n    *         nonce = boolean\n    * @dev Ensure that batch of calls cannot be replayed once they have been executed.\n    */\n mapping(uint256 = bool) public executed;\n+  mapping(uint256 = uint256) public executed;\n \n   /* ============ External Functions ============ */\n \n@@ -36,8 +36,9 @@ contract CrossChainExecutorArbitrum is ICrossChainExecutor {\n     ICrossChainRelayer _relayer = relayer;\n     _isAuthorized(_relayer);\n \n   bool _executedNonce = executed[_nonce];\n   executed[_nonce] = true;\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    bool _executedNonce = (executed[baseIndex] & mask) != 0;\n+    executed[baseIndex] |= mask;\n \n     CallLib.executeCalls(_nonce, _sender, _calls, _executedNonce);\n \n@@ -54,6 +55,11 @@ contract CrossChainExecutorArbitrum is ICrossChainExecutor {\n     relayer = _relayer;\n   }\n \n+  function isExecuted(uint256 _nonce) external view returns (bool) {\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    return (executed[baseIndex] & mask) != 0;\n+  }\n+\n   /* ============ Internal Functions ============ */\n \n   /\n@@ -67,4 +73,11 @@ contract CrossChainExecutorArbitrum is ICrossChainExecutor {\n       \"Executor/sender-unauthorized\"\n     );\n   }\n+\n+  function _getBaseIndexAndMask(uint256 _nonce) internal view returns (uint256, uint256) {\n+    uint256 baseIndex = _nonce / 256;\n+    uint256 index = _nonce (256 * baseIndex);\n+    uint256 mask = 1 << index;\n+    return (baseIndex, mask);\n+  }\n }\n",
                    "diff\ndiff --git a/EthereumToOptimismExecutor.sol.orig b/EthereumToOptimismExecutor.sol\nindex 1aba9c1..6763b22 100644\n--a/EthereumToOptimismExecutor.sol.orig\n+++ b/EthereumToOptimismExecutor.sol\n@@ -26,7 +26,7 @@ contract CrossChainExecutorOptimism is ICrossChainExecutor {\n    *         nonce = boolean\n    * @dev Ensure that batch of calls cannot be replayed once they have been executed.\n    */\n mapping(uint256 = bool) public executed;\n+  mapping(uint256 = uint256) public executed;\n \n   /* ============ Constructor ============ */\n \n@@ -50,8 +50,9 @@ contract CrossChainExecutorOptimism is ICrossChainExecutor {\n     ICrossChainRelayer _relayer = relayer;\n     _isAuthorized(_relayer);\n \n   bool _executedNonce = executed[_nonce];\n   executed[_nonce] = true;\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    bool _executedNonce = (executed[baseIndex] & mask) != 0;\n+    executed[baseIndex] |= mask;\n \n     CallLib.executeCalls(_nonce, _sender, _calls, _executedNonce);\n \n@@ -68,6 +69,11 @@ contract CrossChainExecutorOptimism is ICrossChainExecutor {\n     relayer = _relayer;\n   }\n \n+  function isExecuted(uint256 _nonce) external view returns (bool) {\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    return (executed[baseIndex] & mask) != 0;\n+  }\n+\n   /* ============ Internal Functions ============ */\n \n   /\n@@ -83,4 +89,11 @@ contract CrossChainExecutorOptimism is ICrossChainExecutor {\n       \"Executor/sender-unauthorized\"\n     );\n   }\n+\n+  function _getBaseIndexAndMask(uint256 _nonce) internal view returns (uint256, uint256) {\n+    uint256 baseIndex = _nonce / 256;\n+    uint256 index = _nonce (256 * baseIndex);\n+    uint256 mask = 1 << index;\n+    return (baseIndex, mask);\n+  }\n }\n",
                    "diff\ndiff --git a/EthereumToPolygonExecutor.sol.orig b/EthereumToPolygonExecutor.sol\nindex 29bc54f..9c0df8c 100644\n--a/EthereumToPolygonExecutor.sol.orig\n+++ b/EthereumToPolygonExecutor.sol\n@@ -28,7 +28,7 @@ contract CrossChainExecutorPolygon is FxBaseChildTunnel {\n    *         nonce = boolean\n    * @dev Ensure that batch of calls cannot be replayed once they have been executed.\n    */\n mapping(uint256 = bool) public executed;\n+  mapping(uint256 = uint256) public executed;\n \n   /* ============ Constructor ============ */\n \n@@ -51,11 +51,24 @@ contract CrossChainExecutorPolygon is FxBaseChildTunnel {\n       (uint256, address, CallLib.Call[])\n     );\n \n   bool _executedNonce = executed[_nonce];\n   executed[_nonce] = true;\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    bool _executedNonce = (executed[baseIndex] & mask) != 0;\n+    executed[baseIndex] |= mask;\n \n     CallLib.executeCalls(_nonce, _callsSender, _calls, _executedNonce);\n \n     emit ExecutedCalls(_sender, _nonce);\n   }\n+\n+  function isExecuted(uint256 _nonce) external view returns (bool) {\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    return (executed[baseIndex] & mask) != 0;\n+  }\n+\n+  function _getBaseIndexAndMask(uint256 _nonce) internal view returns (uint256, uint256) {\n+    uint256 baseIndex = _nonce / 256;\n+    uint256 index = _nonce (256 * baseIndex);\n+    uint256 mask = 1 << index;\n+    return (baseIndex, mask);\n+  }\n }\n",
                    "diff\ndiff --git a/EthereumToArbitrumExecutor.t.sol.orig b/EthereumToArbitrumExecutor.t.sol\nindex 942d92d..37e7161 100644\n--a/EthereumToArbitrumExecutor.t.sol.orig\n+++ b/EthereumToArbitrumExecutor.t.sol\n@@ -70,7 +70,7 @@ contract CrossChainExecutorArbitrumUnitTest is Test {\n \n     executor.executeCalls(nonce, sender, calls);\n \n   assertTrue(executor.executed(nonce));\n+    assertTrue(executor.isExecuted(nonce));\n   }\n \n   function testExecuteCallsAlreadyExecuted() public {\n@@ -90,6 +90,17 @@ contract CrossChainExecutorArbitrumUnitTest is Test {\n     executor.executeCalls(nonce, sender, calls);\n   }\n \n+  function testExecuteCallsBenchmark() public {\n+    setRelayer();\n+\n+    vm.startPrank(relayerAlias);\n+\n+    for (uint256 i; i < 100; i++) {\n+      executor.executeCalls(nonce, sender, calls);\n+      nonce++;\n+    }\n+  }\n+\n   /* ============ Setters ============ */\n \n   function testSetRelayer() public {\n",
                    "diff\ndiff --git a/EthereumToOptimismFork.t.sol.orig b/EthereumToOptimismFork.t.sol\nindex be84235..ed2d2e7 100644\n--a/EthereumToOptimismFork.t.sol.orig\n+++ b/EthereumToOptimismFork.t.sol\n@@ -194,6 +194,39 @@ contract EthereumToOptimismForkTest is Test {\n     assertEq(greeter.greet(), l1Greeting);\n   }\n \n+  function testExecuteCallsBenchmark() public {\n+    deployAll();\n+    setAll();\n+\n+    vm.selectFork(optimismFork);\n+\n+    CallLib.Call[] memory _calls = new CallLib.Call[(1);\n+\n+    _calls[0] = CallLib.Call({\n+      target: address(greeter),\n+      data: abi.encodeWithSignature(\"setGreeting(string)\", l1Greeting)\n+    });\n+\n+    L2CrossDomainMessenger l2Bridge = L2CrossDomainMessenger(l2CrossDomainMessenger);\n+\n+    vm.startPrank(AddressAliasHelper.applyL1ToL2Alias(proxyOVML1CrossDomainMessenger));\n+\n+    for (uint256 i; i < 100; i++) {\n+      l2Bridge.relayMessage(\n+        address(executor),\n+        address(relayer),\n+        abi.encodeWithSignature(\n+          \"executeCalls(uint256,address,(address,bytes)[])\",\n+          nonce,\n+          address(this),\n+          _calls\n+        ),\n+        l2Bridge.messageNonce() + 1\n+      );\n+      nonce++;\n+    }\n+  }\n+\n   function testGasLimitTooHigh() public {\n     deployAll();\n     setAll();\n",
                    "diff\ndiff --git a/EthereumToPolygonFork.t.sol.orig b/EthereumToPolygonFork.t.sol\nindex 01913e6..eaad5f2 100644\n--a/EthereumToPolygonFork.t.sol.orig\n+++ b/EthereumToPolygonFork.t.sol\n@@ -179,6 +179,31 @@ contract EthereumToPolygonForkTest is Test {\n     assertEq(greeter.greet(), l1Greeting);\n   }\n \n+  function testExecuteCallsBenchmark() public {\n+    deployAll();\n+    setAll();\n+\n+    vm.selectFork(polygonFork);\n+\n+    CallLib.Call[] memory _calls = new CallLib.Call[(1);\n+\n+    _calls[0] = CallLib.Call({\n+      target: address(greeter),\n+      data: abi.encodeWithSignature(\"setGreeting(string)\", l1Greeting)\n+    });\n+\n+    vm.startPrank(fxChild);\n+\n+    for (uint256 i; i < 100; i++) {\n+      executor.processMessageFromRoot(\n+        1,\n+        address(relayer),\n+        abi.encode(nonce, address(this), _calls)\n+      );\n+      nonce++;\n+    }\n+  }\n+\n   function testGasLimitTooHigh() public {\n     deployAll();\n"
                ],
                "Type": " Use bitmaps to save gas",
                "Description": "\nDuring calls to executeCalls (and processMessageFromRoot in the Polygon executor) the executed mapping is updated, setting the bool flag to true, but because the way the EVM works it allocates an entire storage slot (256 bits) every time a new flag is set. SSTORE opcode cost up to 20000 gas for uninitialized slots like these. Consider using bitmaps instead, this enables you to convert the mapping(uint256 = bool) to a mapping(uint256 = uint256) and pay the cost of slot initialization just once every 256 nonces added, so the high gas costs are amortized over many calls.\n\nEach group of 256 sequential nonces values (0-255, 256-511, ...) are stored together in a single uint256, where each bit represents a bool. The correct index of each nonce inside each bitmap can be calculated by nonce mod 256. An exemplified implementation is shown below (For complete implementations see Modifications section)\n\njavascript\nmapping(uint256 = uint256) public executed;\n\n//setting executed nonce value to true\nuint256 baseIndex = _nonce / 256;\nuint256 index = _nonce (256 * baseIndex); \nuint256 mask = 1 << index;\nexecuted[baseIndex] |= mask;\n\n//getting the executed bool flag for a specific nonce\nuint256 baseIndex = _nonce / 256;\nuint256 index = _nonce (256 * baseIndex); \nuint256 mask = 1 << index;\nbool _executedNonce = (executed[baseIndex] & mask) != 0\n\n\nThe full extent of the gas reduction from these changes cannot be seen using the tests present in the repo, as during the tests executeCalls are called at most a few times, so the effect of amortization cannot be seen, underestimating the effect of these changes. Extra tests were added to enable benchmarking more realistic conditions (See modifications section below), where executeCalls is called 100 times in sequence, simulating many user interacting with the contract during normal operating conditions. Using those benchmarks, we obtain the following results.\n\n|                                                    | avg. gas (before modification) | avg. gas (after modification) | gas diff         |\n|----------------------------------------------------|--------------------------------|-------------------------------|------------------|\n| CrossChainExecutorArbitrum executeCalls          | 31322                          | 9980                          | -21342 (-68.1%)  |\n| CrossChainExecutorOptimism executeCalls          | 32241                          | 10899                         | -21342 (-66.2%)  |\n| CrossChainExecutorPolygon processMessageFromRoot | 32279                          | 10940                         | -21339 (-66.1%)  |\n| Total                                              | 95842                          | 31819                         | -64023 (-66.8%)  |\n\n*Values obtained by running forge test --match-test Benchmark --gas-report\n\n\nhttps://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumExecutor.sol\ndiff\ndiff --git a/EthereumToArbitrumExecutor.sol.orig b/EthereumToArbitrumExecutor.sol\nindex bfee411..cbe299b 100644\n--a/EthereumToArbitrumExecutor.sol.orig\n+++ b/EthereumToArbitrumExecutor.sol\n@@ -23,7 +23,7 @@ contract CrossChainExecutorArbitrum is ICrossChainExecutor {\n    *         nonce = boolean\n    * @dev Ensure that batch of calls cannot be replayed once they have been executed.\n    */\n mapping(uint256 = bool) public executed;\n+  mapping(uint256 = uint256) public executed;\n \n   /* ============ External Functions ============ */\n \n@@ -36,8 +36,9 @@ contract CrossChainExecutorArbitrum is ICrossChainExecutor {\n     ICrossChainRelayer _relayer = relayer;\n     _isAuthorized(_relayer);\n \n   bool _executedNonce = executed[_nonce];\n   executed[_nonce] = true;\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    bool _executedNonce = (executed[baseIndex] & mask) != 0;\n+    executed[baseIndex] |= mask;\n \n     CallLib.executeCalls(_nonce, _sender, _calls, _executedNonce);\n \n@@ -54,6 +55,11 @@ contract CrossChainExecutorArbitrum is ICrossChainExecutor {\n     relayer = _relayer;\n   }\n \n+  function isExecuted(uint256 _nonce) external view returns (bool) {\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    return (executed[baseIndex] & mask) != 0;\n+  }\n+\n   /* ============ Internal Functions ============ */\n \n   /\n@@ -67,4 +73,11 @@ contract CrossChainExecutorArbitrum is ICrossChainExecutor {\n       \"Executor/sender-unauthorized\"\n     );\n   }\n+\n+  function _getBaseIndexAndMask(uint256 _nonce) internal view returns (uint256, uint256) {\n+    uint256 baseIndex = _nonce / 256;\n+    uint256 index = _nonce (256 * baseIndex);\n+    uint256 mask = 1 << index;\n+    return (baseIndex, mask);\n+  }\n }\n\n\nhttps://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-optimism/EthereumToOptimismExecutor.sol\ndiff\ndiff --git a/EthereumToOptimismExecutor.sol.orig b/EthereumToOptimismExecutor.sol\nindex 1aba9c1..6763b22 100644\n--a/EthereumToOptimismExecutor.sol.orig\n+++ b/EthereumToOptimismExecutor.sol\n@@ -26,7 +26,7 @@ contract CrossChainExecutorOptimism is ICrossChainExecutor {\n    *         nonce = boolean\n    * @dev Ensure that batch of calls cannot be replayed once they have been executed.\n    */\n mapping(uint256 = bool) public executed;\n+  mapping(uint256 = uint256) public executed;\n \n   /* ============ Constructor ============ */\n \n@@ -50,8 +50,9 @@ contract CrossChainExecutorOptimism is ICrossChainExecutor {\n     ICrossChainRelayer _relayer = relayer;\n     _isAuthorized(_relayer);\n \n   bool _executedNonce = executed[_nonce];\n   executed[_nonce] = true;\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    bool _executedNonce = (executed[baseIndex] & mask) != 0;\n+    executed[baseIndex] |= mask;\n \n     CallLib.executeCalls(_nonce, _sender, _calls, _executedNonce);\n \n@@ -68,6 +69,11 @@ contract CrossChainExecutorOptimism is ICrossChainExecutor {\n     relayer = _relayer;\n   }\n \n+  function isExecuted(uint256 _nonce) external view returns (bool) {\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    return (executed[baseIndex] & mask) != 0;\n+  }\n+\n   /* ============ Internal Functions ============ */\n \n   /\n@@ -83,4 +89,11 @@ contract CrossChainExecutorOptimism is ICrossChainExecutor {\n       \"Executor/sender-unauthorized\"\n     );\n   }\n+\n+  function _getBaseIndexAndMask(uint256 _nonce) internal view returns (uint256, uint256) {\n+    uint256 baseIndex = _nonce / 256;\n+    uint256 index = _nonce (256 * baseIndex);\n+    uint256 mask = 1 << index;\n+    return (baseIndex, mask);\n+  }\n }\n\n\nhttps://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-polygon/EthereumToPolygonExecutor.sol\ndiff\ndiff --git a/EthereumToPolygonExecutor.sol.orig b/EthereumToPolygonExecutor.sol\nindex 29bc54f..9c0df8c 100644\n--a/EthereumToPolygonExecutor.sol.orig\n+++ b/EthereumToPolygonExecutor.sol\n@@ -28,7 +28,7 @@ contract CrossChainExecutorPolygon is FxBaseChildTunnel {\n    *         nonce = boolean\n    * @dev Ensure that batch of calls cannot be replayed once they have been executed.\n    */\n mapping(uint256 = bool) public executed;\n+  mapping(uint256 = uint256) public executed;\n \n   /* ============ Constructor ============ */\n \n@@ -51,11 +51,24 @@ contract CrossChainExecutorPolygon is FxBaseChildTunnel {\n       (uint256, address, CallLib.Call[])\n     );\n \n   bool _executedNonce = executed[_nonce];\n   executed[_nonce] = true;\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    bool _executedNonce = (executed[baseIndex] & mask) != 0;\n+    executed[baseIndex] |= mask;\n \n     CallLib.executeCalls(_nonce, _callsSender, _calls, _executedNonce);\n \n     emit ExecutedCalls(_sender, _nonce);\n   }\n+\n+  function isExecuted(uint256 _nonce) external view returns (bool) {\n+    (uint256 baseIndex, uint256 mask) = _getBaseIndexAndMask(_nonce);\n+    return (executed[baseIndex] & mask) != 0;\n+  }\n+\n+  function _getBaseIndexAndMask(uint256 _nonce) internal view returns (uint256, uint256) {\n+    uint256 baseIndex = _nonce / 256;\n+    uint256 index = _nonce (256 * baseIndex);\n+    uint256 mask = 1 << index;\n+    return (baseIndex, mask);\n+  }\n }\n\n\nhttps://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/test/unit/ethereum-arbitrum/EthereumToArbitrumExecutor.t.sol\ndiff\ndiff --git a/EthereumToArbitrumExecutor.t.sol.orig b/EthereumToArbitrumExecutor.t.sol\nindex 942d92d..37e7161 100644\n--a/EthereumToArbitrumExecutor.t.sol.orig\n+++ b/EthereumToArbitrumExecutor.t.sol\n@@ -70,7 +70,7 @@ contract CrossChainExecutorArbitrumUnitTest is Test {\n \n     executor.executeCalls(nonce, sender, calls);\n \n   assertTrue(executor.executed(nonce));\n+    assertTrue(executor.isExecuted(nonce));\n   }\n \n   function testExecuteCallsAlreadyExecuted() public {\n@@ -90,6 +90,17 @@ contract CrossChainExecutorArbitrumUnitTest is Test {\n     executor.executeCalls(nonce, sender, calls);\n   }\n \n+  function testExecuteCallsBenchmark() public {\n+    setRelayer();\n+\n+    vm.startPrank(relayerAlias);\n+\n+    for (uint256 i; i < 100; i++) {\n+      executor.executeCalls(nonce, sender, calls);\n+      nonce++;\n+    }\n+  }\n+\n   /* ============ Setters ============ */\n \n   function testSetRelayer() public {\n\n\nhttps://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/test/fork/EthereumToOptimismFork.t.sol\ndiff\ndiff --git a/EthereumToOptimismFork.t.sol.orig b/EthereumToOptimismFork.t.sol\nindex be84235..ed2d2e7 100644\n--a/EthereumToOptimismFork.t.sol.orig\n+++ b/EthereumToOptimismFork.t.sol\n@@ -194,6 +194,39 @@ contract EthereumToOptimismForkTest is Test {\n     assertEq(greeter.greet(), l1Greeting);\n   }\n \n+  function testExecuteCallsBenchmark() public {\n+    deployAll();\n+    setAll();\n+\n+    vm.selectFork(optimismFork);\n+\n+    CallLib.Call[] memory _calls = new CallLib.Call[(1);\n+\n+    _calls[0] = CallLib.Call({\n+      target: address(greeter),\n+      data: abi.encodeWithSignature(\"setGreeting(string)\", l1Greeting)\n+    });\n+\n+    L2CrossDomainMessenger l2Bridge = L2CrossDomainMessenger(l2CrossDomainMessenger);\n+\n+    vm.startPrank(AddressAliasHelper.applyL1ToL2Alias(proxyOVML1CrossDomainMessenger));\n+\n+    for (uint256 i; i < 100; i++) {\n+      l2Bridge.relayMessage(\n+        address(executor),\n+        address(relayer),\n+        abi.encodeWithSignature(\n+          \"executeCalls(uint256,address,(address,bytes)[])\",\n+          nonce,\n+          address(this),\n+          _calls\n+        ),\n+        l2Bridge.messageNonce() + 1\n+      );\n+      nonce++;\n+    }\n+  }\n+\n   function testGasLimitTooHigh() public {\n     deployAll();\n     setAll();\n\n\nhttps://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/test/fork/EthereumToPolygonFork.t.sol\ndiff\ndiff --git a/EthereumToPolygonFork.t.sol.orig b/EthereumToPolygonFork.t.sol\nindex 01913e6..eaad5f2 100644\n--a/EthereumToPolygonFork.t.sol.orig\n+++ b/EthereumToPolygonFork.t.sol\n@@ -179,6 +179,31 @@ contract EthereumToPolygonForkTest is Test {\n     assertEq(greeter.greet(), l1Greeting);\n   }\n \n+  function testExecuteCallsBenchmark() public {\n+    deployAll();\n+    setAll();\n+\n+    vm.selectFork(polygonFork);\n+\n+    CallLib.Call[] memory _calls = new CallLib.Call[(1);\n+\n+    _calls[0] = CallLib.Call({\n+      target: address(greeter),\n+      data: abi.encodeWithSignature(\"setGreeting(string)\", l1Greeting)\n+    });\n+\n+    vm.startPrank(fxChild);\n+\n+    for (uint256 i; i < 100; i++) {\n+      executor.processMessageFromRoot(\n+        1,\n+        address(relayer),\n+        abi.encode(nonce, address(this), _calls)\n+      );\n+      nonce++;\n+    }\n+  }\n+\n   function testGasLimitTooHigh() public {\n     deployAll();\n\n\nPierrickGT (PoolTogether) acknowledged and commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/179#issuecomment-1353700299):\n  Very interesting optimization but it does complexify the code quite a bit.<br\n So for this reason, I've acknowledged the issue but we won't implement the suggestion.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-12-pooltogether-findings/issues/179#issuecomment-1365474238):\n  I believe that in the spirit of Gas Reports, the report has shown:\n A refactoring with code snippets\n It's fully benchmarked\n \n Am accepting the finding as valid, and because it effectively saves one SSTORE on each operation, I believe 20k gas to be the appropriate amount saved\n \n 20_000\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    }
]