[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../internal/nTokenHandler.sol\";\nimport \"../../internal/markets/AssetRate.sol\";\nimport \"../../internal/balances/BalanceHandler.sol\";\nimport \"../../internal/balances/Incentives.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"interfaces/notional/nTokenERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract nTokenAction is StorageLayoutV1, nTokenERC20 {\n    using BalanceHandler for BalanceState;\n    using AssetRate for AssetRateParameters;\n    using AccountContextHandler for AccountContext;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    /// @notice Total number of tokens in circulation\n    /// @param nTokenAddress The address of the nToken\n    /// @return totalSupply number of tokens held\n    function nTokenTotalSupply(address nTokenAddress)\n        external\n        view\n        override\n        returns (uint256 totalSupply)\n    {\n        // prettier-ignore\n        (\n            totalSupply,\n            /* integralTotalSupply */,\n            /* lastSupplyChangeTime */\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function nTokenBalanceOf(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // prettier-ignore\n        (\n            /* int cashBalance */,\n            int256 nTokenBalance,\n            /* uint lastClaimTime */,\n            /* uint lastClaimIntegralSupply */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n\n        require(nTokenBalance >= 0); // dev: negative nToken balance\n        return uint256(nTokenBalance);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param owner The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function nTokenTransferAllowance(\n        uint16 currencyId,\n        address owner,\n        address spender\n    ) external view override returns (uint256) {\n        // This whitelist allowance supersedes any specific allowances\n        uint256 allowance = nTokenWhitelist[owner][spender];\n        if (allowance > 0) return allowance;\n\n        return nTokenAllowance[owner][spender][currencyId];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev Can only be called via the nToken proxy\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApprove(\n        uint16 currencyId,\n        address owner,\n        address spender,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        nTokenAllowance[owner][spender][currencyId] = amount;\n\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param from The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransfer(\n        uint16 currencyId,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        return _transfer(currencyId, from, to, amount);\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param currencyId Currency id of the nToken\n    /// @param spender The address of the original caller\n    /// @param from The address of the source account\n    /// @param to The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransferFrom(\n        uint16 currencyId,\n        address spender,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool, uint256) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        uint256 allowance = nTokenWhitelist[from][spender];\n\n        if (allowance > 0) {\n            // This whitelist allowance supersedes any specific allowances\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenWhitelist[from][spender] = allowance;\n        } else {\n            // This is the specific allowance for the nToken.\n            allowance = nTokenAllowance[from][spender][currencyId];\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenAllowance[from][spender][currencyId] = allowance;\n        }\n\n        bool success = _transfer(currencyId, from, to, amount);\n        return (success, allowance);\n    }\n\n    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve\n    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly\n    /// on the Notional contract, not available via the ERC20 proxy.\n    /// @dev emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApproveAll(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        nTokenWhitelist[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender\n    /// @dev auth:msg.sender\n    /// @return Total amount of incentives claimed\n    function nTokenClaimIncentives() external override returns (uint256) {\n        address account = msg.sender;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        uint256 totalIncentivesClaimed;\n        BalanceState memory balanceState;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n\n            currencies = currencies << 16;\n        }\n\n        // NOTE: no need to set account context after claiming incentives\n        return totalIncentivesClaimed;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in asset tokens\n    function nTokenPresentValueAssetDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* portfolio */\n        ) = _getNTokenPV(currencyId);\n\n        return totalAssetPV;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in underlying\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);\n\n        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);\n    }\n\n    function _getNTokenPV(uint256 currencyId)\n        private\n        view\n        returns (int256, nTokenPortfolio memory)\n    {\n        uint256 blockTime = block.timestamp;\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* ifCashMapping */\n        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);\n\n        return (totalAssetPV, nToken);\n    }\n\n    /// @notice Transferring tokens will also claim incentives at the same time\n    function _transfer(\n        uint256 currencyId,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        {\n            // prettier-ignore\n            (\n                uint256 isNToken,\n                /* incentiveAnnualEmissionRate */,\n                /* lastInitializedTime */,\n                /* parameters */\n            ) = nTokenHandler.getNTokenContext(recipient);\n            // nTokens cannot hold nToken balances\n            require(isNToken == 0, \"Cannot transfer to nToken\");\n        }\n\n        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);\n        BalanceState memory senderBalance;\n        senderBalance.loadBalanceState(sender, currencyId, senderContext);\n\n        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);\n        BalanceState memory recipientBalance;\n        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);\n\n        int256 amountInt = SafeCast.toInt256(amount);\n        senderBalance.netNTokenTransfer = amountInt.neg();\n        recipientBalance.netNTokenTransfer = amountInt;\n\n        senderBalance.finalize(sender, senderContext, false);\n        recipientBalance.finalize(recipient, recipientContext, false);\n        senderContext.setAccountContext(sender);\n        recipientContext.setAccountContext(recipient);\n\n        emit Transfer(sender, recipient, amount);\n\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "nTokenAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Self transfer can lead to unlimited mint",
                "Description": "\nThe implementation of the transfer function in nTokenAction.sol( https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol) is different from the usual erc20 token transfer function.\n\n This happens because it counts the incentive that the user gets, but with a self-transfer,  it can lead to unlimited mint. In L278(https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#_L278), it makes the amount negative, but in L279(https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279), it returns the value to an amount that is not negative. So, in the L281-282(https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282), it finalizes a positive value, only because the negative value is changed to the positive value.\n\n You can interact with this transfer function through nTokenERC20Proxy.sol(https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol).\n\n",
                "Repair": "Recommend adding (sender != recipient).\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "nTokenAllowance",
                    "nTokenWhitelist"
                ],
                "Type": " Allowance checks not correctly implemented",
                "Description": "\nThe nTokenAction implements two token approvals, the nTokenWhitelist which is always used first, and the nTokenAllowance which is checked second.\nIf the nTokenWhitelist does _not_ have enough allowance for the transfer, the transaction fails, even in the case where nTokenAllowance still has enough allowance.\n\nTransfers that have sufficient allowance fail in certain cases.\n\n",
                "Repair": "Recommend that, instead of reverting if the nTokenWhitelist allowance is not enough, default to the nTokenAllowance case.\n\nSomething like this:\n\nsolidity\nuint256 requiredAllowance = amount;\n\nuint256 allowance = nTokenWhitelist[from][spender];\n// use whitelist allowance first\nif (allowance  0) {\n    uint256 min = amount < allowance ? amount : allowance;\n    requiredAllowance -= min;\n    allowance = allowance.sub(min);\n    nTokenWhitelist[from][spender] = allowance;\n}\n\n// use currency-specific allowance now\nif(requiredAllowance  0)\n    // This is the specific allowance for the nToken.\n    allowance = nTokenAllowance[from][spender][currencyId];\n    require(allowance = requiredAllowance, \"Insufficient allowance\");\n    allowance = allowance.sub(requiredAllowance);\n    nTokenAllowance[from][spender][currencyId] = allowance;\n}\n\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/66)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/INoteERC20.sol\";\nimport \"@openzeppelin/contracts/access/TimelockController.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Notional Governor Alpha\n * Fork of Compound Governor Alpha at commit hash\n * https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\n */\ncontract GovernorAlpha is TimelockController {\n    /// @notice The name of this contract\n    string public constant name = \"Notional Governor Alpha\";\n\n    /// @notice The address of the Notional governance token\n    INoteERC20 public immutable note;\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint8 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n    /// @notice The minimum voting period in blocks, about 1 day assuming 13 second blocks. Ensures that proposals will always have\n    /// time to be voted on.\n    uint32 public constant MIN_VOTING_PERIOD_BLOCKS = 6700;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed\n    uint96 public quorumVotes;\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    uint96 public proposalThreshold;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    uint32 public votingDelayBlocks;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint32 public votingPeriodBlocks;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // The timestamp at which voting begins: holders must delegate their votes prior to this block\n        uint32 startBlock;\n        // The timestamp at which voting ends: votes must be cast prior to this block\n        uint32 endBlock;\n        // Current number of votes in favor of this proposal\n        uint96 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint96 againstVotes;\n        // Creator of the proposal\n        address proposer;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Hash of the operation to reduce storage cost\n        bytes32 operationHash;\n    }\n\n    // Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public receipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct uComp by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 indexed id,\n        address indexed proposer,\n        address[] targets,\n        uint256[] values,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address indexed voter, uint256 indexed proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 indexed id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 indexed id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 indexed id);\n\n    /// @notice An event emitted when amount of quorum votes required is updated\n    event UpdateQuorumVotes(uint96 newQuorumVotes);\n\n    /// @notice An event emitted when a new proposal threshold has been set\n    event UpdateProposalThreshold(uint96 newProposalThreshold);\n\n    /// @notice An event emitted when a new voting delay in blocks has been set\n    event UpdateVotingDelayBlocks(uint32 newVotingDelayBlocks);\n\n    /// @notice An event emitted when a new voting period in blocks has been set\n    event UpdateVotingPeriodBlocks(uint32 newVotingPeriodBlocks);\n\n    /// @notice Emitted when the guardian abdicates their role\n    event Abdicate();\n\n    /// @notice An event emitted when guardian is transferred\n    event TransferGuardian(address newGuardian);\n    \n    /// @notice Initializes the GovernorAlpha with initial parameters\n    /// @param quorumVotes_ initial quorum votes value\n    /// @param proposalThreshold_ initial proposal threshold value\n    /// @param votingDelayBlocks_ initial voting delay blocks value\n    /// @param votingPeriodBlocks_ initial voting period blocks value\n    /// @param note_ address of the NOTE token to get voting power\n    /// @param guardian_ address of guardian\n    /// @param minDelay_ initial minimum delay for timelock in seconds\n    constructor(\n        uint96 quorumVotes_,\n        uint96 proposalThreshold_,\n        uint32 votingDelayBlocks_,\n        uint32 votingPeriodBlocks_,\n        address note_,\n        address guardian_,\n        uint256 minDelay_\n    ) TimelockController(minDelay_, new address[](0), new address[](0)) {\n        require(Address.isContract(note_));\n\n        quorumVotes = quorumVotes_;\n        proposalThreshold = proposalThreshold_;\n        votingDelayBlocks = votingDelayBlocks_;\n        // Do not enforce MIN_VOTING_DELAY during constructor so that tests don't require a large number\n        // of blocks for the voting period. During actual mainnet deployment this will be set to a reasonable value.\n        votingPeriodBlocks = votingPeriodBlocks_;\n        note = INoteERC20(note_);\n        guardian = guardian_;\n\n        // Only the external methods can be used to execute governance\n        grantRole(PROPOSER_ROLE, address(this));\n        grantRole(EXECUTOR_ROLE, address(this));\n        revokeRole(TIMELOCK_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @notice Proposes a new governance action\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalCreated\n    /// @return newly created proposal id\n    function propose(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external returns (uint256) {\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber < type(uint32).max);\n\n        require(\n            note.getPriorVotes(msg.sender, blockNumber - 1) > proposalThreshold,\n            \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(\n            targets.length <= PROPOSAL_MAX_OPERATIONS,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        {\n            uint256 latestProposalId = latestProposalIds[msg.sender];\n            if (latestProposalId != 0) {\n                ProposalState proposersLatestProposalState = state(latestProposalId);\n                require(\n                    proposersLatestProposalState != ProposalState.Active,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n                );\n                require(\n                    proposersLatestProposalState != ProposalState.Pending,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n                );\n            }\n        }\n\n        uint256 newProposalId = proposalCount + 1;\n        proposalCount = newProposalId;\n\n        uint32 startBlock = _add32(uint32(blockNumber), votingDelayBlocks);\n        uint32 endBlock = _add32(startBlock, votingPeriodBlocks);\n        bytes32 operationHash = _computeHash(targets, values, calldatas, newProposalId);\n\n        Proposal memory newProposal =\n            Proposal({\n                id: newProposalId,\n                proposer: msg.sender,\n                startBlock: startBlock,\n                endBlock: endBlock,\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false,\n                operationHash: operationHash\n            });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            calldatas,\n            startBlock,\n            endBlock\n        );\n        return newProposal.id;\n    }\n\n    /// @dev Helper method required to clear the stack for hashing operations\n    function _computeHash(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private pure returns (bytes32) {\n        return hashOperationBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));\n    }\n\n    /// @notice Adds a proposal to the timelock queue only after its vote has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal. All proposals\n    /// will automatically be delayed `getMinDelay()` seconds.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalQueued emit:CallScheduled (per call)\n    function queueProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external {\n        require(state(proposalId) == ProposalState.Succeeded, \"Proposal must be success\");\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        {\n            Proposal storage proposal = proposals[proposalId];\n            require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        }\n\n        _scheduleBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalQueued(proposalId, getMinDelay());\n    }\n\n    /// @dev Required to clear the stack for calling the timelock controller\n    function _scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        // NOTE: this will also emit events\n        this.scheduleBatch(\n            targets,\n            values,\n            calldatas,\n            bytes32(0),\n            bytes32(proposalId),\n            getMinDelay()\n        );\n    }\n\n    /// @notice Executes a proposal in the timelock queue after its delay has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalExecuted emit:CallExecuted (per call)\n    function executeProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external payable {\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        // Execute batch will revert if the call has not been scheduled\n        _executeBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalExecuted(proposalId);\n    }\n\n    /// @dev Helper function to clear the stack for the timelock controller call\n    function _executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        this.executeBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));\n    }\n\n    /// @notice Cancels a proposal after it has been created. Can only be done if the proposer\n    /// no longer has sufficient votes (i.e. they made a proposal and then sold their tokens) or\n    /// by a guardian address if it exists.\n    /// @param proposalId unique identifier for the proposal\n    /// @dev emit:ProposalCanceled emit:Canceled\n    function cancelProposal(uint256 proposalId) public {\n        ProposalState proposalState = state(proposalId);\n        require(proposalState != ProposalState.Executed, \"Proposal already executed\");\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber <= type(uint32).max);\n        require(\n            msg.sender == guardian ||\n                note.getPriorVotes(proposal.proposer, blockNumber - 1) < proposalThreshold,\n            \"GovernorAlpha::cancel: proposer above threshold\"\n        );\n\n        proposal.canceled = true;\n        // Removes the operation hash from the timelock controller if pending.\n        if (isOperationPending(proposal.operationHash)) this.cancel(proposal.operationHash);\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /// @notice Returns the voting receipt for a voter on a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param voter address of the voter\n    /// @return the voting receipt for the voter and proposal\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return receipts[proposalId][voter];\n    }\n\n    /// @notice Returns the current state of a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @return ProposalState enum for the current state of the proposal\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n        Proposal memory proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber <= type(uint32).max);\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (blockNumber <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (blockNumber <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (isOperationPending(proposal.operationHash)) {\n            return ProposalState.Queued;\n        } else if (\n            proposal.forVotes > proposal.againstVotes &&\n            proposal.forVotes > quorumVotes &&\n            blockNumber > proposal.endBlock\n        ) {\n            return ProposalState.Succeeded;\n        }\n    }\n\n    /// @notice Cast a vote for a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @dev emit:VoteCast\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /// @notice Cast a vote for a proposal via signature\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @param v signature component\n    /// @param r signature component\n    /// @param s signature component\n    /// @dev emit:VoteCast\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        // ECDSA.recover will check if address is zero\n        address signatory = ECDSA.recover(digest, v, r, s);\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /// @dev Registers a vote, calls the NOTE token to get the voting power for the voter\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = receipts[proposalId][voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = note.getPriorVotes(voter, proposal.startBlock);\n        // Short circuit if voter has no votes\n        if (votes == 0) return;\n\n        if (support) {\n            proposal.forVotes = _add96(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = _add96(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    /// @notice Updates the quorum votes required, can only be executed via a proposal\n    /// @param newQuorumVotes new quorum votes required\n    /// @dev emit:UpdateQuorumVotes\n    function updateQuorumVotes(uint96 newQuorumVotes) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        quorumVotes = newQuorumVotes;\n        emit UpdateQuorumVotes(newQuorumVotes);\n    }\n\n    /// @notice Updates the proposal threshold required, can only be executed via a proposal\n    /// @param newProposalThreshold new proposal threshold\n    /// @dev emit:UpdateProposalThreshold\n    function updateProposalThreshold(uint96 newProposalThreshold) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        proposalThreshold = newProposalThreshold;\n        emit UpdateProposalThreshold(newProposalThreshold);\n    }\n\n    /// @notice Updates the voting delay blocks required, can only be executed via a proposal\n    /// @param newVotingDelayBlocks new voting delay blocks\n    /// @dev emit:UpdateVotingDelayBlocks\n    function updateVotingDelayBlocks(uint32 newVotingDelayBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        votingDelayBlocks = newVotingDelayBlocks;\n        emit UpdateVotingDelayBlocks(newVotingDelayBlocks);\n    }\n\n    /// @notice Updates the voting period blocks required, can only be executed via a proposal\n    /// @param newVotingPeriodBlocks new voting period blocks\n    /// @dev emit:UpdateVotingPeriodBlocks\n    function updateVotingPeriodBlocks(uint32 newVotingPeriodBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        require(newVotingPeriodBlocks >= MIN_VOTING_PERIOD_BLOCKS, \"Below min voting period\");\n        votingPeriodBlocks = newVotingPeriodBlocks;\n        emit UpdateVotingPeriodBlocks(newVotingPeriodBlocks);\n    }\n\n    /// @dev Hidden public method\n    function __abdicate() external {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n        emit Abdicate();\n    }\n\n    /// @notice Transfers guardian role to a new guardian\n    /// @param newGuardian address to transfer role to\n    function __transferGuardian(address newGuardian) external {\n        require(\n            msg.sender == guardian,\n            \"GovernorAlpha::__transferGuardian: sender must be gov guardian\"\n        );\n        require(newGuardian != address(0), \"Cannot transfer to zero address\");\n\n        guardian = newGuardian;\n        emit TransferGuardian(newGuardian);\n    }\n\n    /// @dev Overflow check for adding votes\n    function _add96(uint96 a, uint96 b) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Overflow check for adding block numbers\n    function _add32(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Helper method for signature check\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Constants.sol\";\nimport \"../proxy/utils/UUPSUpgradeable.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\n\n/**\n * Read only version of the Router that can only be upgraded by governance. Used in emergency when the system must\n * be paused for some reason.\n */\ncontract PauseRouter is StorageLayoutV1, UUPSUpgradeable {\n    address public immutable VIEWS;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n\n    constructor(\n        address views_,\n        address liquidateCurrency_,\n        address liquidatefCash_\n    ) {\n        VIEWS = views_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override {\n        // This is only true during a rollback check when the pause router is downgraded\n        bool isRollbackCheck = rollbackRouterImplementation != address(0) &&\n            newImplementation == rollbackRouterImplementation;\n\n        require(\n            owner == msg.sender || (msg.sender == pauseGuardian && isRollbackCheck),\n            \"Unauthorized upgrade\"\n        );\n\n        // Clear this storage slot so the guardian cannot upgrade back to the previous router,\n        // requires governance to do so.\n        rollbackRouterImplementation = address(0);\n    }\n\n    function getLiquidationEnabledState() external view returns (bytes1) {\n        return liquidationEnabledState;\n    }\n\n    function setLiquidationEnabledState(bytes1 liquidationEnabledState_) external {\n        // Only authorized addresses can set the liquidation state\n        require(owner == msg.sender || msg.sender == pauseGuardian);\n        liquidationEnabledState = liquidationEnabledState_;\n    }\n\n    function isEnabled(bytes1 state) private view returns (bool) {\n        return (liquidationEnabledState & state == state);\n    }\n\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        // Liquidation calculation methods are stateful (they settle accounts if required)\n        // and therefore we prevent them from being called unless specifically authorized.\n        if (\n            (sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateCollateralCurrency.selector) &&\n            isEnabled(Constants.COLLATERAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateLocalCurrency.selector) &&\n            isEnabled(Constants.LOCAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashLocal.selector ||\n                sig == NotionalProxy.calculatefCashLocalLiquidation.selector) &&\n            isEnabled(Constants.LOCAL_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n                sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector) &&\n            isEnabled(Constants.CROSS_CURRENCY_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BatchAction.sol\";\nimport \"./nTokenRedeemAction.sol\";\nimport \"../FreeCollateralExternal.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"../../internal/AccountContextHandler.sol\";\nimport \"../../internal/portfolio/TransferAssets.sol\";\nimport \"../../internal/portfolio/PortfolioHandler.sol\";\nimport \"interfaces/IERC1155TokenReceiver.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\n\ncontract ERC1155Action is nERC1155Interface, StorageLayoutV1 {\n    using AccountContextHandler for AccountContext;\n\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(nERC1155Interface).interfaceId;\n    }\n\n    /// @notice Returns the balance of an ERC1155 id on an account. WARNING: the balances returned by\n    /// this method are int256 not uint256 as specified in ERC1155. Modify smart contracts accordingly.\n    /// @param account account to get the id for\n    /// @param id the ERC1155 id\n    /// @return Balance of the ERC1155 id as a signed integer\n    function balanceOf(address account, uint256 id) public view override returns (int256) {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        int256 notional;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            notional = _balanceInBitmap(account, accountContext.bitmapCurrencyId, id);\n        } else {\n            notional = _balanceInArray(\n                PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength),\n                id\n            );\n        }\n\n        return notional;\n    }\n\n    /// @notice Returns the balance of a batch of accounts and ids. WARNING: these balances are signed integers, not\n    /// unsigned integers as the ERC1155 spec designates\n    /// @param accounts array of accounts to get balances for\n    /// @param ids array of ids to get balances for\n    /// @return Returns an array of balances as signed integers\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        override\n        returns (int256[] memory)\n    {\n        require(accounts.length == ids.length);\n        int256[] memory amounts = new int256[](accounts.length);\n\n        for (uint256 i; i < accounts.length; i++) {\n            // This is pretty inefficient but gets the job done\n            amounts[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return amounts;\n    }\n\n    /// @dev Returns the balance from a bitmap given the id\n    function _balanceInBitmap(\n        address account,\n        uint256 bitmapCurrencyId,\n        uint256 id\n    ) internal view returns (int256) {\n        (uint256 currencyId, uint256 maturity, uint256 assetType) = TransferAssets.decodeAssetId(\n            id\n        );\n        if (currencyId != bitmapCurrencyId) return 0;\n        if (assetType != Constants.FCASH_ASSET_TYPE) return 0;\n\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @dev Searches an array for the matching asset\n    function _balanceInArray(PortfolioAsset[] memory portfolio, uint256 id)\n        internal\n        pure\n        returns (int256)\n    {\n        for (uint256 i; i < portfolio.length; i++) {\n            if (\n                TransferAssets.encodeAssetId(\n                    portfolio[i].currencyId,\n                    portfolio[i].maturity,\n                    portfolio[i].assetType\n                ) == id\n            ) return portfolio[i].notional;\n        }\n    }\n\n    /// @notice Transfer of a single fCash or liquidity token asset between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param id ERC1155 id of the asset\n    /// @param amount amount to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferSingle\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external payable override {\n        require(amount <= uint256(type(int256).max)); // dev: int overflow\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        // When amount is set to zero this method can be used as a way to execute trades via a transfer operator\n        AccountContext memory fromContext;\n        if (amount > 0) {\n            PortfolioAsset[] memory assets = new PortfolioAsset[](1);\n            (assets[0].currencyId, assets[0].maturity, assets[0].assetType) = TransferAssets\n                .decodeAssetId(id);\n            assets[0].notional = int256(amount);\n            _assertValidMaturity(assets[0].currencyId, assets[0].maturity, block.timestamp);\n\n            // prettier-ignore\n            (fromContext, /* toContext */) = _transfer(from, to, assets);\n\n            emit TransferSingle(msg.sender, from, to, id, amount);\n        } else {\n            fromContext = AccountContextHandler.getAccountContext(from);\n        }\n\n        // toContext is always empty here because we cannot have bidirectional transfers in `safeTransferFrom`\n        AccountContext memory toContext;\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, false);\n    }\n\n    /// @notice Transfer of a batch of fCash or liquidity token assets between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param ids ERC1155 ids of the assets\n    /// @param amounts amounts to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferBatch\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override {\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155_BATCH_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        (PortfolioAsset[] memory assets, bool toTransferNegative) = _decodeToAssets(ids, amounts);\n        // When doing a bidirectional transfer must ensure that the `to` account has given approval\n        // to msg.sender as well.\n        if (toTransferNegative) require(isApprovedForAll(to, msg.sender), \"Unauthorized\");\n\n        (AccountContext memory fromContext, AccountContext memory toContext) = _transfer(\n            from,\n            to,\n            assets\n        );\n\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, toTransferNegative);\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n    }\n\n    /// @dev Validates accounts on transfer\n    function _validateAccounts(address from, address to) private view {\n        require(from != to && to != address(0), \"Invalid address\");\n        require(msg.sender == from || isApprovedForAll(from, msg.sender), \"Unauthorized\");\n    }\n\n    /// @notice Decodes ids and amounts to PortfolioAsset objects\n    /// @param ids array of ERC1155 ids\n    /// @param amounts amounts to transfer\n    /// @return array of portfolio asset objects\n    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        // prettier-ignore\n        (PortfolioAsset[] memory assets, /* */) = _decodeToAssets(ids, amounts);\n        return assets;\n    }\n\n    function _decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        internal\n        view\n        returns (PortfolioAsset[] memory, bool)\n    {\n        uint256 blockTime = block.timestamp;\n        bool toTransferNegative = false;\n        PortfolioAsset[] memory assets = new PortfolioAsset[](ids.length);\n\n        for (uint256 i; i < ids.length; i++) {\n            (assets[i].currencyId, assets[i].maturity, assets[i].assetType) = TransferAssets\n                .decodeAssetId(ids[i]);\n\n            _assertValidMaturity(assets[i].currencyId, assets[i].maturity, blockTime);\n            // Although amounts is encoded as uint256 we allow it to be negative here. This will\n            // allow for bidirectional transfers of fCash. Internally fCash assets are always stored\n            // as int128 (for bitmap portfolio) or int88 (for array portfolio) so there is no potential\n            // that a uint256 value that is greater than type(int256).max would actually valid.\n            assets[i].notional = int256(amounts[i]);\n            // If there is a negative transfer we mark it as such, this will force us to do a free collateral\n            // check on the `to` address as well.\n            if (assets[i].notional < 0) toTransferNegative = true;\n        }\n\n        return (assets, toTransferNegative);\n    }\n\n    /// @notice Encodes parameters into an ERC1155 id\n    /// @param currencyId currency id of the asset\n    /// @param maturity timestamp of the maturity\n    /// @param assetType id of the asset type\n    /// @return ERC1155 id\n    function encodeToId(\n        uint16 currencyId,\n        uint40 maturity,\n        uint8 assetType\n    ) external pure override returns (uint256) {\n        return TransferAssets.encodeAssetId(currencyId, maturity, assetType);\n    }\n\n    /// @dev Ensures that all maturities specified are valid for the currency id (i.e. they do not\n    /// go past the max maturity date)\n    function _assertValidMaturity(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime\n    ) private view {\n        require(\n            DateTime.isValidMaturity(CashGroup.getMaxMarketIndex(currencyId), maturity, blockTime),\n            \"Invalid maturity\"\n        );\n    }\n\n    /// @dev Internal asset transfer event between accounts\n    function _transfer(\n        address from,\n        address to,\n        PortfolioAsset[] memory assets\n    ) internal returns (AccountContext memory, AccountContext memory) {\n        AccountContext memory fromContext = AccountContextHandler.getAccountContext(from);\n        AccountContext memory toContext = AccountContextHandler.getAccountContext(to);\n\n        toContext = TransferAssets.placeAssetsInAccount(to, toContext, assets);\n        TransferAssets.invertNotionalAmountsInPlace(assets);\n        fromContext = TransferAssets.placeAssetsInAccount(from, fromContext, assets);\n\n        toContext.setAccountContext(to);\n        fromContext.setAccountContext(from);\n\n        return (fromContext, toContext);\n    }\n\n    /// @dev Checks post transfer events which will either be initiating one of the batch trading events or a free collateral\n    /// check if required.\n    function _checkPostTransferEvent(\n        address from,\n        address to,\n        AccountContext memory fromContext,\n        AccountContext memory toContext,\n        bytes calldata data,\n        bool toTransferNegative\n    ) internal {\n        bytes4 sig;\n        address transactedAccount;\n        if (data.length >= 32) {\n            // Method signature is not abi encoded so decode to bytes32 first and take the first 4 bytes. This works\n            // because all the methods we want to call below require more than 32 bytes in the calldata\n            bytes32 tmp = abi.decode(data, (bytes32));\n            sig = bytes4(tmp);\n        }\n\n        // These are the only three methods allowed to occur in a post transfer event. These actions allow `from`\n        // accounts to take any sort of trading action as a result of their transfer. All of these actions will\n        // handle checking free collateral so no additional check is necessary here.\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == BatchAction.batchBalanceAction.selector ||\n            sig == BatchAction.batchBalanceAndTradeAction.selector\n        ) {\n            transactedAccount = abi.decode(data[4:36], (address));\n            // Ensure that the \"transactedAccount\" parameter of the call is set to the from address or the\n            // to address. If it is the \"to\" address then ensure that the msg.sender has approval to\n            // execute operations\n            require(\n                transactedAccount == from ||\n                    (transactedAccount == to && isApprovedForAll(to, msg.sender)),\n                \"Unauthorized call\"\n            );\n\n            (bool status, bytes memory result) = address(this).call{value: msg.value}(data);\n            // TODO: retrieve revert string\n            require(status, \"Call failed\");\n        }\n\n        // The transacted account will have its free collateral checked above so there is\n        // no need to recheck here.\n        if (transactedAccount != from && fromContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(from);\n        }\n\n        // Check free collateral if the `to` account has taken on a negative fCash amount\n        if (transactedAccount != to && toTransferNegative && toContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(to);\n        }\n    }\n\n    /// @notice Allows an account to set approval for an operator\n    /// @param operator address of the operator\n    /// @param approved state of the approval\n    /// @dev emit:ApprovalForAll\n    function setApprovalForAll(address operator, bool approved) external override {\n        accountAuthorizedTransferOperator[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @notice Checks approval state for an account, will first check if global transfer operator is enabled\n    /// before falling through to an account specific transfer operator.\n    /// @param account address of the account\n    /// @param operator address of the operator\n    /// @return true for approved\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (globalTransferOperator[operator]) return true;\n\n        return accountAuthorizedTransferOperator[account][operator];\n    }\n}\n\n\n",
        "CodeNames": [
            "GovernorAlpha.sol",
            "PauseRouter.sol",
            "ERC1155Action.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\ncall-0: grantRole(TIME_LOCK_ADMIN, attackerContract)\ncall-1: grantRole(EXECUTOR, attackerContract)\ncall-2: grantRole(PROPOSER, attackerContract)\ncall-3: updateDelay(0) // such that _afterCall \"isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp\" passes\ncall-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential)\n// attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal\n"
                ],
                "Type": " DAO proposals can be executed by anyone due to vulnerable  TimelockController ",
                "Description": "\nThe GovernorAlpha inherits from a vulnerable TimelockController.\nThis TimelockController allows an EXECUTOR role to escalate privileges and also gain the proposer role. See details on OZ(https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr) and the fix here(https://github.com/OpenZeppelin/openzeppelin-contracts/compare/v4.3.0...v4.3.1).\n\nThe bug is that _executeBatch checks if the proposal was scheduled only after the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed.\nAs the custom GovernorAlpha.executeProposal function removed the original \"queued state check\" (require(state(proposalId) == ProposalState.Queued), the attack can be executed by anyone, even without the EXEUCTOR_ROLE.\n\nProof of concept:\n1. Create a proposal using propose. The calldata will be explained in the next step. (This can be done by anyone passing the min proposalThreshold)\n2. Call executeProposal(proposalId, ...) such that the following calls are made:\n\nsolidity\ncall-0: grantRole(TIME_LOCK_ADMIN, attackerContract)\ncall-1: grantRole(EXECUTOR, attackerContract)\ncall-2: grantRole(PROPOSER, attackerContract)\ncall-3: updateDelay(0) // such that _afterCall \"isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp\" passes\ncall-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential)\n// attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal\n\n\n \u2139\ufe0f  I already talked to Jeff Wu about this and he created a test case for it confirming this finding\n\nThe impact is that, anyone who can create a proposal can become Timelock admin (proposer & executor) and execute arbitrary transactions as the DAO-controlled GovernorAlpha.\nNote that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the globalTransferOperator and steal all tokens.\n\n",
                "Repair": "Recommend updating the vulnerable contract to TimelockController v3.4.2 as it currently uses OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/58)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./actions/nTokenAction.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"./actions/nTokenRedeemAction.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\n\n/**\n * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage\n * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing\n * contracts.\n *\n * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also\n * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a\n * new Router with the new hardcoded addresses will then be deployed and upgraded into place.\n */\ncontract Router is StorageLayoutV1 {\n    // These contract addresses cannot be changed once set by the constructor\n    address public immutable GOVERNANCE;\n    address public immutable VIEWS;\n    address public immutable INITIALIZE_MARKET;\n    address public immutable NTOKEN_ACTIONS;\n    address public immutable NTOKEN_REDEEM;\n    address public immutable BATCH_ACTION;\n    address public immutable ACCOUNT_ACTION;\n    address public immutable ERC1155;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n    address public immutable cETH;\n\n    constructor(\n        address governance_,\n        address views_,\n        address initializeMarket_,\n        address nTokenActions_,\n        address nTokenRedeem_,\n        address batchAction_,\n        address accountAction_,\n        address erc1155_,\n        address liquidateCurrency_,\n        address liquidatefCash_,\n        address cETH_\n    ) {\n        GOVERNANCE = governance_;\n        VIEWS = views_;\n        INITIALIZE_MARKET = initializeMarket_;\n        NTOKEN_ACTIONS = nTokenActions_;\n        NTOKEN_REDEEM = nTokenRedeem_;\n        BATCH_ACTION = batchAction_;\n        ACCOUNT_ACTION = accountAction_;\n        ERC1155 = erc1155_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n        cETH = cETH_;\n    }\n\n    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\n        // Cannot re-initialize once the contract has been initialized, ownership transfer does not\n        // allow address to be set back to zero\n        require(owner == address(0), \"R: already initialized\");\n\n        // Allow list currency to be called by this contract for the purposes of\n        // initializing ETH as a currency\n        owner = msg.sender;\n        // List ETH as currency id == 1, NOTE: return value is ignored here\n        (bool status, ) =\n            address(GOVERNANCE).delegatecall(\n                abi.encodeWithSelector(\n                    NotionalGovernance.listCurrency.selector,\n                    TokenStorage(cETH, false, TokenType.cETH),\n                    // No underlying set for cETH\n                    TokenStorage(address(0), false, TokenType.Ether),\n                    address(0),\n                    false,\n                    130, // Initial settings of 130 buffer\n                    70,  // 70% haircut\n                    105  // 105 liquidation discount\n                )\n            );\n        require(status);\n\n        owner = owner_;\n        // The pause guardian may downgrade the router to the pauseRouter\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n    }\n\n    /// @notice Returns the implementation contract for the method signature\n    /// @param sig method signature to call\n    /// @return implementation address\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        if (\n            sig == NotionalProxy.batchBalanceAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector\n        ) {\n            return BATCH_ACTION;\n        }\n\n        if (\n            sig == nTokenAction.nTokenTotalSupply.selector ||\n            sig == nTokenAction.nTokenBalanceOf.selector ||\n            sig == nTokenAction.nTokenTransferAllowance.selector ||\n            sig == nTokenAction.nTokenTransferApprove.selector ||\n            sig == nTokenAction.nTokenTransfer.selector ||\n            sig == nTokenAction.nTokenTransferFrom.selector ||\n            sig == nTokenAction.nTokenClaimIncentives.selector ||\n            sig == nTokenAction.nTokenTransferApproveAll.selector ||\n            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||\n            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector\n        ) {\n            return NTOKEN_ACTIONS;\n        }\n\n        if (\n            sig == NotionalProxy.depositUnderlyingToken.selector ||\n            sig == NotionalProxy.depositAssetToken.selector ||\n            sig == NotionalProxy.withdraw.selector ||\n            sig == NotionalProxy.settleAccount.selector ||\n            sig == NotionalProxy.enableBitmapCurrency.selector\n        ) {\n            return ACCOUNT_ACTION;\n        }\n\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector\n        ) {\n            return NTOKEN_REDEEM;\n        }\n\n        if (\n            sig == nERC1155Interface.supportsInterface.selector ||\n            sig == nERC1155Interface.balanceOf.selector ||\n            sig == nERC1155Interface.balanceOfBatch.selector ||\n            sig == nERC1155Interface.safeTransferFrom.selector ||\n            sig == nERC1155Interface.safeBatchTransferFrom.selector ||\n            sig == nERC1155Interface.decodeToAssets.selector ||\n            sig == nERC1155Interface.encodeToId.selector ||\n            sig == nERC1155Interface.setApprovalForAll.selector ||\n            sig == nERC1155Interface.isApprovedForAll.selector\n        ) {\n            return ERC1155;\n        }\n\n        if (\n            sig == NotionalProxy.liquidateLocalCurrency.selector ||\n            sig == NotionalProxy.liquidateCollateralCurrency.selector ||\n            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            sig == NotionalProxy.liquidatefCashLocal.selector ||\n            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||\n            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            sig == NotionalProxy.initializeMarkets.selector ||\n            sig == NotionalProxy.sweepCashIntoMarkets.selector\n        ) {\n            return INITIALIZE_MARKET;\n        }\n\n        if (\n            sig == NotionalGovernance.listCurrency.selector ||\n            sig == NotionalGovernance.enableCashGroup.selector ||\n            sig == NotionalGovernance.updateCashGroup.selector ||\n            sig == NotionalGovernance.updateAssetRate.selector ||\n            sig == NotionalGovernance.updateETHRate.selector ||\n            sig == NotionalGovernance.transferOwnership.selector ||\n            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||\n            sig == NotionalGovernance.updateDepositParameters.selector ||\n            sig == NotionalGovernance.updateInitializationParameters.selector ||\n            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||\n            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||\n            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||\n            sig == NotionalProxy.upgradeTo.selector ||\n            sig == NotionalProxy.upgradeToAndCall.selector\n        ) {\n            return GOVERNANCE;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n\n    // NOTE: receive() is overridden in \"nProxy\" to allow for eth transfers to succeed\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../external/FreeCollateralExternal.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"../internal/valuation/ExchangeRate.sol\";\nimport \"../internal/markets/CashGroup.sol\";\nimport \"../internal/markets/AssetRate.sol\";\nimport \"../internal/nTokenHandler.sol\";\nimport \"../internal/balances/TokenHandler.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../math/SafeInt256.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"interfaces/notional/NotionalViews.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Views is StorageLayoutV1, NotionalViews {\n    using CashGroup for CashGroupParameters;\n    using TokenHandler for Token;\n    using Market for MarketParameters;\n    using AssetRate for AssetRateParameters;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n    using BalanceHandler for BalanceState;\n\n    /** Governance Parameter Getters **/\n\n    /// @notice Returns the current maximum currency id\n    function getMaxCurrencyId() external view override returns (uint16) {\n        return maxCurrencyId;\n    }\n\n    /// @notice Returns a currency id, a zero means that it is not listed.\n    function getCurrencyId(address tokenAddress)\n        external\n        view\n        override\n        returns (uint16 currencyId)\n    {\n        currencyId = tokenAddressToCurrencyId[tokenAddress];\n    }\n\n    /// @notice Returns the asset token and underlying token related to a given currency id. If underlying\n    /// token is not set then will return the zero address\n    function getCurrency(uint16 currencyId)\n        external\n        view\n        override\n        returns (Token memory assetToken, Token memory underlyingToken)\n    {\n        assetToken = TokenHandler.getToken(currencyId, false);\n        underlyingToken = TokenHandler.getToken(currencyId, true);\n    }\n\n    /// @notice Returns the ETH and Asset rates for a currency as stored, useful for viewing how they are configured\n    function getRateStorage(uint16 currencyId)\n        external\n        view\n        override\n        returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate)\n    {\n        ethRate = underlyingToETHRateMapping[currencyId];\n        assetRate = assetToUnderlyingRateMapping[currencyId];\n    }\n\n    /// @notice Returns a currency and its corresponding asset rate and ETH exchange rates. Note that this does not recalculate\n    /// cToken interest rates, it only retrieves the latest stored rate.\n    function getCurrencyAndRates(uint16 currencyId)\n        external\n        view\n        override\n        returns (\n            Token memory assetToken,\n            Token memory underlyingToken,\n            ETHRate memory ethRate,\n            AssetRateParameters memory assetRate\n        )\n    {\n        assetToken = TokenHandler.getToken(currencyId, false);\n        underlyingToken = TokenHandler.getToken(currencyId, false);\n        ethRate = ExchangeRate.buildExchangeRate(currencyId);\n        assetRate = AssetRate.buildAssetRateView(currencyId);\n    }\n\n    /// @notice Returns cash group settings for a currency\n    function getCashGroup(uint16 currencyId)\n        external\n        view\n        override\n        returns (CashGroupSettings memory)\n    {\n        return CashGroup.deserializeCashGroupStorage(currencyId);\n    }\n\n    /// @notice Returns the cash group along with the asset rate for convenience.\n    function getCashGroupAndAssetRate(uint16 currencyId)\n        external\n        view\n        override\n        returns (CashGroupSettings memory cashGroup, AssetRateParameters memory assetRate)\n    {\n        cashGroup = CashGroup.deserializeCashGroupStorage(currencyId);\n        assetRate = AssetRate.buildAssetRateView(currencyId);\n    }\n\n    /// @notice Returns market initialization parameters for a given currency\n    function getInitializationParameters(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)\n    {\n        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (annualizedAnchorRates, proportions) = nTokenHandler.getInitializationParameters(\n            currencyId,\n            maxMarketIndex\n        );\n    }\n\n    /// @notice Returns nToken deposit parameters for a given currency\n    function getDepositParameters(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\n    {\n        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (depositShares, leverageThresholds) = nTokenHandler.getDepositParameters(\n            currencyId,\n            maxMarketIndex\n        );\n    }\n\n    /// @notice Returns nToken address for a given currency\n    function nTokenAddress(uint16 currencyId) external view override returns (address) {\n        return nTokenHandler.nTokenAddress(currencyId);\n    }\n\n    /// @notice Returns address of contract owner\n    function getOwner() external view override returns (address) {\n        return owner;\n    }\n\n    /** Global System State View Methods **/\n\n    /// @notice Returns the asset settlement rate for a given maturity\n    function getSettlementRate(uint16 currencyId, uint40 maturity)\n        external\n        view\n        override\n        returns (AssetRateParameters memory)\n    {\n        return AssetRate.buildSettlementRateView(currencyId, maturity);\n    }\n\n    /// @notice Returns all currently active markets for a currency\n    function getActiveMarkets(uint16 currencyId)\n        external\n        view\n        override\n        returns (MarketParameters[] memory)\n    {\n        uint256 blockTime = block.timestamp;\n        return _getActiveMarketsAtBlockTime(currencyId, blockTime);\n    }\n\n    /// @notice Returns all active markets for a currency at the specified block time, useful for looking\n    /// at historical markets\n    function getActiveMarketsAtBlockTime(uint16 currencyId, uint32 blockTime)\n        external\n        view\n        override\n        returns (MarketParameters[] memory)\n    {\n        return _getActiveMarketsAtBlockTime(currencyId, blockTime);\n    }\n\n    function _getActiveMarketsAtBlockTime(uint256 currencyId, uint256 blockTime)\n        internal\n        view\n        returns (MarketParameters[] memory)\n    {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters[] memory markets = new MarketParameters[](cashGroup.maxMarketIndex);\n\n        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) {\n            cashGroup.loadMarket(markets[i], i + 1, true, blockTime);\n        }\n\n        return markets;\n    }\n\n    /// @notice Returns the current reserve balance for a currency\n    function getReserveBalance(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256 reserveBalance)\n    {\n        // prettier-ignore\n        (\n            reserveBalance,\n            /* */,\n            /* */,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n    }\n\n    function getNTokenPortfolio(address tokenAddress)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory liquidityTokens, PortfolioAsset[] memory netfCashAssets)\n    {\n        // prettier-ignore\n        (\n            uint256 currencyId,\n            /* incentiveRate */,\n            uint256 lastInitializedTime,\n            bytes6 parameters\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\n\n        liquidityTokens = PortfolioHandler.getSortedPortfolio(\n            tokenAddress,\n            uint8(parameters[Constants.ASSET_ARRAY_LENGTH])\n        );\n\n        netfCashAssets = BitmapAssetsHandler.getifCashArray(\n            tokenAddress,\n            currencyId,\n            lastInitializedTime\n        );\n    }\n\n    function getNTokenAccount(address tokenAddress)\n        external\n        view\n        override\n        returns (\n            uint256 currencyId,\n            uint256 totalSupply,\n            uint256 incentiveAnnualEmissionRate,\n            uint256 lastInitializedTime,\n            bytes6 nTokenParameters,\n            int256 cashBalance,\n            uint256 integralTotalSupply,\n            uint256 lastSupplyChangeTime\n        )\n    {\n        (\n            currencyId,\n            incentiveAnnualEmissionRate,\n            lastInitializedTime,\n            nTokenParameters\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\n\n        // prettier-ignore\n        (\n            totalSupply,\n            integralTotalSupply,\n            lastSupplyChangeTime\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(tokenAddress);\n\n        // prettier-ignore\n        (\n            cashBalance,\n            /* */,\n            /* */,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(tokenAddress, currencyId);\n    }\n\n    /** Account Specific View Methods **/\n\n    /// @notice Returns all account details in a single view\n    function getAccount(address account)\n        external\n        view\n        override\n        returns (\n            AccountContext memory accountContext,\n            AccountBalance[] memory accountBalances,\n            PortfolioAsset[] memory portfolio\n        )\n    {\n        accountContext = AccountContextHandler.getAccountContext(account);\n        accountBalances = new AccountBalance[](10);\n\n        uint256 i;\n        if (accountContext.bitmapCurrencyId != 0) {\n            (\n                accountBalances[i].cashBalance,\n                accountBalances[i].nTokenBalance,\n                accountBalances[i].lastClaimTime,\n                accountBalances[i].lastClaimIntegralSupply\n            ) = BalanceHandler.getBalanceStorage(account, accountContext.bitmapCurrencyId);\n            i += 1;\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            accountBalances[i].currencyId = uint256(\n                uint16(bytes2(currencies) & Constants.UNMASK_FLAGS)\n            );\n            if (accountBalances[i].currencyId == 0) break;\n\n            (\n                accountBalances[i].cashBalance,\n                accountBalances[i].nTokenBalance,\n                accountBalances[i].lastClaimTime,\n                accountBalances[i].lastClaimIntegralSupply\n            ) = BalanceHandler.getBalanceStorage(account, accountBalances[i].currencyId);\n            i += 1;\n            currencies = currencies << 16;\n        }\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            portfolio = BitmapAssetsHandler.getifCashArray(\n                account,\n                accountContext.bitmapCurrencyId,\n                accountContext.nextSettleTime\n            );\n        } else {\n            portfolio = PortfolioHandler.getSortedPortfolio(\n                account,\n                accountContext.assetArrayLength\n            );\n        }\n    }\n\n    /// @notice Returns account context\n    function getAccountContext(address account)\n        external\n        view\n        override\n        returns (AccountContext memory)\n    {\n        return AccountContextHandler.getAccountContext(account);\n    }\n\n    /// @notice Returns account balances for a given currency\n    function getAccountBalance(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (\n            int256 cashBalance,\n            int256 nTokenBalance,\n            uint256 lastClaimTime\n        )\n    {\n        // prettier-ignore\n        (\n            cashBalance,\n            nTokenBalance,\n            lastClaimTime,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n    }\n\n    /// @notice Returns account portfolio of assets\n    function getAccountPortfolio(address account)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        if (accountContext.bitmapCurrencyId != 0) {\n            return\n                BitmapAssetsHandler.getifCashArray(\n                    account,\n                    accountContext.bitmapCurrencyId,\n                    accountContext.nextSettleTime\n                );\n        } else {\n            return PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength);\n        }\n    }\n\n    /// @notice Returns the fCash amount at the specified maturity for a bitmapped portfolio\n    function getfCashNotional(\n        address account,\n        uint256 currencyId,\n        uint256 maturity\n    ) external view override returns (int256) {\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @notice Returns the assets bitmap for an account\n    function getAssetsBitmap(address account, uint256 currencyId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return BitmapAssetsHandler.getAssetsBitmap(account, currencyId);\n    }\n\n    /// @notice Returns free collateral of an account along with an array of the individual net available\n    /// asset cash amounts\n    function getFreeCollateral(address account)\n        external\n        view\n        override\n        returns (int256, int256[] memory)\n    {\n        return FreeCollateralExternal.getFreeCollateralView(account);\n    }\n\n    /** General Calculation View Methods **/\n\n    /// @notice Returns the nTokens that will be minted when some amount of asset tokens are deposited\n    function calculateNTokensToMint(uint16 currencyId, uint88 amountToDepositExternalPrecision)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        Token memory token = TokenHandler.getToken(currencyId, false);\n        int256 amountToDepositInternal =\n            token.convertToInternal(int256(amountToDepositExternalPrecision));\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 tokensToMint,\n            /* */\n        ) = nTokenMintAction.calculateTokensToMint(\n            nToken,\n            amountToDepositInternal,\n            block.timestamp\n        );\n\n        return SafeCast.toUint256(tokensToMint);\n    }\n\n    /// @notice Returns the fCash amount to send when given a cash amount, be sure to buffer these amounts\n    /// slightly because the liquidity curve is sensitive to changes in block time\n    function getfCashAmountGivenCashAmount(\n        uint16 currencyId,\n        int88 netCashToAccount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view override returns (int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters memory market;\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\n\n        require(market.maturity > blockTime, \"Invalid block time\");\n        uint256 timeToMaturity = market.maturity - blockTime;\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\n            Market.getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\n        int256 fee = Market.getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\n\n        return\n            Market.getfCashGivenCashAmount(\n                market.totalfCash,\n                int256(netCashToAccount),\n                totalCashUnderlying,\n                rateScalar,\n                rateAnchor,\n                fee,\n                0\n            );\n    }\n\n    /// @notice Returns the cash amount that will be traded given an fCash amount, be sure to buffer these amounts\n    /// slightly because the liquidity curve is sensitive to changes in block time\n    function getCashAmountGivenfCashAmount(\n        uint16 currencyId,\n        int88 fCashAmount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view override returns (int256, int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters memory market;\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\n\n        require(market.maturity > blockTime, \"Invalid block time\");\n        uint256 timeToMaturity = market.maturity - blockTime;\n\n        // prettier-ignore\n        (int256 assetCash, /* int fee */) =\n            market.calculateTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);\n\n        return (assetCash, cashGroup.assetRate.convertToUnderlying(assetCash));\n    }\n\n    /// @notice Returns the claimable incentives for all nToken balances\n    /// @param account The address of the account which holds the tokens\n    /// @param blockTime The block time when incentives will be minted\n    /// @return Incentives an account is eligible to claim\n    function nTokenGetClaimableIncentives(address account, uint256 blockTime)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        uint256 totalIncentivesClaimable;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\n\n                // prettier-ignore\n                (\n                    /* totalSupply */,\n                    uint256 integralTotalSupply,\n                    /* lastSupplyChangeTime */\n                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);\n\n                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(\n                    tokenAddress,\n                    uint256(balanceState.storedNTokenBalance),\n                    balanceState.lastClaimTime,\n                    balanceState.lastClaimIntegralSupply,\n                    blockTime,\n                    integralTotalSupply\n                );\n                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n\n            if (balanceState.storedNTokenBalance > 0) {\n                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\n\n                (\n                    /* totalSupply */,\n                    uint256 integralTotalSupply,\n                    /* lastSupplyChangeTime */\n                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);\n\n                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(\n                    nTokenHandler.nTokenAddress(balanceState.currencyId),\n                    uint256(balanceState.storedNTokenBalance),\n                    balanceState.lastClaimTime,\n                    balanceState.lastClaimIntegralSupply,\n                    blockTime,\n                    integralTotalSupply\n                );\n                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);\n            }\n\n            currencies = currencies << 16;\n        }\n\n        return totalIncentivesClaimable;\n    }\n\n    fallback() external {\n        revert(\"Method not found\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        // borrow on notional via special flash loan facility\n        //  - borrow repayment amount\n        //  - withdraw to wallet, redeem to underlying\n        // receive callback (tokens transferred to borrowing account)\n        //   -> inside callback\n        //   -> repayBorrowBehalf(account, repayAmount)\n        //   -> deposit cToken to notional (account needs to have set approvals)\n        //   -> exit callback\n        // inside original borrow, check FC\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }\n\n    receive() external payable {\n        // This contract cannot migrate ETH loans because there is no way\n        // to do transferFrom on ETH\n        revert(\"Cannot transfer ETH\");\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BatchAction.sol\";\nimport \"./nTokenRedeemAction.sol\";\nimport \"../FreeCollateralExternal.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"../../internal/AccountContextHandler.sol\";\nimport \"../../internal/portfolio/TransferAssets.sol\";\nimport \"../../internal/portfolio/PortfolioHandler.sol\";\nimport \"interfaces/IERC1155TokenReceiver.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\n\ncontract ERC1155Action is nERC1155Interface, StorageLayoutV1 {\n    using AccountContextHandler for AccountContext;\n\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(nERC1155Interface).interfaceId;\n    }\n\n    /// @notice Returns the balance of an ERC1155 id on an account. WARNING: the balances returned by\n    /// this method are int256 not uint256 as specified in ERC1155. Modify smart contracts accordingly.\n    /// @param account account to get the id for\n    /// @param id the ERC1155 id\n    /// @return Balance of the ERC1155 id as a signed integer\n    function balanceOf(address account, uint256 id) public view override returns (int256) {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        int256 notional;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            notional = _balanceInBitmap(account, accountContext.bitmapCurrencyId, id);\n        } else {\n            notional = _balanceInArray(\n                PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength),\n                id\n            );\n        }\n\n        return notional;\n    }\n\n    /// @notice Returns the balance of a batch of accounts and ids. WARNING: these balances are signed integers, not\n    /// unsigned integers as the ERC1155 spec designates\n    /// @param accounts array of accounts to get balances for\n    /// @param ids array of ids to get balances for\n    /// @return Returns an array of balances as signed integers\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        override\n        returns (int256[] memory)\n    {\n        require(accounts.length == ids.length);\n        int256[] memory amounts = new int256[](accounts.length);\n\n        for (uint256 i; i < accounts.length; i++) {\n            // This is pretty inefficient but gets the job done\n            amounts[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return amounts;\n    }\n\n    /// @dev Returns the balance from a bitmap given the id\n    function _balanceInBitmap(\n        address account,\n        uint256 bitmapCurrencyId,\n        uint256 id\n    ) internal view returns (int256) {\n        (uint256 currencyId, uint256 maturity, uint256 assetType) = TransferAssets.decodeAssetId(\n            id\n        );\n        if (currencyId != bitmapCurrencyId) return 0;\n        if (assetType != Constants.FCASH_ASSET_TYPE) return 0;\n\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @dev Searches an array for the matching asset\n    function _balanceInArray(PortfolioAsset[] memory portfolio, uint256 id)\n        internal\n        pure\n        returns (int256)\n    {\n        for (uint256 i; i < portfolio.length; i++) {\n            if (\n                TransferAssets.encodeAssetId(\n                    portfolio[i].currencyId,\n                    portfolio[i].maturity,\n                    portfolio[i].assetType\n                ) == id\n            ) return portfolio[i].notional;\n        }\n    }\n\n    /// @notice Transfer of a single fCash or liquidity token asset between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param id ERC1155 id of the asset\n    /// @param amount amount to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferSingle\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external payable override {\n        require(amount <= uint256(type(int256).max)); // dev: int overflow\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        // When amount is set to zero this method can be used as a way to execute trades via a transfer operator\n        AccountContext memory fromContext;\n        if (amount > 0) {\n            PortfolioAsset[] memory assets = new PortfolioAsset[](1);\n            (assets[0].currencyId, assets[0].maturity, assets[0].assetType) = TransferAssets\n                .decodeAssetId(id);\n            assets[0].notional = int256(amount);\n            _assertValidMaturity(assets[0].currencyId, assets[0].maturity, block.timestamp);\n\n            // prettier-ignore\n            (fromContext, /* toContext */) = _transfer(from, to, assets);\n\n            emit TransferSingle(msg.sender, from, to, id, amount);\n        } else {\n            fromContext = AccountContextHandler.getAccountContext(from);\n        }\n\n        // toContext is always empty here because we cannot have bidirectional transfers in `safeTransferFrom`\n        AccountContext memory toContext;\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, false);\n    }\n\n    /// @notice Transfer of a batch of fCash or liquidity token assets between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param ids ERC1155 ids of the assets\n    /// @param amounts amounts to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferBatch\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override {\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155_BATCH_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        (PortfolioAsset[] memory assets, bool toTransferNegative) = _decodeToAssets(ids, amounts);\n        // When doing a bidirectional transfer must ensure that the `to` account has given approval\n        // to msg.sender as well.\n        if (toTransferNegative) require(isApprovedForAll(to, msg.sender), \"Unauthorized\");\n\n        (AccountContext memory fromContext, AccountContext memory toContext) = _transfer(\n            from,\n            to,\n            assets\n        );\n\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, toTransferNegative);\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n    }\n\n    /// @dev Validates accounts on transfer\n    function _validateAccounts(address from, address to) private view {\n        require(from != to && to != address(0), \"Invalid address\");\n        require(msg.sender == from || isApprovedForAll(from, msg.sender), \"Unauthorized\");\n    }\n\n    /// @notice Decodes ids and amounts to PortfolioAsset objects\n    /// @param ids array of ERC1155 ids\n    /// @param amounts amounts to transfer\n    /// @return array of portfolio asset objects\n    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        // prettier-ignore\n        (PortfolioAsset[] memory assets, /* */) = _decodeToAssets(ids, amounts);\n        return assets;\n    }\n\n    function _decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        internal\n        view\n        returns (PortfolioAsset[] memory, bool)\n    {\n        uint256 blockTime = block.timestamp;\n        bool toTransferNegative = false;\n        PortfolioAsset[] memory assets = new PortfolioAsset[](ids.length);\n\n        for (uint256 i; i < ids.length; i++) {\n            (assets[i].currencyId, assets[i].maturity, assets[i].assetType) = TransferAssets\n                .decodeAssetId(ids[i]);\n\n            _assertValidMaturity(assets[i].currencyId, assets[i].maturity, blockTime);\n            // Although amounts is encoded as uint256 we allow it to be negative here. This will\n            // allow for bidirectional transfers of fCash. Internally fCash assets are always stored\n            // as int128 (for bitmap portfolio) or int88 (for array portfolio) so there is no potential\n            // that a uint256 value that is greater than type(int256).max would actually valid.\n            assets[i].notional = int256(amounts[i]);\n            // If there is a negative transfer we mark it as such, this will force us to do a free collateral\n            // check on the `to` address as well.\n            if (assets[i].notional < 0) toTransferNegative = true;\n        }\n\n        return (assets, toTransferNegative);\n    }\n\n    /// @notice Encodes parameters into an ERC1155 id\n    /// @param currencyId currency id of the asset\n    /// @param maturity timestamp of the maturity\n    /// @param assetType id of the asset type\n    /// @return ERC1155 id\n    function encodeToId(\n        uint16 currencyId,\n        uint40 maturity,\n        uint8 assetType\n    ) external pure override returns (uint256) {\n        return TransferAssets.encodeAssetId(currencyId, maturity, assetType);\n    }\n\n    /// @dev Ensures that all maturities specified are valid for the currency id (i.e. they do not\n    /// go past the max maturity date)\n    function _assertValidMaturity(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime\n    ) private view {\n        require(\n            DateTime.isValidMaturity(CashGroup.getMaxMarketIndex(currencyId), maturity, blockTime),\n            \"Invalid maturity\"\n        );\n    }\n\n    /// @dev Internal asset transfer event between accounts\n    function _transfer(\n        address from,\n        address to,\n        PortfolioAsset[] memory assets\n    ) internal returns (AccountContext memory, AccountContext memory) {\n        AccountContext memory fromContext = AccountContextHandler.getAccountContext(from);\n        AccountContext memory toContext = AccountContextHandler.getAccountContext(to);\n\n        toContext = TransferAssets.placeAssetsInAccount(to, toContext, assets);\n        TransferAssets.invertNotionalAmountsInPlace(assets);\n        fromContext = TransferAssets.placeAssetsInAccount(from, fromContext, assets);\n\n        toContext.setAccountContext(to);\n        fromContext.setAccountContext(from);\n\n        return (fromContext, toContext);\n    }\n\n    /// @dev Checks post transfer events which will either be initiating one of the batch trading events or a free collateral\n    /// check if required.\n    function _checkPostTransferEvent(\n        address from,\n        address to,\n        AccountContext memory fromContext,\n        AccountContext memory toContext,\n        bytes calldata data,\n        bool toTransferNegative\n    ) internal {\n        bytes4 sig;\n        address transactedAccount;\n        if (data.length >= 32) {\n            // Method signature is not abi encoded so decode to bytes32 first and take the first 4 bytes. This works\n            // because all the methods we want to call below require more than 32 bytes in the calldata\n            bytes32 tmp = abi.decode(data, (bytes32));\n            sig = bytes4(tmp);\n        }\n\n        // These are the only three methods allowed to occur in a post transfer event. These actions allow `from`\n        // accounts to take any sort of trading action as a result of their transfer. All of these actions will\n        // handle checking free collateral so no additional check is necessary here.\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == BatchAction.batchBalanceAction.selector ||\n            sig == BatchAction.batchBalanceAndTradeAction.selector\n        ) {\n            transactedAccount = abi.decode(data[4:36], (address));\n            // Ensure that the \"transactedAccount\" parameter of the call is set to the from address or the\n            // to address. If it is the \"to\" address then ensure that the msg.sender has approval to\n            // execute operations\n            require(\n                transactedAccount == from ||\n                    (transactedAccount == to && isApprovedForAll(to, msg.sender)),\n                \"Unauthorized call\"\n            );\n\n            (bool status, bytes memory result) = address(this).call{value: msg.value}(data);\n            // TODO: retrieve revert string\n            require(status, \"Call failed\");\n        }\n\n        // The transacted account will have its free collateral checked above so there is\n        // no need to recheck here.\n        if (transactedAccount != from && fromContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(from);\n        }\n\n        // Check free collateral if the `to` account has taken on a negative fCash amount\n        if (transactedAccount != to && toTransferNegative && toContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(to);\n        }\n    }\n\n    /// @notice Allows an account to set approval for an operator\n    /// @param operator address of the operator\n    /// @param approved state of the approval\n    /// @dev emit:ApprovalForAll\n    function setApprovalForAll(address operator, bool approved) external override {\n        accountAuthorizedTransferOperator[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @notice Checks approval state for an account, will first check if global transfer operator is enabled\n    /// before falling through to an account specific transfer operator.\n    /// @param account address of the account\n    /// @param operator address of the operator\n    /// @return true for approved\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (globalTransferOperator[operator]) return true;\n\n        return accountAuthorizedTransferOperator[account][operator];\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../SettleAssetsExternal.sol\";\nimport \"../FreeCollateralExternal.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../internal/balances/BalanceHandler.sol\";\nimport \"../../internal/AccountContextHandler.sol\";\n\ncontract AccountAction {\n    using BalanceHandler for BalanceState;\n    using AccountContextHandler for AccountContext;\n    using SafeInt256 for int256;\n\n    /// @notice Enables a bitmap currency for msg.sender, account cannot have any assets when this call\n    /// occurs.\n    /// @param currencyId the currency to enable the bitmap for\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    function enableBitmapCurrency(uint16 currencyId) external {\n        require(msg.sender != address(this)); // dev: no internal call to enableBitmapCurrency\n        address account = msg.sender;\n        AccountContext memory accountContext = _settleAccountIfRequiredAndFinalize(account);\n        accountContext.enableBitmapForAccount(account, currencyId, block.timestamp);\n        accountContext.setAccountContext(account);\n    }\n\n    /// @notice Method for manually settling an account, generally should not be called because other\n    /// methods will check if an account needs to be settled automatically. If a bitmap account has debt\n    /// and is settled via this method, the hasDebt flag will not be cleared until a free collateral check\n    /// is performed on the account.\n    /// @param account the account to settle\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:none\n    function settleAccount(address account) external {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        if (accountContext.mustSettleAssets()) {\n            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);\n            // Don't use the internal method here to avoid setting the account context if it does\n            // not require settlement\n            accountContext.setAccountContext(account);\n        }\n    }\n\n    /// @notice Deposits and wraps the underlying token for a particular cToken. Does not settle assets or check free\n    /// collateral, idea is to be as gas efficient as possible during potential liquidation events.\n    /// @param account the account to deposit into\n    /// @param currencyId currency id of the asset token that wraps this underlying\n    /// @param amountExternalPrecision the amount of underlying tokens in its native decimal precision\n    /// (i.e. 18 decimals for DAI or 6 decimals for USDC). This will be converted to 8 decimals during transfer.\n    /// @return asset tokens minted and deposited to the account in internal decimals (8)\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:none\n    function depositUnderlyingToken(\n        address account,\n        uint16 currencyId,\n        uint256 amountExternalPrecision\n    ) external payable returns (uint256) {\n        // No other authorization required on depositing\n        require(msg.sender != address(this)); // dev: no internal call to deposit underlying\n\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n\n        // Int conversion overflow check done inside this method call\n        // NOTE: using msg.sender here allows for a different sender to deposit tokens into the specified account. This may\n        // be useful for on-demand collateral top ups from a third party\n        int256 assetTokensReceivedInternal = balanceState.depositUnderlyingToken(\n            msg.sender,\n            int256(amountExternalPrecision)\n        );\n\n        balanceState.finalize(account, accountContext, false);\n        accountContext.setAccountContext(account);\n\n        require(assetTokensReceivedInternal > 0); // dev: asset tokens negative\n\n        // NOTE: no free collateral checks required for depositing\n        return uint256(assetTokensReceivedInternal);\n    }\n\n    /// @notice Deposits asset tokens into an account. Does not settle or check free collateral, idea is to\n    /// make deposit as gas efficient as possible during potential liquidation events.\n    /// @param account the account to deposit into\n    /// @param currencyId currency id of the asset token\n    /// @param amountExternalPrecision the amount of asset tokens in its native decimal precision\n    /// (i.e. 8 decimals for cTokens). This will be converted to 8 decimals during transfer if necessary.\n    /// @return asset tokens minted and deposited to the account in internal decimals (8)\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:none\n    function depositAssetToken(\n        address account,\n        uint16 currencyId,\n        uint256 amountExternalPrecision\n    ) external returns (uint256) {\n        require(msg.sender != address(this)); // dev: no internal call to deposit asset\n\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n\n        // Int conversion overflow check done inside this method call. msg.sender\n        // is used as the account in deposit to allow for other accounts to deposit\n        // on behalf of the given account.\n        int256 assetTokensReceivedInternal = balanceState.depositAssetToken(\n            msg.sender,\n            int256(amountExternalPrecision),\n            true // force transfer to ensure that msg.sender does the transfer, not account\n        );\n\n        balanceState.finalize(account, accountContext, false);\n        accountContext.setAccountContext(account);\n\n        require(assetTokensReceivedInternal > 0); // dev: asset tokens negative\n\n        // NOTE: no free collateral checks required for depositing\n        return uint256(assetTokensReceivedInternal);\n    }\n\n    /// @notice Withdraws balances from Notional, may also redeem to underlying tokens on user request. Will settle\n    /// and do free collateral checks if required. Can only be called by msg.sender, operators who want to withdraw for\n    /// an account must do an authenticated call via ERC1155Action `safeTransferFrom` or `safeBatchTransferFrom`\n    /// @param currencyId currency id of the asset token\n    /// @param amountInternalPrecision the amount of asset tokens in its native decimal precision\n    /// (i.e. 8 decimals for cTokens). This will be converted to 8 decimals during transfer if necessary.\n    /// @param redeemToUnderlying true if the tokens should be converted to underlying assets\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    /// @return the amount of tokens received by the account denominated in the destination token precision (if\n    // redeeming to underlying the amount will be the underlying amount received in that token's native precision)\n    function withdraw(\n        uint16 currencyId,\n        uint88 amountInternalPrecision,\n        bool redeemToUnderlying\n    ) external returns (uint256) {\n        address account = msg.sender;\n\n        // This happens before reading the balance state to get the most up to date cash balance\n        AccountContext memory accountContext = _settleAccountIfRequiredAndFinalize(account);\n\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n        require(balanceState.storedCashBalance >= amountInternalPrecision, \"Insufficient balance\");\n        balanceState.netAssetTransferInternalPrecision = int256(amountInternalPrecision).neg();\n\n        int256 amountWithdrawn = balanceState.finalize(account, accountContext, redeemToUnderlying);\n\n        accountContext.setAccountContext(account);\n        if (accountContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(account);\n        }\n\n        require(amountWithdrawn <= 0);\n        return uint256(amountWithdrawn.neg());\n    }\n\n    function _settleAccountIfRequiredAndFinalize(address account)\n        private\n        returns (AccountContext memory)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        if (accountContext.mustSettleAssets()) {\n            return SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);\n        }\n\n        return accountContext;\n    }\n}\n\n\n",
        "CodeNames": [
            "Router.sol",
            "Views.sol",
            "CompoundToNotionalV2.sol",
            "ERC1155Action.sol",
            "AccountAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "safeTransfer",
                    "IERC",
                    "transfer",
                    "cToken",
                    "CompoundToNotionalV",
                    "safeTransferFrom",
                    "void"
                ],
                "Type": "  CompoundToNotionalV2.notionalCallback  ERC20 return values not checked",
                "Description": "\nSome tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert. See CompoundToNotionalV2.notionalCallback's IERC20(underlyingToken).transferFrom call.\n\nTokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.\nThe fact that there is a cToken with USDT as the underlying this issue directly applies to the protocol.\n\nWe recommend using OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/68)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../internal/AccountContextHandler.sol\";\nimport \"../internal/valuation/FreeCollateral.sol\";\n\n/// @title Externally deployed library for free collateral calculations\nlibrary FreeCollateralExternal {\n    using AccountContextHandler for AccountContext;\n\n    /// @notice Returns the ETH denominated free collateral of an account, represents the amount of\n    /// debt that the account can incur before liquidation.\n    /// @dev Called via the Views.sol method to return an account's free collateral. Does not work\n    /// for the nToken\n    /// @param account account to calculate free collateral for\n    /// @return\n    ///     - total free collateral in ETH w/ 8 decimal places\n    ///     - array of net local values in asset values ordered\n    function getFreeCollateralView(address account)\n        external\n        view\n        returns (int256, int256[] memory)\n    {\n        uint256 blockTime = block.timestamp;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        return FreeCollateral.getFreeCollateralView(account, accountContext, blockTime);\n    }\n\n    /// @notice Calculates free collateral and will revert if it falls below zero. If the account context\n    /// must be updated due to changes in debt settings, will update\n    /// @param account account to calculate free collateral for\n    function checkFreeCollateralAndRevert(address account) external {\n        uint256 blockTime = block.timestamp;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n\n        (int256 ethDenominatedFC, bool updateContext) =\n            FreeCollateral.getFreeCollateralStateful(account, accountContext, blockTime);\n\n        if (updateContext) {\n            accountContext.setAccountContext(account);\n        }\n\n        require(ethDenominatedFC >= 0, \"Insufficient free collateral\");\n    }\n\n    /// @notice Calculates liquidation factors for an account\n    /// @param account account to liquidate\n    /// @param localCurrencyId currency that the debts are denominated in\n    /// @param collateralCurrencyId collateral currency to liquidate against, set to zero in the case of local currency liquidation\n    function getLiquidationFactors(\n        address account,\n        uint256 localCurrencyId,\n        uint256 collateralCurrencyId\n    )\n        external\n        returns (\n            AccountContext memory accountContext,\n            LiquidationFactors memory factors,\n            PortfolioAsset[] memory portfolio\n        )\n    {\n        accountContext = AccountContextHandler.getAccountContext(account);\n\n        if (accountContext.mustSettleAssets()) {\n            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);\n        }\n\n        (factors, portfolio) = FreeCollateral.getLiquidationFactors(\n            account,\n            accountContext,\n            block.timestamp,\n            localCurrencyId,\n            collateralCurrencyId\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        // borrow on notional via special flash loan facility\n        //  - borrow repayment amount\n        //  - withdraw to wallet, redeem to underlying\n        // receive callback (tokens transferred to borrowing account)\n        //   -> inside callback\n        //   -> repayBorrowBehalf(account, repayAmount)\n        //   -> deposit cToken to notional (account needs to have set approvals)\n        //   -> exit callback\n        // inside original borrow, check FC\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }\n\n    receive() external payable {\n        // This contract cannot migrate ETH loans because there is no way\n        // to do transferFrom on ETH\n        revert(\"Cannot transfer ETH\");\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Constants.sol\";\nimport \"../proxy/utils/UUPSUpgradeable.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\n\n/**\n * Read only version of the Router that can only be upgraded by governance. Used in emergency when the system must\n * be paused for some reason.\n */\ncontract PauseRouter is StorageLayoutV1, UUPSUpgradeable {\n    address public immutable VIEWS;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n\n    constructor(\n        address views_,\n        address liquidateCurrency_,\n        address liquidatefCash_\n    ) {\n        VIEWS = views_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override {\n        // This is only true during a rollback check when the pause router is downgraded\n        bool isRollbackCheck = rollbackRouterImplementation != address(0) &&\n            newImplementation == rollbackRouterImplementation;\n\n        require(\n            owner == msg.sender || (msg.sender == pauseGuardian && isRollbackCheck),\n            \"Unauthorized upgrade\"\n        );\n\n        // Clear this storage slot so the guardian cannot upgrade back to the previous router,\n        // requires governance to do so.\n        rollbackRouterImplementation = address(0);\n    }\n\n    function getLiquidationEnabledState() external view returns (bytes1) {\n        return liquidationEnabledState;\n    }\n\n    function setLiquidationEnabledState(bytes1 liquidationEnabledState_) external {\n        // Only authorized addresses can set the liquidation state\n        require(owner == msg.sender || msg.sender == pauseGuardian);\n        liquidationEnabledState = liquidationEnabledState_;\n    }\n\n    function isEnabled(bytes1 state) private view returns (bool) {\n        return (liquidationEnabledState & state == state);\n    }\n\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        // Liquidation calculation methods are stateful (they settle accounts if required)\n        // and therefore we prevent them from being called unless specifically authorized.\n        if (\n            (sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateCollateralCurrency.selector) &&\n            isEnabled(Constants.COLLATERAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateLocalCurrency.selector) &&\n            isEnabled(Constants.LOCAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashLocal.selector ||\n                sig == NotionalProxy.calculatefCashLocalLiquidation.selector) &&\n            isEnabled(Constants.LOCAL_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n                sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector) &&\n            isEnabled(Constants.CROSS_CURRENCY_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n}\n\n\n",
        "CodeNames": [
            "FreeCollateralExternal.sol",
            "CompoundToNotionalV2.sol",
            "PauseRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n// @audit sender can be passed in by the attacker\nrequire(sender == address(this), \"Unauthorized callback\");\n",
                    "//solidity\n// @audit using a malicious contract, this can be any token\naddress underlyingToken = CTokenInterface(cTokenBorrow).underlying();\nbool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\nrequire(success, \"Transfer of repayment failed\");\n\n// Use the amount transferred to repay the borrow\n// @audit using a malicious contract, this can be a no-op\nuint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n"
                ],
                "Type": " Access restrictions on  CompoundToNotionalV2.notionalCallback  can be bypassed",
                "Description": "\nThe CompoundToNotionalV2.notionalCallback is supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providing sender = this, as sender is a parameter of the function that can be chosen by the attacker.\n\nsolidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n// @audit sender can be passed in by the attacker\nrequire(sender == address(this), \"Unauthorized callback\");\n\n\nAn attacker can call the function passing in an arbitrary account whose tokens are then transferred to the contract.\nThe account first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker front-runs the actual transaction.\n\nIt's at least a griefing attack:\nI can pass in a malicious cTokenBorrow that returns any token of my choice (through the .underlying() call) but whose repayBorrowBehalf is a no-op.\n\n\nThis will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:\n\nsolidity\n// @audit using a malicious contract, this can be any token\naddress underlyingToken = CTokenInterface(cTokenBorrow).underlying();\nbool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\nrequire(success, \"Transfer of repayment failed\");\n\n// Use the amount transferred to repay the borrow\n// @audit using a malicious contract, this can be a no-op\nuint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n\n\nNote that the assumption at the end of the function \"// When this exits a free collateral check will be triggered\" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.\n\n",
                "Repair": "Recommend fixing the authorization check.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/69)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../internal/AccountContextHandler.sol\";\nimport \"../internal/valuation/FreeCollateral.sol\";\n\n/// @title Externally deployed library for free collateral calculations\nlibrary FreeCollateralExternal {\n    using AccountContextHandler for AccountContext;\n\n    /// @notice Returns the ETH denominated free collateral of an account, represents the amount of\n    /// debt that the account can incur before liquidation.\n    /// @dev Called via the Views.sol method to return an account's free collateral. Does not work\n    /// for the nToken\n    /// @param account account to calculate free collateral for\n    /// @return\n    ///     - total free collateral in ETH w/ 8 decimal places\n    ///     - array of net local values in asset values ordered\n    function getFreeCollateralView(address account)\n        external\n        view\n        returns (int256, int256[] memory)\n    {\n        uint256 blockTime = block.timestamp;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        return FreeCollateral.getFreeCollateralView(account, accountContext, blockTime);\n    }\n\n    /// @notice Calculates free collateral and will revert if it falls below zero. If the account context\n    /// must be updated due to changes in debt settings, will update\n    /// @param account account to calculate free collateral for\n    function checkFreeCollateralAndRevert(address account) external {\n        uint256 blockTime = block.timestamp;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n\n        (int256 ethDenominatedFC, bool updateContext) =\n            FreeCollateral.getFreeCollateralStateful(account, accountContext, blockTime);\n\n        if (updateContext) {\n            accountContext.setAccountContext(account);\n        }\n\n        require(ethDenominatedFC >= 0, \"Insufficient free collateral\");\n    }\n\n    /// @notice Calculates liquidation factors for an account\n    /// @param account account to liquidate\n    /// @param localCurrencyId currency that the debts are denominated in\n    /// @param collateralCurrencyId collateral currency to liquidate against, set to zero in the case of local currency liquidation\n    function getLiquidationFactors(\n        address account,\n        uint256 localCurrencyId,\n        uint256 collateralCurrencyId\n    )\n        external\n        returns (\n            AccountContext memory accountContext,\n            LiquidationFactors memory factors,\n            PortfolioAsset[] memory portfolio\n        )\n    {\n        accountContext = AccountContextHandler.getAccountContext(account);\n\n        if (accountContext.mustSettleAssets()) {\n            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);\n        }\n\n        (factors, portfolio) = FreeCollateral.getLiquidationFactors(\n            account,\n            accountContext,\n            block.timestamp,\n            localCurrencyId,\n            collateralCurrencyId\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../external/FreeCollateralExternal.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"../internal/valuation/ExchangeRate.sol\";\nimport \"../internal/markets/CashGroup.sol\";\nimport \"../internal/markets/AssetRate.sol\";\nimport \"../internal/nTokenHandler.sol\";\nimport \"../internal/balances/TokenHandler.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../math/SafeInt256.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"interfaces/notional/NotionalViews.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Views is StorageLayoutV1, NotionalViews {\n    using CashGroup for CashGroupParameters;\n    using TokenHandler for Token;\n    using Market for MarketParameters;\n    using AssetRate for AssetRateParameters;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n    using BalanceHandler for BalanceState;\n\n    /** Governance Parameter Getters **/\n\n    /// @notice Returns the current maximum currency id\n    function getMaxCurrencyId() external view override returns (uint16) {\n        return maxCurrencyId;\n    }\n\n    /// @notice Returns a currency id, a zero means that it is not listed.\n    function getCurrencyId(address tokenAddress)\n        external\n        view\n        override\n        returns (uint16 currencyId)\n    {\n        currencyId = tokenAddressToCurrencyId[tokenAddress];\n    }\n\n    /// @notice Returns the asset token and underlying token related to a given currency id. If underlying\n    /// token is not set then will return the zero address\n    function getCurrency(uint16 currencyId)\n        external\n        view\n        override\n        returns (Token memory assetToken, Token memory underlyingToken)\n    {\n        assetToken = TokenHandler.getToken(currencyId, false);\n        underlyingToken = TokenHandler.getToken(currencyId, true);\n    }\n\n    /// @notice Returns the ETH and Asset rates for a currency as stored, useful for viewing how they are configured\n    function getRateStorage(uint16 currencyId)\n        external\n        view\n        override\n        returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate)\n    {\n        ethRate = underlyingToETHRateMapping[currencyId];\n        assetRate = assetToUnderlyingRateMapping[currencyId];\n    }\n\n    /// @notice Returns a currency and its corresponding asset rate and ETH exchange rates. Note that this does not recalculate\n    /// cToken interest rates, it only retrieves the latest stored rate.\n    function getCurrencyAndRates(uint16 currencyId)\n        external\n        view\n        override\n        returns (\n            Token memory assetToken,\n            Token memory underlyingToken,\n            ETHRate memory ethRate,\n            AssetRateParameters memory assetRate\n        )\n    {\n        assetToken = TokenHandler.getToken(currencyId, false);\n        underlyingToken = TokenHandler.getToken(currencyId, false);\n        ethRate = ExchangeRate.buildExchangeRate(currencyId);\n        assetRate = AssetRate.buildAssetRateView(currencyId);\n    }\n\n    /// @notice Returns cash group settings for a currency\n    function getCashGroup(uint16 currencyId)\n        external\n        view\n        override\n        returns (CashGroupSettings memory)\n    {\n        return CashGroup.deserializeCashGroupStorage(currencyId);\n    }\n\n    /// @notice Returns the cash group along with the asset rate for convenience.\n    function getCashGroupAndAssetRate(uint16 currencyId)\n        external\n        view\n        override\n        returns (CashGroupSettings memory cashGroup, AssetRateParameters memory assetRate)\n    {\n        cashGroup = CashGroup.deserializeCashGroupStorage(currencyId);\n        assetRate = AssetRate.buildAssetRateView(currencyId);\n    }\n\n    /// @notice Returns market initialization parameters for a given currency\n    function getInitializationParameters(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)\n    {\n        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (annualizedAnchorRates, proportions) = nTokenHandler.getInitializationParameters(\n            currencyId,\n            maxMarketIndex\n        );\n    }\n\n    /// @notice Returns nToken deposit parameters for a given currency\n    function getDepositParameters(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\n    {\n        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (depositShares, leverageThresholds) = nTokenHandler.getDepositParameters(\n            currencyId,\n            maxMarketIndex\n        );\n    }\n\n    /// @notice Returns nToken address for a given currency\n    function nTokenAddress(uint16 currencyId) external view override returns (address) {\n        return nTokenHandler.nTokenAddress(currencyId);\n    }\n\n    /// @notice Returns address of contract owner\n    function getOwner() external view override returns (address) {\n        return owner;\n    }\n\n    /** Global System State View Methods **/\n\n    /// @notice Returns the asset settlement rate for a given maturity\n    function getSettlementRate(uint16 currencyId, uint40 maturity)\n        external\n        view\n        override\n        returns (AssetRateParameters memory)\n    {\n        return AssetRate.buildSettlementRateView(currencyId, maturity);\n    }\n\n    /// @notice Returns all currently active markets for a currency\n    function getActiveMarkets(uint16 currencyId)\n        external\n        view\n        override\n        returns (MarketParameters[] memory)\n    {\n        uint256 blockTime = block.timestamp;\n        return _getActiveMarketsAtBlockTime(currencyId, blockTime);\n    }\n\n    /// @notice Returns all active markets for a currency at the specified block time, useful for looking\n    /// at historical markets\n    function getActiveMarketsAtBlockTime(uint16 currencyId, uint32 blockTime)\n        external\n        view\n        override\n        returns (MarketParameters[] memory)\n    {\n        return _getActiveMarketsAtBlockTime(currencyId, blockTime);\n    }\n\n    function _getActiveMarketsAtBlockTime(uint256 currencyId, uint256 blockTime)\n        internal\n        view\n        returns (MarketParameters[] memory)\n    {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters[] memory markets = new MarketParameters[](cashGroup.maxMarketIndex);\n\n        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) {\n            cashGroup.loadMarket(markets[i], i + 1, true, blockTime);\n        }\n\n        return markets;\n    }\n\n    /// @notice Returns the current reserve balance for a currency\n    function getReserveBalance(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256 reserveBalance)\n    {\n        // prettier-ignore\n        (\n            reserveBalance,\n            /* */,\n            /* */,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n    }\n\n    function getNTokenPortfolio(address tokenAddress)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory liquidityTokens, PortfolioAsset[] memory netfCashAssets)\n    {\n        // prettier-ignore\n        (\n            uint256 currencyId,\n            /* incentiveRate */,\n            uint256 lastInitializedTime,\n            bytes6 parameters\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\n\n        liquidityTokens = PortfolioHandler.getSortedPortfolio(\n            tokenAddress,\n            uint8(parameters[Constants.ASSET_ARRAY_LENGTH])\n        );\n\n        netfCashAssets = BitmapAssetsHandler.getifCashArray(\n            tokenAddress,\n            currencyId,\n            lastInitializedTime\n        );\n    }\n\n    function getNTokenAccount(address tokenAddress)\n        external\n        view\n        override\n        returns (\n            uint256 currencyId,\n            uint256 totalSupply,\n            uint256 incentiveAnnualEmissionRate,\n            uint256 lastInitializedTime,\n            bytes6 nTokenParameters,\n            int256 cashBalance,\n            uint256 integralTotalSupply,\n            uint256 lastSupplyChangeTime\n        )\n    {\n        (\n            currencyId,\n            incentiveAnnualEmissionRate,\n            lastInitializedTime,\n            nTokenParameters\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\n\n        // prettier-ignore\n        (\n            totalSupply,\n            integralTotalSupply,\n            lastSupplyChangeTime\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(tokenAddress);\n\n        // prettier-ignore\n        (\n            cashBalance,\n            /* */,\n            /* */,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(tokenAddress, currencyId);\n    }\n\n    /** Account Specific View Methods **/\n\n    /// @notice Returns all account details in a single view\n    function getAccount(address account)\n        external\n        view\n        override\n        returns (\n            AccountContext memory accountContext,\n            AccountBalance[] memory accountBalances,\n            PortfolioAsset[] memory portfolio\n        )\n    {\n        accountContext = AccountContextHandler.getAccountContext(account);\n        accountBalances = new AccountBalance[](10);\n\n        uint256 i;\n        if (accountContext.bitmapCurrencyId != 0) {\n            (\n                accountBalances[i].cashBalance,\n                accountBalances[i].nTokenBalance,\n                accountBalances[i].lastClaimTime,\n                accountBalances[i].lastClaimIntegralSupply\n            ) = BalanceHandler.getBalanceStorage(account, accountContext.bitmapCurrencyId);\n            i += 1;\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            accountBalances[i].currencyId = uint256(\n                uint16(bytes2(currencies) & Constants.UNMASK_FLAGS)\n            );\n            if (accountBalances[i].currencyId == 0) break;\n\n            (\n                accountBalances[i].cashBalance,\n                accountBalances[i].nTokenBalance,\n                accountBalances[i].lastClaimTime,\n                accountBalances[i].lastClaimIntegralSupply\n            ) = BalanceHandler.getBalanceStorage(account, accountBalances[i].currencyId);\n            i += 1;\n            currencies = currencies << 16;\n        }\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            portfolio = BitmapAssetsHandler.getifCashArray(\n                account,\n                accountContext.bitmapCurrencyId,\n                accountContext.nextSettleTime\n            );\n        } else {\n            portfolio = PortfolioHandler.getSortedPortfolio(\n                account,\n                accountContext.assetArrayLength\n            );\n        }\n    }\n\n    /// @notice Returns account context\n    function getAccountContext(address account)\n        external\n        view\n        override\n        returns (AccountContext memory)\n    {\n        return AccountContextHandler.getAccountContext(account);\n    }\n\n    /// @notice Returns account balances for a given currency\n    function getAccountBalance(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (\n            int256 cashBalance,\n            int256 nTokenBalance,\n            uint256 lastClaimTime\n        )\n    {\n        // prettier-ignore\n        (\n            cashBalance,\n            nTokenBalance,\n            lastClaimTime,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n    }\n\n    /// @notice Returns account portfolio of assets\n    function getAccountPortfolio(address account)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        if (accountContext.bitmapCurrencyId != 0) {\n            return\n                BitmapAssetsHandler.getifCashArray(\n                    account,\n                    accountContext.bitmapCurrencyId,\n                    accountContext.nextSettleTime\n                );\n        } else {\n            return PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength);\n        }\n    }\n\n    /// @notice Returns the fCash amount at the specified maturity for a bitmapped portfolio\n    function getfCashNotional(\n        address account,\n        uint256 currencyId,\n        uint256 maturity\n    ) external view override returns (int256) {\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @notice Returns the assets bitmap for an account\n    function getAssetsBitmap(address account, uint256 currencyId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return BitmapAssetsHandler.getAssetsBitmap(account, currencyId);\n    }\n\n    /// @notice Returns free collateral of an account along with an array of the individual net available\n    /// asset cash amounts\n    function getFreeCollateral(address account)\n        external\n        view\n        override\n        returns (int256, int256[] memory)\n    {\n        return FreeCollateralExternal.getFreeCollateralView(account);\n    }\n\n    /** General Calculation View Methods **/\n\n    /// @notice Returns the nTokens that will be minted when some amount of asset tokens are deposited\n    function calculateNTokensToMint(uint16 currencyId, uint88 amountToDepositExternalPrecision)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        Token memory token = TokenHandler.getToken(currencyId, false);\n        int256 amountToDepositInternal =\n            token.convertToInternal(int256(amountToDepositExternalPrecision));\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 tokensToMint,\n            /* */\n        ) = nTokenMintAction.calculateTokensToMint(\n            nToken,\n            amountToDepositInternal,\n            block.timestamp\n        );\n\n        return SafeCast.toUint256(tokensToMint);\n    }\n\n    /// @notice Returns the fCash amount to send when given a cash amount, be sure to buffer these amounts\n    /// slightly because the liquidity curve is sensitive to changes in block time\n    function getfCashAmountGivenCashAmount(\n        uint16 currencyId,\n        int88 netCashToAccount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view override returns (int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters memory market;\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\n\n        require(market.maturity > blockTime, \"Invalid block time\");\n        uint256 timeToMaturity = market.maturity - blockTime;\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\n            Market.getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\n        int256 fee = Market.getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\n\n        return\n            Market.getfCashGivenCashAmount(\n                market.totalfCash,\n                int256(netCashToAccount),\n                totalCashUnderlying,\n                rateScalar,\n                rateAnchor,\n                fee,\n                0\n            );\n    }\n\n    /// @notice Returns the cash amount that will be traded given an fCash amount, be sure to buffer these amounts\n    /// slightly because the liquidity curve is sensitive to changes in block time\n    function getCashAmountGivenfCashAmount(\n        uint16 currencyId,\n        int88 fCashAmount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view override returns (int256, int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters memory market;\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\n\n        require(market.maturity > blockTime, \"Invalid block time\");\n        uint256 timeToMaturity = market.maturity - blockTime;\n\n        // prettier-ignore\n        (int256 assetCash, /* int fee */) =\n            market.calculateTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);\n\n        return (assetCash, cashGroup.assetRate.convertToUnderlying(assetCash));\n    }\n\n    /// @notice Returns the claimable incentives for all nToken balances\n    /// @param account The address of the account which holds the tokens\n    /// @param blockTime The block time when incentives will be minted\n    /// @return Incentives an account is eligible to claim\n    function nTokenGetClaimableIncentives(address account, uint256 blockTime)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        uint256 totalIncentivesClaimable;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\n\n                // prettier-ignore\n                (\n                    /* totalSupply */,\n                    uint256 integralTotalSupply,\n                    /* lastSupplyChangeTime */\n                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);\n\n                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(\n                    tokenAddress,\n                    uint256(balanceState.storedNTokenBalance),\n                    balanceState.lastClaimTime,\n                    balanceState.lastClaimIntegralSupply,\n                    blockTime,\n                    integralTotalSupply\n                );\n                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n\n            if (balanceState.storedNTokenBalance > 0) {\n                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\n\n                (\n                    /* totalSupply */,\n                    uint256 integralTotalSupply,\n                    /* lastSupplyChangeTime */\n                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);\n\n                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(\n                    nTokenHandler.nTokenAddress(balanceState.currencyId),\n                    uint256(balanceState.storedNTokenBalance),\n                    balanceState.lastClaimTime,\n                    balanceState.lastClaimIntegralSupply,\n                    blockTime,\n                    integralTotalSupply\n                );\n                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);\n            }\n\n            currencies = currencies << 16;\n        }\n\n        return totalIncentivesClaimable;\n    }\n\n    fallback() external {\n        revert(\"Method not found\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../internal/AccountContextHandler.sol\";\nimport \"../../internal/liquidation/LiquidateCurrency.sol\";\nimport \"../../internal/liquidation/LiquidationHelpers.sol\";\nimport \"../../math/SafeInt256.sol\";\n\ncontract LiquidateCurrencyAction {\n    using AccountContextHandler for AccountContext;\n    using BalanceHandler for BalanceState;\n    using SafeInt256 for int256;\n\n    event LiquidateLocalCurrency(\n        address indexed liquidated,\n        address indexed liquidator,\n        uint16 localCurrencyId,\n        int256 localAssetCashFromLiquidator\n    );\n\n    event LiquidateCollateralCurrency(\n        address indexed liquidated,\n        address indexed liquidator,\n        uint16 localCurrencyId,\n        uint16 collateralCurrencyId,\n        int256 localAssetCashFromLiquidator,\n        int256 netCollateralTransfer,\n        int256 netNTokenTransfer\n    );\n\n    /// @notice Calculates the net local currency required by the liquidator. This is a stateful method\n    /// because it may settle the liquidated account if required. However, it can be called using staticcall\n    /// off chain to determine the net local currency required before liquidating.\n    /// @param liquidateAccount account to liquidate\n    /// @param localCurrency id of the local currency\n    /// @param maxNTokenLiquidation maximum amount of nTokens to purchase (if any)\n    /// @return currency transfer amounts:\n    ///   - local currency required from liquidator (positive or negative)\n    ///   - local nTokens paid to liquidator (positive)\n    function calculateLocalCurrencyLiquidation(\n        address liquidateAccount,\n        uint256 localCurrency,\n        uint96 maxNTokenLiquidation\n    ) external returns (int256, int256) {\n        // prettier-ignore\n        (\n            int256 localAssetCashFromLiquidator,\n            BalanceState memory localBalanceState,\n            /* PortfolioState memory portfolio */,\n            /* AccountContext memory accountContext */,\n            /* MarketParameters[] memory markets */\n        ) = _localCurrencyLiquidation(liquidateAccount, localCurrency, maxNTokenLiquidation);\n\n        return (\n            localAssetCashFromLiquidator,\n            localBalanceState.netNTokenTransfer.neg()\n        );\n    }\n\n    /// @notice Liquidates an account using local currency only\n    /// @param liquidateAccount account to liquidate\n    /// @param localCurrency id of the local currency\n    /// @param maxNTokenLiquidation maximum amount of nTokens to purchase (if any)\n    /// @return currency transfer amounts:\n    ///   - local currency required from liquidator (positive or negative)\n    ///   - local nTokens paid to liquidator (positive)\n    function liquidateLocalCurrency(\n        address liquidateAccount,\n        uint256 localCurrency,\n        uint96 maxNTokenLiquidation\n    ) external returns (int256, int256) {\n        (\n            int256 localAssetCashFromLiquidator,\n            BalanceState memory localBalanceState,\n            PortfolioState memory portfolio,\n            AccountContext memory accountContext,\n            MarketParameters[] memory markets\n        ) = _localCurrencyLiquidation(liquidateAccount, localCurrency, maxNTokenLiquidation);\n\n        // Transfers a positive or negative amount of local currency as well as the net nToken\n        // amounts to the liquidator\n        AccountContext memory liquidatorContext =\n            LiquidationHelpers.finalizeLiquidatorLocal(\n                msg.sender,\n                localCurrency,\n                localAssetCashFromLiquidator,\n                localBalanceState.netNTokenTransfer.neg()\n            );\n        liquidatorContext.setAccountContext(msg.sender);\n\n        LiquidateCurrency.finalizeLiquidatedCollateralAndPortfolio(\n            liquidateAccount,\n            localBalanceState, // In this case, local currency is the collateral\n            accountContext,\n            portfolio,\n            markets\n        );\n\n        emit LiquidateLocalCurrency(\n            liquidateAccount,\n            msg.sender,\n            uint16(localCurrency),\n            localAssetCashFromLiquidator\n        );\n\n        return (\n            localAssetCashFromLiquidator,\n            localBalanceState.netNTokenTransfer.neg()\n        );\n    }\n\n    /// @notice Calculates local and collateral currency transfers for a liquidation. This is a stateful method\n    /// because it may settle the liquidated account if required. However, it can be called using staticcall\n    /// off chain to determine the net currency amounts required before liquidating.\n    /// @param liquidateAccount account to liquidate\n    /// @param localCurrency id of the local currency\n    /// @param collateralCurrency id of the collateral currency\n    /// @param maxCollateralLiquidation maximum amount of collateral (inclusive of cash and nTokens) to liquidate\n    /// @param maxNTokenLiquidation maximum amount of nTokens to purchase (if any)\n    /// @return currency transfer amounts:\n    ///   - local currency required from liquidator (negative)\n    ///   - collateral asset cash paid to liquidator (positive)\n    ///   - collateral nTokens paid to liquidator (positive)\n    function calculateCollateralCurrencyLiquidation(\n        address liquidateAccount,\n        uint256 localCurrency,\n        uint256 collateralCurrency,\n        uint128 maxCollateralLiquidation,\n        uint96 maxNTokenLiquidation\n    )\n        external\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        // prettier-ignore\n        (\n            int256 localAssetCashFromLiquidator,\n            BalanceState memory collateralBalanceState,\n            /* PortfolioState memory portfolio */,\n            /* AccountContext memory accountContext */,\n            /* MarketParameters[] memory markets */\n        ) = _collateralCurrencyLiquidation(\n                liquidateAccount,\n                localCurrency,\n                collateralCurrency,\n                maxCollateralLiquidation,\n                maxNTokenLiquidation\n            );\n\n        return (\n            localAssetCashFromLiquidator,\n            _collateralAssetCashToLiquidator(collateralBalanceState),\n            collateralBalanceState.netNTokenTransfer.neg()\n        );\n    }\n\n    /// @notice Liquidates an account between local and collateral currency\n    /// @param liquidateAccount account to liquidate\n    /// @param localCurrency id of the local currency\n    /// @param collateralCurrency id of the collateral currency\n    /// @param maxCollateralLiquidation maximum amount of collateral (inclusive of cash and nTokens) to liquidate\n    /// @param maxNTokenLiquidation maximum amount of nTokens to purchase (if any)\n    /// @param withdrawCollateral if true, withdraws collateral back to msg.sender\n    /// @param redeemToUnderlying if true, converts collateral from asset cash to underlying\n    /// @return currency transfer amounts:\n    ///   - local currency required from liquidator (negative)\n    ///   - collateral asset cash paid to liquidator (positive)\n    ///   - collateral nTokens paid to liquidator (positive)\n    function liquidateCollateralCurrency(\n        address liquidateAccount,\n        uint256 localCurrency,\n        uint256 collateralCurrency,\n        uint128 maxCollateralLiquidation,\n        uint96 maxNTokenLiquidation,\n        bool withdrawCollateral,\n        bool redeemToUnderlying\n    )\n        external\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        (\n            int256 localAssetCashFromLiquidator,\n            BalanceState memory collateralBalanceState,\n            PortfolioState memory portfolio,\n            AccountContext memory accountContext,\n            MarketParameters[] memory markets\n        ) =\n            _collateralCurrencyLiquidation(\n                liquidateAccount,\n                localCurrency,\n                collateralCurrency,\n                maxCollateralLiquidation,\n                maxNTokenLiquidation\n            );\n\n        _finalizeLiquidatorBalances(\n            localCurrency,\n            collateralCurrency,\n            localAssetCashFromLiquidator,\n            collateralBalanceState,\n            withdrawCollateral,\n            redeemToUnderlying\n        );\n\n        _emitCollateralEvent(\n            liquidateAccount,\n            uint16(localCurrency),\n            localAssetCashFromLiquidator,\n            collateralBalanceState\n        );\n\n        // Liquidated local currency balance will increase by the net paid from the liquidator\n        LiquidationHelpers.finalizeLiquidatedLocalBalance(\n            liquidateAccount,\n            localCurrency,\n            accountContext,\n            localAssetCashFromLiquidator\n        );\n\n        // netAssetTransfer is cleared and set back when finalizing inside this function\n        LiquidateCurrency.finalizeLiquidatedCollateralAndPortfolio(\n            liquidateAccount,\n            collateralBalanceState,\n            accountContext,\n            portfolio,\n            markets\n        );\n\n        return (\n            localAssetCashFromLiquidator,\n            _collateralAssetCashToLiquidator(collateralBalanceState),\n            collateralBalanceState.netNTokenTransfer.neg()\n        );\n    }\n\n    function _emitCollateralEvent(\n        address liquidateAccount,\n        uint256 localCurrency,\n        int256 localAssetCashFromLiquidator,\n        BalanceState memory collateralBalanceState\n    ) private {\n        emit LiquidateCollateralCurrency(\n            liquidateAccount,\n            msg.sender,\n            uint16(localCurrency),\n            uint16(collateralBalanceState.currencyId),\n            localAssetCashFromLiquidator,\n            _collateralAssetCashToLiquidator(collateralBalanceState),\n            collateralBalanceState.netNTokenTransfer.neg()\n        );\n    }\n\n    function _localCurrencyLiquidation(\n        address liquidateAccount,\n        uint256 localCurrency,\n        uint96 maxNTokenLiquidation\n    )\n        private\n        returns (\n            int256,\n            BalanceState memory,\n            PortfolioState memory,\n            AccountContext memory,\n            MarketParameters[] memory markets\n        )\n    {\n        uint256 blockTime = block.timestamp;\n        (\n            AccountContext memory accountContext,\n            LiquidationFactors memory factors,\n            PortfolioState memory portfolio\n        ) = LiquidationHelpers.preLiquidationActions(liquidateAccount, localCurrency, 0);\n        BalanceState memory localBalanceState;\n        localBalanceState.loadBalanceState(liquidateAccount, localCurrency, accountContext);\n\n        int256 localAssetCashFromLiquidator =\n            LiquidateCurrency.liquidateLocalCurrency(\n                localCurrency,\n                maxNTokenLiquidation,\n                blockTime,\n                localBalanceState,\n                factors,\n                portfolio\n            );\n\n        return (\n            localAssetCashFromLiquidator,\n            localBalanceState,\n            portfolio,\n            accountContext,\n            factors.markets\n        );\n    }\n\n    function _collateralCurrencyLiquidation(\n        address liquidateAccount,\n        uint256 localCurrency,\n        uint256 collateralCurrency,\n        uint128 maxCollateralLiquidation,\n        uint96 maxNTokenLiquidation\n    )\n        private\n        returns (\n            int256,\n            BalanceState memory,\n            PortfolioState memory,\n            AccountContext memory,\n            MarketParameters[] memory markets\n        )\n    {\n        uint256 blockTime = block.timestamp;\n        (\n            AccountContext memory accountContext,\n            LiquidationFactors memory factors,\n            PortfolioState memory portfolio\n        ) =\n            LiquidationHelpers.preLiquidationActions(\n                liquidateAccount,\n                localCurrency,\n                collateralCurrency\n            );\n\n        BalanceState memory collateralBalanceState;\n        collateralBalanceState.loadBalanceState(\n            liquidateAccount,\n            collateralCurrency,\n            accountContext\n        );\n\n        int256 localAssetCashFromLiquidator =\n            LiquidateCurrency.liquidateCollateralCurrency(\n                maxCollateralLiquidation,\n                maxNTokenLiquidation,\n                blockTime,\n                collateralBalanceState,\n                factors,\n                portfolio\n            );\n\n        return (\n            localAssetCashFromLiquidator,\n            collateralBalanceState,\n            portfolio,\n            accountContext,\n            factors.markets\n        );\n    }\n\n    /// @dev Only used for collateral currency liquidation\n    function _finalizeLiquidatorBalances(\n        uint256 localCurrency,\n        uint256 collateralCurrency,\n        int256 localAssetCashFromLiquidator,\n        BalanceState memory collateralBalanceState,\n        bool withdrawCollateral,\n        bool redeemToUnderlying\n    ) private {\n        // Will transfer local currency from the liquidator\n        AccountContext memory liquidatorContext =\n            LiquidationHelpers.finalizeLiquidatorLocal(\n                msg.sender,\n                localCurrency,\n                localAssetCashFromLiquidator,\n                0 // No nToken transfers\n            );\n\n        // Will transfer collateral to the liquidator\n        LiquidationHelpers.finalizeLiquidatorCollateral(\n            msg.sender,\n            liquidatorContext,\n            collateralCurrency,\n            _collateralAssetCashToLiquidator(collateralBalanceState),\n            collateralBalanceState.netNTokenTransfer.neg(),\n            withdrawCollateral,\n            redeemToUnderlying\n        );\n\n        liquidatorContext.setAccountContext(msg.sender);\n    }\n\n    function _collateralAssetCashToLiquidator(BalanceState memory collateralBalanceState)\n        private\n        pure\n        returns (int256)\n    {\n        return\n            collateralBalanceState.netCashChange.neg().add(\n                collateralBalanceState.netAssetTransferInternalPrecision\n            );\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Constants.sol\";\nimport \"../proxy/utils/UUPSUpgradeable.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\n\n/**\n * Read only version of the Router that can only be upgraded by governance. Used in emergency when the system must\n * be paused for some reason.\n */\ncontract PauseRouter is StorageLayoutV1, UUPSUpgradeable {\n    address public immutable VIEWS;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n\n    constructor(\n        address views_,\n        address liquidateCurrency_,\n        address liquidatefCash_\n    ) {\n        VIEWS = views_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override {\n        // This is only true during a rollback check when the pause router is downgraded\n        bool isRollbackCheck = rollbackRouterImplementation != address(0) &&\n            newImplementation == rollbackRouterImplementation;\n\n        require(\n            owner == msg.sender || (msg.sender == pauseGuardian && isRollbackCheck),\n            \"Unauthorized upgrade\"\n        );\n\n        // Clear this storage slot so the guardian cannot upgrade back to the previous router,\n        // requires governance to do so.\n        rollbackRouterImplementation = address(0);\n    }\n\n    function getLiquidationEnabledState() external view returns (bytes1) {\n        return liquidationEnabledState;\n    }\n\n    function setLiquidationEnabledState(bytes1 liquidationEnabledState_) external {\n        // Only authorized addresses can set the liquidation state\n        require(owner == msg.sender || msg.sender == pauseGuardian);\n        liquidationEnabledState = liquidationEnabledState_;\n    }\n\n    function isEnabled(bytes1 state) private view returns (bool) {\n        return (liquidationEnabledState & state == state);\n    }\n\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        // Liquidation calculation methods are stateful (they settle accounts if required)\n        // and therefore we prevent them from being called unless specifically authorized.\n        if (\n            (sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateCollateralCurrency.selector) &&\n            isEnabled(Constants.COLLATERAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateLocalCurrency.selector) &&\n            isEnabled(Constants.LOCAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashLocal.selector ||\n                sig == NotionalProxy.calculatefCashLocalLiquidation.selector) &&\n            isEnabled(Constants.LOCAL_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n                sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector) &&\n            isEnabled(Constants.CROSS_CURRENCY_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n}\n\n\n",
        "CodeNames": [
            "FreeCollateralExternal.sol",
            "Views.sol",
            "LiquidateCurrencyAction.sol",
            "PauseRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n    require(sender == address(this), \"Unauthorized callback\");\n"
                ],
                "Type": " Access restrictions on  NotionalV1ToNotionalV2.notionalCallback  can be bypassed",
                "Description": "\nThe NotionalV1ToNotionalV2.notionalCallback is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing sender = this as sender is a parameter of the function that can be chosen by the attacker.\n\nsolidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n    require(sender == address(this), \"Unauthorized callback\");\n\n\nAn attacker can call the function passing in an arbitrary account whose tokens can then be stolen.\nThe account first has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.\n\nThe attacker can steal the tokens by performing an attack similar to the following:\nfirst transaction is used to withdraw the victim's funds to the contract. This can be done by choosing account=victim, v1RepayAmount=0, v1CollateralId=WBTC, v2CollateralId=DAI. The NotionalV1Erc1155.batchOperationWithdraw(https://github.com/notional-finance/contracts/blob/4bf7a85e6cf81cde4283e0efab0b03f21249ba00/contracts/ERC1155Trade.sol#L108) (not part of this contest) will withdraw the victim's funds to this contract. Note that the attacker has to deposit the same v2CollateralBalance = uint256(collateralBalance) for the victim into the V2 version, but they can choose different cheaper collateral (for example, withdraw WBTC, deposit same amount of DAI).\nsecond transaction is now used to deposit the victim funds in the contract into the user's account. They use account=attacker, v1DebtCurrencyId=WBTC, v1RepayAmount=amount to deposit it into Notional V1. (They need to have a small collateralBalance, etc. to pass all checks).\n\n",
                "Repair": "Recommend fixing the authorization check.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../external/FreeCollateralExternal.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"../internal/valuation/ExchangeRate.sol\";\nimport \"../internal/markets/CashGroup.sol\";\nimport \"../internal/markets/AssetRate.sol\";\nimport \"../internal/nTokenHandler.sol\";\nimport \"../internal/balances/TokenHandler.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../math/SafeInt256.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"interfaces/notional/NotionalViews.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Views is StorageLayoutV1, NotionalViews {\n    using CashGroup for CashGroupParameters;\n    using TokenHandler for Token;\n    using Market for MarketParameters;\n    using AssetRate for AssetRateParameters;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n    using BalanceHandler for BalanceState;\n\n    /** Governance Parameter Getters **/\n\n    /// @notice Returns the current maximum currency id\n    function getMaxCurrencyId() external view override returns (uint16) {\n        return maxCurrencyId;\n    }\n\n    /// @notice Returns a currency id, a zero means that it is not listed.\n    function getCurrencyId(address tokenAddress)\n        external\n        view\n        override\n        returns (uint16 currencyId)\n    {\n        currencyId = tokenAddressToCurrencyId[tokenAddress];\n    }\n\n    /// @notice Returns the asset token and underlying token related to a given currency id. If underlying\n    /// token is not set then will return the zero address\n    function getCurrency(uint16 currencyId)\n        external\n        view\n        override\n        returns (Token memory assetToken, Token memory underlyingToken)\n    {\n        assetToken = TokenHandler.getToken(currencyId, false);\n        underlyingToken = TokenHandler.getToken(currencyId, true);\n    }\n\n    /// @notice Returns the ETH and Asset rates for a currency as stored, useful for viewing how they are configured\n    function getRateStorage(uint16 currencyId)\n        external\n        view\n        override\n        returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate)\n    {\n        ethRate = underlyingToETHRateMapping[currencyId];\n        assetRate = assetToUnderlyingRateMapping[currencyId];\n    }\n\n    /// @notice Returns a currency and its corresponding asset rate and ETH exchange rates. Note that this does not recalculate\n    /// cToken interest rates, it only retrieves the latest stored rate.\n    function getCurrencyAndRates(uint16 currencyId)\n        external\n        view\n        override\n        returns (\n            Token memory assetToken,\n            Token memory underlyingToken,\n            ETHRate memory ethRate,\n            AssetRateParameters memory assetRate\n        )\n    {\n        assetToken = TokenHandler.getToken(currencyId, false);\n        underlyingToken = TokenHandler.getToken(currencyId, false);\n        ethRate = ExchangeRate.buildExchangeRate(currencyId);\n        assetRate = AssetRate.buildAssetRateView(currencyId);\n    }\n\n    /// @notice Returns cash group settings for a currency\n    function getCashGroup(uint16 currencyId)\n        external\n        view\n        override\n        returns (CashGroupSettings memory)\n    {\n        return CashGroup.deserializeCashGroupStorage(currencyId);\n    }\n\n    /// @notice Returns the cash group along with the asset rate for convenience.\n    function getCashGroupAndAssetRate(uint16 currencyId)\n        external\n        view\n        override\n        returns (CashGroupSettings memory cashGroup, AssetRateParameters memory assetRate)\n    {\n        cashGroup = CashGroup.deserializeCashGroupStorage(currencyId);\n        assetRate = AssetRate.buildAssetRateView(currencyId);\n    }\n\n    /// @notice Returns market initialization parameters for a given currency\n    function getInitializationParameters(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)\n    {\n        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (annualizedAnchorRates, proportions) = nTokenHandler.getInitializationParameters(\n            currencyId,\n            maxMarketIndex\n        );\n    }\n\n    /// @notice Returns nToken deposit parameters for a given currency\n    function getDepositParameters(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\n    {\n        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (depositShares, leverageThresholds) = nTokenHandler.getDepositParameters(\n            currencyId,\n            maxMarketIndex\n        );\n    }\n\n    /// @notice Returns nToken address for a given currency\n    function nTokenAddress(uint16 currencyId) external view override returns (address) {\n        return nTokenHandler.nTokenAddress(currencyId);\n    }\n\n    /// @notice Returns address of contract owner\n    function getOwner() external view override returns (address) {\n        return owner;\n    }\n\n    /** Global System State View Methods **/\n\n    /// @notice Returns the asset settlement rate for a given maturity\n    function getSettlementRate(uint16 currencyId, uint40 maturity)\n        external\n        view\n        override\n        returns (AssetRateParameters memory)\n    {\n        return AssetRate.buildSettlementRateView(currencyId, maturity);\n    }\n\n    /// @notice Returns all currently active markets for a currency\n    function getActiveMarkets(uint16 currencyId)\n        external\n        view\n        override\n        returns (MarketParameters[] memory)\n    {\n        uint256 blockTime = block.timestamp;\n        return _getActiveMarketsAtBlockTime(currencyId, blockTime);\n    }\n\n    /// @notice Returns all active markets for a currency at the specified block time, useful for looking\n    /// at historical markets\n    function getActiveMarketsAtBlockTime(uint16 currencyId, uint32 blockTime)\n        external\n        view\n        override\n        returns (MarketParameters[] memory)\n    {\n        return _getActiveMarketsAtBlockTime(currencyId, blockTime);\n    }\n\n    function _getActiveMarketsAtBlockTime(uint256 currencyId, uint256 blockTime)\n        internal\n        view\n        returns (MarketParameters[] memory)\n    {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters[] memory markets = new MarketParameters[](cashGroup.maxMarketIndex);\n\n        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) {\n            cashGroup.loadMarket(markets[i], i + 1, true, blockTime);\n        }\n\n        return markets;\n    }\n\n    /// @notice Returns the current reserve balance for a currency\n    function getReserveBalance(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256 reserveBalance)\n    {\n        // prettier-ignore\n        (\n            reserveBalance,\n            /* */,\n            /* */,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n    }\n\n    function getNTokenPortfolio(address tokenAddress)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory liquidityTokens, PortfolioAsset[] memory netfCashAssets)\n    {\n        // prettier-ignore\n        (\n            uint256 currencyId,\n            /* incentiveRate */,\n            uint256 lastInitializedTime,\n            bytes6 parameters\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\n\n        liquidityTokens = PortfolioHandler.getSortedPortfolio(\n            tokenAddress,\n            uint8(parameters[Constants.ASSET_ARRAY_LENGTH])\n        );\n\n        netfCashAssets = BitmapAssetsHandler.getifCashArray(\n            tokenAddress,\n            currencyId,\n            lastInitializedTime\n        );\n    }\n\n    function getNTokenAccount(address tokenAddress)\n        external\n        view\n        override\n        returns (\n            uint256 currencyId,\n            uint256 totalSupply,\n            uint256 incentiveAnnualEmissionRate,\n            uint256 lastInitializedTime,\n            bytes6 nTokenParameters,\n            int256 cashBalance,\n            uint256 integralTotalSupply,\n            uint256 lastSupplyChangeTime\n        )\n    {\n        (\n            currencyId,\n            incentiveAnnualEmissionRate,\n            lastInitializedTime,\n            nTokenParameters\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\n\n        // prettier-ignore\n        (\n            totalSupply,\n            integralTotalSupply,\n            lastSupplyChangeTime\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(tokenAddress);\n\n        // prettier-ignore\n        (\n            cashBalance,\n            /* */,\n            /* */,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(tokenAddress, currencyId);\n    }\n\n    /** Account Specific View Methods **/\n\n    /// @notice Returns all account details in a single view\n    function getAccount(address account)\n        external\n        view\n        override\n        returns (\n            AccountContext memory accountContext,\n            AccountBalance[] memory accountBalances,\n            PortfolioAsset[] memory portfolio\n        )\n    {\n        accountContext = AccountContextHandler.getAccountContext(account);\n        accountBalances = new AccountBalance[](10);\n\n        uint256 i;\n        if (accountContext.bitmapCurrencyId != 0) {\n            (\n                accountBalances[i].cashBalance,\n                accountBalances[i].nTokenBalance,\n                accountBalances[i].lastClaimTime,\n                accountBalances[i].lastClaimIntegralSupply\n            ) = BalanceHandler.getBalanceStorage(account, accountContext.bitmapCurrencyId);\n            i += 1;\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            accountBalances[i].currencyId = uint256(\n                uint16(bytes2(currencies) & Constants.UNMASK_FLAGS)\n            );\n            if (accountBalances[i].currencyId == 0) break;\n\n            (\n                accountBalances[i].cashBalance,\n                accountBalances[i].nTokenBalance,\n                accountBalances[i].lastClaimTime,\n                accountBalances[i].lastClaimIntegralSupply\n            ) = BalanceHandler.getBalanceStorage(account, accountBalances[i].currencyId);\n            i += 1;\n            currencies = currencies << 16;\n        }\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            portfolio = BitmapAssetsHandler.getifCashArray(\n                account,\n                accountContext.bitmapCurrencyId,\n                accountContext.nextSettleTime\n            );\n        } else {\n            portfolio = PortfolioHandler.getSortedPortfolio(\n                account,\n                accountContext.assetArrayLength\n            );\n        }\n    }\n\n    /// @notice Returns account context\n    function getAccountContext(address account)\n        external\n        view\n        override\n        returns (AccountContext memory)\n    {\n        return AccountContextHandler.getAccountContext(account);\n    }\n\n    /// @notice Returns account balances for a given currency\n    function getAccountBalance(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (\n            int256 cashBalance,\n            int256 nTokenBalance,\n            uint256 lastClaimTime\n        )\n    {\n        // prettier-ignore\n        (\n            cashBalance,\n            nTokenBalance,\n            lastClaimTime,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n    }\n\n    /// @notice Returns account portfolio of assets\n    function getAccountPortfolio(address account)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        if (accountContext.bitmapCurrencyId != 0) {\n            return\n                BitmapAssetsHandler.getifCashArray(\n                    account,\n                    accountContext.bitmapCurrencyId,\n                    accountContext.nextSettleTime\n                );\n        } else {\n            return PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength);\n        }\n    }\n\n    /// @notice Returns the fCash amount at the specified maturity for a bitmapped portfolio\n    function getfCashNotional(\n        address account,\n        uint256 currencyId,\n        uint256 maturity\n    ) external view override returns (int256) {\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @notice Returns the assets bitmap for an account\n    function getAssetsBitmap(address account, uint256 currencyId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return BitmapAssetsHandler.getAssetsBitmap(account, currencyId);\n    }\n\n    /// @notice Returns free collateral of an account along with an array of the individual net available\n    /// asset cash amounts\n    function getFreeCollateral(address account)\n        external\n        view\n        override\n        returns (int256, int256[] memory)\n    {\n        return FreeCollateralExternal.getFreeCollateralView(account);\n    }\n\n    /** General Calculation View Methods **/\n\n    /// @notice Returns the nTokens that will be minted when some amount of asset tokens are deposited\n    function calculateNTokensToMint(uint16 currencyId, uint88 amountToDepositExternalPrecision)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        Token memory token = TokenHandler.getToken(currencyId, false);\n        int256 amountToDepositInternal =\n            token.convertToInternal(int256(amountToDepositExternalPrecision));\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 tokensToMint,\n            /* */\n        ) = nTokenMintAction.calculateTokensToMint(\n            nToken,\n            amountToDepositInternal,\n            block.timestamp\n        );\n\n        return SafeCast.toUint256(tokensToMint);\n    }\n\n    /// @notice Returns the fCash amount to send when given a cash amount, be sure to buffer these amounts\n    /// slightly because the liquidity curve is sensitive to changes in block time\n    function getfCashAmountGivenCashAmount(\n        uint16 currencyId,\n        int88 netCashToAccount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view override returns (int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters memory market;\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\n\n        require(market.maturity > blockTime, \"Invalid block time\");\n        uint256 timeToMaturity = market.maturity - blockTime;\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\n            Market.getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\n        int256 fee = Market.getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\n\n        return\n            Market.getfCashGivenCashAmount(\n                market.totalfCash,\n                int256(netCashToAccount),\n                totalCashUnderlying,\n                rateScalar,\n                rateAnchor,\n                fee,\n                0\n            );\n    }\n\n    /// @notice Returns the cash amount that will be traded given an fCash amount, be sure to buffer these amounts\n    /// slightly because the liquidity curve is sensitive to changes in block time\n    function getCashAmountGivenfCashAmount(\n        uint16 currencyId,\n        int88 fCashAmount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view override returns (int256, int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters memory market;\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\n\n        require(market.maturity > blockTime, \"Invalid block time\");\n        uint256 timeToMaturity = market.maturity - blockTime;\n\n        // prettier-ignore\n        (int256 assetCash, /* int fee */) =\n            market.calculateTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);\n\n        return (assetCash, cashGroup.assetRate.convertToUnderlying(assetCash));\n    }\n\n    /// @notice Returns the claimable incentives for all nToken balances\n    /// @param account The address of the account which holds the tokens\n    /// @param blockTime The block time when incentives will be minted\n    /// @return Incentives an account is eligible to claim\n    function nTokenGetClaimableIncentives(address account, uint256 blockTime)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        uint256 totalIncentivesClaimable;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\n\n                // prettier-ignore\n                (\n                    /* totalSupply */,\n                    uint256 integralTotalSupply,\n                    /* lastSupplyChangeTime */\n                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);\n\n                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(\n                    tokenAddress,\n                    uint256(balanceState.storedNTokenBalance),\n                    balanceState.lastClaimTime,\n                    balanceState.lastClaimIntegralSupply,\n                    blockTime,\n                    integralTotalSupply\n                );\n                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n\n            if (balanceState.storedNTokenBalance > 0) {\n                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\n\n                (\n                    /* totalSupply */,\n                    uint256 integralTotalSupply,\n                    /* lastSupplyChangeTime */\n                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);\n\n                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(\n                    nTokenHandler.nTokenAddress(balanceState.currencyId),\n                    uint256(balanceState.storedNTokenBalance),\n                    balanceState.lastClaimTime,\n                    balanceState.lastClaimIntegralSupply,\n                    blockTime,\n                    integralTotalSupply\n                );\n                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);\n            }\n\n            currencies = currencies << 16;\n        }\n\n        return totalIncentivesClaimable;\n    }\n\n    fallback() external {\n        revert(\"Method not found\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BatchAction.sol\";\nimport \"./nTokenRedeemAction.sol\";\nimport \"../FreeCollateralExternal.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"../../internal/AccountContextHandler.sol\";\nimport \"../../internal/portfolio/TransferAssets.sol\";\nimport \"../../internal/portfolio/PortfolioHandler.sol\";\nimport \"interfaces/IERC1155TokenReceiver.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\n\ncontract ERC1155Action is nERC1155Interface, StorageLayoutV1 {\n    using AccountContextHandler for AccountContext;\n\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(nERC1155Interface).interfaceId;\n    }\n\n    /// @notice Returns the balance of an ERC1155 id on an account. WARNING: the balances returned by\n    /// this method are int256 not uint256 as specified in ERC1155. Modify smart contracts accordingly.\n    /// @param account account to get the id for\n    /// @param id the ERC1155 id\n    /// @return Balance of the ERC1155 id as a signed integer\n    function balanceOf(address account, uint256 id) public view override returns (int256) {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        int256 notional;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            notional = _balanceInBitmap(account, accountContext.bitmapCurrencyId, id);\n        } else {\n            notional = _balanceInArray(\n                PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength),\n                id\n            );\n        }\n\n        return notional;\n    }\n\n    /// @notice Returns the balance of a batch of accounts and ids. WARNING: these balances are signed integers, not\n    /// unsigned integers as the ERC1155 spec designates\n    /// @param accounts array of accounts to get balances for\n    /// @param ids array of ids to get balances for\n    /// @return Returns an array of balances as signed integers\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        override\n        returns (int256[] memory)\n    {\n        require(accounts.length == ids.length);\n        int256[] memory amounts = new int256[](accounts.length);\n\n        for (uint256 i; i < accounts.length; i++) {\n            // This is pretty inefficient but gets the job done\n            amounts[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return amounts;\n    }\n\n    /// @dev Returns the balance from a bitmap given the id\n    function _balanceInBitmap(\n        address account,\n        uint256 bitmapCurrencyId,\n        uint256 id\n    ) internal view returns (int256) {\n        (uint256 currencyId, uint256 maturity, uint256 assetType) = TransferAssets.decodeAssetId(\n            id\n        );\n        if (currencyId != bitmapCurrencyId) return 0;\n        if (assetType != Constants.FCASH_ASSET_TYPE) return 0;\n\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @dev Searches an array for the matching asset\n    function _balanceInArray(PortfolioAsset[] memory portfolio, uint256 id)\n        internal\n        pure\n        returns (int256)\n    {\n        for (uint256 i; i < portfolio.length; i++) {\n            if (\n                TransferAssets.encodeAssetId(\n                    portfolio[i].currencyId,\n                    portfolio[i].maturity,\n                    portfolio[i].assetType\n                ) == id\n            ) return portfolio[i].notional;\n        }\n    }\n\n    /// @notice Transfer of a single fCash or liquidity token asset between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param id ERC1155 id of the asset\n    /// @param amount amount to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferSingle\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external payable override {\n        require(amount <= uint256(type(int256).max)); // dev: int overflow\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        // When amount is set to zero this method can be used as a way to execute trades via a transfer operator\n        AccountContext memory fromContext;\n        if (amount > 0) {\n            PortfolioAsset[] memory assets = new PortfolioAsset[](1);\n            (assets[0].currencyId, assets[0].maturity, assets[0].assetType) = TransferAssets\n                .decodeAssetId(id);\n            assets[0].notional = int256(amount);\n            _assertValidMaturity(assets[0].currencyId, assets[0].maturity, block.timestamp);\n\n            // prettier-ignore\n            (fromContext, /* toContext */) = _transfer(from, to, assets);\n\n            emit TransferSingle(msg.sender, from, to, id, amount);\n        } else {\n            fromContext = AccountContextHandler.getAccountContext(from);\n        }\n\n        // toContext is always empty here because we cannot have bidirectional transfers in `safeTransferFrom`\n        AccountContext memory toContext;\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, false);\n    }\n\n    /// @notice Transfer of a batch of fCash or liquidity token assets between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param ids ERC1155 ids of the assets\n    /// @param amounts amounts to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferBatch\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override {\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155_BATCH_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        (PortfolioAsset[] memory assets, bool toTransferNegative) = _decodeToAssets(ids, amounts);\n        // When doing a bidirectional transfer must ensure that the `to` account has given approval\n        // to msg.sender as well.\n        if (toTransferNegative) require(isApprovedForAll(to, msg.sender), \"Unauthorized\");\n\n        (AccountContext memory fromContext, AccountContext memory toContext) = _transfer(\n            from,\n            to,\n            assets\n        );\n\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, toTransferNegative);\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n    }\n\n    /// @dev Validates accounts on transfer\n    function _validateAccounts(address from, address to) private view {\n        require(from != to && to != address(0), \"Invalid address\");\n        require(msg.sender == from || isApprovedForAll(from, msg.sender), \"Unauthorized\");\n    }\n\n    /// @notice Decodes ids and amounts to PortfolioAsset objects\n    /// @param ids array of ERC1155 ids\n    /// @param amounts amounts to transfer\n    /// @return array of portfolio asset objects\n    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        // prettier-ignore\n        (PortfolioAsset[] memory assets, /* */) = _decodeToAssets(ids, amounts);\n        return assets;\n    }\n\n    function _decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        internal\n        view\n        returns (PortfolioAsset[] memory, bool)\n    {\n        uint256 blockTime = block.timestamp;\n        bool toTransferNegative = false;\n        PortfolioAsset[] memory assets = new PortfolioAsset[](ids.length);\n\n        for (uint256 i; i < ids.length; i++) {\n            (assets[i].currencyId, assets[i].maturity, assets[i].assetType) = TransferAssets\n                .decodeAssetId(ids[i]);\n\n            _assertValidMaturity(assets[i].currencyId, assets[i].maturity, blockTime);\n            // Although amounts is encoded as uint256 we allow it to be negative here. This will\n            // allow for bidirectional transfers of fCash. Internally fCash assets are always stored\n            // as int128 (for bitmap portfolio) or int88 (for array portfolio) so there is no potential\n            // that a uint256 value that is greater than type(int256).max would actually valid.\n            assets[i].notional = int256(amounts[i]);\n            // If there is a negative transfer we mark it as such, this will force us to do a free collateral\n            // check on the `to` address as well.\n            if (assets[i].notional < 0) toTransferNegative = true;\n        }\n\n        return (assets, toTransferNegative);\n    }\n\n    /// @notice Encodes parameters into an ERC1155 id\n    /// @param currencyId currency id of the asset\n    /// @param maturity timestamp of the maturity\n    /// @param assetType id of the asset type\n    /// @return ERC1155 id\n    function encodeToId(\n        uint16 currencyId,\n        uint40 maturity,\n        uint8 assetType\n    ) external pure override returns (uint256) {\n        return TransferAssets.encodeAssetId(currencyId, maturity, assetType);\n    }\n\n    /// @dev Ensures that all maturities specified are valid for the currency id (i.e. they do not\n    /// go past the max maturity date)\n    function _assertValidMaturity(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime\n    ) private view {\n        require(\n            DateTime.isValidMaturity(CashGroup.getMaxMarketIndex(currencyId), maturity, blockTime),\n            \"Invalid maturity\"\n        );\n    }\n\n    /// @dev Internal asset transfer event between accounts\n    function _transfer(\n        address from,\n        address to,\n        PortfolioAsset[] memory assets\n    ) internal returns (AccountContext memory, AccountContext memory) {\n        AccountContext memory fromContext = AccountContextHandler.getAccountContext(from);\n        AccountContext memory toContext = AccountContextHandler.getAccountContext(to);\n\n        toContext = TransferAssets.placeAssetsInAccount(to, toContext, assets);\n        TransferAssets.invertNotionalAmountsInPlace(assets);\n        fromContext = TransferAssets.placeAssetsInAccount(from, fromContext, assets);\n\n        toContext.setAccountContext(to);\n        fromContext.setAccountContext(from);\n\n        return (fromContext, toContext);\n    }\n\n    /// @dev Checks post transfer events which will either be initiating one of the batch trading events or a free collateral\n    /// check if required.\n    function _checkPostTransferEvent(\n        address from,\n        address to,\n        AccountContext memory fromContext,\n        AccountContext memory toContext,\n        bytes calldata data,\n        bool toTransferNegative\n    ) internal {\n        bytes4 sig;\n        address transactedAccount;\n        if (data.length >= 32) {\n            // Method signature is not abi encoded so decode to bytes32 first and take the first 4 bytes. This works\n            // because all the methods we want to call below require more than 32 bytes in the calldata\n            bytes32 tmp = abi.decode(data, (bytes32));\n            sig = bytes4(tmp);\n        }\n\n        // These are the only three methods allowed to occur in a post transfer event. These actions allow `from`\n        // accounts to take any sort of trading action as a result of their transfer. All of these actions will\n        // handle checking free collateral so no additional check is necessary here.\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == BatchAction.batchBalanceAction.selector ||\n            sig == BatchAction.batchBalanceAndTradeAction.selector\n        ) {\n            transactedAccount = abi.decode(data[4:36], (address));\n            // Ensure that the \"transactedAccount\" parameter of the call is set to the from address or the\n            // to address. If it is the \"to\" address then ensure that the msg.sender has approval to\n            // execute operations\n            require(\n                transactedAccount == from ||\n                    (transactedAccount == to && isApprovedForAll(to, msg.sender)),\n                \"Unauthorized call\"\n            );\n\n            (bool status, bytes memory result) = address(this).call{value: msg.value}(data);\n            // TODO: retrieve revert string\n            require(status, \"Call failed\");\n        }\n\n        // The transacted account will have its free collateral checked above so there is\n        // no need to recheck here.\n        if (transactedAccount != from && fromContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(from);\n        }\n\n        // Check free collateral if the `to` account has taken on a negative fCash amount\n        if (transactedAccount != to && toTransferNegative && toContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(to);\n        }\n    }\n\n    /// @notice Allows an account to set approval for an operator\n    /// @param operator address of the operator\n    /// @param approved state of the approval\n    /// @dev emit:ApprovalForAll\n    function setApprovalForAll(address operator, bool approved) external override {\n        accountAuthorizedTransferOperator[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @notice Checks approval state for an account, will first check if global transfer operator is enabled\n    /// before falling through to an account specific transfer operator.\n    /// @param account address of the account\n    /// @param operator address of the operator\n    /// @return true for approved\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (globalTransferOperator[operator]) return true;\n\n        return accountAuthorizedTransferOperator[account][operator];\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AssetRate.sol\";\nimport \"./CashGroup.sol\";\nimport \"./DateTime.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../math/ABDKMath64x64.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary Market {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using CashGroup for CashGroupParameters;\n    using AssetRate for AssetRateParameters;\n\n    bytes1 private constant STORAGE_STATE_NO_CHANGE = 0x00;\n    bytes1 private constant STORAGE_STATE_UPDATE_LIQUIDITY = 0x01;\n    bytes1 private constant STORAGE_STATE_UPDATE_TRADE = 0x02;\n    bytes1 internal constant STORAGE_STATE_INITIALIZE_MARKET = 0x03; // Both settings are set\n\n    // Max positive value for a ABDK64x64 integer\n    int256 private constant MAX64 = 0x7FFFFFFFFFFFFFFF;\n\n    /// @notice Add liquidity to a market, assuming that it is initialized. If not then\n    /// this method will revert and the market must be initialized first.\n    /// @return liquidityTokenAmount and net negative fCash\n    function addLiquidity(MarketParameters memory market, int256 assetCash)\n        internal\n        pure\n        returns (int256, int256)\n    {\n        require(market.totalLiquidity > 0, \"M: zero liquidity\");\n        if (assetCash == 0) return (0, 0);\n        require(assetCash > 0); // dev: negative asset cash\n\n        int256 liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);\n        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.\n        int256 fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);\n\n        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);\n        market.totalfCash = market.totalfCash.add(fCash);\n        market.totalAssetCash = market.totalAssetCash.add(assetCash);\n        market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;\n\n        return (liquidityTokens, fCash.neg());\n    }\n\n    /// @notice Remove liquidity from a market, assuming that it is initialized.\n    /// @return asset cash and positive fCash claim to return\n    function removeLiquidity(MarketParameters memory market, int256 tokensToRemove)\n        internal\n        pure\n        returns (int256, int256)\n    {\n        if (tokensToRemove == 0) return (0, 0);\n        require(tokensToRemove > 0); // dev: negative tokens to remove\n\n        int256 assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);\n        int256 fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);\n\n        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);\n        market.totalfCash = market.totalfCash.subNoNeg(fCash);\n        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);\n        market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;\n\n        return (assetCash, fCash);\n    }\n\n    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive\n    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.\n    /// @param market the current market state\n    /// @param cashGroup cash group configuration parameters\n    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change\n    /// to the market is in the opposite direction.\n    /// @param timeToMaturity number of seconds until maturity\n    /// @return netAssetCash, netAssetCashToReserve\n    function calculateTrade(\n        MarketParameters memory market,\n        CashGroupParameters memory cashGroup,\n        int256 fCashToAccount,\n        uint256 timeToMaturity,\n        uint256 marketIndex\n    ) internal view returns (int256, int256) {\n        // We return false if there is not enough fCash to support this trade.\n        if (market.totalfCash.sub(fCashToAccount) <= 0) return (0, 0);\n\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\n            getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\n\n        int256 preFeeExchangeRate;\n        {\n            bool success;\n            (preFeeExchangeRate, success) = _getExchangeRate(\n                market.totalfCash,\n                totalCashUnderlying,\n                rateScalar,\n                rateAnchor,\n                fCashToAccount\n            );\n            if (!success) return (0, 0);\n        }\n\n        (int256 netCashToAccount, int256 netCashToMarket, int256 netCashToReserve) =\n            _getNetCashAmountsUnderlying(\n                cashGroup,\n                preFeeExchangeRate,\n                fCashToAccount,\n                timeToMaturity\n            );\n        if (netCashToAccount == 0) return (0, 0);\n\n        {\n            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\n            market.lastImpliedRate = getImpliedRate(\n                market.totalfCash,\n                totalCashUnderlying.add(netCashToMarket),\n                rateScalar,\n                rateAnchor,\n                timeToMaturity\n            );\n\n            // It's technically possible that the implied rate is actually exactly zero (or\n            // more accurately the natural log rounds down to zero) but we will still fail\n            // in this case. If this does happen we may assume that markets are not initialized.\n            if (market.lastImpliedRate == 0) return (0, 0);\n        }\n\n        return\n            _setNewMarketState(\n                market,\n                cashGroup.assetRate,\n                netCashToAccount,\n                netCashToMarket,\n                netCashToReserve\n            );\n    }\n\n    /// @notice Returns factors for calculating exchange rates\n    function getExchangeRateFactors(\n        MarketParameters memory market,\n        CashGroupParameters memory cashGroup,\n        uint256 timeToMaturity,\n        uint256 marketIndex\n    )\n        internal\n        pure\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        int256 rateScalar = cashGroup.getRateScalar(marketIndex, timeToMaturity);\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\n\n        // This will result in a divide by zero\n        if (market.totalfCash == 0 || totalCashUnderlying == 0) return (0, 0, 0);\n\n        // Get the rate anchor given the market state, this will establish the baseline for where\n        // the exchange rate is set.\n        int256 rateAnchor;\n        {\n            bool success;\n            (rateAnchor, success) = _getRateAnchor(\n                market.totalfCash,\n                market.lastImpliedRate,\n                totalCashUnderlying,\n                rateScalar,\n                timeToMaturity\n            );\n            if (!success) return (0, 0, 0);\n        }\n\n        return (rateScalar, totalCashUnderlying, rateAnchor);\n    }\n\n    /// @dev Returns net asset cash amounts to the account, the market and the reserve\n    function _getNetCashAmountsUnderlying(\n        CashGroupParameters memory cashGroup,\n        int256 preFeeExchangeRate,\n        int256 fCashToAccount,\n        uint256 timeToMaturity\n    )\n        private\n        pure\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        // Fees are specified in basis points which is an implied rate denomination. We convert this to\n        // an exchange rate denomination for the given time to maturity. (i.e. get e^(fee * t) and multiply\n        // or divide depending on the side of the trade).\n        // tradeExchangeRate = exp((tradeInterestRateNoFee +/- fee) * timeToMaturity)\n        // tradeExchangeRate = tradeExchangeRateNoFee (* or /) exp(fee * timeToMaturity)\n        int256 preFeeCashToAccount =\n            fCashToAccount.divInRatePrecision(preFeeExchangeRate).neg();\n        int256 fee = getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\n\n        if (fCashToAccount > 0) {\n            // Lending\n            int256 postFeeExchangeRate = preFeeExchangeRate.divInRatePrecision(fee);\n            // It's possible that the fee pushes exchange rates into negative territory. This is not possible\n            // when borrowing. If this happens then the trade has failed.\n            if (postFeeExchangeRate < Constants.RATE_PRECISION) return (0, 0, 0);\n\n            // cashToAccount = -(fCashToAccount / exchangeRate)\n            // postFeeExchangeRate = preFeeExchangeRate / feeExchangeRate\n            // preFeeCashToAccount = -(fCashToAccount / preFeeExchangeRate)\n            // postFeeCashToAccount = -(fCashToAccount / postFeeExchangeRate)\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\n            // netFee = ((fCashToAccount * feeExchangeRate) / preFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (feeExchangeRate - 1)\n            // netFee = -(preFeeCashToAccount) * (feeExchangeRate - 1)\n            // netFee = preFeeCashToAccount * (1 - feeExchangeRate)\n            fee = preFeeCashToAccount.mulInRatePrecision(Constants.RATE_PRECISION.sub(fee));\n        } else {\n            // Borrowing\n            // cashToAccount = -(fCashToAccount / exchangeRate)\n            // postFeeExchangeRate = preFeeExchangeRate * feeExchangeRate\n\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\n            // netFee = ((fCashToAccount / (feeExchangeRate * preFeeExchangeRate)) - (fCashToAccount / preFeeExchangeRate)\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (1 / feeExchangeRate - 1)\n            // netFee = preFeeCashToAccount * ((1 - feeExchangeRate) / feeExchangeRate)\n            // NOTE: preFeeCashToAccount is negative in this branch so we negate it to ensure that fee is a positive number\n            fee = preFeeCashToAccount.mul(Constants.RATE_PRECISION.sub(fee)).div(fee).neg();\n        }\n\n        int256 cashToReserve =\n            fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);\n\n        return (\n            // postFeeCashToAccount = preFeeCashToAccount - fee\n            preFeeCashToAccount.sub(fee),\n            // netCashToMarket = -(preFeeCashToAccount - fee + cashToReserve)\n            (preFeeCashToAccount.sub(fee).add(cashToReserve)).neg(),\n            cashToReserve\n        );\n    }\n\n    function _setNewMarketState(\n        MarketParameters memory market,\n        AssetRateParameters memory assetRate,\n        int256 netCashToAccount,\n        int256 netCashToMarket,\n        int256 netCashToReserve\n    ) private view returns (int256, int256) {\n        int256 netAssetCashToMarket = assetRate.convertFromUnderlying(netCashToMarket);\n        market.totalAssetCash = market.totalAssetCash.add(netAssetCashToMarket);\n\n        // Sets the trade time for the next oracle update\n        market.previousTradeTime = block.timestamp;\n        market.storageState = market.storageState | STORAGE_STATE_UPDATE_TRADE;\n\n        int256 assetCashToReserve = assetRate.convertFromUnderlying(netCashToReserve);\n        int256 netAssetCashToAccount = assetRate.convertFromUnderlying(netCashToAccount);\n        return (netAssetCashToAccount, assetCashToReserve);\n    }\n\n    /// @notice Rate anchors update as the market gets closer to maturity. Rate anchors are not comparable\n    /// across time or markets but implied rates are. The goal here is to ensure that the implied rate\n    /// before and after the rate anchor update is the same. Therefore, the market will trade at the same implied\n    /// rate that it last traded at. If these anchors do not update then it opens up the opportunity for arbitrage\n    /// which will hurt the liquidity providers.\n    ///\n    /// The rate anchor will update as the market rolls down to maturity. The calculation is:\n    /// newExchangeRate = e^(lastImpliedRate * timeToMaturity / Constants.IMPLIED_RATE_TIME)\n    /// newAnchor = newExchangeRate - ln((proportion / (1 - proportion)) / rateScalar\n    ///\n    /// where:\n    /// lastImpliedRate = ln(exchangeRate') * (Constants.IMPLIED_RATE_TIME / timeToMaturity')\n    ///      (calculated when the last trade in the market was made)\n    /// @dev has an underscore to denote as private but is marked internal for the mock\n    /// @return the new rate anchor and a boolean that signifies success\n    function _getRateAnchor(\n        int256 totalfCash,\n        uint256 lastImpliedRate,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        uint256 timeToMaturity\n    ) internal pure returns (int256, bool) {\n        // This is the exchange rate at the new time to maturity\n        int256 exchangeRate = getExchangeRateFromImpliedRate(lastImpliedRate, timeToMaturity);\n        if (exchangeRate < Constants.RATE_PRECISION) return (0, false);\n\n        int256 rateAnchor;\n        {\n            int256 proportion =\n                totalfCash.divInRatePrecision(totalfCash.add(totalCashUnderlying));\n\n            (int256 lnProportion, bool success) = _logProportion(proportion);\n            if (!success) return (0, false);\n\n            rateAnchor = exchangeRate.sub(lnProportion.divInRatePrecision(rateScalar));\n        }\n\n        return (rateAnchor, true);\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return the implied rate and a bool that is true on success\n    function getImpliedRate(\n        int256 totalfCash,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToMaturity\n    ) internal pure returns (uint256) {\n        // This will check for exchange rates < Constants.RATE_PRECISION\n        (int256 exchangeRate, bool success) =\n            _getExchangeRate(totalfCash, totalCashUnderlying, rateScalar, rateAnchor, 0);\n        if (!success) return 0;\n\n        // Uses continuous compounding to calculate the implied rate:\n        // ln(exchangeRate) * Constants.IMPLIED_RATE_TIME / timeToMaturity\n        int128 rate = ABDKMath64x64.fromInt(exchangeRate);\n        int128 rateScaled = ABDKMath64x64.div(rate, Constants.RATE_PRECISION_64x64);\n        // We will not have a negative log here because we check that exchangeRate > Constants.RATE_PRECISION\n        // inside getExchangeRate\n        int128 lnRateScaled = ABDKMath64x64.ln(rateScaled);\n        uint256 lnRate =\n            ABDKMath64x64.toUInt(ABDKMath64x64.mul(lnRateScaled, Constants.RATE_PRECISION_64x64));\n\n        uint256 impliedRate = lnRate.mul(Constants.IMPLIED_RATE_TIME).div(timeToMaturity);\n\n        // Implied rates over 429% will overflow, this seems like a safe assumption\n        if (impliedRate > type(uint32).max) return 0;\n\n        return impliedRate;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The\n    /// formula is E = e^rt\n    function getExchangeRateFromImpliedRate(uint256 impliedRate, uint256 timeToMaturity)\n        internal\n        pure\n        returns (int256)\n    {\n        int128 expValue =\n            ABDKMath64x64.fromUInt(\n                impliedRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME)\n            );\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\n\n        return ABDKMath64x64.toInt(expResultScaled);\n    }\n\n    /// @notice Returns the exchange rate between fCash and cash for the given market\n    /// Calculates the following exchange rate:\n    ///     (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor\n    /// where:\n    ///     proportion = totalfCash / (totalfCash + totalUnderlyingCash)\n    /// @dev has an underscore to denote as private but is marked internal for the mock\n    function _getExchangeRate(\n        int256 totalfCash,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 fCashToAccount\n    ) internal pure returns (int256, bool) {\n        int256 numerator = totalfCash.subNoNeg(fCashToAccount);\n\n        // This is the proportion scaled by Constants.RATE_PRECISION\n        int256 proportion =\n            numerator.divInRatePrecision(totalfCash.add(totalCashUnderlying));\n\n        (int256 lnProportion, bool success) = _logProportion(proportion);\n        if (!success) return (0, false);\n\n        int256 rate = lnProportion.divInRatePrecision(rateScalar).add(rateAnchor);\n        // Do not succeed if interest rates fall below 1\n        if (rate < Constants.RATE_PRECISION) {\n            return (0, false);\n        } else {\n            return (rate, true);\n        }\n    }\n\n    /// @dev This method calculates the log of the proportion inside the logit function which is\n    /// defined as ln(proportion / (1 - proportion)). Special handling here is required to deal with\n    /// fixed point precision and the ABDK library.\n    function _logProportion(int256 proportion) internal pure returns (int256, bool) {\n        if (proportion == Constants.RATE_PRECISION) return (0, false);\n\n        proportion = proportion.divInRatePrecision(Constants.RATE_PRECISION.sub(proportion));\n\n        // This is the max 64 bit integer for ABDKMath. This is unlikely to trip because the\n        // value is 9.2e18 and the proportion is scaled by 1e9. We can hit very high levels of\n        // pool utilization before this returns false.\n        if (proportion > MAX64) return (0, false);\n\n        // ABDK does not handle log of numbers that are less than 1, in order to get the right value\n        // scaled by RATE_PRECISION we use the log identity:\n        // (ln(proportion / RATE_PRECISION)) * RATE_PRECISION = (ln(proportion) - ln(RATE_PRECISION)) * RATE_PRECISION\n        int128 abdkProportion = ABDKMath64x64.fromInt(proportion);\n        // Here, abdk will revert due to negative log so abort\n        if (abdkProportion <= 0) return (0, false);\n        int256 result =\n            ABDKMath64x64.toInt(\n                ABDKMath64x64.mul(\n                    ABDKMath64x64.sub(\n                        ABDKMath64x64.ln(abdkProportion),\n                        Constants.LOG_RATE_PRECISION_64x64\n                    ),\n                    Constants.RATE_PRECISION_64x64\n                )\n            );\n\n        return (result, true);\n    }\n\n    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value\n    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,\n    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.\n    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then\n    /// be liquidated.\n    ///\n    /// Oracle rates are calculated when the market is loaded from storage.\n    ///\n    /// The oracle rate is a lagged weighted average over a short term price window. If we are past\n    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the\n    /// weighted average:\n    ///     lastImpliedRatePreTrade * (currentTs - previousTs) / timeWindow +\n    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)\n    function _updateRateOracle(\n        uint256 previousTradeTime,\n        uint256 lastImpliedRate,\n        uint256 oracleRate,\n        uint256 rateOracleTimeWindow,\n        uint256 blockTime\n    ) private pure returns (uint256) {\n        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero\n\n        // This can occur when using a view function get to a market state in the past\n        if (previousTradeTime > blockTime) return lastImpliedRate;\n\n        uint256 timeDiff = blockTime.sub(previousTradeTime);\n        if (timeDiff > rateOracleTimeWindow) {\n            // If past the time window just return the lastImpliedRate\n            return lastImpliedRate;\n        }\n\n        // (currentTs - previousTs) / timeWindow\n        uint256 lastTradeWeight =\n            timeDiff.mul(uint256(Constants.RATE_PRECISION)).div(rateOracleTimeWindow);\n\n        // 1 - (currentTs - previousTs) / timeWindow\n        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);\n\n        uint256 newOracleRate =\n            (lastImpliedRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight))).div(\n                uint256(Constants.RATE_PRECISION)\n            );\n\n        return newOracleRate;\n    }\n\n    function getSlot(\n        uint256 currencyId,\n        uint256 settlementDate,\n        uint256 maturity\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    maturity,\n                    keccak256(\n                        abi.encode(\n                            settlementDate,\n                            keccak256(abi.encode(currencyId, Constants.MARKET_STORAGE_OFFSET))\n                        )\n                    )\n                )\n            );\n    }\n\n    /// @notice Liquidity is not required for lending and borrowing so we don't automatically read it. This method is called if we\n    /// do need to load the liquidity amount.\n    function getTotalLiquidity(MarketParameters memory market) internal view {\n        int256 totalLiquidity;\n        bytes32 slot = bytes32(uint256(market.storageSlot) + 1);\n\n        assembly {\n            totalLiquidity := sload(slot)\n        }\n        market.totalLiquidity = totalLiquidity;\n    }\n\n    function getOracleRate(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 rateOracleTimeWindow,\n        uint256 blockTime\n    ) internal view returns (uint256) {\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\n        bytes32 slot = getSlot(currencyId, settlementDate, maturity);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        uint256 lastImpliedRate = uint256(uint32(uint256(data >> 160)));\n        uint256 oracleRate = uint256(uint32(uint256(data >> 192)));\n        uint256 previousTradeTime = uint256(uint32(uint256(data >> 224)));\n\n        // If the oracle rate is set to zero this can only be because the markets have past their settlement\n        // date but the new set of markets has not yet been initialized. This means that accounts cannot be liquidated\n        // during this time, but market initialization can be called by anyone so the actual time that this condition\n        // exists for should be quite short.\n        require(oracleRate > 0, \"Market not initialized\");\n\n        return\n            _updateRateOracle(\n                previousTradeTime,\n                lastImpliedRate,\n                oracleRate,\n                rateOracleTimeWindow,\n                blockTime\n            );\n    }\n\n    /// @notice Reads a market object directly from storage. `buildMarket` should be called instead of this method\n    /// which ensures that the rate oracle is set properly.\n    function _loadMarketStorage(\n        MarketParameters memory market,\n        uint256 currencyId,\n        uint256 maturity,\n        bool needsLiquidity,\n        uint256 settlementDate\n    ) private view {\n        // Market object always uses the most current reference time as the settlement date\n        bytes32 slot = getSlot(currencyId, settlementDate, maturity);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        market.storageSlot = slot;\n        market.maturity = maturity;\n        market.totalfCash = int256(uint80(uint256(data)));\n        market.totalAssetCash = int256(uint80(uint256(data >> 80)));\n        market.lastImpliedRate = uint256(uint32(uint256(data >> 160)));\n        market.oracleRate = uint256(uint32(uint256(data >> 192)));\n        market.previousTradeTime = uint256(uint32(uint256(data >> 224)));\n        market.storageState = STORAGE_STATE_NO_CHANGE;\n\n        if (needsLiquidity) {\n            getTotalLiquidity(market);\n        } else {\n            market.totalLiquidity = 0;\n        }\n    }\n\n    /// @notice Writes market parameters to storage if the market is marked as updated.\n    function setMarketStorage(MarketParameters memory market) internal {\n        if (market.storageState == STORAGE_STATE_NO_CHANGE) return;\n        bytes32 slot = market.storageSlot;\n\n        if (market.storageState & STORAGE_STATE_UPDATE_TRADE != STORAGE_STATE_UPDATE_TRADE) {\n            // If no trade has occurred then the oracleRate on chain should not update.\n            bytes32 oldData;\n            assembly {\n                oldData := sload(slot)\n            }\n            market.oracleRate = uint256(uint32(uint256(oldData >> 192)));\n        }\n\n        require(market.totalfCash >= 0 && market.totalfCash <= type(uint80).max); // dev: market storage totalfCash overflow\n        require(market.totalAssetCash >= 0 && market.totalAssetCash <= type(uint80).max); // dev: market storage totalAssetCash overflow\n        require(market.lastImpliedRate >= 0 && market.lastImpliedRate <= type(uint32).max); // dev: market storage lastImpliedRate overflow\n        require(market.oracleRate >= 0 && market.oracleRate <= type(uint32).max); // dev: market storage oracleRate overflow\n        require(market.previousTradeTime >= 0 && market.previousTradeTime <= type(uint32).max); // dev: market storage previous trade time overflow\n\n        bytes32 data =\n            (bytes32(market.totalfCash) |\n                (bytes32(market.totalAssetCash) << 80) |\n                (bytes32(market.lastImpliedRate) << 160) |\n                (bytes32(market.oracleRate) << 192) |\n                (bytes32(market.previousTradeTime) << 224));\n\n        assembly {\n            sstore(slot, data)\n        }\n\n        if (\n            market.storageState & STORAGE_STATE_UPDATE_LIQUIDITY == STORAGE_STATE_UPDATE_LIQUIDITY\n        ) {\n            require(market.totalLiquidity >= 0 && market.totalLiquidity <= type(uint80).max); // dev: market storage totalLiquidity overflow\n            slot = bytes32(uint256(slot) + 1);\n            bytes32 totalLiquidity = bytes32(market.totalLiquidity);\n\n            assembly {\n                sstore(slot, totalLiquidity)\n            }\n        }\n    }\n\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately.\n    function loadMarket(\n        MarketParameters memory market,\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime,\n        bool needsLiquidity,\n        uint256 rateOracleTimeWindow\n    ) internal view {\n        // Always reference the current settlement date\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\n        loadMarketWithSettlementDate(\n            market,\n            currencyId,\n            maturity,\n            blockTime,\n            needsLiquidity,\n            rateOracleTimeWindow,\n            settlementDate\n        );\n    }\n\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately, this\n    /// is mainly used in the InitializeMarketAction contract.\n    function loadMarketWithSettlementDate(\n        MarketParameters memory market,\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime,\n        bool needsLiquidity,\n        uint256 rateOracleTimeWindow,\n        uint256 settlementDate\n    ) internal view {\n        _loadMarketStorage(market, currencyId, maturity, needsLiquidity, settlementDate);\n\n        market.oracleRate = _updateRateOracle(\n            market.previousTradeTime,\n            market.lastImpliedRate,\n            market.oracleRate,\n            rateOracleTimeWindow,\n            blockTime\n        );\n    }\n\n    /// @notice When settling liquidity tokens we only need to get half of the market parameters and the settlement\n    /// date must be specified.\n    function getSettlementMarket(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 settlementDate\n    ) internal view returns (SettlementMarket memory) {\n        uint256 slot = uint256(getSlot(currencyId, settlementDate, maturity));\n        int256 totalLiquidity;\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        int256 totalfCash = int256(uint80(uint256(data)));\n        int256 totalAssetCash = int256(uint80(uint256(data >> 80)));\n        // Clear the lower 160 bits, this data will be combined with the new totalfCash\n        // and totalAssetCash figures.\n        data = data & 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\n\n        slot = uint256(slot) + 1;\n\n        assembly {\n            totalLiquidity := sload(slot)\n        }\n\n        return\n            SettlementMarket({\n                storageSlot: bytes32(slot - 1),\n                totalfCash: totalfCash,\n                totalAssetCash: totalAssetCash,\n                totalLiquidity: int256(totalLiquidity),\n                data: data\n            });\n    }\n\n    function setSettlementMarket(SettlementMarket memory market) internal {\n        bytes32 slot = market.storageSlot;\n        bytes32 data;\n        require(market.totalfCash >= 0 && market.totalfCash <= type(uint80).max); // dev: settlement market storage totalfCash overflow\n        require(market.totalAssetCash >= 0 && market.totalAssetCash <= type(uint80).max); // dev: settlement market storage totalAssetCash overflow\n        require(market.totalLiquidity >= 0 && market.totalLiquidity <= type(uint80).max); // dev: settlement market storage totalLiquidity overflow\n\n        data = (bytes32(market.totalfCash) |\n            (bytes32(market.totalAssetCash) << 80) |\n            bytes32(market.data));\n\n        // Don't clear the storage even when all liquidity tokens have been removed because we need to use\n        // the oracle rates to initialize the next set of markets.\n        assembly {\n            sstore(slot, data)\n        }\n\n        slot = bytes32(uint256(slot) + 1);\n        bytes32 totalLiquidity = bytes32(market.totalLiquidity);\n        assembly {\n            sstore(slot, totalLiquidity)\n        }\n    }\n\n    /// Uses Newton's method to converge on an fCash amount given the amount of\n    /// cash. The relation between cash and fcash is:\n    /// cashAmount * exchangeRate * fee + fCash = 0\n    /// where exchangeRate(fCash) = (rateScalar ^ -1) * ln(p / (1 - p)) + rateAnchor\n    ///       p = (totalfCash - fCash) / (totalfCash + totalCash)\n    ///       if cashAmount < 0: fee = feeRate ^ -1\n    ///       if cashAmount > 0: fee = feeRate\n    ///\n    /// Newton's method is:\n    /// fCash_(n+1) = fCash_n - f(fCash) / f'(fCash)\n    ///\n    /// f(fCash) = cashAmount * exchangeRate(fCash) * fee + fCash\n    ///\n    ///                                    (totalfCash + totalCash)\n    /// exchangeRate'(fCash) = -  ------------------------------------------\n    ///                           (totalfCash - fCash) * (totalCash + fCash)\n    ///\n    /// https://www.wolframalpha.com/input/?i=ln%28%28%28a-x%29%2F%28a%2Bb%29%29%2F%281-%28a-x%29%2F%28a%2Bb%29%29%29\n    ///\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\n    /// f'(fCash) = 1 - ------------------------------------------------------\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\n    ///\n    /// NOTE: each iteration costs about 11.3k so this is only done via a view function.\n    function getfCashGivenCashAmount(\n        int256 totalfCash,\n        int256 netCashToAccount,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 feeRate,\n        uint256 maxDelta\n    ) internal pure returns (int256) {\n        int256 fCashChangeToAccountGuess =\n            netCashToAccount.mul(rateAnchor).div(Constants.RATE_PRECISION).neg();\n        for (uint8 i; i < 250; i++) {\n            (int256 exchangeRate, bool success) =\n                _getExchangeRate(\n                    totalfCash,\n                    totalCashUnderlying,\n                    rateScalar,\n                    rateAnchor,\n                    fCashChangeToAccountGuess\n                );\n\n            require(success); // dev: invalid exchange rate\n            int256 delta =\n                _calculateDelta(\n                    netCashToAccount,\n                    totalfCash,\n                    totalCashUnderlying,\n                    rateScalar,\n                    fCashChangeToAccountGuess,\n                    exchangeRate,\n                    feeRate\n                );\n\n            if (delta.abs() <= int256(maxDelta)) return fCashChangeToAccountGuess;\n            fCashChangeToAccountGuess = fCashChangeToAccountGuess.sub(delta);\n        }\n\n        revert(\"No convergence\");\n    }\n\n    /// @dev Calculates: f(fCash) / f'(fCash)\n    /// f(fCash) = cashAmount * exchangeRate * fee + fCash\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\n    /// f'(fCash) = 1 - ------------------------------------------------------\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\n    function _calculateDelta(\n        int256 cashAmount,\n        int256 totalfCash,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        int256 fCashGuess,\n        int256 exchangeRate,\n        int256 feeRate\n    ) private pure returns (int256) {\n        int256 derivative;\n        // rateScalar * (totalfCash - fCash) * (totalCash + fCash)\n        // Precision: TOKEN_PRECISION ^ 2\n        int256 denominator =\n            rateScalar.mulInRatePrecision(\n                (totalfCash.sub(fCashGuess)).mul(totalCashUnderlying.add(fCashGuess))\n            );\n\n        if (fCashGuess > 0) {\n            // Lending\n            exchangeRate = exchangeRate.divInRatePrecision(feeRate);\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\n\n            // (cashAmount / fee) * (totalfCash + totalCash)\n            // Precision: TOKEN_PRECISION ^ 2\n            derivative = cashAmount\n                .mul(totalfCash.add(totalCashUnderlying))\n                .divInRatePrecision(feeRate);\n        } else {\n            // Borrowing\n            exchangeRate = exchangeRate.mulInRatePrecision(feeRate);\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\n\n            // (cashAmount * fee) * (totalfCash + totalCash)\n            // Precision: TOKEN_PRECISION ^ 2\n            derivative = cashAmount.mulInRatePrecision(\n                feeRate.mul(totalfCash.add(totalCashUnderlying))\n            );\n        }\n        // 1 - numerator / denominator\n        // Precision: TOKEN_PRECISION\n        derivative = Constants.INTERNAL_TOKEN_PRECISION.sub(derivative.div(denominator));\n\n        // f(fCash) = cashAmount * exchangeRate * fee + fCash\n        // NOTE: exchangeRate at this point already has the fee taken into account\n        int256 numerator = cashAmount.mulInRatePrecision(exchangeRate);\n        numerator = numerator.add(fCashGuess);\n\n        // f(fCash) / f'(fCash), note that they are both denominated as cashAmount so use TOKEN_PRECISION\n        // here instead of RATE_PRECISION\n        return numerator.mul(Constants.INTERNAL_TOKEN_PRECISION).div(derivative);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Incentives.sol\";\nimport \"./TokenHandler.sol\";\nimport \"../AccountContextHandler.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../math/FloatingPoint56.sol\";\n\nlibrary BalanceHandler {\n    using SafeInt256 for int256;\n    using TokenHandler for Token;\n    using AssetRate for AssetRateParameters;\n    using AccountContextHandler for AccountContext;\n\n    /// @notice Emitted when a cash balance changes\n    event CashBalanceChange(address indexed account, uint16 currencyId, int256 netCashChange);\n    /// @notice Emitted when nToken supply changes (not the same as transfers)\n    event nTokenSupplyChange(address indexed account, uint16 currencyId, int256 tokenSupplyChange);\n\n    /// @notice Deposits asset tokens into an account\n    /// @dev Handles two special cases when depositing tokens into an account.\n    ///  - If a token has transfer fees then the amount specified does not equal the amount that the contract\n    ///    will receive. Complete the deposit here rather than in finalize so that the contract has the correct\n    ///    balance to work with.\n    ///  - Force a transfer before finalize to allow a different account to deposit into an account\n    /// @return Returns two values:\n    ///  - assetAmountInternal which is the converted asset amount accounting for transfer fees\n    ///  - assetAmountTransferred which is the internal precision amount transferred into the account\n    function depositAssetToken(\n        BalanceState memory balanceState,\n        address account,\n        int256 assetAmountExternal,\n        bool forceTransfer\n    ) internal returns (int256) {\n        if (assetAmountExternal == 0) return 0;\n        require(assetAmountExternal > 0); // dev: deposit asset token amount negative\n        Token memory token = TokenHandler.getToken(balanceState.currencyId, false);\n        int256 assetAmountInternal = token.convertToInternal(assetAmountExternal);\n\n        // Force transfer is used to complete the transfer before going to finalize\n        if (token.hasTransferFee || forceTransfer) {\n            // If the token has a transfer fee the deposit amount may not equal the actual amount\n            // that the contract will receive. We handle the deposit here and then update the netCashChange\n            // accordingly which is denominated in internal precision.\n            int256 assetAmountExternalPrecisionFinal = token.transfer(account, assetAmountExternal);\n            // Convert the external precision to internal, it's possible that we lose dust amounts here but\n            // this is unavoidable because we do not know how transfer fees are calculated.\n            assetAmountInternal = token.convertToInternal(assetAmountExternalPrecisionFinal);\n            balanceState.netCashChange = balanceState.netCashChange.add(assetAmountInternal);\n\n            return assetAmountInternal;\n        }\n\n        // Otherwise add the asset amount here. It may be net off later and we want to only do\n        // a single transfer during the finalize method. Use internal precision to ensure that internal accounting\n        // and external account remain in sync.\n        balanceState.netAssetTransferInternalPrecision = balanceState\n            .netAssetTransferInternalPrecision\n            .add(assetAmountInternal);\n\n        // Returns the converted assetAmountExternal to the internal amount\n        return assetAmountInternal;\n    }\n\n    /// @notice Handle deposits of the underlying token\n    /// @dev In this case we must wrap the underlying token into an asset token, ensuring that we do not end up\n    /// with any underlying tokens left as dust on the contract.\n    function depositUnderlyingToken(\n        BalanceState memory balanceState,\n        address account,\n        int256 underlyingAmountExternal\n    ) internal returns (int256) {\n        if (underlyingAmountExternal == 0) return 0;\n        require(underlyingAmountExternal > 0); // dev: deposit underlying token negative\n\n        Token memory underlyingToken = TokenHandler.getToken(balanceState.currencyId, true);\n        // This is the exact amount of underlying tokens the account has in external precision.\n        if (underlyingToken.tokenType == TokenType.Ether) {\n            require(underlyingAmountExternal == int256(msg.value), \"Invalid ETH balance\");\n        } else {\n            underlyingAmountExternal = underlyingToken.transfer(account, underlyingAmountExternal);\n        }\n\n        Token memory assetToken = TokenHandler.getToken(balanceState.currencyId, false);\n        // Tokens that are not mintable like cTokens will be deposited as assetTokens\n        require(assetToken.tokenType == TokenType.cToken || assetToken.tokenType == TokenType.cETH); // dev: deposit underlying token invalid token type\n        int256 assetTokensReceivedExternalPrecision =\n            assetToken.mint(uint256(underlyingAmountExternal));\n\n        // cTokens match INTERNAL_TOKEN_PRECISION so this will short circuit but we leave this here in case a different\n        // type of asset token is listed in the future. It's possible if those tokens have a different precision dust may\n        // accrue but that is not relevant now.\n        int256 assetTokensReceivedInternal =\n            assetToken.convertToInternal(assetTokensReceivedExternalPrecision);\n        balanceState.netCashChange = balanceState.netCashChange.add(assetTokensReceivedInternal);\n\n        return assetTokensReceivedInternal;\n    }\n\n    /// @notice Finalizes an account's balances, handling any transfer logic required\n    /// @dev This method SHOULD NOT be used for nToken accounts, for that use setBalanceStorageForNToken\n    /// as the nToken is limited in what types of balances it can hold.\n    function finalize(\n        BalanceState memory balanceState,\n        address account,\n        AccountContext memory accountContext,\n        bool redeemToUnderlying\n    ) internal returns (int256 transferAmountExternal) {\n        bool mustUpdate;\n        if (balanceState.netNTokenTransfer < 0) {\n            require(\n                balanceState.storedNTokenBalance.add(balanceState.netNTokenSupplyChange) >=\n                    balanceState.netNTokenTransfer.neg(),\n                \"Neg withdraw\"\n            );\n        }\n\n        if (balanceState.netAssetTransferInternalPrecision < 0) {\n            require(\n                balanceState.storedCashBalance.add(balanceState.netCashChange).add(\n                    balanceState.netAssetTransferInternalPrecision\n                ) >= 0,\n                \"Neg withdraw\"\n            );\n        }\n\n        if (balanceState.netAssetTransferInternalPrecision != 0) {\n            transferAmountExternal = _finalizeTransfers(balanceState, account, redeemToUnderlying);\n        }\n\n        if (\n            balanceState.netCashChange != 0 || balanceState.netAssetTransferInternalPrecision != 0\n        ) {\n            balanceState.storedCashBalance = balanceState\n                .storedCashBalance\n                .add(balanceState.netCashChange)\n                .add(balanceState.netAssetTransferInternalPrecision);\n\n            mustUpdate = true;\n\n            emit CashBalanceChange(\n                account,\n                uint16(balanceState.currencyId),\n                balanceState.netCashChange.add(balanceState.netAssetTransferInternalPrecision)\n            );\n        }\n\n        if (balanceState.netNTokenTransfer != 0 || balanceState.netNTokenSupplyChange != 0) {\n            // It's crucial that incentives are claimed before we do any sort of nToken transfer to prevent gaming\n            // of the system. This method will update the lastClaimTime time in the balanceState for storage.\n            Incentives.claimIncentives(balanceState, account);\n\n            // nTokens are within the notional system so we can update balances directly.\n            balanceState.storedNTokenBalance = balanceState\n                .storedNTokenBalance\n                .add(balanceState.netNTokenTransfer)\n                .add(balanceState.netNTokenSupplyChange);\n\n            if (balanceState.netNTokenSupplyChange != 0) {\n                emit nTokenSupplyChange(\n                    account,\n                    uint16(balanceState.currencyId),\n                    balanceState.netNTokenSupplyChange\n                );\n            }\n\n            mustUpdate = true;\n        }\n\n        if (mustUpdate) {\n            _setBalanceStorage(\n                account,\n                balanceState.currencyId,\n                balanceState.storedCashBalance,\n                balanceState.storedNTokenBalance,\n                balanceState.lastClaimTime,\n                balanceState.lastClaimIntegralSupply\n            );\n        }\n\n        accountContext.setActiveCurrency(\n            balanceState.currencyId,\n            // Set active currency to true if either balance is non-zero\n            balanceState.storedCashBalance != 0 || balanceState.storedNTokenBalance != 0,\n            Constants.ACTIVE_IN_BALANCES\n        );\n\n        if (balanceState.storedCashBalance < 0) {\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check where all balances\n            // are examined\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\n        }\n\n        return transferAmountExternal;\n    }\n\n    /// @dev Returns the amount transferred in underlying or asset terms depending on how redeem to underlying\n    /// is specified.\n    function _finalizeTransfers(\n        BalanceState memory balanceState,\n        address account,\n        bool redeemToUnderlying\n    ) private returns (int256 actualTransferAmountExternal) {\n        Token memory assetToken = TokenHandler.getToken(balanceState.currencyId, false);\n        int256 assetTransferAmountExternal =\n            assetToken.convertToExternal(balanceState.netAssetTransferInternalPrecision);\n\n        // We only do the redeem to underlying if the asset transfer amount is less than zero. If it is greater than\n        // zero then we will do a normal transfer instead. We know in this function that the value will not be zero.\n        if (redeemToUnderlying && assetTransferAmountExternal < 0) {\n            // We use the internal amount here and then scale it to the external amount so that there is\n            // no loss of precision between our internal accounting and the external account. In this case\n            // there will be no dust accrual since we will transfer the exact amount of underlying that was\n            // received.\n            Token memory underlyingToken = TokenHandler.getToken(balanceState.currencyId, true);\n            int256 underlyingAmountExternal = assetToken.redeem(\n                underlyingToken,\n                // NOTE: dust may accrue at the lowest decimal place\n                uint256(assetTransferAmountExternal.neg())\n            );\n\n            // Withdraws the underlying amount out to the destination account\n            actualTransferAmountExternal = underlyingToken.transfer(\n                account,\n                underlyingAmountExternal.neg()\n            );\n        } else {\n            assetTransferAmountExternal = assetToken.transfer(account, assetTransferAmountExternal);\n            actualTransferAmountExternal = assetTransferAmountExternal;\n        }\n\n        // Convert the actual transferred amount\n        balanceState.netAssetTransferInternalPrecision = assetToken.convertToInternal(\n            assetTransferAmountExternal\n        );\n\n        return actualTransferAmountExternal;\n    }\n\n    /// @notice Special method for settling negative current cash debts. This occurs when an account\n    /// has a negative fCash balance settle to cash. A settler may come and force the account to borrow\n    /// at the prevailing 3 month rate\n    /// @dev Use this method to avoid any nToken and transfer logic in finalize which is unnecessary.\n    function setBalanceStorageForSettleCashDebt(\n        address account,\n        CashGroupParameters memory cashGroup,\n        int256 amountToSettleAsset,\n        AccountContext memory accountContext\n    ) internal returns (int256) {\n        require(amountToSettleAsset >= 0); // dev: amount to settle negative\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 lastClaimIntegralSupply) =\n            getBalanceStorage(account, cashGroup.currencyId);\n\n        require(cashBalance < 0, \"Invalid settle balance\");\n        if (amountToSettleAsset == 0) {\n            // Symbolizes that the entire debt should be settled\n            amountToSettleAsset = cashBalance.neg();\n            cashBalance = 0;\n        } else {\n            // A partial settlement of the debt\n            require(amountToSettleAsset <= cashBalance.neg(), \"Invalid amount to settle\");\n            cashBalance = cashBalance.add(amountToSettleAsset);\n        }\n\n        // NOTE: we do not update HAS_CASH_DEBT here because it is possible that the other balances\n        // also have cash debts\n        if (cashBalance == 0 && nTokenBalance == 0) {\n            accountContext.setActiveCurrency(\n                cashGroup.currencyId,\n                false,\n                Constants.ACTIVE_IN_BALANCES\n            );\n        }\n\n        _setBalanceStorage(\n            account,\n            cashGroup.currencyId,\n            cashBalance,\n            nTokenBalance,\n            lastClaimTime,\n            lastClaimIntegralSupply\n        );\n\n        // Emit the event here, we do not call finalize\n        emit CashBalanceChange(account, uint16(cashGroup.currencyId), amountToSettleAsset);\n\n        return amountToSettleAsset;\n    }\n\n    /// @notice Helper method for settling the output of the SettleAssets method\n    function finalizeSettleAmounts(\n        address account,\n        AccountContext memory accountContext,\n        SettleAmount[] memory settleAmounts\n    ) internal {\n        for (uint256 i; i < settleAmounts.length; i++) {\n            if (settleAmounts[i].netCashChange == 0) continue;\n\n            (\n                int256 cashBalance,\n                int256 nTokenBalance,\n                uint256 lastClaimTime,\n                uint256 lastClaimIntegralSupply\n            ) = getBalanceStorage(account, settleAmounts[i].currencyId);\n\n            cashBalance = cashBalance.add(settleAmounts[i].netCashChange);\n            accountContext.setActiveCurrency(\n                settleAmounts[i].currencyId,\n                cashBalance != 0 || nTokenBalance != 0,\n                Constants.ACTIVE_IN_BALANCES\n            );\n\n            if (cashBalance < 0) {\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\n            }\n\n            emit CashBalanceChange(\n                account,\n                uint16(settleAmounts[i].currencyId),\n                settleAmounts[i].netCashChange\n            );\n\n            _setBalanceStorage(\n                account,\n                settleAmounts[i].currencyId,\n                cashBalance,\n                nTokenBalance,\n                lastClaimTime,\n                lastClaimIntegralSupply\n            );\n        }\n    }\n\n    /// @notice Special method for setting balance storage for nToken\n    function setBalanceStorageForNToken(\n        address nTokenAddress,\n        uint256 currencyId,\n        int256 cashBalance\n    ) internal {\n        require(cashBalance >= 0); // dev: invalid nToken cash balance\n        _setBalanceStorage(nTokenAddress, currencyId, cashBalance, 0, 0, 0);\n    }\n\n    /// @notice increments fees to the reserve\n    function incrementFeeToReserve(uint256 currencyId, int256 fee) internal {\n        require(fee >= 0); // dev: invalid fee\n        // prettier-ignore\n        (int256 totalReserve, /* */, /* */, /* */) = getBalanceStorage(Constants.RESERVE, currencyId);\n        totalReserve = totalReserve.add(fee);\n        _setBalanceStorage(Constants.RESERVE, currencyId, totalReserve, 0, 0, 0);\n    }\n\n    function _getSlot(address account, uint256 currencyId) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    currencyId,\n                    keccak256(abi.encode(account, Constants.BALANCE_STORAGE_OFFSET))\n                )\n            );\n    }\n\n    /// @notice Sets internal balance storage.\n    function _setBalanceStorage(\n        address account,\n        uint256 currencyId,\n        int256 cashBalance,\n        int256 nTokenBalance,\n        uint256 lastClaimTime,\n        uint256 lastClaimIntegralSupply\n    ) private {\n        bytes32 slot = _getSlot(account, currencyId);\n        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow\n        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow\n        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow\n        require(lastClaimTime >= 0 && lastClaimTime <= type(uint32).max); // dev: last claim time overflow\n        // Last claim supply is stored in a \"floating point\" storage slot that does not maintain exact precision but\n        // is also not limited by storage overflows. `packTo56Bits` will ensure that the the returned value will fit\n        // in 56 bits (7 bytes)\n        bytes32 packedLastClaimIntegralSupply = FloatingPoint56.packTo56Bits(lastClaimIntegralSupply);\n\n        bytes32 data =\n            ((bytes32(uint256(nTokenBalance))) |\n                (bytes32(lastClaimTime) << 80) |\n                (packedLastClaimIntegralSupply << 112) |\n                (bytes32(cashBalance) << 168));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }\n\n    /// @notice Gets internal balance storage, nTokens are stored alongside cash balances\n    function getBalanceStorage(address account, uint256 currencyId)\n        internal\n        view\n        returns (\n            int256 cashBalance,\n            int256 nTokenBalance,\n            uint256 lastClaimTime,\n            uint256 lastClaimIntegralSupply\n        )\n    {\n        bytes32 slot = _getSlot(account, currencyId);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        nTokenBalance = int256(uint80(uint256(data)));\n        lastClaimTime = uint256(uint32(uint256(data >> 80)));\n        lastClaimIntegralSupply = FloatingPoint56.unpackFrom56Bits(uint256(uint56(uint256(data >> 112))));\n        cashBalance = int256(int88(int256(data >> 168)));\n    }\n\n    /// @notice Loads a balance state memory object\n    /// @dev Balance state objects occupy a lot of memory slots, so this method allows\n    /// us to reuse them if possible\n    function loadBalanceState(\n        BalanceState memory balanceState,\n        address account,\n        uint256 currencyId,\n        AccountContext memory accountContext\n    ) internal view {\n        require(currencyId != 0); // dev: invalid currency id\n        balanceState.currencyId = currencyId;\n\n        if (accountContext.isActiveInBalances(currencyId)) {\n            (\n                balanceState.storedCashBalance,\n                balanceState.storedNTokenBalance,\n                balanceState.lastClaimTime,\n                balanceState.lastClaimIntegralSupply\n            ) = getBalanceStorage(account, currencyId);\n        } else {\n            balanceState.storedCashBalance = 0;\n            balanceState.storedNTokenBalance = 0;\n            balanceState.lastClaimTime = 0;\n            balanceState.lastClaimIntegralSupply = 0;\n        }\n\n        balanceState.netCashChange = 0;\n        balanceState.netAssetTransferInternalPrecision = 0;\n        balanceState.netNTokenTransfer = 0;\n        balanceState.netNTokenSupplyChange = 0;\n    }\n\n    /// @notice Used when manually claiming incentives in nTokenAction\n    function claimIncentivesManual(BalanceState memory balanceState, address account)\n        internal\n        returns (uint256)\n    {\n        uint256 incentivesClaimed = Incentives.claimIncentives(balanceState, account);\n        _setBalanceStorage(\n            account,\n            balanceState.currencyId,\n            balanceState.storedCashBalance,\n            balanceState.storedNTokenBalance,\n            balanceState.lastClaimTime,\n            balanceState.lastClaimIntegralSupply\n        );\n\n        return incentivesClaimed;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/compound/CEtherInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    currencyId,\n                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))\n                )\n            );\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {\n        bytes32 slot = _getSlot(currencyId, underlying);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n        address tokenAddress = address(bytes20(data << 96));\n        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;\n        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));\n        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));\n\n        return\n            Token({\n                tokenAddress: tokenAddress,\n                hasTransferFee: tokenHasTransferFee,\n                decimals: int256(10**tokenDecimalPlaces),\n                tokenType: tokenType\n            });\n    }\n\n    /// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }\n\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        uint256 success;\n        if (token.tokenType == TokenType.cToken) {\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\n        } else if (token.tokenType == TokenType.cETH) {\n            // Reverts on error\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\n        } else {\n            revert(); // dev: non mintable token\n        }\n\n        require(success == 0, \"Mint fail\");\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        // This is the starting and ending balance in external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    function redeem(\n        Token memory assetToken,\n        Token memory underlyingToken,\n        uint256 assetAmountExternal\n    ) internal returns (int256) {\n        uint256 startingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            startingBalance = address(this).balance;\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        } else {\n            revert(); // dev: non redeemable failure\n        }\n\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\n        require(success == 0, \"Redeem fail\");\n\n        uint256 endingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            endingBalance = address(this).balance;\n        } else {\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        }\n\n        // Underlying token external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\n    /// precision.\n    function transfer(\n        Token memory token,\n        address account,\n        int256 netTransferExternal\n    ) internal returns (int256) {\n        if (netTransferExternal > 0) {\n            // Deposits must account for transfer fees.\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\n        } else if (token.tokenType == TokenType.Ether) {\n            require(netTransferExternal < 0); // dev: cannot transfer ether\n            address payable accountPayable = payable(account);\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\n        } else {\n            safeTransferOut(\n                IERC20(token.tokenAddress),\n                account,\n                uint256(netTransferExternal.neg())\n            );\n        }\n\n        return netTransferExternal;\n    }\n\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\n    /// precision.\n    function _deposit(\n        Token memory token,\n        address account,\n        uint256 amount\n    ) private returns (int256) {\n        if (token.hasTransferFee) {\n            // Must deposit from the token and calculate the net transfer\n            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n            safeTransferIn(IERC20(token.tokenAddress), account, amount);\n            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n            return int256(endingBalance.sub(startingBalance));\n        }\n\n        safeTransferIn(IERC20(token.tokenAddress), account, amount);\n        return int256(amount);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);\n    }\n\n    function safeTransferOut(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transfer(account, amount);\n        checkReturnCode();\n    }\n\n    function safeTransferIn(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transferFrom(account, address(this), amount);\n        checkReturnCode();\n    }\n\n    function checkReturnCode() private pure {\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {\n                    // This is a non-standard ERC-20\n                    success := not(0) // set success to true\n                }\n                case 32 {\n                    // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0) // Set `success = returndata` of external call\n                }\n                default {\n                    // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        require(success, \"Transfer Failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "Views.sol",
            "ERC1155Action.sol",
            "Market.sol",
            "BalanceHandler.sol",
            "TokenHandler.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "IERC",
                    "boolean",
                    "checkReturnCode",
                    "token.transfer(account, amount)",
                    "safeTransferOut",
                    "token"
                ],
                "Type": "  TokenHandler.safeTransferOut  does not work on non-standard compliant tokens like USDT",
                "Description": "\nThe TokenHandler.safeTransferOut function uses the standard IERC20 function for the transfer call and proceeds with a checkReturnCode function to handle non-standard compliant tokens that don't return a return value.\nHowever, this does not work, as calling token.transfer(account, amount) already reverts if the token does not return a return value, as token's IERC20.transfer is defined to always return a boolean.\n\nThe impact is that, when using any non-standard compliant token like USDT, the function will revert.\nDeposits for these tokens are broken, which is bad as USDT is a valid underlying for the cUSDT cToken.\n\nWe recommend using OpenZeppelin\u2019s SafeERC20(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/79)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BatchAction.sol\";\nimport \"./nTokenRedeemAction.sol\";\nimport \"../FreeCollateralExternal.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"../../internal/AccountContextHandler.sol\";\nimport \"../../internal/portfolio/TransferAssets.sol\";\nimport \"../../internal/portfolio/PortfolioHandler.sol\";\nimport \"interfaces/IERC1155TokenReceiver.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\n\ncontract ERC1155Action is nERC1155Interface, StorageLayoutV1 {\n    using AccountContextHandler for AccountContext;\n\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(nERC1155Interface).interfaceId;\n    }\n\n    /// @notice Returns the balance of an ERC1155 id on an account. WARNING: the balances returned by\n    /// this method are int256 not uint256 as specified in ERC1155. Modify smart contracts accordingly.\n    /// @param account account to get the id for\n    /// @param id the ERC1155 id\n    /// @return Balance of the ERC1155 id as a signed integer\n    function balanceOf(address account, uint256 id) public view override returns (int256) {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        int256 notional;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            notional = _balanceInBitmap(account, accountContext.bitmapCurrencyId, id);\n        } else {\n            notional = _balanceInArray(\n                PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength),\n                id\n            );\n        }\n\n        return notional;\n    }\n\n    /// @notice Returns the balance of a batch of accounts and ids. WARNING: these balances are signed integers, not\n    /// unsigned integers as the ERC1155 spec designates\n    /// @param accounts array of accounts to get balances for\n    /// @param ids array of ids to get balances for\n    /// @return Returns an array of balances as signed integers\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        override\n        returns (int256[] memory)\n    {\n        require(accounts.length == ids.length);\n        int256[] memory amounts = new int256[](accounts.length);\n\n        for (uint256 i; i < accounts.length; i++) {\n            // This is pretty inefficient but gets the job done\n            amounts[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return amounts;\n    }\n\n    /// @dev Returns the balance from a bitmap given the id\n    function _balanceInBitmap(\n        address account,\n        uint256 bitmapCurrencyId,\n        uint256 id\n    ) internal view returns (int256) {\n        (uint256 currencyId, uint256 maturity, uint256 assetType) = TransferAssets.decodeAssetId(\n            id\n        );\n        if (currencyId != bitmapCurrencyId) return 0;\n        if (assetType != Constants.FCASH_ASSET_TYPE) return 0;\n\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @dev Searches an array for the matching asset\n    function _balanceInArray(PortfolioAsset[] memory portfolio, uint256 id)\n        internal\n        pure\n        returns (int256)\n    {\n        for (uint256 i; i < portfolio.length; i++) {\n            if (\n                TransferAssets.encodeAssetId(\n                    portfolio[i].currencyId,\n                    portfolio[i].maturity,\n                    portfolio[i].assetType\n                ) == id\n            ) return portfolio[i].notional;\n        }\n    }\n\n    /// @notice Transfer of a single fCash or liquidity token asset between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param id ERC1155 id of the asset\n    /// @param amount amount to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferSingle\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external payable override {\n        require(amount <= uint256(type(int256).max)); // dev: int overflow\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        // When amount is set to zero this method can be used as a way to execute trades via a transfer operator\n        AccountContext memory fromContext;\n        if (amount > 0) {\n            PortfolioAsset[] memory assets = new PortfolioAsset[](1);\n            (assets[0].currencyId, assets[0].maturity, assets[0].assetType) = TransferAssets\n                .decodeAssetId(id);\n            assets[0].notional = int256(amount);\n            _assertValidMaturity(assets[0].currencyId, assets[0].maturity, block.timestamp);\n\n            // prettier-ignore\n            (fromContext, /* toContext */) = _transfer(from, to, assets);\n\n            emit TransferSingle(msg.sender, from, to, id, amount);\n        } else {\n            fromContext = AccountContextHandler.getAccountContext(from);\n        }\n\n        // toContext is always empty here because we cannot have bidirectional transfers in `safeTransferFrom`\n        AccountContext memory toContext;\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, false);\n    }\n\n    /// @notice Transfer of a batch of fCash or liquidity token assets between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param ids ERC1155 ids of the assets\n    /// @param amounts amounts to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferBatch\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override {\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155_BATCH_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        (PortfolioAsset[] memory assets, bool toTransferNegative) = _decodeToAssets(ids, amounts);\n        // When doing a bidirectional transfer must ensure that the `to` account has given approval\n        // to msg.sender as well.\n        if (toTransferNegative) require(isApprovedForAll(to, msg.sender), \"Unauthorized\");\n\n        (AccountContext memory fromContext, AccountContext memory toContext) = _transfer(\n            from,\n            to,\n            assets\n        );\n\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, toTransferNegative);\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n    }\n\n    /// @dev Validates accounts on transfer\n    function _validateAccounts(address from, address to) private view {\n        require(from != to && to != address(0), \"Invalid address\");\n        require(msg.sender == from || isApprovedForAll(from, msg.sender), \"Unauthorized\");\n    }\n\n    /// @notice Decodes ids and amounts to PortfolioAsset objects\n    /// @param ids array of ERC1155 ids\n    /// @param amounts amounts to transfer\n    /// @return array of portfolio asset objects\n    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        // prettier-ignore\n        (PortfolioAsset[] memory assets, /* */) = _decodeToAssets(ids, amounts);\n        return assets;\n    }\n\n    function _decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        internal\n        view\n        returns (PortfolioAsset[] memory, bool)\n    {\n        uint256 blockTime = block.timestamp;\n        bool toTransferNegative = false;\n        PortfolioAsset[] memory assets = new PortfolioAsset[](ids.length);\n\n        for (uint256 i; i < ids.length; i++) {\n            (assets[i].currencyId, assets[i].maturity, assets[i].assetType) = TransferAssets\n                .decodeAssetId(ids[i]);\n\n            _assertValidMaturity(assets[i].currencyId, assets[i].maturity, blockTime);\n            // Although amounts is encoded as uint256 we allow it to be negative here. This will\n            // allow for bidirectional transfers of fCash. Internally fCash assets are always stored\n            // as int128 (for bitmap portfolio) or int88 (for array portfolio) so there is no potential\n            // that a uint256 value that is greater than type(int256).max would actually valid.\n            assets[i].notional = int256(amounts[i]);\n            // If there is a negative transfer we mark it as such, this will force us to do a free collateral\n            // check on the `to` address as well.\n            if (assets[i].notional < 0) toTransferNegative = true;\n        }\n\n        return (assets, toTransferNegative);\n    }\n\n    /// @notice Encodes parameters into an ERC1155 id\n    /// @param currencyId currency id of the asset\n    /// @param maturity timestamp of the maturity\n    /// @param assetType id of the asset type\n    /// @return ERC1155 id\n    function encodeToId(\n        uint16 currencyId,\n        uint40 maturity,\n        uint8 assetType\n    ) external pure override returns (uint256) {\n        return TransferAssets.encodeAssetId(currencyId, maturity, assetType);\n    }\n\n    /// @dev Ensures that all maturities specified are valid for the currency id (i.e. they do not\n    /// go past the max maturity date)\n    function _assertValidMaturity(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime\n    ) private view {\n        require(\n            DateTime.isValidMaturity(CashGroup.getMaxMarketIndex(currencyId), maturity, blockTime),\n            \"Invalid maturity\"\n        );\n    }\n\n    /// @dev Internal asset transfer event between accounts\n    function _transfer(\n        address from,\n        address to,\n        PortfolioAsset[] memory assets\n    ) internal returns (AccountContext memory, AccountContext memory) {\n        AccountContext memory fromContext = AccountContextHandler.getAccountContext(from);\n        AccountContext memory toContext = AccountContextHandler.getAccountContext(to);\n\n        toContext = TransferAssets.placeAssetsInAccount(to, toContext, assets);\n        TransferAssets.invertNotionalAmountsInPlace(assets);\n        fromContext = TransferAssets.placeAssetsInAccount(from, fromContext, assets);\n\n        toContext.setAccountContext(to);\n        fromContext.setAccountContext(from);\n\n        return (fromContext, toContext);\n    }\n\n    /// @dev Checks post transfer events which will either be initiating one of the batch trading events or a free collateral\n    /// check if required.\n    function _checkPostTransferEvent(\n        address from,\n        address to,\n        AccountContext memory fromContext,\n        AccountContext memory toContext,\n        bytes calldata data,\n        bool toTransferNegative\n    ) internal {\n        bytes4 sig;\n        address transactedAccount;\n        if (data.length >= 32) {\n            // Method signature is not abi encoded so decode to bytes32 first and take the first 4 bytes. This works\n            // because all the methods we want to call below require more than 32 bytes in the calldata\n            bytes32 tmp = abi.decode(data, (bytes32));\n            sig = bytes4(tmp);\n        }\n\n        // These are the only three methods allowed to occur in a post transfer event. These actions allow `from`\n        // accounts to take any sort of trading action as a result of their transfer. All of these actions will\n        // handle checking free collateral so no additional check is necessary here.\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == BatchAction.batchBalanceAction.selector ||\n            sig == BatchAction.batchBalanceAndTradeAction.selector\n        ) {\n            transactedAccount = abi.decode(data[4:36], (address));\n            // Ensure that the \"transactedAccount\" parameter of the call is set to the from address or the\n            // to address. If it is the \"to\" address then ensure that the msg.sender has approval to\n            // execute operations\n            require(\n                transactedAccount == from ||\n                    (transactedAccount == to && isApprovedForAll(to, msg.sender)),\n                \"Unauthorized call\"\n            );\n\n            (bool status, bytes memory result) = address(this).call{value: msg.value}(data);\n            // TODO: retrieve revert string\n            require(status, \"Call failed\");\n        }\n\n        // The transacted account will have its free collateral checked above so there is\n        // no need to recheck here.\n        if (transactedAccount != from && fromContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(from);\n        }\n\n        // Check free collateral if the `to` account has taken on a negative fCash amount\n        if (transactedAccount != to && toTransferNegative && toContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(to);\n        }\n    }\n\n    /// @notice Allows an account to set approval for an operator\n    /// @param operator address of the operator\n    /// @param approved state of the approval\n    /// @dev emit:ApprovalForAll\n    function setApprovalForAll(address operator, bool approved) external override {\n        accountAuthorizedTransferOperator[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @notice Checks approval state for an account, will first check if global transfer operator is enabled\n    /// before falling through to an account specific transfer operator.\n    /// @param account address of the account\n    /// @param operator address of the operator\n    /// @return true for approved\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (globalTransferOperator[operator]) return true;\n\n        return accountAuthorizedTransferOperator[account][operator];\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../external/FreeCollateralExternal.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"../internal/valuation/ExchangeRate.sol\";\nimport \"../internal/markets/CashGroup.sol\";\nimport \"../internal/markets/AssetRate.sol\";\nimport \"../internal/nTokenHandler.sol\";\nimport \"../internal/balances/TokenHandler.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../math/SafeInt256.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"interfaces/notional/NotionalViews.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Views is StorageLayoutV1, NotionalViews {\n    using CashGroup for CashGroupParameters;\n    using TokenHandler for Token;\n    using Market for MarketParameters;\n    using AssetRate for AssetRateParameters;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n    using BalanceHandler for BalanceState;\n\n    /** Governance Parameter Getters **/\n\n    /// @notice Returns the current maximum currency id\n    function getMaxCurrencyId() external view override returns (uint16) {\n        return maxCurrencyId;\n    }\n\n    /// @notice Returns a currency id, a zero means that it is not listed.\n    function getCurrencyId(address tokenAddress)\n        external\n        view\n        override\n        returns (uint16 currencyId)\n    {\n        currencyId = tokenAddressToCurrencyId[tokenAddress];\n    }\n\n    /// @notice Returns the asset token and underlying token related to a given currency id. If underlying\n    /// token is not set then will return the zero address\n    function getCurrency(uint16 currencyId)\n        external\n        view\n        override\n        returns (Token memory assetToken, Token memory underlyingToken)\n    {\n        assetToken = TokenHandler.getToken(currencyId, false);\n        underlyingToken = TokenHandler.getToken(currencyId, true);\n    }\n\n    /// @notice Returns the ETH and Asset rates for a currency as stored, useful for viewing how they are configured\n    function getRateStorage(uint16 currencyId)\n        external\n        view\n        override\n        returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate)\n    {\n        ethRate = underlyingToETHRateMapping[currencyId];\n        assetRate = assetToUnderlyingRateMapping[currencyId];\n    }\n\n    /// @notice Returns a currency and its corresponding asset rate and ETH exchange rates. Note that this does not recalculate\n    /// cToken interest rates, it only retrieves the latest stored rate.\n    function getCurrencyAndRates(uint16 currencyId)\n        external\n        view\n        override\n        returns (\n            Token memory assetToken,\n            Token memory underlyingToken,\n            ETHRate memory ethRate,\n            AssetRateParameters memory assetRate\n        )\n    {\n        assetToken = TokenHandler.getToken(currencyId, false);\n        underlyingToken = TokenHandler.getToken(currencyId, false);\n        ethRate = ExchangeRate.buildExchangeRate(currencyId);\n        assetRate = AssetRate.buildAssetRateView(currencyId);\n    }\n\n    /// @notice Returns cash group settings for a currency\n    function getCashGroup(uint16 currencyId)\n        external\n        view\n        override\n        returns (CashGroupSettings memory)\n    {\n        return CashGroup.deserializeCashGroupStorage(currencyId);\n    }\n\n    /// @notice Returns the cash group along with the asset rate for convenience.\n    function getCashGroupAndAssetRate(uint16 currencyId)\n        external\n        view\n        override\n        returns (CashGroupSettings memory cashGroup, AssetRateParameters memory assetRate)\n    {\n        cashGroup = CashGroup.deserializeCashGroupStorage(currencyId);\n        assetRate = AssetRate.buildAssetRateView(currencyId);\n    }\n\n    /// @notice Returns market initialization parameters for a given currency\n    function getInitializationParameters(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)\n    {\n        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (annualizedAnchorRates, proportions) = nTokenHandler.getInitializationParameters(\n            currencyId,\n            maxMarketIndex\n        );\n    }\n\n    /// @notice Returns nToken deposit parameters for a given currency\n    function getDepositParameters(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\n    {\n        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (depositShares, leverageThresholds) = nTokenHandler.getDepositParameters(\n            currencyId,\n            maxMarketIndex\n        );\n    }\n\n    /// @notice Returns nToken address for a given currency\n    function nTokenAddress(uint16 currencyId) external view override returns (address) {\n        return nTokenHandler.nTokenAddress(currencyId);\n    }\n\n    /// @notice Returns address of contract owner\n    function getOwner() external view override returns (address) {\n        return owner;\n    }\n\n    /** Global System State View Methods **/\n\n    /// @notice Returns the asset settlement rate for a given maturity\n    function getSettlementRate(uint16 currencyId, uint40 maturity)\n        external\n        view\n        override\n        returns (AssetRateParameters memory)\n    {\n        return AssetRate.buildSettlementRateView(currencyId, maturity);\n    }\n\n    /// @notice Returns all currently active markets for a currency\n    function getActiveMarkets(uint16 currencyId)\n        external\n        view\n        override\n        returns (MarketParameters[] memory)\n    {\n        uint256 blockTime = block.timestamp;\n        return _getActiveMarketsAtBlockTime(currencyId, blockTime);\n    }\n\n    /// @notice Returns all active markets for a currency at the specified block time, useful for looking\n    /// at historical markets\n    function getActiveMarketsAtBlockTime(uint16 currencyId, uint32 blockTime)\n        external\n        view\n        override\n        returns (MarketParameters[] memory)\n    {\n        return _getActiveMarketsAtBlockTime(currencyId, blockTime);\n    }\n\n    function _getActiveMarketsAtBlockTime(uint256 currencyId, uint256 blockTime)\n        internal\n        view\n        returns (MarketParameters[] memory)\n    {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters[] memory markets = new MarketParameters[](cashGroup.maxMarketIndex);\n\n        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) {\n            cashGroup.loadMarket(markets[i], i + 1, true, blockTime);\n        }\n\n        return markets;\n    }\n\n    /// @notice Returns the current reserve balance for a currency\n    function getReserveBalance(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256 reserveBalance)\n    {\n        // prettier-ignore\n        (\n            reserveBalance,\n            /* */,\n            /* */,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n    }\n\n    function getNTokenPortfolio(address tokenAddress)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory liquidityTokens, PortfolioAsset[] memory netfCashAssets)\n    {\n        // prettier-ignore\n        (\n            uint256 currencyId,\n            /* incentiveRate */,\n            uint256 lastInitializedTime,\n            bytes6 parameters\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\n\n        liquidityTokens = PortfolioHandler.getSortedPortfolio(\n            tokenAddress,\n            uint8(parameters[Constants.ASSET_ARRAY_LENGTH])\n        );\n\n        netfCashAssets = BitmapAssetsHandler.getifCashArray(\n            tokenAddress,\n            currencyId,\n            lastInitializedTime\n        );\n    }\n\n    function getNTokenAccount(address tokenAddress)\n        external\n        view\n        override\n        returns (\n            uint256 currencyId,\n            uint256 totalSupply,\n            uint256 incentiveAnnualEmissionRate,\n            uint256 lastInitializedTime,\n            bytes6 nTokenParameters,\n            int256 cashBalance,\n            uint256 integralTotalSupply,\n            uint256 lastSupplyChangeTime\n        )\n    {\n        (\n            currencyId,\n            incentiveAnnualEmissionRate,\n            lastInitializedTime,\n            nTokenParameters\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\n\n        // prettier-ignore\n        (\n            totalSupply,\n            integralTotalSupply,\n            lastSupplyChangeTime\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(tokenAddress);\n\n        // prettier-ignore\n        (\n            cashBalance,\n            /* */,\n            /* */,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(tokenAddress, currencyId);\n    }\n\n    /** Account Specific View Methods **/\n\n    /// @notice Returns all account details in a single view\n    function getAccount(address account)\n        external\n        view\n        override\n        returns (\n            AccountContext memory accountContext,\n            AccountBalance[] memory accountBalances,\n            PortfolioAsset[] memory portfolio\n        )\n    {\n        accountContext = AccountContextHandler.getAccountContext(account);\n        accountBalances = new AccountBalance[](10);\n\n        uint256 i;\n        if (accountContext.bitmapCurrencyId != 0) {\n            (\n                accountBalances[i].cashBalance,\n                accountBalances[i].nTokenBalance,\n                accountBalances[i].lastClaimTime,\n                accountBalances[i].lastClaimIntegralSupply\n            ) = BalanceHandler.getBalanceStorage(account, accountContext.bitmapCurrencyId);\n            i += 1;\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            accountBalances[i].currencyId = uint256(\n                uint16(bytes2(currencies) & Constants.UNMASK_FLAGS)\n            );\n            if (accountBalances[i].currencyId == 0) break;\n\n            (\n                accountBalances[i].cashBalance,\n                accountBalances[i].nTokenBalance,\n                accountBalances[i].lastClaimTime,\n                accountBalances[i].lastClaimIntegralSupply\n            ) = BalanceHandler.getBalanceStorage(account, accountBalances[i].currencyId);\n            i += 1;\n            currencies = currencies << 16;\n        }\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            portfolio = BitmapAssetsHandler.getifCashArray(\n                account,\n                accountContext.bitmapCurrencyId,\n                accountContext.nextSettleTime\n            );\n        } else {\n            portfolio = PortfolioHandler.getSortedPortfolio(\n                account,\n                accountContext.assetArrayLength\n            );\n        }\n    }\n\n    /// @notice Returns account context\n    function getAccountContext(address account)\n        external\n        view\n        override\n        returns (AccountContext memory)\n    {\n        return AccountContextHandler.getAccountContext(account);\n    }\n\n    /// @notice Returns account balances for a given currency\n    function getAccountBalance(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (\n            int256 cashBalance,\n            int256 nTokenBalance,\n            uint256 lastClaimTime\n        )\n    {\n        // prettier-ignore\n        (\n            cashBalance,\n            nTokenBalance,\n            lastClaimTime,\n            /* */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n    }\n\n    /// @notice Returns account portfolio of assets\n    function getAccountPortfolio(address account)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        if (accountContext.bitmapCurrencyId != 0) {\n            return\n                BitmapAssetsHandler.getifCashArray(\n                    account,\n                    accountContext.bitmapCurrencyId,\n                    accountContext.nextSettleTime\n                );\n        } else {\n            return PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength);\n        }\n    }\n\n    /// @notice Returns the fCash amount at the specified maturity for a bitmapped portfolio\n    function getfCashNotional(\n        address account,\n        uint256 currencyId,\n        uint256 maturity\n    ) external view override returns (int256) {\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @notice Returns the assets bitmap for an account\n    function getAssetsBitmap(address account, uint256 currencyId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return BitmapAssetsHandler.getAssetsBitmap(account, currencyId);\n    }\n\n    /// @notice Returns free collateral of an account along with an array of the individual net available\n    /// asset cash amounts\n    function getFreeCollateral(address account)\n        external\n        view\n        override\n        returns (int256, int256[] memory)\n    {\n        return FreeCollateralExternal.getFreeCollateralView(account);\n    }\n\n    /** General Calculation View Methods **/\n\n    /// @notice Returns the nTokens that will be minted when some amount of asset tokens are deposited\n    function calculateNTokensToMint(uint16 currencyId, uint88 amountToDepositExternalPrecision)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        Token memory token = TokenHandler.getToken(currencyId, false);\n        int256 amountToDepositInternal =\n            token.convertToInternal(int256(amountToDepositExternalPrecision));\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 tokensToMint,\n            /* */\n        ) = nTokenMintAction.calculateTokensToMint(\n            nToken,\n            amountToDepositInternal,\n            block.timestamp\n        );\n\n        return SafeCast.toUint256(tokensToMint);\n    }\n\n    /// @notice Returns the fCash amount to send when given a cash amount, be sure to buffer these amounts\n    /// slightly because the liquidity curve is sensitive to changes in block time\n    function getfCashAmountGivenCashAmount(\n        uint16 currencyId,\n        int88 netCashToAccount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view override returns (int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters memory market;\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\n\n        require(market.maturity > blockTime, \"Invalid block time\");\n        uint256 timeToMaturity = market.maturity - blockTime;\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\n            Market.getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\n        int256 fee = Market.getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\n\n        return\n            Market.getfCashGivenCashAmount(\n                market.totalfCash,\n                int256(netCashToAccount),\n                totalCashUnderlying,\n                rateScalar,\n                rateAnchor,\n                fee,\n                0\n            );\n    }\n\n    /// @notice Returns the cash amount that will be traded given an fCash amount, be sure to buffer these amounts\n    /// slightly because the liquidity curve is sensitive to changes in block time\n    function getCashAmountGivenfCashAmount(\n        uint16 currencyId,\n        int88 fCashAmount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view override returns (int256, int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);\n        MarketParameters memory market;\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\n\n        require(market.maturity > blockTime, \"Invalid block time\");\n        uint256 timeToMaturity = market.maturity - blockTime;\n\n        // prettier-ignore\n        (int256 assetCash, /* int fee */) =\n            market.calculateTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);\n\n        return (assetCash, cashGroup.assetRate.convertToUnderlying(assetCash));\n    }\n\n    /// @notice Returns the claimable incentives for all nToken balances\n    /// @param account The address of the account which holds the tokens\n    /// @param blockTime The block time when incentives will be minted\n    /// @return Incentives an account is eligible to claim\n    function nTokenGetClaimableIncentives(address account, uint256 blockTime)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        uint256 totalIncentivesClaimable;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\n\n                // prettier-ignore\n                (\n                    /* totalSupply */,\n                    uint256 integralTotalSupply,\n                    /* lastSupplyChangeTime */\n                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);\n\n                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(\n                    tokenAddress,\n                    uint256(balanceState.storedNTokenBalance),\n                    balanceState.lastClaimTime,\n                    balanceState.lastClaimIntegralSupply,\n                    blockTime,\n                    integralTotalSupply\n                );\n                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n\n            if (balanceState.storedNTokenBalance > 0) {\n                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\n\n                (\n                    /* totalSupply */,\n                    uint256 integralTotalSupply,\n                    /* lastSupplyChangeTime */\n                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);\n\n                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(\n                    nTokenHandler.nTokenAddress(balanceState.currencyId),\n                    uint256(balanceState.storedNTokenBalance),\n                    balanceState.lastClaimTime,\n                    balanceState.lastClaimIntegralSupply,\n                    blockTime,\n                    integralTotalSupply\n                );\n                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);\n            }\n\n            currencies = currencies << 16;\n        }\n\n        return totalIncentivesClaimable;\n    }\n\n    fallback() external {\n        revert(\"Method not found\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/compound/CEtherInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    currencyId,\n                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))\n                )\n            );\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {\n        bytes32 slot = _getSlot(currencyId, underlying);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n        address tokenAddress = address(bytes20(data << 96));\n        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;\n        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));\n        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));\n\n        return\n            Token({\n                tokenAddress: tokenAddress,\n                hasTransferFee: tokenHasTransferFee,\n                decimals: int256(10**tokenDecimalPlaces),\n                tokenType: tokenType\n            });\n    }\n\n    /// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }\n\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        uint256 success;\n        if (token.tokenType == TokenType.cToken) {\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\n        } else if (token.tokenType == TokenType.cETH) {\n            // Reverts on error\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\n        } else {\n            revert(); // dev: non mintable token\n        }\n\n        require(success == 0, \"Mint fail\");\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        // This is the starting and ending balance in external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    function redeem(\n        Token memory assetToken,\n        Token memory underlyingToken,\n        uint256 assetAmountExternal\n    ) internal returns (int256) {\n        uint256 startingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            startingBalance = address(this).balance;\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        } else {\n            revert(); // dev: non redeemable failure\n        }\n\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\n        require(success == 0, \"Redeem fail\");\n\n        uint256 endingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            endingBalance = address(this).balance;\n        } else {\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        }\n\n        // Underlying token external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\n    /// precision.\n    function transfer(\n        Token memory token,\n        address account,\n        int256 netTransferExternal\n    ) internal returns (int256) {\n        if (netTransferExternal > 0) {\n            // Deposits must account for transfer fees.\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\n        } else if (token.tokenType == TokenType.Ether) {\n            require(netTransferExternal < 0); // dev: cannot transfer ether\n            address payable accountPayable = payable(account);\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\n        } else {\n            safeTransferOut(\n                IERC20(token.tokenAddress),\n                account,\n                uint256(netTransferExternal.neg())\n            );\n        }\n\n        return netTransferExternal;\n    }\n\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\n    /// precision.\n    function _deposit(\n        Token memory token,\n        address account,\n        uint256 amount\n    ) private returns (int256) {\n        if (token.hasTransferFee) {\n            // Must deposit from the token and calculate the net transfer\n            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n            safeTransferIn(IERC20(token.tokenAddress), account, amount);\n            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n            return int256(endingBalance.sub(startingBalance));\n        }\n\n        safeTransferIn(IERC20(token.tokenAddress), account, amount);\n        return int256(amount);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);\n    }\n\n    function safeTransferOut(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transfer(account, amount);\n        checkReturnCode();\n    }\n\n    function safeTransferIn(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transferFrom(account, address(this), amount);\n        checkReturnCode();\n    }\n\n    function checkReturnCode() private pure {\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {\n                    // This is a non-standard ERC-20\n                    success := not(0) // set success to true\n                }\n                case 32 {\n                    // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0) // Set `success = returndata` of external call\n                }\n                default {\n                    // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        require(success, \"Transfer Failed\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AssetRate.sol\";\nimport \"./CashGroup.sol\";\nimport \"./DateTime.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../math/ABDKMath64x64.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary Market {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using CashGroup for CashGroupParameters;\n    using AssetRate for AssetRateParameters;\n\n    bytes1 private constant STORAGE_STATE_NO_CHANGE = 0x00;\n    bytes1 private constant STORAGE_STATE_UPDATE_LIQUIDITY = 0x01;\n    bytes1 private constant STORAGE_STATE_UPDATE_TRADE = 0x02;\n    bytes1 internal constant STORAGE_STATE_INITIALIZE_MARKET = 0x03; // Both settings are set\n\n    // Max positive value for a ABDK64x64 integer\n    int256 private constant MAX64 = 0x7FFFFFFFFFFFFFFF;\n\n    /// @notice Add liquidity to a market, assuming that it is initialized. If not then\n    /// this method will revert and the market must be initialized first.\n    /// @return liquidityTokenAmount and net negative fCash\n    function addLiquidity(MarketParameters memory market, int256 assetCash)\n        internal\n        pure\n        returns (int256, int256)\n    {\n        require(market.totalLiquidity > 0, \"M: zero liquidity\");\n        if (assetCash == 0) return (0, 0);\n        require(assetCash > 0); // dev: negative asset cash\n\n        int256 liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);\n        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.\n        int256 fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);\n\n        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);\n        market.totalfCash = market.totalfCash.add(fCash);\n        market.totalAssetCash = market.totalAssetCash.add(assetCash);\n        market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;\n\n        return (liquidityTokens, fCash.neg());\n    }\n\n    /// @notice Remove liquidity from a market, assuming that it is initialized.\n    /// @return asset cash and positive fCash claim to return\n    function removeLiquidity(MarketParameters memory market, int256 tokensToRemove)\n        internal\n        pure\n        returns (int256, int256)\n    {\n        if (tokensToRemove == 0) return (0, 0);\n        require(tokensToRemove > 0); // dev: negative tokens to remove\n\n        int256 assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);\n        int256 fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);\n\n        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);\n        market.totalfCash = market.totalfCash.subNoNeg(fCash);\n        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);\n        market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;\n\n        return (assetCash, fCash);\n    }\n\n    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive\n    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.\n    /// @param market the current market state\n    /// @param cashGroup cash group configuration parameters\n    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change\n    /// to the market is in the opposite direction.\n    /// @param timeToMaturity number of seconds until maturity\n    /// @return netAssetCash, netAssetCashToReserve\n    function calculateTrade(\n        MarketParameters memory market,\n        CashGroupParameters memory cashGroup,\n        int256 fCashToAccount,\n        uint256 timeToMaturity,\n        uint256 marketIndex\n    ) internal view returns (int256, int256) {\n        // We return false if there is not enough fCash to support this trade.\n        if (market.totalfCash.sub(fCashToAccount) <= 0) return (0, 0);\n\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\n            getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\n\n        int256 preFeeExchangeRate;\n        {\n            bool success;\n            (preFeeExchangeRate, success) = _getExchangeRate(\n                market.totalfCash,\n                totalCashUnderlying,\n                rateScalar,\n                rateAnchor,\n                fCashToAccount\n            );\n            if (!success) return (0, 0);\n        }\n\n        (int256 netCashToAccount, int256 netCashToMarket, int256 netCashToReserve) =\n            _getNetCashAmountsUnderlying(\n                cashGroup,\n                preFeeExchangeRate,\n                fCashToAccount,\n                timeToMaturity\n            );\n        if (netCashToAccount == 0) return (0, 0);\n\n        {\n            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\n            market.lastImpliedRate = getImpliedRate(\n                market.totalfCash,\n                totalCashUnderlying.add(netCashToMarket),\n                rateScalar,\n                rateAnchor,\n                timeToMaturity\n            );\n\n            // It's technically possible that the implied rate is actually exactly zero (or\n            // more accurately the natural log rounds down to zero) but we will still fail\n            // in this case. If this does happen we may assume that markets are not initialized.\n            if (market.lastImpliedRate == 0) return (0, 0);\n        }\n\n        return\n            _setNewMarketState(\n                market,\n                cashGroup.assetRate,\n                netCashToAccount,\n                netCashToMarket,\n                netCashToReserve\n            );\n    }\n\n    /// @notice Returns factors for calculating exchange rates\n    function getExchangeRateFactors(\n        MarketParameters memory market,\n        CashGroupParameters memory cashGroup,\n        uint256 timeToMaturity,\n        uint256 marketIndex\n    )\n        internal\n        pure\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        int256 rateScalar = cashGroup.getRateScalar(marketIndex, timeToMaturity);\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\n\n        // This will result in a divide by zero\n        if (market.totalfCash == 0 || totalCashUnderlying == 0) return (0, 0, 0);\n\n        // Get the rate anchor given the market state, this will establish the baseline for where\n        // the exchange rate is set.\n        int256 rateAnchor;\n        {\n            bool success;\n            (rateAnchor, success) = _getRateAnchor(\n                market.totalfCash,\n                market.lastImpliedRate,\n                totalCashUnderlying,\n                rateScalar,\n                timeToMaturity\n            );\n            if (!success) return (0, 0, 0);\n        }\n\n        return (rateScalar, totalCashUnderlying, rateAnchor);\n    }\n\n    /// @dev Returns net asset cash amounts to the account, the market and the reserve\n    function _getNetCashAmountsUnderlying(\n        CashGroupParameters memory cashGroup,\n        int256 preFeeExchangeRate,\n        int256 fCashToAccount,\n        uint256 timeToMaturity\n    )\n        private\n        pure\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        // Fees are specified in basis points which is an implied rate denomination. We convert this to\n        // an exchange rate denomination for the given time to maturity. (i.e. get e^(fee * t) and multiply\n        // or divide depending on the side of the trade).\n        // tradeExchangeRate = exp((tradeInterestRateNoFee +/- fee) * timeToMaturity)\n        // tradeExchangeRate = tradeExchangeRateNoFee (* or /) exp(fee * timeToMaturity)\n        int256 preFeeCashToAccount =\n            fCashToAccount.divInRatePrecision(preFeeExchangeRate).neg();\n        int256 fee = getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\n\n        if (fCashToAccount > 0) {\n            // Lending\n            int256 postFeeExchangeRate = preFeeExchangeRate.divInRatePrecision(fee);\n            // It's possible that the fee pushes exchange rates into negative territory. This is not possible\n            // when borrowing. If this happens then the trade has failed.\n            if (postFeeExchangeRate < Constants.RATE_PRECISION) return (0, 0, 0);\n\n            // cashToAccount = -(fCashToAccount / exchangeRate)\n            // postFeeExchangeRate = preFeeExchangeRate / feeExchangeRate\n            // preFeeCashToAccount = -(fCashToAccount / preFeeExchangeRate)\n            // postFeeCashToAccount = -(fCashToAccount / postFeeExchangeRate)\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\n            // netFee = ((fCashToAccount * feeExchangeRate) / preFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (feeExchangeRate - 1)\n            // netFee = -(preFeeCashToAccount) * (feeExchangeRate - 1)\n            // netFee = preFeeCashToAccount * (1 - feeExchangeRate)\n            fee = preFeeCashToAccount.mulInRatePrecision(Constants.RATE_PRECISION.sub(fee));\n        } else {\n            // Borrowing\n            // cashToAccount = -(fCashToAccount / exchangeRate)\n            // postFeeExchangeRate = preFeeExchangeRate * feeExchangeRate\n\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\n            // netFee = ((fCashToAccount / (feeExchangeRate * preFeeExchangeRate)) - (fCashToAccount / preFeeExchangeRate)\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (1 / feeExchangeRate - 1)\n            // netFee = preFeeCashToAccount * ((1 - feeExchangeRate) / feeExchangeRate)\n            // NOTE: preFeeCashToAccount is negative in this branch so we negate it to ensure that fee is a positive number\n            fee = preFeeCashToAccount.mul(Constants.RATE_PRECISION.sub(fee)).div(fee).neg();\n        }\n\n        int256 cashToReserve =\n            fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);\n\n        return (\n            // postFeeCashToAccount = preFeeCashToAccount - fee\n            preFeeCashToAccount.sub(fee),\n            // netCashToMarket = -(preFeeCashToAccount - fee + cashToReserve)\n            (preFeeCashToAccount.sub(fee).add(cashToReserve)).neg(),\n            cashToReserve\n        );\n    }\n\n    function _setNewMarketState(\n        MarketParameters memory market,\n        AssetRateParameters memory assetRate,\n        int256 netCashToAccount,\n        int256 netCashToMarket,\n        int256 netCashToReserve\n    ) private view returns (int256, int256) {\n        int256 netAssetCashToMarket = assetRate.convertFromUnderlying(netCashToMarket);\n        market.totalAssetCash = market.totalAssetCash.add(netAssetCashToMarket);\n\n        // Sets the trade time for the next oracle update\n        market.previousTradeTime = block.timestamp;\n        market.storageState = market.storageState | STORAGE_STATE_UPDATE_TRADE;\n\n        int256 assetCashToReserve = assetRate.convertFromUnderlying(netCashToReserve);\n        int256 netAssetCashToAccount = assetRate.convertFromUnderlying(netCashToAccount);\n        return (netAssetCashToAccount, assetCashToReserve);\n    }\n\n    /// @notice Rate anchors update as the market gets closer to maturity. Rate anchors are not comparable\n    /// across time or markets but implied rates are. The goal here is to ensure that the implied rate\n    /// before and after the rate anchor update is the same. Therefore, the market will trade at the same implied\n    /// rate that it last traded at. If these anchors do not update then it opens up the opportunity for arbitrage\n    /// which will hurt the liquidity providers.\n    ///\n    /// The rate anchor will update as the market rolls down to maturity. The calculation is:\n    /// newExchangeRate = e^(lastImpliedRate * timeToMaturity / Constants.IMPLIED_RATE_TIME)\n    /// newAnchor = newExchangeRate - ln((proportion / (1 - proportion)) / rateScalar\n    ///\n    /// where:\n    /// lastImpliedRate = ln(exchangeRate') * (Constants.IMPLIED_RATE_TIME / timeToMaturity')\n    ///      (calculated when the last trade in the market was made)\n    /// @dev has an underscore to denote as private but is marked internal for the mock\n    /// @return the new rate anchor and a boolean that signifies success\n    function _getRateAnchor(\n        int256 totalfCash,\n        uint256 lastImpliedRate,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        uint256 timeToMaturity\n    ) internal pure returns (int256, bool) {\n        // This is the exchange rate at the new time to maturity\n        int256 exchangeRate = getExchangeRateFromImpliedRate(lastImpliedRate, timeToMaturity);\n        if (exchangeRate < Constants.RATE_PRECISION) return (0, false);\n\n        int256 rateAnchor;\n        {\n            int256 proportion =\n                totalfCash.divInRatePrecision(totalfCash.add(totalCashUnderlying));\n\n            (int256 lnProportion, bool success) = _logProportion(proportion);\n            if (!success) return (0, false);\n\n            rateAnchor = exchangeRate.sub(lnProportion.divInRatePrecision(rateScalar));\n        }\n\n        return (rateAnchor, true);\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return the implied rate and a bool that is true on success\n    function getImpliedRate(\n        int256 totalfCash,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToMaturity\n    ) internal pure returns (uint256) {\n        // This will check for exchange rates < Constants.RATE_PRECISION\n        (int256 exchangeRate, bool success) =\n            _getExchangeRate(totalfCash, totalCashUnderlying, rateScalar, rateAnchor, 0);\n        if (!success) return 0;\n\n        // Uses continuous compounding to calculate the implied rate:\n        // ln(exchangeRate) * Constants.IMPLIED_RATE_TIME / timeToMaturity\n        int128 rate = ABDKMath64x64.fromInt(exchangeRate);\n        int128 rateScaled = ABDKMath64x64.div(rate, Constants.RATE_PRECISION_64x64);\n        // We will not have a negative log here because we check that exchangeRate > Constants.RATE_PRECISION\n        // inside getExchangeRate\n        int128 lnRateScaled = ABDKMath64x64.ln(rateScaled);\n        uint256 lnRate =\n            ABDKMath64x64.toUInt(ABDKMath64x64.mul(lnRateScaled, Constants.RATE_PRECISION_64x64));\n\n        uint256 impliedRate = lnRate.mul(Constants.IMPLIED_RATE_TIME).div(timeToMaturity);\n\n        // Implied rates over 429% will overflow, this seems like a safe assumption\n        if (impliedRate > type(uint32).max) return 0;\n\n        return impliedRate;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The\n    /// formula is E = e^rt\n    function getExchangeRateFromImpliedRate(uint256 impliedRate, uint256 timeToMaturity)\n        internal\n        pure\n        returns (int256)\n    {\n        int128 expValue =\n            ABDKMath64x64.fromUInt(\n                impliedRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME)\n            );\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\n\n        return ABDKMath64x64.toInt(expResultScaled);\n    }\n\n    /// @notice Returns the exchange rate between fCash and cash for the given market\n    /// Calculates the following exchange rate:\n    ///     (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor\n    /// where:\n    ///     proportion = totalfCash / (totalfCash + totalUnderlyingCash)\n    /// @dev has an underscore to denote as private but is marked internal for the mock\n    function _getExchangeRate(\n        int256 totalfCash,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 fCashToAccount\n    ) internal pure returns (int256, bool) {\n        int256 numerator = totalfCash.subNoNeg(fCashToAccount);\n\n        // This is the proportion scaled by Constants.RATE_PRECISION\n        int256 proportion =\n            numerator.divInRatePrecision(totalfCash.add(totalCashUnderlying));\n\n        (int256 lnProportion, bool success) = _logProportion(proportion);\n        if (!success) return (0, false);\n\n        int256 rate = lnProportion.divInRatePrecision(rateScalar).add(rateAnchor);\n        // Do not succeed if interest rates fall below 1\n        if (rate < Constants.RATE_PRECISION) {\n            return (0, false);\n        } else {\n            return (rate, true);\n        }\n    }\n\n    /// @dev This method calculates the log of the proportion inside the logit function which is\n    /// defined as ln(proportion / (1 - proportion)). Special handling here is required to deal with\n    /// fixed point precision and the ABDK library.\n    function _logProportion(int256 proportion) internal pure returns (int256, bool) {\n        if (proportion == Constants.RATE_PRECISION) return (0, false);\n\n        proportion = proportion.divInRatePrecision(Constants.RATE_PRECISION.sub(proportion));\n\n        // This is the max 64 bit integer for ABDKMath. This is unlikely to trip because the\n        // value is 9.2e18 and the proportion is scaled by 1e9. We can hit very high levels of\n        // pool utilization before this returns false.\n        if (proportion > MAX64) return (0, false);\n\n        // ABDK does not handle log of numbers that are less than 1, in order to get the right value\n        // scaled by RATE_PRECISION we use the log identity:\n        // (ln(proportion / RATE_PRECISION)) * RATE_PRECISION = (ln(proportion) - ln(RATE_PRECISION)) * RATE_PRECISION\n        int128 abdkProportion = ABDKMath64x64.fromInt(proportion);\n        // Here, abdk will revert due to negative log so abort\n        if (abdkProportion <= 0) return (0, false);\n        int256 result =\n            ABDKMath64x64.toInt(\n                ABDKMath64x64.mul(\n                    ABDKMath64x64.sub(\n                        ABDKMath64x64.ln(abdkProportion),\n                        Constants.LOG_RATE_PRECISION_64x64\n                    ),\n                    Constants.RATE_PRECISION_64x64\n                )\n            );\n\n        return (result, true);\n    }\n\n    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value\n    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,\n    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.\n    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then\n    /// be liquidated.\n    ///\n    /// Oracle rates are calculated when the market is loaded from storage.\n    ///\n    /// The oracle rate is a lagged weighted average over a short term price window. If we are past\n    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the\n    /// weighted average:\n    ///     lastImpliedRatePreTrade * (currentTs - previousTs) / timeWindow +\n    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)\n    function _updateRateOracle(\n        uint256 previousTradeTime,\n        uint256 lastImpliedRate,\n        uint256 oracleRate,\n        uint256 rateOracleTimeWindow,\n        uint256 blockTime\n    ) private pure returns (uint256) {\n        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero\n\n        // This can occur when using a view function get to a market state in the past\n        if (previousTradeTime > blockTime) return lastImpliedRate;\n\n        uint256 timeDiff = blockTime.sub(previousTradeTime);\n        if (timeDiff > rateOracleTimeWindow) {\n            // If past the time window just return the lastImpliedRate\n            return lastImpliedRate;\n        }\n\n        // (currentTs - previousTs) / timeWindow\n        uint256 lastTradeWeight =\n            timeDiff.mul(uint256(Constants.RATE_PRECISION)).div(rateOracleTimeWindow);\n\n        // 1 - (currentTs - previousTs) / timeWindow\n        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);\n\n        uint256 newOracleRate =\n            (lastImpliedRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight))).div(\n                uint256(Constants.RATE_PRECISION)\n            );\n\n        return newOracleRate;\n    }\n\n    function getSlot(\n        uint256 currencyId,\n        uint256 settlementDate,\n        uint256 maturity\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    maturity,\n                    keccak256(\n                        abi.encode(\n                            settlementDate,\n                            keccak256(abi.encode(currencyId, Constants.MARKET_STORAGE_OFFSET))\n                        )\n                    )\n                )\n            );\n    }\n\n    /// @notice Liquidity is not required for lending and borrowing so we don't automatically read it. This method is called if we\n    /// do need to load the liquidity amount.\n    function getTotalLiquidity(MarketParameters memory market) internal view {\n        int256 totalLiquidity;\n        bytes32 slot = bytes32(uint256(market.storageSlot) + 1);\n\n        assembly {\n            totalLiquidity := sload(slot)\n        }\n        market.totalLiquidity = totalLiquidity;\n    }\n\n    function getOracleRate(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 rateOracleTimeWindow,\n        uint256 blockTime\n    ) internal view returns (uint256) {\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\n        bytes32 slot = getSlot(currencyId, settlementDate, maturity);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        uint256 lastImpliedRate = uint256(uint32(uint256(data >> 160)));\n        uint256 oracleRate = uint256(uint32(uint256(data >> 192)));\n        uint256 previousTradeTime = uint256(uint32(uint256(data >> 224)));\n\n        // If the oracle rate is set to zero this can only be because the markets have past their settlement\n        // date but the new set of markets has not yet been initialized. This means that accounts cannot be liquidated\n        // during this time, but market initialization can be called by anyone so the actual time that this condition\n        // exists for should be quite short.\n        require(oracleRate > 0, \"Market not initialized\");\n\n        return\n            _updateRateOracle(\n                previousTradeTime,\n                lastImpliedRate,\n                oracleRate,\n                rateOracleTimeWindow,\n                blockTime\n            );\n    }\n\n    /// @notice Reads a market object directly from storage. `buildMarket` should be called instead of this method\n    /// which ensures that the rate oracle is set properly.\n    function _loadMarketStorage(\n        MarketParameters memory market,\n        uint256 currencyId,\n        uint256 maturity,\n        bool needsLiquidity,\n        uint256 settlementDate\n    ) private view {\n        // Market object always uses the most current reference time as the settlement date\n        bytes32 slot = getSlot(currencyId, settlementDate, maturity);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        market.storageSlot = slot;\n        market.maturity = maturity;\n        market.totalfCash = int256(uint80(uint256(data)));\n        market.totalAssetCash = int256(uint80(uint256(data >> 80)));\n        market.lastImpliedRate = uint256(uint32(uint256(data >> 160)));\n        market.oracleRate = uint256(uint32(uint256(data >> 192)));\n        market.previousTradeTime = uint256(uint32(uint256(data >> 224)));\n        market.storageState = STORAGE_STATE_NO_CHANGE;\n\n        if (needsLiquidity) {\n            getTotalLiquidity(market);\n        } else {\n            market.totalLiquidity = 0;\n        }\n    }\n\n    /// @notice Writes market parameters to storage if the market is marked as updated.\n    function setMarketStorage(MarketParameters memory market) internal {\n        if (market.storageState == STORAGE_STATE_NO_CHANGE) return;\n        bytes32 slot = market.storageSlot;\n\n        if (market.storageState & STORAGE_STATE_UPDATE_TRADE != STORAGE_STATE_UPDATE_TRADE) {\n            // If no trade has occurred then the oracleRate on chain should not update.\n            bytes32 oldData;\n            assembly {\n                oldData := sload(slot)\n            }\n            market.oracleRate = uint256(uint32(uint256(oldData >> 192)));\n        }\n\n        require(market.totalfCash >= 0 && market.totalfCash <= type(uint80).max); // dev: market storage totalfCash overflow\n        require(market.totalAssetCash >= 0 && market.totalAssetCash <= type(uint80).max); // dev: market storage totalAssetCash overflow\n        require(market.lastImpliedRate >= 0 && market.lastImpliedRate <= type(uint32).max); // dev: market storage lastImpliedRate overflow\n        require(market.oracleRate >= 0 && market.oracleRate <= type(uint32).max); // dev: market storage oracleRate overflow\n        require(market.previousTradeTime >= 0 && market.previousTradeTime <= type(uint32).max); // dev: market storage previous trade time overflow\n\n        bytes32 data =\n            (bytes32(market.totalfCash) |\n                (bytes32(market.totalAssetCash) << 80) |\n                (bytes32(market.lastImpliedRate) << 160) |\n                (bytes32(market.oracleRate) << 192) |\n                (bytes32(market.previousTradeTime) << 224));\n\n        assembly {\n            sstore(slot, data)\n        }\n\n        if (\n            market.storageState & STORAGE_STATE_UPDATE_LIQUIDITY == STORAGE_STATE_UPDATE_LIQUIDITY\n        ) {\n            require(market.totalLiquidity >= 0 && market.totalLiquidity <= type(uint80).max); // dev: market storage totalLiquidity overflow\n            slot = bytes32(uint256(slot) + 1);\n            bytes32 totalLiquidity = bytes32(market.totalLiquidity);\n\n            assembly {\n                sstore(slot, totalLiquidity)\n            }\n        }\n    }\n\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately.\n    function loadMarket(\n        MarketParameters memory market,\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime,\n        bool needsLiquidity,\n        uint256 rateOracleTimeWindow\n    ) internal view {\n        // Always reference the current settlement date\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\n        loadMarketWithSettlementDate(\n            market,\n            currencyId,\n            maturity,\n            blockTime,\n            needsLiquidity,\n            rateOracleTimeWindow,\n            settlementDate\n        );\n    }\n\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately, this\n    /// is mainly used in the InitializeMarketAction contract.\n    function loadMarketWithSettlementDate(\n        MarketParameters memory market,\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime,\n        bool needsLiquidity,\n        uint256 rateOracleTimeWindow,\n        uint256 settlementDate\n    ) internal view {\n        _loadMarketStorage(market, currencyId, maturity, needsLiquidity, settlementDate);\n\n        market.oracleRate = _updateRateOracle(\n            market.previousTradeTime,\n            market.lastImpliedRate,\n            market.oracleRate,\n            rateOracleTimeWindow,\n            blockTime\n        );\n    }\n\n    /// @notice When settling liquidity tokens we only need to get half of the market parameters and the settlement\n    /// date must be specified.\n    function getSettlementMarket(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 settlementDate\n    ) internal view returns (SettlementMarket memory) {\n        uint256 slot = uint256(getSlot(currencyId, settlementDate, maturity));\n        int256 totalLiquidity;\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        int256 totalfCash = int256(uint80(uint256(data)));\n        int256 totalAssetCash = int256(uint80(uint256(data >> 80)));\n        // Clear the lower 160 bits, this data will be combined with the new totalfCash\n        // and totalAssetCash figures.\n        data = data & 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\n\n        slot = uint256(slot) + 1;\n\n        assembly {\n            totalLiquidity := sload(slot)\n        }\n\n        return\n            SettlementMarket({\n                storageSlot: bytes32(slot - 1),\n                totalfCash: totalfCash,\n                totalAssetCash: totalAssetCash,\n                totalLiquidity: int256(totalLiquidity),\n                data: data\n            });\n    }\n\n    function setSettlementMarket(SettlementMarket memory market) internal {\n        bytes32 slot = market.storageSlot;\n        bytes32 data;\n        require(market.totalfCash >= 0 && market.totalfCash <= type(uint80).max); // dev: settlement market storage totalfCash overflow\n        require(market.totalAssetCash >= 0 && market.totalAssetCash <= type(uint80).max); // dev: settlement market storage totalAssetCash overflow\n        require(market.totalLiquidity >= 0 && market.totalLiquidity <= type(uint80).max); // dev: settlement market storage totalLiquidity overflow\n\n        data = (bytes32(market.totalfCash) |\n            (bytes32(market.totalAssetCash) << 80) |\n            bytes32(market.data));\n\n        // Don't clear the storage even when all liquidity tokens have been removed because we need to use\n        // the oracle rates to initialize the next set of markets.\n        assembly {\n            sstore(slot, data)\n        }\n\n        slot = bytes32(uint256(slot) + 1);\n        bytes32 totalLiquidity = bytes32(market.totalLiquidity);\n        assembly {\n            sstore(slot, totalLiquidity)\n        }\n    }\n\n    /// Uses Newton's method to converge on an fCash amount given the amount of\n    /// cash. The relation between cash and fcash is:\n    /// cashAmount * exchangeRate * fee + fCash = 0\n    /// where exchangeRate(fCash) = (rateScalar ^ -1) * ln(p / (1 - p)) + rateAnchor\n    ///       p = (totalfCash - fCash) / (totalfCash + totalCash)\n    ///       if cashAmount < 0: fee = feeRate ^ -1\n    ///       if cashAmount > 0: fee = feeRate\n    ///\n    /// Newton's method is:\n    /// fCash_(n+1) = fCash_n - f(fCash) / f'(fCash)\n    ///\n    /// f(fCash) = cashAmount * exchangeRate(fCash) * fee + fCash\n    ///\n    ///                                    (totalfCash + totalCash)\n    /// exchangeRate'(fCash) = -  ------------------------------------------\n    ///                           (totalfCash - fCash) * (totalCash + fCash)\n    ///\n    /// https://www.wolframalpha.com/input/?i=ln%28%28%28a-x%29%2F%28a%2Bb%29%29%2F%281-%28a-x%29%2F%28a%2Bb%29%29%29\n    ///\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\n    /// f'(fCash) = 1 - ------------------------------------------------------\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\n    ///\n    /// NOTE: each iteration costs about 11.3k so this is only done via a view function.\n    function getfCashGivenCashAmount(\n        int256 totalfCash,\n        int256 netCashToAccount,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 feeRate,\n        uint256 maxDelta\n    ) internal pure returns (int256) {\n        int256 fCashChangeToAccountGuess =\n            netCashToAccount.mul(rateAnchor).div(Constants.RATE_PRECISION).neg();\n        for (uint8 i; i < 250; i++) {\n            (int256 exchangeRate, bool success) =\n                _getExchangeRate(\n                    totalfCash,\n                    totalCashUnderlying,\n                    rateScalar,\n                    rateAnchor,\n                    fCashChangeToAccountGuess\n                );\n\n            require(success); // dev: invalid exchange rate\n            int256 delta =\n                _calculateDelta(\n                    netCashToAccount,\n                    totalfCash,\n                    totalCashUnderlying,\n                    rateScalar,\n                    fCashChangeToAccountGuess,\n                    exchangeRate,\n                    feeRate\n                );\n\n            if (delta.abs() <= int256(maxDelta)) return fCashChangeToAccountGuess;\n            fCashChangeToAccountGuess = fCashChangeToAccountGuess.sub(delta);\n        }\n\n        revert(\"No convergence\");\n    }\n\n    /// @dev Calculates: f(fCash) / f'(fCash)\n    /// f(fCash) = cashAmount * exchangeRate * fee + fCash\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\n    /// f'(fCash) = 1 - ------------------------------------------------------\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\n    function _calculateDelta(\n        int256 cashAmount,\n        int256 totalfCash,\n        int256 totalCashUnderlying,\n        int256 rateScalar,\n        int256 fCashGuess,\n        int256 exchangeRate,\n        int256 feeRate\n    ) private pure returns (int256) {\n        int256 derivative;\n        // rateScalar * (totalfCash - fCash) * (totalCash + fCash)\n        // Precision: TOKEN_PRECISION ^ 2\n        int256 denominator =\n            rateScalar.mulInRatePrecision(\n                (totalfCash.sub(fCashGuess)).mul(totalCashUnderlying.add(fCashGuess))\n            );\n\n        if (fCashGuess > 0) {\n            // Lending\n            exchangeRate = exchangeRate.divInRatePrecision(feeRate);\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\n\n            // (cashAmount / fee) * (totalfCash + totalCash)\n            // Precision: TOKEN_PRECISION ^ 2\n            derivative = cashAmount\n                .mul(totalfCash.add(totalCashUnderlying))\n                .divInRatePrecision(feeRate);\n        } else {\n            // Borrowing\n            exchangeRate = exchangeRate.mulInRatePrecision(feeRate);\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\n\n            // (cashAmount * fee) * (totalfCash + totalCash)\n            // Precision: TOKEN_PRECISION ^ 2\n            derivative = cashAmount.mulInRatePrecision(\n                feeRate.mul(totalfCash.add(totalCashUnderlying))\n            );\n        }\n        // 1 - numerator / denominator\n        // Precision: TOKEN_PRECISION\n        derivative = Constants.INTERNAL_TOKEN_PRECISION.sub(derivative.div(denominator));\n\n        // f(fCash) = cashAmount * exchangeRate * fee + fCash\n        // NOTE: exchangeRate at this point already has the fee taken into account\n        int256 numerator = cashAmount.mulInRatePrecision(exchangeRate);\n        numerator = numerator.add(fCashGuess);\n\n        // f(fCash) / f'(fCash), note that they are both denominated as cashAmount so use TOKEN_PRECISION\n        // here instead of RATE_PRECISION\n        return numerator.mul(Constants.INTERNAL_TOKEN_PRECISION).div(derivative);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC1155Action.sol",
            "Views.sol",
            "TokenHandler.sol",
            "Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "IERC",
                    "boolean",
                    "checkReturnCode",
                    "token.transferFrom(account, amount)",
                    "safeTransferIn",
                    "token"
                ],
                "Type": "  TokenHandler.safeTransferIn  does not work on non-standard compliant tokens like USDT",
                "Description": "\nThe TokenHandler.safeTransferIn function uses the standard IERC20 function for the transfer call and proceeds with a checkReturnCode function to handle non-standard compliant tokens that don't return a return value.\nHowever, this does not work, as calling token.transferFrom(account, amount) already reverts if the token does not return a return value, as token's IERC20.transferFrom is defined to always return a boolean.\n\nWhen using any non-standard compliant token like USDT, the function will revert.\nWithdrawals for these tokens are broken, which is bad as USDT is a valid underlying for the cUSDT cToken.\n\nWe recommend using OpenZeppelin\u2019s SafeERC20(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/80)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/INoteERC20.sol\";\nimport \"@openzeppelin/contracts/access/TimelockController.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Notional Governor Alpha\n * Fork of Compound Governor Alpha at commit hash\n * https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\n */\ncontract GovernorAlpha is TimelockController {\n    /// @notice The name of this contract\n    string public constant name = \"Notional Governor Alpha\";\n\n    /// @notice The address of the Notional governance token\n    INoteERC20 public immutable note;\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint8 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n    /// @notice The minimum voting period in blocks, about 1 day assuming 13 second blocks. Ensures that proposals will always have\n    /// time to be voted on.\n    uint32 public constant MIN_VOTING_PERIOD_BLOCKS = 6700;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed\n    uint96 public quorumVotes;\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    uint96 public proposalThreshold;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    uint32 public votingDelayBlocks;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint32 public votingPeriodBlocks;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // The timestamp at which voting begins: holders must delegate their votes prior to this block\n        uint32 startBlock;\n        // The timestamp at which voting ends: votes must be cast prior to this block\n        uint32 endBlock;\n        // Current number of votes in favor of this proposal\n        uint96 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint96 againstVotes;\n        // Creator of the proposal\n        address proposer;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Hash of the operation to reduce storage cost\n        bytes32 operationHash;\n    }\n\n    // Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public receipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct uComp by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 indexed id,\n        address indexed proposer,\n        address[] targets,\n        uint256[] values,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address indexed voter, uint256 indexed proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 indexed id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 indexed id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 indexed id);\n\n    /// @notice An event emitted when amount of quorum votes required is updated\n    event UpdateQuorumVotes(uint96 newQuorumVotes);\n\n    /// @notice An event emitted when a new proposal threshold has been set\n    event UpdateProposalThreshold(uint96 newProposalThreshold);\n\n    /// @notice An event emitted when a new voting delay in blocks has been set\n    event UpdateVotingDelayBlocks(uint32 newVotingDelayBlocks);\n\n    /// @notice An event emitted when a new voting period in blocks has been set\n    event UpdateVotingPeriodBlocks(uint32 newVotingPeriodBlocks);\n\n    /// @notice Emitted when the guardian abdicates their role\n    event Abdicate();\n\n    /// @notice An event emitted when guardian is transferred\n    event TransferGuardian(address newGuardian);\n    \n    /// @notice Initializes the GovernorAlpha with initial parameters\n    /// @param quorumVotes_ initial quorum votes value\n    /// @param proposalThreshold_ initial proposal threshold value\n    /// @param votingDelayBlocks_ initial voting delay blocks value\n    /// @param votingPeriodBlocks_ initial voting period blocks value\n    /// @param note_ address of the NOTE token to get voting power\n    /// @param guardian_ address of guardian\n    /// @param minDelay_ initial minimum delay for timelock in seconds\n    constructor(\n        uint96 quorumVotes_,\n        uint96 proposalThreshold_,\n        uint32 votingDelayBlocks_,\n        uint32 votingPeriodBlocks_,\n        address note_,\n        address guardian_,\n        uint256 minDelay_\n    ) TimelockController(minDelay_, new address[](0), new address[](0)) {\n        require(Address.isContract(note_));\n\n        quorumVotes = quorumVotes_;\n        proposalThreshold = proposalThreshold_;\n        votingDelayBlocks = votingDelayBlocks_;\n        // Do not enforce MIN_VOTING_DELAY during constructor so that tests don't require a large number\n        // of blocks for the voting period. During actual mainnet deployment this will be set to a reasonable value.\n        votingPeriodBlocks = votingPeriodBlocks_;\n        note = INoteERC20(note_);\n        guardian = guardian_;\n\n        // Only the external methods can be used to execute governance\n        grantRole(PROPOSER_ROLE, address(this));\n        grantRole(EXECUTOR_ROLE, address(this));\n        revokeRole(TIMELOCK_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @notice Proposes a new governance action\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalCreated\n    /// @return newly created proposal id\n    function propose(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external returns (uint256) {\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber < type(uint32).max);\n\n        require(\n            note.getPriorVotes(msg.sender, blockNumber - 1) > proposalThreshold,\n            \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(\n            targets.length <= PROPOSAL_MAX_OPERATIONS,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        {\n            uint256 latestProposalId = latestProposalIds[msg.sender];\n            if (latestProposalId != 0) {\n                ProposalState proposersLatestProposalState = state(latestProposalId);\n                require(\n                    proposersLatestProposalState != ProposalState.Active,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n                );\n                require(\n                    proposersLatestProposalState != ProposalState.Pending,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n                );\n            }\n        }\n\n        uint256 newProposalId = proposalCount + 1;\n        proposalCount = newProposalId;\n\n        uint32 startBlock = _add32(uint32(blockNumber), votingDelayBlocks);\n        uint32 endBlock = _add32(startBlock, votingPeriodBlocks);\n        bytes32 operationHash = _computeHash(targets, values, calldatas, newProposalId);\n\n        Proposal memory newProposal =\n            Proposal({\n                id: newProposalId,\n                proposer: msg.sender,\n                startBlock: startBlock,\n                endBlock: endBlock,\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false,\n                operationHash: operationHash\n            });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            calldatas,\n            startBlock,\n            endBlock\n        );\n        return newProposal.id;\n    }\n\n    /// @dev Helper method required to clear the stack for hashing operations\n    function _computeHash(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private pure returns (bytes32) {\n        return hashOperationBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));\n    }\n\n    /// @notice Adds a proposal to the timelock queue only after its vote has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal. All proposals\n    /// will automatically be delayed `getMinDelay()` seconds.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalQueued emit:CallScheduled (per call)\n    function queueProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external {\n        require(state(proposalId) == ProposalState.Succeeded, \"Proposal must be success\");\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        {\n            Proposal storage proposal = proposals[proposalId];\n            require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        }\n\n        _scheduleBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalQueued(proposalId, getMinDelay());\n    }\n\n    /// @dev Required to clear the stack for calling the timelock controller\n    function _scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        // NOTE: this will also emit events\n        this.scheduleBatch(\n            targets,\n            values,\n            calldatas,\n            bytes32(0),\n            bytes32(proposalId),\n            getMinDelay()\n        );\n    }\n\n    /// @notice Executes a proposal in the timelock queue after its delay has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalExecuted emit:CallExecuted (per call)\n    function executeProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external payable {\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        // Execute batch will revert if the call has not been scheduled\n        _executeBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalExecuted(proposalId);\n    }\n\n    /// @dev Helper function to clear the stack for the timelock controller call\n    function _executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        this.executeBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));\n    }\n\n    /// @notice Cancels a proposal after it has been created. Can only be done if the proposer\n    /// no longer has sufficient votes (i.e. they made a proposal and then sold their tokens) or\n    /// by a guardian address if it exists.\n    /// @param proposalId unique identifier for the proposal\n    /// @dev emit:ProposalCanceled emit:Canceled\n    function cancelProposal(uint256 proposalId) public {\n        ProposalState proposalState = state(proposalId);\n        require(proposalState != ProposalState.Executed, \"Proposal already executed\");\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber <= type(uint32).max);\n        require(\n            msg.sender == guardian ||\n                note.getPriorVotes(proposal.proposer, blockNumber - 1) < proposalThreshold,\n            \"GovernorAlpha::cancel: proposer above threshold\"\n        );\n\n        proposal.canceled = true;\n        // Removes the operation hash from the timelock controller if pending.\n        if (isOperationPending(proposal.operationHash)) this.cancel(proposal.operationHash);\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /// @notice Returns the voting receipt for a voter on a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param voter address of the voter\n    /// @return the voting receipt for the voter and proposal\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return receipts[proposalId][voter];\n    }\n\n    /// @notice Returns the current state of a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @return ProposalState enum for the current state of the proposal\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n        Proposal memory proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber <= type(uint32).max);\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (blockNumber <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (blockNumber <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (isOperationPending(proposal.operationHash)) {\n            return ProposalState.Queued;\n        } else if (\n            proposal.forVotes > proposal.againstVotes &&\n            proposal.forVotes > quorumVotes &&\n            blockNumber > proposal.endBlock\n        ) {\n            return ProposalState.Succeeded;\n        }\n    }\n\n    /// @notice Cast a vote for a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @dev emit:VoteCast\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /// @notice Cast a vote for a proposal via signature\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @param v signature component\n    /// @param r signature component\n    /// @param s signature component\n    /// @dev emit:VoteCast\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        // ECDSA.recover will check if address is zero\n        address signatory = ECDSA.recover(digest, v, r, s);\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /// @dev Registers a vote, calls the NOTE token to get the voting power for the voter\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = receipts[proposalId][voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = note.getPriorVotes(voter, proposal.startBlock);\n        // Short circuit if voter has no votes\n        if (votes == 0) return;\n\n        if (support) {\n            proposal.forVotes = _add96(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = _add96(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    /// @notice Updates the quorum votes required, can only be executed via a proposal\n    /// @param newQuorumVotes new quorum votes required\n    /// @dev emit:UpdateQuorumVotes\n    function updateQuorumVotes(uint96 newQuorumVotes) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        quorumVotes = newQuorumVotes;\n        emit UpdateQuorumVotes(newQuorumVotes);\n    }\n\n    /// @notice Updates the proposal threshold required, can only be executed via a proposal\n    /// @param newProposalThreshold new proposal threshold\n    /// @dev emit:UpdateProposalThreshold\n    function updateProposalThreshold(uint96 newProposalThreshold) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        proposalThreshold = newProposalThreshold;\n        emit UpdateProposalThreshold(newProposalThreshold);\n    }\n\n    /// @notice Updates the voting delay blocks required, can only be executed via a proposal\n    /// @param newVotingDelayBlocks new voting delay blocks\n    /// @dev emit:UpdateVotingDelayBlocks\n    function updateVotingDelayBlocks(uint32 newVotingDelayBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        votingDelayBlocks = newVotingDelayBlocks;\n        emit UpdateVotingDelayBlocks(newVotingDelayBlocks);\n    }\n\n    /// @notice Updates the voting period blocks required, can only be executed via a proposal\n    /// @param newVotingPeriodBlocks new voting period blocks\n    /// @dev emit:UpdateVotingPeriodBlocks\n    function updateVotingPeriodBlocks(uint32 newVotingPeriodBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        require(newVotingPeriodBlocks >= MIN_VOTING_PERIOD_BLOCKS, \"Below min voting period\");\n        votingPeriodBlocks = newVotingPeriodBlocks;\n        emit UpdateVotingPeriodBlocks(newVotingPeriodBlocks);\n    }\n\n    /// @dev Hidden public method\n    function __abdicate() external {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n        emit Abdicate();\n    }\n\n    /// @notice Transfers guardian role to a new guardian\n    /// @param newGuardian address to transfer role to\n    function __transferGuardian(address newGuardian) external {\n        require(\n            msg.sender == guardian,\n            \"GovernorAlpha::__transferGuardian: sender must be gov guardian\"\n        );\n        require(newGuardian != address(0), \"Cannot transfer to zero address\");\n\n        guardian = newGuardian;\n        emit TransferGuardian(newGuardian);\n    }\n\n    /// @dev Overflow check for adding votes\n    function _add96(uint96 a, uint96 b) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Overflow check for adding block numbers\n    function _add32(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Helper method for signature check\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Constants.sol\";\nimport \"../proxy/utils/UUPSUpgradeable.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\n\n/**\n * Read only version of the Router that can only be upgraded by governance. Used in emergency when the system must\n * be paused for some reason.\n */\ncontract PauseRouter is StorageLayoutV1, UUPSUpgradeable {\n    address public immutable VIEWS;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n\n    constructor(\n        address views_,\n        address liquidateCurrency_,\n        address liquidatefCash_\n    ) {\n        VIEWS = views_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override {\n        // This is only true during a rollback check when the pause router is downgraded\n        bool isRollbackCheck = rollbackRouterImplementation != address(0) &&\n            newImplementation == rollbackRouterImplementation;\n\n        require(\n            owner == msg.sender || (msg.sender == pauseGuardian && isRollbackCheck),\n            \"Unauthorized upgrade\"\n        );\n\n        // Clear this storage slot so the guardian cannot upgrade back to the previous router,\n        // requires governance to do so.\n        rollbackRouterImplementation = address(0);\n    }\n\n    function getLiquidationEnabledState() external view returns (bytes1) {\n        return liquidationEnabledState;\n    }\n\n    function setLiquidationEnabledState(bytes1 liquidationEnabledState_) external {\n        // Only authorized addresses can set the liquidation state\n        require(owner == msg.sender || msg.sender == pauseGuardian);\n        liquidationEnabledState = liquidationEnabledState_;\n    }\n\n    function isEnabled(bytes1 state) private view returns (bool) {\n        return (liquidationEnabledState & state == state);\n    }\n\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        // Liquidation calculation methods are stateful (they settle accounts if required)\n        // and therefore we prevent them from being called unless specifically authorized.\n        if (\n            (sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateCollateralCurrency.selector) &&\n            isEnabled(Constants.COLLATERAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateLocalCurrency.selector) &&\n            isEnabled(Constants.LOCAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashLocal.selector ||\n                sig == NotionalProxy.calculatefCashLocalLiquidation.selector) &&\n            isEnabled(Constants.LOCAL_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n                sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector) &&\n            isEnabled(Constants.CROSS_CURRENCY_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./actions/nTokenAction.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"./actions/nTokenRedeemAction.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\n\n/**\n * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage\n * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing\n * contracts.\n *\n * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also\n * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a\n * new Router with the new hardcoded addresses will then be deployed and upgraded into place.\n */\ncontract Router is StorageLayoutV1 {\n    // These contract addresses cannot be changed once set by the constructor\n    address public immutable GOVERNANCE;\n    address public immutable VIEWS;\n    address public immutable INITIALIZE_MARKET;\n    address public immutable NTOKEN_ACTIONS;\n    address public immutable NTOKEN_REDEEM;\n    address public immutable BATCH_ACTION;\n    address public immutable ACCOUNT_ACTION;\n    address public immutable ERC1155;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n    address public immutable cETH;\n\n    constructor(\n        address governance_,\n        address views_,\n        address initializeMarket_,\n        address nTokenActions_,\n        address nTokenRedeem_,\n        address batchAction_,\n        address accountAction_,\n        address erc1155_,\n        address liquidateCurrency_,\n        address liquidatefCash_,\n        address cETH_\n    ) {\n        GOVERNANCE = governance_;\n        VIEWS = views_;\n        INITIALIZE_MARKET = initializeMarket_;\n        NTOKEN_ACTIONS = nTokenActions_;\n        NTOKEN_REDEEM = nTokenRedeem_;\n        BATCH_ACTION = batchAction_;\n        ACCOUNT_ACTION = accountAction_;\n        ERC1155 = erc1155_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n        cETH = cETH_;\n    }\n\n    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\n        // Cannot re-initialize once the contract has been initialized, ownership transfer does not\n        // allow address to be set back to zero\n        require(owner == address(0), \"R: already initialized\");\n\n        // Allow list currency to be called by this contract for the purposes of\n        // initializing ETH as a currency\n        owner = msg.sender;\n        // List ETH as currency id == 1, NOTE: return value is ignored here\n        (bool status, ) =\n            address(GOVERNANCE).delegatecall(\n                abi.encodeWithSelector(\n                    NotionalGovernance.listCurrency.selector,\n                    TokenStorage(cETH, false, TokenType.cETH),\n                    // No underlying set for cETH\n                    TokenStorage(address(0), false, TokenType.Ether),\n                    address(0),\n                    false,\n                    130, // Initial settings of 130 buffer\n                    70,  // 70% haircut\n                    105  // 105 liquidation discount\n                )\n            );\n        require(status);\n\n        owner = owner_;\n        // The pause guardian may downgrade the router to the pauseRouter\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n    }\n\n    /// @notice Returns the implementation contract for the method signature\n    /// @param sig method signature to call\n    /// @return implementation address\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        if (\n            sig == NotionalProxy.batchBalanceAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector\n        ) {\n            return BATCH_ACTION;\n        }\n\n        if (\n            sig == nTokenAction.nTokenTotalSupply.selector ||\n            sig == nTokenAction.nTokenBalanceOf.selector ||\n            sig == nTokenAction.nTokenTransferAllowance.selector ||\n            sig == nTokenAction.nTokenTransferApprove.selector ||\n            sig == nTokenAction.nTokenTransfer.selector ||\n            sig == nTokenAction.nTokenTransferFrom.selector ||\n            sig == nTokenAction.nTokenClaimIncentives.selector ||\n            sig == nTokenAction.nTokenTransferApproveAll.selector ||\n            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||\n            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector\n        ) {\n            return NTOKEN_ACTIONS;\n        }\n\n        if (\n            sig == NotionalProxy.depositUnderlyingToken.selector ||\n            sig == NotionalProxy.depositAssetToken.selector ||\n            sig == NotionalProxy.withdraw.selector ||\n            sig == NotionalProxy.settleAccount.selector ||\n            sig == NotionalProxy.enableBitmapCurrency.selector\n        ) {\n            return ACCOUNT_ACTION;\n        }\n\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector\n        ) {\n            return NTOKEN_REDEEM;\n        }\n\n        if (\n            sig == nERC1155Interface.supportsInterface.selector ||\n            sig == nERC1155Interface.balanceOf.selector ||\n            sig == nERC1155Interface.balanceOfBatch.selector ||\n            sig == nERC1155Interface.safeTransferFrom.selector ||\n            sig == nERC1155Interface.safeBatchTransferFrom.selector ||\n            sig == nERC1155Interface.decodeToAssets.selector ||\n            sig == nERC1155Interface.encodeToId.selector ||\n            sig == nERC1155Interface.setApprovalForAll.selector ||\n            sig == nERC1155Interface.isApprovedForAll.selector\n        ) {\n            return ERC1155;\n        }\n\n        if (\n            sig == NotionalProxy.liquidateLocalCurrency.selector ||\n            sig == NotionalProxy.liquidateCollateralCurrency.selector ||\n            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            sig == NotionalProxy.liquidatefCashLocal.selector ||\n            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||\n            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            sig == NotionalProxy.initializeMarkets.selector ||\n            sig == NotionalProxy.sweepCashIntoMarkets.selector\n        ) {\n            return INITIALIZE_MARKET;\n        }\n\n        if (\n            sig == NotionalGovernance.listCurrency.selector ||\n            sig == NotionalGovernance.enableCashGroup.selector ||\n            sig == NotionalGovernance.updateCashGroup.selector ||\n            sig == NotionalGovernance.updateAssetRate.selector ||\n            sig == NotionalGovernance.updateETHRate.selector ||\n            sig == NotionalGovernance.transferOwnership.selector ||\n            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||\n            sig == NotionalGovernance.updateDepositParameters.selector ||\n            sig == NotionalGovernance.updateInitializationParameters.selector ||\n            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||\n            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||\n            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||\n            sig == NotionalProxy.upgradeTo.selector ||\n            sig == NotionalProxy.upgradeToAndCall.selector\n        ) {\n            return GOVERNANCE;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n\n    // NOTE: receive() is overridden in \"nProxy\" to allow for eth transfers to succeed\n}\n\n\n",
        "CodeNames": [
            "GovernorAlpha.sol",
            "PauseRouter.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "constructor()",
                    "NoteERC",
                    "initialize()"
                ],
                "Type": " DOS by Frontrunning NoteERC20  initialize()  Function",
                "Description": "\nThe scripts/ folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilize the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic.\n\nWhen users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. NoteERC20.sol and Router.sol both implement an initialize() function which aims to replace the role of the constructor() when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious front-running.\n\nHowever, scripts/deployment.py does not follow this pattern when deploying NoteERC20.sol's proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the NoteERC20 contract and front-run the initialize() transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional's contract deployment, leading to unrecoverable gas expenses. See deployment.py L44-L60(https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60), and deploy_governance.py L71-L105(https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105).\n\nAs the GovernanceAlpha.sol and NoteERC20.sol are co-dependent contracts in terms of deployment, it won't be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the NoteERC20.sol proxy contract is deployed and initialized in the same transaction, or ensure the initialize() function is callable only by the deployer of the NoteERC20.sol contract. This could be set in the proxy contracts constructor().\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/7)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./actions/nTokenAction.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"./actions/nTokenRedeemAction.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\n\n/**\n * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage\n * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing\n * contracts.\n *\n * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also\n * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a\n * new Router with the new hardcoded addresses will then be deployed and upgraded into place.\n */\ncontract Router is StorageLayoutV1 {\n    // These contract addresses cannot be changed once set by the constructor\n    address public immutable GOVERNANCE;\n    address public immutable VIEWS;\n    address public immutable INITIALIZE_MARKET;\n    address public immutable NTOKEN_ACTIONS;\n    address public immutable NTOKEN_REDEEM;\n    address public immutable BATCH_ACTION;\n    address public immutable ACCOUNT_ACTION;\n    address public immutable ERC1155;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n    address public immutable cETH;\n\n    constructor(\n        address governance_,\n        address views_,\n        address initializeMarket_,\n        address nTokenActions_,\n        address nTokenRedeem_,\n        address batchAction_,\n        address accountAction_,\n        address erc1155_,\n        address liquidateCurrency_,\n        address liquidatefCash_,\n        address cETH_\n    ) {\n        GOVERNANCE = governance_;\n        VIEWS = views_;\n        INITIALIZE_MARKET = initializeMarket_;\n        NTOKEN_ACTIONS = nTokenActions_;\n        NTOKEN_REDEEM = nTokenRedeem_;\n        BATCH_ACTION = batchAction_;\n        ACCOUNT_ACTION = accountAction_;\n        ERC1155 = erc1155_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n        cETH = cETH_;\n    }\n\n    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\n        // Cannot re-initialize once the contract has been initialized, ownership transfer does not\n        // allow address to be set back to zero\n        require(owner == address(0), \"R: already initialized\");\n\n        // Allow list currency to be called by this contract for the purposes of\n        // initializing ETH as a currency\n        owner = msg.sender;\n        // List ETH as currency id == 1, NOTE: return value is ignored here\n        (bool status, ) =\n            address(GOVERNANCE).delegatecall(\n                abi.encodeWithSelector(\n                    NotionalGovernance.listCurrency.selector,\n                    TokenStorage(cETH, false, TokenType.cETH),\n                    // No underlying set for cETH\n                    TokenStorage(address(0), false, TokenType.Ether),\n                    address(0),\n                    false,\n                    130, // Initial settings of 130 buffer\n                    70,  // 70% haircut\n                    105  // 105 liquidation discount\n                )\n            );\n        require(status);\n\n        owner = owner_;\n        // The pause guardian may downgrade the router to the pauseRouter\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n    }\n\n    /// @notice Returns the implementation contract for the method signature\n    /// @param sig method signature to call\n    /// @return implementation address\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        if (\n            sig == NotionalProxy.batchBalanceAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector\n        ) {\n            return BATCH_ACTION;\n        }\n\n        if (\n            sig == nTokenAction.nTokenTotalSupply.selector ||\n            sig == nTokenAction.nTokenBalanceOf.selector ||\n            sig == nTokenAction.nTokenTransferAllowance.selector ||\n            sig == nTokenAction.nTokenTransferApprove.selector ||\n            sig == nTokenAction.nTokenTransfer.selector ||\n            sig == nTokenAction.nTokenTransferFrom.selector ||\n            sig == nTokenAction.nTokenClaimIncentives.selector ||\n            sig == nTokenAction.nTokenTransferApproveAll.selector ||\n            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||\n            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector\n        ) {\n            return NTOKEN_ACTIONS;\n        }\n\n        if (\n            sig == NotionalProxy.depositUnderlyingToken.selector ||\n            sig == NotionalProxy.depositAssetToken.selector ||\n            sig == NotionalProxy.withdraw.selector ||\n            sig == NotionalProxy.settleAccount.selector ||\n            sig == NotionalProxy.enableBitmapCurrency.selector\n        ) {\n            return ACCOUNT_ACTION;\n        }\n\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector\n        ) {\n            return NTOKEN_REDEEM;\n        }\n\n        if (\n            sig == nERC1155Interface.supportsInterface.selector ||\n            sig == nERC1155Interface.balanceOf.selector ||\n            sig == nERC1155Interface.balanceOfBatch.selector ||\n            sig == nERC1155Interface.safeTransferFrom.selector ||\n            sig == nERC1155Interface.safeBatchTransferFrom.selector ||\n            sig == nERC1155Interface.decodeToAssets.selector ||\n            sig == nERC1155Interface.encodeToId.selector ||\n            sig == nERC1155Interface.setApprovalForAll.selector ||\n            sig == nERC1155Interface.isApprovedForAll.selector\n        ) {\n            return ERC1155;\n        }\n\n        if (\n            sig == NotionalProxy.liquidateLocalCurrency.selector ||\n            sig == NotionalProxy.liquidateCollateralCurrency.selector ||\n            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            sig == NotionalProxy.liquidatefCashLocal.selector ||\n            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||\n            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            sig == NotionalProxy.initializeMarkets.selector ||\n            sig == NotionalProxy.sweepCashIntoMarkets.selector\n        ) {\n            return INITIALIZE_MARKET;\n        }\n\n        if (\n            sig == NotionalGovernance.listCurrency.selector ||\n            sig == NotionalGovernance.enableCashGroup.selector ||\n            sig == NotionalGovernance.updateCashGroup.selector ||\n            sig == NotionalGovernance.updateAssetRate.selector ||\n            sig == NotionalGovernance.updateETHRate.selector ||\n            sig == NotionalGovernance.transferOwnership.selector ||\n            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||\n            sig == NotionalGovernance.updateDepositParameters.selector ||\n            sig == NotionalGovernance.updateInitializationParameters.selector ||\n            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||\n            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||\n            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||\n            sig == NotionalProxy.upgradeTo.selector ||\n            sig == NotionalProxy.upgradeToAndCall.selector\n        ) {\n            return GOVERNANCE;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n\n    // NOTE: receive() is overridden in \"nProxy\" to allow for eth transfers to succeed\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/INoteERC20.sol\";\nimport \"@openzeppelin/contracts/access/TimelockController.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Notional Governor Alpha\n * Fork of Compound Governor Alpha at commit hash\n * https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\n */\ncontract GovernorAlpha is TimelockController {\n    /// @notice The name of this contract\n    string public constant name = \"Notional Governor Alpha\";\n\n    /// @notice The address of the Notional governance token\n    INoteERC20 public immutable note;\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint8 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n    /// @notice The minimum voting period in blocks, about 1 day assuming 13 second blocks. Ensures that proposals will always have\n    /// time to be voted on.\n    uint32 public constant MIN_VOTING_PERIOD_BLOCKS = 6700;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed\n    uint96 public quorumVotes;\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    uint96 public proposalThreshold;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    uint32 public votingDelayBlocks;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint32 public votingPeriodBlocks;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // The timestamp at which voting begins: holders must delegate their votes prior to this block\n        uint32 startBlock;\n        // The timestamp at which voting ends: votes must be cast prior to this block\n        uint32 endBlock;\n        // Current number of votes in favor of this proposal\n        uint96 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint96 againstVotes;\n        // Creator of the proposal\n        address proposer;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Hash of the operation to reduce storage cost\n        bytes32 operationHash;\n    }\n\n    // Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public receipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct uComp by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 indexed id,\n        address indexed proposer,\n        address[] targets,\n        uint256[] values,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address indexed voter, uint256 indexed proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 indexed id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 indexed id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 indexed id);\n\n    /// @notice An event emitted when amount of quorum votes required is updated\n    event UpdateQuorumVotes(uint96 newQuorumVotes);\n\n    /// @notice An event emitted when a new proposal threshold has been set\n    event UpdateProposalThreshold(uint96 newProposalThreshold);\n\n    /// @notice An event emitted when a new voting delay in blocks has been set\n    event UpdateVotingDelayBlocks(uint32 newVotingDelayBlocks);\n\n    /// @notice An event emitted when a new voting period in blocks has been set\n    event UpdateVotingPeriodBlocks(uint32 newVotingPeriodBlocks);\n\n    /// @notice Emitted when the guardian abdicates their role\n    event Abdicate();\n\n    /// @notice An event emitted when guardian is transferred\n    event TransferGuardian(address newGuardian);\n    \n    /// @notice Initializes the GovernorAlpha with initial parameters\n    /// @param quorumVotes_ initial quorum votes value\n    /// @param proposalThreshold_ initial proposal threshold value\n    /// @param votingDelayBlocks_ initial voting delay blocks value\n    /// @param votingPeriodBlocks_ initial voting period blocks value\n    /// @param note_ address of the NOTE token to get voting power\n    /// @param guardian_ address of guardian\n    /// @param minDelay_ initial minimum delay for timelock in seconds\n    constructor(\n        uint96 quorumVotes_,\n        uint96 proposalThreshold_,\n        uint32 votingDelayBlocks_,\n        uint32 votingPeriodBlocks_,\n        address note_,\n        address guardian_,\n        uint256 minDelay_\n    ) TimelockController(minDelay_, new address[](0), new address[](0)) {\n        require(Address.isContract(note_));\n\n        quorumVotes = quorumVotes_;\n        proposalThreshold = proposalThreshold_;\n        votingDelayBlocks = votingDelayBlocks_;\n        // Do not enforce MIN_VOTING_DELAY during constructor so that tests don't require a large number\n        // of blocks for the voting period. During actual mainnet deployment this will be set to a reasonable value.\n        votingPeriodBlocks = votingPeriodBlocks_;\n        note = INoteERC20(note_);\n        guardian = guardian_;\n\n        // Only the external methods can be used to execute governance\n        grantRole(PROPOSER_ROLE, address(this));\n        grantRole(EXECUTOR_ROLE, address(this));\n        revokeRole(TIMELOCK_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @notice Proposes a new governance action\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalCreated\n    /// @return newly created proposal id\n    function propose(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external returns (uint256) {\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber < type(uint32).max);\n\n        require(\n            note.getPriorVotes(msg.sender, blockNumber - 1) > proposalThreshold,\n            \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(\n            targets.length <= PROPOSAL_MAX_OPERATIONS,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        {\n            uint256 latestProposalId = latestProposalIds[msg.sender];\n            if (latestProposalId != 0) {\n                ProposalState proposersLatestProposalState = state(latestProposalId);\n                require(\n                    proposersLatestProposalState != ProposalState.Active,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n                );\n                require(\n                    proposersLatestProposalState != ProposalState.Pending,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n                );\n            }\n        }\n\n        uint256 newProposalId = proposalCount + 1;\n        proposalCount = newProposalId;\n\n        uint32 startBlock = _add32(uint32(blockNumber), votingDelayBlocks);\n        uint32 endBlock = _add32(startBlock, votingPeriodBlocks);\n        bytes32 operationHash = _computeHash(targets, values, calldatas, newProposalId);\n\n        Proposal memory newProposal =\n            Proposal({\n                id: newProposalId,\n                proposer: msg.sender,\n                startBlock: startBlock,\n                endBlock: endBlock,\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false,\n                operationHash: operationHash\n            });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            calldatas,\n            startBlock,\n            endBlock\n        );\n        return newProposal.id;\n    }\n\n    /// @dev Helper method required to clear the stack for hashing operations\n    function _computeHash(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private pure returns (bytes32) {\n        return hashOperationBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));\n    }\n\n    /// @notice Adds a proposal to the timelock queue only after its vote has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal. All proposals\n    /// will automatically be delayed `getMinDelay()` seconds.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalQueued emit:CallScheduled (per call)\n    function queueProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external {\n        require(state(proposalId) == ProposalState.Succeeded, \"Proposal must be success\");\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        {\n            Proposal storage proposal = proposals[proposalId];\n            require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        }\n\n        _scheduleBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalQueued(proposalId, getMinDelay());\n    }\n\n    /// @dev Required to clear the stack for calling the timelock controller\n    function _scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        // NOTE: this will also emit events\n        this.scheduleBatch(\n            targets,\n            values,\n            calldatas,\n            bytes32(0),\n            bytes32(proposalId),\n            getMinDelay()\n        );\n    }\n\n    /// @notice Executes a proposal in the timelock queue after its delay has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalExecuted emit:CallExecuted (per call)\n    function executeProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external payable {\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        // Execute batch will revert if the call has not been scheduled\n        _executeBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalExecuted(proposalId);\n    }\n\n    /// @dev Helper function to clear the stack for the timelock controller call\n    function _executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        this.executeBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));\n    }\n\n    /// @notice Cancels a proposal after it has been created. Can only be done if the proposer\n    /// no longer has sufficient votes (i.e. they made a proposal and then sold their tokens) or\n    /// by a guardian address if it exists.\n    /// @param proposalId unique identifier for the proposal\n    /// @dev emit:ProposalCanceled emit:Canceled\n    function cancelProposal(uint256 proposalId) public {\n        ProposalState proposalState = state(proposalId);\n        require(proposalState != ProposalState.Executed, \"Proposal already executed\");\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber <= type(uint32).max);\n        require(\n            msg.sender == guardian ||\n                note.getPriorVotes(proposal.proposer, blockNumber - 1) < proposalThreshold,\n            \"GovernorAlpha::cancel: proposer above threshold\"\n        );\n\n        proposal.canceled = true;\n        // Removes the operation hash from the timelock controller if pending.\n        if (isOperationPending(proposal.operationHash)) this.cancel(proposal.operationHash);\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /// @notice Returns the voting receipt for a voter on a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param voter address of the voter\n    /// @return the voting receipt for the voter and proposal\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return receipts[proposalId][voter];\n    }\n\n    /// @notice Returns the current state of a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @return ProposalState enum for the current state of the proposal\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n        Proposal memory proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber <= type(uint32).max);\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (blockNumber <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (blockNumber <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (isOperationPending(proposal.operationHash)) {\n            return ProposalState.Queued;\n        } else if (\n            proposal.forVotes > proposal.againstVotes &&\n            proposal.forVotes > quorumVotes &&\n            blockNumber > proposal.endBlock\n        ) {\n            return ProposalState.Succeeded;\n        }\n    }\n\n    /// @notice Cast a vote for a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @dev emit:VoteCast\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /// @notice Cast a vote for a proposal via signature\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @param v signature component\n    /// @param r signature component\n    /// @param s signature component\n    /// @dev emit:VoteCast\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        // ECDSA.recover will check if address is zero\n        address signatory = ECDSA.recover(digest, v, r, s);\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /// @dev Registers a vote, calls the NOTE token to get the voting power for the voter\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = receipts[proposalId][voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = note.getPriorVotes(voter, proposal.startBlock);\n        // Short circuit if voter has no votes\n        if (votes == 0) return;\n\n        if (support) {\n            proposal.forVotes = _add96(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = _add96(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    /// @notice Updates the quorum votes required, can only be executed via a proposal\n    /// @param newQuorumVotes new quorum votes required\n    /// @dev emit:UpdateQuorumVotes\n    function updateQuorumVotes(uint96 newQuorumVotes) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        quorumVotes = newQuorumVotes;\n        emit UpdateQuorumVotes(newQuorumVotes);\n    }\n\n    /// @notice Updates the proposal threshold required, can only be executed via a proposal\n    /// @param newProposalThreshold new proposal threshold\n    /// @dev emit:UpdateProposalThreshold\n    function updateProposalThreshold(uint96 newProposalThreshold) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        proposalThreshold = newProposalThreshold;\n        emit UpdateProposalThreshold(newProposalThreshold);\n    }\n\n    /// @notice Updates the voting delay blocks required, can only be executed via a proposal\n    /// @param newVotingDelayBlocks new voting delay blocks\n    /// @dev emit:UpdateVotingDelayBlocks\n    function updateVotingDelayBlocks(uint32 newVotingDelayBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        votingDelayBlocks = newVotingDelayBlocks;\n        emit UpdateVotingDelayBlocks(newVotingDelayBlocks);\n    }\n\n    /// @notice Updates the voting period blocks required, can only be executed via a proposal\n    /// @param newVotingPeriodBlocks new voting period blocks\n    /// @dev emit:UpdateVotingPeriodBlocks\n    function updateVotingPeriodBlocks(uint32 newVotingPeriodBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        require(newVotingPeriodBlocks >= MIN_VOTING_PERIOD_BLOCKS, \"Below min voting period\");\n        votingPeriodBlocks = newVotingPeriodBlocks;\n        emit UpdateVotingPeriodBlocks(newVotingPeriodBlocks);\n    }\n\n    /// @dev Hidden public method\n    function __abdicate() external {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n        emit Abdicate();\n    }\n\n    /// @notice Transfers guardian role to a new guardian\n    /// @param newGuardian address to transfer role to\n    function __transferGuardian(address newGuardian) external {\n        require(\n            msg.sender == guardian,\n            \"GovernorAlpha::__transferGuardian: sender must be gov guardian\"\n        );\n        require(newGuardian != address(0), \"Cannot transfer to zero address\");\n\n        guardian = newGuardian;\n        emit TransferGuardian(newGuardian);\n    }\n\n    /// @dev Overflow check for adding votes\n    function _add96(uint96 a, uint96 b) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Overflow check for adding block numbers\n    function _add32(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Helper method for signature check\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../internal/valuation/ExchangeRate.sol\";\nimport \"../../internal/markets/CashGroup.sol\";\nimport \"../../internal/nTokenHandler.sol\";\nimport \"../../internal/balances/TokenHandler.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"../../proxy/utils/UUPSUpgradeable.sol\";\nimport \"../adapters/nTokenERC20Proxy.sol\";\nimport \"interfaces/notional/AssetRateAdapter.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\n/// @notice Governance methods can only be called by the governance contract\ncontract GovernanceAction is StorageLayoutV1, NotionalGovernance, UUPSUpgradeable {\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Can only be called by the current owner.\n    function transferOwnership(address newOwner) external override onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /// @dev Only the owner may upgrade the contract, the pauseGuardian may downgrade the contract\n    /// to a predetermined router contract that provides read only access to the system.\n    function _authorizeUpgrade(address newImplementation) internal override {\n        require(\n            owner == msg.sender ||\n            (msg.sender == pauseGuardian && newImplementation == pauseRouter),\n            \"Unauthorized upgrade\"\n        );\n\n        // This is set temporarily during a downgrade to the pauseRouter so that the upgrade\n        // will pass _authorizeUpgrade on the pauseRouter during the UUPSUpgradeable rollback check\n        if (newImplementation == pauseRouter) rollbackRouterImplementation = _getImplementation();\n    }\n\n    /// @notice Sets a new pause router and guardian address.\n    function setPauseRouterAndGuardian(\n        address pauseRouter_,\n        address pauseGuardian_\n    ) external override onlyOwner {\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n\n        emit PauseRouterAndGuardianUpdated(pauseRouter_, pauseGuardian_);\n    }\n\n    /// @notice Lists a new currency along with its exchange rate to ETH\n    /// @dev emit:ListCurrency emit:UpdateETHRate\n    /// @param assetToken the token parameters for the asset token\n    /// @param underlyingToken the underlying token (if asset token is an interest bearing wrapper)\n    /// @param rateOracle ETH to underlying rate oracle\n    /// @param mustInvert if the rate from the oracle needs to be inverted\n    /// @param buffer multiplier (>= 100) for negative balances when calculating free collateral\n    /// @param haircut multiplier (<= 100) for positive balances when calculating free collateral\n    /// @param liquidationDiscount multiplier (>= 100) for exchange rate when liquidating\n    function listCurrency(\n        TokenStorage calldata assetToken,\n        TokenStorage calldata underlyingToken,\n        address rateOracle,\n        bool mustInvert,\n        uint8 buffer,\n        uint8 haircut,\n        uint8 liquidationDiscount\n    ) external override onlyOwner {\n        uint16 currencyId = maxCurrencyId + 1;\n        // Set the new max currency id\n        maxCurrencyId = currencyId;\n        require(currencyId <= Constants.MAX_CURRENCIES, \"G: max currency overflow\");\n        require(\n            tokenAddressToCurrencyId[assetToken.tokenAddress] == 0,\n            \"G: duplicate token listing\"\n        );\n        tokenAddressToCurrencyId[assetToken.tokenAddress] = currencyId;\n\n        // Set the underlying first because the asset token may set an approval using the underlying\n        if (\n            underlyingToken.tokenAddress != address(0) ||\n            // Ether has a token address of zero\n            underlyingToken.tokenType == TokenType.Ether\n        ) {\n            TokenHandler.setToken(currencyId, true, underlyingToken);\n        }\n        TokenHandler.setToken(currencyId, false, assetToken);\n\n        _updateETHRate(currencyId, rateOracle, mustInvert, buffer, haircut, liquidationDiscount);\n\n        emit ListCurrency(currencyId);\n    }\n\n    /// @notice Enables a cash group on a given currency so that it can have lend and borrow markets. Will\n    /// also deploy an nToken contract so that markets can be initialized.\n    /// @dev emit:UpdateCashGroup emit:UpdateAssetRate emit:DeployNToken\n    /// @param currencyId id of the currency to enable\n    /// @param assetRateOracle address of the rate oracle for converting interest bearing assets to\n    /// underlying values\n    /// @param cashGroup parameters for the cash group\n    /// @param underlyingName underlying token name for seeding nToken name\n    /// @param underlyingSymbol underlying token symbol for seeding nToken symbol (i.e. nDAI)\n    function enableCashGroup(\n        uint16 currencyId,\n        address assetRateOracle,\n        CashGroupSettings calldata cashGroup,\n        string calldata underlyingName,\n        string calldata underlyingSymbol\n    ) external override onlyOwner {\n        _updateCashGroup(currencyId, cashGroup);\n        _updateAssetRate(currencyId, assetRateOracle);\n\n        // Creates the nToken erc20 proxy that routes back to the main contract\n        address nTokenAddress =\n            Create2.deploy(\n                0,\n                bytes32(uint256(currencyId)),\n                abi.encodePacked(\n                    type(nTokenERC20Proxy).creationCode,\n                    abi.encode(address(this), currencyId, underlyingName, underlyingSymbol)\n                )\n            );\n\n        nTokenHandler.setNTokenAddress(currencyId, nTokenAddress);\n        emit DeployNToken(currencyId, nTokenAddress);\n    }\n\n    /// @notice Updates the deposit parameters for an nToken\n    /// @dev emit:UpdateDepositParameters\n    /// @param currencyId the currency id that the nToken references\n    /// @param depositShares an array of values that represent the proportion of each deposit\n    /// that will go to a respective market, must add up to DEPOSIT_PERCENT_BASIS. For example,\n    /// 0.40e8, 0.40e8 and 0.20e8 will result in 40%, 40% and 20% deposited as liquidity into\n    /// the 3 month, 6 month and 1 year markets.\n    /// @param leverageThresholds an array of values denominated in RATE_PRECISION that mark the\n    /// highest proportion of fCash where the nToken will provide liquidity. Above this proportion,\n    /// the nToken will lend to the market instead to reduce the leverage in the market.\n    function updateDepositParameters(\n        uint16 currencyId,\n        uint32[] calldata depositShares,\n        uint32[] calldata leverageThresholds\n    ) external override onlyOwner {\n        nTokenHandler.setDepositParameters(currencyId, depositShares, leverageThresholds);\n        emit UpdateDepositParameters(currencyId);\n    }\n\n    /// @notice Updates the market initialization parameters for an nToken\n    /// @dev emit:UpdateInitializationParameters\n    /// @param currencyId the currency id that the nToken references\n    /// @param annualizedAnchorRates is a target interest rate that will be used to calculate a \n    /// rate anchor during initialize markets. This rate anchor will set the offset from the\n    /// x-axis where the liquidity curve will be initialized. This is used in combination with\n    /// previous market rates to determine the initial proportion where markets will be initialized\n    /// every quarter.\n    /// @param proportions used to combination with annualizedAnchorRate set the initial proportion when\n    /// a market is first initialized. This is required since there is no previous rate to reference.\n    function updateInitializationParameters(\n        uint16 currencyId,\n        uint32[] calldata annualizedAnchorRates,\n        uint32[] calldata proportions\n    ) external override onlyOwner {\n        nTokenHandler.setInitializationParameters(currencyId, annualizedAnchorRates, proportions);\n        emit UpdateInitializationParameters(currencyId);\n    }\n\n    /// @notice Updates the emission rate of incentives for a given currency\n    /// @dev emit:UpdateIncentiveEmissionRate\n    /// @param currencyId the currency id that the nToken references\n    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year\n    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be\n    /// exact due to multiplier effects and fluctuating token supply.\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate)\n        external\n        override\n        onlyOwner\n    {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0), \"Invalid currency\");\n        // Sanity check that emissions rate is not specified in 1e8 terms.\n        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, \"Invalid rate\");\n\n        nTokenHandler.setIncentiveEmissionRate(nTokenAddress, newEmissionRate);\n        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);\n    }\n\n    /// @notice Updates collateralization parameters for an nToken\n    /// @dev emit:UpdateTokenCollateralParameters\n    /// @param currencyId the currency id that the nToken references\n    /// @param residualPurchaseIncentive10BPS nTokens will have residual amounts of fCash at the end of each\n    /// quarter that are \"dead weight\" because they are at idiosyncratic maturities and do not contribute to\n    /// actively providing liquidity. This parameter will incentivize market participants to purchase these residuals\n    /// at a discount from the on chain oracle rate, denominated in 10 basis point increments. These residuals will\n    /// be added back into nToken balances and will be used to provide liquidity upon the next market initialization.\n    /// @param pvHaircutPercentage a percentage (< 100) that the present value of the nToken's assets will be valued\n    /// at for the purposes of free collateral, relevant when accounts hold nTokens as collateral against debts.\n    /// @param residualPurchaseTimeBufferHours an arbitrage opportunity is available by pushing markets in one direction\n    /// before quarterly settlement to generate large residual balances that can be purchased at a discount. The time buffer\n    /// here ensures that anyone attempting such an act would have to wait some number of hours (likely a few days) before\n    /// they could attempt to purchase residuals, ensuring that the market could realign to rates where the arbitrage is\n    /// no longer possible.\n    /// @param cashWithholdingBuffer10BPS nToken residuals may be negative fCash (debt), in this case cash is withheld to\n    /// transfer to accounts that take on the debt. This parameter denominates the discounted rate at which the cash will\n    /// be withheld at for this purpose.\n    /// @param liquidationHaircutPercentage a percentage of nToken present value (> pvHaircutPercentage and <= 100) at which\n    /// liquidators will purchase nTokens during liquidation\n    function updateTokenCollateralParameters(\n        uint16 currencyId,\n        uint8 residualPurchaseIncentive10BPS,\n        uint8 pvHaircutPercentage,\n        uint8 residualPurchaseTimeBufferHours,\n        uint8 cashWithholdingBuffer10BPS,\n        uint8 liquidationHaircutPercentage\n    ) external override onlyOwner {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0), \"Invalid currency\");\n\n        nTokenHandler.setNTokenCollateralParameters(\n            nTokenAddress,\n            residualPurchaseIncentive10BPS,\n            pvHaircutPercentage,\n            residualPurchaseTimeBufferHours,\n            cashWithholdingBuffer10BPS,\n            liquidationHaircutPercentage\n        );\n        emit UpdateTokenCollateralParameters(currencyId);\n    }\n\n    /// @notice Updates cash group parameters\n    /// @dev emit:UpdateCashGroup\n    /// @param currencyId id of the currency to enable\n    /// @param cashGroup new parameters for the cash group\n    function updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup)\n        external\n        override\n        onlyOwner\n    {\n        _updateCashGroup(currencyId, cashGroup);\n    }\n\n    /// @notice Updates asset rate oracle\n    /// @dev emit:UpdateAssetRate\n    /// @param currencyId id of the currency\n    /// @param rateOracle new rate oracle for the asset\n    function updateAssetRate(uint16 currencyId, address rateOracle) external override onlyOwner {\n        _updateAssetRate(currencyId, rateOracle);\n    }\n\n    /// @notice Updates ETH exchange rate or related parameters\n    /// @dev emit:UpdateETHRate\n    /// @param currencyId id of the currency\n    /// @param rateOracle new rate oracle for the asset\n    /// @param rateOracle ETH to underlying rate oracle\n    /// @param mustInvert if the rate from the oracle needs to be inverted\n    /// @param buffer multiplier (>= 100) for negative balances when calculating free collateral\n    /// @param haircut multiplier (<= 100) for positive balances when calculating free collateral\n    /// @param liquidationDiscount multiplier (>= 100) for exchange rate when liquidating\n    function updateETHRate(\n        uint16 currencyId,\n        address rateOracle,\n        bool mustInvert,\n        uint8 buffer,\n        uint8 haircut,\n        uint8 liquidationDiscount\n    ) external override onlyOwner {\n        _updateETHRate(currencyId, rateOracle, mustInvert, buffer, haircut, liquidationDiscount);\n    }\n\n    /// @notice Sets a global transfer operator that can do authenticated ERC1155 transfers. This enables\n    /// OTC trading or other use cases such as layer 2 authenticated transfers.\n    /// @dev emit:UpdateGlobalTransferOperator\n    /// @param operator address of the operator\n    /// @param approved true if the operator is allowed to transfer globally\n    function updateGlobalTransferOperator(address operator, bool approved)\n        external\n        override\n        onlyOwner\n    {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(operator)\n        }\n        // Sanity check to ensure that operator is a contract, not an EOA\n        require(codeSize > 0, \"Operator must be a contract\");\n\n        globalTransferOperator[operator] = approved;\n        emit UpdateGlobalTransferOperator(operator, approved);\n    }\n\n    /// @notice Approves contracts that can call `batchTradeActionWithCallback`. These contracts can\n    /// \"flash loan\" from Notional V2 and receive a callback before the free collateral check. Flash loans\n    /// via the Notional V2 liquidity pool are not very gas efficient so this is not generally available,\n    /// it can be used for migrating borrows into Notional V2 from other platforms.\n    /// @dev emit:UpdateAuthorizedCallbackContract\n    /// @param operator address of the contract\n    /// @param approved true if the contract is authorized\n    function updateAuthorizedCallbackContract(address operator, bool approved)\n        external\n        override\n        onlyOwner\n    {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(operator)\n        }\n        // Sanity check to ensure that operator is a contract, not an EOA\n        require(codeSize > 0, \"Operator must be a contract\");\n\n        authorizedCallbackContract[operator] = approved;\n        emit UpdateAuthorizedCallbackContract(operator, approved);\n    }\n\n    function _updateCashGroup(uint256 currencyId, CashGroupSettings calldata cashGroup) internal {\n        require(currencyId != 0, \"G: invalid currency id\");\n        require(currencyId <= maxCurrencyId, \"G: invalid currency id\");\n\n        CashGroup.setCashGroupStorage(currencyId, cashGroup);\n\n        emit UpdateCashGroup(uint16(currencyId));\n    }\n\n    function _updateAssetRate(uint256 currencyId, address rateOracle) internal {\n        require(currencyId != 0, \"G: invalid currency id\");\n        require(currencyId <= maxCurrencyId, \"G: invalid currency id\");\n\n        // If rate oracle refers to address zero then do not apply any updates here, this means\n        // that a token is non mintable.\n        Token memory assetToken = TokenHandler.getToken(currencyId, false);\n        if (rateOracle == address(0)) {\n            // Sanity check that unset rate oracles are only for non mintable tokens\n            require(assetToken.tokenType == TokenType.NonMintable, \"G: invalid asset rate\");\n            return;\n        }\n\n        // Sanity check that the rate oracle refers to the proper asset token\n        address token = AssetRateAdapter(rateOracle).token();\n        require(assetToken.tokenAddress == token, \"G: invalid rate oracle\");\n\n        uint8 underlyingDecimals;\n        if (currencyId == 1) {\n            // If currencyId is one then this is referring to cETH and there is no underlying() to call\n            underlyingDecimals = 18;\n        } else {\n            address underlyingToken = AssetRateAdapter(rateOracle).underlying();\n            underlyingDecimals = ERC20(underlyingToken).decimals();\n        }\n\n        assetToUnderlyingRateMapping[currencyId] = AssetRateStorage({\n            rateOracle: rateOracle,\n            underlyingDecimalPlaces: underlyingDecimals\n        });\n\n        emit UpdateAssetRate(uint16(currencyId));\n    }\n\n    function _updateETHRate(\n        uint256 currencyId,\n        address rateOracle,\n        bool mustInvert,\n        uint8 buffer,\n        uint8 haircut,\n        uint8 liquidationDiscount\n    ) internal {\n        require(currencyId != 0, \"G: invalid currency id\");\n        require(currencyId <= maxCurrencyId, \"G: invalid currency id\");\n\n        uint8 rateDecimalPlaces;\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\n            // ETH to ETH exchange rate is fixed at 1 and has no rate oracle\n            rateOracle = address(0);\n            rateDecimalPlaces = 18;\n        } else {\n            require(rateOracle != address(0), \"G: zero rate oracle address\");\n            rateDecimalPlaces = AggregatorV2V3Interface(rateOracle).decimals();\n        }\n        require(buffer >= Constants.PERCENTAGE_DECIMALS, \"G: buffer must be gte decimals\");\n        require(haircut <= Constants.PERCENTAGE_DECIMALS, \"G: buffer must be lte decimals\");\n        require(\n            liquidationDiscount > Constants.PERCENTAGE_DECIMALS,\n            \"G: discount must be gt decimals\"\n        );\n\n        underlyingToETHRateMapping[currencyId] = ETHRateStorage({\n            rateOracle: rateOracle,\n            rateDecimalPlaces: rateDecimalPlaces,\n            mustInvert: mustInvert,\n            buffer: buffer,\n            haircut: haircut,\n            liquidationDiscount: liquidationDiscount\n        });\n\n        emit UpdateETHRate(uint16(currencyId));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Constants.sol\";\nimport \"../proxy/utils/UUPSUpgradeable.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\n\n/**\n * Read only version of the Router that can only be upgraded by governance. Used in emergency when the system must\n * be paused for some reason.\n */\ncontract PauseRouter is StorageLayoutV1, UUPSUpgradeable {\n    address public immutable VIEWS;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n\n    constructor(\n        address views_,\n        address liquidateCurrency_,\n        address liquidatefCash_\n    ) {\n        VIEWS = views_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override {\n        // This is only true during a rollback check when the pause router is downgraded\n        bool isRollbackCheck = rollbackRouterImplementation != address(0) &&\n            newImplementation == rollbackRouterImplementation;\n\n        require(\n            owner == msg.sender || (msg.sender == pauseGuardian && isRollbackCheck),\n            \"Unauthorized upgrade\"\n        );\n\n        // Clear this storage slot so the guardian cannot upgrade back to the previous router,\n        // requires governance to do so.\n        rollbackRouterImplementation = address(0);\n    }\n\n    function getLiquidationEnabledState() external view returns (bytes1) {\n        return liquidationEnabledState;\n    }\n\n    function setLiquidationEnabledState(bytes1 liquidationEnabledState_) external {\n        // Only authorized addresses can set the liquidation state\n        require(owner == msg.sender || msg.sender == pauseGuardian);\n        liquidationEnabledState = liquidationEnabledState_;\n    }\n\n    function isEnabled(bytes1 state) private view returns (bool) {\n        return (liquidationEnabledState & state == state);\n    }\n\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        // Liquidation calculation methods are stateful (they settle accounts if required)\n        // and therefore we prevent them from being called unless specifically authorized.\n        if (\n            (sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateCollateralCurrency.selector) &&\n            isEnabled(Constants.COLLATERAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateLocalCurrency.selector) &&\n            isEnabled(Constants.LOCAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashLocal.selector ||\n                sig == NotionalProxy.calculatefCashLocalLiquidation.selector) &&\n            isEnabled(Constants.LOCAL_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n                sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector) &&\n            isEnabled(Constants.CROSS_CURRENCY_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n}\n\n\n",
        "CodeNames": [
            "Router.sol",
            "GovernorAlpha.sol",
            "GovernanceAction.sol",
            "UUPSUpgradeable.sol",
            "PauseRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "_authorizeUpgrade",
                    "upgradeToAndCall()",
                    "onlyOwner",
                    "NoteERC",
                    "initialize()"
                ],
                "Type": " Potential DOS in Contracts Inheriting  UUPSUpgradeable.sol ",
                "Description": "\nThere are a number of contracts which inherit UUPSUpgradeable.sol, namely; GovernanceAction.sol, PauseRouter.sol and NoteERC20.sol.\n\nAll these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract.\n\nHowever, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the onlyOwner role in the implementation contract for NoteERC20.sol. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all NoteERC20.sol interactions until a new implementation contract is deployed.\n\nInitial information about this issue was found here(https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).\n\nConsider the following scenario:\nNotional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is NoteERC20.sol.\nThis allows any arbitrary user to call initialize() on the NoteERC20.sol implementation contract.\nOnce a user has gained control over NoteERC20.sol's implementation contract, they can bypass the _authorizeUpgrade check used to restrict upgrades to the onlyOwner role.\nThe malicious user then calls UUPSUpgradeable.upgradeToAndCall() shown here(https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls this(https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function.\nAs a result, the implementation contract will be self-destructed due to the user-controlled delegate call shown here(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the NoteERC20.sol proxy contract until a new implementation contract has been deployed.\n\n",
                "Repair": "Recommend considering initializing the implementation contract for NoteERC20.sol and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.\n\njeffywu (Notional) acknowledged and disagreed with severity(https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917410089):\n  Acknowledged, I don't think this should be categorized high risk because the worst case is a denial of service and a redeployment of the ERC20 contract. As it stands, we've already successfully deployed our ERC20 contract so this is a non-issue.\n\n I would categorize as 0 (Non-critical)\n\nadamavenir (organizer) commented(https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917415717):\n  Warden leastwood added this proof of concept to illustrate the vulnerability https://gist.github.com/leastwood/b23d9e975883c817780116c2ceb785b8\n\njeffywu (Notional) commented(https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917416175):\n  Ok I retract my previous statement, I misread the issue description. Up to you guys but do you want to pay out a full amount to someone who is reporting issues discovered elsewhere? OZ has already called initialize on our deployed contract for us.\n\nadamavenir (organizer) commented(https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917706252):\n  @jeffywu (Notional) I think the question is whether the issue is valid based on the original code base. Given your initial response and change after his proof of concept, my read was there was value here in what he reported. Is that a correct understanding?\n\njeffywu (Notional) commented(https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917706960):\n  There was value added here but perhaps not at the same level as the other high risk issues.\n\nadamavenir (organizer) commented(https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917744246):\n  @jeffywu (Notional) Thanks for the input. As per our rules, awards are determined strictly based on the judge's assessment of the validity and severity, so we'll see how our judge chooses to score this.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"../markets/CashGroup.sol\";\nimport \"../markets/AssetRate.sol\";\nimport \"../portfolio/PortfolioHandler.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../math/ABDKMath64x64.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary AssetHandler {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using CashGroup for CashGroupParameters;\n    using AssetRate for AssetRateParameters;\n\n    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\n        return\n            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\n    }\n\n    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method\n    /// calculates the settlement date for any PortfolioAsset.\n    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\n        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type\n        // 3 month tokens and fCash tokens settle at maturity\n        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\n\n        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\n        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:\n        // maturity = tRef + marketLength\n        // Here we calculate:\n        // tRef = maturity - marketLength + 90 days\n        return asset.maturity.sub(marketLength).add(Constants.QUARTER);\n    }\n\n    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.\n    /// The formula is: notional * e^(-rate * timeToMaturity).\n    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)\n        internal\n        pure\n        returns (int256)\n    {\n        int128 expValue =\n            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));\n        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\n        expValue = ABDKMath64x64.exp(expValue * -1);\n        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);\n        int256 discountFactor = ABDKMath64x64.toInt(expValue);\n\n        return discountFactor;\n    }\n\n    /// @notice Present value of an fCash asset without any risk adjustments.\n    function getPresentValue(\n        int256 notional,\n        uint256 maturity,\n        uint256 blockTime,\n        uint256 oracleRate\n    ) internal pure returns (int256) {\n        if (notional == 0) return 0;\n\n        uint256 timeToMaturity = maturity.sub(blockTime);\n        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);\n\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor\n        return notional.mulInRatePrecision(discountFactor);\n    }\n\n    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more\n    /// heavily than the oracle rate given and vice versa for negative fCash.\n    function getRiskAdjustedPresentValue(\n        CashGroupParameters memory cashGroup,\n        int256 notional,\n        uint256 maturity,\n        uint256 blockTime,\n        uint256 oracleRate\n    ) internal pure returns (int256) {\n        if (notional == 0) return 0;\n        uint256 timeToMaturity = maturity.sub(blockTime);\n\n        int256 discountFactor;\n        if (notional > 0) {\n            discountFactor = getDiscountFactor(\n                timeToMaturity,\n                oracleRate.add(cashGroup.getfCashHaircut())\n            );\n        } else {\n            uint256 debtBuffer = cashGroup.getDebtBuffer();\n            // If the adjustment exceeds the oracle rate we floor the value of the fCash\n            // at the notional value. We don't want to require the account to hold more than\n            // absolutely required.\n            if (debtBuffer >= oracleRate) return notional;\n\n            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);\n        }\n\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor\n        return notional.mulInRatePrecision(discountFactor);\n    }\n\n    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.\n    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\n        internal\n        pure\n        returns (int256 assetCash, int256 fCash)\n    {\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims\n\n        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\n        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\n    }\n\n    /// @notice Returns the haircut claims on cash and fCash\n    /// @return (assetCash, fCash)\n    function getHaircutCashClaims(\n        PortfolioAsset memory token,\n        MarketParameters memory market,\n        CashGroupParameters memory cashGroup\n    ) internal pure returns (int256, int256) {\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset get haircut cash claims\n\n        require(token.currencyId == cashGroup.currencyId); // dev: haircut cash claims, currency id mismatch\n        // This won't overflow, the liquidity token haircut is stored as an uint8\n        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\n\n        int256 assetCash =\n            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\n\n        int256 fCash =\n            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\n\n        return (assetCash, fCash);\n    }\n\n    /// @dev This is here to clean up the stack in getHaircutCashClaims\n    function _calcToken(\n        int256 numerator,\n        int256 tokens,\n        int256 haircut,\n        int256 liquidity\n    ) private pure returns (int256) {\n        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);\n    }\n\n    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\n    function getLiquidityTokenValue(\n        uint256 index,\n        CashGroupParameters memory cashGroup,\n        MarketParameters memory market,\n        PortfolioAsset[] memory assets,\n        uint256 blockTime,\n        bool riskAdjusted\n    ) internal view returns (int256, int256) {\n        PortfolioAsset memory liquidityToken = assets[index];\n        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); // dev: get liquidity token value, not liquidity token\n\n        {\n            (uint256 marketIndex, bool idiosyncratic) =\n                DateTime.getMarketIndex(\n                    cashGroup.maxMarketIndex,\n                    liquidityToken.maturity,\n                    blockTime\n                );\n            // Liquidity tokens can never be idiosyncratic\n            require(!idiosyncratic); // dev: idiosyncratic liquidity token\n\n            // This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.\n            cashGroup.loadMarket(market, marketIndex, true, blockTime);\n        }\n\n        int256 assetCashClaim;\n        int256 fCashClaim;\n        if (riskAdjusted) {\n            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\n        } else {\n            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\n        }\n\n        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and\n        // in that case we know the previous asset will be the matching fCash asset\n        if (\n            index > 0 &&\n            assets[index - 1].currencyId == liquidityToken.currencyId &&\n            assets[index - 1].maturity == liquidityToken.maturity &&\n            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE\n        ) {\n            // Net off the fCashClaim here and we will discount it to present value in the second pass.\n            // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!\n            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);\n            return (assetCashClaim, 0);\n        }\n\n        // If not matching fCash asset found then get the pv directly\n        if (riskAdjusted) {\n            int256 pv =\n                getRiskAdjustedPresentValue(\n                    cashGroup,\n                    fCashClaim,\n                    liquidityToken.maturity,\n                    blockTime,\n                    market.oracleRate\n                );\n\n            return (assetCashClaim, pv);\n        } else {\n            int256 pv =\n                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\n\n            return (assetCashClaim, pv);\n        }\n    }\n\n    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\n    function getNetCashGroupValue(\n        PortfolioAsset[] memory assets,\n        CashGroupParameters memory cashGroup,\n        MarketParameters memory market,\n        uint256 blockTime,\n        uint256 portfolioIndex\n    ) internal view returns (int256, uint256) {\n        int256 presentValueAsset;\n        int256 presentValueUnderlying;\n\n        // First calculate value of liquidity tokens because we need to net off fCash value\n        // before discounting to present value\n        for (uint256 i = portfolioIndex; i < assets.length; i++) {\n            if (!isLiquidityToken(assets[i].assetType)) continue;\n            if (assets[i].currencyId != cashGroup.currencyId) break;\n\n            (int256 assetCashClaim, int256 pv) =\n                getLiquidityTokenValue(\n                    i,\n                    cashGroup,\n                    market,\n                    assets,\n                    blockTime,\n                    true // risk adjusted\n                );\n\n            presentValueAsset = presentValueAsset.add(assetCashClaim);\n            presentValueUnderlying = presentValueUnderlying.add(pv);\n        }\n\n        uint256 j = portfolioIndex;\n        for (; j < assets.length; j++) {\n            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;\n            // If we hit a different currency id then we've accounted for all assets in this currency\n            if (assets[j].currencyId != cashGroup.currencyId) break;\n\n            uint256 maturity = assets[j].maturity;\n            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\n\n            int256 pv =\n                getRiskAdjustedPresentValue(\n                    cashGroup,\n                    assets[j].notional,\n                    maturity,\n                    blockTime,\n                    oracleRate\n                );\n            presentValueUnderlying = presentValueUnderlying.add(pv);\n        }\n\n        presentValueAsset = presentValueAsset.add(\n            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)\n        );\n\n        return (presentValueAsset, j);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../internal/AccountContextHandler.sol\";\nimport \"../internal/valuation/FreeCollateral.sol\";\n\n/// @title Externally deployed library for free collateral calculations\nlibrary FreeCollateralExternal {\n    using AccountContextHandler for AccountContext;\n\n    /// @notice Returns the ETH denominated free collateral of an account, represents the amount of\n    /// debt that the account can incur before liquidation.\n    /// @dev Called via the Views.sol method to return an account's free collateral. Does not work\n    /// for the nToken\n    /// @param account account to calculate free collateral for\n    /// @return\n    ///     - total free collateral in ETH w/ 8 decimal places\n    ///     - array of net local values in asset values ordered\n    function getFreeCollateralView(address account)\n        external\n        view\n        returns (int256, int256[] memory)\n    {\n        uint256 blockTime = block.timestamp;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        return FreeCollateral.getFreeCollateralView(account, accountContext, blockTime);\n    }\n\n    /// @notice Calculates free collateral and will revert if it falls below zero. If the account context\n    /// must be updated due to changes in debt settings, will update\n    /// @param account account to calculate free collateral for\n    function checkFreeCollateralAndRevert(address account) external {\n        uint256 blockTime = block.timestamp;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n\n        (int256 ethDenominatedFC, bool updateContext) =\n            FreeCollateral.getFreeCollateralStateful(account, accountContext, blockTime);\n\n        if (updateContext) {\n            accountContext.setAccountContext(account);\n        }\n\n        require(ethDenominatedFC >= 0, \"Insufficient free collateral\");\n    }\n\n    /// @notice Calculates liquidation factors for an account\n    /// @param account account to liquidate\n    /// @param localCurrencyId currency that the debts are denominated in\n    /// @param collateralCurrencyId collateral currency to liquidate against, set to zero in the case of local currency liquidation\n    function getLiquidationFactors(\n        address account,\n        uint256 localCurrencyId,\n        uint256 collateralCurrencyId\n    )\n        external\n        returns (\n            AccountContext memory accountContext,\n            LiquidationFactors memory factors,\n            PortfolioAsset[] memory portfolio\n        )\n    {\n        accountContext = AccountContextHandler.getAccountContext(account);\n\n        if (accountContext.mustSettleAssets()) {\n            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);\n        }\n\n        (factors, portfolio) = FreeCollateral.getLiquidationFactors(\n            account,\n            accountContext,\n            block.timestamp,\n            localCurrencyId,\n            collateralCurrencyId\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "AssetHandler.sol",
            "FreeCollateralExternal.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "//solidity\n// @audit token.notional are the LP tokens to redeem\nassetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\nfCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\n"
                ],
                "Type": " Liquidity token value can be manipulated",
                "Description": "\nThe liquidity token value (AssetHandler.getLiquidityTokenValue) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash.\nThe amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see AssetHandler.getCashClaims / AssetHandler.getHaircutCashClaims:\n\nsolidity\n// @audit token.notional are the LP tokens to redeem\nassetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\nfCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\n\n\nThis means the value depends on the current market reserves which can be manipulated.\nYou're essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.\n\nSee the \"How do I tell if I\u2019m using spot price?\" section here(https://shouldiusespotpriceasmyoracle.com/).\n However, by doing this you\u2019re actually incorporating the spot price because you\u2019re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this footgun(https://cmichel.io/pricing-lp-tokens/) in this writeup by @cmichelio.\n\nThe value of an LP token is computed as assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) ), where (assetCashClaim, fCashClaim) depends on the current market reserves which can be manipulated by an attacker via flashloans.\nTherefore, an attacker trading large amounts in the market can either increase or decrease the value of an LP token.\n\nIf the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens.\nIf the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.\n\nThe exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage.\nIn constant-product AMMs like Uniswap it's profitable and several projects have already been exploited by this, like warp.finance(https://cmichel.io/pricing-lp-tokens/).\nHowever, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles:\n \"Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated.\" Market.sol L424\n\n",
                "Repair": "Recommend not using the current market reserves to determine the value of LP tokens. Also, think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.\n\nT-Woodward (Notional) confirmed and disagreed with severity (https://github.com/code-423n4/2021-08-notional-findings/issues/85#issuecomment-917422519):\n  It is true that a flash loan could be used to manipulate the value of a liquidity token\u2019s cash and fCash claims. This issue can potentially cause accounts to be liquidated which shouldn\u2019t be, but not for the reasons stated in this issue. I\u2019ll explain what actually can go wrong, and why the fix is simple and non-invasive.\n\n First, to restate the issue: The manipulator could borrow or lend a large amount to a liquidity pool, which would change the amount of cash and fCash sitting in that pool and the corresponding cash and fCash claims of a liquidity token associated with that pool. This could change the liquidity token\u2019s net value within the space of a transaction despite the fact that the oracleRate used to value fCash is lagged and manipulation resistant.\n\n But it is not true that this manipulation could decrease the value of a liquidity token in fact it could only increase a liquidity token\u2019s value. By borrowing or lending a large amount using a flash loan, the interest rate that the attacker would receive would deviate from the oracleRate in favor of the liquidity provider. If the attacker executed a large lend order, the interest rate on the loan would be significantly below the oracleRate. This would mean that the liquidity providers had borrowed at a below-market rate and that the net value of that trade would be positive for them. Conversely if the attacker executed a large borrow order, the interest rate on the loan would be significantly above the oracleRate. Again, this would mean that the net value of that trade would be positive for the liquidity providers because they would effectively be lending at an above-market rate. In either case, the value of the liquidity token would increase, not decrease.\n\n However, even though the value of a liquidity token could only increase during such an attack, the collateral value of the liquidity token could decrease once the haircuts were applied in the free collateral calculation. The reason for this is that fCash claims are effectively double-haircut (once by the liquidity token haircut and once by the fCash haircut), whereas cash claims are only haircut once (by the liquidity token haircut). This means that even though the attack would increase the value of the liquidity token without haircuts, once you consider the haircuts applied in the free collateral calculation, the collateral value of the liquidity token can be decreased and accounts could become undercollateralized and eligible for liquidation.\n\n Remediation:\n The immediate remediation for this issue is to restrict providing liquidity to the nToken account exclusively. In the longer term, we will plan to add TWAPs to determine the collateral value of liquidity token cash and fCash claims. This immediate remediation will be fine for now though, and will not degrade the system for two reasons:\n\n 1. The team does not anticipate users providing liquidity directly outside of the nToken (we don\u2019t even offer a way to do it within the UI for example). Only nToken holders receive NOTE incentives, not direct liquidity providers.\n\n 2. The nToken accounts are safe from this attack because the maximum amount that an attacker could temporarily decrease the collateral value of liquidity tokens could never be enough to cause the nToken accounts to become undercollateralized, and therefore they would never be at risk of liquidation due to this attack. The TLDR here is that this attack can\u2019t actually decrease the collateral value of liquidity tokens all that much, and so for an account to be vulnerable they would have to be running quite close to minimum collateralization. This will never happen for the nToken because it doesn\u2019t borrow, it just provides liquidity and always maintains very healthy collateralization levels.\n\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-08-notional-findings/issues/85#issuecomment-922395545):\n  Again, I gave it some thought and I think that this is high risk. Keeping as is.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/compound/CEtherInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    currencyId,\n                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))\n                )\n            );\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {\n        bytes32 slot = _getSlot(currencyId, underlying);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n        address tokenAddress = address(bytes20(data << 96));\n        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;\n        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));\n        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));\n\n        return\n            Token({\n                tokenAddress: tokenAddress,\n                hasTransferFee: tokenHasTransferFee,\n                decimals: int256(10**tokenDecimalPlaces),\n                tokenType: tokenType\n            });\n    }\n\n    /// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }\n\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        uint256 success;\n        if (token.tokenType == TokenType.cToken) {\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\n        } else if (token.tokenType == TokenType.cETH) {\n            // Reverts on error\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\n        } else {\n            revert(); // dev: non mintable token\n        }\n\n        require(success == 0, \"Mint fail\");\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        // This is the starting and ending balance in external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    function redeem(\n        Token memory assetToken,\n        Token memory underlyingToken,\n        uint256 assetAmountExternal\n    ) internal returns (int256) {\n        uint256 startingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            startingBalance = address(this).balance;\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        } else {\n            revert(); // dev: non redeemable failure\n        }\n\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\n        require(success == 0, \"Redeem fail\");\n\n        uint256 endingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            endingBalance = address(this).balance;\n        } else {\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        }\n\n        // Underlying token external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\n    /// precision.\n    function transfer(\n        Token memory token,\n        address account,\n        int256 netTransferExternal\n    ) internal returns (int256) {\n        if (netTransferExternal > 0) {\n            // Deposits must account for transfer fees.\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\n        } else if (token.tokenType == TokenType.Ether) {\n            require(netTransferExternal < 0); // dev: cannot transfer ether\n            address payable accountPayable = payable(account);\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\n        } else {\n            safeTransferOut(\n                IERC20(token.tokenAddress),\n                account,\n                uint256(netTransferExternal.neg())\n            );\n        }\n\n        return netTransferExternal;\n    }\n\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\n    /// precision.\n    function _deposit(\n        Token memory token,\n        address account,\n        uint256 amount\n    ) private returns (int256) {\n        if (token.hasTransferFee) {\n            // Must deposit from the token and calculate the net transfer\n            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n            safeTransferIn(IERC20(token.tokenAddress), account, amount);\n            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n            return int256(endingBalance.sub(startingBalance));\n        }\n\n        safeTransferIn(IERC20(token.tokenAddress), account, amount);\n        return int256(amount);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);\n    }\n\n    function safeTransferOut(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transfer(account, amount);\n        checkReturnCode();\n    }\n\n    function safeTransferIn(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transferFrom(account, address(this), amount);\n        checkReturnCode();\n    }\n\n    function checkReturnCode() private pure {\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {\n                    // This is a non-standard ERC-20\n                    success := not(0) // set success to true\n                }\n                case 32 {\n                    // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0) // Set `success = returndata` of external call\n                }\n                default {\n                    // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        require(success, \"Transfer Failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "TokenHandler.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [],
                "Type": " TokenHandler.sol, L174 -  .transfer  is bad practice",
                "Description": "\nThe use of .transfer in TokenHandler.sol L174(https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L174) to send ether is now considered bad practice as gas costs can change which would break the code.\n\nSee stop using soliditys transfer now(https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/), and istanbul hardfork eips increasing gas costs and more(https://chainsecurity.com/istanbul-hardfork-eips-increasing-gas-costs-and-more/).\n\n",
                "Repair": "Recommend using call instead, and make sure to check for reentrancy.\n\njeffywu (Notional) commented(https://github.com/code-423n4/2021-08-notional-findings/issues/38#issuecomment-917446532):\n  This should be 0 (Non critical). ETH transfers still work as of today. This is a best practice recommendation. In the case that there is a hard fork that breaks ETH transfers the protocol can be upgraded to support the use of call()\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-08-notional-findings/issues/38#issuecomment-920428460):\n  I aline with warden on this one. .transfer will not work if the account is a smart contract. Keeping as is.\n\n_EDITORS NOTE: Additional conversation regarding this vulnerability can be found here(https://github.com/code-423n4/2021-08-notional-findings/issues/38)_\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../balances/TokenHandler.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\nlibrary ExchangeRate {\n    using SafeInt256 for int256;\n\n    uint256 private constant ETH_RATE_STORAGE_SLOT = 1;\n\n    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are\n    /// always applied in this method.\n    /// @param er exchange rate object from base to ETH\n    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION\n    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {\n        if (balance == 0) return 0;\n        int256 multiplier = balance > 0 ? er.haircut : er.buffer;\n\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\n        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)\n        // Therefore the result is in ethDecimals\n        int256 result =\n            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(\n                er.rateDecimals\n            );\n\n        return result;\n    }\n\n    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.\n    /// Buffers and haircuts ARE NOT applied in this method.\n    /// @param er exchange rate object from base to ETH\n    /// @param balance amount (denominated in ETH) to convert\n    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {\n        if (balance == 0) return 0;\n\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\n        // internalDecimals * rateDecimals / rateDecimals\n        int256 result = balance.mul(er.rateDecimals).div(er.rate);\n\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in\n    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals\n    /// @param baseER base exchange rate struct\n    /// @param quoteER quote exchange rate struct\n    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)\n        internal\n        pure\n        returns (int256)\n    {\n        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);\n    }\n\n    /// @notice Returns an ETHRate object used to calculate free collateral\n    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {\n        bytes32 slot = keccak256(abi.encode(currencyId, ETH_RATE_STORAGE_SLOT));\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        int256 rateDecimals;\n        int256 rate;\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\n            // ETH rates will just be 1e18, but will still have buffers, haircuts,\n            // and liquidation discounts\n            rateDecimals = Constants.ETH_DECIMALS;\n            rate = Constants.ETH_DECIMALS;\n        } else {\n            address rateOracle = address(bytes20(data << 96));\n            // prettier-ignore\n            (\n                /* uint80 */,\n                rate,\n                /* uint256 */,\n                /* uint256 */,\n                /* uint80 */\n            ) = AggregatorV2V3Interface(rateOracle).latestRoundData();\n            require(rate > 0, \"ExchangeRate: invalid rate\");\n\n            uint8 rateDecimalPlaces = uint8(bytes1(data << 88));\n            rateDecimals = int256(10**rateDecimalPlaces);\n            if (\n                bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */\n            ) {\n                rate = rateDecimals.mul(rateDecimals).div(rate);\n            }\n        }\n\n        int256 buffer = int256(uint8(bytes1(data << 72)));\n        int256 haircut = int256(uint8(bytes1(data << 64)));\n        int256 liquidationDiscount = int256(uint8(bytes1(data << 56)));\n        return\n            ETHRate({\n                rateDecimals: rateDecimals,\n                rate: rate,\n                buffer: buffer,\n                haircut: haircut,\n                liquidationDiscount: liquidationDiscount\n            });\n    }\n}\n\n\n",
        "CodeNames": [
            "ExchangeRate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [],
                "Type": "  .latestRoundData()  does not update the oracle -  ExchangeRate.sol ",
                "Description": "\nThe method .latestRoundData() on an oracle returns the latest updated price from the oracle, but this is not the current price of an asset. To get an accurate current price you need to query it by calling the oracle and waiting for a callback to fulfill the request.\n\nInaccurate price data could quickly lead to a large loss of funds. Suppose the price of an asset changes downward 5% but your oracle is not updated. A user could deposit funds (credited with an extra 5% since the oracle isn't updated), wait until .latestRoundData() updates (or update it himself) and becomes accurate. He then withdraws to the same asset he put in for an extra 5%. ExchangeRate.sol L84(https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/valuation/ExchangeRate.sol#L84)\n\n",
                "Repair": "Recommend not fetching the latest price (having to call the oracle to update the price instead), and then waiting for the callback.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../internal/nTokenHandler.sol\";\nimport \"../../internal/markets/AssetRate.sol\";\nimport \"../../internal/balances/BalanceHandler.sol\";\nimport \"../../internal/balances/Incentives.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"interfaces/notional/nTokenERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract nTokenAction is StorageLayoutV1, nTokenERC20 {\n    using BalanceHandler for BalanceState;\n    using AssetRate for AssetRateParameters;\n    using AccountContextHandler for AccountContext;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    /// @notice Total number of tokens in circulation\n    /// @param nTokenAddress The address of the nToken\n    /// @return totalSupply number of tokens held\n    function nTokenTotalSupply(address nTokenAddress)\n        external\n        view\n        override\n        returns (uint256 totalSupply)\n    {\n        // prettier-ignore\n        (\n            totalSupply,\n            /* integralTotalSupply */,\n            /* lastSupplyChangeTime */\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function nTokenBalanceOf(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // prettier-ignore\n        (\n            /* int cashBalance */,\n            int256 nTokenBalance,\n            /* uint lastClaimTime */,\n            /* uint lastClaimIntegralSupply */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n\n        require(nTokenBalance >= 0); // dev: negative nToken balance\n        return uint256(nTokenBalance);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param owner The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function nTokenTransferAllowance(\n        uint16 currencyId,\n        address owner,\n        address spender\n    ) external view override returns (uint256) {\n        // This whitelist allowance supersedes any specific allowances\n        uint256 allowance = nTokenWhitelist[owner][spender];\n        if (allowance > 0) return allowance;\n\n        return nTokenAllowance[owner][spender][currencyId];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev Can only be called via the nToken proxy\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApprove(\n        uint16 currencyId,\n        address owner,\n        address spender,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        nTokenAllowance[owner][spender][currencyId] = amount;\n\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param from The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransfer(\n        uint16 currencyId,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        return _transfer(currencyId, from, to, amount);\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param currencyId Currency id of the nToken\n    /// @param spender The address of the original caller\n    /// @param from The address of the source account\n    /// @param to The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransferFrom(\n        uint16 currencyId,\n        address spender,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool, uint256) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        uint256 allowance = nTokenWhitelist[from][spender];\n\n        if (allowance > 0) {\n            // This whitelist allowance supersedes any specific allowances\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenWhitelist[from][spender] = allowance;\n        } else {\n            // This is the specific allowance for the nToken.\n            allowance = nTokenAllowance[from][spender][currencyId];\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenAllowance[from][spender][currencyId] = allowance;\n        }\n\n        bool success = _transfer(currencyId, from, to, amount);\n        return (success, allowance);\n    }\n\n    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve\n    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly\n    /// on the Notional contract, not available via the ERC20 proxy.\n    /// @dev emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApproveAll(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        nTokenWhitelist[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender\n    /// @dev auth:msg.sender\n    /// @return Total amount of incentives claimed\n    function nTokenClaimIncentives() external override returns (uint256) {\n        address account = msg.sender;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        uint256 totalIncentivesClaimed;\n        BalanceState memory balanceState;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n\n            currencies = currencies << 16;\n        }\n\n        // NOTE: no need to set account context after claiming incentives\n        return totalIncentivesClaimed;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in asset tokens\n    function nTokenPresentValueAssetDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* portfolio */\n        ) = _getNTokenPV(currencyId);\n\n        return totalAssetPV;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in underlying\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);\n\n        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);\n    }\n\n    function _getNTokenPV(uint256 currencyId)\n        private\n        view\n        returns (int256, nTokenPortfolio memory)\n    {\n        uint256 blockTime = block.timestamp;\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* ifCashMapping */\n        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);\n\n        return (totalAssetPV, nToken);\n    }\n\n    /// @notice Transferring tokens will also claim incentives at the same time\n    function _transfer(\n        uint256 currencyId,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        {\n            // prettier-ignore\n            (\n                uint256 isNToken,\n                /* incentiveAnnualEmissionRate */,\n                /* lastInitializedTime */,\n                /* parameters */\n            ) = nTokenHandler.getNTokenContext(recipient);\n            // nTokens cannot hold nToken balances\n            require(isNToken == 0, \"Cannot transfer to nToken\");\n        }\n\n        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);\n        BalanceState memory senderBalance;\n        senderBalance.loadBalanceState(sender, currencyId, senderContext);\n\n        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);\n        BalanceState memory recipientBalance;\n        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);\n\n        int256 amountInt = SafeCast.toInt256(amount);\n        senderBalance.netNTokenTransfer = amountInt.neg();\n        recipientBalance.netNTokenTransfer = amountInt;\n\n        senderBalance.finalize(sender, senderContext, false);\n        recipientBalance.finalize(recipient, recipientContext, false);\n        senderContext.setAccountContext(sender);\n        recipientContext.setAccountContext(recipient);\n\n        emit Transfer(sender, recipient, amount);\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        // borrow on notional via special flash loan facility\n        //  - borrow repayment amount\n        //  - withdraw to wallet, redeem to underlying\n        // receive callback (tokens transferred to borrowing account)\n        //   -> inside callback\n        //   -> repayBorrowBehalf(account, repayAmount)\n        //   -> deposit cToken to notional (account needs to have set approvals)\n        //   -> exit callback\n        // inside original borrow, check FC\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }\n\n    receive() external payable {\n        // This contract cannot migrate ETH loans because there is no way\n        // to do transferFrom on ETH\n        revert(\"Cannot transfer ETH\");\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./actions/nTokenAction.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"./actions/nTokenRedeemAction.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\n\n/**\n * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage\n * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing\n * contracts.\n *\n * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also\n * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a\n * new Router with the new hardcoded addresses will then be deployed and upgraded into place.\n */\ncontract Router is StorageLayoutV1 {\n    // These contract addresses cannot be changed once set by the constructor\n    address public immutable GOVERNANCE;\n    address public immutable VIEWS;\n    address public immutable INITIALIZE_MARKET;\n    address public immutable NTOKEN_ACTIONS;\n    address public immutable NTOKEN_REDEEM;\n    address public immutable BATCH_ACTION;\n    address public immutable ACCOUNT_ACTION;\n    address public immutable ERC1155;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n    address public immutable cETH;\n\n    constructor(\n        address governance_,\n        address views_,\n        address initializeMarket_,\n        address nTokenActions_,\n        address nTokenRedeem_,\n        address batchAction_,\n        address accountAction_,\n        address erc1155_,\n        address liquidateCurrency_,\n        address liquidatefCash_,\n        address cETH_\n    ) {\n        GOVERNANCE = governance_;\n        VIEWS = views_;\n        INITIALIZE_MARKET = initializeMarket_;\n        NTOKEN_ACTIONS = nTokenActions_;\n        NTOKEN_REDEEM = nTokenRedeem_;\n        BATCH_ACTION = batchAction_;\n        ACCOUNT_ACTION = accountAction_;\n        ERC1155 = erc1155_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n        cETH = cETH_;\n    }\n\n    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\n        // Cannot re-initialize once the contract has been initialized, ownership transfer does not\n        // allow address to be set back to zero\n        require(owner == address(0), \"R: already initialized\");\n\n        // Allow list currency to be called by this contract for the purposes of\n        // initializing ETH as a currency\n        owner = msg.sender;\n        // List ETH as currency id == 1, NOTE: return value is ignored here\n        (bool status, ) =\n            address(GOVERNANCE).delegatecall(\n                abi.encodeWithSelector(\n                    NotionalGovernance.listCurrency.selector,\n                    TokenStorage(cETH, false, TokenType.cETH),\n                    // No underlying set for cETH\n                    TokenStorage(address(0), false, TokenType.Ether),\n                    address(0),\n                    false,\n                    130, // Initial settings of 130 buffer\n                    70,  // 70% haircut\n                    105  // 105 liquidation discount\n                )\n            );\n        require(status);\n\n        owner = owner_;\n        // The pause guardian may downgrade the router to the pauseRouter\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n    }\n\n    /// @notice Returns the implementation contract for the method signature\n    /// @param sig method signature to call\n    /// @return implementation address\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        if (\n            sig == NotionalProxy.batchBalanceAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector\n        ) {\n            return BATCH_ACTION;\n        }\n\n        if (\n            sig == nTokenAction.nTokenTotalSupply.selector ||\n            sig == nTokenAction.nTokenBalanceOf.selector ||\n            sig == nTokenAction.nTokenTransferAllowance.selector ||\n            sig == nTokenAction.nTokenTransferApprove.selector ||\n            sig == nTokenAction.nTokenTransfer.selector ||\n            sig == nTokenAction.nTokenTransferFrom.selector ||\n            sig == nTokenAction.nTokenClaimIncentives.selector ||\n            sig == nTokenAction.nTokenTransferApproveAll.selector ||\n            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||\n            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector\n        ) {\n            return NTOKEN_ACTIONS;\n        }\n\n        if (\n            sig == NotionalProxy.depositUnderlyingToken.selector ||\n            sig == NotionalProxy.depositAssetToken.selector ||\n            sig == NotionalProxy.withdraw.selector ||\n            sig == NotionalProxy.settleAccount.selector ||\n            sig == NotionalProxy.enableBitmapCurrency.selector\n        ) {\n            return ACCOUNT_ACTION;\n        }\n\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector\n        ) {\n            return NTOKEN_REDEEM;\n        }\n\n        if (\n            sig == nERC1155Interface.supportsInterface.selector ||\n            sig == nERC1155Interface.balanceOf.selector ||\n            sig == nERC1155Interface.balanceOfBatch.selector ||\n            sig == nERC1155Interface.safeTransferFrom.selector ||\n            sig == nERC1155Interface.safeBatchTransferFrom.selector ||\n            sig == nERC1155Interface.decodeToAssets.selector ||\n            sig == nERC1155Interface.encodeToId.selector ||\n            sig == nERC1155Interface.setApprovalForAll.selector ||\n            sig == nERC1155Interface.isApprovedForAll.selector\n        ) {\n            return ERC1155;\n        }\n\n        if (\n            sig == NotionalProxy.liquidateLocalCurrency.selector ||\n            sig == NotionalProxy.liquidateCollateralCurrency.selector ||\n            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            sig == NotionalProxy.liquidatefCashLocal.selector ||\n            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||\n            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            sig == NotionalProxy.initializeMarkets.selector ||\n            sig == NotionalProxy.sweepCashIntoMarkets.selector\n        ) {\n            return INITIALIZE_MARKET;\n        }\n\n        if (\n            sig == NotionalGovernance.listCurrency.selector ||\n            sig == NotionalGovernance.enableCashGroup.selector ||\n            sig == NotionalGovernance.updateCashGroup.selector ||\n            sig == NotionalGovernance.updateAssetRate.selector ||\n            sig == NotionalGovernance.updateETHRate.selector ||\n            sig == NotionalGovernance.transferOwnership.selector ||\n            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||\n            sig == NotionalGovernance.updateDepositParameters.selector ||\n            sig == NotionalGovernance.updateInitializationParameters.selector ||\n            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||\n            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||\n            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||\n            sig == NotionalProxy.upgradeTo.selector ||\n            sig == NotionalProxy.upgradeToAndCall.selector\n        ) {\n            return GOVERNANCE;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n\n    // NOTE: receive() is overridden in \"nProxy\" to allow for eth transfers to succeed\n}\n\n\n",
        "CodeNames": [
            "nTokenAction.sol",
            "CompoundToNotionalV2.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "false",
                    "CompoundToNotionalV",
                    "enableToken",
                    "success",
                    "ERC"
                ],
                "Type": "  CompoundToNotionalV2.enableToken  ERC20 missing return value check",
                "Description": "\nThe enableToken function performs an ERC20.approve() call but does not check the success return value.\nSome tokens do not revert if the approval failed, returning false instead.\n\nThe impact is that, tokens that don't actually perform the approve and return false are still counted as a correct approve.\n\n",
                "Repair": "Recommend using OpenZeppelin\u2019s SafeERC20(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/67)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BatchAction.sol\";\nimport \"./nTokenRedeemAction.sol\";\nimport \"../FreeCollateralExternal.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"../../internal/AccountContextHandler.sol\";\nimport \"../../internal/portfolio/TransferAssets.sol\";\nimport \"../../internal/portfolio/PortfolioHandler.sol\";\nimport \"interfaces/IERC1155TokenReceiver.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\n\ncontract ERC1155Action is nERC1155Interface, StorageLayoutV1 {\n    using AccountContextHandler for AccountContext;\n\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(nERC1155Interface).interfaceId;\n    }\n\n    /// @notice Returns the balance of an ERC1155 id on an account. WARNING: the balances returned by\n    /// this method are int256 not uint256 as specified in ERC1155. Modify smart contracts accordingly.\n    /// @param account account to get the id for\n    /// @param id the ERC1155 id\n    /// @return Balance of the ERC1155 id as a signed integer\n    function balanceOf(address account, uint256 id) public view override returns (int256) {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        int256 notional;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            notional = _balanceInBitmap(account, accountContext.bitmapCurrencyId, id);\n        } else {\n            notional = _balanceInArray(\n                PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength),\n                id\n            );\n        }\n\n        return notional;\n    }\n\n    /// @notice Returns the balance of a batch of accounts and ids. WARNING: these balances are signed integers, not\n    /// unsigned integers as the ERC1155 spec designates\n    /// @param accounts array of accounts to get balances for\n    /// @param ids array of ids to get balances for\n    /// @return Returns an array of balances as signed integers\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        override\n        returns (int256[] memory)\n    {\n        require(accounts.length == ids.length);\n        int256[] memory amounts = new int256[](accounts.length);\n\n        for (uint256 i; i < accounts.length; i++) {\n            // This is pretty inefficient but gets the job done\n            amounts[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return amounts;\n    }\n\n    /// @dev Returns the balance from a bitmap given the id\n    function _balanceInBitmap(\n        address account,\n        uint256 bitmapCurrencyId,\n        uint256 id\n    ) internal view returns (int256) {\n        (uint256 currencyId, uint256 maturity, uint256 assetType) = TransferAssets.decodeAssetId(\n            id\n        );\n        if (currencyId != bitmapCurrencyId) return 0;\n        if (assetType != Constants.FCASH_ASSET_TYPE) return 0;\n\n        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);\n    }\n\n    /// @dev Searches an array for the matching asset\n    function _balanceInArray(PortfolioAsset[] memory portfolio, uint256 id)\n        internal\n        pure\n        returns (int256)\n    {\n        for (uint256 i; i < portfolio.length; i++) {\n            if (\n                TransferAssets.encodeAssetId(\n                    portfolio[i].currencyId,\n                    portfolio[i].maturity,\n                    portfolio[i].assetType\n                ) == id\n            ) return portfolio[i].notional;\n        }\n    }\n\n    /// @notice Transfer of a single fCash or liquidity token asset between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param id ERC1155 id of the asset\n    /// @param amount amount to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferSingle\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external payable override {\n        require(amount <= uint256(type(int256).max)); // dev: int overflow\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        // When amount is set to zero this method can be used as a way to execute trades via a transfer operator\n        AccountContext memory fromContext;\n        if (amount > 0) {\n            PortfolioAsset[] memory assets = new PortfolioAsset[](1);\n            (assets[0].currencyId, assets[0].maturity, assets[0].assetType) = TransferAssets\n                .decodeAssetId(id);\n            assets[0].notional = int256(amount);\n            _assertValidMaturity(assets[0].currencyId, assets[0].maturity, block.timestamp);\n\n            // prettier-ignore\n            (fromContext, /* toContext */) = _transfer(from, to, assets);\n\n            emit TransferSingle(msg.sender, from, to, id, amount);\n        } else {\n            fromContext = AccountContextHandler.getAccountContext(from);\n        }\n\n        // toContext is always empty here because we cannot have bidirectional transfers in `safeTransferFrom`\n        AccountContext memory toContext;\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, false);\n    }\n\n    /// @notice Transfer of a batch of fCash or liquidity token assets between accounts. Allows `from` account to transfer more fCash\n    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param ids ERC1155 ids of the assets\n    /// @param amounts amounts to transfer\n    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate\n    /// a trading action on Notional for the `from` address\n    /// @dev emit:TransferBatch\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override {\n        _validateAccounts(from, to);\n\n        // If code size > 0 call onERC1155received\n        uint256 codeSize;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize > 0) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155_BATCH_ACCEPTED,\n                \"Not accepted\"\n            );\n        }\n\n        (PortfolioAsset[] memory assets, bool toTransferNegative) = _decodeToAssets(ids, amounts);\n        // When doing a bidirectional transfer must ensure that the `to` account has given approval\n        // to msg.sender as well.\n        if (toTransferNegative) require(isApprovedForAll(to, msg.sender), \"Unauthorized\");\n\n        (AccountContext memory fromContext, AccountContext memory toContext) = _transfer(\n            from,\n            to,\n            assets\n        );\n\n        _checkPostTransferEvent(from, to, fromContext, toContext, data, toTransferNegative);\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n    }\n\n    /// @dev Validates accounts on transfer\n    function _validateAccounts(address from, address to) private view {\n        require(from != to && to != address(0), \"Invalid address\");\n        require(msg.sender == from || isApprovedForAll(from, msg.sender), \"Unauthorized\");\n    }\n\n    /// @notice Decodes ids and amounts to PortfolioAsset objects\n    /// @param ids array of ERC1155 ids\n    /// @param amounts amounts to transfer\n    /// @return array of portfolio asset objects\n    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        external\n        view\n        override\n        returns (PortfolioAsset[] memory)\n    {\n        // prettier-ignore\n        (PortfolioAsset[] memory assets, /* */) = _decodeToAssets(ids, amounts);\n        return assets;\n    }\n\n    function _decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\n        internal\n        view\n        returns (PortfolioAsset[] memory, bool)\n    {\n        uint256 blockTime = block.timestamp;\n        bool toTransferNegative = false;\n        PortfolioAsset[] memory assets = new PortfolioAsset[](ids.length);\n\n        for (uint256 i; i < ids.length; i++) {\n            (assets[i].currencyId, assets[i].maturity, assets[i].assetType) = TransferAssets\n                .decodeAssetId(ids[i]);\n\n            _assertValidMaturity(assets[i].currencyId, assets[i].maturity, blockTime);\n            // Although amounts is encoded as uint256 we allow it to be negative here. This will\n            // allow for bidirectional transfers of fCash. Internally fCash assets are always stored\n            // as int128 (for bitmap portfolio) or int88 (for array portfolio) so there is no potential\n            // that a uint256 value that is greater than type(int256).max would actually valid.\n            assets[i].notional = int256(amounts[i]);\n            // If there is a negative transfer we mark it as such, this will force us to do a free collateral\n            // check on the `to` address as well.\n            if (assets[i].notional < 0) toTransferNegative = true;\n        }\n\n        return (assets, toTransferNegative);\n    }\n\n    /// @notice Encodes parameters into an ERC1155 id\n    /// @param currencyId currency id of the asset\n    /// @param maturity timestamp of the maturity\n    /// @param assetType id of the asset type\n    /// @return ERC1155 id\n    function encodeToId(\n        uint16 currencyId,\n        uint40 maturity,\n        uint8 assetType\n    ) external pure override returns (uint256) {\n        return TransferAssets.encodeAssetId(currencyId, maturity, assetType);\n    }\n\n    /// @dev Ensures that all maturities specified are valid for the currency id (i.e. they do not\n    /// go past the max maturity date)\n    function _assertValidMaturity(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 blockTime\n    ) private view {\n        require(\n            DateTime.isValidMaturity(CashGroup.getMaxMarketIndex(currencyId), maturity, blockTime),\n            \"Invalid maturity\"\n        );\n    }\n\n    /// @dev Internal asset transfer event between accounts\n    function _transfer(\n        address from,\n        address to,\n        PortfolioAsset[] memory assets\n    ) internal returns (AccountContext memory, AccountContext memory) {\n        AccountContext memory fromContext = AccountContextHandler.getAccountContext(from);\n        AccountContext memory toContext = AccountContextHandler.getAccountContext(to);\n\n        toContext = TransferAssets.placeAssetsInAccount(to, toContext, assets);\n        TransferAssets.invertNotionalAmountsInPlace(assets);\n        fromContext = TransferAssets.placeAssetsInAccount(from, fromContext, assets);\n\n        toContext.setAccountContext(to);\n        fromContext.setAccountContext(from);\n\n        return (fromContext, toContext);\n    }\n\n    /// @dev Checks post transfer events which will either be initiating one of the batch trading events or a free collateral\n    /// check if required.\n    function _checkPostTransferEvent(\n        address from,\n        address to,\n        AccountContext memory fromContext,\n        AccountContext memory toContext,\n        bytes calldata data,\n        bool toTransferNegative\n    ) internal {\n        bytes4 sig;\n        address transactedAccount;\n        if (data.length >= 32) {\n            // Method signature is not abi encoded so decode to bytes32 first and take the first 4 bytes. This works\n            // because all the methods we want to call below require more than 32 bytes in the calldata\n            bytes32 tmp = abi.decode(data, (bytes32));\n            sig = bytes4(tmp);\n        }\n\n        // These are the only three methods allowed to occur in a post transfer event. These actions allow `from`\n        // accounts to take any sort of trading action as a result of their transfer. All of these actions will\n        // handle checking free collateral so no additional check is necessary here.\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == BatchAction.batchBalanceAction.selector ||\n            sig == BatchAction.batchBalanceAndTradeAction.selector\n        ) {\n            transactedAccount = abi.decode(data[4:36], (address));\n            // Ensure that the \"transactedAccount\" parameter of the call is set to the from address or the\n            // to address. If it is the \"to\" address then ensure that the msg.sender has approval to\n            // execute operations\n            require(\n                transactedAccount == from ||\n                    (transactedAccount == to && isApprovedForAll(to, msg.sender)),\n                \"Unauthorized call\"\n            );\n\n            (bool status, bytes memory result) = address(this).call{value: msg.value}(data);\n            // TODO: retrieve revert string\n            require(status, \"Call failed\");\n        }\n\n        // The transacted account will have its free collateral checked above so there is\n        // no need to recheck here.\n        if (transactedAccount != from && fromContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(from);\n        }\n\n        // Check free collateral if the `to` account has taken on a negative fCash amount\n        if (transactedAccount != to && toTransferNegative && toContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(to);\n        }\n    }\n\n    /// @notice Allows an account to set approval for an operator\n    /// @param operator address of the operator\n    /// @param approved state of the approval\n    /// @dev emit:ApprovalForAll\n    function setApprovalForAll(address operator, bool approved) external override {\n        accountAuthorizedTransferOperator[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @notice Checks approval state for an account, will first check if global transfer operator is enabled\n    /// before falling through to an account specific transfer operator.\n    /// @param account address of the account\n    /// @param operator address of the operator\n    /// @return true for approved\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (globalTransferOperator[operator]) return true;\n\n        return accountAuthorizedTransferOperator[account][operator];\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        // borrow on notional via special flash loan facility\n        //  - borrow repayment amount\n        //  - withdraw to wallet, redeem to underlying\n        // receive callback (tokens transferred to borrowing account)\n        //   -> inside callback\n        //   -> repayBorrowBehalf(account, repayAmount)\n        //   -> deposit cToken to notional (account needs to have set approvals)\n        //   -> exit callback\n        // inside original borrow, check FC\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }\n\n    receive() external payable {\n        // This contract cannot migrate ETH loans because there is no way\n        // to do transferFrom on ETH\n        revert(\"Cannot transfer ETH\");\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../internal/valuation/ExchangeRate.sol\";\nimport \"../../internal/markets/CashGroup.sol\";\nimport \"../../internal/nTokenHandler.sol\";\nimport \"../../internal/balances/TokenHandler.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"../../proxy/utils/UUPSUpgradeable.sol\";\nimport \"../adapters/nTokenERC20Proxy.sol\";\nimport \"interfaces/notional/AssetRateAdapter.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\n/// @notice Governance methods can only be called by the governance contract\ncontract GovernanceAction is StorageLayoutV1, NotionalGovernance, UUPSUpgradeable {\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Can only be called by the current owner.\n    function transferOwnership(address newOwner) external override onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /// @dev Only the owner may upgrade the contract, the pauseGuardian may downgrade the contract\n    /// to a predetermined router contract that provides read only access to the system.\n    function _authorizeUpgrade(address newImplementation) internal override {\n        require(\n            owner == msg.sender ||\n            (msg.sender == pauseGuardian && newImplementation == pauseRouter),\n            \"Unauthorized upgrade\"\n        );\n\n        // This is set temporarily during a downgrade to the pauseRouter so that the upgrade\n        // will pass _authorizeUpgrade on the pauseRouter during the UUPSUpgradeable rollback check\n        if (newImplementation == pauseRouter) rollbackRouterImplementation = _getImplementation();\n    }\n\n    /// @notice Sets a new pause router and guardian address.\n    function setPauseRouterAndGuardian(\n        address pauseRouter_,\n        address pauseGuardian_\n    ) external override onlyOwner {\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n\n        emit PauseRouterAndGuardianUpdated(pauseRouter_, pauseGuardian_);\n    }\n\n    /// @notice Lists a new currency along with its exchange rate to ETH\n    /// @dev emit:ListCurrency emit:UpdateETHRate\n    /// @param assetToken the token parameters for the asset token\n    /// @param underlyingToken the underlying token (if asset token is an interest bearing wrapper)\n    /// @param rateOracle ETH to underlying rate oracle\n    /// @param mustInvert if the rate from the oracle needs to be inverted\n    /// @param buffer multiplier (>= 100) for negative balances when calculating free collateral\n    /// @param haircut multiplier (<= 100) for positive balances when calculating free collateral\n    /// @param liquidationDiscount multiplier (>= 100) for exchange rate when liquidating\n    function listCurrency(\n        TokenStorage calldata assetToken,\n        TokenStorage calldata underlyingToken,\n        address rateOracle,\n        bool mustInvert,\n        uint8 buffer,\n        uint8 haircut,\n        uint8 liquidationDiscount\n    ) external override onlyOwner {\n        uint16 currencyId = maxCurrencyId + 1;\n        // Set the new max currency id\n        maxCurrencyId = currencyId;\n        require(currencyId <= Constants.MAX_CURRENCIES, \"G: max currency overflow\");\n        require(\n            tokenAddressToCurrencyId[assetToken.tokenAddress] == 0,\n            \"G: duplicate token listing\"\n        );\n        tokenAddressToCurrencyId[assetToken.tokenAddress] = currencyId;\n\n        // Set the underlying first because the asset token may set an approval using the underlying\n        if (\n            underlyingToken.tokenAddress != address(0) ||\n            // Ether has a token address of zero\n            underlyingToken.tokenType == TokenType.Ether\n        ) {\n            TokenHandler.setToken(currencyId, true, underlyingToken);\n        }\n        TokenHandler.setToken(currencyId, false, assetToken);\n\n        _updateETHRate(currencyId, rateOracle, mustInvert, buffer, haircut, liquidationDiscount);\n\n        emit ListCurrency(currencyId);\n    }\n\n    /// @notice Enables a cash group on a given currency so that it can have lend and borrow markets. Will\n    /// also deploy an nToken contract so that markets can be initialized.\n    /// @dev emit:UpdateCashGroup emit:UpdateAssetRate emit:DeployNToken\n    /// @param currencyId id of the currency to enable\n    /// @param assetRateOracle address of the rate oracle for converting interest bearing assets to\n    /// underlying values\n    /// @param cashGroup parameters for the cash group\n    /// @param underlyingName underlying token name for seeding nToken name\n    /// @param underlyingSymbol underlying token symbol for seeding nToken symbol (i.e. nDAI)\n    function enableCashGroup(\n        uint16 currencyId,\n        address assetRateOracle,\n        CashGroupSettings calldata cashGroup,\n        string calldata underlyingName,\n        string calldata underlyingSymbol\n    ) external override onlyOwner {\n        _updateCashGroup(currencyId, cashGroup);\n        _updateAssetRate(currencyId, assetRateOracle);\n\n        // Creates the nToken erc20 proxy that routes back to the main contract\n        address nTokenAddress =\n            Create2.deploy(\n                0,\n                bytes32(uint256(currencyId)),\n                abi.encodePacked(\n                    type(nTokenERC20Proxy).creationCode,\n                    abi.encode(address(this), currencyId, underlyingName, underlyingSymbol)\n                )\n            );\n\n        nTokenHandler.setNTokenAddress(currencyId, nTokenAddress);\n        emit DeployNToken(currencyId, nTokenAddress);\n    }\n\n    /// @notice Updates the deposit parameters for an nToken\n    /// @dev emit:UpdateDepositParameters\n    /// @param currencyId the currency id that the nToken references\n    /// @param depositShares an array of values that represent the proportion of each deposit\n    /// that will go to a respective market, must add up to DEPOSIT_PERCENT_BASIS. For example,\n    /// 0.40e8, 0.40e8 and 0.20e8 will result in 40%, 40% and 20% deposited as liquidity into\n    /// the 3 month, 6 month and 1 year markets.\n    /// @param leverageThresholds an array of values denominated in RATE_PRECISION that mark the\n    /// highest proportion of fCash where the nToken will provide liquidity. Above this proportion,\n    /// the nToken will lend to the market instead to reduce the leverage in the market.\n    function updateDepositParameters(\n        uint16 currencyId,\n        uint32[] calldata depositShares,\n        uint32[] calldata leverageThresholds\n    ) external override onlyOwner {\n        nTokenHandler.setDepositParameters(currencyId, depositShares, leverageThresholds);\n        emit UpdateDepositParameters(currencyId);\n    }\n\n    /// @notice Updates the market initialization parameters for an nToken\n    /// @dev emit:UpdateInitializationParameters\n    /// @param currencyId the currency id that the nToken references\n    /// @param annualizedAnchorRates is a target interest rate that will be used to calculate a \n    /// rate anchor during initialize markets. This rate anchor will set the offset from the\n    /// x-axis where the liquidity curve will be initialized. This is used in combination with\n    /// previous market rates to determine the initial proportion where markets will be initialized\n    /// every quarter.\n    /// @param proportions used to combination with annualizedAnchorRate set the initial proportion when\n    /// a market is first initialized. This is required since there is no previous rate to reference.\n    function updateInitializationParameters(\n        uint16 currencyId,\n        uint32[] calldata annualizedAnchorRates,\n        uint32[] calldata proportions\n    ) external override onlyOwner {\n        nTokenHandler.setInitializationParameters(currencyId, annualizedAnchorRates, proportions);\n        emit UpdateInitializationParameters(currencyId);\n    }\n\n    /// @notice Updates the emission rate of incentives for a given currency\n    /// @dev emit:UpdateIncentiveEmissionRate\n    /// @param currencyId the currency id that the nToken references\n    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year\n    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be\n    /// exact due to multiplier effects and fluctuating token supply.\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate)\n        external\n        override\n        onlyOwner\n    {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0), \"Invalid currency\");\n        // Sanity check that emissions rate is not specified in 1e8 terms.\n        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, \"Invalid rate\");\n\n        nTokenHandler.setIncentiveEmissionRate(nTokenAddress, newEmissionRate);\n        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);\n    }\n\n    /// @notice Updates collateralization parameters for an nToken\n    /// @dev emit:UpdateTokenCollateralParameters\n    /// @param currencyId the currency id that the nToken references\n    /// @param residualPurchaseIncentive10BPS nTokens will have residual amounts of fCash at the end of each\n    /// quarter that are \"dead weight\" because they are at idiosyncratic maturities and do not contribute to\n    /// actively providing liquidity. This parameter will incentivize market participants to purchase these residuals\n    /// at a discount from the on chain oracle rate, denominated in 10 basis point increments. These residuals will\n    /// be added back into nToken balances and will be used to provide liquidity upon the next market initialization.\n    /// @param pvHaircutPercentage a percentage (< 100) that the present value of the nToken's assets will be valued\n    /// at for the purposes of free collateral, relevant when accounts hold nTokens as collateral against debts.\n    /// @param residualPurchaseTimeBufferHours an arbitrage opportunity is available by pushing markets in one direction\n    /// before quarterly settlement to generate large residual balances that can be purchased at a discount. The time buffer\n    /// here ensures that anyone attempting such an act would have to wait some number of hours (likely a few days) before\n    /// they could attempt to purchase residuals, ensuring that the market could realign to rates where the arbitrage is\n    /// no longer possible.\n    /// @param cashWithholdingBuffer10BPS nToken residuals may be negative fCash (debt), in this case cash is withheld to\n    /// transfer to accounts that take on the debt. This parameter denominates the discounted rate at which the cash will\n    /// be withheld at for this purpose.\n    /// @param liquidationHaircutPercentage a percentage of nToken present value (> pvHaircutPercentage and <= 100) at which\n    /// liquidators will purchase nTokens during liquidation\n    function updateTokenCollateralParameters(\n        uint16 currencyId,\n        uint8 residualPurchaseIncentive10BPS,\n        uint8 pvHaircutPercentage,\n        uint8 residualPurchaseTimeBufferHours,\n        uint8 cashWithholdingBuffer10BPS,\n        uint8 liquidationHaircutPercentage\n    ) external override onlyOwner {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0), \"Invalid currency\");\n\n        nTokenHandler.setNTokenCollateralParameters(\n            nTokenAddress,\n            residualPurchaseIncentive10BPS,\n            pvHaircutPercentage,\n            residualPurchaseTimeBufferHours,\n            cashWithholdingBuffer10BPS,\n            liquidationHaircutPercentage\n        );\n        emit UpdateTokenCollateralParameters(currencyId);\n    }\n\n    /// @notice Updates cash group parameters\n    /// @dev emit:UpdateCashGroup\n    /// @param currencyId id of the currency to enable\n    /// @param cashGroup new parameters for the cash group\n    function updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup)\n        external\n        override\n        onlyOwner\n    {\n        _updateCashGroup(currencyId, cashGroup);\n    }\n\n    /// @notice Updates asset rate oracle\n    /// @dev emit:UpdateAssetRate\n    /// @param currencyId id of the currency\n    /// @param rateOracle new rate oracle for the asset\n    function updateAssetRate(uint16 currencyId, address rateOracle) external override onlyOwner {\n        _updateAssetRate(currencyId, rateOracle);\n    }\n\n    /// @notice Updates ETH exchange rate or related parameters\n    /// @dev emit:UpdateETHRate\n    /// @param currencyId id of the currency\n    /// @param rateOracle new rate oracle for the asset\n    /// @param rateOracle ETH to underlying rate oracle\n    /// @param mustInvert if the rate from the oracle needs to be inverted\n    /// @param buffer multiplier (>= 100) for negative balances when calculating free collateral\n    /// @param haircut multiplier (<= 100) for positive balances when calculating free collateral\n    /// @param liquidationDiscount multiplier (>= 100) for exchange rate when liquidating\n    function updateETHRate(\n        uint16 currencyId,\n        address rateOracle,\n        bool mustInvert,\n        uint8 buffer,\n        uint8 haircut,\n        uint8 liquidationDiscount\n    ) external override onlyOwner {\n        _updateETHRate(currencyId, rateOracle, mustInvert, buffer, haircut, liquidationDiscount);\n    }\n\n    /// @notice Sets a global transfer operator that can do authenticated ERC1155 transfers. This enables\n    /// OTC trading or other use cases such as layer 2 authenticated transfers.\n    /// @dev emit:UpdateGlobalTransferOperator\n    /// @param operator address of the operator\n    /// @param approved true if the operator is allowed to transfer globally\n    function updateGlobalTransferOperator(address operator, bool approved)\n        external\n        override\n        onlyOwner\n    {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(operator)\n        }\n        // Sanity check to ensure that operator is a contract, not an EOA\n        require(codeSize > 0, \"Operator must be a contract\");\n\n        globalTransferOperator[operator] = approved;\n        emit UpdateGlobalTransferOperator(operator, approved);\n    }\n\n    /// @notice Approves contracts that can call `batchTradeActionWithCallback`. These contracts can\n    /// \"flash loan\" from Notional V2 and receive a callback before the free collateral check. Flash loans\n    /// via the Notional V2 liquidity pool are not very gas efficient so this is not generally available,\n    /// it can be used for migrating borrows into Notional V2 from other platforms.\n    /// @dev emit:UpdateAuthorizedCallbackContract\n    /// @param operator address of the contract\n    /// @param approved true if the contract is authorized\n    function updateAuthorizedCallbackContract(address operator, bool approved)\n        external\n        override\n        onlyOwner\n    {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(operator)\n        }\n        // Sanity check to ensure that operator is a contract, not an EOA\n        require(codeSize > 0, \"Operator must be a contract\");\n\n        authorizedCallbackContract[operator] = approved;\n        emit UpdateAuthorizedCallbackContract(operator, approved);\n    }\n\n    function _updateCashGroup(uint256 currencyId, CashGroupSettings calldata cashGroup) internal {\n        require(currencyId != 0, \"G: invalid currency id\");\n        require(currencyId <= maxCurrencyId, \"G: invalid currency id\");\n\n        CashGroup.setCashGroupStorage(currencyId, cashGroup);\n\n        emit UpdateCashGroup(uint16(currencyId));\n    }\n\n    function _updateAssetRate(uint256 currencyId, address rateOracle) internal {\n        require(currencyId != 0, \"G: invalid currency id\");\n        require(currencyId <= maxCurrencyId, \"G: invalid currency id\");\n\n        // If rate oracle refers to address zero then do not apply any updates here, this means\n        // that a token is non mintable.\n        Token memory assetToken = TokenHandler.getToken(currencyId, false);\n        if (rateOracle == address(0)) {\n            // Sanity check that unset rate oracles are only for non mintable tokens\n            require(assetToken.tokenType == TokenType.NonMintable, \"G: invalid asset rate\");\n            return;\n        }\n\n        // Sanity check that the rate oracle refers to the proper asset token\n        address token = AssetRateAdapter(rateOracle).token();\n        require(assetToken.tokenAddress == token, \"G: invalid rate oracle\");\n\n        uint8 underlyingDecimals;\n        if (currencyId == 1) {\n            // If currencyId is one then this is referring to cETH and there is no underlying() to call\n            underlyingDecimals = 18;\n        } else {\n            address underlyingToken = AssetRateAdapter(rateOracle).underlying();\n            underlyingDecimals = ERC20(underlyingToken).decimals();\n        }\n\n        assetToUnderlyingRateMapping[currencyId] = AssetRateStorage({\n            rateOracle: rateOracle,\n            underlyingDecimalPlaces: underlyingDecimals\n        });\n\n        emit UpdateAssetRate(uint16(currencyId));\n    }\n\n    function _updateETHRate(\n        uint256 currencyId,\n        address rateOracle,\n        bool mustInvert,\n        uint8 buffer,\n        uint8 haircut,\n        uint8 liquidationDiscount\n    ) internal {\n        require(currencyId != 0, \"G: invalid currency id\");\n        require(currencyId <= maxCurrencyId, \"G: invalid currency id\");\n\n        uint8 rateDecimalPlaces;\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\n            // ETH to ETH exchange rate is fixed at 1 and has no rate oracle\n            rateOracle = address(0);\n            rateDecimalPlaces = 18;\n        } else {\n            require(rateOracle != address(0), \"G: zero rate oracle address\");\n            rateDecimalPlaces = AggregatorV2V3Interface(rateOracle).decimals();\n        }\n        require(buffer >= Constants.PERCENTAGE_DECIMALS, \"G: buffer must be gte decimals\");\n        require(haircut <= Constants.PERCENTAGE_DECIMALS, \"G: buffer must be lte decimals\");\n        require(\n            liquidationDiscount > Constants.PERCENTAGE_DECIMALS,\n            \"G: discount must be gt decimals\"\n        );\n\n        underlyingToETHRateMapping[currencyId] = ETHRateStorage({\n            rateOracle: rateOracle,\n            rateDecimalPlaces: rateDecimalPlaces,\n            mustInvert: mustInvert,\n            buffer: buffer,\n            haircut: haircut,\n            liquidationDiscount: liquidationDiscount\n        });\n\n        emit UpdateETHRate(uint16(currencyId));\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./actions/nTokenAction.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"./actions/nTokenRedeemAction.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\n\n/**\n * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage\n * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing\n * contracts.\n *\n * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also\n * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a\n * new Router with the new hardcoded addresses will then be deployed and upgraded into place.\n */\ncontract Router is StorageLayoutV1 {\n    // These contract addresses cannot be changed once set by the constructor\n    address public immutable GOVERNANCE;\n    address public immutable VIEWS;\n    address public immutable INITIALIZE_MARKET;\n    address public immutable NTOKEN_ACTIONS;\n    address public immutable NTOKEN_REDEEM;\n    address public immutable BATCH_ACTION;\n    address public immutable ACCOUNT_ACTION;\n    address public immutable ERC1155;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n    address public immutable cETH;\n\n    constructor(\n        address governance_,\n        address views_,\n        address initializeMarket_,\n        address nTokenActions_,\n        address nTokenRedeem_,\n        address batchAction_,\n        address accountAction_,\n        address erc1155_,\n        address liquidateCurrency_,\n        address liquidatefCash_,\n        address cETH_\n    ) {\n        GOVERNANCE = governance_;\n        VIEWS = views_;\n        INITIALIZE_MARKET = initializeMarket_;\n        NTOKEN_ACTIONS = nTokenActions_;\n        NTOKEN_REDEEM = nTokenRedeem_;\n        BATCH_ACTION = batchAction_;\n        ACCOUNT_ACTION = accountAction_;\n        ERC1155 = erc1155_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n        cETH = cETH_;\n    }\n\n    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\n        // Cannot re-initialize once the contract has been initialized, ownership transfer does not\n        // allow address to be set back to zero\n        require(owner == address(0), \"R: already initialized\");\n\n        // Allow list currency to be called by this contract for the purposes of\n        // initializing ETH as a currency\n        owner = msg.sender;\n        // List ETH as currency id == 1, NOTE: return value is ignored here\n        (bool status, ) =\n            address(GOVERNANCE).delegatecall(\n                abi.encodeWithSelector(\n                    NotionalGovernance.listCurrency.selector,\n                    TokenStorage(cETH, false, TokenType.cETH),\n                    // No underlying set for cETH\n                    TokenStorage(address(0), false, TokenType.Ether),\n                    address(0),\n                    false,\n                    130, // Initial settings of 130 buffer\n                    70,  // 70% haircut\n                    105  // 105 liquidation discount\n                )\n            );\n        require(status);\n\n        owner = owner_;\n        // The pause guardian may downgrade the router to the pauseRouter\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n    }\n\n    /// @notice Returns the implementation contract for the method signature\n    /// @param sig method signature to call\n    /// @return implementation address\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        if (\n            sig == NotionalProxy.batchBalanceAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector\n        ) {\n            return BATCH_ACTION;\n        }\n\n        if (\n            sig == nTokenAction.nTokenTotalSupply.selector ||\n            sig == nTokenAction.nTokenBalanceOf.selector ||\n            sig == nTokenAction.nTokenTransferAllowance.selector ||\n            sig == nTokenAction.nTokenTransferApprove.selector ||\n            sig == nTokenAction.nTokenTransfer.selector ||\n            sig == nTokenAction.nTokenTransferFrom.selector ||\n            sig == nTokenAction.nTokenClaimIncentives.selector ||\n            sig == nTokenAction.nTokenTransferApproveAll.selector ||\n            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||\n            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector\n        ) {\n            return NTOKEN_ACTIONS;\n        }\n\n        if (\n            sig == NotionalProxy.depositUnderlyingToken.selector ||\n            sig == NotionalProxy.depositAssetToken.selector ||\n            sig == NotionalProxy.withdraw.selector ||\n            sig == NotionalProxy.settleAccount.selector ||\n            sig == NotionalProxy.enableBitmapCurrency.selector\n        ) {\n            return ACCOUNT_ACTION;\n        }\n\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector\n        ) {\n            return NTOKEN_REDEEM;\n        }\n\n        if (\n            sig == nERC1155Interface.supportsInterface.selector ||\n            sig == nERC1155Interface.balanceOf.selector ||\n            sig == nERC1155Interface.balanceOfBatch.selector ||\n            sig == nERC1155Interface.safeTransferFrom.selector ||\n            sig == nERC1155Interface.safeBatchTransferFrom.selector ||\n            sig == nERC1155Interface.decodeToAssets.selector ||\n            sig == nERC1155Interface.encodeToId.selector ||\n            sig == nERC1155Interface.setApprovalForAll.selector ||\n            sig == nERC1155Interface.isApprovedForAll.selector\n        ) {\n            return ERC1155;\n        }\n\n        if (\n            sig == NotionalProxy.liquidateLocalCurrency.selector ||\n            sig == NotionalProxy.liquidateCollateralCurrency.selector ||\n            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            sig == NotionalProxy.liquidatefCashLocal.selector ||\n            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||\n            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            sig == NotionalProxy.initializeMarkets.selector ||\n            sig == NotionalProxy.sweepCashIntoMarkets.selector\n        ) {\n            return INITIALIZE_MARKET;\n        }\n\n        if (\n            sig == NotionalGovernance.listCurrency.selector ||\n            sig == NotionalGovernance.enableCashGroup.selector ||\n            sig == NotionalGovernance.updateCashGroup.selector ||\n            sig == NotionalGovernance.updateAssetRate.selector ||\n            sig == NotionalGovernance.updateETHRate.selector ||\n            sig == NotionalGovernance.transferOwnership.selector ||\n            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||\n            sig == NotionalGovernance.updateDepositParameters.selector ||\n            sig == NotionalGovernance.updateInitializationParameters.selector ||\n            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||\n            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||\n            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||\n            sig == NotionalProxy.upgradeTo.selector ||\n            sig == NotionalProxy.upgradeToAndCall.selector\n        ) {\n            return GOVERNANCE;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n\n    // NOTE: receive() is overridden in \"nProxy\" to allow for eth transfers to succeed\n}\n\n\n",
        "CodeNames": [
            "ERC1155Action.sol",
            "CompoundToNotionalV2.sol",
            "GovernanceAction.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "false",
                    "transfer",
                    "approve",
                    "transferFrom",
                    "nTokenERC",
                    "Approval",
                    "Transfer"
                ],
                "Type": "  nTokenERC20Proxy  emits events even when not success",
                "Description": "\nThe nTokenERC20Proxy functions emit events all the time, even if the return value from the inner call returns false, indicating an unsuccessful action.\n\nAn off-chain script scanning for Transfer or Approval events can be tricked into believing that an unsuccessful transfer was indeed successful.\nThis happens in the approve, transfer and transferFrom functions.\n\n",
                "Repair": "Recommend only emitting events on success.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/72)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../internal/nTokenHandler.sol\";\nimport \"../../internal/markets/AssetRate.sol\";\nimport \"../../internal/balances/BalanceHandler.sol\";\nimport \"../../internal/balances/Incentives.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"interfaces/notional/nTokenERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract nTokenAction is StorageLayoutV1, nTokenERC20 {\n    using BalanceHandler for BalanceState;\n    using AssetRate for AssetRateParameters;\n    using AccountContextHandler for AccountContext;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    /// @notice Total number of tokens in circulation\n    /// @param nTokenAddress The address of the nToken\n    /// @return totalSupply number of tokens held\n    function nTokenTotalSupply(address nTokenAddress)\n        external\n        view\n        override\n        returns (uint256 totalSupply)\n    {\n        // prettier-ignore\n        (\n            totalSupply,\n            /* integralTotalSupply */,\n            /* lastSupplyChangeTime */\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function nTokenBalanceOf(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // prettier-ignore\n        (\n            /* int cashBalance */,\n            int256 nTokenBalance,\n            /* uint lastClaimTime */,\n            /* uint lastClaimIntegralSupply */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n\n        require(nTokenBalance >= 0); // dev: negative nToken balance\n        return uint256(nTokenBalance);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param owner The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function nTokenTransferAllowance(\n        uint16 currencyId,\n        address owner,\n        address spender\n    ) external view override returns (uint256) {\n        // This whitelist allowance supersedes any specific allowances\n        uint256 allowance = nTokenWhitelist[owner][spender];\n        if (allowance > 0) return allowance;\n\n        return nTokenAllowance[owner][spender][currencyId];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev Can only be called via the nToken proxy\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApprove(\n        uint16 currencyId,\n        address owner,\n        address spender,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        nTokenAllowance[owner][spender][currencyId] = amount;\n\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param from The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransfer(\n        uint16 currencyId,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        return _transfer(currencyId, from, to, amount);\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param currencyId Currency id of the nToken\n    /// @param spender The address of the original caller\n    /// @param from The address of the source account\n    /// @param to The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransferFrom(\n        uint16 currencyId,\n        address spender,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool, uint256) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        uint256 allowance = nTokenWhitelist[from][spender];\n\n        if (allowance > 0) {\n            // This whitelist allowance supersedes any specific allowances\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenWhitelist[from][spender] = allowance;\n        } else {\n            // This is the specific allowance for the nToken.\n            allowance = nTokenAllowance[from][spender][currencyId];\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenAllowance[from][spender][currencyId] = allowance;\n        }\n\n        bool success = _transfer(currencyId, from, to, amount);\n        return (success, allowance);\n    }\n\n    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve\n    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly\n    /// on the Notional contract, not available via the ERC20 proxy.\n    /// @dev emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApproveAll(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        nTokenWhitelist[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender\n    /// @dev auth:msg.sender\n    /// @return Total amount of incentives claimed\n    function nTokenClaimIncentives() external override returns (uint256) {\n        address account = msg.sender;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        uint256 totalIncentivesClaimed;\n        BalanceState memory balanceState;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n\n            currencies = currencies << 16;\n        }\n\n        // NOTE: no need to set account context after claiming incentives\n        return totalIncentivesClaimed;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in asset tokens\n    function nTokenPresentValueAssetDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* portfolio */\n        ) = _getNTokenPV(currencyId);\n\n        return totalAssetPV;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in underlying\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);\n\n        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);\n    }\n\n    function _getNTokenPV(uint256 currencyId)\n        private\n        view\n        returns (int256, nTokenPortfolio memory)\n    {\n        uint256 blockTime = block.timestamp;\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* ifCashMapping */\n        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);\n\n        return (totalAssetPV, nToken);\n    }\n\n    /// @notice Transferring tokens will also claim incentives at the same time\n    function _transfer(\n        uint256 currencyId,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        {\n            // prettier-ignore\n            (\n                uint256 isNToken,\n                /* incentiveAnnualEmissionRate */,\n                /* lastInitializedTime */,\n                /* parameters */\n            ) = nTokenHandler.getNTokenContext(recipient);\n            // nTokens cannot hold nToken balances\n            require(isNToken == 0, \"Cannot transfer to nToken\");\n        }\n\n        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);\n        BalanceState memory senderBalance;\n        senderBalance.loadBalanceState(sender, currencyId, senderContext);\n\n        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);\n        BalanceState memory recipientBalance;\n        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);\n\n        int256 amountInt = SafeCast.toInt256(amount);\n        senderBalance.netNTokenTransfer = amountInt.neg();\n        recipientBalance.netNTokenTransfer = amountInt;\n\n        senderBalance.finalize(sender, senderContext, false);\n        recipientBalance.finalize(recipient, recipientContext, false);\n        senderContext.setAccountContext(sender);\n        recipientContext.setAccountContext(recipient);\n\n        emit Transfer(sender, recipient, amount);\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/compound/CEtherInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    currencyId,\n                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))\n                )\n            );\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {\n        bytes32 slot = _getSlot(currencyId, underlying);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n        address tokenAddress = address(bytes20(data << 96));\n        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;\n        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));\n        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));\n\n        return\n            Token({\n                tokenAddress: tokenAddress,\n                hasTransferFee: tokenHasTransferFee,\n                decimals: int256(10**tokenDecimalPlaces),\n                tokenType: tokenType\n            });\n    }\n\n    /// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }\n\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        uint256 success;\n        if (token.tokenType == TokenType.cToken) {\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\n        } else if (token.tokenType == TokenType.cETH) {\n            // Reverts on error\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\n        } else {\n            revert(); // dev: non mintable token\n        }\n\n        require(success == 0, \"Mint fail\");\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        // This is the starting and ending balance in external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    function redeem(\n        Token memory assetToken,\n        Token memory underlyingToken,\n        uint256 assetAmountExternal\n    ) internal returns (int256) {\n        uint256 startingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            startingBalance = address(this).balance;\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        } else {\n            revert(); // dev: non redeemable failure\n        }\n\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\n        require(success == 0, \"Redeem fail\");\n\n        uint256 endingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            endingBalance = address(this).balance;\n        } else {\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        }\n\n        // Underlying token external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\n    /// precision.\n    function transfer(\n        Token memory token,\n        address account,\n        int256 netTransferExternal\n    ) internal returns (int256) {\n        if (netTransferExternal > 0) {\n            // Deposits must account for transfer fees.\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\n        } else if (token.tokenType == TokenType.Ether) {\n            require(netTransferExternal < 0); // dev: cannot transfer ether\n            address payable accountPayable = payable(account);\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\n        } else {\n            safeTransferOut(\n                IERC20(token.tokenAddress),\n                account,\n                uint256(netTransferExternal.neg())\n            );\n        }\n\n        return netTransferExternal;\n    }\n\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\n    /// precision.\n    function _deposit(\n        Token memory token,\n        address account,\n        uint256 amount\n    ) private returns (int256) {\n        if (token.hasTransferFee) {\n            // Must deposit from the token and calculate the net transfer\n            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n            safeTransferIn(IERC20(token.tokenAddress), account, amount);\n            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n            return int256(endingBalance.sub(startingBalance));\n        }\n\n        safeTransferIn(IERC20(token.tokenAddress), account, amount);\n        return int256(amount);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);\n    }\n\n    function safeTransferOut(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transfer(account, amount);\n        checkReturnCode();\n    }\n\n    function safeTransferIn(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transferFrom(account, address(this), amount);\n        checkReturnCode();\n    }\n\n    function checkReturnCode() private pure {\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {\n                    // This is a non-standard ERC-20\n                    success := not(0) // set success to true\n                }\n                case 32 {\n                    // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0) // Set `success = returndata` of external call\n                }\n                default {\n                    // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        require(success, \"Transfer Failed\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./actions/nTokenAction.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"./actions/nTokenRedeemAction.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\n\n/**\n * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage\n * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing\n * contracts.\n *\n * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also\n * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a\n * new Router with the new hardcoded addresses will then be deployed and upgraded into place.\n */\ncontract Router is StorageLayoutV1 {\n    // These contract addresses cannot be changed once set by the constructor\n    address public immutable GOVERNANCE;\n    address public immutable VIEWS;\n    address public immutable INITIALIZE_MARKET;\n    address public immutable NTOKEN_ACTIONS;\n    address public immutable NTOKEN_REDEEM;\n    address public immutable BATCH_ACTION;\n    address public immutable ACCOUNT_ACTION;\n    address public immutable ERC1155;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n    address public immutable cETH;\n\n    constructor(\n        address governance_,\n        address views_,\n        address initializeMarket_,\n        address nTokenActions_,\n        address nTokenRedeem_,\n        address batchAction_,\n        address accountAction_,\n        address erc1155_,\n        address liquidateCurrency_,\n        address liquidatefCash_,\n        address cETH_\n    ) {\n        GOVERNANCE = governance_;\n        VIEWS = views_;\n        INITIALIZE_MARKET = initializeMarket_;\n        NTOKEN_ACTIONS = nTokenActions_;\n        NTOKEN_REDEEM = nTokenRedeem_;\n        BATCH_ACTION = batchAction_;\n        ACCOUNT_ACTION = accountAction_;\n        ERC1155 = erc1155_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n        cETH = cETH_;\n    }\n\n    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\n        // Cannot re-initialize once the contract has been initialized, ownership transfer does not\n        // allow address to be set back to zero\n        require(owner == address(0), \"R: already initialized\");\n\n        // Allow list currency to be called by this contract for the purposes of\n        // initializing ETH as a currency\n        owner = msg.sender;\n        // List ETH as currency id == 1, NOTE: return value is ignored here\n        (bool status, ) =\n            address(GOVERNANCE).delegatecall(\n                abi.encodeWithSelector(\n                    NotionalGovernance.listCurrency.selector,\n                    TokenStorage(cETH, false, TokenType.cETH),\n                    // No underlying set for cETH\n                    TokenStorage(address(0), false, TokenType.Ether),\n                    address(0),\n                    false,\n                    130, // Initial settings of 130 buffer\n                    70,  // 70% haircut\n                    105  // 105 liquidation discount\n                )\n            );\n        require(status);\n\n        owner = owner_;\n        // The pause guardian may downgrade the router to the pauseRouter\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n    }\n\n    /// @notice Returns the implementation contract for the method signature\n    /// @param sig method signature to call\n    /// @return implementation address\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        if (\n            sig == NotionalProxy.batchBalanceAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector\n        ) {\n            return BATCH_ACTION;\n        }\n\n        if (\n            sig == nTokenAction.nTokenTotalSupply.selector ||\n            sig == nTokenAction.nTokenBalanceOf.selector ||\n            sig == nTokenAction.nTokenTransferAllowance.selector ||\n            sig == nTokenAction.nTokenTransferApprove.selector ||\n            sig == nTokenAction.nTokenTransfer.selector ||\n            sig == nTokenAction.nTokenTransferFrom.selector ||\n            sig == nTokenAction.nTokenClaimIncentives.selector ||\n            sig == nTokenAction.nTokenTransferApproveAll.selector ||\n            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||\n            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector\n        ) {\n            return NTOKEN_ACTIONS;\n        }\n\n        if (\n            sig == NotionalProxy.depositUnderlyingToken.selector ||\n            sig == NotionalProxy.depositAssetToken.selector ||\n            sig == NotionalProxy.withdraw.selector ||\n            sig == NotionalProxy.settleAccount.selector ||\n            sig == NotionalProxy.enableBitmapCurrency.selector\n        ) {\n            return ACCOUNT_ACTION;\n        }\n\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector\n        ) {\n            return NTOKEN_REDEEM;\n        }\n\n        if (\n            sig == nERC1155Interface.supportsInterface.selector ||\n            sig == nERC1155Interface.balanceOf.selector ||\n            sig == nERC1155Interface.balanceOfBatch.selector ||\n            sig == nERC1155Interface.safeTransferFrom.selector ||\n            sig == nERC1155Interface.safeBatchTransferFrom.selector ||\n            sig == nERC1155Interface.decodeToAssets.selector ||\n            sig == nERC1155Interface.encodeToId.selector ||\n            sig == nERC1155Interface.setApprovalForAll.selector ||\n            sig == nERC1155Interface.isApprovedForAll.selector\n        ) {\n            return ERC1155;\n        }\n\n        if (\n            sig == NotionalProxy.liquidateLocalCurrency.selector ||\n            sig == NotionalProxy.liquidateCollateralCurrency.selector ||\n            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            sig == NotionalProxy.liquidatefCashLocal.selector ||\n            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||\n            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            sig == NotionalProxy.initializeMarkets.selector ||\n            sig == NotionalProxy.sweepCashIntoMarkets.selector\n        ) {\n            return INITIALIZE_MARKET;\n        }\n\n        if (\n            sig == NotionalGovernance.listCurrency.selector ||\n            sig == NotionalGovernance.enableCashGroup.selector ||\n            sig == NotionalGovernance.updateCashGroup.selector ||\n            sig == NotionalGovernance.updateAssetRate.selector ||\n            sig == NotionalGovernance.updateETHRate.selector ||\n            sig == NotionalGovernance.transferOwnership.selector ||\n            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||\n            sig == NotionalGovernance.updateDepositParameters.selector ||\n            sig == NotionalGovernance.updateInitializationParameters.selector ||\n            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||\n            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||\n            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||\n            sig == NotionalProxy.upgradeTo.selector ||\n            sig == NotionalProxy.upgradeToAndCall.selector\n        ) {\n            return GOVERNANCE;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n\n    // NOTE: receive() is overridden in \"nProxy\" to allow for eth transfers to succeed\n}\n\n\n",
        "CodeNames": [
            "nTokenAction.sol",
            "TokenHandler.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "false",
                    "success",
                    "setToken",
                    "ERC"
                ],
                "Type": "  TokenHandler.setToken  ERC20 missing return value check",
                "Description": "\nThe setToken function performs an ERC20.approve() call but does not check the success return value.\nSome tokens do not revert if the approval failed but return false instead.\n\nThe impact is that tokens that don't actually perform the approve and return false are still counted as a correct approve.\n\nWe recommend using OpenZeppelin\u2019s SafeERC20(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2021-08-notional-findings/issues/77)\n\n\n",
                "Repair": ""
            }
        ]
    }
]