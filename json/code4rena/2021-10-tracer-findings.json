[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\n// @audit \ud83d\udc47 this comment is not correct, it's in Quad units\n// tip percent in wad units\nbytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval));\n",
                    "//solidity\nABDKMathQuad.add(\n    ABDKMathQuad.fromUInt(_keeperGas),\n    // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100\n    ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100))\n)\n"
                ],
                "Type": " Wrong keeper reward computation",
                "Description": "\nThe PoolKeeper.keeperReward computation mixes WADs and Quads which leads to issues.\n\n1.  Note that keeperTip returns values where 1 = 1%, and 100 = 100%, the same way BASE_TIP = 5 = 5%. Thus _tipPercent = ABDKMathQuad.fromUInt(keeperTip) is a Quad value of this keeper tip, and not in \"wad units\" as the comment above it says.\n\nsolidity\n// @audit \ud83d\udc47 this comment is not correct, it's in Quad units\n// tip percent in wad units\nbytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval));\n\n\n2.  Now the wadRewardValue interprets _tipPercent as a WAD + Quad value which ultimately leads to significantly fewer keeper rewards:\n\nIt tries to compute _keeperGas + _keeperGas * _tipPercent and to compute _keeperGas * _tipPercent it does a wrong division by fixedPoint (1e18 as a quad value) because it thinks the _tipPercent is a WAD value (100%=1e18) as a quad, when indeed 100%=100. It seems like it should divide by 100 as a quad instead.\nsolidity\nABDKMathQuad.add(\n    ABDKMathQuad.fromUInt(_keeperGas),\n    // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100\n    ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100))\n)\n\n\nThe keeper rewards are off as the _keeperGas * _tipPercent is divided by 1e18 instead of 1e2.\nKeeper will just receive their _keeperGas cost but the tip part will be close to zero every time.\n\n",
                "Repair": "\nGenerally, I'd say the contract mixes quad and WAD units where it doesn't have to do it. Usually, you either use WAD or Quad math but not both at the same time.\nThis complicates the code.\nI'd make keeperTip()  return a byte16 Quad value as a percentage where 100% = ABDKMathQuad.fromUInt(1). This temporary float result can then be used in a different ABDKMathQuad computation.\n\nAlternatively, divide by 100 as a quad instead of 1e18 as a quad because _tipPercent is not a WAD value, but simply a percentage where 1 = 1%.\n\nsolidity\nABDKMathQuad.add(\n    ABDKMathQuad.fromUInt(_keeperGas),\n    // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100\n    ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100))\n)\n\n\nmynameuhh (Tracer) confirmed(https://github.com/code-423n4/2021-10-tracer-findings/issues/23)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/23#issuecomment-955087515):\n  Agree with the finding and its severity, great find.\n\n\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [],
                "Type": " Deposits don't work with fee-on transfer tokens",
                "Description": "\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom().\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).\n\n\nThe PoolCommiter.commit() function will store the entire amount in the commitment but with fee-on-transfer tokens, fewer tokens will be transferred which leads to inconsistencies with the pool.longBalance() and in uncommit.\n\n",
                "Repair": "\nOne possible mitigation is to measure the asset change right before and after the asset-transferring routines\n\n\nrogue developer (Tracer) disputed(https://github.com/code-423n4/2021-10-tracer-findings/issues/17#issuecomment-944009136):\n  Only governance (a multisig) can deploy markets, and has complete say over what markets can be deployed (see the onlyGov modifier in PoolFactory.sol#deployPool). Because new markets being deployed would be done via proposal to the DAO, which include the collateral token being used in a proposed market, markets with fee-on transfer tokens like Aave's aTokens just won't be deployed. I think this is a fairly safe assumption to make and thus we're making it out of scope. In any case, the chances of this happening and slipping past everyone who votes in the proposals _and_ not being noticed extremely soon after a market is deployed are extremely low.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/17#issuecomment-955088716):\n  I think this is a valid finding, the warden has shown a way to tamper with the protocol, extracting value (as such medium severity)\n \n In terms of mitigation, not using feeOnTransfer or rebasing tokens is completely legitimate.\n\n\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": "  uncommit  sends tokens to the wrong user",
                "Description": "\nThe PoolCommitter._uncommit function calls the ILeveragedPool(leveragedPool).quoteTokenTransfer/mintTokens function with msg.sender.\nBut in _uncommit's case that's the pool, not the commit owner, see onlyPool modifier on executeAllCommitments which calls _uncommit.\n\n\nUsers lose all tokens from their commitments as they are sent / minted to the pool instead.\n\n",
                "Repair": "\nInstead of msg.sender, use _commit.owner:\n\nsolidity\n// minting: return quote tokens to the commit owner\n// @audit msg.sender is pool, should be _commit.owner\nILeveragedPool(leveragedPool).quoteTokenTransfer(msg.sender, _commit.amount);\n// same with mint cases\n\n\nrogue developer (Tracer) disagreed with severity(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-945331001):\n  This is a valid issue. However, it requires there to be an underlying bug in the contracts which would make the executeCommitment call in executeAllCommitments revert (as _uncommit is only called in that case). If the warden can find a way for executeCommitment to revert, we would consider this to be an issue of this severity but otherwise we disagree with the severity as it requires/needs to be paired with another bug in the contracts.\n \n It's also worth noting that governance can rescue any funds (rather, quote/collateral tokens) from the LeveragedPool contract. So if there were to be a case where there was a bug in the contracts that led to executeCommitment reverting and the users having their mints (quote tokens sent back to the LeveragedPool), governance could pause the contracts, drain out the equivalent worth and set up another contract where users can burn their tokens/claim them; if they burned the tokens which later uncommitted, then governance could send them an equal amount in collateral tokens. On the same note, if a critical vulnerability in executeCommitment were to be happening whereby commits were being uncommitted, then governance could also pause the contracts, rescue the funds and do some combination of the efforts above to ensure users get the funds back securely.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955094840):\n  Would setting up a commit such that this line will underflow\n https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolCommitter.sol#L305\n , causing a revert, be a way to cause the function to call _uncommit ?\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955095206):\n  Also, to clarify, you're saying you believe the code will never call _uncommit as it won't ever revert, right?\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955097577):\n  At this time I believe that if a user mistakenly commits more than the value in shadowPools[_commitType] they can cause a silent revert which will trigger the bug\n \n I think only their own funds are at risk, and either passing along the original committer or storing it in the commitData would allow to safely return them their funds.\n \n With the information I have this issue sits between medium and high severity, high severity because user funds are at risk, medium because:\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n As of now I'll mark as medium and valid.\n \n Will think it over the weekend\n \n If the sponsor can let me know their take and reply to the questions above, that can help clarify the severity and validity\n\nrogue developer (Tracer) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955099303):\n   Would setting up a commit such that this line will underflow https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolCommitter.sol#L305 , causing a revert, be a way to cause the function to call _uncommit ?\n \n @Alex the Entreprenerd No. shadowPools is a mapping of commit types to the sum of pool tokens to be burned (rather, to be executed because they've already been burned), or sum of collateral tokens to be used in minting that haven't been used for minting yet. executeCommitment can only be called on Commit's, which are in the commits mapping, which can only be added to via the commit function where users have to commit to putting up collateral/burning their pool tokens, which is the function that increments shadowPools. I realise that sounds a bit convoluted, but basically executeCommitment and its _commit parameter has a direct dependency on users committing via the commit function, which increments shadowPools by the value of their commit (which they can't game -their collateral tokens get sent to the LeveragedPool contract instantly and their tokens get burned instantly and they don't have access to those funds anymore). \n \n  Also, to clarify, you're saying you believe the code will never call _uncommit as it won't ever revert, right?\n \n Yes, that's right. It is there as a fail-safe (so that if there was some bug in a commit that stopped a commit in the queue from being executed, it wouldn't stop the markets). We are refactoring this code nonetheless though.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955101993):\n  Alright from this information I understand that the underflow idea can't happen (gas optimization there would be to use unsafe operations I guess)\n \n I think given the system a refactoring to send the funds back is warranted\n \n That said the fact that there seems to be no way to get a revert excludes the high severity.\n \n That leaves us with the finding either being med or low risk\n \n Low risk would be acceptable as the code doesn't work as it suggests (_uncommit is never executed, and if it did it wouldn't reimburse the user)\n \n The alternative take is Medium: if _uncommit where executed it would cause in a loss of funds / funds stuck\n \n As of now I'll leave it as med, while we don't have a way to trigger _uncommit we can still make the claim that if _uncommit where to run, it wouldn't reimburse the user\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955108907):\n  Going a little deeper for the sake of clarity:\n \n The math library is programmed to never revert:\n https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolSwapLibrary.sol#L256\n \n The amounts in commit are always greater than 0 so no revert there\n \n \n The pool.setter is innocuous\n \n The only thing I found is the pool.quoteTokenTransfer(_commit.owner, amountOut);\n \n If for an unfortunate reason the pool is drained from the quoteToken and the safeTransfer fail, then the function would revert\n \n \n On that note the way to perform this would be to use\n     function setKeeper(address _keeper) external override onlyGov onlyUnpaused {\n To change the keeper to a EOA / Malicious account\n \n And then run\n function payKeeperFromBalances(address to, uint256 amount)\n with the full amount (or close to it) of amount <= shortBalance + longBalance\n \n This seems to be a permissioned way (admin privilege) to rug funds from the LeveragedPool as well as enabling the _uncommit to be triggered\n \n Given these findings (which I may misunderstand, so feel free to correct me) I highly recommend the sponsor to ensure there's a timelock for changing keeper\n Additionally (and I may be missing something) allowing payKeeperFromBalances to take an indiscriminate amount of funds may prove to be a rug vector the sponsor should consider eliminating.\n \n I'm fairly confident the math library(https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.sol) will never revert, even if you input a high fee, which means that while the end state may be unexpected, the function can be used to rug.\n \n Highly recommend the sponsor to consider having caps on the amount parameter for payKeeperFromBalances(https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L111) as this function seems to be the way to break the protocol (and the trust of the users)\n \n\nrogue developer (Tracer) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955112942):\n  @Alex the Entreprenerd Yep, that's completely right. However (and this is something we should have made clear in an assumptions section), all markets will be deployed by the DAO/DAO multisig. You can see that the payKeeperFromBalances function has a modifier called onlyGov -meaning only governance (the DAO/DAO multisig) can change this and that's something that's immutable and can't be changed. Governance also has the ability to take quote tokens out of the LeveragedPool contract (with withdrawQuote) unlike the hack with changing the keeper (more directly this way) but we've been going under the assumption that the only reason we'd do this is in the rescue of user funds in the case of some hack. \n \n If the governance multisig is compromised, they have the ability to do a lot of damage but we've been going under the assumption this just won't be the case, which I think is a safe one to make. So you're right in that uncommit can send tokens to the wrong user in case the function reverts because of governance draining funds directly or via setting a malicious keeper, but I think that uncommit sending tokens to the wrong user is the least of problems if that happens because governance would only ever drain funds in the case of a major hack. If we're going under the assumption that the multisig _can_ easily be compromised, then the \"centralisation\" point around the DAO would be a much bigger point. \n \n I still think this should be a low/information by virtue of the fact that unless there is an underlying bug in the contracts, uncommit can't be called (it may as well be dead code) -if it gets called because governance has rugged, that is then relatively a fairly small problem because all the funds would be at risk in a much more direct way in that case.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955115864):\n  @rogue developer agree that if governance is malicious, the _uncommit path is the least problem\n \n One thing to note is that the keeper has the ability of trying to claim a lot of fees, and the modifier seems to be onlyKeeper if the keeper were to be a bot, or a human operator they would have the ability of rugging, unless the parameter amount was under some check (let's say less than 1% AUM or something)\n \n I agree that you can set to the PoolKeeper contract which seems safe, once potential rug vector, again from governance would be to inject a high gasPrice via setGasPrice which as a onlyOwner modifier\n \n Contract for PoolKeeper:\n https://arbiscan.io/address/0x759E817F0C40B11C775d1071d466B5ff5c6ce28e#code\n \n The owner is the Dev Multisig:\n https://arbiscan.io/address/0x0f79e82ae88e1318b8cfc8b4a205fe2f982b928a#readContract\n \n This does give the Dev Multisig admin privileges and a potential for griefing at the very least if not rugging, as they could raise the gas price, and then run performUpkeepSinglePool which would eventually call payKeeperFromBalances\n \n That said, this is something I'm flagging up right now and outside of the contest\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955116449):\n  As per the finding at this point I believe it's valid and at medium severity, it is not high severity due to need for existing preconditions that are not \"usual\", see definition from Gitbook:\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n We can agree that the pre-condition here are drastic and this finding would be the last of the protocols problems\n \n In terms of mitigation, ensuring that the funds are send back to the address that initiated the commit are more than sufficient\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955116649):\n  Per the \"multisig privileges\" above, I recommend you replace owner on the poolKeeper with a TimeLock as in it's current state, the gasPrice may be a way to rug funds from depositors\n\n\n"
            }
        ]
    }
]