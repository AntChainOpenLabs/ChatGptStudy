[
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../libraries/AccountMigrationLibrary.sol\";\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./NFTMarketAuction.sol\";\nimport \"./NFTMarketCore.sol\";\nimport \"./NFTMarketFees.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @param minAmount The minimum amount that must be bid in order for it to be accepted.\nerror NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);\nerror NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n/// @param reservePrice The current reserve price.\nerror NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);\n/// @param endTime The timestamp at which the auction had ended.\nerror NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);\nerror NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n/// @param endTime The timestamp at which the auction will end.\nerror NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);\n/// @param seller The current owner of the NFT.\nerror NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);\nerror NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\nerror NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.\nerror NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);\n/// @param extensionDuration The extension duration, in seconds.\nerror NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);\nerror NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n/// @param seller The current owner of the NFT.\nerror NFTMarketReserveAuction_Not_Matching_Seller(address seller);\n/// @param owner The current owner of the NFT.\nerror NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);\nerror NFTMarketReserveAuction_Too_Much_Value_Provided();\n\n/**\n * @title Allows the owner of an NFT to list it in auction.\n * @notice NFTs in auction are escrowed in the market contract.\n * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.\n * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.\n */\nabstract contract NFTMarketReserveAuction is\n  Constants,\n  FoundationTreasuryNode,\n  NFTMarketCore,\n  ReentrancyGuardUpgradeable,\n  SendValueWithFallbackWithdraw,\n  NFTMarketFees,\n  NFTMarketAuction\n{\n  using AccountMigrationLibrary for address;\n\n  /// @notice Stores the auction configuration for a specific NFT.\n  struct ReserveAuction {\n    /// @notice The address of the NFT contract.\n    address nftContract;\n    /// @notice The id of the NFT.\n    uint256 tokenId;\n    /// @notice The owner of the NFT which listed it in auction.\n    address payable seller;\n    /// @notice The duration for this auction.\n    uint256 duration;\n    /// @notice The extension window for this auction.\n    uint256 extensionDuration;\n    /// @notice The time at which this auction will not accept any new bids.\n    /// @dev This is `0` until the first bid is placed.\n    uint256 endTime;\n    /// @notice The current highest bidder in this auction.\n    /// @dev This is `address(0)` until the first bid is placed.\n    address payable bidder;\n    /// @notice The latest price of the NFT in this auction.\n    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.\n    uint256 amount;\n  }\n\n  /// @notice The auction configuration for a specific auction id.\n  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;\n  /// @notice The auction id for a specific NFT.\n  /// @dev This is deleted when an auction is finalized or canceled.\n  mapping(uint256 => ReserveAuction) private auctionIdToAuction;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private __gap_was_minPercentIncrementInBasisPoints;\n   * uint256 private __gap_was_maxBidIncrementRequirement;\n   * uint256 private __gap_was_duration;\n   * uint256 private __gap_was_extensionDuration;\n   * uint256 private __gap_was_goLiveDate;\n   */\n  uint256[5] private __gap_was_config;\n\n  /// @notice How long an auction lasts for once the first bid has been received.\n  uint256 private immutable DURATION;\n\n  /// @notice The window for auction extensions, any bid placed in the final 15 minutes\n  /// of an auction will reset the time remaining to 15 minutes.\n  uint256 private constant EXTENSION_DURATION = 15 minutes;\n\n  /// @notice Caps the max duration that may be configured so that overflows will not occur.\n  uint256 private constant MAX_MAX_DURATION = 1000 days;\n\n  /**\n   * @notice Emitted when a bid is placed.\n   * @param auctionId The id of the auction this bid was for.\n   * @param bidder The address of the bidder.\n   * @param amount The amount of the bid.\n   * @param endTime The new end time of the auction (which may have been set or extended by this bid).\n   */\n  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);\n  /**\n   * @notice Emitted when an auction is cancelled.\n   * @dev This is only possible if the auction has not received any bids.\n   * @param auctionId The id of the auction that was cancelled.\n   */\n  event ReserveAuctionCanceled(uint256 indexed auctionId);\n  /**\n   * @notice Emitted when an auction is canceled by a Foundation admin.\n   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.\n   * @param auctionId The id of the auction that was cancelled.\n   * @param reason The reason for the cancellation.\n   */\n  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);\n  /**\n   * @notice Emitted when an NFT is listed for auction.\n   * @param seller The address of the seller.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param duration The duration of the auction (always 24-hours).\n   * @param extensionDuration The duration of the auction extension window (always 15-minutes).\n   * @param reservePrice The reserve price to kick off the auction.\n   * @param auctionId The id of the auction that was created.\n   */\n  event ReserveAuctionCreated(\n    address indexed seller,\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    uint256 duration,\n    uint256 extensionDuration,\n    uint256 reservePrice,\n    uint256 auctionId\n  );\n  /**\n   * @notice Emitted when an auction that has already ended is finalized,\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\n   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param auctionId The id of the auction that was finalized.\n   * @param seller The address of the seller.\n   * @param bidder The address of the highest bidder that won the NFT.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event ReserveAuctionFinalized(\n    uint256 indexed auctionId,\n    address indexed seller,\n    address indexed bidder,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev\n  );\n  /**\n   * @notice Emitted when an auction is invalidated due to other market activity.\n   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.\n   * @param auctionId The id of the auction that was invalidated.\n   */\n  event ReserveAuctionInvalidated(uint256 indexed auctionId);\n  /**\n   * @notice Emitted when the seller for an auction has been changed to a new account.\n   * @dev Account migrations require approval from both the original account and Foundation.\n   * @param auctionId The id of the auction that was updated.\n   * @param originalSellerAddress The original address of the auction's seller.\n   * @param newSellerAddress The new address for the auction's seller.\n   */\n  event ReserveAuctionSellerMigrated(\n    uint256 indexed auctionId,\n    address indexed originalSellerAddress,\n    address indexed newSellerAddress\n  );\n  /**\n   * @notice Emitted when the auction's reserve price is changed.\n   * @dev This is only possible if the auction has not received any bids.\n   * @param auctionId The id of the auction that was updated.\n   * @param reservePrice The new reserve price for the auction.\n   */\n  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);\n\n  /// @notice Confirms that the reserve price is not zero.\n  modifier onlyValidAuctionConfig(uint256 reservePrice) {\n    if (reservePrice == 0) {\n      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n    }\n    _;\n  }\n\n  /**\n   * @notice Configures the duration for auctions.\n   * @param duration The duration for auctions, in seconds.\n   */\n  constructor(uint256 duration) {\n    if (duration > MAX_MAX_DURATION) {\n      // This ensures that math in this file will not overflow due to a huge duration.\n      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);\n    }\n    if (duration < EXTENSION_DURATION) {\n      // The auction duration configuration must be greater than the extension window of 15 minutes\n      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);\n    }\n    DURATION = duration;\n  }\n\n  /**\n   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to\n   * the seller (if not active buy price set).\n   * This should only be used for extreme cases such as DMCA takedown requests.\n   * @param auctionId The id of the auction to cancel.\n   * @param reason The reason for the cancellation (a required field).\n   */\n  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)\n    external\n    onlyFoundationAdmin\n    nonReentrant\n  {\n    if (bytes(reason).length == 0) {\n      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n    }\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.amount == 0) {\n      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\n    }\n\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Return the NFT to the owner.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    if (auction.bidder != address(0)) {\n      // Refund the highest bidder if any bids were placed in this auction.\n      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionCanceledByAdmin(auctionId, reason);\n  }\n\n  /**\n   * @notice Allows an NFT owner and Foundation to work together in order to update the seller\n   * for auctions they have listed to a new account.\n   * @dev This will gracefully skip any auctions that have already been finalized.\n   * @param listedAuctionIds The ids of the auctions to update.\n   * @param originalAddress The original address of the seller of these auctions.\n   * @param newAddress The new address for the seller of these auctions.\n   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\n   * signed by the original account.\n   */\n  function adminAccountMigration(\n    uint256[] calldata listedAuctionIds,\n    address originalAddress,\n    address payable newAddress,\n    bytes memory signature\n  ) external onlyFoundationOperator {\n    // Validate the owner of the original account has approved this change.\n    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);\n\n    unchecked {\n      // The array length cannot overflow 256 bits.\n      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {\n        uint256 auctionId = listedAuctionIds[i];\n        ReserveAuction storage auction = auctionIdToAuction[auctionId];\n        if (auction.seller != address(0)) {\n          // Only if the auction was found and not finalized before this transaction.\n\n          if (auction.seller != originalAddress) {\n            // Confirm that the signature approval was the correct owner of this auction.\n            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);\n          }\n\n          // Update the auction's seller address.\n          auction.seller = newAddress;\n\n          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\n   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.\n   * @param auctionId The id of the auction to cancel.\n   */\n  function cancelReserveAuction(uint256 auctionId) external nonReentrant {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    }\n    if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n\n    // Remove the auction.\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Transfer the NFT unless it still has a buy price set.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    emit ReserveAuctionCanceled(auctionId);\n  }\n\n  /**\n   * @notice Creates an auction for the given NFT.\n   * The NFT is held in escrow until the auction is finalized or canceled.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param reservePrice The initial reserve price for the auction.\n   */\n  function createReserveAuction(\n    address nftContract,\n    uint256 tokenId,\n    uint256 reservePrice\n  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {\n    uint256 auctionId = _getNextAndIncrementAuctionId();\n\n    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.\n    _transferToEscrow(nftContract, tokenId);\n\n    // Store the auction details\n    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;\n    auctionIdToAuction[auctionId] = ReserveAuction(\n      nftContract,\n      tokenId,\n      payable(msg.sender),\n      DURATION,\n      EXTENSION_DURATION,\n      0, // endTime is only known once the reserve price is met\n      payable(0), // bidder is only known once a bid has been placed\n      reservePrice\n    );\n\n    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);\n  }\n\n  /**\n   * @notice Once the countdown has expired for an auction, anyone can settle the auction.\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\n   * @param auctionId The id of the auction to settle.\n   */\n  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {\n    if (auctionIdToAuction[auctionId].endTime == 0) {\n      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n    }\n    _finalizeReserveAuction(auctionId, false);\n  }\n\n  /**\n   * @notice Place a bid in an auction.\n   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.\n   * If this is the first bid on the auction, the countdown will begin.\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\n   * @param auctionId The id of the auction to bid on.\n   */\n  function placeBid(uint256 auctionId) external payable {\n    placeBidOf(auctionId, msg.value);\n  }\n\n  /**\n   * @notice Place a bid in an auction.\n   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.\n   * If this is the first bid on the auction, the countdown will begin.\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\n   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.\n   * @param auctionId The id of the auction to bid on.\n   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {\n    if (amount < msg.value) {\n      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.\n      revert NFTMarketReserveAuction_Too_Much_Value_Provided();\n    } else if (amount > msg.value) {\n      // Withdraw additional ETH required from their available FETH balance.\n\n      unchecked {\n        // The if above ensures delta will not underflow.\n        uint256 delta = amount - msg.value;\n\n        // Withdraw ETH from the buyer's account in the FETH token contract.\n        feth.marketWithdrawFrom(msg.sender, delta);\n      }\n    }\n\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n\n    if (auction.amount == 0) {\n      // No auction found\n      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\n    }\n\n    if (auction.endTime == 0) {\n      // This is the first bid, kicking off the auction.\n\n      if (auction.amount > amount) {\n        // The bid must be >= the reserve price.\n        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);\n      }\n\n      // Notify other market tools that an auction for this NFT has been kicked off.\n      _afterAuctionStarted(auction.nftContract, auction.tokenId);\n\n      // Store the bid details.\n      auction.amount = amount;\n      auction.bidder = payable(msg.sender);\n\n      // On the first bid, set the endTime to now + duration.\n      unchecked {\n        // Duration is always set to 24hrs so the below can't overflow.\n        auction.endTime = block.timestamp + auction.duration;\n      }\n    } else {\n      if (auction.endTime < block.timestamp) {\n        // The auction has already ended.\n        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);\n      } else if (auction.bidder == msg.sender) {\n        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.\n        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\n      } else if (amount < _getMinIncrement(auction.amount)) {\n        // If this bid outbids another, it must be at least 10% greater than the last bid.\n        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));\n      }\n\n      // Cache and update bidder state\n      uint256 originalAmount = auction.amount;\n      address payable originalBidder = auction.bidder;\n      auction.amount = amount;\n      auction.bidder = payable(msg.sender);\n\n      unchecked {\n        // When a bid outbids another, check to see if a time extension should apply.\n        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.\n        if (auction.endTime - block.timestamp < auction.extensionDuration) {\n          // Current time plus extension duration (always 15 mins) cannot overflow.\n          auction.endTime = block.timestamp + auction.extensionDuration;\n        }\n      }\n\n      // Refund the previous bidder\n      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);\n  }\n\n  /**\n   * @notice If an auction has been created but has not yet received bids, the reservePrice may be\n   * changed by the seller.\n   * @param auctionId The id of the auction to change.\n   * @param reservePrice The new reserve price for this auction.\n   */\n  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    } else if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n\n    // Update the current reserve price.\n    auction.amount = reservePrice;\n\n    emit ReserveAuctionUpdated(auctionId, reservePrice);\n  }\n\n  /**\n   * @notice Settle an auction that has already ended.\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\n   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding\n   * redundant transfers if the NFT should remain in escrow, such as when the new owner\n   * sets a buy price or lists it in a new auction.\n   */\n  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n\n    if (auction.endTime >= block.timestamp) {\n      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);\n    }\n\n    // Remove the auction.\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    if (!keepInEscrow) {\n      /*\n       * Save gas by calling core directly since it cannot have another escrow requirement\n       * (buy price set or another auction listed) until this one has been finalized.\n       */\n      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));\n    }\n\n    // Distribute revenue for this sale.\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      auction.nftContract,\n      auction.tokenId,\n      auction.seller,\n      auction.amount\n    );\n\n    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev If an auction is found:\n   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.\n   *  - If the auction has not received a bid, it will invalidate the auction.\n   *  - If the auction is in progress, this will revert.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n  ) internal virtual override {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    if (auctionId != 0) {\n      ReserveAuction storage auction = auctionIdToAuction[auctionId];\n      if (auction.endTime == 0) {\n        // The auction has not received any bids yet so it may be invalided.\n\n        if (auction.seller != seller) {\n          // The account trying to transfer the NFT is not the current owner.\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\n        }\n\n        // Remove the auction.\n        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];\n        delete auctionIdToAuction[auctionId];\n\n        emit ReserveAuctionInvalidated(auctionId);\n      } else {\n        // If the auction has started, the highest bidder will be the new owner.\n\n        if (auction.bidder != seller) {\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\n        }\n\n        // Finalization will revert if the auction has not yet ended.\n        _finalizeReserveAuction(auctionId, false);\n\n        // Finalize includes the transfer, so we are done here.\n        return;\n      }\n    }\n\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.\n   */\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal virtual override {\n    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {\n      // No auction was found\n\n      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\n    }\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    if (auctionId == 0) {\n      // NFT is not in auction\n      super._transferToEscrow(nftContract, tokenId);\n      return;\n    }\n    // Using storage saves gas since most of the data is not needed\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.endTime == 0) {\n      // Reserve price set, confirm the seller is a match\n      if (auction.seller != msg.sender) {\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\n      }\n    } else {\n      // Auction in progress, confirm the highest bidder is a match\n      if (auction.bidder != msg.sender) {\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\n      }\n\n      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended\n      _finalizeReserveAuction(auctionId, true);\n    }\n  }\n\n  /**\n   * @notice Returns the minimum amount a bidder must spend to participate in an auction.\n   * Bids must be greater than or equal to this value or they will revert.\n   * @param auctionId The id of the auction to check.\n   * @return minimum The minimum amount for a bid to be accepted.\n   */\n  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.endTime == 0) {\n      return auction.amount;\n    }\n    return _getMinIncrement(auction.amount);\n  }\n\n  /**\n   * @notice Returns auction details for a given auctionId.\n   * @param auctionId The id of the auction to lookup.\n   * @return auction The auction details.\n   */\n  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {\n    return auctionIdToAuction[auctionId];\n  }\n\n  /**\n   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.\n   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @return auctionId The id of the auction, or 0 if no auction is found.\n   */\n  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {\n    return nftContractToTokenIdToAuctionId[nftContract][tokenId];\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Returns the seller that has the given NFT in escrow for an auction,\n   * or bubbles the call up for other considerations.\n   */\n  function _getSellerFor(address nftContract, uint256 tokenId)\n    internal\n    view\n    virtual\n    override\n    returns (address payable seller)\n  {\n    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;\n    if (seller == address(0)) {\n      seller = super._getSellerFor(nftContract, tokenId);\n    }\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./mixins/Constants.sol\";\nimport \"./mixins/FoundationTreasuryNode.sol\";\nimport \"./mixins/NFTMarketAuction.sol\";\nimport \"./mixins/NFTMarketBuyPrice.sol\";\nimport \"./mixins/NFTMarketCore.sol\";\nimport \"./mixins/NFTMarketCreators.sol\";\nimport \"./mixins/NFTMarketFees.sol\";\nimport \"./mixins/NFTMarketOffer.sol\";\nimport \"./mixins/NFTMarketPrivateSale.sol\";\nimport \"./mixins/NFTMarketReserveAuction.sol\";\nimport \"./mixins/SendValueWithFallbackWithdraw.sol\";\n\n/**\n * @title A market for NFTs on Foundation.\n * @notice The Foundation marketplace is a contract which allows traders to buy and sell NFTs.\n * It supports buying and selling via auctions, private sales, buy price, and offers.\n * @dev All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific\n * to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was\n * originally deployed, it may be added using the [Royalty Registry](https://royaltyregistry.xyz/) which will be\n * respected by our market contract.\n */\ncontract FNDNFTMarket is\n  Constants,\n  Initializable,\n  FoundationTreasuryNode,\n  NFTMarketCore,\n  ReentrancyGuardUpgradeable,\n  NFTMarketCreators,\n  SendValueWithFallbackWithdraw,\n  NFTMarketFees,\n  NFTMarketAuction,\n  NFTMarketReserveAuction,\n  NFTMarketPrivateSale,\n  NFTMarketBuyPrice,\n  NFTMarketOffer\n{\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   */\n  constructor(\n    address payable treasury,\n    address feth,\n    address royaltyRegistry,\n    uint256 duration,\n    address marketProxyAddress\n  )\n    FoundationTreasuryNode(treasury)\n    NFTMarketCore(feth)\n    NFTMarketCreators(royaltyRegistry)\n    NFTMarketReserveAuction(duration)\n    NFTMarketPrivateSale(marketProxyAddress) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called once to configure the contract after the initial proxy deployment.\n   * @dev This farms the initialize call out to inherited contracts as needed to initialize mutable variables.\n   */\n  function initialize() external initializer {\n    NFTMarketAuction._initializeNFTMarketAuction();\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _afterAuctionStarted(address nftContract, uint256 tokenId)\n    internal\n    override(NFTMarketCore, NFTMarketBuyPrice, NFTMarketOffer)\n  {\n    super._afterAuctionStarted(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n  ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice) {\n    super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _transferToEscrow(address nftContract, uint256 tokenId)\n    internal\n    override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice)\n  {\n    super._transferToEscrow(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _getSellerFor(address nftContract, uint256 tokenId)\n    internal\n    view\n    override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice)\n    returns (address payable seller)\n  {\n    return super._getSellerFor(nftContract, tokenId);\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTMarketReserveAuction.sol",
            "FNDNFTMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "nftContractToTokenIdToAuctionId[nftContract][tokenId]",
                    "_transferToEscrow",
                    "createReserveAuction"
                ],
                "Type": " NFT owner can create multiple auctions",
                "Description": "\nNFTMarketReserveAuction.sol#L325-L349(https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L325-L349)<br\nNFTMarketReserveAuction.sol#L596-L599(https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L596-L599)<br\n\nNFT owner can permanently lock funds of bidders.\n\n\nAlice (the attacker) calls createReserveAuction, and creates one like normal. let this be auction id 1.\n\nAlice calls createReserveAuction again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because _transferToEscrow doesn't revert if there's an existing auction. let this be Auction id 2.\n\nSince nftContractToTokenIdToAuctionId[nftContract][tokenId] will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).\n\nAlice can now cancel auction id 1, then cancel auction id 2, locking up the funds of the last bidder on auction id 2 forever.\n\n",
                "Repair": "\nPrevent NFT owners from creating multiple auctions.\n\nNickCuso (Foundation) confirmed and commented(https://github.com/code-423n4/2022-02-foundation-findings/issues/23#issuecomment-1054614690):\n  This is a great find!\n \n The impact of this bug is:\n  Bidder's funds are stuck in escrow in an unrecoverable way without an upgrade, and even with an upgrade it would have been non-trivial to offer a migration path to recover the funds (but it would have been possible to recover correctly).\n  It allows sellers to stop the clock and/or back out of an auction. Normally once a bid is received we do not allow the seller to cancel the auction. With this bug, they could have created a new auction and then cancel that in order to back out of the deal entirely. This violates trust with collectors.\n \n We have fixed this problem by adding the following code to createReserveAuction:\n \n solidity\n     // This check must be after _transferToEscrow in case auto-settle was required\n     if (nftContractToTokenIdToAuctionId[nftContract][tokenId] != 0) {\n       revert NFTMarketReserveAuction_Already_Listed(nftContractToTokenIdToAuctionId[nftContract][tokenId]);\n     }\n \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @title Constant values shared across mixins.\n */\nabstract contract Constants {\n  /**\n   * @notice 100% in basis points.\n   */\n  uint256 internal constant BASIS_POINTS = 10000;\n\n  /**\n   * @notice Cap the number of royalty recipients to 5.\n   * @dev A cap is required to ensure gas costs are not too high when a sale is settled.\n   */\n  uint256 internal constant MAX_ROYALTY_RECIPIENTS_INDEX = 4;\n\n  /**\n   * @notice The minimum increase of 10% required when making an offer or placing a bid.\n   */\n  uint256 internal constant MIN_PERCENT_INCREMENT_IN_BASIS_POINTS = 1000;\n\n  /**\n   * @notice The gas limit used when making external read-only calls.\n   * @dev This helps to ensure that external calls does not prevent the market from executing.\n   */\n  uint256 internal constant READ_ONLY_GAS_LIMIT = 40000;\n\n  /**\n   * @notice The gas limit to send ETH to multiple recipients, enough for a 5-way split.\n   */\n  uint256 internal constant SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210000;\n\n  /**\n   * @notice The gas limit to send ETH to a single recipient, enough for a contract with a simple receiver.\n   */\n  uint256 internal constant SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20000;\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = \"Foundation Wrapped Ether\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] < amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance < delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./Constants.sol\";\nimport \"./NFTMarketCore.sol\";\nimport \"./NFTMarketFees.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @param buyPrice The current buy price set for this NFT.\nerror NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price(uint256 buyPrice);\nerror NFTMarketBuyPrice_Cannot_Buy_Unset_Price();\nerror NFTMarketBuyPrice_Cannot_Cancel_Unset_Price();\n/// @param owner The current owner of this NFT.\nerror NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price(address owner);\n/// @param owner The current owner of this NFT.\nerror NFTMarketBuyPrice_Only_Owner_Can_Set_Price(address owner);\nerror NFTMarketBuyPrice_Price_Too_High();\n/// @param seller The current owner of this NFT.\nerror NFTMarketBuyPrice_Seller_Mismatch(address seller);\n\n/**\n * @title Allows sellers to set a buy price of their NFTs that may be accepted and instantly transferred to the buyer.\n * @notice NFTs with a buy price set are escrowed in the market contract.\n */\nabstract contract NFTMarketBuyPrice is NFTMarketCore, NFTMarketFees {\n  using AddressUpgradeable for address payable;\n\n  /// @notice Stores the buy price details for a specific NFT.\n  /// @dev The struct is packed into a single slot to optimize gas.\n  struct BuyPrice {\n    /// @notice The current owner of this NFT which set a buy price.\n    /// @dev A zero price is acceptable so a non-zero address determines whether a price has been set.\n    address payable seller;\n    /// @notice The current buy price set for this NFT.\n    uint96 price;\n  }\n\n  /// @notice Stores the current buy price for each NFT.\n  mapping(address => mapping(uint256 => BuyPrice)) private nftContractToTokenIdToBuyPrice;\n\n  /**\n   * @notice Emitted when an NFT is bought by accepting the buy price,\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\n   * @dev The total buy price that was accepted is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyer The address of the collector that purchased the NFT using `buy`.\n   * @param seller The address of the seller which originally set the buy price.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event BuyPriceAccepted(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address indexed seller,\n    address buyer,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev\n  );\n  /**\n   * @notice Emitted when the buy price is removed by the owner of an NFT.\n   * @dev The NFT is transferred back to the owner unless it's still escrowed for another market tool,\n   * e.g. listed for sale in an auction.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   */\n  event BuyPriceCanceled(address indexed nftContract, uint256 indexed tokenId);\n  /**\n   * @notice Emitted when a buy price is invalidated due to other market activity.\n   * @dev This occurs when the buy price is no longer eligible to be accepted,\n   * e.g. when a bid is placed in an auction for this NFT.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   */\n  event BuyPriceInvalidated(address indexed nftContract, uint256 indexed tokenId);\n  /**\n   * @notice Emitted when a buy price is set by the owner of an NFT.\n   * @dev The NFT is transferred into the market contract for escrow unless it was already escrowed,\n   * e.g. for auction listing.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param seller The address of the NFT owner which set the buy price.\n   * @param price The price of the NFT.\n   */\n  event BuyPriceSet(address indexed nftContract, uint256 indexed tokenId, address indexed seller, uint256 price);\n\n  /**\n   * @notice Buy the NFT at the set buy price.\n   * `msg.value` must be <= `maxPrice` and any delta will be taken from the account's available FETH balance.\n   * @dev `maxPrice` protects the buyer in case a the price is increased but allows the transaction to continue\n   * when the price is reduced (and any surplus funds provided are refunded).\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param maxPrice The maximum price to pay for the NFT.\n   */\n  function buy(\n    address nftContract,\n    uint256 tokenId,\n    uint256 maxPrice\n  ) external payable {\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    if (buyPrice.price > maxPrice) {\n      revert NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price(buyPrice.price);\n    } else if (buyPrice.seller == address(0)) {\n      revert NFTMarketBuyPrice_Cannot_Buy_Unset_Price();\n    }\n\n    _buy(nftContract, tokenId);\n  }\n\n  /**\n   * @notice Removes the buy price set for an NFT.\n   * @dev The NFT is transferred back to the owner unless it's still escrowed for another market tool,\n   * e.g. listed for sale in an auction.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   */\n  function cancelBuyPrice(address nftContract, uint256 tokenId) external nonReentrant {\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    if (buyPrice.seller == address(0)) {\n      // This check is redundant with the next one, but done in order to provide a more clear error message.\n      revert NFTMarketBuyPrice_Cannot_Cancel_Unset_Price();\n    } else if (buyPrice.seller != msg.sender) {\n      revert NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price(buyPrice.seller);\n    }\n\n    // Remove the buy price\n    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n\n    // Transfer the NFT back to the owner if it is not listed in auction.\n    _transferFromEscrowIfAvailable(nftContract, tokenId, msg.sender);\n\n    emit BuyPriceCanceled(nftContract, tokenId);\n  }\n\n  /**\n   * @notice Sets the buy price for an NFT and escrows it in the market contract.\n   * @dev If there is an offer for this amount or higher, that will be accepted instead of setting a buy price.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param price The price at which someone could buy this NFT.\n   */\n  function setBuyPrice(\n    address nftContract,\n    uint256 tokenId,\n    uint256 price\n  ) external nonReentrant {\n    // If there is a valid offer at this price or higher, accept that instead.\n    if (_autoAcceptOffer(nftContract, tokenId, price)) {\n      return;\n    }\n\n    if (price > type(uint96).max) {\n      // This ensures that no data is lost when storing the price as `uint96`.\n      revert NFTMarketBuyPrice_Price_Too_High();\n    }\n\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n\n    // Store the new price for this NFT.\n    buyPrice.price = uint96(price);\n\n    if (buyPrice.seller == address(0)) {\n      // Transfer the NFT into escrow, if it's already in escrow confirm the `msg.sender` is the owner.\n      _transferToEscrow(nftContract, tokenId);\n\n      // The price was not previously set for this NFT, store the seller.\n      buyPrice.seller = payable(msg.sender);\n    } else if (buyPrice.seller != msg.sender) {\n      // Buy price was previously set by a different user\n      revert NFTMarketBuyPrice_Only_Owner_Can_Set_Price(buyPrice.seller);\n    }\n\n    emit BuyPriceSet(nftContract, tokenId, msg.sender, price);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Invalidates the buy price on a auction start, if one is found.\n   */\n  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    if (buyPrice.seller != address(0)) {\n      // A buy price was set for this NFT, invalidate it.\n      _invalidateBuyPrice(nftContract, tokenId);\n    }\n    super._afterAuctionStarted(nftContract, tokenId);\n  }\n\n  /**\n   * @notice If there is a buy price at this price or lower, accept that and return true.\n   */\n  function _autoAcceptBuyPrice(\n    address nftContract,\n    uint256 tokenId,\n    uint256 maxPrice\n  ) internal override returns (bool) {\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    if (buyPrice.seller == address(0) || buyPrice.price > maxPrice) {\n      // No buy price was found, or the price is too high.\n      return false;\n    }\n\n    _buy(nftContract, tokenId);\n    return true;\n  }\n\n  /**\n   * @notice Process the purchase of an NFT at the current buy price.\n   * @dev The caller must confirm that the seller != address(0) before calling this function.\n   */\n  function _buy(address nftContract, uint256 tokenId) private nonReentrant {\n    BuyPrice memory buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n\n    // Remove the buy now price\n    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n\n    if (buyPrice.price > msg.value) {\n      // Withdraw additional ETH required from their available FETH balance.\n\n      // Cancel the buyer's offer if there is one in order to free up their FETH balance.\n      _cancelBuyersOffer(nftContract, tokenId);\n\n      unchecked {\n        // The if above ensures delta will not underflow.\n        uint256 delta = buyPrice.price - msg.value;\n        // Withdraw ETH from the buyer's account in the FETH token contract,\n        // making the ETH available for `_distributeFunds` below.\n        feth.marketWithdrawFrom(msg.sender, delta);\n      }\n    } else if (buyPrice.price < msg.value) {\n      // Return any surplus funds to the buyer.\n\n      unchecked {\n        // The if above ensures this will not underflow\n        payable(msg.sender).sendValue(msg.value - buyPrice.price);\n      }\n    }\n\n    // Transfer the NFT to the buyer.\n    // This should revert if the `msg.sender` is not the owner of this NFT.\n    _transferFromEscrow(nftContract, tokenId, msg.sender, buyPrice.seller);\n\n    // Distribute revenue for this sale.\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      address(nftContract),\n      tokenId,\n      buyPrice.seller,\n      buyPrice.price\n    );\n\n    emit BuyPriceAccepted(nftContract, tokenId, buyPrice.seller, msg.sender, f8nFee, creatorFee, ownerRev);\n  }\n\n  /**\n   * @notice Clear a buy price and emit BuyPriceInvalidated.\n   * @dev The caller must confirm the buy price is set before calling this function.\n   */\n  function _invalidateBuyPrice(address nftContract, uint256 tokenId) private {\n    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    emit BuyPriceInvalidated(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Invalidates the buy price if one is found before transferring the NFT.\n   * This will revert if there is a buy price set but the `msg.sender` is not the owner.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n  ) internal virtual override {\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    if (buyPrice.seller != address(0)) {\n      // A buy price was set for this NFT.\n      if (buyPrice.seller != seller) {\n        // When there is a buy price set, the `buyPrice.seller` is the owner of the NFT.\n        revert NFTMarketBuyPrice_Seller_Mismatch(buyPrice.seller);\n      }\n\n      // Invalidate the buy price as the NFT will no longer be in escrow.\n      _invalidateBuyPrice(nftContract, tokenId);\n    }\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Checks if there is a buy price set, if not then allow the transfer to proceed.\n   */\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal virtual override {\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    if (buyPrice.seller == address(0)) {\n      // A buy price has been set for this NFT so it should remain in escrow.\n      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\n    }\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Checks if the NFT is already in escrow for buy now.\n   */\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    if (buyPrice.seller == address(0)) {\n      // The NFT is not in escrow for buy now.\n      super._transferToEscrow(nftContract, tokenId);\n    } else if (buyPrice.seller != msg.sender) {\n      // When there is a buy price set, the `buyPrice.seller` is the owner of the NFT.\n      revert NFTMarketBuyPrice_Seller_Mismatch(buyPrice.seller);\n    }\n  }\n\n  /**\n   * @notice Returns the buy price details for an NFT if one is available.\n   * @dev If no price is found, seller will be address(0) and price will be max uint256.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @return seller The address of the owner that listed a buy price for this NFT.\n   * Returns `address(0)` if there is no buy price set for this NFT.\n   * @return price The price of the NFT.\n   * Returns `0` if there is no buy price set for this NFT.\n   */\n  function getBuyPrice(address nftContract, uint256 tokenId) external view returns (address seller, uint256 price) {\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\n    if (buyPrice.seller == address(0)) {\n      return (address(0), type(uint256).max);\n    }\n    return (buyPrice.seller, buyPrice.price);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Returns the seller if there is a buy price set for this NFT, otherwise\n   * bubbles the call up for other considerations.\n   */\n  function _getSellerFor(address nftContract, uint256 tokenId)\n    internal\n    view\n    virtual\n    override\n    returns (address payable seller)\n  {\n    seller = nftContractToTokenIdToBuyPrice[nftContract][tokenId].seller;\n    if (seller == address(0)) {\n      seller = super._getSellerFor(nftContract, tokenId);\n    }\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./OZ/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./Constants.sol\";\n\nimport \"../interfaces/IGetFees.sol\";\nimport \"../interfaces/IGetRoyalties.sol\";\nimport \"../interfaces/IOwnable.sol\";\nimport \"../interfaces/IRoyaltyInfo.sol\";\nimport \"../interfaces/ITokenCreator.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\n\nerror NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin for associating creators to NFTs.\n * @dev In the future this may store creators directly in order to support NFTs created on a different platform.\n */\nabstract contract NFTMarketCreators is\n  Constants,\n  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization\n{\n  using ERC165Checker for address;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n  }\n\n  /**\n   * @notice Looks up the royalty payment configuration for a given NFT.\n   * @dev This will check various royalty APIs on the NFT and the royalty override\n   * if one was registered with the royalty registry. This aims to send royalties\n   * in the manner requested by the NFT owner, regardless of where the NFT was minted.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getCreatorPaymentInfo(\n    address nftContract,\n    uint256 tokenId,\n    address seller\n  )\n    internal\n    view\n    returns (\n      address payable[] memory recipients,\n      uint256[] memory splitPerRecipientInBasisPoints,\n      bool isCreator\n    )\n  {\n    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented\n\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 /* royaltyAmount */\n      ) {\n        if (receiver != address(0)) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n          if (receiver == seller) {\n            return (recipients, splitPerRecipientInBasisPoints, true);\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {\n          bool hasRecipient;\n          unchecked {\n            // The array length cannot overflow 256 bits.\n            for (uint256 i = 0; i < _recipients.length; ++i) {\n              if (_recipients[i] != address(0)) {\n                hasRecipient = true;\n                if (_recipients[i] == seller) {\n                  return (_recipients, recipientBasisPoints, true);\n                }\n              }\n            }\n          }\n          if (hasRecipient) {\n            recipients = _recipients;\n            splitPerRecipientInBasisPoints = recipientBasisPoints;\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n    if (recipients.length == 0) {\n      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n        address overrideContract\n      ) {\n        if (overrideContract != nftContract) {\n          nftContract = overrideContract;\n\n          // The functions above are repeated here if an override is set.\n\n          // 3rd priority: ERC-2981 override\n          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {\n            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n              address receiver,\n              uint256 /* royaltyAmount */\n            ) {\n              if (receiver != address(0)) {\n                recipients = new address payable[](1);\n                recipients[0] = payable(receiver);\n                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n                if (receiver == seller) {\n                  return (recipients, splitPerRecipientInBasisPoints, true);\n                }\n              }\n            } catch // solhint-disable-next-line no-empty-blocks\n            {\n              // Fall through\n            }\n          }\n\n          // 4th priority: getRoyalties override\n          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\n            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n              address payable[] memory _recipients,\n              uint256[] memory recipientBasisPoints\n            ) {\n              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {\n                bool hasRecipient;\n                for (uint256 i = 0; i < _recipients.length; ++i) {\n                  if (_recipients[i] != address(0)) {\n                    hasRecipient = true;\n                    if (_recipients[i] == seller) {\n                      return (_recipients, recipientBasisPoints, true);\n                    }\n                  }\n                }\n                if (hasRecipient) {\n                  recipients = _recipients;\n                  splitPerRecipientInBasisPoints = recipientBasisPoints;\n                }\n              }\n            } catch // solhint-disable-next-line no-empty-blocks\n            {\n              // Fall through\n            }\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Ignore out of gas errors and continue using the nftContract address\n      }\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length > 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              bool hasRecipient;\n              unchecked {\n                // The array length cannot overflow 256 bits.\n                for (uint256 i = 0; i < _recipients.length; ++i) {\n                  if (_recipients[i] != address(0)) {\n                    hasRecipient = true;\n                    if (_recipients[i] == seller) {\n                      return (_recipients, recipientBasisPoints, true);\n                    }\n                  }\n                }\n              }\n              if (hasRecipient) {\n                recipients = _recipients;\n                splitPerRecipientInBasisPoints = recipientBasisPoints;\n              }\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n      address payable _creator\n    ) {\n      if (_creator != address(0)) {\n        if (recipients.length == 0) {\n          // Only pay the tokenCreator if there wasn't another royalty defined\n          recipients = new address payable[](1);\n          recipients[0] = _creator;\n          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n        }\n        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (recipients.length == 0) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n      }\n      return (recipients, splitPerRecipientInBasisPoints, owner == seller);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() public view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.\n   */\n  uint256[500] private __gap;\n}\n\n\n",
        "CodeNames": [
            "Constants.sol",
            "FETH.sol",
            "NFTMarketBuyPrice.sol",
            "NFTMarketCreators.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n          // 4th priority: getRoyalties override\n          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\n            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n              address payable[] memory _recipients,\n              uint256[] memory recipientBasisPoints\n            ) {\n              if (_recipients.length  0 && _recipients.length == recipientBasisPoints.length) {\n                bool hasRecipient;\n                for (uint256 i = 0; i < _recipients.length; ++i) {\n                  if (_recipients[i] != address(0)) {\n                    hasRecipient = true;\n                    if (_recipients[i] == seller) {\n                      return (_recipients, recipientBasisPoints, true);\n",
                    "//solidity\n      uint256 ownerRev\n    )\n  {\n    bool isCreator;\n    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);\n\n    // Calculate the Foundation fee\n    uint256 fee;\n    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {\n      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;\n    } else {\n      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;\n    }\n\n    foundationFee = (price * fee) / BASIS_POINTS;\n\n    if (creatorRecipients.length  0) {\n      if (isCreator) {\n        // When sold by the creator, all revenue is split if applicable.\n        creatorRev = price foundationFee;\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;\n        ownerRevTo = seller;\n        ownerRev = price foundationFee creatorRev;\n      }\n    } else {\n      // No royalty recipients found.\n      ownerRevTo = seller;\n      ownerRev = price foundationFee;\n    }\n  }\n",
                    "//solidity\n        uint256 maxCreatorIndex = creatorRecipients.length 1;\n        if (maxCreatorIndex  MAX_ROYALTY_RECIPIENTS_INDEX) {\n          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;\n        }\n"
                ],
                "Type": " Creators can steal sale revenue from owners' sales",
                "Description": "\nNFTMarketCreators.sol#L158-L160(https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L158-L160)<br\nNFTMarketCreators.sol#L196-L198(https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L196-L198)<br\nNFTMarketCreators.sol#L97-L99(https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L97-L99)<br\n\nAccording to the README.md(<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/README.md?plain=1#L21):\n\n All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.\n\nUsing the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.\n\n\nBy updating the registry to include the seller as one of the royalty recipients, the creator can steal the sale price minus fees. This is because if code finds that the seller is a royalty recipient the royalties are all passed to the creator regardless of whether the owner is the seller or not.\n\n\nsolidity\n          // 4th priority: getRoyalties override\n          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\n            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n              address payable[] memory _recipients,\n              uint256[] memory recipientBasisPoints\n            ) {\n              if (_recipients.length  0 && _recipients.length == recipientBasisPoints.length) {\n                bool hasRecipient;\n                for (uint256 i = 0; i < _recipients.length; ++i) {\n                  if (_recipients[i] != address(0)) {\n                    hasRecipient = true;\n                    if (_recipients[i] == seller) {\n                      return (_recipients, recipientBasisPoints, true);\n\n\n<https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127-L154\n\nWhen true is returned as the final return value above, the following code leaves ownerRev as zero because isCreator is true.\n\nsolidity\n      uint256 ownerRev\n    )\n  {\n    bool isCreator;\n    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);\n\n    // Calculate the Foundation fee\n    uint256 fee;\n    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {\n      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;\n    } else {\n      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;\n    }\n\n    foundationFee = (price * fee) / BASIS_POINTS;\n\n    if (creatorRecipients.length  0) {\n      if (isCreator) {\n        // When sold by the creator, all revenue is split if applicable.\n        creatorRev = price foundationFee;\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;\n        ownerRevTo = seller;\n        ownerRev = price foundationFee creatorRev;\n      }\n    } else {\n      // No royalty recipients found.\n      ownerRevTo = seller;\n      ownerRev = price foundationFee;\n    }\n  }\n\n\nIn addition, if the index of the seller in _recipients is greater than MAX_ROYALTY_RECIPIENTS_INDEX, then the seller is omitted from the calculation and gets zero (_sendValueWithFallbackWithdraw() doesn't complain when it sends zero).\n\nsolidity\n        uint256 maxCreatorIndex = creatorRecipients.length 1;\n        if (maxCreatorIndex  MAX_ROYALTY_RECIPIENTS_INDEX) {\n          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;\n        }\n\n\n<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L76-L79\n\nThis issue does a lot of damage because the creator can choose whether and when to apply it on a sale-by-sale basis. Two other similar, but separate, exploits are available for the other blocks in _getCreatorPaymentInfo() that return arrays but they either require a malicious NFT implementation or can only specify a static seller for which this will affect things. In all cases, not only may the seller get zero dollars for the sale, but they'll potentially owe a lot of taxes based on the 'sale' price. The attacker may or may not be the creator creators can be bribed with kickbacks.\n\n",
                "Repair": "\nAlways calculate owner/seller revenue separately from royalty revenue.\n\nNickCuso (Foundation) confirmed and commented(https://github.com/code-423n4/2022-02-foundation-findings/issues/30#issuecomment-1060623733):\n  This is a great discovery and a creative way for creators to abuse the system, stealing funds from a secondary sale. Thank you for reporting this.\n \n It's a difficult one for us to address. We want to ensure that NFTs minted on our platform as a split continue to split revenue from the initial sale. We were using isCreator from _getCreatorPaymentInfo as our way of determining if all the revenue from a sale should go to the royalty recipients, which is a split contract for the use case we are concerned about here.\n \n The royalty override makes it easy for a creator to choose to abuse this feature at any time. So that was our primary focus for this fix.\n \n This is the change we have made in _getFees:\n \n solidity\n     bool isCreator = false;\n     // lookup for tokenCreator\n     try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n       address payable _creator\n     ) {\n       isCreator = _creator == seller;\n     } catch // solhint-disable-next-line no-empty-blocks\n     {\n       // Fall through\n     }\n \n     (creatorRecipients, creatorShares) = _getCreatorPaymentInfo(nftContract, tokenId);\n \n \n Since the royalty override is only considered in _getCreatorPaymentInfo we are no longer vulnerable to someone adding logic after the NFT has been released to try and rug pull the current owner(s).\n \n It is still possible for someone to try and abuse this logic, but to do so they must have built into the NFT contract itself a way to lie about who the tokenCreator is before the time of a sale. If we were to detect this happening, we would moderate that collection from the Foundation website. Additionally we will think about a longer term solution here so that this type of attack is strictly not possible with our market contract.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./Constants.sol\";\n\nimport \"../interfaces/IFethMarket.sol\";\n\nerror NFTMarketCore_FETH_Address_Is_Not_A_Contract();\nerror NFTMarketCore_Only_FETH_Can_Transfer_ETH();\n\n/**\n * @title A place for common modifiers and functions used by various NFTMarket mixins, if any.\n * @dev This also leaves a gap which can be used to add a new mixin to the top of the inheritance tree.\n */\nabstract contract NFTMarketCore is Constants {\n  using AddressUpgradeable for address;\n\n  /// @notice The FETH ERC-20 token for managing escrow and lockup.\n  IFethMarket internal immutable feth;\n\n  constructor(address _feth) {\n    if (!_feth.isContract()) {\n      revert NFTMarketCore_FETH_Address_Is_Not_A_Contract();\n    }\n    feth = IFethMarket(_feth);\n  }\n\n  /**\n   * @notice Only used by FETH. Any direct transfer from users will revert.\n   */\n  receive() external payable {\n    if (msg.sender != address(feth)) {\n      revert NFTMarketCore_Only_FETH_Can_Transfer_ETH();\n    }\n  }\n\n  /**\n   * @notice Notify implementors when an auction has received its first bid.\n   * Once a bid is received the sale is guaranteed to the auction winner\n   * and other sale mechanisms become unavailable.\n   * @dev Implementors of this interface should update internal state to reflect an auction has been kicked off.\n   */\n  function _afterAuctionStarted(\n    address, /*nftContract*/\n    uint256 /*tokenId*/ // solhint-disable-next-line no-empty-blocks\n  ) internal virtual {\n    // No-op\n  }\n\n  /**\n   * @notice If there is a buy price at this amount or lower, accept that and return true.\n   */\n  function _autoAcceptBuyPrice(\n    address nftContract,\n    uint256 tokenId,\n    uint256 amount\n  ) internal virtual returns (bool);\n\n  /**\n   * @notice If there is a valid offer at the given price or higher, accept that and return true.\n   */\n  function _autoAcceptOffer(\n    address nftContract,\n    uint256 tokenId,\n    uint256 minAmount\n  ) internal virtual returns (bool);\n\n  /**\n   * @notice Cancel the buyer's offer if there is one in order to free up their FETH balance.\n   */\n  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal virtual;\n\n  /**\n   * @notice Transfers the NFT from escrow and clears any state tracking this escrowed NFT.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address /*seller*/\n  ) internal virtual {\n    IERC721(nftContract).transferFrom(address(this), recipient, tokenId);\n  }\n\n  /**\n   * @notice Transfers the NFT from escrow unless there is another reason for it to remain in escrow.\n   */\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal virtual {\n    IERC721(nftContract).transferFrom(address(this), recipient, tokenId);\n  }\n\n  /**\n   * @notice Transfers an NFT into escrow,\n   * if already there this requires the msg.sender is authorized to manage the sale of this NFT.\n   */\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual {\n    IERC721(nftContract).transferFrom(msg.sender, address(this), tokenId);\n  }\n\n  /**\n   * @notice Gets the FETH contract used to escrow offer funds.\n   * @return fethAddress The FETH contract address.\n   */\n  function getFethAddress() external view returns (address fethAddress) {\n    return address(feth);\n  }\n\n  /**\n   * @dev Determines the minimum amount when increasing an existing offer or bid.\n   */\n  function _getMinIncrement(uint256 currentAmount) internal pure returns (uint256) {\n    uint256 minIncrement = currentAmount * MIN_PERCENT_INCREMENT_IN_BASIS_POINTS;\n    unchecked {\n      minIncrement /= BASIS_POINTS;\n      if (minIncrement == 0) {\n        // Since minIncrement reduces from the currentAmount, this cannot overflow.\n        // The next amount must be at least 1 wei greater than the current.\n        return currentAmount + 1;\n      }\n    }\n\n    return minIncrement + currentAmount;\n  }\n\n  /**\n   * @notice Checks who the seller for an NFT is, checking escrow or return the current owner if not in escrow.\n   * @dev If the NFT did not have an escrowed seller to return, fall back to return the current owner.\n   */\n  function _getSellerFor(address nftContract, uint256 tokenId) internal view virtual returns (address payable seller) {\n    seller = payable(IERC721(nftContract).ownerOf(tokenId));\n  }\n\n  /**\n   * @notice Checks if an escrowed NFT is currently in active auction.\n   * @return Returns false if the auction has ended, even if it has not yet been settled.\n   */\n  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view virtual returns (bool);\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   * @dev 50 slots were consumed by adding `ReentrancyGuard`.\n   */\n  uint256[950] private __gap;\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../libraries/AccountMigrationLibrary.sol\";\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./NFTMarketAuction.sol\";\nimport \"./NFTMarketCore.sol\";\nimport \"./NFTMarketFees.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @param minAmount The minimum amount that must be bid in order for it to be accepted.\nerror NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);\nerror NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n/// @param reservePrice The current reserve price.\nerror NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);\n/// @param endTime The timestamp at which the auction had ended.\nerror NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);\nerror NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n/// @param endTime The timestamp at which the auction will end.\nerror NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);\n/// @param seller The current owner of the NFT.\nerror NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);\nerror NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\nerror NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.\nerror NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);\n/// @param extensionDuration The extension duration, in seconds.\nerror NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);\nerror NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n/// @param seller The current owner of the NFT.\nerror NFTMarketReserveAuction_Not_Matching_Seller(address seller);\n/// @param owner The current owner of the NFT.\nerror NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);\nerror NFTMarketReserveAuction_Too_Much_Value_Provided();\n\n/**\n * @title Allows the owner of an NFT to list it in auction.\n * @notice NFTs in auction are escrowed in the market contract.\n * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.\n * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.\n */\nabstract contract NFTMarketReserveAuction is\n  Constants,\n  FoundationTreasuryNode,\n  NFTMarketCore,\n  ReentrancyGuardUpgradeable,\n  SendValueWithFallbackWithdraw,\n  NFTMarketFees,\n  NFTMarketAuction\n{\n  using AccountMigrationLibrary for address;\n\n  /// @notice Stores the auction configuration for a specific NFT.\n  struct ReserveAuction {\n    /// @notice The address of the NFT contract.\n    address nftContract;\n    /// @notice The id of the NFT.\n    uint256 tokenId;\n    /// @notice The owner of the NFT which listed it in auction.\n    address payable seller;\n    /// @notice The duration for this auction.\n    uint256 duration;\n    /// @notice The extension window for this auction.\n    uint256 extensionDuration;\n    /// @notice The time at which this auction will not accept any new bids.\n    /// @dev This is `0` until the first bid is placed.\n    uint256 endTime;\n    /// @notice The current highest bidder in this auction.\n    /// @dev This is `address(0)` until the first bid is placed.\n    address payable bidder;\n    /// @notice The latest price of the NFT in this auction.\n    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.\n    uint256 amount;\n  }\n\n  /// @notice The auction configuration for a specific auction id.\n  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;\n  /// @notice The auction id for a specific NFT.\n  /// @dev This is deleted when an auction is finalized or canceled.\n  mapping(uint256 => ReserveAuction) private auctionIdToAuction;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private __gap_was_minPercentIncrementInBasisPoints;\n   * uint256 private __gap_was_maxBidIncrementRequirement;\n   * uint256 private __gap_was_duration;\n   * uint256 private __gap_was_extensionDuration;\n   * uint256 private __gap_was_goLiveDate;\n   */\n  uint256[5] private __gap_was_config;\n\n  /// @notice How long an auction lasts for once the first bid has been received.\n  uint256 private immutable DURATION;\n\n  /// @notice The window for auction extensions, any bid placed in the final 15 minutes\n  /// of an auction will reset the time remaining to 15 minutes.\n  uint256 private constant EXTENSION_DURATION = 15 minutes;\n\n  /// @notice Caps the max duration that may be configured so that overflows will not occur.\n  uint256 private constant MAX_MAX_DURATION = 1000 days;\n\n  /**\n   * @notice Emitted when a bid is placed.\n   * @param auctionId The id of the auction this bid was for.\n   * @param bidder The address of the bidder.\n   * @param amount The amount of the bid.\n   * @param endTime The new end time of the auction (which may have been set or extended by this bid).\n   */\n  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);\n  /**\n   * @notice Emitted when an auction is cancelled.\n   * @dev This is only possible if the auction has not received any bids.\n   * @param auctionId The id of the auction that was cancelled.\n   */\n  event ReserveAuctionCanceled(uint256 indexed auctionId);\n  /**\n   * @notice Emitted when an auction is canceled by a Foundation admin.\n   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.\n   * @param auctionId The id of the auction that was cancelled.\n   * @param reason The reason for the cancellation.\n   */\n  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);\n  /**\n   * @notice Emitted when an NFT is listed for auction.\n   * @param seller The address of the seller.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param duration The duration of the auction (always 24-hours).\n   * @param extensionDuration The duration of the auction extension window (always 15-minutes).\n   * @param reservePrice The reserve price to kick off the auction.\n   * @param auctionId The id of the auction that was created.\n   */\n  event ReserveAuctionCreated(\n    address indexed seller,\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    uint256 duration,\n    uint256 extensionDuration,\n    uint256 reservePrice,\n    uint256 auctionId\n  );\n  /**\n   * @notice Emitted when an auction that has already ended is finalized,\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\n   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param auctionId The id of the auction that was finalized.\n   * @param seller The address of the seller.\n   * @param bidder The address of the highest bidder that won the NFT.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event ReserveAuctionFinalized(\n    uint256 indexed auctionId,\n    address indexed seller,\n    address indexed bidder,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev\n  );\n  /**\n   * @notice Emitted when an auction is invalidated due to other market activity.\n   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.\n   * @param auctionId The id of the auction that was invalidated.\n   */\n  event ReserveAuctionInvalidated(uint256 indexed auctionId);\n  /**\n   * @notice Emitted when the seller for an auction has been changed to a new account.\n   * @dev Account migrations require approval from both the original account and Foundation.\n   * @param auctionId The id of the auction that was updated.\n   * @param originalSellerAddress The original address of the auction's seller.\n   * @param newSellerAddress The new address for the auction's seller.\n   */\n  event ReserveAuctionSellerMigrated(\n    uint256 indexed auctionId,\n    address indexed originalSellerAddress,\n    address indexed newSellerAddress\n  );\n  /**\n   * @notice Emitted when the auction's reserve price is changed.\n   * @dev This is only possible if the auction has not received any bids.\n   * @param auctionId The id of the auction that was updated.\n   * @param reservePrice The new reserve price for the auction.\n   */\n  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);\n\n  /// @notice Confirms that the reserve price is not zero.\n  modifier onlyValidAuctionConfig(uint256 reservePrice) {\n    if (reservePrice == 0) {\n      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n    }\n    _;\n  }\n\n  /**\n   * @notice Configures the duration for auctions.\n   * @param duration The duration for auctions, in seconds.\n   */\n  constructor(uint256 duration) {\n    if (duration > MAX_MAX_DURATION) {\n      // This ensures that math in this file will not overflow due to a huge duration.\n      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);\n    }\n    if (duration < EXTENSION_DURATION) {\n      // The auction duration configuration must be greater than the extension window of 15 minutes\n      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);\n    }\n    DURATION = duration;\n  }\n\n  /**\n   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to\n   * the seller (if not active buy price set).\n   * This should only be used for extreme cases such as DMCA takedown requests.\n   * @param auctionId The id of the auction to cancel.\n   * @param reason The reason for the cancellation (a required field).\n   */\n  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)\n    external\n    onlyFoundationAdmin\n    nonReentrant\n  {\n    if (bytes(reason).length == 0) {\n      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n    }\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.amount == 0) {\n      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\n    }\n\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Return the NFT to the owner.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    if (auction.bidder != address(0)) {\n      // Refund the highest bidder if any bids were placed in this auction.\n      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionCanceledByAdmin(auctionId, reason);\n  }\n\n  /**\n   * @notice Allows an NFT owner and Foundation to work together in order to update the seller\n   * for auctions they have listed to a new account.\n   * @dev This will gracefully skip any auctions that have already been finalized.\n   * @param listedAuctionIds The ids of the auctions to update.\n   * @param originalAddress The original address of the seller of these auctions.\n   * @param newAddress The new address for the seller of these auctions.\n   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\n   * signed by the original account.\n   */\n  function adminAccountMigration(\n    uint256[] calldata listedAuctionIds,\n    address originalAddress,\n    address payable newAddress,\n    bytes memory signature\n  ) external onlyFoundationOperator {\n    // Validate the owner of the original account has approved this change.\n    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);\n\n    unchecked {\n      // The array length cannot overflow 256 bits.\n      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {\n        uint256 auctionId = listedAuctionIds[i];\n        ReserveAuction storage auction = auctionIdToAuction[auctionId];\n        if (auction.seller != address(0)) {\n          // Only if the auction was found and not finalized before this transaction.\n\n          if (auction.seller != originalAddress) {\n            // Confirm that the signature approval was the correct owner of this auction.\n            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);\n          }\n\n          // Update the auction's seller address.\n          auction.seller = newAddress;\n\n          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\n   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.\n   * @param auctionId The id of the auction to cancel.\n   */\n  function cancelReserveAuction(uint256 auctionId) external nonReentrant {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    }\n    if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n\n    // Remove the auction.\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Transfer the NFT unless it still has a buy price set.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    emit ReserveAuctionCanceled(auctionId);\n  }\n\n  /**\n   * @notice Creates an auction for the given NFT.\n   * The NFT is held in escrow until the auction is finalized or canceled.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param reservePrice The initial reserve price for the auction.\n   */\n  function createReserveAuction(\n    address nftContract,\n    uint256 tokenId,\n    uint256 reservePrice\n  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {\n    uint256 auctionId = _getNextAndIncrementAuctionId();\n\n    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.\n    _transferToEscrow(nftContract, tokenId);\n\n    // Store the auction details\n    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;\n    auctionIdToAuction[auctionId] = ReserveAuction(\n      nftContract,\n      tokenId,\n      payable(msg.sender),\n      DURATION,\n      EXTENSION_DURATION,\n      0, // endTime is only known once the reserve price is met\n      payable(0), // bidder is only known once a bid has been placed\n      reservePrice\n    );\n\n    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);\n  }\n\n  /**\n   * @notice Once the countdown has expired for an auction, anyone can settle the auction.\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\n   * @param auctionId The id of the auction to settle.\n   */\n  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {\n    if (auctionIdToAuction[auctionId].endTime == 0) {\n      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n    }\n    _finalizeReserveAuction(auctionId, false);\n  }\n\n  /**\n   * @notice Place a bid in an auction.\n   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.\n   * If this is the first bid on the auction, the countdown will begin.\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\n   * @param auctionId The id of the auction to bid on.\n   */\n  function placeBid(uint256 auctionId) external payable {\n    placeBidOf(auctionId, msg.value);\n  }\n\n  /**\n   * @notice Place a bid in an auction.\n   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.\n   * If this is the first bid on the auction, the countdown will begin.\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\n   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.\n   * @param auctionId The id of the auction to bid on.\n   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {\n    if (amount < msg.value) {\n      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.\n      revert NFTMarketReserveAuction_Too_Much_Value_Provided();\n    } else if (amount > msg.value) {\n      // Withdraw additional ETH required from their available FETH balance.\n\n      unchecked {\n        // The if above ensures delta will not underflow.\n        uint256 delta = amount - msg.value;\n\n        // Withdraw ETH from the buyer's account in the FETH token contract.\n        feth.marketWithdrawFrom(msg.sender, delta);\n      }\n    }\n\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n\n    if (auction.amount == 0) {\n      // No auction found\n      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\n    }\n\n    if (auction.endTime == 0) {\n      // This is the first bid, kicking off the auction.\n\n      if (auction.amount > amount) {\n        // The bid must be >= the reserve price.\n        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);\n      }\n\n      // Notify other market tools that an auction for this NFT has been kicked off.\n      _afterAuctionStarted(auction.nftContract, auction.tokenId);\n\n      // Store the bid details.\n      auction.amount = amount;\n      auction.bidder = payable(msg.sender);\n\n      // On the first bid, set the endTime to now + duration.\n      unchecked {\n        // Duration is always set to 24hrs so the below can't overflow.\n        auction.endTime = block.timestamp + auction.duration;\n      }\n    } else {\n      if (auction.endTime < block.timestamp) {\n        // The auction has already ended.\n        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);\n      } else if (auction.bidder == msg.sender) {\n        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.\n        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\n      } else if (amount < _getMinIncrement(auction.amount)) {\n        // If this bid outbids another, it must be at least 10% greater than the last bid.\n        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));\n      }\n\n      // Cache and update bidder state\n      uint256 originalAmount = auction.amount;\n      address payable originalBidder = auction.bidder;\n      auction.amount = amount;\n      auction.bidder = payable(msg.sender);\n\n      unchecked {\n        // When a bid outbids another, check to see if a time extension should apply.\n        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.\n        if (auction.endTime - block.timestamp < auction.extensionDuration) {\n          // Current time plus extension duration (always 15 mins) cannot overflow.\n          auction.endTime = block.timestamp + auction.extensionDuration;\n        }\n      }\n\n      // Refund the previous bidder\n      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);\n  }\n\n  /**\n   * @notice If an auction has been created but has not yet received bids, the reservePrice may be\n   * changed by the seller.\n   * @param auctionId The id of the auction to change.\n   * @param reservePrice The new reserve price for this auction.\n   */\n  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    } else if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n\n    // Update the current reserve price.\n    auction.amount = reservePrice;\n\n    emit ReserveAuctionUpdated(auctionId, reservePrice);\n  }\n\n  /**\n   * @notice Settle an auction that has already ended.\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\n   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding\n   * redundant transfers if the NFT should remain in escrow, such as when the new owner\n   * sets a buy price or lists it in a new auction.\n   */\n  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n\n    if (auction.endTime >= block.timestamp) {\n      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);\n    }\n\n    // Remove the auction.\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    if (!keepInEscrow) {\n      /*\n       * Save gas by calling core directly since it cannot have another escrow requirement\n       * (buy price set or another auction listed) until this one has been finalized.\n       */\n      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));\n    }\n\n    // Distribute revenue for this sale.\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      auction.nftContract,\n      auction.tokenId,\n      auction.seller,\n      auction.amount\n    );\n\n    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev If an auction is found:\n   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.\n   *  - If the auction has not received a bid, it will invalidate the auction.\n   *  - If the auction is in progress, this will revert.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n  ) internal virtual override {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    if (auctionId != 0) {\n      ReserveAuction storage auction = auctionIdToAuction[auctionId];\n      if (auction.endTime == 0) {\n        // The auction has not received any bids yet so it may be invalided.\n\n        if (auction.seller != seller) {\n          // The account trying to transfer the NFT is not the current owner.\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\n        }\n\n        // Remove the auction.\n        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];\n        delete auctionIdToAuction[auctionId];\n\n        emit ReserveAuctionInvalidated(auctionId);\n      } else {\n        // If the auction has started, the highest bidder will be the new owner.\n\n        if (auction.bidder != seller) {\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\n        }\n\n        // Finalization will revert if the auction has not yet ended.\n        _finalizeReserveAuction(auctionId, false);\n\n        // Finalize includes the transfer, so we are done here.\n        return;\n      }\n    }\n\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.\n   */\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal virtual override {\n    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {\n      // No auction was found\n\n      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\n    }\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    if (auctionId == 0) {\n      // NFT is not in auction\n      super._transferToEscrow(nftContract, tokenId);\n      return;\n    }\n    // Using storage saves gas since most of the data is not needed\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.endTime == 0) {\n      // Reserve price set, confirm the seller is a match\n      if (auction.seller != msg.sender) {\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\n      }\n    } else {\n      // Auction in progress, confirm the highest bidder is a match\n      if (auction.bidder != msg.sender) {\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\n      }\n\n      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended\n      _finalizeReserveAuction(auctionId, true);\n    }\n  }\n\n  /**\n   * @notice Returns the minimum amount a bidder must spend to participate in an auction.\n   * Bids must be greater than or equal to this value or they will revert.\n   * @param auctionId The id of the auction to check.\n   * @return minimum The minimum amount for a bid to be accepted.\n   */\n  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.endTime == 0) {\n      return auction.amount;\n    }\n    return _getMinIncrement(auction.amount);\n  }\n\n  /**\n   * @notice Returns auction details for a given auctionId.\n   * @param auctionId The id of the auction to lookup.\n   * @return auction The auction details.\n   */\n  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {\n    return auctionIdToAuction[auctionId];\n  }\n\n  /**\n   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.\n   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @return auctionId The id of the auction, or 0 if no auction is found.\n   */\n  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {\n    return nftContractToTokenIdToAuctionId[nftContract][tokenId];\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Returns the seller that has the given NFT in escrow for an auction,\n   * or bubbles the call up for other considerations.\n   */\n  function _getSellerFor(address nftContract, uint256 tokenId)\n    internal\n    view\n    virtual\n    override\n    returns (address payable seller)\n  {\n    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;\n    if (seller == address(0)) {\n      seller = super._getSellerFor(nftContract, tokenId);\n    }\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./NFTMarketCore.sol\";\nimport \"./NFTMarketFees.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nerror NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();\n/// @param currentOfferAmount The current highest offer available for this NFT.\nerror NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);\n/// @param expiry The time at which the offer had expired.\nerror NFTMarketOffer_Offer_Expired(uint256 expiry);\n/// @param currentOfferFrom The address of the collector which has made the current highest offer.\nerror NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);\n/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.\nerror NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);\nerror NFTMarketOffer_Reason_Required();\n\n/**\n * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.\n * @notice Funds are escrowed in the FETH ERC-20 token contract.\n */\nabstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {\n  using AddressUpgradeable for address;\n\n  /// @notice Stores offer details for a specific NFT.\n  struct Offer {\n    // Slot 1: When increasing an offer, only this slot is updated.\n    /// @notice The expiration timestamp of when this offer expires.\n    uint32 expiration;\n    /// @notice The amount, in wei, of the highest offer.\n    uint96 amount;\n    // 128 bits are available in slot 1\n\n    // Slot 2: When the buyer changes, both slots need updating\n    /// @notice The address of the collector who made this offer.\n    address buyer;\n  }\n\n  /// @notice Stores the highest offer for each NFT.\n  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;\n\n  /**\n   * @notice Emitted when an offer is accepted,\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\n   * @dev The accepted total offer amount is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyer The address of the collector that made the offer which was accepted.\n   * @param seller The address of the seller which accepted the offer.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event OfferAccepted(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address indexed buyer,\n    address seller,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev\n  );\n  /**\n   * @notice Emitted when an offer is canceled by a Foundation admin.\n   * @dev This should only be used for extreme cases such as DMCA takedown requests.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param reason The reason for the cancellation (a required field).\n   */\n  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);\n  /**\n   * @notice Emitted when an offer is invalidated due to other market activity.\n   * When this occurs, the collector which made the offer has their FETH balance unlocked\n   * and the funds are available to place other offers or to be withdrawn.\n   * @dev This occurs when the offer is no longer eligible to be accepted,\n   * e.g. when a bid is placed in an auction for this NFT.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   */\n  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);\n  /**\n   * @notice Emitted when an offer is made.\n   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds\n   * remain available until the `expiration` date.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyer The address of the collector that made the offer to buy this NFT.\n   * @param amount The amount, in wei, of the offer.\n   * @param expiration The expiration timestamp for the offer.\n   */\n  event OfferMade(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address indexed buyer,\n    uint256 amount,\n    uint256 expiration\n  );\n\n  /**\n   * @notice Accept the highest offer for an NFT.\n   * @dev The offer must not be expired and the NFT owned + approved by the seller or\n   * available in the market contract's escrow.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param offerFrom The address of the collector that you wish to sell to.\n   * If the current highest offer is not from this user, the transaction will revert.\n   * This could happen if a last minute offer was made by another collector,\n   * and would require the seller to try accepting again.\n   * @param minAmount The minimum value of the highest offer for it to be accepted.\n   * If the value is less than this amount, the transaction will revert.\n   * This could happen if the original offer expires and is replaced with a smaller offer.\n   */\n  function acceptOffer(\n    address nftContract,\n    uint256 tokenId,\n    address offerFrom,\n    uint256 minAmount\n  ) external nonReentrant {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    // Validate offer expiry and amount\n    if (offer.expiration < block.timestamp) {\n      revert NFTMarketOffer_Offer_Expired(offer.expiration);\n    } else if (offer.amount < minAmount) {\n      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);\n    }\n    // Validate the buyer\n    if (offer.buyer != offerFrom) {\n      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);\n    }\n\n    _acceptOffer(nftContract, tokenId);\n  }\n\n  /**\n   * @notice Allows Foundation to cancel offers.\n   * This will unlock the funds in the FETH ERC-20 contract for the highest offer\n   * and prevent the offer from being accepted.\n   * @dev This should only be used for extreme cases such as DMCA takedown requests.\n   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.\n   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.\n   * @param reason The reason for the cancellation (a required field).\n   */\n  function adminCancelOffers(\n    address[] calldata nftContracts,\n    uint256[] calldata tokenIds,\n    string calldata reason\n  ) external onlyFoundationAdmin nonReentrant {\n    if (bytes(reason).length == 0) {\n      revert NFTMarketOffer_Reason_Required();\n    }\n\n    // The array length cannot overflow 256 bits\n    unchecked {\n      for (uint256 i = 0; i < nftContracts.length; ++i) {\n        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];\n        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];\n\n        if (offer.expiration >= block.timestamp) {\n          // Unlock from escrow and emit an event only if the offer is still active\n          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);\n          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);\n        }\n        // Else continue on so the rest of the batch transaction can process successfully\n      }\n    }\n  }\n\n  /**\n   * @notice Make an offer for any NFT which is valid for 24-25 hours.\n   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.\n   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.\n   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param amount The amount to offer for this NFT.\n   * @return expiration The timestamp for when this offer will expire.\n   * This is provided as a return value in case another contract would like to leverage this information,\n   * user's should refer to the expiration in the `OfferMade` event log.\n   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.\n   */\n  function makeOffer(\n    address nftContract,\n    uint256 tokenId,\n    uint256 amount\n  ) external payable returns (uint256 expiration) {\n    // If there is a buy price set at this price or lower, accept that instead.\n    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {\n      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.\n      return 0;\n    }\n\n    if (_isInActiveAuction(nftContract, tokenId)) {\n      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();\n    }\n\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n\n    if (offer.expiration < block.timestamp) {\n      // This is a new offer for the NFT (no other offer found or the previous offer expired)\n\n      // Lock the offer amount in FETH until the offer expires in 24-25 hours.\n      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);\n    } else {\n      // A previous offer exists and has not expired\n\n      if (amount < _getMinIncrement(offer.amount)) {\n        // A non-trivial increase in price is required to avoid sniping\n        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));\n      }\n\n      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw\n      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.\n      expiration = feth.marketChangeLockup{ value: msg.value }(\n        offer.buyer,\n        offer.expiration,\n        offer.amount,\n        msg.sender,\n        amount\n      );\n    }\n\n    // Record offer details\n    offer.buyer = msg.sender;\n    // The FETH contract guarantees that the expiration fits into 32 bits.\n    offer.expiration = uint32(expiration);\n    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.\n    offer.amount = uint96(amount);\n\n    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);\n  }\n\n  /**\n   * @notice Accept the highest offer for an NFT from the `msg.sender` account.\n   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.\n   * @dev The caller must validate the expiry and amount before calling this helper.\n   * This may invalidate other market tools, such as clearing the buy price if set.\n   */\n  function _acceptOffer(address nftContract, uint256 tokenId) private {\n    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];\n\n    // Remove offer\n    delete nftContractToIdToOffer[nftContract][tokenId];\n    // Withdraw ETH from the buyer's account in the FETH token contract.\n    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);\n\n    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      nftContract,\n      tokenId,\n      payable(msg.sender),\n      offer.amount\n    );\n\n    // Transfer the NFT to the buyer.\n    try\n      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks\n    {\n      // NFT was in the seller's wallet so the transfer is complete.\n    } catch {\n      // If the transfer fails then attempt to transfer from escrow instead.\n      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.\n      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);\n    }\n\n    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.\n   */\n  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {\n    _invalidateOffer(nftContract, tokenId);\n    super._afterAuctionStarted(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Invalidates the highest offer if it's from the same user that purchased the NFT\n   * using a different market tool such as accepting the buy price.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address buyer,\n    address seller\n  ) internal virtual override {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.buyer == buyer) {\n      // The highest offer is from the same user that purchased the NFT using a different market tool.\n      _invalidateOffer(nftContract, tokenId);\n    }\n    // For other users, the offer remains valid for consideration by the new owner.\n    super._transferFromEscrow(nftContract, tokenId, buyer, seller);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _autoAcceptOffer(\n    address nftContract,\n    uint256 tokenId,\n    uint256 minAmount\n  ) internal override returns (bool) {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.expiration < block.timestamp || offer.amount < minAmount) {\n      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.\n      return false;\n    }\n\n    _acceptOffer(nftContract, tokenId);\n    return true;\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.buyer == msg.sender) {\n      _invalidateOffer(nftContract, tokenId);\n    }\n  }\n\n  /**\n   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.\n   */\n  function _invalidateOffer(address nftContract, uint256 tokenId) private {\n    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {\n      // An offer was found and it has not already expired\n      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];\n\n      // Remove offer\n      delete nftContractToIdToOffer[nftContract][tokenId];\n      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw\n      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);\n\n      emit OfferInvalidated(nftContract, tokenId);\n    }\n  }\n\n  /**\n   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.\n   * @dev Offers for this NFT which are less than this value will revert.\n   * Once the previous offer has expired smaller offers can be made.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @return minimum The minimum amount that must be offered for this NFT.\n   */\n  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.expiration >= block.timestamp) {\n      return _getMinIncrement(offer.amount);\n    }\n    // Absolute min is anything > 0\n    return 1;\n  }\n\n  /**\n   * @notice Returns details about the current highest offer for an NFT.\n   * @dev Default values are returned if there is no offer or the offer has expired.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @return buyer The address of the buyer that made the current highest offer.\n   * Returns `address(0)` if there is no offer or the most recent offer has expired.\n   * @return expiration The timestamp that the current highest offer expires.\n   * Returns `0` if there is no offer or the most recent offer has expired.\n   * @return amount The amount being offered for this NFT.\n   * Returns `0` if there is no offer or the most recent offer has expired.\n   */\n  function getOffer(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (\n      address buyer,\n      uint256 expiration,\n      uint256 amount\n    )\n  {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.expiration < block.timestamp) {\n      // Offer not found or has expired\n      return (address(0), 0, 0);\n    }\n\n    // An offer was found and it has not yet expired.\n    return (offer.buyer, offer.expiration, offer.amount);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./mixins/Constants.sol\";\nimport \"./mixins/FoundationTreasuryNode.sol\";\nimport \"./mixins/NFTMarketAuction.sol\";\nimport \"./mixins/NFTMarketBuyPrice.sol\";\nimport \"./mixins/NFTMarketCore.sol\";\nimport \"./mixins/NFTMarketCreators.sol\";\nimport \"./mixins/NFTMarketFees.sol\";\nimport \"./mixins/NFTMarketOffer.sol\";\nimport \"./mixins/NFTMarketPrivateSale.sol\";\nimport \"./mixins/NFTMarketReserveAuction.sol\";\nimport \"./mixins/SendValueWithFallbackWithdraw.sol\";\n\n/**\n * @title A market for NFTs on Foundation.\n * @notice The Foundation marketplace is a contract which allows traders to buy and sell NFTs.\n * It supports buying and selling via auctions, private sales, buy price, and offers.\n * @dev All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific\n * to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was\n * originally deployed, it may be added using the [Royalty Registry](https://royaltyregistry.xyz/) which will be\n * respected by our market contract.\n */\ncontract FNDNFTMarket is\n  Constants,\n  Initializable,\n  FoundationTreasuryNode,\n  NFTMarketCore,\n  ReentrancyGuardUpgradeable,\n  NFTMarketCreators,\n  SendValueWithFallbackWithdraw,\n  NFTMarketFees,\n  NFTMarketAuction,\n  NFTMarketReserveAuction,\n  NFTMarketPrivateSale,\n  NFTMarketBuyPrice,\n  NFTMarketOffer\n{\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   */\n  constructor(\n    address payable treasury,\n    address feth,\n    address royaltyRegistry,\n    uint256 duration,\n    address marketProxyAddress\n  )\n    FoundationTreasuryNode(treasury)\n    NFTMarketCore(feth)\n    NFTMarketCreators(royaltyRegistry)\n    NFTMarketReserveAuction(duration)\n    NFTMarketPrivateSale(marketProxyAddress) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called once to configure the contract after the initial proxy deployment.\n   * @dev This farms the initialize call out to inherited contracts as needed to initialize mutable variables.\n   */\n  function initialize() external initializer {\n    NFTMarketAuction._initializeNFTMarketAuction();\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _afterAuctionStarted(address nftContract, uint256 tokenId)\n    internal\n    override(NFTMarketCore, NFTMarketBuyPrice, NFTMarketOffer)\n  {\n    super._afterAuctionStarted(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n  ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice) {\n    super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _transferToEscrow(address nftContract, uint256 tokenId)\n    internal\n    override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice)\n  {\n    super._transferToEscrow(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev This is a no-op function required to avoid compile errors.\n   */\n  function _getSellerFor(address nftContract, uint256 tokenId)\n    internal\n    view\n    override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice)\n    returns (address payable seller)\n  {\n    return super._getSellerFor(nftContract, tokenId);\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTMarketCore.sol",
            "NFTMarketReserveAuction.sol",
            "NFTMarketOffer.sol",
            "FNDNFTMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "nftContractToIdToOffer",
                    "_acceptOffer",
                    "acceptOffer",
                    "_isInActiveAuction",
                    "_finalizeReserveAuction",
                    "recipient",
                    "_transferFromEscrow",
                    "makeOffer"
                ],
                "Type": " An offer made after auction end can be stolen by an auction winner",
                "Description": "\nAn Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as _transferFromEscrow being called by _acceptOffer will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.\n\nThis way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.\n\n\nWhen an auction has ended, there is a possibility to make the offers for an auctioned NFT as:\n\nmakeOffer checks _isInActiveAuction:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L200\n\n_isInActiveAuction returns false when auctionIdToAuction[auctionId].endTime < block.timestamp, so makeOffer above can proceed:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L666-L669\n\nThen, the auction winner can call acceptOffer - _acceptOffer (or setBuyPrice - _autoAcceptOffer - _acceptOffer).\n\n_acceptOffer will try to transfer directly, and then calls _transferFromEscrow:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271\n\nIf the auction has ended, but a winner hasn't picked up the NFT yet, the direct transfer will fail, proceeding with _transferFromEscrow in the FNDNFTMarket defined order:\n\n    function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n    ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n    }\n\nNFTMarketOffer._transferFromEscrow will call super as nftContractToIdToOffer was already deleted:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L296-L302\n\nNFTMarketBuyPrice._transferFromEscrow will call super as there is no buy price set:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L283-L293\n\nFinally, NFTMarketReserveAuction._transferFromEscrow will send the NFT to the winner via _finalizeReserveAuction, not to the user who made the offer:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560\n\nThe recipient user who made the offer is not present in this logic, the NFT is being transferred to the auction.bidder, and the original acceptOffer will go through successfully.\n\n",
                "Repair": "\nAn attempt to set a buy price from auction winner will lead to auction finalisation, so _buy cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction._transferFromEscrow L550-L560 logic is called from the NFTMarketOffer._acceptOffer only:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L270\n\nis the only user of\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L550-L560\n\nThis way the fix is to update L556-L560 for the described case as:\n\nNow:\n\n    // Finalization will revert if the auction has not yet ended.\n    _finalizeReserveAuction(auctionId, false);\n\n    // Finalize includes the transfer, so we are done here.\n    return;\n\nTo be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient:\n\n    // Finalization will revert if the auction has not yet ended.\n    _finalizeReserveAuction(auctionId, true);\n\nNickCuso (Foundation) confirmed and commented(https://github.com/code-423n4/2022-02-foundation-findings/issues/49#issuecomment-1060649574):\n  Yes! This was a great find and a major issue with our implementation. I'm very happy that it was flagged by a few different people, it helps raise our confidence that several wardens really dove into the code.\n \n It was a big miss on our part that this was not thoroughly tested. Our tests for this scenario confirmed the events and payouts, but did not validate the ownership in the end!\n \n The proposed fix is perfect and exactly what we have implemented. This follows the patterns we established well, and actually simplifies the logic here so that things are easier to reason about.\n\n\n\n*\n \n\n"
            }
        ]
    }
]