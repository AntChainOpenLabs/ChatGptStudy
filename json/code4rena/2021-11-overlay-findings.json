[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./libraries/FixedPoint.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol\";\nimport \"./interfaces/IUniswapV3Pool.sol\";\nimport \"./market/OverlayV1Market.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/TickMath.sol\";\n\ncontract OverlayV1UniswapV3Market is OverlayV1Market {\n\n    using FixedPoint for uint256;\n\n    uint256 internal X96 = 0x1000000000000000000000000;\n\n    uint256 public immutable macroWindow; // window size for main TWAP\n    uint256 public immutable microWindow; // window size for bid/ask TWAP\n\n    address public immutable marketFeed;\n    address public immutable ovlFeed;\n    address public immutable base;\n    address public immutable quote;\n    uint128 internal immutable baseAmount;\n\n    address internal immutable eth;\n    bool internal immutable ethIs0;\n\n    constructor(\n        address _mothership,\n        address _ovlFeed,\n        address _marketFeed,\n        address _quote,\n        address _eth,\n        uint128 _baseAmount,\n        uint256 _macroWindow,\n        uint256 _microWindow,\n        uint256 _priceFrameCap\n    ) OverlayV1Market (\n        _mothership\n    ) OverlayV1Comptroller (\n        _microWindow\n    ) OverlayV1OI (\n        _microWindow\n    ) OverlayV1PricePoint (\n        _priceFrameCap\n    ) {\n\n        // immutables\n        eth = _eth;\n        ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\n        ovlFeed = _ovlFeed;\n        marketFeed = _marketFeed;\n        baseAmount = _baseAmount;\n        macroWindow = _macroWindow;\n        microWindow = _microWindow;\n\n        address _token0 = IUniswapV3Pool(_marketFeed).token0();\n        address _token1 = IUniswapV3Pool(_marketFeed).token1();\n\n        base = _token0 != _quote ? _token0 : _token1;\n        quote = _token0 == _quote ? _token0 : _token1;\n\n        int24 _tick = OracleLibraryV2.consult(\n            _marketFeed,\n            uint32(_macroWindow),\n            uint32(0)\n        );\n\n        _pricePoints.push(PricePoint(\n            _tick, \n            _tick, \n            0\n        ));\n\n        uint _price = OracleLibraryV2.getQuoteAtTick(\n            _tick,\n            uint128(_baseAmount),\n            _token0 != _quote ? _token0 : _token1,\n            _token0 == _quote ? _token0 : _token1\n        );\n\n        emit NewPricePoint(_price, _price, 0);\n\n    }\n\n\n    /// @notice Reads the current price and depth information\n    /// @dev Reads price and depth of market feed\n    /// @return price_ Price point\n    function fetchPricePoint () public view override returns (\n        PricePoint memory price_\n    ) {\n\n        int56[] memory _ticks;\n        uint160[] memory _liqs;\n\n        uint _ovlPrice;\n        uint _marketLiquidity;\n\n        int24 _microTick;\n        int24 _macroTick;\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](3);\n            _secondsAgo[2] = uint32(macroWindow);\n            _secondsAgo[1] = uint32(microWindow);\n\n            ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n\n            _macroTick = int24(( _ticks[0] - _ticks[2]) / int56(int32(int(macroWindow))));\n\n            _microTick = int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))));\n\n            uint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);\n\n            uint _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );\n\n            _marketLiquidity = ethIs0\n                ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n                : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n\n        }\n\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](2);\n\n            _secondsAgo[1] = uint32(macroWindow);\n\n            ( _ticks, ) = IUniswapV3Pool(ovlFeed).observe(_secondsAgo);\n\n            _ovlPrice = OracleLibraryV2.getQuoteAtTick(\n                int24((_ticks[0] - _ticks[1]) / int56(int32(int(macroWindow)))),\n                1e18,\n                ovl,\n                eth\n            );\n\n        }\n\n        price_ = PricePoint(\n            _microTick, \n            _macroTick, \n            computeDepth(_marketLiquidity, _ovlPrice)\n        );\n\n    }\n\n\n    /// @notice Arithmetic to get depth\n    /// @dev Derived from cnstant product formula X*Y=K and tailored \n    /// to Uniswap V3 selective liquidity provision.\n    /// @param _marketLiquidity Amount of liquidity in market in ETH terms.\n    /// @param _ovlPrice Price of OVL against ETH.\n    /// @return depth_ Depth criteria for market in OVL terms.\n    function computeDepth (\n        uint _marketLiquidity,\n        uint _ovlPrice\n    ) public override view returns (\n        uint depth_\n    ) {\n\n        depth_ = ((_marketLiquidity * 1e18) / _ovlPrice)\n            .mulUp(lmbda)    \n            .divDown(2e18);\n\n    }\n\n    function _tickToPrice (\n        int24 _tick\n    ) public override view returns (\n        uint quote_\n    ) {\n\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(_tick);\n\n        // better precision if no overflow when squared\n        if (sqrtRatioX96 <= type(uint128).max) {\n\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n\n            quote_ = base < quote\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n\n        } else {\n\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n\n            quote_ = base < quote\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n\n        }\n\n    }\n\n}\n\n\n",
        "CodeNames": [
            "OverlayV1UniswapV3Market.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n_marketLiquidity = ethIs0\n    ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n    : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n",
                    "//solidity\n// in constructor, if token0 is eth refers to ovlFeed\nethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\n\n// in fetchPricePoint, _liquidity comes from different market feed\n( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n_marketLiquidity = ethIs0\n    ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n    : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n"
                ],
                "Type": "  OverlayV1UniswapV3Market  computes wrong market liquidity",
                "Description": "\nThe OverlayV1UniswapV3Market.fetchPricePoint tries to compute the market depth in OVL terms as marketLiquidity (in ETH) / ovlPrice (in ETH per OVL).\nTo get the market liquidity *in ETH* (and not the other token pair), it uses the ethIs0 boolean.\n\nsolidity\n_marketLiquidity = ethIs0\n    ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n    : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n\n\nHowever, ethIs0 boolean refers to the ovlFeed, whereas the _liquidity refers to the marketFeed, and therefore the ethIs0 boolean has nothing to do with the *market* feed where the liquidity is taken from:\n\nsolidity\n// in constructor, if token0 is eth refers to ovlFeed\nethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\n\n// in fetchPricePoint, _liquidity comes from different market feed\n( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n_marketLiquidity = ethIs0\n    ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n    : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n\n\n\nIf the ovlFeed and marketFeed do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for both pairs), then the market liquidity & depth is computed wrong (inverted).\nFor example, the OverlayV1Market.depth() function will return a wrong depth which is used in the market cap computation.\n\n",
                "Repair": "\nIt seems that marketFeed.token0() == WETH should be used in fetchPricePoint to compute the liquidity instead of ovlFeed.token0() == WETH.\n\nrealisation (Overlay) confirmed(https://github.com/code-423n4/2021-11-overlay-findings/issues/83#issuecomment-985656027):\n  Yeah, was aware of this, just hadn't finalized it in the code as of yet. \n\n\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\nIOverlayTokenNew immutable public ovl;\n",
                    "//solidity\nmothership = IOverlayV1Mothership(_mothership);\novl = IOverlayV1Mothership(_mothership).ovl();\n",
                    "//solidity\nfunction setOVL (address _ovl) external onlyGovernor {\n    ovl = _ovl;\n}\n"
                ],
                "Type": " Cached version of ovl may be outdated",
                "Description": "\n\ncontract OverlayV1OVLCollateral and OverlayV1Governance cache ovl address:\n\nsolidity\nIOverlayTokenNew immutable public ovl;\n\n\nThis variable is initialized in the constructor and fetched from the mothership contract:\n\nsolidity\nmothership = IOverlayV1Mothership(_mothership);\novl = IOverlayV1Mothership(_mothership).ovl();\n\n\novl is declared as immutable and later contract interacts with this cached version. However, mothership contains a setter function, so the governor can point it to a new address:\n\nsolidity\nfunction setOVL (address _ovl) external onlyGovernor {\n    ovl = _ovl;\n}\n\n\nOverlayV1OVLCollateral and OverlayV1Governance will still use this old cached value.\n\n",
                "Repair": "\nConsider if this was intended, or you want to remove this cached version and always fetch on the go (this will increase the gas costs though).\n\nrealisation (Overlay) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/129#issuecomment-978085480):\n  This is just a detail we were yet to settle on but definitely were going to as we got the contracts to a totally deployable state.\n\nmikeyrf (Overlay) disagreed with severity(https://github.com/code-423n4/2021-11-overlay-findings/issues/129#issuecomment-989289973):\n  disagree w severity reason would put this at 1 Low Risk given the governor would be responsible for properly setting\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/129#issuecomment-998216930):\n  I agree with the warden that this constitutes a medium risk.\n \n From the judging criteria (emphasis mine):\n  2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../libraries/Position.sol\";\nimport \"../libraries/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\";\nimport \"../interfaces/IOverlayV1Market.sol\";\nimport \"../interfaces/IOverlayV1Mothership.sol\";\nimport \"../interfaces/IOverlayToken.sol\";\nimport \"../interfaces/IOverlayTokenNew.sol\";\n\ncontract OverlayV1OVLCollateral is ERC1155Supply {\n\n    event log(string k, uint v);\n    event log_addr(string k, address v);\n\n    using Position for Position.Info;\n    using FixedPoint for uint256;\n\n    bytes32 constant private GOVERNOR = keccak256(\"GOVERNOR\");\n\n    mapping (address => mapping(uint => uint)) internal currentBlockPositionsLong;\n    mapping (address => mapping(uint => uint)) internal currentBlockPositionsShort;\n    mapping (address => MarketInfo) public marketInfo;\n    struct MarketInfo {\n        uint marginMaintenance;\n        uint marginRewardRate;\n        uint maxLeverage;\n    }\n\n    Position.Info[] public positions;\n\n    IOverlayV1Mothership public immutable mothership;\n    IOverlayTokenNew immutable public ovl;\n\n    uint256 public fees;\n    uint256 public liquidations;\n\n    event Build(\n        address market,\n        uint256 positionId,\n        uint256 oi,\n        uint256 debt\n    );\n\n    event Unwind(\n        address market,\n        uint256 positionId,\n        uint256 oi,\n        uint256 debt\n    );\n\n    event Liquidate(\n        uint256 positionId,\n        uint256 oi,\n        uint256 reward,\n        address rewarded\n    );\n\n    event Update(\n        uint feesCollected,\n        uint feesBurned,\n        uint liquidationsCollected,\n        uint liquidationsBurned\n    );\n\n    modifier onlyGovernor () {\n        require(mothership.hasRole(GOVERNOR, msg.sender), \"OVLV1:!governor\");\n        _;\n    }\n\n    constructor (\n        string memory _uri,\n        address _mothership\n    ) ERC1155(_uri) {\n\n        mothership = IOverlayV1Mothership(_mothership);\n\n        ovl = IOverlayV1Mothership(_mothership).ovl();\n\n        positions.push(Position.Info({\n            market: address(0),\n            isLong: false,\n            leverage: 0,\n            pricePoint: 0,\n            oiShares: 0,\n            debt: 0,\n            cost: 0\n        }));\n\n    }\n\n    function setMarketInfo (\n        address _market,\n        uint _marginMaintenance,\n        uint _marginRewardRate,\n        uint _maxLeverage\n    ) external onlyGovernor {\n\n        marketInfo[_market].marginMaintenance = _marginMaintenance;\n        marketInfo[_market].marginRewardRate = _marginRewardRate;\n        marketInfo[_market].maxLeverage = _maxLeverage;\n\n    }\n\n    function marginMaintenance(\n        address _market\n    ) external view returns (\n        uint marginMaintenance_\n    ) {\n\n        marginMaintenance_ = marketInfo[_market].marginMaintenance;\n\n    }\n\n    function maxLeverage(\n        address _market\n    ) external view returns (\n        uint maxLeverage_\n    ) {\n\n        maxLeverage_ = marketInfo[_market].maxLeverage;\n\n    }\n\n    function marginRewardRate(\n        address _market\n    ) external view returns (\n        uint marginRewardRate_\n    ) {\n\n        marginRewardRate_ = marketInfo[_market].marginRewardRate;\n\n    }\n\n\n    /// @notice Disburses fees\n    function disburse () public {\n\n        (   uint256 _marginBurnRate,\n            uint256 _feeBurnRate,\n            address _feeTo ) = mothership.getUpdateParams();\n\n        uint _feeForward = fees;\n        uint _feeBurn = _feeForward.mulUp(_feeBurnRate);\n        _feeForward = _feeForward - _feeBurn;\n\n        uint _liqForward = liquidations;\n        uint _liqBurn = _liqForward.mulUp(_marginBurnRate);\n        _liqForward -= _liqBurn;\n\n        fees = 0;\n        liquidations = 0;\n\n        emit Update(\n            _feeForward,\n            _feeBurn,\n            _liqForward,\n            _liqBurn\n        );\n\n        ovl.burn(address(this), _feeBurn + _liqBurn);\n        ovl.transfer(_feeTo, _feeForward + _liqForward);\n\n    }\n\n    function getCurrentBlockPositionId (\n        address _market,\n        bool _isLong,\n        uint _leverage,\n        uint _pricePointNext\n    ) internal returns (\n        uint positionId_\n    ) {\n\n        mapping(uint=>uint) storage _currentBlockPositions = _isLong\n            ? currentBlockPositionsLong[_market]\n            : currentBlockPositionsShort[_market];\n\n        positionId_ = _currentBlockPositions[_leverage];\n\n        Position.Info storage position = positions[positionId_];\n\n        if (position.pricePoint < _pricePointNext) {\n\n            positions.push(Position.Info({\n                market: _market,\n                isLong: _isLong,\n                leverage: _leverage,\n                pricePoint: _pricePointNext,\n                oiShares: 0,\n                debt: 0,\n                cost: 0\n            }));\n\n            positionId_ = positions.length - 1;\n\n            _currentBlockPositions[_leverage] = positionId_;\n\n        }\n\n    }\n\n\n    /// @notice Build a position on Overlay with OVL collateral\n    /// @dev This interacts with an Overlay Market to register oi and hold \n    /// positions on behalf of users.\n    /// @param _market The address of the desired market to interact with.\n    /// @param _collateral The amount of OVL to use as collateral in the position.\n    /// @param _leverage The amount of leverage to use in the position\n    /// @param _isLong Whether to take out a position on the long or short side.\n    /// @param _oiMinimum Minimum acceptable amount of OI after impact and fees.\n    /// @return positionId_ Id of the built position for on chain convenience.\n    function build (\n        address _market,\n        uint256 _collateral,\n        uint256 _leverage,\n        bool _isLong,\n        uint256 _oiMinimum\n    ) external returns (\n        uint positionId_\n    ) {\n\n        require(mothership.marketActive(_market), \"OVLV1:!market\");\n        require(_leverage <= marketInfo[_market].maxLeverage, \"OVLV1:lev>max\");\n\n        (   uint _oiAdjusted,\n            uint _collateralAdjusted,\n            uint _debtAdjusted,\n            uint _fee,\n            uint _impact,\n            uint _pricePointNext ) = IOverlayV1Market(_market)\n                .enterOI(\n                    _isLong,\n                    _collateral,\n                    _leverage\n                );\n\n        require(_oiAdjusted >= _oiMinimum, \"OVLV1:oi<min\");\n\n        uint _positionId = getCurrentBlockPositionId(\n            _market,\n            _isLong,\n            _leverage,\n            _pricePointNext\n        );\n\n        Position.Info storage pos = positions[_positionId];\n\n        pos.oiShares += _oiAdjusted;\n        pos.cost += _collateralAdjusted;\n        pos.debt += _debtAdjusted;\n\n        fees += _fee;\n\n        emit Build(_market, _positionId, _oiAdjusted, _debtAdjusted);\n\n        ovl.transferFromBurn(msg.sender, address(this), _collateralAdjusted + _fee, _impact);\n\n        // ovl.burn(msg.sender, _impact);\n\n        _mint(msg.sender, _positionId, _oiAdjusted, \"\"); // WARNING: last b/c erc1155 callback\n\n        positionId_ = _positionId;\n\n    }\n\n    /// @notice Unwinds shares of an existing position.\n    /// @dev Interacts with a market contract to realize the PnL on a position.\n    /// @param _positionId Id of the position to be unwound.\n    /// @param _shares Number of shars to unwind from the position.\n    function unwind (\n        uint256 _positionId,\n        uint256 _shares\n    ) external {\n\n        require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), \"OVLV1:!shares\");\n\n        Position.Info storage pos = positions[_positionId];\n\n        require(0 < pos.oiShares, \"OVLV1:liquidated\");\n\n        {\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = IOverlayV1Market(pos.market)\n                .exitData(\n                    pos.isLong,\n                    pos.pricePoint\n                );\n\n        uint _totalPosShares = totalSupply(_positionId);\n\n        uint _userOiShares = _shares;\n        uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;\n        uint _userDebt = _shares * pos.debt / _totalPosShares;\n        uint _userCost = _shares * pos.cost / _totalPosShares;\n        uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;\n\n        emit Unwind(pos.market, _positionId, _userOi, _userDebt);\n\n        // TODO: think through edge case of underwater position ... and fee adjustments ...\n        uint _feeAmount = _userNotional.mulUp(mothership.fee());\n\n        uint _userValueAdjusted = _userNotional - _feeAmount;\n        if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt;\n        else _userValueAdjusted = 0;\n\n        fees += _feeAmount; // adds to fee pot, which is transferred on update\n\n        pos.debt -= _userDebt;\n        pos.cost -= _userCost;\n        pos.oiShares -= _userOiShares;\n\n        // ovl.transfer(msg.sender, _userCost);\n\n        // mint/burn excess PnL = valueAdjusted - cost\n        if (_userCost < _userValueAdjusted) {\n\n            ovl.transferMint(\n                msg.sender, \n                _userCost, \n                _userValueAdjusted - _userCost\n            );\n\n        } else {\n\n            ovl.transferBurn(\n                msg.sender, \n                _userValueAdjusted, \n                _userCost - _userValueAdjusted\n            );\n\n        }\n\n\n        IOverlayV1Market(pos.market).exitOI(\n            pos.isLong,\n            _userOi,\n            _userOiShares,\n            _userCost < _userValueAdjusted ? _userValueAdjusted - _userCost : 0,\n            _userCost < _userValueAdjusted ? 0 : _userCost - _userValueAdjusted\n        );\n\n        }\n\n        _burn(msg.sender, _positionId, _shares);\n\n    }\n\n    /// @notice Liquidates an existing position.\n    /// @dev Interacts with an Overlay Market to exit all open interest\n    /// associated with a liquidatable positoin.\n    /// @param _positionId ID of the position being liquidated.\n    /// @param _rewardsTo Address to send liquidation reward to.\n    function liquidate (\n        uint256 _positionId,\n        address _rewardsTo\n    ) external {\n\n        Position.Info storage pos = positions[_positionId];\n\n        require(0 < pos.oiShares, \"OVLV1:liquidated\");\n\n        bool _isLong = pos.isLong;\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = IOverlayV1Market(pos.market)\n                .exitData(\n                    _isLong,\n                    pos.pricePoint\n                );\n\n        MarketInfo memory _marketInfo = marketInfo[pos.market];\n\n        require(pos.isLiquidatable(\n            _oi,\n            _oiShares,\n            _priceFrame,\n            _marketInfo.marginMaintenance\n        ), \"OVLV1:!liquidatable\");\n\n        uint _value = pos.value(_oi, _oiShares, _priceFrame);\n\n        IOverlayV1Market(pos.market).exitOI(\n            _isLong,\n            pos.oi(_oi, _oiShares),\n            pos.oiShares,\n            0,\n            pos.cost - _value\n        );\n\n        // TODO: which is better on gas\n        pos.oiShares = 0;\n        pos.debt = 0;\n        // positions[positionId].oiShares = 0;\n\n        uint _toReward = _value.mulUp(_marketInfo.marginRewardRate);\n\n        liquidations += _value - _toReward;\n\n        emit Liquidate(\n            _positionId,\n            _oi,\n            _toReward,\n            _rewardsTo\n        );\n\n        // ovl.burn(address(this), pos.cost - _value);\n        ovl.transferBurn(_rewardsTo, _toReward, pos.cost - _value);\n\n    }\n\n\n    /// @notice Retrieves required information from market contract \n    /// to calculate position value with.\n    /// @dev Gets price frame, total open interest and \n    /// total open interest shares from an Overlay market.\n    /// @param _positionId ID of position to determine value of.\n    /// @return value_ Value of the position\n    function value (\n        uint _positionId\n    ) public view returns (\n        uint256 value_\n    ) {\n\n        Position.Info storage pos = positions[_positionId];\n\n        IOverlayV1Market _market = IOverlayV1Market(pos.market);\n\n        (   uint _oi,\n            uint _oiShares,\n            uint _priceFrame ) = _market\n            .positionInfo(\n                pos.isLong,\n                pos.pricePoint\n            );\n\n        value_ = pos.value(\n            _oi,\n            _oiShares,\n            _priceFrame\n        );\n\n    }\n\n}\n\n\n",
        "CodeNames": [
            "OverlayV1OVLCollateral.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "yaml\n  dependencies:\n    OpenZeppelin/openzeppelin-contracts@4.3.2\n",
                    "//solidity\n  contract OverlayV1OVLCollateral is ERC1155Supply\n"
                ],
                "Type": " OZ ERC1155Supply vulnerability",
                "Description": "\n\nOverlay uses OZ contracts version 4.3.2:\n\nyaml\n  dependencies:\n    OpenZeppelin/openzeppelin-contracts@4.3.2\n\n\nand has a contract that inherits from ERC1155Supply:\n\nsolidity\n  contract OverlayV1OVLCollateral is ERC1155Supply\n\n\nThis version has a recently discovered vulnerability:\n<https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg\n\nIn your case, function unwind relies on totalSupply when calculating _userNotional, _userDebt, _userCost, and _userOi, so a malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.\n\n",
                "Repair": "\nConsider updating to a patched version of 4.3.3.\n\nmikeyrf (Overlay) confirmed(https://github.com/code-423n4/2021-11-overlay-findings/issues/127)\n\n \n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "disburse()"
                ],
                "Type": " Fee double counting for underwater positions",
                "Description": "\n\nActual available fees are less than recorded. That's because a part of them corresponds to underwater positions, and will not have the correct amount stored with the contract: when calculation happens the fee is recorded first, then there is a check for position health, and the funds are channeled to cover the debt firsthand. This way in a case of unfunded position the fee is recorded, but cannot be allocated, so the fees accounted can be greater than the value of fees stored.\n\nThis can lead to fee withdrawal malfunction, i.e. disburse() will burn more and attempt to transfer more than needed. This leads either to inability to withdraw fees when disburse is failing due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals because of lack of funds.\n\n\nThe fees are accounted for before position health check and aren't corrected thereafter when there is a shortage of funds.\n\n<https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L311\n\n",
                "Repair": "\nAdjust fees after position health check: accrue fees only on a remaining part of position that is available after taking debt into account.\n\nNow:\nsolidity\nuint _feeAmount = _userNotional.mulUp(mothership.fee());\n\nuint _userValueAdjusted = _userNotional _feeAmount;\nif (_userValueAdjusted  _userDebt) _userValueAdjusted -= _userDebt;\nelse _userValueAdjusted = 0;\n\nTo be:\nsolidity\nuint _feeAmount = _userNotional.mulUp(mothership.fee());\n\nuint _userValueAdjusted = _userNotional _feeAmount;\nif (_userValueAdjusted  _userDebt) {\n    _userValueAdjusted -= _userDebt;\n} else {\n    _userValueAdjusted = 0;\n    _feeAmount = _userNotional  _userDebt ? _userNotional _userDebt : 0;\n}\n\nmikeyrf (Overlay) confirmed(https://github.com/code-423n4/2021-11-overlay-findings/issues/134)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./FixedPoint.sol\";\n\nlibrary Position {\n\n    using FixedPoint for uint256;\n\n    struct Info {\n        address market; // the market for the position\n        bool isLong; // whether long or short\n        uint leverage; // discrete initial leverage amount\n        uint pricePoint; // pricePointIndex\n        uint256 oiShares; // shares of total open interest on long/short side, depending on isLong value\n        uint256 debt; // total debt associated with this position\n        uint256 cost; // total amount of collateral initially locked; effectively, cost to enter position\n    }\n\n    uint256 constant TWO = 2e18;\n\n    function _initialOi (\n        Info memory _self\n    ) private pure returns (\n        uint initialOi_\n    ) {\n\n        initialOi_ = _self.cost + _self.debt;\n\n    }\n\n    function _oi (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares\n    ) private pure returns (uint256 oi_) {\n\n        oi_ = _self.oiShares\n            .mulDown(totalOi)\n            .divUp(totalOiShares);\n\n    }\n\n    /// @dev Floors to zero, so won't properly compute if self is underwater\n    function _value (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (uint256 val_) {\n\n        uint256 __oi = _oi(_self, totalOi, totalOiShares);\n\n        if (_self.isLong) { // oi * priceFrame - debt\n\n            val_ = __oi.mulDown(priceFrame);\n            val_ -= Math.min(val_, _self.debt); // floor to 0\n\n        } else { // oi * (2 - priceFrame) - debt\n\n            val_ = __oi.mulDown(2e18);\n            val_ -= Math.min(val_, _self.debt + __oi.mulDown(priceFrame)); // floor to 0\n\n        }\n\n    }\n\n    /// @dev is true when position value < 0\n    function _isUnderwater(\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (bool isUnder) {\n\n        uint256 __oi = _oi(_self, totalOi, totalOiShares);\n\n        bool _long = _self.isLong;\n\n        if (_long) isUnder = __oi.mulDown(priceFrame) < _self.debt;\n        else isUnder = __oi.mulDown(priceFrame) + _self.debt < ( __oi * 2 );\n\n    }\n\n    /// @dev Floors to _self.debt, so won't properly compute if _self is underwater\n    function _notional (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (uint256 notion) {\n\n        uint256 val = _value(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n        notion = val + _self.debt;\n\n    }\n\n    /// @dev ceils uint256.max if position value <= 0\n    function _openLeverage (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (uint lev) {\n\n        uint val = _value(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n        if (val != 0) {\n\n            uint256 notion = _notional(\n                _self,\n                totalOi,\n                totalOiShares,\n                priceFrame\n            );\n\n            lev = notion.divDown(val);\n\n        } else lev = type(uint256).max;\n\n    }\n\n    /// @dev floors zero if position value <= 0; equiv to 1 / open leverage\n    function _openMargin (\n        Info memory _self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) private pure returns (uint margin) {\n\n        uint notion = _notional(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n        if (notion != 0) {\n\n            uint256 val = _value(\n                _self,\n                totalOi,\n                totalOiShares,\n                priceFrame\n            );\n\n            margin = val.divDown(notion);\n\n        } else margin = 0;\n\n    }\n\n    /// @dev is true when open margin < maintenance margin\n    function _isLiquidatable (\n        Info memory _self,\n        uint256 _totalOi,\n        uint256 _totalOiShares,\n        uint256 _priceFrame,\n        uint256 _marginMaintenance\n    ) private pure returns (\n        bool can_\n    ) {\n\n        uint _val = _value(\n            _self,\n            _totalOi,\n            _totalOiShares,\n            _priceFrame\n        );\n\n        uint _initOi = _initialOi(_self);\n\n        uint _maintenanceMargin = _initOi.mulUp(_marginMaintenance);\n\n        can_ = _val < _maintenanceMargin;\n\n    }\n\n    function _liquidationPrice (\n        Info memory _self,\n        uint256 _totalOi,\n        uint256 _totalOiShares,\n        uint256 _priceEntry,\n        uint256 _marginMaintenance\n    ) private pure returns (uint256 liqPrice) {\n\n        uint256 _posOi = _oi(_self, _totalOi, _totalOiShares);\n        uint256 _posInitialOi = _initialOi(_self);\n\n        uint256 _oiFrame = _posInitialOi.mulUp(_marginMaintenance)\n            .add(_self.debt)\n            .divDown(_posOi);\n\n        if (_self.isLong) liqPrice = _priceEntry.mulUp(_oiFrame);\n        else liqPrice = _priceEntry.mulUp(TWO.sub(_oiFrame));\n\n    }\n\n    function initialOi (\n        Info storage self\n    ) internal view returns (\n        uint256 initialOi_\n    ) {\n\n        Info memory _self = self;\n\n        initialOi_ = _initialOi(_self);\n\n    }\n\n    /// @notice Computes the open interest of a position\n    function oi (\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares\n    ) internal view returns (uint256) {\n\n        Info memory _self = self;\n\n        return _oi(_self, totalOi, totalOiShares);\n\n    }\n\n    /// @notice Computes the value of a position\n    /// @dev Floors to zero, so won't properly compute if self is underwater\n    function value(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (uint256) {\n\n        Info memory _self = self;\n\n        return _value(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Whether position is underwater\n    /// @dev is true when position value <= 0\n    function isUnderwater(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (bool) {\n\n        Info memory _self = self;\n\n        return _isUnderwater(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Computes the notional of a position\n    /// @dev Floors to _self.debt if value <= 0\n    function notional(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (uint256) {\n\n        Info memory _self = self;\n\n        return _notional(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Computes the open leverage of a position\n    /// @dev ceils uint256.max if position value <= 0\n    function openLeverage(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (uint) {\n\n        Info memory _self = self;\n\n        return _openLeverage(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Computes the open margin of a position\n    /// @dev floors zero if position value <= 0\n    function openMargin(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame\n    ) internal view returns (uint) {\n\n        Info memory _self = self;\n\n        return _openMargin(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame\n        );\n\n    }\n\n    /// @notice Whether a position can be liquidated\n    /// @dev is true when value < maintenance margin\n    function isLiquidatable(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceFrame,\n        uint256 marginMaintenance\n    ) internal view returns (bool) {\n\n        Info memory _self = self;\n\n        return _isLiquidatable(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceFrame,\n            marginMaintenance\n        );\n\n    }\n\n    /// @notice Computes the liquidation price of a position\n    /// @dev price when value < maintenance margin\n    function liquidationPrice(\n        Info storage self,\n        uint256 totalOi,\n        uint256 totalOiShares,\n        uint256 priceEntry,\n        uint256 marginMaintenance\n    ) internal view returns (\n        uint256 liquidationPrice_\n    ) {\n\n        Info memory _self = self;\n\n        liquidationPrice_ = _liquidationPrice(\n            _self,\n            totalOi,\n            totalOiShares,\n            priceEntry,\n            marginMaintenance\n        );\n\n    }\n}\n\n\n",
        "CodeNames": [
            "Position.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "isUnder",
                    "isUnderwater",
                    "_isUnderwater"
                ],
                "Type": " isUnderwater returns opposite boolean for short positions",
                "Description": "\n\nThe function isUnderwater should return true if the position value is < 0. In the case of a short position, this is when oi * (2 priceFrame) debt < 0 (based on the logic given in the _value function). Rearranging this equation, a short position is underwater if oi * 2 < oi * priceFrame + debt. However, in the function _isUnderwater in Position.sol, the left and right side of this equation is flipped, meaning that the function will return the opposite of what it should when called on short positions.\n\nFortunately, the V1 implementation of OverlayOVLCollateral does not directly use the isUnderwater function in major control flow changes. However, line 304 of OverlayV1OVLCollateral.sol is a comment that says:\n\n// TODO: think through edge case of underwater position ... and fee adjustments ...\n\nwhich hints that this function is going to be used to deal with underwater positions. As a result, this issue would have a huge impact if not properly dealt with.\n\n\nSee code for _isUnderwater here: <https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/libraries/Position.sol#L70\n\nNotice that for short positions the inequality is flipped from what it should be (indeed, when self.debt is higher it is more likely that isUnder will be false, which is obviously incorrect).\n\nAlso, see the TODO comment here that shows isUnderwater is important: <https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L304\n\n\nInspection\n\n",
                "Repair": "\nFlip the left and right side of the inequality for short positions in _isUnderwater.\n\nmikeyrf (Overlay) disagreed with severity(https://github.com/code-423n4/2021-11-overlay-findings/issues/53#issuecomment-988281184):\n  disagree with severity isUnderwater() isn't used anywhere in the collateral manager and markets. Is more for information purposes, so would rate this at a severity of 2 Medium in the event we had actually used this function for something more important\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/53#issuecomment-997196446):\n  I agree with the sponsor here. This represents a severe, but hypothetical issue.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.7;\nimport \"./LogExpMath.sol\";\nimport \"../utils/Errors.sol\";\n\n/* solhint-disable private-vars-leading-underscore */\n\nlibrary FixedPoint {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\n\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        uint256 c = a + b;\n        _require(c >= a, Errors.ADD_OVERFLOW);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        _require(b <= a, Errors.SUB_OVERFLOW);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\n\n        return product / ONE;\n    }\n\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\n\n        if (product == 0) {\n            return 0;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((product - 1) / ONE) + 1;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            return aInflated / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n     * the true value (that is, the error function expected - actual is always positive).\n     */\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\n\n        if (0 == y || x == ONE) return ONE;\n\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        if (raw < maxError) {\n            return 0;\n        } else {\n            return sub(raw, maxError);\n        }\n\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n     * the true value (that is, the error function expected - actual is always negative).\n     */\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\n\n        if (ONE == x || y == 0) return ONE;\n\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        return add(raw, maxError);\n\n    }\n\n    /**\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n     *\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\n     * prevents intermediate negative values.\n     */\n    function complement(uint256 x) internal pure returns (uint256) {\n        return (x < ONE) ? (ONE - x) : 0;\n    }\n}\n\n",
        "CodeNames": [
            "FixedPoint.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "JS\n function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n        _require(x < 2255, Errors.X_OUT_OF_BOUNDS);\n",
                    "JS\nfunction pow(uint256 x, uint256 y) internal pure returns (uint256) {\n    if (y == 0) {\n        // We solve the 0^0 indetermination by making it equal one.\n        return uint256(ONE_18);\n    }\n\n    if (x == 0) {\n        return 0;\n    }      \n    _require(x < 2255, Errors.X_OUT_OF_BOUNDS);\n"
                ],
                "Type": " pow() is missing check on input parameters with 0 value",
                "Description": "\n\nThe contract LogExpMath.sol seems to be a fork of the balancer LogExpMath.sol contract.\nIt is mostly similar, except for checks for x and y being 0 in the beginning of the function pow(), see below.\n\nThis omission might lead to unexpected results.\n\n\n<https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/libraries/LogExpMath.sol#L93-L110\n\nJS\n function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n        _require(x < 2255, Errors.X_OUT_OF_BOUNDS);\n\n\n<https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/solidity-utils/contracts/math/LogExpMath.sol#L93-L109\n\nJS\nfunction pow(uint256 x, uint256 y) internal pure returns (uint256) {\n    if (y == 0) {\n        // We solve the 0^0 indetermination by making it equal one.\n        return uint256(ONE_18);\n    }\n\n    if (x == 0) {\n        return 0;\n    }      \n    _require(x < 2255, Errors.X_OUT_OF_BOUNDS);\n\n\n",
                "Repair": "\nCheck if the extra code of the balance contract is useful and if so add it.\n\nrealisation (Overlay) disputed(https://github.com/code-423n4/2021-11-overlay-findings/issues/54#issuecomment-988278760):\n  Out of scope\n\ndmvt (judge) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/54#issuecomment-997201531):\n  I disagree with sponsor regarding scope. The Contracts section of the Contest Scope(https://github.com/code-423n4/2021-11-overlay/tree/914bed22f190ebe7088194453bab08c424c3f70c#contracts) lists several contracts which rely on contracts/libraries/FixedPoint.sol. This contract uses the pow function containing the issue described. The warden has not described an exact attack but has show a math issue, which can certainly lead to a hypothetical loss of funds. Medium severity is appropriate and sponsor should definitely fix this.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"../interfaces/IOverlayV1Market.sol\";\nimport \"../OverlayToken.sol\";\n\ncontract OverlayV1Mothership is AccessControlEnumerable {\n\n    uint16 public constant MIN_FEE = 1; // 0.01%\n    uint16 public constant MAX_FEE = 100; // 1.00%\n\n    uint16 public constant MIN_MARGIN_MAINTENANCE = 100; // 1% maintenance\n    uint16 public constant MAX_MARGIN_MAINTENANCE = 6000; // 60% maintenance\n\n    bytes32 public constant ADMIN = 0x00;\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant MINTER = keccak256(\"MINTER\");\n    bytes32 public constant BURNER = keccak256(\"BURNER\");\n\n    // ovl erc20 token\n    address public ovl;\n\n    // portion of liquidations to burn on update\n    uint public marginBurnRate;\n\n    // global params adjustable by gov\n    // build/unwind trading fee\n    uint public fee;\n    // portion of build/unwind fee burnt\n    uint public feeBurnRate;\n    // address to send fees to\n    address public feeTo;\n\n    mapping(address => bool) public marketActive;\n    mapping(address => bool) public marketExists;\n    address[] public allMarkets;\n\n    mapping(address => bool) public collateralExists;\n    mapping(address => bool) public collateralActive;\n    address[] public allCollateral;\n\n    modifier onlyGovernor () {\n        require(hasRole(GOVERNOR, msg.sender), \"OVLV1:!gov\");\n        _;\n    }\n\n    modifier onlyGuardian () {\n        require(hasRole(GUARDIAN, msg.sender), \"OVLV1:!guard\");\n        _;\n    }\n\n    constructor(\n        address _feeTo,\n        uint _fee,\n        uint _feeBurnRate,\n        uint _marginBurnRate\n    ) {\n\n        _setupRole(ADMIN, msg.sender);\n        _setupRole(GOVERNOR, msg.sender);\n        _setupRole(GUARDIAN, msg.sender);\n        _setRoleAdmin(GOVERNOR, ADMIN);\n        _setRoleAdmin(GUARDIAN, ADMIN);\n\n        // global params\n        fee = _fee;\n        feeBurnRate = _feeBurnRate;\n        feeTo = _feeTo;\n        marginBurnRate = _marginBurnRate;\n\n    }\n\n    function setOVL (address _ovl) external onlyGovernor {\n\n        ovl = _ovl;\n\n    }\n\n    function totalMarkets () external view returns (uint) {\n        return allMarkets.length;\n    }\n\n    /// @notice Initializes an existing market contract after deployment\n    /// @dev Should be called after contract deployment in specific market factory.createMarket\n    function initializeMarket(address market) external onlyGovernor {\n\n        require(!marketExists[market], \"OVLV1:!!initialized\");\n\n        marketExists[market] = true;\n        marketActive[market] = true;\n\n        allMarkets.push(market);\n\n    }\n\n    /// @notice Disables an existing market contract for a mirin market\n    function disableMarket(address market) external onlyGovernor {\n\n        require(marketActive[market], \"OVLV1: !enabled\");\n\n        marketActive[market] = false;\n\n    }\n\n    /// @notice Enables an existing market contract for a mirin market\n    function enableMarket(address market) external onlyGovernor {\n\n        require(marketExists[market], \"OVLV1: !exists\");\n\n        require(!marketActive[market], \"OVLV1: !disabled\");\n\n        marketActive[market] = true;\n\n    }\n\n    function initializeCollateral (address _collateral) external onlyGovernor {\n\n        require(!collateralExists[_collateral], \"OVLV1:!!iintialized\");\n\n        collateralExists[_collateral] = true;\n        collateralActive[_collateral] = true;\n\n        allCollateral.push(_collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    function enableCollateral (address _collateral) external onlyGovernor {\n\n        require(collateralExists[_collateral], \"OVLV1:!exists\");\n\n        require(!collateralActive[_collateral], \"OVLV1:!disabled\");\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    function disableCollateral (address _collateral) external onlyGovernor {\n\n        require(collateralActive[_collateral], \"OVLV1:!enabled\");\n\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    /// @notice Allows gov to adjust per market params\n\n    /// @notice Allows gov to adjust global params\n    function adjustGlobalParams(\n        uint16 _fee,\n        uint16 _feeBurnRate,\n        address _feeTo\n    ) external onlyGovernor {\n        fee = _fee;\n        feeBurnRate = _feeBurnRate;\n        feeTo = _feeTo;\n    }\n\n    function getUpdateParams() external view returns (\n        uint,\n        uint,\n        address\n    ) {\n        return (\n            marginBurnRate,\n            feeBurnRate,\n            feeTo\n        );\n    }\n\n}\n\n\n",
        "CodeNames": [
            "OverlayV1Mothership.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "JS\nfunction enableCollateral (address _collateral) external onlyGovernor {\n    require(collateralExists[_collateral], \"OVLV1:!exists\");\n    require(!collateralActive[_collateral], \"OVLV1:!disabled\");\n    OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n    OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n}\n\nfunction disableCollateral (address _collateral) external onlyGovernor {\n    require(collateralActive[_collateral], \"OVLV1:!enabled\");\n    OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n    OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n}\n"
                ],
                "Type": " Can't enableCollateral after a disableCollateral ",
                "Description": "\n\nThe function disableCollateral of OverlayV1Mothership.sol doesn't set collateralActive[_collateral] = false;\nBut it does revoke the roles.\n\nNow enableCollateral  can never be used because collateralActive[_collateral] ==true  and it will never pass the second require.\nSo you can never grant the roles again.\n\nNote: enableCollateral also doesn't set collateralActive[_collateral] = true\n\n\n<https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/mothership/OverlayV1Mothership.sol#L133-L153\n\nJS\nfunction enableCollateral (address _collateral) external onlyGovernor {\n    require(collateralExists[_collateral], \"OVLV1:!exists\");\n    require(!collateralActive[_collateral], \"OVLV1:!disabled\");\n    OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n    OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n}\n\nfunction disableCollateral (address _collateral) external onlyGovernor {\n    require(collateralActive[_collateral], \"OVLV1:!enabled\");\n    OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n    OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n}\n\n\n",
                "Repair": "\nIn function enableCollateral() add the following (after the require):\ncollateralActive[_collateral] = true;\n\nIn function disableCollateral add the following (after the require):\ncollateralActive[_collateral] = false;\n\nmikeyrf (Overlay) confirmed(https://github.com/code-423n4/2021-11-overlay-findings/issues/55) \n\n\n"
            }
        ]
    },
    {
        "Code": "\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IOverlayTokenNew.sol\";\nimport \"./utils/AccessControlEnumerable.sol\";\nimport \"./utils/Context.sol\";\n\n\ncontract OverlayTokenNew is Context, IOverlayTokenNew, AccessControlEnumerable {\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    bytes32 public constant ADMIN_ROLE = 0x00;\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER\");\n\n    string constant public override name = \"Overlay Token\";\n    string constant public override symbol = \"OVL\";\n    uint256 constant public override decimals = 18;\n\n    uint256 private _totalSupply;\n\n    constructor() {\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(MINTER_ROLE, msg.sender);\n        _setupRole(BURNER_ROLE, msg.sender);\n        _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(BURNER_ROLE, ADMIN_ROLE);\n\n    }\n\n    modifier onlyMinter() {\n        require(hasRole(MINTER_ROLE, msg.sender), \"OVL:!minter\");\n        _;\n    }\n\n    modifier onlyBurner() {\n        require(hasRole(BURNER_ROLE, msg.sender), \"OVL:!burner\");\n        _;\n    }\n\n\n    /// @dev Get the current total supply of OVL.\n    /// @return totalSupply_ The outstanding supply of OVL tokens.\n    function totalSupply() public view virtual override returns (\n        uint256 totalSupply_\n    ) {\n        totalSupply_ = _totalSupply;\n    }\n\n    /// @dev Get OVL balance of a given account.\n    /// @param account Account to find the OVL balance of.\n    /// @return balance_ The account's balance of OVL.\n    function balanceOf(\n        address account\n    ) public view virtual override returns (\n        uint256 balance_\n    ) {\n\n        balance_ = _balances[account];\n\n    }\n\n\n    /// @dev Transfer amount of tokens from msg.sender to recipient\n    /// @param recipient Can not be the zero address.\n    /// @param amount Msg.sender must have at least this amount in tokens.\n    /// @return success_ Returns success == true when call does not revert.\n    function transfer(\n        address recipient, \n        uint256 amount\n    ) public virtual override returns (\n        bool success_\n    ) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        success_ = true;\n\n    }\n\n\n    /// @dev Returns allowance on one account for another account.\n    /// @param owner Account to allow another to spend its tokens.\n    /// @param spender Account allowed to spend the tokens of another.\n    /// @return allowance_ Amount of tokens owner allows spender to control.\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n\n    /// @dev Allows one account to approve another to spend from its balance. \n    /// @param spender Account to allow to spend from msg.sender's balance.\n    /// @param amount Amount to allow spending of.\n    /// @return success_ Returns success == true if call does not revert.\n    function approve(\n        address spender, \n        uint256 amount\n    ) public virtual override returns (\n        bool success_\n    ) {\n\n        _approve(_msgSender(), spender, amount);\n\n        success_ = true;\n\n    }\n\n    /// @dev Transfers tokens from sender to recipient if sender has allowance.\n    /// @param sender Address of account from which to send tokens.\n    /// @param recipient Address of account to receive tokens.\n    /// @param amount Amount of tokens to send.\n    /// @param success_ Returns success == true if call does not revert.\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (\n        bool success_\n    ) {\n\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n\n        unchecked { _approve(sender, _msgSender(), currentAllowance - amount); }\n\n        success_ = true;\n\n    }\n\n\n    /// @dev Allows msg.sender to simultaneously send and burn tokens.\n    /// @param recipient Account to send tokens to.\n    /// @param amount Amount of tokens to send.\n    /// @param burnt Amount of tokens to burn from msg.sender.\n    /// @return success_ Returns success == true if call does not revert.\n    function transferBurn(\n        address recipient,\n        uint256 amount,\n        uint256 burnt\n    ) public override onlyBurner returns (\n        bool\n    ) {\n\n        _transferBurn(msg.sender, recipient, amount, burnt);\n\n        return true;\n\n    }\n\n\n    /// @dev Allows msg.sender to simultaneously send and burn tokens \n    /// from sender according to allowance granted.\n    /// @param sender Address from which to transfer tokens.\n    /// @param recipient Address to trasnfer tokens into.\n    /// @param amount Amount of tokens to send.\n    /// @param burnt Amount of tokens to burn.\n    /// @return success Returns true if call does not revert.\n    function transferFromBurn(\n        address sender,\n        address recipient,\n        uint256 amount,\n        uint256 burnt\n    ) public override onlyBurner returns (\n        bool success\n    ) {\n\n        _transferBurn(sender, recipient, amount, burnt);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n\n        require(currentAllowance >= amount + burnt, \"OVL:allowance<amount+burnt\");\n\n        unchecked { _approve(sender, msg.sender, currentAllowance - amount - burnt); }\n\n        success = true;\n\n    }\n    \n\n    /// @dev Internal function to transfer and burn OVL simultaneously.\n    /// @param sender Address to send and burn from.\n    /// @param recipient Address to send to.\n    /// @param amount Amount to send.\n    /// @param burnt Amount to burn.\n    function _transferBurn(\n        address sender,\n        address recipient,\n        uint256 amount,\n        uint256 burnt\n    ) internal {\n\n        uint256 senderBalance = _balances[sender];\n\n        require(senderBalance >= amount + burnt, \"OVL:balance<amount+burnt\");\n\n        unchecked { _balances[sender] = senderBalance - amount - burnt; }\n\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n        emit Transfer(sender, address(0), burnt);\n\n    }\n\n    /// @dev Allows msg.sender to simultaneously transfer tokens and mint \n    /// to the recipient.\n    /// @param recipient Account to transfer and mint tokens to.\n    /// @param amount Amount of tokens to transfer.\n    /// @param minted Amount of tokens to mint.\n    /// @return success Returns true if call does not revert.\n    function transferMint(\n        address recipient,\n        uint256 amount,\n        uint256 minted\n    ) public override onlyMinter returns (\n        bool success\n    ) {\n\n        _transferMint(msg.sender, recipient, amount, minted);\n\n        success = true;\n\n    }\n\n    /// @dev Allows msg.sender to simultaneously transfer from sender \n    /// according to its granted allowance and mint to recipient.\n    /// @param sender Account to transfer tokens from.\n    /// @param recipient Account to transfer tokens and mint to.\n    /// @param amount Amount of tokens to transfer.\n    /// @param minted Amount of tokens to mint.\n    /// @return success Returns true if call does not revert.\n    function transferFromMint(\n        address sender,\n        address recipient,\n        uint256 amount,\n        uint256 minted\n    ) public override onlyMinter returns (\n        bool\n    ) {\n\n        _transferMint(sender, recipient, amount, minted);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n\n        require(currentAllowance >= amount, \"OVL:allowance<amount\");\n\n        unchecked { _approve(sender, msg.sender, currentAllowance - amount); }\n\n        return true;\n\n    }\n\n    /// @dev Internal function taking care of transfering from sender \n    /// to recipient and minting at recipient.\n    /// @param sender Account to transfer tokens from.\n    /// @param recipient Account to transfer tokens to and mint at.\n    /// @param amount Amount of tokens to transfer.\n    /// @param minted Amount of tokens to mint.\n    function _transferMint(\n        address sender,\n        address recipient,\n        uint256 amount,\n        uint256 minted\n    ) internal {\n\n        uint256 senderBalance = _balances[sender];\n\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        unchecked { _balances[sender] = senderBalance - amount; }\n\n        _balances[recipient] += amount + minted;\n\n        emit Transfer(sender, recipient, amount);\n        emit Transfer(address(0), recipient, minted);\n\n    }\n\n    function increaseAllowance(\n        address spender, \n        uint256 addedValue\n    ) public virtual returns (\n        bool success\n    ) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n\n        success = true;\n\n    }\n\n    function decreaseAllowance(\n        address spender, \n        uint256 subtractedValue\n    ) public virtual returns (\n        bool success\n    ) {\n\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n\n        unchecked { _approve(_msgSender(), spender, currentAllowance - subtractedValue); }\n\n        success = true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n\n    function mint(\n        address _recipient, \n        uint256 _amount\n    ) external override onlyMinter {\n\n        _mint(_recipient, _amount);\n\n    }\n\n    function _mint(\n        address account, \n        uint256 amount\n    ) internal virtual {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n\n    }\n\n    function burn(\n        address _account, \n        uint256 _amount\n    ) external override onlyBurner {\n\n        _burn(_account, _amount);\n\n    }\n\n\n    function _burn(\n        address account, \n        uint256 amount\n    ) internal virtual {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n}\n\n",
        "CodeNames": [
            "OverlayToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "js\nfunction _mint( address account, uint256 amount) internal virtual {\n   ...\n      _totalSupply += amount;\n",
                    "js\nfunction _burn(address account, uint256 amount) internal virtual {\n   ...\n        _totalSupply -= amount;\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286\n"
                ],
                "Type": " _totalSupply not updated in _transferMint() and _transferBurn() ",
                "Description": "\n\nThe functions _transferMint() and _transferBurn() of OverlayToken.sol don't update _totalSupply.\nWhereas the similar functions _mint() and _burn() do update _totalSupply.\n\nThis means that _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens.\n\nFor the protocol itself it isn't such a problem because this value isn't used in the protocol (as far as I can see).\nBut other protocols building on Overlay may use it, as well as user interfaces and analytic platforms.\n\n\n<https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L349-L364\n\njs\nfunction _mint( address account, uint256 amount) internal virtual {\n   ...\n      _totalSupply += amount;\n\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L376-L395\n\njs\nfunction _burn(address account, uint256 amount) internal virtual {\n   ...\n        _totalSupply -= amount;\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286\n\n\n## Recommended Mitigation Steps\nUpdate _totalSupply  in _transferMint() and _transferBurn()\n\n\nrealisation (Overlay) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/59#issuecomment-988286320):\n  We're not sure if this is a 1 or a 2. Definitely, at least a one this is an incorrect implementation of the spec. \n \n But is it a two? It wouldn't lose funds with our contracts, we make no use of the total supply of OVL in our accounting.\n \n This might prove to be a vulnerability if another protocol, like Ribbon, used us for a vault of theirs, made use of total supply, and failed to discern this problem.\n \n \n \n \n\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./libraries/FixedPoint.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol\";\nimport \"./interfaces/IUniswapV3Pool.sol\";\nimport \"./market/OverlayV1Market.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/TickMath.sol\";\n\ncontract OverlayV1UniswapV3Market is OverlayV1Market {\n\n    using FixedPoint for uint256;\n\n    uint256 internal X96 = 0x1000000000000000000000000;\n\n    uint256 public immutable macroWindow; // window size for main TWAP\n    uint256 public immutable microWindow; // window size for bid/ask TWAP\n\n    address public immutable marketFeed;\n    address public immutable ovlFeed;\n    address public immutable base;\n    address public immutable quote;\n    uint128 internal immutable baseAmount;\n\n    address internal immutable eth;\n    bool internal immutable ethIs0;\n\n    constructor(\n        address _mothership,\n        address _ovlFeed,\n        address _marketFeed,\n        address _quote,\n        address _eth,\n        uint128 _baseAmount,\n        uint256 _macroWindow,\n        uint256 _microWindow,\n        uint256 _priceFrameCap\n    ) OverlayV1Market (\n        _mothership\n    ) OverlayV1Comptroller (\n        _microWindow\n    ) OverlayV1OI (\n        _microWindow\n    ) OverlayV1PricePoint (\n        _priceFrameCap\n    ) {\n\n        // immutables\n        eth = _eth;\n        ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\n        ovlFeed = _ovlFeed;\n        marketFeed = _marketFeed;\n        baseAmount = _baseAmount;\n        macroWindow = _macroWindow;\n        microWindow = _microWindow;\n\n        address _token0 = IUniswapV3Pool(_marketFeed).token0();\n        address _token1 = IUniswapV3Pool(_marketFeed).token1();\n\n        base = _token0 != _quote ? _token0 : _token1;\n        quote = _token0 == _quote ? _token0 : _token1;\n\n        int24 _tick = OracleLibraryV2.consult(\n            _marketFeed,\n            uint32(_macroWindow),\n            uint32(0)\n        );\n\n        _pricePoints.push(PricePoint(\n            _tick, \n            _tick, \n            0\n        ));\n\n        uint _price = OracleLibraryV2.getQuoteAtTick(\n            _tick,\n            uint128(_baseAmount),\n            _token0 != _quote ? _token0 : _token1,\n            _token0 == _quote ? _token0 : _token1\n        );\n\n        emit NewPricePoint(_price, _price, 0);\n\n    }\n\n\n    /// @notice Reads the current price and depth information\n    /// @dev Reads price and depth of market feed\n    /// @return price_ Price point\n    function fetchPricePoint () public view override returns (\n        PricePoint memory price_\n    ) {\n\n        int56[] memory _ticks;\n        uint160[] memory _liqs;\n\n        uint _ovlPrice;\n        uint _marketLiquidity;\n\n        int24 _microTick;\n        int24 _macroTick;\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](3);\n            _secondsAgo[2] = uint32(macroWindow);\n            _secondsAgo[1] = uint32(microWindow);\n\n            ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n\n            _macroTick = int24(( _ticks[0] - _ticks[2]) / int56(int32(int(macroWindow))));\n\n            _microTick = int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))));\n\n            uint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);\n\n            uint _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );\n\n            _marketLiquidity = ethIs0\n                ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n                : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n\n        }\n\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](2);\n\n            _secondsAgo[1] = uint32(macroWindow);\n\n            ( _ticks, ) = IUniswapV3Pool(ovlFeed).observe(_secondsAgo);\n\n            _ovlPrice = OracleLibraryV2.getQuoteAtTick(\n                int24((_ticks[0] - _ticks[1]) / int56(int32(int(macroWindow)))),\n                1e18,\n                ovl,\n                eth\n            );\n\n        }\n\n        price_ = PricePoint(\n            _microTick, \n            _macroTick, \n            computeDepth(_marketLiquidity, _ovlPrice)\n        );\n\n    }\n\n\n    /// @notice Arithmetic to get depth\n    /// @dev Derived from cnstant product formula X*Y=K and tailored \n    /// to Uniswap V3 selective liquidity provision.\n    /// @param _marketLiquidity Amount of liquidity in market in ETH terms.\n    /// @param _ovlPrice Price of OVL against ETH.\n    /// @return depth_ Depth criteria for market in OVL terms.\n    function computeDepth (\n        uint _marketLiquidity,\n        uint _ovlPrice\n    ) public override view returns (\n        uint depth_\n    ) {\n\n        depth_ = ((_marketLiquidity * 1e18) / _ovlPrice)\n            .mulUp(lmbda)    \n            .divDown(2e18);\n\n    }\n\n    function _tickToPrice (\n        int24 _tick\n    ) public override view returns (\n        uint quote_\n    ) {\n\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(_tick);\n\n        // better precision if no overflow when squared\n        if (sqrtRatioX96 <= type(uint128).max) {\n\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n\n            quote_ = base < quote\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n\n        } else {\n\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n\n            quote_ = base < quote\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n\n        }\n\n    }\n\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"../interfaces/IOverlayV1Market.sol\";\nimport \"../OverlayToken.sol\";\n\ncontract OverlayV1Mothership is AccessControlEnumerable {\n\n    uint16 public constant MIN_FEE = 1; // 0.01%\n    uint16 public constant MAX_FEE = 100; // 1.00%\n\n    uint16 public constant MIN_MARGIN_MAINTENANCE = 100; // 1% maintenance\n    uint16 public constant MAX_MARGIN_MAINTENANCE = 6000; // 60% maintenance\n\n    bytes32 public constant ADMIN = 0x00;\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant MINTER = keccak256(\"MINTER\");\n    bytes32 public constant BURNER = keccak256(\"BURNER\");\n\n    // ovl erc20 token\n    address public ovl;\n\n    // portion of liquidations to burn on update\n    uint public marginBurnRate;\n\n    // global params adjustable by gov\n    // build/unwind trading fee\n    uint public fee;\n    // portion of build/unwind fee burnt\n    uint public feeBurnRate;\n    // address to send fees to\n    address public feeTo;\n\n    mapping(address => bool) public marketActive;\n    mapping(address => bool) public marketExists;\n    address[] public allMarkets;\n\n    mapping(address => bool) public collateralExists;\n    mapping(address => bool) public collateralActive;\n    address[] public allCollateral;\n\n    modifier onlyGovernor () {\n        require(hasRole(GOVERNOR, msg.sender), \"OVLV1:!gov\");\n        _;\n    }\n\n    modifier onlyGuardian () {\n        require(hasRole(GUARDIAN, msg.sender), \"OVLV1:!guard\");\n        _;\n    }\n\n    constructor(\n        address _feeTo,\n        uint _fee,\n        uint _feeBurnRate,\n        uint _marginBurnRate\n    ) {\n\n        _setupRole(ADMIN, msg.sender);\n        _setupRole(GOVERNOR, msg.sender);\n        _setupRole(GUARDIAN, msg.sender);\n        _setRoleAdmin(GOVERNOR, ADMIN);\n        _setRoleAdmin(GUARDIAN, ADMIN);\n\n        // global params\n        fee = _fee;\n        feeBurnRate = _feeBurnRate;\n        feeTo = _feeTo;\n        marginBurnRate = _marginBurnRate;\n\n    }\n\n    function setOVL (address _ovl) external onlyGovernor {\n\n        ovl = _ovl;\n\n    }\n\n    function totalMarkets () external view returns (uint) {\n        return allMarkets.length;\n    }\n\n    /// @notice Initializes an existing market contract after deployment\n    /// @dev Should be called after contract deployment in specific market factory.createMarket\n    function initializeMarket(address market) external onlyGovernor {\n\n        require(!marketExists[market], \"OVLV1:!!initialized\");\n\n        marketExists[market] = true;\n        marketActive[market] = true;\n\n        allMarkets.push(market);\n\n    }\n\n    /// @notice Disables an existing market contract for a mirin market\n    function disableMarket(address market) external onlyGovernor {\n\n        require(marketActive[market], \"OVLV1: !enabled\");\n\n        marketActive[market] = false;\n\n    }\n\n    /// @notice Enables an existing market contract for a mirin market\n    function enableMarket(address market) external onlyGovernor {\n\n        require(marketExists[market], \"OVLV1: !exists\");\n\n        require(!marketActive[market], \"OVLV1: !disabled\");\n\n        marketActive[market] = true;\n\n    }\n\n    function initializeCollateral (address _collateral) external onlyGovernor {\n\n        require(!collateralExists[_collateral], \"OVLV1:!!iintialized\");\n\n        collateralExists[_collateral] = true;\n        collateralActive[_collateral] = true;\n\n        allCollateral.push(_collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    function enableCollateral (address _collateral) external onlyGovernor {\n\n        require(collateralExists[_collateral], \"OVLV1:!exists\");\n\n        require(!collateralActive[_collateral], \"OVLV1:!disabled\");\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    function disableCollateral (address _collateral) external onlyGovernor {\n\n        require(collateralActive[_collateral], \"OVLV1:!enabled\");\n\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    /// @notice Allows gov to adjust per market params\n\n    /// @notice Allows gov to adjust global params\n    function adjustGlobalParams(\n        uint16 _fee,\n        uint16 _feeBurnRate,\n        address _feeTo\n    ) external onlyGovernor {\n        fee = _fee;\n        feeBurnRate = _feeBurnRate;\n        feeTo = _feeTo;\n    }\n\n    function getUpdateParams() external view returns (\n        uint,\n        uint,\n        address\n    ) {\n        return (\n            marginBurnRate,\n            feeBurnRate,\n            feeTo\n        );\n    }\n\n}\n\n\n",
        "CodeNames": [
            "OverlayV1UniswapV3Market.sol",
            "OverlayV1Mothership.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "initializeMarket",
                    "adjustGlobalParams",
                    "OverlayV",
                    "setOVL",
                    "disableMarket",
                    "disableCollateral",
                    "enableMarket",
                    "initializeCollateral",
                    "enableCollateral"
                ],
                "Type": " Timelock and events for governor functions",
                "Description": "\n\nThere are contracts that contain functions that change important parameters of the system, e.g. OverlayV1Mothership has setOVL, initializeMarket, disableMarket, enableMarket, initializeCollateral, enableCollateral, disableCollateral, adjustGlobalParams. None of these functions emit events, nor they are timelocked. Usually, it is a good practice to give time for users to react and adjust to changes.\n\nA similar issue was submitted in a previous contest and assigned a severity of Medium: <https://github.com/code-423n4/2021-09-swivel-findings/issues/101\n\n",
                "Repair": "\nConsider using a timelock for critical params of the system and emitting events to inform the outside world.\n\nrealisation (Overlay) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/120#issuecomment-978096272):\n  The plan has been to have a timelock at some point in the protocol. Probably on whatever is the admin for the mothership. But this just had to be evaluated. It might be on the market contract itself, or on the addresses granted the role of admin.\n\nmikeyrf (Overlay) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/120#issuecomment-987979184):\n  duplicate #64 \n\ndmvt (judge) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/120#issuecomment-997204779):\n  I'm removing the duplicate in this case because issue #64 refers exclusively to the events. This issue is focused primarily on the lack of governance timelock, which has traditionally been considered a medium severity issue.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"../interfaces/IOverlayV1Market.sol\";\nimport \"../OverlayToken.sol\";\n\ncontract OverlayV1Mothership is AccessControlEnumerable {\n\n    uint16 public constant MIN_FEE = 1; // 0.01%\n    uint16 public constant MAX_FEE = 100; // 1.00%\n\n    uint16 public constant MIN_MARGIN_MAINTENANCE = 100; // 1% maintenance\n    uint16 public constant MAX_MARGIN_MAINTENANCE = 6000; // 60% maintenance\n\n    bytes32 public constant ADMIN = 0x00;\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant MINTER = keccak256(\"MINTER\");\n    bytes32 public constant BURNER = keccak256(\"BURNER\");\n\n    // ovl erc20 token\n    address public ovl;\n\n    // portion of liquidations to burn on update\n    uint public marginBurnRate;\n\n    // global params adjustable by gov\n    // build/unwind trading fee\n    uint public fee;\n    // portion of build/unwind fee burnt\n    uint public feeBurnRate;\n    // address to send fees to\n    address public feeTo;\n\n    mapping(address => bool) public marketActive;\n    mapping(address => bool) public marketExists;\n    address[] public allMarkets;\n\n    mapping(address => bool) public collateralExists;\n    mapping(address => bool) public collateralActive;\n    address[] public allCollateral;\n\n    modifier onlyGovernor () {\n        require(hasRole(GOVERNOR, msg.sender), \"OVLV1:!gov\");\n        _;\n    }\n\n    modifier onlyGuardian () {\n        require(hasRole(GUARDIAN, msg.sender), \"OVLV1:!guard\");\n        _;\n    }\n\n    constructor(\n        address _feeTo,\n        uint _fee,\n        uint _feeBurnRate,\n        uint _marginBurnRate\n    ) {\n\n        _setupRole(ADMIN, msg.sender);\n        _setupRole(GOVERNOR, msg.sender);\n        _setupRole(GUARDIAN, msg.sender);\n        _setRoleAdmin(GOVERNOR, ADMIN);\n        _setRoleAdmin(GUARDIAN, ADMIN);\n\n        // global params\n        fee = _fee;\n        feeBurnRate = _feeBurnRate;\n        feeTo = _feeTo;\n        marginBurnRate = _marginBurnRate;\n\n    }\n\n    function setOVL (address _ovl) external onlyGovernor {\n\n        ovl = _ovl;\n\n    }\n\n    function totalMarkets () external view returns (uint) {\n        return allMarkets.length;\n    }\n\n    /// @notice Initializes an existing market contract after deployment\n    /// @dev Should be called after contract deployment in specific market factory.createMarket\n    function initializeMarket(address market) external onlyGovernor {\n\n        require(!marketExists[market], \"OVLV1:!!initialized\");\n\n        marketExists[market] = true;\n        marketActive[market] = true;\n\n        allMarkets.push(market);\n\n    }\n\n    /// @notice Disables an existing market contract for a mirin market\n    function disableMarket(address market) external onlyGovernor {\n\n        require(marketActive[market], \"OVLV1: !enabled\");\n\n        marketActive[market] = false;\n\n    }\n\n    /// @notice Enables an existing market contract for a mirin market\n    function enableMarket(address market) external onlyGovernor {\n\n        require(marketExists[market], \"OVLV1: !exists\");\n\n        require(!marketActive[market], \"OVLV1: !disabled\");\n\n        marketActive[market] = true;\n\n    }\n\n    function initializeCollateral (address _collateral) external onlyGovernor {\n\n        require(!collateralExists[_collateral], \"OVLV1:!!iintialized\");\n\n        collateralExists[_collateral] = true;\n        collateralActive[_collateral] = true;\n\n        allCollateral.push(_collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    function enableCollateral (address _collateral) external onlyGovernor {\n\n        require(collateralExists[_collateral], \"OVLV1:!exists\");\n\n        require(!collateralActive[_collateral], \"OVLV1:!disabled\");\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    function disableCollateral (address _collateral) external onlyGovernor {\n\n        require(collateralActive[_collateral], \"OVLV1:!enabled\");\n\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n\n    }\n\n    /// @notice Allows gov to adjust per market params\n\n    /// @notice Allows gov to adjust global params\n    function adjustGlobalParams(\n        uint16 _fee,\n        uint16 _feeBurnRate,\n        address _feeTo\n    ) external onlyGovernor {\n        fee = _fee;\n        feeBurnRate = _feeBurnRate;\n        feeTo = _feeTo;\n    }\n\n    function getUpdateParams() external view returns (\n        uint,\n        uint,\n        address\n    ) {\n        return (\n            marginBurnRate,\n            feeBurnRate,\n            feeTo\n        );\n    }\n\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n\n\n",
        "CodeNames": [
            "OverlayV1Mothership.sol",
            "IUniswapV3PoolOwnerActions.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "setFee",
                    "adjustGlobalParams"
                ],
                "Type": " Improper Upper Bound Definition on the Fee",
                "Description": "\n\nIn the adjustGlobalParams function on line 1603 of \"<https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L1630\", adjustGlobalParams function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.\n\n\n*   The setFee function that begins on line 163 of adjustGlobalParams sets the liquidity and transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system.\n*   Navigate to \"<https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L163\" contract and go to line #163.\n*   On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.\n\n\nNone\n\n",
                "Repair": "\nConsider defining upper and lower bounds on the adjustGlobalParams function.\n\nmikeyrf (Overlay) confirmed(https://github.com/code-423n4/2021-11-overlay-findings/issues/77) \n\ndmvt (judge) commented(https://github.com/code-423n4/2021-11-overlay-findings/issues/77#issuecomment-997195772):\n  Several wardens have marked this issue as high severity due to the potential for governance to rug users. Several have marked it as low risk because it's really just a bounding issue and presumably governance would not willingly choose to rug their users. \n \n I view this a medium severity issue. If exploited, the impact would be high. The likelihood that it would be exploited intentionally or happen unintentionally is low, but not impossible as the uninformed users dynamic could come into play here.\n\n\n"
            }
        ]
    }
]