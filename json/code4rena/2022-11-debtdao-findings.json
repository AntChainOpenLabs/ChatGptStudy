[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Call to  declareInsolvent()  would revert when contract status reaches liquidation point after repayment of credit position 1",
                "Description": "*Submitted by cryptphi(https://github.com/code-423n4/2022-11-debtdao-findings/issues/69), also found by adriro(https://github.com/code-423n4/2022-11-debtdao-findings/issues/329), Ch_301(https://github.com/code-423n4/2022-11-debtdao-findings/issues/316), PaludoX0(https://github.com/code-423n4/2022-11-debtdao-findings/issues/211), ayeslick(https://github.com/code-423n4/2022-11-debtdao-findings/issues/166), and perseverancesuccess(https://github.com/code-423n4/2022-11-debtdao-findings/issues/150)*\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L143\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L83-L86\n\n\nThe modifier whileBorrowing() is used along in the call to LineOfCredit.declareInsolvent(). However this check reverts when count == 0 or credits[ids[0]].principal == 0 . Within the contract, any lender can add credit which adds an entry in credits array, credits[ids].\n\nAssume, when borrower chooses lender positions including credits[ids[0]] to draw on, and repays back the loan fully for credits[ids[1]], then the call to declareInsolvent() by the arbiter would revert since it does not pass the whileBorrowing() modifier check due to the ids array index shift in the call to  stepQ(), which would shift ids[1] to ids[0], thereby making the condition for credits[ids[0]].principal == 0 be true causing the revert.\n\n\n1.  LineOfCredit contract is set up and 5 lenders have deposited into the contract.\n2.  Alice, the borrower borrows credit from these 5 credit positions including by calling LineOfCredit.borrow() for the position ids.\n3.  Later Alice pays back the loan for  credit position id 1 just before the contract gets liquidated.\n4.  At the point where ids.stepQ() is called in _repay(), position 1 is moved to ids[0]\n5.  When contract status is LIQUIDATABLE, no loan drawn on credit position 0 and arbiter calls declareInsolvent() , the call would revert since credits[ids[0]].principal == 0\n\n",
                "Repair": "\nThe modifier whileBorrowing() would need to be reviewed and amended.\n\ndmvt (judge) increased severity to High(https://github.com/code-423n4/2022-11-debtdao-findings/issues/69)\n\nkibagateaux (Debt DAO) confirmed(https://github.com/code-423n4/2022-11-debtdao-findings/issues/69)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n       if(self.settings[revenueContract].claimFunction == bytes4(0)) {\n            // push payments\n\n            // claimed = total balance already accounted for balance\n            claimed = existingBalance self.escrowed[token]; //@audit Rebasing tokens\n            // underflow revert ensures we have more tokens than we started with and actually claimed revenue\n        }\n",
                    "//solidity\nuint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;\n",
                    "diff\n--a/contracts/tests/Spigot.t.sol\n+++ b/contracts/tests/Spigot.t.sol\n@@ -174,7 +174,7 @@ contract SpigotTest is Test {\n         assertEq(token.balanceOf(address(spigot)), totalRevenue);\n         \n         bytes memory claimData;\n       spigot.claimRevenue(revenueContract, address(token), claimData);\n+        spigot.claimRevenue(address(0), address(token), claimData);\n"
                ],
                "Type": " Non-existing revenue contract can be passed to claimRevenue to send all tokens to treasury",
                "Description": "*Submitted by Lambda(https://github.com/code-423n4/2022-11-debtdao-findings/issues/119), also found by berndartmueller(https://github.com/code-423n4/2022-11-debtdao-findings/issues/462), adriro(https://github.com/code-423n4/2022-11-debtdao-findings/issues/317), and aphak5010(https://github.com/code-423n4/2022-11-debtdao-findings/issues/70)*\n\nNeither SpigotLib.claimRevenue nor SpigotLib._claimRevenue check that the provided revenueContract was registered before. If this is not the case, SpigotLib._claimRevenue assumes that this is a revenue contract with push payments (because self.settings[revenueContract].claimFunction is 0) and just returns the difference since the last call to claimRevenue:\n\nsolidity\n       if(self.settings[revenueContract].claimFunction == bytes4(0)) {\n            // push payments\n\n            // claimed = total balance already accounted for balance\n            claimed = existingBalance self.escrowed[token]; //@audit Rebasing tokens\n            // underflow revert ensures we have more tokens than we started with and actually claimed revenue\n        }\n\n\nSpigotLib.claimRevenue will then read self.settings[revenueContract].ownerSplit, which is 0 for non-registered revenue contracts:\n\nsolidity\nuint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;\n\n\nTherefore, the whole claimed amount is sent to the treasury.\n\nThis becomes very problematic for revenue tokens that use push payments. An attacker (in practice the borrower) can just regularly call claimRevenue with this token and a non-existing revenue contract. All of the tokens that were sent to the spigot since the last call will be sent to the treasury and none to the escrow, i.e. a borrower can ensure that no revenue will be available for the lender, no matter what the configured split is.\n\n\nAs mentioned above, the attack pattern works for arbitrary tokens where one (or more) revenue contracts use push payments, i.e. where the balance of the Spigot increases from time to time. Then, the attacker just calls claimRevenue with a non-existing address. This is illustrated in the following diff:\n\ndiff\n--a/contracts/tests/Spigot.t.sol\n+++ b/contracts/tests/Spigot.t.sol\n@@ -174,7 +174,7 @@ contract SpigotTest is Test {\n         assertEq(token.balanceOf(address(spigot)), totalRevenue);\n         \n         bytes memory claimData;\n       spigot.claimRevenue(revenueContract, address(token), claimData);\n+        spigot.claimRevenue(address(0), address(token), claimData);\n\n\nThanks to this small modification, all of the tokens are sent to the treasury and none are sent to the escrow.\n\n",
                "Repair": "\nCheck that a revenue contract was registered before, revert if it does not.\n\nkibagateaux (Debt DAO) confirmed(https://github.com/code-423n4/2022-11-debtdao-findings/issues/119) \n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nmodifier mutualConsent(address _signerOne, address _signerTwo) {\n      if(_mutualConsent(_signerOne, _signerTwo))  {\n        // Run whatever code needed 2/2 consent\n        _;\n      }\n}\n\nfunction _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {\n        if(msg.sender != _signerOne && msg.sender != _signerTwo) { revert Unauthorized(); }\n\n        address nonCaller = _getNonCaller(_signerOne, _signerTwo);\n\n        // The consent hash is defined by the hash of the transaction call data and sender of msg,\n        // which uniquely identifies the function, arguments, and sender.\n        bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));\n\n        if (!mutualConsents[expectedHash]) {\n            bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));\n\n            mutualConsents[newHash] = true;\n\n            emit MutualConsentRegistered(newHash);\n\n            return false;\n        }\n\n        delete mutualConsents[expectedHash];\n\n        return true;\n}\n"
                ],
                "Type": " addCredit / increaseCredit cannot be called by lender first when token is ETH",
                "Description": "*Submitted by Lambda(https://github.com/code-423n4/2022-11-debtdao-findings/issues/125), also found by berndartmueller(https://github.com/code-423n4/2022-11-debtdao-findings/issues/471), Trust(https://github.com/code-423n4/2022-11-debtdao-findings/issues/430), minhquanym(https://github.com/code-423n4/2022-11-debtdao-findings/issues/351), adriro(https://github.com/code-423n4/2022-11-debtdao-findings/issues/325), and HE1M(https://github.com/code-423n4/2022-11-debtdao-findings/issues/42)*\n\n<https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L234\n\n<https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L270\n\n\nThe functions addCredit and increaseCredit both ahve a mutualConsent or mutualConsentById modifier. Furthermore, these functions are payable and the lender needs to send the corresponding ETH with each call. However, if we look at the mutual consent modifier works, we can have a problem:\n\nsolidity\nmodifier mutualConsent(address _signerOne, address _signerTwo) {\n      if(_mutualConsent(_signerOne, _signerTwo))  {\n        // Run whatever code needed 2/2 consent\n        _;\n      }\n}\n\nfunction _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {\n        if(msg.sender != _signerOne && msg.sender != _signerTwo) { revert Unauthorized(); }\n\n        address nonCaller = _getNonCaller(_signerOne, _signerTwo);\n\n        // The consent hash is defined by the hash of the transaction call data and sender of msg,\n        // which uniquely identifies the function, arguments, and sender.\n        bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));\n\n        if (!mutualConsents[expectedHash]) {\n            bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));\n\n            mutualConsents[newHash] = true;\n\n            emit MutualConsentRegistered(newHash);\n\n            return false;\n        }\n\n        delete mutualConsents[expectedHash];\n\n        return true;\n}\n\n\nThe problem is: On the first call, when the other party has not given consent to the call yet, the modifier does not revert. It sets the consent of the calling party instead.\n\nThis is very problematic in combination with sending ETH for two reasons:\n1. When the lender performs the calls first and sends ETH along with the call, the call will not revert. It will instead set the consent for him, but the sent ETH is lost.\n2. Even when the lender thinks about this and does not provide any ETH on the first call, the borrower has to perform the second call. Of course, he will not provide the ETH with this call, but this will cause the transaction to revert. There is now no way for the borrower to also grant consent, but still let the lender perform the call.\n\n\nLender Alice calls LineOfCredit.addCredit first to add a credit with 1 ETH. She sends 1 ETH with the call. However, because borrower Bob has not performed this call yet, the function body is not executed, but the 1 ETH is still sent. Afterwards, Bob wants to give his consent, so he performs the same call. However, this call reverts, because Bob does not send any ETH with it.\n\n",
                "Repair": "\nConsider implementing an external function to grant consent to avoid this scenario. Also consider reverting when ETH is sent along, but the other party has not given their consent yet.\n\ndmvt (judge) increased severity to High(https://github.com/code-423n4/2022-11-debtdao-findings/issues/125)\n\nkibagateaux (Debt DAO) confirmed(https://github.com/code-423n4/2022-11-debtdao-findings/issues/125)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction close(bytes32 id) external payable override returns (bool) {\n    Credit memory credit = credits[id];\n    address b = borrower; // gas savings\n    if(msg.sender != credit.lender && msg.sender != b) {\n      revert CallerAccessDenied();\n    }\n\n    // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n    credit = _accrue(credit, id);\n    uint256 facilityFee = credit.interestAccrued;\n    if(facilityFee  0) {\n      // only allow repaying interest since they are skipping repayment queue.\n      // If principal still owed, _close() MUST fail\n      LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n      credit = _repay(credit, id, facilityFee);\n    }\n\n    _close(credit, id); // deleted; no need to save to storage\n\n    return true;\n}\n",
                    "//solidity\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    if(credit.principal  0) { revert CloseFailedWithPrincipal(); }\n\n    // return the Lender's funds that are being repaid\n    if (credit.deposit + credit.interestRepaid  0) {\n        LineLib.sendOutTokenOrETH(\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n\n    delete credits[id]; // gas refunds\n\n    // remove from active list\n    ids.removePosition(id);\n    unchecked { --count; }\n\n    // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n    if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n    emit CloseCreditPosition(id);\n\n    return true;\n}\n",
                    "//solidity\n// contracts/tests/LineOfCredit.t.sol\nfunction testCloseWithoutRepaying_AUDIT() public {\n    assertEq(supportedToken1.balanceOf(address(line)), 0, \"Line balance should be 0\");\n    assertEq(supportedToken1.balanceOf(lender), mintAmount, \"Lender should have initial mint balance\");\n      \n    _addCredit(address(supportedToken1), 1 ether);\n\n    bytes32 id = line.ids(0);\n    assert(id != bytes32(0));\n\n    assertEq(supportedToken1.balanceOf(lender), mintAmount 1 ether, \"Lender should have initial balance less lent amount\");\n    \n    hoax(borrower);\n    line.borrow(id, 1 ether);\n    assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether, \"Borrower should have initial balance + loan\");\n    \n    // The credit hasn't been repaid.\n    // hoax(borrower);\n    // line.depositAndRepay(1 ether);\n    \n    hoax(borrower);\n    // Closing with a non-existent credit ID.\n    line.close(bytes32(uint256(31337)));\n\n    // The debt hasn't been repaid but the status is REPAID.\n    assertEq(uint(line.status()), uint(LineLib.STATUS.REPAID));\n\n    // Lender's balance is still reduced by the borrow amount.\n    assertEq(supportedToken1.balanceOf(lender), mintAmount 1 ether);\n\n    // Borrower's balance still includes the borrowed amount.\n    assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether);\n}\n"
                ],
                "Type": " Borrower can close a credit without repaying debt",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-11-debtdao-findings/issues/258), also found by joestakey(https://github.com/code-423n4/2022-11-debtdao-findings/issues/527), berndartmueller(https://github.com/code-423n4/2022-11-debtdao-findings/issues/472), smiling_heretic(https://github.com/code-423n4/2022-11-debtdao-findings/issues/394), adriro(https://github.com/code-423n4/2022-11-debtdao-findings/issues/334), hansfriese(https://github.com/code-423n4/2022-11-debtdao-findings/issues/298), and bin2chen(https://github.com/code-423n4/2022-11-debtdao-findings/issues/272)*\n\nA borrower can close a credit without repaying the debt to the lender. The lender will be left with a bad debt and the borrower will keep the borrowed amount and the collateral.\n\n\nThe close function of LineOfCredit doesn't check whether a credit exists or not. As a result, the count variable is decreased in the internal _close function when the close function is called with an non-existent credit ID:\nLineOfCredit.sol#L388(https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388):\n\nsolidity\nfunction close(bytes32 id) external payable override returns (bool) {\n    Credit memory credit = credits[id];\n    address b = borrower; // gas savings\n    if(msg.sender != credit.lender && msg.sender != b) {\n      revert CallerAccessDenied();\n    }\n\n    // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n    credit = _accrue(credit, id);\n    uint256 facilityFee = credit.interestAccrued;\n    if(facilityFee  0) {\n      // only allow repaying interest since they are skipping repayment queue.\n      // If principal still owed, _close() MUST fail\n      LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n      credit = _repay(credit, id, facilityFee);\n    }\n\n    _close(credit, id); // deleted; no need to save to storage\n\n    return true;\n}\n\n\nLineOfCredit.sol#L483(https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483):\n\nsolidity\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    if(credit.principal  0) { revert CloseFailedWithPrincipal(); }\n\n    // return the Lender's funds that are being repaid\n    if (credit.deposit + credit.interestRepaid  0) {\n        LineLib.sendOutTokenOrETH(\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n\n    delete credits[id]; // gas refunds\n\n    // remove from active list\n    ids.removePosition(id);\n    unchecked { --count; }\n\n    // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n    if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n    emit CloseCreditPosition(id);\n\n    return true;\n}\n\n\nProof of Concept:\n\nsolidity\n// contracts/tests/LineOfCredit.t.sol\nfunction testCloseWithoutRepaying_AUDIT() public {\n    assertEq(supportedToken1.balanceOf(address(line)), 0, \"Line balance should be 0\");\n    assertEq(supportedToken1.balanceOf(lender), mintAmount, \"Lender should have initial mint balance\");\n      \n    _addCredit(address(supportedToken1), 1 ether);\n\n    bytes32 id = line.ids(0);\n    assert(id != bytes32(0));\n\n    assertEq(supportedToken1.balanceOf(lender), mintAmount 1 ether, \"Lender should have initial balance less lent amount\");\n    \n    hoax(borrower);\n    line.borrow(id, 1 ether);\n    assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether, \"Borrower should have initial balance + loan\");\n    \n    // The credit hasn't been repaid.\n    // hoax(borrower);\n    // line.depositAndRepay(1 ether);\n    \n    hoax(borrower);\n    // Closing with a non-existent credit ID.\n    line.close(bytes32(uint256(31337)));\n\n    // The debt hasn't been repaid but the status is REPAID.\n    assertEq(uint(line.status()), uint(LineLib.STATUS.REPAID));\n\n    // Lender's balance is still reduced by the borrow amount.\n    assertEq(supportedToken1.balanceOf(lender), mintAmount 1 ether);\n\n    // Borrower's balance still includes the borrowed amount.\n    assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether);\n}\n\n\n",
                "Repair": "\nIn the close function of LineOfCredit, consider ensuring that a credit with the user-supplied ID exists, before closing it.\n\nkibagateaux (Debt DAO) confirmed(https://github.com/code-423n4/2022-11-debtdao-findings/issues/258)\n\n\n*\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [],
                "Type": " Borrower can craft a borrow that cannot be liquidated, even by arbiter. ",
                "Description": "*Submitted by Trust(https://github.com/code-423n4/2022-11-debtdao-findings/issues/421), also found by bin2chen(https://github.com/code-423n4/2022-11-debtdao-findings/issues/281)*\n\nLineOfCredit manages an array of open credit line identifiers called ids. Many interactions with the Line operate on ids[0], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids[0] before other credit lines. \n\nThe list is managed by several functions:\n\n1.  CreditListLib.removePosition deletes parameter id in the ids array\n2.  CreditListLib.stepQ rotates all ids members one to the left, with the leftmost becoming the last element\n3.  _sortIntoQ most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:\n    1.  target index is not empty\n    2.  there is no principal owed for the target index's credit\n\nThe idea I had is that if we could corrupt the ids array so that ids[0] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing. \n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\nIt turns out there is a simple sequence of calls which allows borrowing while ids[0] is deleted, and does not re-arrange the new borrow into ids[0]!\n\n1.  id1 = addCredit() add a new credit line, a new id is pushed to the end of ids array.\n2.  id2 = addCredit() called again, ids.length = 2\n3.  close(id1) calls removePosition() on id1, now ids array is [0x000000000000000000000000, id2 ]\n4.  borrow(id2) will borrow from id2 and call _sortIntoQ. The sorting loop will not find another index other than id2's existing index (id == bytes32(0) is true).\n\nFrom this sequence, we achieve a borrow while ids[0] is 0! Therefore, credits[ids[0]].principal = credits[0].principal = 0, and whileBorrowing() reverts.\n\nThe impact is massive the following functions are disabled:\n\n*   SecureLine::liquidate()\n*   LineOfCredit::depositAndClose()\n*   LineOfCredit::depositAndRepay()\n*   LineOfCredit::claimAndRepay()\n*   LineOfCredit::claimAndTrade()\n\n\nBorrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.\n\n\nCopy the following code into LineOfCredit.t.sol\n\n    function _addCreditLender2(address token, uint256 amount) public {\n        // Prepare lender 2 operations, does same as mintAndApprove()\n        address lender2 = address(21);\n        deal(lender2, mintAmount);\n        supportedToken1.mint(lender2, mintAmount);\n        supportedToken2.mint(lender2, mintAmount);\n        unsupportedToken.mint(lender2, mintAmount);\n        vm.startPrank(lender2);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n        // addCredit logic\n        vm.prank(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender2);\n        vm.stopPrank();\n        vm.prank(lender2);\n        line.addCredit(dRate, fRate, amount, token, lender2);\n        vm.stopPrank();\n    }\n    function test_attackUnliquidatable() public {\n        bytes32 id_1;\n        bytes32 id_2;\n        _addCredit(address(supportedToken1), 1 ether);\n        _addCreditLender2(address(supportedToken1), 1 ether);\n        id_1 =  line.ids(0);\n        id_2 =  line.ids(1);\n        hoax(borrower);\n        line.close(id_1);\n        hoax(borrower);\n        line.borrow(id_2, 1 ether);\n        id_1 =  line.ids(0);\n        id_2 = line.ids(1);\n        console.log(\"id1 : \", uint256(id_1));\n        console.log(\"id2 : \", uint256(id_2));\n        vm.warp(ttl+1);\n        assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);\n        vm.expectRevert(ILineOfCredit.NotBorrowing.selector);\n        bool isSolvent = line.declareInsolvent();\n    }\n\n",
                "Repair": "\nWhen sorting new borrows into the ids queue, do not skip any elements.\n\ndmvt (judge) marked as nullified(https://github.com/code-423n4/2022-11-debtdao-findings/issues/421)\n\nTrust (warden) commented(https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1341256600):\n  Unclear why this issue is nullified, I have demonstrated a POC that shows line cannot be declared insolvent.\n\ndmvt (judge) re-opened the issue and commented(https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1343253554):\n  Kicking back to the sponsor for another look. I'm inclined to bring this one back as valid unless the sponsor can show why it isn't.\n\nkibagateaux (Debt DAO) confirmed(https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1405074802)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\nfunction repay(\n  ILineOfCredit.Credit memory credit,\n  bytes32 id,\n  uint256 amount\n)\n  external\n  returns (ILineOfCredit.Credit memory)\n{ unchecked {\n    if (amount <= credit.interestAccrued) {\n        credit.interestAccrued -= amount;\n        credit.interestRepaid += amount;\n        emit RepayInterest(id, amount);\n        return credit;\n    } else {\n        uint256 interest = credit.interestAccrued;\n        uint256 principalPayment = amount interest;\n\n        // update individual credit line denominated in token\n        credit.principal -= principalPayment; // @audit-info potential underflow without an error due to the unchecked block\n        credit.interestRepaid += interest;\n        credit.interestAccrued = 0;\n\n        emit RepayInterest(id, interest);\n        emit RepayPrincipal(id, principalPayment);\n\n        return credit;\n    }\n} }\n",
                    "//solidity\nfunction test_lender_use_and_repay_underflow() public {\n    uint256 largeRevenueAmount = lentAmount * 2;\n\n    deal(address(lender), lentAmount + 1 ether);\n    deal(address(revenueToken), MAX_REVENUE);\n    address revenueC = address(0xbeef); // need new spigot for testing\n    bytes32 id = _createCredit(address(revenueToken), Denominations.ETH, revenueC);\n\n    // 1. Borrow lentAmount = 1 ether\n    _borrow(id, lentAmount);\n\n    // 2. Claim and trade largeRevenueAmount = 2 ether (revenue)\n    bytes memory tradeData = abi.encodeWithSignature(\n      'trade(address,address,uint256,uint256)',\n      address(revenueToken),\n      Denominations.ETH,\n      1 gwei,\n      largeRevenueAmount\n    );\n\n    hoax(borrower);\n    line.claimAndTrade(address(revenueToken), tradeData);\n\n    (, uint256 principalBeforeRepaying,,,,,) = line.credits(line.ids(0));\n    assertEq(principalBeforeRepaying, lentAmount);\n\n    // 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)\n    vm.prank(lender);\n    line.useAndRepay(largeRevenueAmount);\n    (, uint256 _principal,,,,,) = line.credits(line.ids(0));\n\n    uint256 underflowedPrincipal = principalBeforeRepaying;\n\n    unchecked {\n      underflowedPrincipal -= (largeRevenueAmount);\n    }\n\n    // 4. Principal underflowed\n    assertEq(_principal, underflowedPrincipal);\n  }\n"
                ],
                "Type": " Repaying a line of credit with a higher than necessary claimed revenue amount will force the borrower into liquidation",
                "Description": "*Submitted by berndartmueller(https://github.com/code-423n4/2022-11-debtdao-findings/issues/461), also found by Trust(https://github.com/code-423n4/2022-11-debtdao-findings/issues/418), hansfriese(https://github.com/code-423n4/2022-11-debtdao-findings/issues/414), adriro(https://github.com/code-423n4/2022-11-debtdao-findings/issues/336), 0xdeadbeef0x(https://github.com/code-423n4/2022-11-debtdao-findings/issues/210), aphak5010(https://github.com/code-423n4/2022-11-debtdao-findings/issues/93), and rvierdiiev(https://github.com/code-423n4/2022-11-debtdao-findings/issues/82)*\n\nA borrower can repay (parts) of a credit line with the SpigotedLine.useAndRepay function. This function will use amount of unusedTokens[credit.token] as a repayment. However, if amount exceeds the principal and the accrued interest, credit.principal will underflow without an error and set the principal value to a very large number.\n\nThis a problem because a borrower can unknowingly provide a larger than necessary amount to the SpigotedLine.useAndRepay function to make sure enough funds are used to fully repay the principal and the remaining interest.\n\nAdditionally, a lender can do the same thing as the lender can call this function.\n\n\nThe credit.principal underflows without an error and will be set to a very large number. This will force a secured line immediately into liquidation. Additionally, having a principal value close to 2^256 1 will make it hugely expensive to repay the credit line.\n\n\nutils/CreditLib.sol#L186(https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186)\n\nsolidity\nfunction repay(\n  ILineOfCredit.Credit memory credit,\n  bytes32 id,\n  uint256 amount\n)\n  external\n  returns (ILineOfCredit.Credit memory)\n{ unchecked {\n    if (amount <= credit.interestAccrued) {\n        credit.interestAccrued -= amount;\n        credit.interestRepaid += amount;\n        emit RepayInterest(id, amount);\n        return credit;\n    } else {\n        uint256 interest = credit.interestAccrued;\n        uint256 principalPayment = amount interest;\n\n        // update individual credit line denominated in token\n        credit.principal -= principalPayment; // @audit-info potential underflow without an error due to the unchecked block\n        credit.interestRepaid += interest;\n        credit.interestAccrued = 0;\n\n        emit RepayInterest(id, interest);\n        emit RepayPrincipal(id, principalPayment);\n\n        return credit;\n    }\n} }\n\n\nTo demonstrate the issue, copy the following test case and paste it into the SpigotedLine.t.sol test file. Then run forge test --match-test \"test_lender_use_and_repay_underflow\".\n\nFollowing scenario causes the repayment to underflow:\n\n1.  Borrower borrows 1 ether of revenueToken\n2.  2 ether worth of revenueToken is claimed and traded from the revenue contract\n3.  Use all of the previously claimed funds (2 ether) to repay the line of credit (= 1 ether)\n4.  credit.principal underflows due to principalPayment is larger than credit.principal\n\nsolidity\nfunction test_lender_use_and_repay_underflow() public {\n    uint256 largeRevenueAmount = lentAmount * 2;\n\n    deal(address(lender), lentAmount + 1 ether);\n    deal(address(revenueToken), MAX_REVENUE);\n    address revenueC = address(0xbeef); // need new spigot for testing\n    bytes32 id = _createCredit(address(revenueToken), Denominations.ETH, revenueC);\n\n    // 1. Borrow lentAmount = 1 ether\n    _borrow(id, lentAmount);\n\n    // 2. Claim and trade largeRevenueAmount = 2 ether (revenue)\n    bytes memory tradeData = abi.encodeWithSignature(\n      'trade(address,address,uint256,uint256)',\n      address(revenueToken),\n      Denominations.ETH,\n      1 gwei,\n      largeRevenueAmount\n    );\n\n    hoax(borrower);\n    line.claimAndTrade(address(revenueToken), tradeData);\n\n    (, uint256 principalBeforeRepaying,,,,,) = line.credits(line.ids(0));\n    assertEq(principalBeforeRepaying, lentAmount);\n\n    // 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)\n    vm.prank(lender);\n    line.useAndRepay(largeRevenueAmount);\n    (, uint256 _principal,,,,,) = line.credits(line.ids(0));\n\n    uint256 underflowedPrincipal = principalBeforeRepaying;\n\n    unchecked {\n      underflowedPrincipal -= (largeRevenueAmount);\n    }\n\n    // 4. Principal underflowed\n    assertEq(_principal, underflowedPrincipal);\n  }\n\n\n",
                "Repair": "\nConsider asserting amount is less or equal than credit.principal + credit.interestAccrued (require(amount <= credit.principal + credit.interestAccrued);). Similar as how it is done in LineOfCredit.depositAndRepay()(https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326)\n\nkibagateaux (Debt DAO) confirmed(https://github.com/code-423n4/2022-11-debtdao-findings/issues/461)\n\n\n*\n\n \n\n"
            }
        ]
    }
]