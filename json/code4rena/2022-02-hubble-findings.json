[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "\ncontracts/AMM.sol:\n  99:     ) external initializer {\n\ncontracts/ClearingHouse.sol:\n  44:     ) external initializer {\n\ncontracts/MarginAccount.sol:\n  124:     ) external initializer {\n\ncontracts/Oracle.sol:\n  20:     function initialize(address _governance) external initializer {\n\n"
                ],
                "Type": " Update initializer modifier to prevent reentrancy during initialization",
                "Description": "\n<https://github.com/code-423n4/2022-02-hubble/blob/main/package.json#L17<br\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L5<br\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L24\n\nWhile Governable.sol is out of scope, I figured this issue would still be fair game.\n\nThe solution uses: \"@openzeppelin/contracts\": \"4.2.0\".<br\nThis dependency has a known high severity vulnerability: <https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTS-2320176<br\nWhich makes this contract vulnerable:\n\n    File: Governable.sol\n    05: import { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n    ...\n    24: contract Governable is VanillaGovernable, Initializable {}\n\nThis contract is inherited at multiple places:\n\n    contracts/AMM.sol:\n      11: contract AMM is IAMM, Governable {\n\n    contracts/InsuranceFund.sol:\n      13: contract InsuranceFund is VanillaGovernable, ERC20Upgradeable {\n\n    contracts/Oracle.sol:\n      11: contract Oracle is Governable {\n\n    contracts/legos/HubbleBase.sol:\n      15: contract HubbleBase is Governable, Pausable, ERC2771Context {\n\n    contracts/ClearingHouse.sol:\n      11: contract ClearingHouse is IClearingHouse, HubbleBase {\n\n    contracts/MarginAccount.sol:\n      25: contract MarginAccount is IMarginAccount, HubbleBase {\n\n\u00ecnitializer() is used here:\n\n\ncontracts/AMM.sol:\n  99:     ) external initializer {\n\ncontracts/ClearingHouse.sol:\n  44:     ) external initializer {\n\ncontracts/MarginAccount.sol:\n  124:     ) external initializer {\n\ncontracts/Oracle.sol:\n  20:     function initialize(address _governance) external initializer {\n\n\n\n",
                "Repair": "\nUpgrade @openzeppelin/contracts to version 4.4.1 or higher.\n\natvanguard (Hubble) confirmed and resolved(https://github.com/code-423n4/2022-02-hubble-findings/issues/81)\n\nmoose-code (judge) commented(https://github.com/code-423n4/2022-02-hubble-findings/issues/81#issuecomment-1059916859):\n  Agreed. Other issues such as this(https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301) have also popped up, so always safest to be on the newest OZ. This includes for contracts and contracts-upgradeable packages.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IClearingHouse, IMarginAccount, IAMM, IVAMM, IHubbleViewer } from \"./Interfaces.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract HubbleViewer is IHubbleViewer {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    int256 constant PRECISION_INT = 1e6;\n    uint256 constant PRECISION_UINT = 1e6;\n\n    uint constant VUSD_IDX = 0;\n\n    IClearingHouse public immutable clearingHouse;\n    IMarginAccount public immutable marginAccount;\n    address public immutable registry;\n\n    struct Position {\n        int256 size;\n        uint256 openNotional;\n        int256 unrealizedPnl;\n        uint256 avgOpen;\n    }\n\n    /// @dev UI Helper\n    struct MarketInfo {\n        address amm;\n        address underlying;\n    }\n\n    constructor(\n        IClearingHouse _clearingHouse,\n        IMarginAccount _marginAccount,\n        address _registry\n    ) {\n        clearingHouse = _clearingHouse;\n        marginAccount = _marginAccount;\n        registry = _registry;\n    }\n\n    function getMarginFractionAndMakerStatus(address[] calldata traders)\n        external\n        view\n        returns(int256[] memory fractions, bool[] memory isMaker)\n    {\n        uint len = traders.length;\n        fractions = new int256[](len);\n        isMaker = new bool[](len);\n        for (uint i = 0; i < len; i++) {\n            fractions[i] = clearingHouse.getMarginFraction(traders[i]);\n            isMaker[i] = clearingHouse.isMaker(traders[i]);\n        }\n    }\n\n    function getNotionalPositionAndMargin(address[] calldata traders)\n        external\n        view\n        returns(uint256[] memory notionalPositions, int256[] memory margins)\n    {\n        notionalPositions = new uint256[](traders.length);\n        margins = new int256[](traders.length);\n        for (uint i = 0; i < traders.length; i++) {\n            (notionalPositions[i], margins[i]) = clearingHouse.getNotionalPositionAndMargin(traders[i], true /* includeFundingPayments */);\n        }\n    }\n\n    function marginAccountLiquidatationStatus(address[] calldata traders)\n        external\n        view\n        returns(IMarginAccount.LiquidationStatus[] memory isLiquidatable, uint[] memory repayAmount, uint[] memory incentivePerDollar)\n    {\n        isLiquidatable = new IMarginAccount.LiquidationStatus[](traders.length);\n        repayAmount = new uint[](traders.length);\n        incentivePerDollar = new uint[](traders.length);\n        for (uint i = 0; i < traders.length; i++) {\n            (isLiquidatable[i], repayAmount[i], incentivePerDollar[i]) = marginAccount.isLiquidatable(traders[i], true);\n        }\n    }\n\n    /**\n    * @notice Get information about all user positions\n    * @param trader Trader for which information is to be obtained\n    * @return positions in order of amms\n    *   positions[i].size - BaseAssetQuantity amount longed (+ve) or shorted (-ve)\n    *   positions[i].openNotional - $ value of position\n    *   positions[i].unrealizedPnl - in dollars. +ve is profit, -ve if loss\n    *   positions[i].avgOpen - Average $ value at which position was started\n    */\n    function userPositions(address trader) external view returns(Position[] memory positions) {\n        uint l = clearingHouse.getAmmsLength();\n        positions = new Position[](l);\n        for (uint i = 0; i < l; i++) {\n            IAMM amm = clearingHouse.amms(i);\n            (positions[i].size, positions[i].openNotional, ) = amm.positions(trader);\n            if (positions[i].size == 0) {\n                positions[i].unrealizedPnl = 0;\n                positions[i].avgOpen = 0;\n            } else {\n                (,positions[i].unrealizedPnl) = amm.getTakerNotionalPositionAndUnrealizedPnl(trader);\n                positions[i].avgOpen = positions[i].openNotional * 1e18 / _abs(positions[i].size).toUint256();\n            }\n        }\n    }\n\n    /**\n    * @notice Get information about maker's all impermanent positions\n    * @param maker Maker for which information is to be obtained\n    * @return positions in order of amms\n    *   positions[i].size - BaseAssetQuantity amount longed (+ve) or shorted (-ve)\n    *   positions[i].openNotional - $ value of position\n    *   positions[i].unrealizedPnl - in dollars. +ve is profit, -ve if loss\n    *   positions[i].avgOpen - Average $ value at which position was started\n    */\n    function makerPositions(address maker) external view returns(Position[] memory positions) {\n        uint l = clearingHouse.getAmmsLength();\n        positions = new Position[](l);\n        for (uint i = 0; i < l; i++) {\n            (\n                positions[i].size,\n                positions[i].openNotional,\n                positions[i].unrealizedPnl\n            ) = getMakerPositionAndUnrealizedPnl(maker, i);\n            if (positions[i].size == 0) {\n                positions[i].avgOpen = 0;\n            } else {\n                positions[i].avgOpen = positions[i].openNotional * 1e18 / _abs(positions[i].size).toUint256();\n            }\n        }\n    }\n\n    function markets() external view returns(MarketInfo[] memory _markets) {\n        uint l = clearingHouse.getAmmsLength();\n        _markets = new MarketInfo[](l);\n        for (uint i = 0; i < l; i++) {\n            IAMM amm = clearingHouse.amms(i);\n            _markets[i] = MarketInfo(address(amm), amm.underlyingAsset());\n        }\n    }\n\n    /**\n    * Get final margin fraction and liquidation price if user longs/shorts baseAssetQuantity\n    * @param idx AMM Index\n    * @param baseAssetQuantity Positive if long, negative if short, scaled 18 decimals\n    * @return expectedMarginFraction Resultant Margin fraction when the trade is executed\n    * @return quoteAssetQuantity USD rate for the trade\n    * @return liquidationPrice Mark Price at which trader will be liquidated\n    */\n    function getTakerExpectedMFAndLiquidationPrice(address trader, uint idx, int256 baseAssetQuantity)\n        external\n        view\n        returns (int256 expectedMarginFraction, uint256 quoteAssetQuantity, uint256 liquidationPrice)\n    {\n        IAMM amm = clearingHouse.amms(idx);\n        // get quoteAsset required to swap baseAssetQuantity\n        quoteAssetQuantity = getQuote(baseAssetQuantity, idx);\n\n        // get total notionalPosition and margin (including unrealizedPnL and funding)\n        (uint256 notionalPosition, int256 margin) = clearingHouse.getNotionalPositionAndMargin(trader, true /* includeFundingPayments */);\n\n        // get market specific position info\n        (int256 takerPosSize,,) = amm.positions(trader);\n        uint takerNowNotional = amm.getCloseQuote(takerPosSize);\n        uint takerUpdatedNotional = amm.getCloseQuote(takerPosSize + baseAssetQuantity);\n        // Calculate new total notionalPosition\n        notionalPosition = notionalPosition + takerUpdatedNotional - takerNowNotional;\n\n        margin -= _calculateTradeFee(quoteAssetQuantity).toInt256();\n        expectedMarginFraction = _getMarginFraction(margin, notionalPosition);\n        liquidationPrice = _getLiquidationPrice(trader, amm, notionalPosition, margin, baseAssetQuantity, quoteAssetQuantity);\n    }\n\n    /**\n    * Get final margin fraction and liquidation price if user add/remove liquidity\n    * @param idx AMM Index\n    * @param vUSD vUSD amount to be added in the pool (in 6 decimals)\n    * @param isRemove true is liquidity is being removed, false if added\n    * @return expectedMarginFraction Resultant Margin fraction after the tx\n    * @return liquidationPrice Mark Price at which maker will be liquidated\n    */\n    function getMakerExpectedMFAndLiquidationPrice(address trader, uint idx, uint vUSD, bool isRemove)\n        external\n        view\n        returns (int256 expectedMarginFraction, uint256 liquidationPrice)\n    {\n        // get total notionalPosition and margin (including unrealizedPnL and funding)\n        (uint256 notionalPosition, int256 margin) = clearingHouse.getNotionalPositionAndMargin(trader, true /* includeFundingPayments */);\n\n        IAMM amm = clearingHouse.amms(idx);\n\n        // get taker info\n        (int256 takerPosSize,,) = amm.positions(trader);\n        uint takerNotional = amm.getCloseQuote(takerPosSize);\n        // get maker info\n        (uint makerDebt,,,,,,) = amm.makers(trader);\n        // calculate total value of deposited liquidity after the tx\n        if (isRemove) {\n            makerDebt = 2 * (makerDebt - vUSD);\n        } else {\n            makerDebt = 2 * (makerDebt + vUSD);\n        }\n\n        {\n            // calculate effective notionalPosition\n            (int256 makerPosSize,,) = getMakerPositionAndUnrealizedPnl(trader, idx);\n            uint totalPosNotional = amm.getCloseQuote(makerPosSize + takerPosSize);\n            notionalPosition += _max(makerDebt + takerNotional, totalPosNotional);\n        }\n\n        {\n            (uint nowNotional,,,) = amm.getNotionalPositionAndUnrealizedPnl(trader);\n            notionalPosition -= nowNotional;\n        }\n\n        expectedMarginFraction = _getMarginFraction(margin, notionalPosition);\n        liquidationPrice = _getLiquidationPrice(trader, amm, notionalPosition, margin, 0, 0);\n    }\n\n    function getLiquidationPrice(address trader, uint idx) external view returns (uint liquidationPrice) {\n        // get total notionalPosition and margin (including unrealizedPnL and funding)\n        (uint256 notionalPosition, int256 margin) = clearingHouse.getNotionalPositionAndMargin(trader, true /* includeFundingPayments */);\n        IAMM amm = clearingHouse.amms(idx);\n        liquidationPrice = _getLiquidationPrice(trader, amm, notionalPosition, margin, 0, 0);\n    }\n\n    /**\n    * @notice get maker impermanent position and unrealizedPnl for a particular amm\n    * @param _maker maker address\n    * @param idx amm index\n    * @return position Maker's current impermanent position\n    * @return openNotional Position open notional for the current impermanent position inclusive of fee earned\n    * @return unrealizedPnl PnL if maker removes liquidity and closes their impermanent position in the same amm\n    */\n    function getMakerPositionAndUnrealizedPnl(address _maker, uint idx)\n        override\n        public\n        view\n        returns (int256 position, uint openNotional, int256 unrealizedPnl)\n    {\n        IAMM amm = clearingHouse.amms(idx);\n        IVAMM vamm = amm.vamm();\n\n        (uint vUSD, uint vAsset, uint dToken,,,,) = amm.makers(_maker);\n        (position, openNotional, unrealizedPnl) = vamm.get_maker_position(dToken, vUSD, vAsset, dToken);\n    }\n\n    /**\n    * @notice calculate amount of quote asset required for trade\n    * @param baseAssetQuantity base asset to long/short\n    * @param idx amm index\n    */\n    function getQuote(int256 baseAssetQuantity, uint idx) public view returns(uint256 quoteAssetQuantity) {\n        IAMM amm = clearingHouse.amms(idx);\n        IVAMM vamm = amm.vamm();\n\n        if (baseAssetQuantity >= 0) {\n            return vamm.get_dx(0, 1, baseAssetQuantity.toUint256()) + 1;\n        }\n        // rounding-down while shorting is not a problem\n        // because lower the min_dy, more permissible it is\n        return vamm.get_dy(1, 0, (-baseAssetQuantity).toUint256());\n    }\n\n    /**\n    * @notice calculate amount of base asset required for trade\n    * @param quoteAssetQuantity amount of quote asset to long/short\n    * @param idx amm index\n    * @param isLong long - true, short - false\n    */\n    function getBase(uint256 quoteAssetQuantity, uint idx, bool isLong) external view returns(int256 /* baseAssetQuantity */) {\n        IAMM amm = clearingHouse.amms(idx);\n        IVAMM vamm = amm.vamm();\n\n        uint256 baseAssetQuantity;\n        if (isLong) {\n            baseAssetQuantity = vamm.get_dy(0, 1, quoteAssetQuantity);\n            return baseAssetQuantity.toInt256();\n        }\n        baseAssetQuantity = vamm.get_dx(1, 0, quoteAssetQuantity);\n        return -(baseAssetQuantity.toInt256());\n    }\n\n    /**\n    * @notice Get total liquidity deposited by maker and its current value\n    * @param _maker maker for which information to be obtained\n    * @return\n    *   vAsset - current base asset amount of maker in the pool\n    *   vUSD - current quote asset amount of maker in the pool\n    *   totalDeposited - total value of initial liquidity deposited in the pool by maker\n    *   dToken - maker dToken balance\n    *   vAssetBalance - base token liquidity in the pool\n    *   vUSDBalance - quote token liquidity in the pool\n    */\n    function getMakerLiquidity(address _maker, uint idx) external view returns (uint vAsset, uint vUSD, uint totalDeposited, uint dToken, uint vAssetBalance, uint vUSDBalance) {\n        IAMM amm = clearingHouse.amms(idx);\n        IVAMM vamm = amm.vamm();\n        (vUSD,, dToken,,,,) = amm.makers(_maker);\n\n        totalDeposited = 2 * vUSD;\n        uint totalDTokenSupply = vamm.totalSupply();\n        vUSDBalance = vamm.balances(0);\n        vAssetBalance = vamm.balances(1);\n\n        if (totalDTokenSupply > 0) {\n            vUSD = vUSDBalance * dToken / totalDTokenSupply;\n            vAsset = vAssetBalance * dToken / totalDTokenSupply;\n        }\n    }\n\n    /**\n    * @notice calculate base and quote asset amount form dToken\n     */\n    function calcWithdrawAmounts(uint dToken, uint idx) external view returns (uint quoteAsset, uint baseAsset) {\n        IAMM amm = clearingHouse.amms(idx);\n        IVAMM vamm = amm.vamm();\n\n        uint totalDTokenSupply = vamm.totalSupply();\n        if (totalDTokenSupply > 0) {\n            quoteAsset = vamm.balances(0) * dToken / totalDTokenSupply;\n            baseAsset = vamm.balances(1) * dToken / totalDTokenSupply;\n        }\n    }\n\n    /**\n    * @notice Get amount of token to add/remove given the amount of other token\n    * @param inputAmount quote/base asset amount to add or remove, base - 18 decimal, quote - 6 decimal\n    * @param isBase true if inputAmount is base asset\n    * @param deposit true -> addLiquidity, false -> removeLiquidity\n    * @return fillAmount base/quote asset amount to be added/removed\n    *         dToken - equivalent dToken amount\n    */\n    function getMakerQuote(uint idx, uint inputAmount, bool isBase, bool deposit) external view returns (uint fillAmount, uint dToken) {\n        IAMM amm = clearingHouse.amms(idx);\n        IVAMM vamm = amm.vamm();\n\n        if (isBase) {\n            // calculate quoteAsset amount, fillAmount = quoteAsset, inputAmount = baseAsset\n            uint baseAssetBal = vamm.balances(1);\n            if (baseAssetBal == 0) {\n                fillAmount = inputAmount * vamm.price_scale() / 1e30;\n            } else {\n                fillAmount = inputAmount * vamm.balances(0) / baseAssetBal;\n            }\n            dToken = vamm.calc_token_amount([fillAmount, inputAmount], deposit);\n        } else {\n            uint bal0 = vamm.balances(0);\n            // calculate quote asset amount, fillAmount = baseAsset, inputAmount = quoteAsset\n            if (bal0 == 0) {\n                fillAmount = inputAmount * 1e30 / vamm.price_scale();\n            } else {\n                fillAmount = inputAmount * vamm.balances(1) / bal0;\n            }\n            dToken = vamm.calc_token_amount([inputAmount, fillAmount], deposit);\n        }\n    }\n\n    /**\n    * @notice get user margin for all collaterals\n    */\n    function userInfo(address trader) external view returns(int256[] memory) {\n        uint length = marginAccount.supportedAssetsLen();\n        int256[] memory _margin = new int256[](length);\n        // -ve funding means user received funds\n        _margin[VUSD_IDX] = marginAccount.margin(VUSD_IDX, trader) - clearingHouse.getTotalFunding(trader);\n        for (uint i = 1; i < length; i++) {\n            _margin[i] = marginAccount.margin(i, trader);\n        }\n        return _margin;\n    }\n\n    /**\n    * @notice get user account information\n    */\n    function getAccountInfo(address trader) external view returns (\n        int totalCollateral,\n        int256 freeMargin,\n        int256 marginFraction,\n        uint notionalPosition,\n        int256 unrealizedPnl\n    ) {\n        int256 margin;\n        (margin, totalCollateral) = marginAccount.weightedAndSpotCollateral(trader);\n        marginFraction = clearingHouse.getMarginFraction(trader);\n        (notionalPosition, unrealizedPnl) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader);\n        int256 minAllowableMargin = clearingHouse.minAllowableMargin();\n        freeMargin = margin + unrealizedPnl - clearingHouse.getTotalFunding(trader) - notionalPosition.toInt256() * minAllowableMargin / PRECISION_INT;\n    }\n\n    // Internal\n\n    /**\n    * @dev At liquidation,\n    * (margin + pnl) / notionalPosition = maintenanceMargin (MM)\n    * => pnl = MM * notionalPosition - margin\n    *\n    * for long, pnl = liquidationPrice * size - openNotional\n    * => liquidationPrice = (pnl + openNotional) / size\n    *\n    * for short, pnl = openNotional - liquidationPrice * size\n    * => liquidationPrice = (openNotional - pnl) / size\n    */\n    function _getLiquidationPrice(\n            address trader,\n            IAMM amm,\n            uint256 notionalPosition,\n            int256 margin,\n            int256 baseAssetQuantity,\n            uint quoteAssetQuantity\n        )\n        internal\n        view\n        returns(uint256 liquidationPrice)\n    {\n        if (notionalPosition == 0) {\n            return 0;\n        }\n\n        (, int256 unrealizedPnl, int256 totalPosSize, uint256 openNotional) = amm.getNotionalPositionAndUnrealizedPnl(trader);\n\n        if (baseAssetQuantity != 0) {\n            // Calculate effective position and openNotional\n            if (baseAssetQuantity * totalPosSize >= 0) { // increasingPosition i.e. same direction trade\n                openNotional += quoteAssetQuantity;\n            } else { // open reverse position\n                uint totalPosNotional = amm.getCloseQuote(totalPosSize + baseAssetQuantity);\n                if (_abs(totalPosSize) >= _abs(baseAssetQuantity)) { // position side remains same after the trade\n                    (openNotional,) = amm.getOpenNotionalWhileReducingPosition(\n                        totalPosSize,\n                        totalPosNotional,\n                        unrealizedPnl,\n                        baseAssetQuantity\n                    );\n                } else { // position side changes after the trade\n                    openNotional = totalPosNotional;\n                }\n            }\n            totalPosSize += baseAssetQuantity;\n        }\n\n        int256 pnlForLiquidation = clearingHouse.maintenanceMargin() * notionalPosition.toInt256() / PRECISION_INT - margin;\n        int256 _liquidationPrice;\n        if (totalPosSize > 0) {\n            _liquidationPrice = (openNotional.toInt256() + pnlForLiquidation) * 1e18 / totalPosSize;\n        } else if (totalPosSize < 0) {\n            _liquidationPrice = (openNotional.toInt256() - pnlForLiquidation) * 1e18 / (-totalPosSize);\n        }\n\n        if (_liquidationPrice < 0) { // is this possible?\n            _liquidationPrice = 0;\n        }\n        return _liquidationPrice.toUint256();\n    }\n\n    function _calculateTradeFee(uint quoteAsset) internal view returns (uint) {\n        return quoteAsset * clearingHouse.tradeFee() / PRECISION_UINT;\n    }\n\n    // Pure\n\n    function _getMarginFraction(int256 accountValue, uint notionalPosition) private pure returns(int256) {\n        if (notionalPosition == 0) {\n            return type(int256).max;\n        }\n        return accountValue * PRECISION_INT / notionalPosition.toInt256();\n    }\n\n    function _abs(int x) private pure returns (int) {\n        return x >= 0 ? x : -x;\n    }\n\n    function _max(uint x, uint y) private pure returns (uint) {\n        return x >= y ? x : y;\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry } from \"./Interfaces.sol\";\n\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    uint public pendingObligation;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(msg.sender == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    function initialize(address _governance) external {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\"); // has initializer modifier\n        _setGovernace(_governance);\n    }\n\n    function deposit(uint _amount) external {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = balance();\n        uint _totalSupply = totalSupply();\n        if (_totalSupply == 0 && _pool > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance, _pool);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(msg.sender, address(this), _amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = _amount;\n        } else {\n            shares = _amount * _totalSupply / _pool;\n        }\n        _mint(msg.sender, shares);\n        emit FundsAdded(msg.sender, _amount, block.timestamp);\n    }\n\n    function withdraw(uint _shares) external {\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        uint amount = balance() * _shares / totalSupply();\n        _burn(msg.sender, _shares);\n        vusd.safeTransfer(msg.sender, amount);\n        emit FundsWithdrawn(msg.sender, amount, block.timestamp);\n    }\n\n    function seizeBadDebt(uint amount) external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(IRegistry _registry) public onlyGovernance {\n        vusd = IERC20(_registry.vusd());\n        marginAccount = _registry.marginAccount();\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { ERC20Detailed, IOracle, IRegistry, IVAMM, IAMM } from \"./Interfaces.sol\";\n\ncontract AMM is IAMM, Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    uint256 public constant spotPriceTwapInterval = 1 hours;\n    uint256 public constant fundingPeriod = 1 hours;\n    int256 constant BASE_PRECISION = 1e18;\n\n    // System-wide config\n\n    IOracle public oracle;\n    address public clearingHouse;\n\n    // AMM config\n\n    IVAMM override public vamm;\n    address override public underlyingAsset;\n    string public name;\n\n    uint256 public fundingBufferPeriod;\n    uint256 public nextFundingTime;\n    int256 public fundingRate;\n    int256 public cumulativePremiumFraction;\n    int256 public cumulativePremiumPerDtoken;\n    int256 public posAccumulator;\n\n    uint256 public longOpenInterestNotional;\n    uint256 public shortOpenInterestNotional;\n\n    enum Side { LONG, SHORT }\n    struct Position {\n        int256 size;\n        uint256 openNotional;\n        int256 lastPremiumFraction;\n    }\n    mapping(address => Position) override public positions;\n\n    struct Maker {\n        uint vUSD;\n        uint vAsset;\n        uint dToken;\n        int pos; // position\n        int posAccumulator; // value of global.posAccumulator until which pos has been updated\n        int lastPremiumFraction;\n        int lastPremiumPerDtoken;\n    }\n    mapping(address => Maker) override public makers;\n\n    struct ReserveSnapshot {\n        uint256 lastPrice;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n    ReserveSnapshot[] public reserveSnapshots;\n\n    /**\n    * @dev We do not deliberately have a Pause state. There is only a master-level pause at clearingHouse level\n    */\n    enum AMMState { Inactive, Ignition, Active }\n    AMMState public ammState;\n\n    uint256[50] private __gap;\n\n    // Events\n\n    event PositionChanged(address indexed trader, int256 size, uint256 openNotional, int256 realizedPnl);\n    event FundingRateUpdated(int256 premiumFraction, int256 rate, uint256 underlyingPrice, uint256 timestamp, uint256 blockNumber);\n    event FundingPaid(address indexed trader, int256 takerPosSize, int256 takerFundingPayment, int256 makerFundingPayment, int256 latestCumulativePremiumFraction, int256 latestPremiumPerDtoken);\n    event Swap(int256 baseAsset, uint256 quoteAsset, uint256 lastPrice, uint256 openInterestNotional);\n    event LiquidityAdded(address indexed maker, uint dToken, uint baseAsset, uint quoteAsset, uint timestamp);\n    event LiquidityRemoved(address indexed maker, uint dToken, uint baseAsset, uint quoteAsset, uint timestamp, int256 realizedPnl);\n\n    modifier onlyClearingHouse() {\n        require(msg.sender == clearingHouse, \"Only clearingHouse\");\n        _;\n    }\n\n    modifier onlyVamm() {\n        require(msg.sender == address(vamm), \"Only VAMM\");\n        _;\n    }\n\n    function initialize(\n        address _registry,\n        address _underlyingAsset,\n        string memory _name,\n        address _vamm,\n        address _governance\n    ) external initializer {\n        _setGovernace(_governance);\n\n        vamm = IVAMM(_vamm);\n        underlyingAsset = _underlyingAsset;\n        name = _name;\n        fundingBufferPeriod = 15 minutes;\n\n        syncDeps(_registry);\n    }\n\n    /**\n    * @dev baseAssetQuantity != 0 has been validated in clearingHouse._openPosition()\n    */\n    function openPosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased)\n    {\n        require(ammState == AMMState.Active, \"AMM.openPosition.not_active\");\n        Position memory position = positions[trader];\n        bool isNewPosition = position.size == 0 ? true : false;\n        Side side = baseAssetQuantity > 0 ? Side.LONG : Side.SHORT;\n        if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) {\n            // realizedPnl = 0;\n            quoteAsset = _increasePosition(trader, baseAssetQuantity, quoteAssetLimit);\n            isPositionIncreased = true;\n        } else {\n            (realizedPnl, quoteAsset, isPositionIncreased) = _openReversePosition(trader, baseAssetQuantity, quoteAssetLimit);\n        }\n        _emitPositionChanged(trader, realizedPnl);\n    }\n\n    function liquidatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset)\n    {\n        // don't need an ammState check because there should be no active positions\n        Position memory position = positions[trader];\n        bool isLongPosition = position.size > 0 ? true : false;\n        // sending market orders can fk the trader. @todo put some safe guards around price of liquidations\n        if (isLongPosition) {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0);\n        } else {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max);\n        }\n        _emitPositionChanged(trader, realizedPnl);\n    }\n\n    function updatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns(int256 fundingPayment)\n    {\n        if (ammState != AMMState.Active) return 0;\n        (\n            int256 takerFundingPayment,\n            int256 makerFundingPayment,\n            int256 latestCumulativePremiumFraction,\n            int256 latestPremiumPerDtoken\n        ) = getPendingFundingPayment(trader);\n\n        Position storage position = positions[trader];\n        position.lastPremiumFraction = latestCumulativePremiumFraction;\n\n        Maker storage maker = makers[trader];\n        maker.lastPremiumFraction = latestCumulativePremiumFraction;\n        maker.lastPremiumPerDtoken = latestPremiumPerDtoken;\n\n        emit FundingPaid(trader, position.size, takerFundingPayment, makerFundingPayment, latestCumulativePremiumFraction, latestPremiumPerDtoken);\n\n        // +: trader paid, -: trader received\n        fundingPayment = takerFundingPayment + makerFundingPayment;\n        if (fundingPayment < 0) {\n            fundingPayment -= fundingPayment / 1e3; // receivers charged 0.1% to account for rounding-offs\n        }\n    }\n\n    function addLiquidity(address maker, uint baseAssetQuantity, uint minDToken)\n        override\n        external\n        onlyClearingHouse\n    {\n        require(ammState != AMMState.Inactive, \"AMM.addLiquidity.amm_inactive\");\n        uint quoteAsset;\n        uint baseAssetBal = vamm.balances(1);\n        if (baseAssetBal == 0) {\n            quoteAsset = baseAssetQuantity * vamm.price_scale() / 1e30;\n        } else {\n            quoteAsset = baseAssetQuantity * vamm.balances(0) / baseAssetBal;\n        }\n\n        uint _dToken = vamm.add_liquidity([quoteAsset, baseAssetQuantity], minDToken);\n\n        // updates\n        Maker storage _maker = makers[maker];\n        if (_maker.dToken > 0) { // Maker only accumulates position when they had non-zero liquidity\n            _maker.pos += (posAccumulator - _maker.posAccumulator) * _maker.dToken.toInt256() / 1e18;\n        }\n        _maker.vUSD += quoteAsset;\n        _maker.vAsset += baseAssetQuantity;\n        _maker.dToken += _dToken;\n        _maker.posAccumulator = posAccumulator;\n        emit LiquidityAdded(maker, _dToken, baseAssetQuantity, quoteAsset, _blockTimestamp());\n    }\n\n    function removeLiquidity(address maker, uint amount, uint minQuote, uint minBase)\n        override\n        external\n        onlyClearingHouse\n        returns (int256 /* realizedPnl */, uint /* quoteAsset */)\n    {\n        Maker memory _maker = makers[maker];\n        if (_maker.dToken == 0) {\n            return (0,0);\n        }\n\n        Position memory _taker = positions[maker];\n        // amount <= _maker.dToken will be asserted when updating maker.dToken\n        (\n            int256 makerPosition,\n            uint256 totalOpenNotional,\n            int256 feeAdjustedPnl,\n            uint[2] memory dBalances\n        ) = vamm.remove_liquidity(\n            amount,\n            [minQuote /* minimum QuoteAsset amount */, minBase /* minimum BaseAsset amount */],\n            _maker.vUSD,\n            _maker.vAsset,\n            _maker.dToken,\n            _taker.size,\n            _taker.openNotional\n        );\n\n        {\n            // update maker info\n            Maker storage __maker = makers[maker];\n            uint diff = _maker.dToken - amount;\n\n            if (diff == 0) {\n                __maker.pos = 0;\n                __maker.vAsset = 0;\n                __maker.vUSD = 0;\n                __maker.dToken = 0;\n            } else {\n                // muitiply by diff because a taker position will also be opened while removing liquidity and its funding payment is calculated seperately\n                __maker.pos = _maker.pos + (posAccumulator - _maker.posAccumulator) * diff.toInt256() / 1e18;\n                __maker.vAsset = _maker.vAsset * diff / _maker.dToken;\n                __maker.vUSD = _maker.vUSD * diff / _maker.dToken;\n                __maker.dToken = diff;\n            }\n            __maker.posAccumulator = posAccumulator;\n        }\n\n        int256 realizedPnl = feeAdjustedPnl;\n        {\n            if (makerPosition != 0) {\n                // translate impermanent position to a permanent one\n                Position storage position = positions[maker];\n                if (makerPosition * position.size < 0) { // reducing or reversing position\n                    uint newNotional = getCloseQuote(position.size + makerPosition);\n                    int256 reducePositionPnl = _getPnlWhileReducingPosition(position.size, position.openNotional, makerPosition, newNotional);\n                    realizedPnl += reducePositionPnl;\n                }\n                position.openNotional = totalOpenNotional;\n                position.size += makerPosition;\n\n                // update long and short open interest notional\n                if (makerPosition > 0) {\n                    longOpenInterestNotional += makerPosition.toUint256();\n                } else {\n                    shortOpenInterestNotional += (-makerPosition).toUint256();\n                }\n            }\n        }\n\n        emit LiquidityRemoved(maker, amount, dBalances[1] /** baseAsset */,\n            dBalances[0] /** quoteAsset */, _blockTimestamp(), realizedPnl);\n        return (realizedPnl, dBalances[0]);\n    }\n\n\n    function getOpenNotionalWhileReducingPosition(\n        int256 positionSize,\n        uint256 newNotionalPosition,\n        int256 unrealizedPnl,\n        int256 baseAssetQuantity\n    )\n        override\n        public\n        pure\n        returns(uint256 remainOpenNotional, int realizedPnl)\n    {\n        require(abs(positionSize) >= abs(baseAssetQuantity), \"AMM.ONLY_REDUCE_POS\");\n        bool isLongPosition = positionSize > 0 ? true : false;\n\n        realizedPnl = unrealizedPnl * abs(baseAssetQuantity) / abs(positionSize);\n        int256 unrealizedPnlAfter = unrealizedPnl - realizedPnl;\n\n        /**\n        * We need to determine the openNotional value of the reduced position now.\n        * We know notionalPosition and unrealizedPnlAfter (unrealizedPnl times the ratio of open position)\n        * notionalPosition = notionalPosition - quoteAsset (exchangedQuoteAssetAmount)\n        * calculate openNotional (it's different depends on long or short side)\n        * long: unrealizedPnl = notionalPosition - openNotional => openNotional = notionalPosition - unrealizedPnl\n        * short: unrealizedPnl = openNotional - notionalPosition => openNotional = notionalPosition + unrealizedPnl\n        */\n        if (isLongPosition) {\n            /**\n            * Let baseAssetQuantity = Q, position.size = size, by definition of _reducePosition, abs(size) >= abs(Q)\n            * quoteAsset = notionalPosition * Q / size\n            * unrealizedPnlAfter = unrealizedPnl - realizedPnl = unrealizedPnl - unrealizedPnl * Q / size\n            * remainOpenNotional = notionalPosition - notionalPosition * Q / size - unrealizedPnl + unrealizedPnl * Q / size\n            * => remainOpenNotional = notionalPosition(size-Q)/size - unrealizedPnl(size-Q)/size\n            * => remainOpenNotional = (notionalPosition - unrealizedPnl) * (size-Q)/size\n            * Since notionalPosition includes the PnL component, notionalPosition >= unrealizedPnl and size >= Q\n            * Hence remainOpenNotional >= 0\n            */\n            remainOpenNotional = (newNotionalPosition.toInt256() - unrealizedPnlAfter).toUint256();  // will assert that remainOpenNotional >= 0\n        } else {\n            /**\n            * Let baseAssetQuantity = Q, position.size = size, by definition of _reducePosition, abs(size) >= abs(Q)\n            * quoteAsset = notionalPosition * Q / size\n            * unrealizedPnlAfter = unrealizedPnl - realizedPnl = unrealizedPnl - unrealizedPnl * Q / size\n            * remainOpenNotional = notionalPosition - notionalPosition * Q / size + unrealizedPnl - unrealizedPnl * Q / size\n            * => remainOpenNotional = notionalPosition(size-Q)/size + unrealizedPnl(size-Q)/size\n            * => remainOpenNotional = (notionalPosition + unrealizedPnl) * (size-Q)/size\n            * => In AMM.sol, unrealizedPnl = position.openNotional - notionalPosition\n            * => notionalPosition + unrealizedPnl >= 0\n            * Hence remainOpenNotional >= 0\n            */\n            remainOpenNotional = (newNotionalPosition.toInt256() + unrealizedPnlAfter).toUint256();  // will assert that remainOpenNotional >= 0\n        }\n    }\n\n    /**\n     * @notice update funding rate\n     * @dev only allow to update while reaching `nextFundingTime`\n     */\n    function settleFunding()\n        override\n        external\n        onlyClearingHouse\n    {\n        if (ammState != AMMState.Active) return;\n        require(_blockTimestamp() >= nextFundingTime, \"settle funding too early\");\n\n        // premium = twapMarketPrice - twapIndexPrice\n        // timeFraction = fundingPeriod(1 hour) / 1 day\n        // premiumFraction = premium * timeFraction\n        int256 underlyingPrice = getUnderlyingTwapPrice(spotPriceTwapInterval);\n        int256 premium = getTwapPrice(spotPriceTwapInterval) - underlyingPrice;\n        int256 premiumFraction = (premium * int256(fundingPeriod)) / 1 days;\n\n        // update funding rate = premiumFraction / twapIndexPrice\n        _updateFundingRate(premiumFraction, underlyingPrice);\n\n        int256 premiumPerDtoken = posAccumulator * premiumFraction;\n\n        // makers pay slightly more to account for rounding off\n        premiumPerDtoken = (premiumPerDtoken / BASE_PRECISION) + 1;\n\n        cumulativePremiumFraction += premiumFraction;\n        cumulativePremiumPerDtoken += premiumPerDtoken;\n\n        // Updates for next funding event\n        // in order to prevent multiple funding settlement during very short time after network congestion\n        uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod;\n\n        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600\n        uint256 nextFundingTimeOnHourStart = ((nextFundingTime + fundingPeriod) / 1 hours) * 1 hours;\n\n        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)\n        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime\n            ? nextFundingTimeOnHourStart\n            : minNextValidFundingTime;\n    }\n\n    // View\n\n    function getSnapshotLen() external view returns (uint256) {\n        return reserveSnapshots.length;\n    }\n\n    function getUnderlyingTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return oracle.getUnderlyingTwapPrice(underlyingAsset, _intervalInSeconds);\n    }\n\n    function getTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return int256(_calcTwap(_intervalInSeconds));\n    }\n\n    function getNotionalPositionAndUnrealizedPnl(address trader)\n        override\n        external\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl, int256 size, uint256 openNotional)\n    {\n        Position memory _taker = positions[trader];\n        Maker memory _maker = makers[trader];\n\n        (notionalPosition, size, unrealizedPnl, openNotional) = vamm.get_notional(\n            _maker.dToken,\n            _maker.vUSD,\n            _maker.vAsset,\n            _taker.size,\n            _taker.openNotional\n        );\n    }\n\n    function getPendingFundingPayment(address trader)\n        override\n        public\n        view\n        returns(\n            int256 takerFundingPayment,\n            int256 makerFundingPayment,\n            int256 latestCumulativePremiumFraction,\n            int256 latestPremiumPerDtoken\n        )\n    {\n        latestCumulativePremiumFraction = cumulativePremiumFraction;\n        Position memory taker = positions[trader];\n\n        takerFundingPayment = (latestCumulativePremiumFraction - taker.lastPremiumFraction)\n            * taker.size\n            / BASE_PRECISION;\n\n        // Maker funding payment\n        latestPremiumPerDtoken = cumulativePremiumPerDtoken;\n\n        Maker memory maker = makers[trader];\n        int256 dToken = maker.dToken.toInt256();\n        if (dToken > 0) {\n            int256 cpf = latestCumulativePremiumFraction - maker.lastPremiumFraction;\n            makerFundingPayment = (\n                maker.pos * cpf +\n                (\n                    latestPremiumPerDtoken\n                    - maker.lastPremiumPerDtoken\n                    - maker.posAccumulator * cpf / BASE_PRECISION\n                ) * dToken\n            ) / BASE_PRECISION;\n        }\n    }\n\n    function getCloseQuote(int256 baseAssetQuantity) override public view returns(uint256 quoteAssetQuantity) {\n        if (baseAssetQuantity > 0) {\n            return vamm.get_dy(1, 0, baseAssetQuantity.toUint256());\n        } else if (baseAssetQuantity < 0) {\n            return vamm.get_dx(0, 1, (-baseAssetQuantity).toUint256());\n        }\n        return 0;\n    }\n\n    function getTakerNotionalPositionAndUnrealizedPnl(address trader) override public view returns(uint takerNotionalPosition, int256 unrealizedPnl) {\n        Position memory position = positions[trader];\n        if (position.size > 0) {\n            takerNotionalPosition = vamm.get_dy(1, 0, position.size.toUint256());\n            unrealizedPnl = takerNotionalPosition.toInt256() - position.openNotional.toInt256();\n        } else if (position.size < 0) {\n            takerNotionalPosition = vamm.get_dx(0, 1, (-position.size).toUint256());\n            unrealizedPnl = position.openNotional.toInt256() - takerNotionalPosition.toInt256();\n        }\n    }\n\n    function lastPrice() external view returns(uint256) {\n        return vamm.last_prices() / 1e12;\n    }\n\n    function openInterestNotional() public view returns (uint256) {\n        return longOpenInterestNotional + shortOpenInterestNotional;\n    }\n\n    // internal\n\n    /**\n    * @dev Go long on an asset\n    * @param baseAssetQuantity Exact base asset quantity to go long\n    * @param max_dx Maximum amount of quote asset to be used while longing baseAssetQuantity. Lower means longing at a lower price (desirable).\n    * @return quoteAssetQuantity quote asset utilised. quoteAssetQuantity / baseAssetQuantity was the average rate.\n      quoteAssetQuantity <= max_dx\n    */\n    function _long(int256 baseAssetQuantity, uint max_dx) internal returns (uint256 quoteAssetQuantity) {\n        require(baseAssetQuantity > 0, \"VAMM._long: baseAssetQuantity is <= 0\");\n\n        uint _lastPrice;\n        (quoteAssetQuantity, _lastPrice) = vamm.exchangeExactOut(\n            0, // sell quote asset\n            1, // purchase base asset\n            baseAssetQuantity.toUint256(), // long exactly. Note that statement asserts that baseAssetQuantity >= 0\n            max_dx\n        ); // 6 decimals precision\n\n        _addReserveSnapshot(_lastPrice);\n        // since maker position will be opposite of the trade\n        posAccumulator -= baseAssetQuantity * 1e18 / vamm.totalSupply().toInt256();\n        emit Swap(baseAssetQuantity, quoteAssetQuantity, _lastPrice, openInterestNotional());\n    }\n\n    /**\n    * @dev Go short on an asset\n    * @param baseAssetQuantity Exact base asset quantity to short\n    * @param min_dy Minimum amount of quote asset to be used while shorting baseAssetQuantity. Higher means shorting at a higher price (desirable).\n    * @return quoteAssetQuantity quote asset utilised. quoteAssetQuantity / baseAssetQuantity was the average short rate.\n      quoteAssetQuantity >= min_dy.\n    */\n    function _short(int256 baseAssetQuantity, uint min_dy) internal returns (uint256 quoteAssetQuantity) {\n        require(baseAssetQuantity < 0, \"VAMM._short: baseAssetQuantity is >= 0\");\n\n        uint _lastPrice;\n        (quoteAssetQuantity, _lastPrice) = vamm.exchange(\n            1, // sell base asset\n            0, // get quote asset\n            (-baseAssetQuantity).toUint256(), // short exactly. Note that statement asserts that baseAssetQuantity <= 0\n            min_dy\n        );\n\n        _addReserveSnapshot(_lastPrice);\n        // since maker position will be opposite of the trade\n        posAccumulator -= baseAssetQuantity * 1e18 / vamm.totalSupply().toInt256();\n        emit Swap(baseAssetQuantity, quoteAssetQuantity, _lastPrice, openInterestNotional());\n    }\n\n    function _emitPositionChanged(address trader, int256 realizedPnl) internal {\n        Position memory position = positions[trader];\n        emit PositionChanged(trader, position.size, position.openNotional, realizedPnl);\n    }\n\n    // @dev check takerPosition != 0 before calling\n    function _getPnlWhileReducingPosition(\n        int256 takerPosition,\n        uint takerOpenNotional,\n        int256 makerPosition,\n        uint newNotional\n    ) internal pure returns (int256 pnlToBeRealized) {\n        /**\n            makerNotional = newNotional * makerPos / totalPos\n            if (side remains same)\n                reducedOpenNotional = takerOpenNotional * makerPos / takerPos\n                pnl = makerNotional - reducedOpenNotional\n            else (reverse position)\n                closedPositionNotional = newNotional * takerPos / totalPos\n                pnl = closePositionNotional - takerOpenNotional\n         */\n\n        uint totalPosition = abs(makerPosition + takerPosition).toUint256();\n        if (abs(takerPosition) > abs(makerPosition)) { // taker position side remains same\n            uint reducedOpenNotional = takerOpenNotional * abs(makerPosition).toUint256() / abs(takerPosition).toUint256();\n            uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition;\n            pnlToBeRealized = _getPnlToBeRealized(takerPosition, makerNotional, reducedOpenNotional);\n        } else { // taker position side changes\n            // @todo handle case when totalPosition = 0\n            uint closedPositionNotional = newNotional * abs(takerPosition).toUint256() / totalPosition;\n            pnlToBeRealized = _getPnlToBeRealized(takerPosition, closedPositionNotional, takerOpenNotional);\n        }\n    }\n\n    function _getPnlToBeRealized(int256 takerPosition, uint notionalPosition, uint openNotional) internal pure returns (int256 pnlToBeRealized) {\n        if (takerPosition > 0) {\n            pnlToBeRealized = notionalPosition.toInt256() - openNotional.toInt256();\n        } else {\n            pnlToBeRealized = openNotional.toInt256() - notionalPosition.toInt256();\n        }\n    }\n\n    function _increasePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns(uint quoteAsset)\n    {\n        if (baseAssetQuantity > 0) { // Long - purchase baseAssetQuantity\n            longOpenInterestNotional += baseAssetQuantity.toUint256();\n            quoteAsset = _long(baseAssetQuantity, quoteAssetLimit);\n        } else { // Short - sell baseAssetQuantity\n            shortOpenInterestNotional += (-baseAssetQuantity).toUint256();\n            quoteAsset = _short(baseAssetQuantity, quoteAssetLimit);\n        }\n        positions[trader].size += baseAssetQuantity; // -ve baseAssetQuantity will increase short position\n        positions[trader].openNotional += quoteAsset;\n    }\n\n    function _openReversePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased)\n    {\n        Position memory position = positions[trader];\n        if (abs(position.size) >= abs(baseAssetQuantity)) {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, baseAssetQuantity, quoteAssetLimit);\n        } else {\n            uint closedRatio = (quoteAssetLimit * abs(position.size).toUint256()) / abs(baseAssetQuantity).toUint256();\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, closedRatio);\n\n            // this is required because the user might pass a very less value (slippage-prone) while shorting\n            if (quoteAssetLimit >= quoteAsset) {\n                quoteAssetLimit -= quoteAsset;\n            }\n            quoteAsset += _increasePosition(trader, baseAssetQuantity + position.size, quoteAssetLimit);\n            isPositionIncreased = true;\n        }\n    }\n\n    /**\n    * @dev validate that baseAssetQuantity <= position.size should be performed before the call to _reducePosition\n    */\n    function _reducePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns (int realizedPnl, uint256 quoteAsset)\n    {\n        (, int256 unrealizedPnl) = getTakerNotionalPositionAndUnrealizedPnl(trader);\n\n        Position storage position = positions[trader]; // storage because there are updates at the end\n        bool isLongPosition = position.size > 0 ? true : false;\n\n        if (isLongPosition) {\n            longOpenInterestNotional -= (-baseAssetQuantity).toUint256();\n            quoteAsset = _short(baseAssetQuantity, quoteAssetLimit);\n        } else {\n            shortOpenInterestNotional -= baseAssetQuantity.toUint256();\n            quoteAsset = _long(baseAssetQuantity, quoteAssetLimit);\n        }\n        uint256 notionalPosition = getCloseQuote(position.size + baseAssetQuantity);\n        (position.openNotional, realizedPnl) = getOpenNotionalWhileReducingPosition(position.size, notionalPosition, unrealizedPnl, baseAssetQuantity);\n        position.size += baseAssetQuantity;\n    }\n\n    function _addReserveSnapshot(uint256 price)\n        internal\n    {\n        uint256 currentBlock = block.number;\n        uint256 blockTimestamp = _blockTimestamp();\n\n        if (reserveSnapshots.length == 0) {\n            reserveSnapshots.push(\n                ReserveSnapshot(price, blockTimestamp, currentBlock)\n            );\n            return;\n        }\n\n        ReserveSnapshot storage latestSnapshot = reserveSnapshots[reserveSnapshots.length - 1];\n        // update values in snapshot if in the same block\n        if (currentBlock == latestSnapshot.blockNumber) {\n            latestSnapshot.lastPrice = price;\n        } else {\n            reserveSnapshots.push(\n                ReserveSnapshot(price, blockTimestamp, currentBlock)\n            );\n        }\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _calcTwap(uint256 _intervalInSeconds)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshotIndex = reserveSnapshots.length - 1;\n        uint256 currentPrice = reserveSnapshots[snapshotIndex].lastPrice;\n        if (_intervalInSeconds == 0) {\n            return currentPrice;\n        }\n\n        uint256 baseTimestamp = _blockTimestamp() - _intervalInSeconds;\n        ReserveSnapshot memory currentSnapshot = reserveSnapshots[snapshotIndex];\n        // return the latest snapshot price directly\n        // if only one snapshot or the timestamp of latest snapshot is earlier than asking for\n        if (reserveSnapshots.length == 1 || currentSnapshot.timestamp <= baseTimestamp) {\n            return currentPrice;\n        }\n\n        uint256 previousTimestamp = currentSnapshot.timestamp;\n        uint256 period = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = currentPrice * period;\n        while (true) {\n            // if snapshot history is too short\n            if (snapshotIndex == 0) {\n                return weightedPrice / period;\n            }\n\n            snapshotIndex = snapshotIndex - 1;\n            currentSnapshot = reserveSnapshots[snapshotIndex];\n            currentPrice = reserveSnapshots[snapshotIndex].lastPrice;\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentSnapshot.timestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, _interval is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentSnapshot.timestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            period = period + timeFraction;\n            previousTimestamp = currentSnapshot.timestamp;\n        }\n        return weightedPrice / _intervalInSeconds;\n    }\n\n    function _updateFundingRate(\n        int256 _premiumFraction,\n        int256 _underlyingPrice\n    ) internal {\n        fundingRate = _premiumFraction * 1e6 / _underlyingPrice;\n        emit FundingRateUpdated(_premiumFraction, fundingRate, _underlyingPrice.toUint256(), _blockTimestamp(), block.number);\n    }\n\n    // Pure\n\n    function abs(int x) private pure returns (int) {\n        return x >= 0 ? x : -x;\n    }\n\n    // Governance\n\n    function setAmmState(AMMState _state) external onlyGovernance {\n        require(ammState != _state, \"AMM.setAmmState.sameState\");\n        ammState = _state;\n        if (_state == AMMState.Active) {\n            nextFundingTime = ((_blockTimestamp() + fundingPeriod) / 1 hours) * 1 hours;\n        }\n    }\n\n    function syncDeps(address _registry) public onlyGovernance {\n        IRegistry registry = IRegistry(_registry);\n        clearingHouse = registry.clearingHouse();\n        oracle = IOracle(registry.oracle());\n    }\n\n    function setFundingBufferPeriod(uint _fundingBufferPeriod) external onlyGovernance {\n        fundingBufferPeriod = _fundingBufferPeriod;\n    }\n}\n\n\n",
        "CodeNames": [
            "HubbleViewer.sol",
            "InsuranceFund.sol",
            "AMM.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "balance()",
                    "shares",
                    "withdraw(",
                    "deposit",
                    "deposit(_amount ="
                ],
                "Type": " InsuranceFund depositors can be priced out & deposits can be stolen",
                "Description": "\n<https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L44-L54<br\n\nThe InsuranceFund.deposit function mints initial shares equal to the deposited amount.<br\nThe deposit / withdraw functions also use the VUSD contract balance for the shares computation. (balance() = vusd.balanceOf(address(this)))\n\nIt's possible to increase the share price to very high amounts and price out smaller depositors.\n\n\n*   deposit(_amount = 1): Deposit the smallest unit of VUSD as the first depositor. Mint 1 share and set the total supply and VUSD balance to 1.\n*   Perform a direct transfer of 1000.0 VUSD to the InsuranceFund. The balance() is now 1000e6 + 1\n*   Doing any deposits of less than 1000.0 VUSD will mint zero shares: shares = _amount * _totalSupply / _pool = 1000e6 * 1 / (1000e6 + 1) = 0.\n*   The attacker can call withdraw(1) to burn their single share and receive the entire pool balance, making a profit. (balance() * _shares / totalSupply() = balance())\n\nI give this a high severity as the same concept can be used to always steal the initial insurance fund deposit by frontrunning it and doing the above-mentioned steps, just sending the frontrunned deposit amount to the contract instead of the fixed 1000.0.\nThey can then even repeat the steps to always frontrun and steal any deposits.\n\n",
                "Repair": "\nThe way UniswapV2 prevents this(https://github.com/Uniswap/v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/UniswapV2Pair.sol#L121) is by requiring a minimum deposit amount and sending 1000 initial shares to the zero address to make this attack more expensive.\nThe same mitigation can be done here.\n\natvanguard (Hubble) confirmed(https://github.com/code-423n4/2022-02-hubble-findings/issues/42)\n\n\n\n*\n \n\n"
            }
        ]
    }
]