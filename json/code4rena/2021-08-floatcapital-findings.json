[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/ITokenFactory.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IYieldManager.sol\";\nimport \"./interfaces/IOracleManager.sol\";\n\n/**\n **** visit https://float.capital *****\n */\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          VARIABLES          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Fixed-precision constants \u2550\u2550\u2550\u2550\u2550\u2550 */\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Global state \u2550\u2550\u2550\u2550\u2550\u2550 */\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => bool) public marketExists;\n  mapping(uint32 => uint256) public assetPrice;\n  mapping(uint32 => uint256) public marketUpdateIndex;\n  mapping(uint32 => address) public paymentTokens;\n  mapping(uint32 => address) public yieldManagers;\n  mapping(uint32 => address) public oracleManagers;\n  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market + position (long/short) specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 User specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           EVENTS           \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          MODIFIERS          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, \"only admin\");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    _;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], \"market doesn't exist\");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    _;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n    _;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    _updateSystemStateInternal(marketIndex);\n    _;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       CONTRACT SET-UP       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin's initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       ADMIN       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test's arn't validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       MARKET CREATION       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The `initializeMarket` function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Up \", syntheticName)),\n      string(abi.encodePacked(\"fu\", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Down \", syntheticName)),\n      string(abi.encodePacked(\"fd\", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide >= 1e18,\n      \"Insufficient market seed\"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], \"already initialized\");\n    require(marketIndex <= latestMarket, \"index too high\");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       GETTER FUNCTIONS       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a > b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /**\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side's synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side's synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  */\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /**\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - \"Pending\" - means the next price update hasn't happened or been enacted on by the updateSystemState function.\n        - \"Confirmed\" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - \"Settled\" - there is no more computation left for the user.\n        - \"Non-existant\" - user has no next price actions.\n    This function returns a calculated value only in the case of 'confirmed' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  */\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&\n      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited > 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /**\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   */\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue < shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       HELPER FUNCTIONS       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount > 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure < 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange > 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551     UPDATING SYSTEM STATE     \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           DEPOSIT              \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       MINT POSITION       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551      REDEEM POSITION      \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       SHIFT POSITION      \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551     NEXT PRICE SETTLEMENTS     \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount > 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions > 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551   BATCHED NEXT PRICE SETTLEMENT ACTIONS   \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket > 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket < 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply > 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply < 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n\n  /**\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable > 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable > 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable > 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable > 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable > 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable > 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n\n\n",
        "CodeNames": [
            "LongShort.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction _batchConfirmOutstandingPendingActions(\n..\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n...\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; // should probably be false\n)\n"
                ],
                "Type": " copy paste error in  _batchConfirmOutstandingPendingActions ",
                "Description": "\nThe function _batchConfirmOutstandingPendingActions of LongShort.sol processes the variable batched_amountSyntheticToken_toShiftAwayFrom_marketSide, and sets it to 0 after processing. However, probably due to a copy/paste error, in the second instance, where batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed, the wrong version is set to 0: batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0\n\nThis means the next time the batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.\n\nLongShort.sol L1126(https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1126)\nsolidity\nfunction _batchConfirmOutstandingPendingActions(\n..\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n...\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; // should probably be false\n)\n\n\n",
                "Repair": "Recommend changing the second instance of the following (on line 1207)\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0\nto\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0\n\np.s. confirmed by Jason of Floatcapital: \"Yes, that should definitely be false!\"\n\nJasoonS (Float) commented(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5#issuecomment-895969550):\n  Mitigation\n\n diff\n batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0\n + batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0\n \n\nmoose-code (Float) confirmed(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5#issuecomment-896714257):\n  Good attention to detail. Silly on our part.\n\nDenhamPreen (Float) patched(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5#issuecomment-897472713):\n  https://github.com/Float-Capital/monorepo/pull/1087\n\n Resolved PR\n\n *note this repo is still private\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n  ...\n  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);   // should be marketIndex\n  ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);  // should be marketIndex\n\nfunction initializeMarket(\n    uint32 marketIndex,....)\n...\n  require(!marketExists[marketIndex], \"already initialized\");\n  require(marketIndex <= latestMarket, \"index too high\");\n  marketExists[marketIndex] = true;\n..\n  IStaker(staker).addNewStakingFund(\n    `latestMarket`,                                       // should be marketIndex.\n    syntheticTokens[latestMarket][true],   // should be marketIndex\n    syntheticTokens[latestMarket][false],  // should be marketIndex\n...\n"
                ],
                "Type": "  latestMarket  used where  marketIndex  should have been used",
                "Description": "\nThe functions initializeMarket and _seedMarketInitially use the variable latestMarket.\nIf these functions would be called seperately from createNewSyntheticMarket, then latestMarket would have the same value for each call of initializeMarket and _seedMarketInitially\n\nThis would mean that the latestMarket is initialized multiple times and the previous market(s) are not initialized properly.\nNote: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.\n\nNote: the functions can only be called by the admin, so if createNewSyntheticMarket and initializeMarket are called in combination, then it would not lead to problems,\nbut in future release of the software the calls to createNewSyntheticMarket and initializeMarket might get separated.\n\nLongShort.sol #L304(https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L304)\nsolidity\nfunction _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n  ...\n  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);   // should be marketIndex\n  ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);  // should be marketIndex\n\nfunction initializeMarket(\n    uint32 marketIndex,....)\n...\n  require(!marketExists[marketIndex], \"already initialized\");\n  require(marketIndex <= latestMarket, \"index too high\");\n  marketExists[marketIndex] = true;\n..\n  IStaker(staker).addNewStakingFund(\n    latestMarket,                                       // should be marketIndex.\n    syntheticTokens[latestMarket][true],   // should be marketIndex\n    syntheticTokens[latestMarket][false],  // should be marketIndex\n...\n\n\n",
                "Repair": "Recommend replacing latestMarket with marketIndex in the functions initializeMarket and _seedMarketInitially.\n\np.s. confirmed by Jason of float capital: Definitely an issue, luckily both of those functions are adminOnly. But that is definitely not ideal!\n\nJasoonS (Float) confirmed(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/9#issuecomment-896001724):\n  Great spot!\n\n ![image(https://user-images.githubusercontent.com/6032276/128869917-0121e5cb-d550-4d1e-ac25-5c97efdd2ff1.png)\n\n Not a risk if you know about it (you just need to launch markets sequentially not in batches), but we didn't. So 2 medium risk is fair :)\n\n\nDenhamPreen (Float) patched(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/9#issuecomment-897493238):\n  Resolved PR\n https://github.com/Float-Capital/monorepo/pull/1106\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nlong_synth_balace = 300;\nshort_synth_balace = 200;\n\nmarketUpdateIndex[1] = x;\nuserNextPrice_currentUpdateIndex = 0;\nuserNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;\n",
                    "//solidity\nlong_synth_balace = 200;\nshort_synth_balace = 200;\nuserNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100;\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100;\nuserNextPrice_currentUpdateIndex = x+1 ;\n",
                    "//solidity\nif (\n  userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&\n  userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex\n)\n",
                    "//solidity\nsyntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex]\n"
                ],
                "Type": " Incorrect balance computed in  getUsersConfirmedButNotSettledSynthBalance() ",
                "Description": "\nConsider the following state:\nsolidity\nlong_synth_balace = 300;\nshort_synth_balace = 200;\n\nmarketUpdateIndex[1] = x;\nuserNextPrice_currentUpdateIndex = 0;\nuserNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;\n\n\nUser calls shiftPositionFromLongNextPrice(marketIndex=1, amountSyntheticTokensToShift=100)\n\nThis results in following state changes:\nsolidity\nlong_synth_balace = 200;\nshort_synth_balace = 200;\nuserNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100;\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100;\nuserNextPrice_currentUpdateIndex = x+1 ;\n\n\nDue to some other transactions, oracle updates twice, and now the marketUpdateIndex[1] is x+2 and also updating price snapshots.\n\nWhen User calls getUsersConfirmedButNotSettledSynthBalance(user, 1)\n\ninitial condition:\nsolidity\nif (\n  userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&\n  userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex\n)\n\nwill be true;\nLongShort.sol L532(https://github.com/hack3r-0m/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L532)\nsolidity\nsyntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex]\n\n\nThis uses price of current x+2 th update while it should balance of accounting for price of x+1 th update.\n\nJasoonS (Float) confirmed and disagreed with severity(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142#issuecomment-897368280):\n  Yes good spot.\n\n This function is view only, and is only used for view only purposes. The rest of the system will always operate correctly because it rather uses _executeOutstandingNextPriceSettlements than the getUsersConfirmedButNotSettledSynthBalance. Therefore I propose this as a 1 Low Risk vulnerability.\n\n0xean (judge) (judge) commented(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142#issuecomment-905007960):\n  I am going to align with the 2 (Med Risk) severity.  Reporting the incorrect position in a UI to a user could definitely lead unexpected loss of funds in a sharp market move where a user is intending on hedging elsewhere.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": " Missing events/timelocks for owner/admin only functions that change critical parameters",
                "Description": "\nOwner/admin only functions that change critical parameters should emit events and have timelocks. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.\n\nMissing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.\n\nThere are owner/admin functions that do not emit any events in LongShort.sol. It is not apparent that any owner/admin functions will have timelocks.\n\nSee similar High-severity H03(https://blog.openzeppelin.com/audius-contracts-audit/#high) finding in OpenZeppelin\u2019s Audit of Audius and Medium-severity M01(https://blog.openzeppelin.com/uma-audit-phase-4/) finding OpenZeppelin\u2019s Audit of UMA Phase 4\n\nSee issue page for referenced code.\n\n",
                "Repair": "Recommend adding events to all owner/admin functions that change critical parameters. Add timelocks to introduce time delays for critical parameter changes that significantly impact market/user incentives/security.\n\nJasoonS (Float) acknowledged(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/85#issuecomment-897497116):\n  We will manage timelocks and multi-sigs externally to these contracts.\n\nJasoonS (Float) commented(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/85#issuecomment-898693915):\n  I would consider this a duplicate of #84 in many ways. (or at least #84 is a sub-issue of this issue)\n\n0xean (judge) commented(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/85#issuecomment-905048244):\n  duplicate of #84 as both offer solutions for dealing with privileged functionality (including the transfer of ownership). Leaving severity as 2 based on the potential risks associated with an incorrect admin change or similar.\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction `_updateSystemStateInternal`(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n  ...\n  int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n  int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n  bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n  if (assetPriceHasChanged || msg.sender == staker) {\n    ....\n    if (!assetPriceHasChanged) {\n      return;\n    }\n    ....\n    marketUpdateIndex[marketIndex] += 1;  // never reaches this point if the price doesn't change\n\n// https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1035\nfunction _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n  uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n  if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) { // needs marketUpdateIndex[marketIndex] to be increased\n    _executeOutstandingNextPriceMints(marketIndex, user, true);\n    _executeOutstandingNextPriceMints(marketIndex, user, false);\n    _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n    _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n    _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n    _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n"
                ],
                "Type": " Prevent markets getting stuck when prices don't move",
                "Description": "\nSuppose there is a synthetic token where the price stays constant, for example:\nsynthetic DAI  (with a payment token of DAI the price will not move)\nbinary option token (for example tracking the USA elections; after the election results there will be no more price movements)\n\nIn that case assetPriceHasChanged will never be true (again) and marketUpdateIndex[marketIndex] will never increase.\nThis means the _executeOutstandingNextPrice* functions will never be executed, which means the market effectively will be stuck.\n\nLongShort.sol L669(https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L669)\nsolidity\nfunction _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n  ...\n  int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n  int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n  bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n  if (assetPriceHasChanged || msg.sender == staker) {\n    ....\n    if (!assetPriceHasChanged) {\n      return;\n    }\n    ....\n    marketUpdateIndex[marketIndex] += 1;  // never reaches this point if the price doesn't change\n\n// https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1035\nfunction _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n  uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n  if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) { // needs marketUpdateIndex[marketIndex] to be increased\n    _executeOutstandingNextPriceMints(marketIndex, user, true);\n    _executeOutstandingNextPriceMints(marketIndex, user, false);\n    _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n    _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n    _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n    _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n\n",
                "Repair": "Recommend enhancing _updateSystemStateInternal so that after a certain period of time without price movements (for example 1 day), the entire function is executed (including the marketUpdateIndex[marketIndex] += 1;)\n\nJasoonS (Float) disputed(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16#issuecomment-896069784):\n  Good point, we thought the time since last update check wasn't necessary.\n\n I'll chat with the team about what they think the risk is. But I don't think it is 3 given that we don't plan to launch any assets that don't have regular change (so market would be stuck for a limited time even if it is long).\n\n In a lot of ways our 'nextPriceExecution model is designed for this case. Some more traditional markets close for the weekend and over night. Our mechanism means that users will be able to buy and trade these assets at any time and get the asset as soon as there is an update.\n\nJasoonS (Float) commented(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16#issuecomment-896290768):\n  The more I think about this the more I think it is a safety feature. It is way more likely that if the oracle keeps returning the same value that something is broken (which means we can catch the issue before it negatively impacts the system by unfairly managing user funds or similar). If it really is stuck on the same value legitimately it can replace the OracleManager that is being used to help with that.\n\nmoose-code (Float) commented(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16#issuecomment-896735385):\n  Since there is no current plan for a binary market, and the system would definitely need other accommodations to allow a binary market, since next price execution etc, this doesn't make sense as an issue in this case. The system is built for markets where continuous price updates will occur.\n\n Agree with Jason, if not price update is occurring, there is likely an issue with the oracle, and our system is not failing even in light of this issue. It is effectively paused until a new price update is given. As Jason mentions we can use the oracle manager to fix this\n\n0xean (judge) commented(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16#issuecomment-906047797):\n  Due to the ability to update the oracle, funds would not be lost, but it would be an availability risk (even if temporary) for the system.  Based on that I am downgrading to a 2.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/ITokenFactory.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IYieldManager.sol\";\nimport \"./interfaces/IOracleManager.sol\";\n\n/**\n **** visit https://float.capital *****\n */\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          VARIABLES          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Fixed-precision constants \u2550\u2550\u2550\u2550\u2550\u2550 */\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Global state \u2550\u2550\u2550\u2550\u2550\u2550 */\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => bool) public marketExists;\n  mapping(uint32 => uint256) public assetPrice;\n  mapping(uint32 => uint256) public marketUpdateIndex;\n  mapping(uint32 => address) public paymentTokens;\n  mapping(uint32 => address) public yieldManagers;\n  mapping(uint32 => address) public oracleManagers;\n  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market + position (long/short) specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 User specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           EVENTS           \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          MODIFIERS          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, \"only admin\");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    _;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], \"market doesn't exist\");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    _;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n    _;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    _updateSystemStateInternal(marketIndex);\n    _;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       CONTRACT SET-UP       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin's initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       ADMIN       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test's arn't validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       MARKET CREATION       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The `initializeMarket` function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Up \", syntheticName)),\n      string(abi.encodePacked(\"fu\", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Down \", syntheticName)),\n      string(abi.encodePacked(\"fd\", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide >= 1e18,\n      \"Insufficient market seed\"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], \"already initialized\");\n    require(marketIndex <= latestMarket, \"index too high\");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       GETTER FUNCTIONS       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a > b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /**\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side's synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side's synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  */\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /**\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - \"Pending\" - means the next price update hasn't happened or been enacted on by the updateSystemState function.\n        - \"Confirmed\" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - \"Settled\" - there is no more computation left for the user.\n        - \"Non-existant\" - user has no next price actions.\n    This function returns a calculated value only in the case of 'confirmed' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  */\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&\n      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited > 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /**\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   */\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue < shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       HELPER FUNCTIONS       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount > 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure < 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange > 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551     UPDATING SYSTEM STATE     \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           DEPOSIT              \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       MINT POSITION       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551      REDEEM POSITION      \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       SHIFT POSITION      \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551     NEXT PRICE SETTLEMENTS     \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount > 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions > 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551   BATCHED NEXT PRICE SETTLEMENT ACTIONS   \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket > 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket < 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply > 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply < 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n\n  /**\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable > 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable > 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable > 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable > 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable > 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable > 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport \"./interfaces/IFloatToken.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\n\ncontract Staker is IStaker, Initializable {\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          VARIABLES          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Fixed-precision constants \u2550\u2550\u2550\u2550\u2550\u2550 */\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Global state \u2550\u2550\u2550\u2550\u2550\u2550 */\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 => uint256) public marketUnstakeFee_e18;\n  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n\n  mapping(address => uint32) public marketIndexOfToken;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Reward specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public latestRewardIndex;\n  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 User specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;\n  mapping(address => mapping(address => uint256)) public userAmountStaked;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Token shift management specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;\n  /**\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  */\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           EVENTS           \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          MODIFIERS          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, \"not admin\");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    _;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, \"not valid synth\");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    _;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), \"not valid market\");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    _;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), \"not long short\");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    _;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       CONTRACT SET-UP       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin's initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  */\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       ADMIN       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /** \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  */\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /**\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /**\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  */\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier >= 1e18, \"marketLaunchIncentiveMultiplier must be >= 1e18\");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /**\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  */\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,\n      \"balanceIncentiveCurve_exponent out of bounds\"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  /** \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,\n      \"balanceIncentiveCurve_equilibriumOffset out of bounds\"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /**\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  */\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551        STAKING SETUP        \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  */\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven't been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier < 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  /** \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market's launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  */\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // *never* be set to a value < 1e18, as there are guards against this.\n    assert(kInitialMultiplier >= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp <= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /*\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they've staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   */\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *\n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {\n      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /**\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  */\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /**\n  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative 'r' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  */\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current 'r' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative 'r' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /**\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /**\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    USER REWARD STATE FUNCTIONS    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong > 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort > 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  /** \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   */\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don't do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /**\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /**\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint > 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /**\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint > 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal > 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /**\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /**\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   */\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551        STAKING        \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  */\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n\n  /**\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&\n      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n\n  /**\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  */\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, \"Not enough tokens to shift\");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    WITHDRAWAL & MINTING    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  */\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] > 0, \"nothing to withdraw\");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  /**\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don't withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,\n        \"Outstanding next price stake shifts too great\"\n      );\n    }\n  }\n\n  /**\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n\n\n",
        "CodeNames": [
            "LongShort.sol",
            "Staker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    ...\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n...\n)\n"
                ],
                "Type": " 2 variables not indexed by  marketIndex ",
                "Description": "\nIn the token contract: batched_stakerNextTokenShiftIndex is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.\n\nstakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex.\nSo the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping\ncan be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex[market2]\n\nThis will lead to weird results in _calculateAccumulatedFloat, allocating too much or too little float.\n\nStaker.sol L622(https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L622)\nsolidity\nfunction pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    ...\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n...\n)\n\n\n",
                "Repair": "Recommend adding an index with marketIndex to the variables:\nstakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping\nstakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping\n\nAlso consider shortening the variable names, this way mistakes can be spotted easier.\n\nConfirmed by Jason of Float Capital: Yes, you are totally right, it should use the marketIndex since they are specific per market!\n\nJasoonS (Float) confirmed(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/8#issuecomment-895999895):\n  :see_no_evil: Embarrassed by this one!\n\n Thank you for the report.\n\n Fixed!!\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport \"./interfaces/IFloatToken.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\n\ncontract Staker is IStaker, Initializable {\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          VARIABLES          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Fixed-precision constants \u2550\u2550\u2550\u2550\u2550\u2550 */\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Global state \u2550\u2550\u2550\u2550\u2550\u2550 */\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 => uint256) public marketUnstakeFee_e18;\n  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n\n  mapping(address => uint32) public marketIndexOfToken;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Reward specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public latestRewardIndex;\n  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 User specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;\n  mapping(address => mapping(address => uint256)) public userAmountStaked;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Token shift management specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;\n  /**\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  */\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           EVENTS           \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          MODIFIERS          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, \"not admin\");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    _;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, \"not valid synth\");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    _;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), \"not valid market\");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    _;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), \"not long short\");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    _;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       CONTRACT SET-UP       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin's initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  */\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       ADMIN       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /** \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  */\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /**\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /**\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  */\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier >= 1e18, \"marketLaunchIncentiveMultiplier must be >= 1e18\");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /**\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  */\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,\n      \"balanceIncentiveCurve_exponent out of bounds\"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  /** \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,\n      \"balanceIncentiveCurve_equilibriumOffset out of bounds\"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /**\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  */\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551        STAKING SETUP        \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  */\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven't been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier < 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  /** \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market's launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  */\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // *never* be set to a value < 1e18, as there are guards against this.\n    assert(kInitialMultiplier >= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp <= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /*\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they've staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   */\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *\n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {\n      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /**\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  */\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /**\n  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative 'r' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  */\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current 'r' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative 'r' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /**\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /**\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    USER REWARD STATE FUNCTIONS    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong > 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort > 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  /** \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   */\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don't do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /**\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /**\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint > 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /**\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint > 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal > 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /**\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /**\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   */\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551        STAKING        \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  */\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n\n  /**\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&\n      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n\n  /**\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  */\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, \"Not enough tokens to shift\");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    WITHDRAWAL & MINTING    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  */\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] > 0, \"nothing to withdraw\");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  /**\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don't withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,\n        \"Outstanding next price stake shifts too great\"\n      );\n    }\n  }\n\n  /**\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n\n\n",
        "CodeNames": [
            "Staker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "shiftTokens"
                ],
                "Type": " Users could shift tokens on  Staker  with more than he has staked",
                "Description": "\nThe shiftTokens function of Staker checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the shiftTokens function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked. Staker.sol#L885(https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L885)\n\n",
                "Repair": "Recommend adding checks on userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long and userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short to ensure that the sum of the two variables does not exceed user's stake balance.\n\nJasoonS (Float) confirmed(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/141#issuecomment-897369855):\n  Yes, spot on! We spotted this the next morning after launching the competition. Token shifting was a last minute addition to the codebase. Really glad someone spotted it, but only in the last few hours, phew!\n\n This would allow a malicious user to completely shift all the tokens (even those not belonging to them to one side or the other!!)\n No funds could be stolen by the user directly (since the execution of those shifts would fail on the user level), but it could be done for personal gain (eg improving the users FLT issuance rate, or similar economic manipulation).\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/ITokenFactory.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IYieldManager.sol\";\nimport \"./interfaces/IOracleManager.sol\";\n\n/**\n **** visit https://float.capital *****\n */\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          VARIABLES          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Fixed-precision constants \u2550\u2550\u2550\u2550\u2550\u2550 */\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Global state \u2550\u2550\u2550\u2550\u2550\u2550 */\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => bool) public marketExists;\n  mapping(uint32 => uint256) public assetPrice;\n  mapping(uint32 => uint256) public marketUpdateIndex;\n  mapping(uint32 => address) public paymentTokens;\n  mapping(uint32 => address) public yieldManagers;\n  mapping(uint32 => address) public oracleManagers;\n  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market + position (long/short) specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 User specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           EVENTS           \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          MODIFIERS          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, \"only admin\");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    _;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], \"market doesn't exist\");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    _;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n    _;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    _updateSystemStateInternal(marketIndex);\n    _;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       CONTRACT SET-UP       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin's initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       ADMIN       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test's arn't validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       MARKET CREATION       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The `initializeMarket` function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Up \", syntheticName)),\n      string(abi.encodePacked(\"fu\", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Down \", syntheticName)),\n      string(abi.encodePacked(\"fd\", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide >= 1e18,\n      \"Insufficient market seed\"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], \"already initialized\");\n    require(marketIndex <= latestMarket, \"index too high\");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       GETTER FUNCTIONS       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a > b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /**\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side's synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side's synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  */\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /**\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - \"Pending\" - means the next price update hasn't happened or been enacted on by the updateSystemState function.\n        - \"Confirmed\" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - \"Settled\" - there is no more computation left for the user.\n        - \"Non-existant\" - user has no next price actions.\n    This function returns a calculated value only in the case of 'confirmed' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  */\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&\n      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited > 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /**\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   */\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue < shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       HELPER FUNCTIONS       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount > 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure < 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange > 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551     UPDATING SYSTEM STATE     \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           DEPOSIT              \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       MINT POSITION       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551      REDEEM POSITION      \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       SHIFT POSITION      \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551     NEXT PRICE SETTLEMENTS     \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount > 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions > 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551   BATCHED NEXT PRICE SETTLEMENT ACTIONS   \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket > 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket < 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply > 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply < 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n\n  /**\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable > 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable > 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable > 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable > 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable > 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable > 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/** @title Float Capital Contract */\ncontract FloatCapital_v0 is Initializable {\n  address public admin;\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          MODIFIERS          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"Not admin\");\n    _;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       CONTRACT SETUP        \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  function initialize(address _admin) external initializer {\n    admin = _admin;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    MULTISIG ADMIN FUNCTIONS    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n  }\n\n  /** A percentage of float token to accrue here for project\n     development */\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport \"./interfaces/IFloatToken.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\n\ncontract Staker is IStaker, Initializable {\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          VARIABLES          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Fixed-precision constants \u2550\u2550\u2550\u2550\u2550\u2550 */\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Global state \u2550\u2550\u2550\u2550\u2550\u2550 */\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Market specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 => uint256) public marketUnstakeFee_e18;\n  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n\n  mapping(address => uint32) public marketIndexOfToken;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Reward specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public latestRewardIndex;\n  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 User specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;\n  mapping(address => mapping(address => uint256)) public userAmountStaked;\n\n  /* \u2550\u2550\u2550\u2550\u2550\u2550 Token shift management specific \u2550\u2550\u2550\u2550\u2550\u2550 */\n  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;\n  /**\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  */\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           EVENTS           \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          MODIFIERS          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, \"not admin\");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    _;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, \"not valid synth\");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    _;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), \"not valid market\");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    _;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), \"not long short\");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    _;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       CONTRACT SET-UP       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin's initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  */\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       ADMIN       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /** \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  */\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /**\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /**\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  */\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier >= 1e18, \"marketLaunchIncentiveMultiplier must be >= 1e18\");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /**\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  */\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,\n      \"balanceIncentiveCurve_exponent out of bounds\"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  /** \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,\n      \"balanceIncentiveCurve_equilibriumOffset out of bounds\"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /**\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  */\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551        STAKING SETUP        \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  */\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven't been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier < 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  /** \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market's launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  */\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // *never* be set to a value < 1e18, as there are guards against this.\n    assert(kInitialMultiplier >= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp <= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /*\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they've staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   */\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *\n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {\n      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /**\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  */\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /**\n  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative 'r' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  */\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current 'r' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative 'r' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /**\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /**\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    USER REWARD STATE FUNCTIONS    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong > 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort > 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  /** \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   */\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don't do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /**\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /**\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint > 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /**\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint > 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal > 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /**\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /**\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   */\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551        STAKING        \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  */\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n\n  /**\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&\n      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n\n  /**\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  */\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, \"Not enough tokens to shift\");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551    WITHDRAWAL & MINTING    \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /**\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  */\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] > 0, \"nothing to withdraw\");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  /**\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don't withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,\n        \"Outstanding next price stake shifts too great\"\n      );\n    }\n  }\n\n  /**\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n\n\n",
        "CodeNames": [
            "LongShort.sol",
            "FloatCapital_v0.sol",
            "Staker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "diff\n -return (1e18 * k * longPrice, 0);\n +return (k * longPrice, 0);\n ",
                    "diff\n -return (0, 1e18 * k * shortPrice);\n +return (0, k * shortPrice);\n "
                ],
                "Type": " Staker.sol: Wrong values returned in edge cases of  _calculateFloatPerSecond() ",
                "Description": "\nIn _calculateFloatPerSecond(), the edge cases where full rewards go to either the long or short token returns\n\nreturn (1e18 * k * longPrice, 0); and\n\nreturn (0, 1e18 * k * shortPrice); respectively.\n\nThis is however 1e18 times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. longRewardUnscaled = 0  and shortRewardUnscaled = 1e18. Plugging this into the calculation below,\n\nreturn ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); results in\n\n(0, 1e18 * k * shortPrice / 1e18) or (0, k * shortPrice).\n\nAs we can see, this would result in an extremely large float token issuance rate, which would be disastrous.\n\nThe edge cases should return (k * longPrice, 0) and (0, k * shortPrice) in the cases where rewards should go fully to long and short token holders respectively.\n\nJasoonS (Float) confirmed(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/6#issuecomment-895995908):\n  Fix:\n diff\n -return (1e18 * k * longPrice, 0);\n +return (k * longPrice, 0);\n \n\n and\n\n diff\n -return (0, 1e18 * k * shortPrice);\n +return (0, k * shortPrice);\n \n\nDenhamPreen (Float) patched(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/6#issuecomment-897480501):\n  Resolved\n https://github.com/Float-Capital/monorepo/pull/1085\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./interfaces/IYieldManager.sol\";\nimport \"./interfaces/aave/ILendingPool.sol\";\nimport \"./interfaces/aave/IAaveIncentivesController.sol\";\n\n/** @title YieldManagerAave\n  @notice contract is used to manage the yield generated by the underlying tokens. \n  YieldManagerAave is an implementation of a yield manager that earns APY from the Aave protocol. \n  Each fund's payment token (such as DAI) has a corresponding aToken (such as aDAI) that \n  continuously accrues interest based on a lend/borrow liquidity ratio.\n  @dev https://docs.aave.com/portal/\n  */\ncontract YieldManagerAave is IYieldManager {\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          VARIABLES          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @notice address of longShort contract\n  address public longShort;\n  /// @notice address of treasury contract - this is the address that can claim aave incentives rewards\n  address public treasury;\n\n  /// @notice The payment token the yield manager supports\n  /// @dev DAI token\n  ERC20 public paymentToken;\n  /// @notice The token representing the interest accruing payment token position from Aave\n  /// @dev ADAI token\n  IERC20Upgradeable public aToken;\n  /// @notice The specific Aave lending pool contract\n  ILendingPool public lendingPool;\n  /// @notice The specific Aave incentives controller contract\n  IAaveIncentivesController public aaveIncentivesController;\n\n  /// @dev An aave specific referralCode that has been a depricated feature. This will be set to 0 for \"no referral\" at deployment\n  uint16 referralCode;\n\n  /// @notice distributed yield not yet transferred to the treasury\n  uint256 public override totalReservedForTreasury;\n\n  /// @dev This value will likely remain zero forever. It exists to handle the rare edge case that Aave doesn't have enough liquidity for a withdrawal.\n  ///      In this case this variable would keep track of that so that the withdrawal can happen after the fact when liquidity becomes available.\n  uint256 public amountReservedInCaseOfInsufficientAaveLiquidity;\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           EVENTS            \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  event ClaimAaveRewardTokenToTreasury(uint256 amount);\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551          MODIFIERS          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /// @dev only allow longShort contract to execute modified functions\n  modifier longShortOnly() {\n    require(msg.sender == longShort, \"Not longShort\");\n    _;\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551       CONTRACT SET-UP       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /** \n    @notice Constructor for initializing the aave yield manager with a given payment token and corresponding Aave contracts\n    @param _longShort address of the longShort contract\n    @param _treasury address of the treasury contract\n    @param _paymentToken address of the payment token\n    @param _aToken address of the interest accruing token linked to the payment token\n    @param _lendingPool address of the aave lending pool contract\n    @param _aaveReferralCode unique code for aave referrals\n    @dev referral code will be set to 0, depricated Aave feature\n  */\n  constructor(\n    address _longShort,\n    address _treasury,\n    address _paymentToken,\n    address _aToken,\n    address _lendingPool,\n    address _aaveIncentivesController,\n    uint16 _aaveReferralCode\n  ) {\n    longShort = _longShort;\n    treasury = _treasury;\n\n    referralCode = _aaveReferralCode;\n\n    paymentToken = ERC20(_paymentToken);\n    aToken = IERC20Upgradeable(_aToken);\n    lendingPool = ILendingPool(_lendingPool);\n    aaveIncentivesController = IAaveIncentivesController(_aaveIncentivesController);\n\n    // Approve tokens for aave lending pool maximally.\n    paymentToken.approve(address(lendingPool), type(uint256).max);\n  }\n\n  /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551     IMPLEMENTATION     \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n  /** \n   @notice Allows the LongShort contract to deposit tokens into the aave pool\n   @param amount Amount of payment token to deposit\n  */\n  function depositPaymentToken(uint256 amount) external override longShortOnly {\n    // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount\n    //    It basically always be zero besides extreme and unlikely situations with aave.\n    if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {\n      if (amountReservedInCaseOfInsufficientAaveLiquidity > amount) {\n        amountReservedInCaseOfInsufficientAaveLiquidity -= amount;\n        // Return early, nothing to deposit into the lending pool\n        return;\n      } else {\n        amount -= amountReservedInCaseOfInsufficientAaveLiquidity;\n        amountReservedInCaseOfInsufficientAaveLiquidity = 0;\n      }\n    }\n\n    lendingPool.deposit(address(paymentToken), amount, address(this), referralCode);\n  }\n\n  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Aave\n  /// @param user User to recieve the payout\n  /// @param amount Amount of payment token to pay to user\n  function transferPaymentTokensToUser(address user, uint256 amount) external override longShortOnly {\n    try paymentToken.transfer(user, amount) returns (bool transferSuccess) {\n      if (transferSuccess) {\n        // If the transfer is successful return early, otherwise try pay the user out with the amountReservedInCaseOfInsufficientAaveLiquidity\n        return;\n      }\n    } catch {}\n\n    amountReservedInCaseOfInsufficientAaveLiquidity -= amount;\n\n    // If this reverts (ie aave unable to make payout), then the whole transaction will revent. User will have to wait until sufficient liquidity available.\n    lendingPool.withdraw(address(paymentToken), amount, user);\n  }\n\n  /// @notice Allows the LongShort contract to redeem aTokens for the payment token\n  /// @param amount Amount of payment token to withdraw\n  /// @dev This will update the amountReservedInCaseOfInsufficientAaveLiquidity if not enough liquidity is avaiable on aave.\n  ///      This means that our system can continue to operate even if there is insufficient liquidity in Aave for any reason.\n  function removePaymentTokenFromMarket(uint256 amount) external override longShortOnly {\n    try lendingPool.withdraw(address(paymentToken), amount, address(this)) {} catch {\n      // In theory we should only catch `VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH` errors.\n      // Safe to revert on all errors, if aave completely blocks withdrawals the amountReservedInCaseOfInsufficientAaveLiquidity can grow until it is fixed without problems.\n      amountReservedInCaseOfInsufficientAaveLiquidity += amount;\n    }\n  }\n\n  /**  \n    @notice Allows for withdrawal of aave rewards to the treasury contract    \n    @dev This is specifically implemented to allow withdrawal of aave reward wMatic tokens accrued    \n  */\n  function claimAaveRewardsToTreasury() external {\n    uint256 amount = IAaveIncentivesController(aaveIncentivesController).getUserUnclaimedRewards(address(this));\n\n    address[] memory rewardsDepositedAssets = new address[](1);\n    rewardsDepositedAssets[0] = address(paymentToken);\n\n    IAaveIncentivesController(aaveIncentivesController).claimRewards(rewardsDepositedAssets, amount, treasury);\n\n    emit ClaimAaveRewardTokenToTreasury(amount);\n  }\n\n  /**    \n    @notice Calculates and updates the yield allocation to the treasury and the market\n    @dev treasuryPercent = 1 - marketPercent\n    @param totalValueRealizedForMarket total value of long and short side of the market\n    @param treasuryYieldPercent_e18 Percentage of yield in base 1e18 that is allocated to the treasury\n    @return The market allocation of the yield\n  */\n  function distributeYieldForTreasuryAndReturnMarketAllocation(\n    uint256 totalValueRealizedForMarket,\n    uint256 treasuryYieldPercent_e18\n  ) external override longShortOnly returns (uint256) {\n    uint256 totalHeld = aToken.balanceOf(address(this));\n\n    uint256 totalRealized = totalValueRealizedForMarket +\n      totalReservedForTreasury +\n      amountReservedInCaseOfInsufficientAaveLiquidity;\n\n    if (totalRealized == totalHeld) {\n      return 0;\n    }\n\n    // will revert in case totalRealized > totalHeld which should be never.\n    uint256 unrealizedYield = totalHeld - totalRealized;\n\n    uint256 amountForTreasury = (unrealizedYield * treasuryYieldPercent_e18) / 1e18;\n    uint256 amountForMarketIncentives = unrealizedYield - amountForTreasury;\n\n    totalReservedForTreasury += amountForTreasury;\n\n    emit YieldDistributed(unrealizedYield, treasuryYieldPercent_e18);\n\n    return amountForMarketIncentives;\n  }\n\n  /// @notice Withdraw treasury allocated accrued yield from the lending pool to the treasury contract\n  function withdrawTreasuryFunds() external override {\n    uint256 amountToWithdrawForTreasury = totalReservedForTreasury;\n    totalReservedForTreasury = 0;\n\n    // Redeem aToken for payment tokens.\n    lendingPool.withdraw(address(paymentToken), amountToWithdrawForTreasury, treasury);\n\n    emit WithdrawTreasuryFunds();\n  }\n}\n\n\n",
        "CodeNames": [
            "YieldManagerAave.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "claimRewards"
                ],
                "Type": " Wrong aave usage of  claimRewards ",
                "Description": "\nAave yield manager claims rewards with the payment token. According to aave's document, aToken should be provided.\nThe aave rewards would be unclaimable.\n\nYieldManager's logic in L161-L170(https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L161-L170)\n\nReference: https://docs.aave.com/developers/guides/liquidity-mining#claimrewards\n\n",
                "Repair": "Recommend changing to\nsolidity\n  address[] memory rewardsDepositedAssets = new address[(1);\n  rewardsDepositedAssets[0] = address(aToken);\n\n\nDenhamPreen (Float) confirmed(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49#issuecomment-896811177):\n  Great catch!\n\n This contract is going to be upgradable but really applicable within this context \ud83d\udc4d\n\nmoose-code (Float) commented(https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49#issuecomment-896845365):\n  Oof yeah! Good one :)\n\n Devil in those documentation details :)\n\n ![image(https://user-images.githubusercontent.com/20556729/129041188-b712e09a-f735-44d4-922f-328b156e2461.png)\n\n\n"
            }
        ]
    }
]