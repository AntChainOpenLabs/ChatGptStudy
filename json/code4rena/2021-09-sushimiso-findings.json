[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n/\n * @notice Finalizes Token sale and launches LP.\n * @return liquidity Number of LPs.\n */\nfunction finalize() external nonReentrant returns (uint256 liquidity) {\n    // GP: Can we remove admin, let anyone can finalise and launch?\n    // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n    require(marketConnected(), \"PostAuction: Auction must have this launcher address set as the destination wallet\");\n    require(!launcherInfo.launched);\n\n    if (!market.finalized()) {\n        market.finalize();\n    }\n    require(market.finalized());\n\n    launcherInfo.launched = true;\n    if (!market.auctionSuccessful() ) {\n        return 0;\n    }\n\n    /// @dev if the auction is settled in weth, wrap any contract balance \n    uint256 launcherBalance = address(this).balance;\n    if (launcherBalance  0 ) {\n        IWETH(weth).deposit{value : launcherBalance}();\n    }\n    \n    (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();\n\n    /// @dev cannot start a liquidity pool with no tokens on either side\n    if (token1Amount == 0 || token2Amount == 0 ) {\n        return 0;\n    }\n\n    address pair = factory.getPair(address(token1), address(token2));\n    if(pair == address(0)) {\n        createPool();\n    }\n\n    /// @dev add liquidity to pool via the pair directly\n    _safeTransfer(address(token1), tokenPair, token1Amount);\n    _safeTransfer(address(token2), tokenPair, token2Amount);\n    liquidity = IUniswapV2Pair(tokenPair).mint(address(this));\n    launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));\n\n    /// @dev if unlock time not yet set, add it.\n    if (launcherInfo.unlock == 0 ) {\n        launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));\n    }\n    emit LiquidityAdded(liquidity);\n}\n",
                    "//solidity\nliquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n"
                ],
                "Type": "  PostAuctionLauncher.sol#finalize()  Adding liquidity to an existing pool may allows the attacker to steal most of the tokens",
                "Description": "\nPostAuctionLauncher.finalize() can be called by anyone, and it sends tokens directly to the pair pool to mint liquidity, even when the pair pool exists.\n\nAn attacker may control the LP price by creating the pool and then call finalize() to mint LP token with unfair price (pay huge amounts of tokens and get few amounts of LP token), and then remove the initial liquidity they acquired when creating the pool and take out huge amounts of tokens.\n\n<https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L257\n\nsolidity\n/\n * @notice Finalizes Token sale and launches LP.\n * @return liquidity Number of LPs.\n */\nfunction finalize() external nonReentrant returns (uint256 liquidity) {\n    // GP: Can we remove admin, let anyone can finalise and launch?\n    // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n    require(marketConnected(), \"PostAuction: Auction must have this launcher address set as the destination wallet\");\n    require(!launcherInfo.launched);\n\n    if (!market.finalized()) {\n        market.finalize();\n    }\n    require(market.finalized());\n\n    launcherInfo.launched = true;\n    if (!market.auctionSuccessful() ) {\n        return 0;\n    }\n\n    /// @dev if the auction is settled in weth, wrap any contract balance \n    uint256 launcherBalance = address(this).balance;\n    if (launcherBalance  0 ) {\n        IWETH(weth).deposit{value : launcherBalance}();\n    }\n    \n    (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();\n\n    /// @dev cannot start a liquidity pool with no tokens on either side\n    if (token1Amount == 0 || token2Amount == 0 ) {\n        return 0;\n    }\n\n    address pair = factory.getPair(address(token1), address(token2));\n    if(pair == address(0)) {\n        createPool();\n    }\n\n    /// @dev add liquidity to pool via the pair directly\n    _safeTransfer(address(token1), tokenPair, token1Amount);\n    _safeTransfer(address(token2), tokenPair, token2Amount);\n    liquidity = IUniswapV2Pair(tokenPair).mint(address(this));\n    launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));\n\n    /// @dev if unlock time not yet set, add it.\n    if (launcherInfo.unlock == 0 ) {\n        launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));\n    }\n    emit LiquidityAdded(liquidity);\n}\n\n\nIn line 257, PostAuctionLauncher will mint LP with token1Amount and token2Amount. The amounts (token1Amount and token2Amount) are computed according to the auction result, without considering the current price (reserves) of the existing tokenPair.\n\nSee PostAuctionLauncher.getTokenAmounts()(https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L268)\n\nPostAuctionLauncher will receive an unfairly low amount of lp token because the amounts sent to tokenPair didn't match the current price of the pair.\n\nSee UniswapV2Pair.mint(...)(https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/UniswapV2/UniswapV2Pair.sol#L135)\n\nsolidity\nliquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n\n\n\nLose a majority share of the tokens.\n\n\n1.  The attacker creates LP with 0.0000001 token1 and 1000 token2, receives 0.01 LP token;\n2.  Call PostAuctionLauncher.finalize(). PostAuctionLauncher will mint liquidity with 2000 token1 and 1000 token2 for example, receives only  0.01 LP token;\n3.  The attacker removes all his LP, receives 1000 token1 (most of which come from PostAuctionLauncher).\n\n",
                "Repair": "\nTo only support tokenPair created by PostAuctionLauncher or check for the token price before mint liquidity.\n\nClearwood (Sushi Miso) confirmed and patched(https://github.com/code-423n4/2021-09-sushimiso-findings/issues/14#issuecomment-934641852):\n  https://github.com/sushiswap/miso/pull/21\n\n\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [],
                "Type": " SushiToken transfers are broken due to wrong delegates accounting on transfers",
                "Description": "\nWhen minting / transferring / burning tokens, the SushiToken._beforeTokenTransfer function is called and supposed to correctly shift the voting power due to the increase/decrease in tokens for the from and to accounts.\nHowever, it does not correctly do that, it tries to shift the votes from the from account, instead of the _delegates[from] account.\nThis can lead to transfers reverting.\n\n\nImagine the following transactions on the SushiToken contract.\nWe'll illustrate the corresponding _moveDelegates calls and written checkpoints for each.\n\n*   mint(A, 1000) = transfer(0, A, 1000) =  _moveDelegates(0, delegates[A]=0)   = no checkpoints are written to anyone because delegatees are still zero\n*   A delegates to A' = _moveDelegates(0, A') = writeCheckpoint(A', 1000)\n*   B delegates to B' = no checkpoints are written as B has a zero balance\n*   transfer(A, B, 1000) = _moveDelegates(A, delegates[B] = B') = underflows when subtracting amount=1000 from A's non-existent checkpoint (defaults to 0 votes)\n\nIt should subtract from A's delegatee A''s checkpoint instead.\n\n\nUsers that delegated votes will be unable to transfer any of their tokens.\n\n",
                "Repair": "\nIn SushiToken._beforeTokenTransfer, change the _moveDelegates call to be from _delegates[from] instead:\n\nsolidity\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal override { \n    _moveDelegates(_delegates[from], _delegates[to], amount);\n    super._beforeTokenTransfer(from, to, amount);\n}\n\n\nThis is also how the original code from Compound(https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol#L241) does it.\n\nmaxsam4 (Sushi Miso) acknowledged(https://github.com/code-423n4/2021-09-sushimiso-findings/issues/117#issuecomment-920570459):\n  This is a known issue in Sushi token but was kept unchanged in MISO for \"preservation of history :)\". That was not necessarily a wise choice lol. I think 1 severity should be fine for this as this was an intentional thing. The delegate feature is not supposed to be used in these tokens. We might create a new token type with this bug fixed.\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-09-sushimiso-findings/issues/117#issuecomment-934637612):\n  We have crazy wallets on the blockchain that will call every possible function available to them and that's why I'm keeping this as is. Even intentional, the issue stands so the warden should get credit for it.\n\n\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "js\n function finalize() public nonReentrant {\n        require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender) || finalizeTimeExpired(),\"Crowdsale: sender must be an admin\"); // can be called by admin\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"Crowdsale: already finalized\");\n        MarketInfo storage info = marketInfo;\n        require(auctionEnded(), \"Crowdsale: Has not finished yet\");    // is true if enough sold, even if this is before marketInfo.endTime\n\n        if (auctionSuccessful()) {          \n            /// @dev Transfer contributed tokens to wallet.\n            /// @dev Transfer unsold tokens to wallet.\n        } else {\n            /// @dev Return auction tokens back to wallet.\n        }\n        status.finalized = true;\n\nfunction auctionEnded() public view returns (bool) {\n        return block.timestamp  uint256(marketInfo.endTime) || \n        _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) = uint256(marketInfo.totalTokens); // is true if enough sold, even if this is before marketInfo.endTime\n    }\n\nfunction auctionSuccessful() public view returns (bool) {\n        return uint256(marketStatus.commitmentsTotal) = uint256(marketPrice.goal);\n}\n\nfunction commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement ) public payable nonReentrant  {\n       ...\n        uint256 ethToTransfer = calculateCommitment(msg.value);\n       ...\n       _addCommitment(_beneficiary, ethToTransfer);\n   \n function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) { // this prevents buying too much\n        uint256 tokens = _getTokenAmount(_commitment);\n        uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));\n        if ( tokensCommited.add(tokens)  uint256(marketInfo.totalTokens)) {\n            return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));\n        }\n        return _commitment;\n    }\n\nfunction _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp = uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"Crowdsale: outside auction hours\"); // doesn't check auctionEnded() nor status.finalized\n        ...\n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        ...\n        commitments[_addr] = newCommitment;\n\nfunction withdrawTokens(address payable beneficiary) public   nonReentrant  {    \n        if (auctionSuccessful()) {\n            ...\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            ...\n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);    // will fail is last token is missing\n        } else {\n\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nIn the function _addCommitment, add a check on auctionEnded() or status.finalized\n"
                ],
                "Type": " Last person to withdraw his tokens might not be able to do this, in Crowdsale (edge case)",
                "Description": "\n\nSuppose a Crowdsale is successful and enough commitments are made before the marketInfo.endTime.\nSuppose marketStatus.commitmentsTotal  == marketInfo.totalTokens -1      // note this is an edge case, but can be constructed by an attacker\nThen the function auctionEnded() returns true\nAssume auctionSuccessful() is also true (might depend on the config of marketPrice.goal and marketInfo.totalTokens)\nThen an admin can call finalize() to finalize the Crowdsale.\nThe function finalize distributes the funds and the unsold tokens and sets status.finalized = true so that finalized cannot be called again.\nNow we have \"marketInfo.totalTokens -1\" tokens left in the contract\n\nHowever commitEth() or commitTokens() can still be called (they give no error message that the auction has ended)\nThen functions call calculateCommitment, which luckily prevent from buying too much, however 1 token can still be bought\nThese functions also call _addCommitment(), which only checks for marketInfo.endTime, which hasn't passed yet.\n\nNow an extra token is sold and the contract has 1 token short. So the last person to withdraw his tokens cannot withdraw them (because you cannot specify how much you want to withdraw)\n\nAlso the revenues for the last token cannot be retrieved as finalize() cannot be called again.\n\n\n<https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374\n\njs\n function finalize() public nonReentrant {\n        require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender) || finalizeTimeExpired(),\"Crowdsale: sender must be an admin\"); // can be called by admin\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"Crowdsale: already finalized\");\n        MarketInfo storage info = marketInfo;\n        require(auctionEnded(), \"Crowdsale: Has not finished yet\");    // is true if enough sold, even if this is before marketInfo.endTime\n\n        if (auctionSuccessful()) {          \n            /// @dev Transfer contributed tokens to wallet.\n            /// @dev Transfer unsold tokens to wallet.\n        } else {\n            /// @dev Return auction tokens back to wallet.\n        }\n        status.finalized = true;\n\nfunction auctionEnded() public view returns (bool) {\n        return block.timestamp  uint256(marketInfo.endTime) || \n        _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) = uint256(marketInfo.totalTokens); // is true if enough sold, even if this is before marketInfo.endTime\n    }\n\nfunction auctionSuccessful() public view returns (bool) {\n        return uint256(marketStatus.commitmentsTotal) = uint256(marketPrice.goal);\n}\n\nfunction commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement ) public payable nonReentrant  {\n       ...\n        uint256 ethToTransfer = calculateCommitment(msg.value);\n       ...\n       _addCommitment(_beneficiary, ethToTransfer);\n   \n function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) { // this prevents buying too much\n        uint256 tokens = _getTokenAmount(_commitment);\n        uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));\n        if ( tokensCommited.add(tokens)  uint256(marketInfo.totalTokens)) {\n            return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));\n        }\n        return _commitment;\n    }\n\nfunction _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp = uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"Crowdsale: outside auction hours\"); // doesn't check auctionEnded() nor status.finalized\n        ...\n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        ...\n        commitments[_addr] = newCommitment;\n\nfunction withdrawTokens(address payable beneficiary) public   nonReentrant  {    \n        if (auctionSuccessful()) {\n            ...\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            ...\n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);    // will fail is last token is missing\n        } else {\n\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nIn the function _addCommitment, add a check on auctionEnded() or status.finalized\n\n\nClearwood (Sushi Miso) confirmed and patched(https://github.com/code-423n4/2021-09-sushimiso-findings/issues/15#issuecomment-934641167):\n  https://github.com/sushiswap/miso/pull/20\n\n\n\n \n\n",
                "Repair": ""
            },
            {
                "Name": "M-01",
                "Location": [],
                "Type": " use of transfer() instead of call()  to send eth",
                "Description": "\n\nUse of transfer() might render ETH impossible to withdraw because after istanbul hardfork, there is an increase in the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.Those contracts will break because their fallback functions used to consume less than 2300 gas, and they\u2019ll now consume more, since 2300 the amount of gas a contract\u2019s fallback function receives if it\u2019s called via Solidity\u2019s transfer() or send() methods.\nAny smart contract that uses transfer() or send() is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.\n\n<https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n\n<https://blog.openzeppelin.com/opyn-gamma-protocol-audit/\n\n\n<https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/MISOTokenFactory.sol#L242\n\n<https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/MISOMarket.sol#L256\n\n<https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/MISOLauncher.sol#L251\n\n<https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/MISOFarmFactory.sol#L244\n\n\nmanual review\n\n",
                "Repair": "\nuse call() to send eth\n\nmaxsam4 (Sushi Miso) disputed and commented(https://github.com/code-423n4/2021-09-sushimiso-findings/issues/87#issuecomment-920589153):\n  This is intentional, not a risk. The contract does not want to give any gas stipend to the destination.\n \n Even if the user messes up, misoDev address can be changed to a proper address later.\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-09-sushimiso-findings/issues/87#issuecomment-934654221):\n  using .transfer can make ETH transfer to a smart contract impossible. User can always change the address however I agree with warden that this is an issue.\n\n\n\n \n\n"
            }
        ]
    }
]