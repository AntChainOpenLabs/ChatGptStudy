[
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Vm.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract stdCheats {\n    using stdStorage for StdStorage;\n\n    // we use custom names that are unlikely to cause collisions so this contract\n    // can be inherited easily\n    Vm constant vm_std_cheats = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n    StdStorage std_store_std_cheats;\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) public {\n        vm_std_cheats.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) public {\n        vm_std_cheats.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) public {\n        vm_std_cheats.deal(who, 1 << 128);\n        vm_std_cheats.prank(who);\n    }\n\n    function hoax(address who, uint256 give) public {\n        vm_std_cheats.deal(who, give);\n        vm_std_cheats.prank(who);\n    }\n\n    function hoax(address who, address origin) public {\n        vm_std_cheats.deal(who, 1 << 128);\n        vm_std_cheats.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) public {\n        vm_std_cheats.deal(who, give);\n        vm_std_cheats.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) public {\n        vm_std_cheats.deal(who, 1 << 128);\n        vm_std_cheats.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) public {\n        vm_std_cheats.deal(who, give);\n        vm_std_cheats.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) public {\n        vm_std_cheats.deal(who, 1 << 128);\n        vm_std_cheats.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) public {\n        vm_std_cheats.deal(who, give);\n        vm_std_cheats.startPrank(who, origin);\n    }\n\n    // Allows you to set the balance of an account for a majority of tokens\n    // Be careful not to break something!\n    function tip(address token, address to, uint256 give) public {\n        std_store_std_cheats\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // Deploys a contract by fetching the contract bytecode from\n    // the artifacts directory\n    function deployCode(string memory what, bytes memory args)\n        public\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm_std_cheats.getCode(what), args);\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n    }\n\n    function deployCode(string memory what)\n        public\n        returns (address addr)\n    {\n        bytes memory bytecode = vm_std_cheats.getCode(what);\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n    }\n}\n\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n    \n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n    \n    Vm constant stdstore_vm = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    ) \n        internal \n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        stdstore_vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        \n        (bytes32[] memory reads, ) = stdstore_vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = stdstore_vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"Packed slot. This would cause dangerous overwriting and currently isnt supported\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = stdstore_vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                stdstore_vm.store(who, reads[i], bytes32(hex\"1337\"));\n                {\n                    (, bytes memory rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n                \n                if (fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    stdstore_vm.store(who, reads[i], prev);\n                    break;\n                }\n                stdstore_vm.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"No storage use detected for target\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"NotFound\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth; \n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = stdstore_vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"Packed slot. This would cause dangerous overwriting and currently isnt supported\");\n        }\n        stdstore_vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth; \n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        for (uint i = 0; i < 32; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\n",
        "CodeNames": [
            "stdlib.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "balance()"
                ],
                "Type": " StakedCitadel doesn't use correct balance for internal accounting",
                "Description": "\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L772-L776\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L893\n\n\nThe StakedCitadel contract's balance() function is supposed to return the balance of the vault + the balance of the strategy. But, it only returns the balance of the vault. The balance is used to determine the number of shares that should be minted when depositing funds into the vault and the number of shares that should be burned when withdrawing funds from it.\n\nSince most of the funds will be located in the strategy, the vault's balance will be very low. Some of the issues that arise from this:\n\nYou can't deposit to a vault that already minted shares but has no balance of the underlying token:\n\n1.  fresh vault with 0 funds and 0 shares\n2.  Alice deposits 10 tokens. She receives 10 shares back (<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888)\n3.  Vault's tokens are deposited into the strategy (now balance == 0 and totalSupply == 10)\n4.  Bob tries to deposit but the transaction fails because the contract tries to divide by zero: <https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890 (pool == balance())\n\nYou get more shares than you should\n\n1.  fresh vault with 0 funds and 0 shares\n2.  Alice deposits 10 tokens. She receives 10 shares back (<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888)\n3.  Vault's tokens are deposited into the strategy (now balance == 0 and totalSupply == 10)\n4.  Bob now first transfers 1 token to the vault so that the balance is now 1 instead of 0.\n5.  Bob deposits 5 tokens. He receives 5 * 10 / 1 == 50 shares: <https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890\n\nNow, the vault received 15 tokens. 10 from Alice and 5 from Bob. But Alice only has 10 shares while Bob has 50. Thus, Bob can withdraw more tokens than he should be able to.\n\nIt simply breaks the whole accounting of the vault.\n\n\nThe comment says that it should be vault's + strategy's balance:\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295\n\nHere's another vault from the badger team where the function is implemented correctly: <https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262\n\n",
                "Repair": "\nAdd the strategy's balance to the return value of thebalance() function like here(https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262).\n\nGalloDaSballo (BadgerDAO) confirmed and commented(https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/74#issuecomment-1107163426):\n  Agree balance must have been changed by mistake or perhaps earn should not transfer to a strategy either would work\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/SettAccessControl.sol\";\n\nimport {IVault} from \"./interfaces/badger/IVault.sol\";\nimport {IVesting} from \"./interfaces/citadel/IVesting.sol\";\nimport {IStrategy} from \"./interfaces/badger/IStrategy.sol\";\nimport {IERC20} from \"./interfaces/erc20/IERC20.sol\";\nimport {IBadgerGuestlist} from \"./interfaces/badger/IBadgerGuestlist.sol\";\n\n/*\n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n\n    V1.3\n    * Add guest list functionality\n    * All deposits can be optionally gated by external guestList approval logic on set guestList contract\n\n    V1.4\n    * Add depositFor() to deposit on the half of other users. That user will then be blockLocked.\n\n    V1.5\n    * Removed Controller\n        - Removed harvest from vault (only on strategy)\n    * Params added to track autocompounded rewards (lifeTimeEarned, lastHarvestedAt, lastHarvestAmount, assetsAtLastHarvest)\n      this would work in sync with autoCompoundRatio to help us track harvests better.\n    * Fees\n        - Strategy would report the autocompounded harvest amount to the vault\n        - Calculation performanceFeeGovernance, performanceFeeStrategist, withdrawalFee, managementFee moved to the vault.\n        - Vault mints shares for performanceFees and managementFee to the respective recipient (treasury, strategist)\n        - withdrawal fees is transferred to the rewards address set\n    * Permission:\n        - Strategist can now set performance, withdrawal and management fees\n        - Governance will determine maxPerformanceFee, maxWithdrawalFee, maxManagementFee that can be set to prevent rug of funds.\n    * Strategy would take the actors from the vault it is connected to\n    * All governance related fees goes to treasury\n*/\n\ncontract StakedCitadel is\n    ERC20Upgradeable,\n    SettAccessControl,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    uint256 constant ONE_ETH = 1e18;\n\n    /// ===== Storage Variables ====\n\n    IERC20Upgradeable public token; // Token used for deposits\n    IBadgerGuestlist public guestList; // guestlist when vault is in experiment/ guarded state\n\n    bool public pausedDeposit; // false by default Allows to only block deposits, use pause for the normal pause state\n\n    address public strategy; // address of the strategy connected to the vault\n    address public guardian; // guardian of vault and strategy\n    address public treasury; // set by governance ... any fees go there\n\n    address public badgerTree; // Address we send tokens too via reportAdditionalTokens\n    address public vesting; // Address of the vesting contract where after withdrawal we send CTDL to vest for 21 days\n\n    /// @dev name and symbol prefixes for lpcomponent token of vault\n    string internal constant _defaultNamePrefix = \"Staked \";\n    string internal constant _symbolSymbolPrefix = \"x\";\n\n    /// Params to track autocompounded rewards\n    uint256 public lifeTimeEarned; // keeps track of total earnings\n    uint256 public lastHarvestedAt; // timestamp of the last harvest\n    uint256 public lastHarvestAmount; // amount harvested during last harvest\n    uint256 public assetsAtLastHarvest; // assets for which the harvest took place.\n\n    mapping(address => uint256) public additionalTokensEarned;\n    mapping(address => uint256) public lastAdditionalTokenAmount;\n\n    /// Fees ///\n    /// @notice all fees will be in bps\n    uint256 public performanceFeeGovernance; // Perf fee sent to `treasury`\n    uint256 public performanceFeeStrategist; // Perf fee sent to `strategist`\n    uint256 public withdrawalFee; // fee issued to `treasury` on withdrawal\n    uint256 public managementFee; // fee issued to `treasury` on report (typically on harvest, but only if strat is autocompounding)\n\n    uint256 public maxPerformanceFee; // maximum allowed performance fees\n    uint256 public maxWithdrawalFee; // maximum allowed withdrawal fees\n    uint256 public maxManagementFee; // maximum allowed management fees\n\n    uint256 public toEarnBps; // NOTE: in BPS, minimum amount of token to deposit into strategy when earn is called\n\n    /// ===== Constants ====\n\n    uint256 public constant MAX_BPS = 10_000;\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    uint256 public constant WITHDRAWAL_FEE_HARD_CAP = 200; // Never higher than 2%\n    uint256 public constant PERFORMANCE_FEE_HARD_CAP = 3_000; // Never higher than 30% // 30% maximum performance fee // We usually do 20, so this is insanely high already\n    uint256 public constant MANAGEMENT_FEE_HARD_CAP = 200; // Never higher than 2%\n\n    /// ===== Events ====\n\n    // Emitted when a token is sent to the badgerTree for emissions\n    event TreeDistribution(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    // Emitted during a report, when there has been an increase in pricePerFullShare (ppfs)\n    event Harvested(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    event SetTreasury(address indexed newTreasury);\n    event SetStrategy(address indexed newStrategy);\n    event SetToEarnBps(uint256 newEarnToBps);\n    event SetMaxWithdrawalFee(uint256 newMaxWithdrawalFee);\n    event SetMaxPerformanceFee(uint256 newMaxPerformanceFee);\n    event SetMaxManagementFee(uint256 newMaxManagementFee);\n    event SetGuardian(address indexed newGuardian);\n    event SetVesting(address indexed newVesting);\n    event SetGuestList(address indexed newGuestList);\n    event SetWithdrawalFee(uint256 newWithdrawalFee);\n    event SetPerformanceFeeStrategist(uint256 newPerformanceFeeStrategist);\n    event SetPerformanceFeeGovernance(uint256 newPerformanceFeeGovernance);\n    event SetManagementFee(uint256 newManagementFee);\n\n    event PauseDeposits(address indexed pausedBy);\n    event UnpauseDeposits(address indexed pausedBy);\n\n    /// @notice Initializes the Sett. Can only be called once, ideally when the contract is deployed.\n    /// @param _token Address of the token that can be deposited into the sett.\n    /// @param _governance Address authorized as governance.\n    /// @param _keeper Address authorized as keeper.\n    /// @param _guardian Address authorized as guardian.\n    /// @param _treasury Address to distribute governance fees/rewards to.\n    /// @param _strategist Address authorized as strategist.\n    /// @param _badgerTree Address of badgerTree used for emissions.\n    /// @param _name Specify a custom sett name. Leave empty for default value.\n    /// @param _symbol Specify a custom sett symbol. Leave empty for default value.\n    /// @param _feeConfig Values for the 4 different types of fees charges by the sett\n    ///         [performanceFeeGovernance, performanceFeeStrategist, withdrawToVault, managementFee]\n    ///         Each fee should be less than the constant hard-caps defined above.\n    function initialize(\n        address _token,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        address _treasury,\n        address _strategist,\n        address _badgerTree,\n        address _vesting,\n        string memory _name,\n        string memory _symbol,\n        uint256[4] memory _feeConfig\n    ) public initializer whenNotPaused {\n        require(_token != address(0)); // dev: _token address should not be zero\n        require(_governance != address(0)); // dev: _governance address should not be zero\n        require(_keeper != address(0)); // dev: _keeper address should not be zero\n        require(_guardian != address(0)); // dev: _guardian address should not be zero\n        require(_treasury != address(0)); // dev: _treasury address should not be zero\n        require(_strategist != address(0)); // dev: _strategist address should not be zero\n        require(_badgerTree != address(0)); // dev: _badgerTree address should not be zero\n        require(_vesting != address(0)); // dev: _vesting address should not be zero\n\n        // Check for fees being reasonable (see below for interpretation)\n        require(\n            _feeConfig[0] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeGovernance too high\"\n        );\n        require(\n            _feeConfig[1] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n        require(\n            _feeConfig[2] <= WITHDRAWAL_FEE_HARD_CAP,\n            \"withdrawalFee too high\"\n        );\n        require(\n            _feeConfig[3] <= MANAGEMENT_FEE_HARD_CAP,\n            \"managementFee too high\"\n        );\n\n        string memory name;\n        string memory symbol;\n\n        // If they are non empty string we'll use the custom names\n        // Else just add the default prefix\n        IERC20 namedToken = IERC20(_token);\n\n        if (keccak256(abi.encodePacked(_name)) != keccak256(\"\")) {\n            name = _name;\n        } else {\n            name = string(\n                abi.encodePacked(_defaultNamePrefix, namedToken.name())\n            );\n        }\n\n        if (keccak256(abi.encodePacked(_symbol)) != keccak256(\"\")) {\n            symbol = _symbol;\n        } else {\n            symbol = string(\n                abi.encodePacked(_symbolSymbolPrefix, namedToken.symbol())\n            );\n        }\n\n        // Initializing the lpcomponent token\n        __ERC20_init(name, symbol);\n        // Initialize the other contracts\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        treasury = _treasury;\n        strategist = _strategist;\n        keeper = _keeper;\n        guardian = _guardian;\n        badgerTree = _badgerTree;\n        vesting = _vesting;\n\n        lastHarvestedAt = block.timestamp; // setting initial value to the time when the vault was deployed\n\n        performanceFeeGovernance = _feeConfig[0];\n        performanceFeeStrategist = _feeConfig[1];\n        withdrawalFee = _feeConfig[2];\n        managementFee = _feeConfig[3];\n        maxPerformanceFee = PERFORMANCE_FEE_HARD_CAP; // 30% max performance fee\n        maxWithdrawalFee = WITHDRAWAL_FEE_HARD_CAP; // 2% maximum withdrawal fee\n        maxManagementFee = MANAGEMENT_FEE_HARD_CAP; // 2% maximum management fee\n\n        toEarnBps = 9_500; // initial value of toEarnBps // 95% is invested to the strategy, 5% for cheap withdrawals\n    }\n\n    /// ===== Modifiers ====\n\n    /// @notice Checks whether a call is from guardian or governance.\n    function _onlyAuthorizedPausers() internal view {\n        require(\n            msg.sender == guardian || msg.sender == governance,\n            \"onlyPausers\"\n        );\n    }\n\n    /// @notice Checks whether a call is from the strategy.\n    function _onlyStrategy() internal view {\n        require(msg.sender == strategy, \"onlyStrategy\");\n    }\n\n    /// ===== View Functions =====\n\n    /// @notice Used to track the deployed version of the contract.\n    /// @return Current version of the contract.\n    function version() external pure returns (string memory) {\n        return \"1.5\";\n    }\n\n    /// @notice Gives the price for a single Sett share.\n    /// @dev Sett starts with a price per share of 1.\n    /// @return Value of a single share.\n    function getPricePerFullShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return ONE_ETH;\n        }\n        return (balance() * ONE_ETH) / totalSupply();\n    }\n\n    /// @notice Gives the total balance of the underlying token within the sett and strategy system.\n    /// @return Balance of token handled by the sett.\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Defines how much of the Setts' underlying is available for strategy to borrow.\n    /// @return Amount of tokens that the sett can provide to the strategy.\n    function available() public view returns (uint256) {\n        return (token.balanceOf(address(this)) * toEarnBps) / MAX_BPS;\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _amount Quantity of tokens to deposit.\n    function deposit(uint256 _amount) external whenNotPaused {\n        _depositWithAuthorization(_amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling account is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _amount Quantity of tokens to deposit.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function deposit(uint256 _amount, bytes32[] memory proof)\n        external\n        whenNotPaused\n    {\n        _depositWithAuthorization(_amount, proof);\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    function depositAll() external whenNotPaused {\n        _depositWithAuthorization(\n            token.balanceOf(msg.sender),\n            new bytes32[](0)\n        );\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling is authorized to make a full deposit.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function depositAll(bytes32[] memory proof) external whenNotPaused {\n        _depositWithAuthorization(token.balanceOf(msg.sender), proof);\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(address _recipient, uint256 _amount)\n        external\n        whenNotPaused\n    {\n        _depositForWithAuthorization(_recipient, _amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Checks the guestlist to verify that `recipient` is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) external whenNotPaused {\n        _depositForWithAuthorization(_recipient, _amount, proof);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    /// @param _shares Quantity of shares to redeem.\n    function withdraw(uint256 _shares) external whenNotPaused {\n        _withdraw(_shares);\n    }\n\n    /// @notice Redeems all shares, issuing an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    function withdrawAll() external whenNotPaused {\n        _withdraw(balanceOf(msg.sender));\n    }\n\n    /// ===== Permissioned Actions: Strategy =====\n\n    /// @notice Used by the strategy to report a harvest to the sett.\n    ///         Issues shares for the strategist and treasury based on the performance fees and harvested amount.\n    ///         Issues shares for the treasury based on the management fee and the time elapsed since last harvest.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This implicitly trusts that the strategy reports the correct amount.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _harvestedAmount Amount of underlying token harvested by the strategy.\n    function reportHarvest(uint256 _harvestedAmount) external nonReentrant {\n        _onlyStrategy();\n\n        uint256 harvestTime = block.timestamp;\n        uint256 assetsAtHarvest = balance() - _harvestedAmount; // Must be less than or equal or revert\n\n        _handleFees(_harvestedAmount, harvestTime);\n\n        // Updated lastHarvestAmount\n        lastHarvestAmount = _harvestedAmount;\n\n        // if we withdrawAll\n        // we will have some yield left\n        // having 0 for assets will inflate APY\n        // Instead, have the last harvest report with the previous assets\n        // And if you end up harvesting again, that report will have both 0s\n        if (assetsAtHarvest != 0) {\n            assetsAtLastHarvest = assetsAtHarvest;\n        } else if (_harvestedAmount == 0) {\n            // If zero\n            assetsAtLastHarvest = 0;\n        }\n\n        lifeTimeEarned = lifeTimeEarned + _harvestedAmount;\n        // Update time either way\n        lastHarvestedAt = harvestTime;\n\n        emit Harvested(\n            address(token),\n            _harvestedAmount,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// @notice Used by the strategy to report harvest of additional tokens to the sett.\n    ///         Charges performance fees on the additional tokens and transfers fees to treasury and strategist.\n    ///         The remaining amount is sent to badgerTree for emissions.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This function is called after the strategy sends the additional tokens to the sett.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _token Address of additional token harvested by the strategy.\n    function reportAdditionalToken(address _token) external nonReentrant {\n        _onlyStrategy();\n        require(address(token) != _token, \"No want\");\n        uint256 tokenBalance = IERC20Upgradeable(_token).balanceOf(\n            address(this)\n        );\n\n        additionalTokensEarned[_token] =\n            additionalTokensEarned[_token] +\n            tokenBalance;\n        lastAdditionalTokenAmount[_token] = tokenBalance;\n\n        // We may have more, but we still report only what the strat sent\n        uint256 governanceRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeGovernance\n        );\n        uint256 strategistRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeStrategist\n        );\n\n        IERC20Upgradeable(_token).safeTransfer(treasury, governanceRewardsFee);\n        IERC20Upgradeable(_token).safeTransfer(\n            strategist,\n            strategistRewardsFee\n        );\n\n        // Send rest to tree\n        uint256 newBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n        IERC20Upgradeable(_token).safeTransfer(badgerTree, newBalance);\n        emit TreeDistribution(\n            _token,\n            newBalance,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n\n    /// @notice Changes the treasury address.\n    ///         Treasury is recipient of management and governance performance fees.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @param _treasury Address of the new treasury.\n    function setTreasury(address _treasury) external whenNotPaused {\n        _onlyGovernance();\n        require(_treasury != address(0), \"Address 0\");\n\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n    /// @notice Changes the strategy address.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @dev This is a rug vector, pay extremely close attention to the next strategy being set.\n    ///      Changing the strategy should happen only via timelock.\n    ///      This function must not be callable when the sett is paused as this would force depositors into a strategy they may not want to use.\n    /// @param _strategy Address of new strategy.\n    function setStrategy(address _strategy) external whenNotPaused {\n        _onlyGovernance();\n        require(_strategy != address(0), \"Address 0\");\n\n        /// NOTE: Migrate funds if settings strategy when already existing one\n        if (strategy != address(0)) {\n            require(\n                IStrategy(strategy).balanceOf() == 0,\n                \"Please withdrawToVault before changing strat\"\n            );\n        }\n        strategy = _strategy;\n        emit SetStrategy(_strategy);\n    }\n\n    // === Setters that can be called by governance even when paused ===\n\n    /// @notice Sets the max withdrawal fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `WITHDRAWAL_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for withdrawal fee.\n    function setMaxWithdrawalFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= WITHDRAWAL_FEE_HARD_CAP, \"withdrawalFee too high\");\n\n        maxWithdrawalFee = _fees;\n        emit SetMaxWithdrawalFee(_fees);\n    }\n\n    /// @notice Sets the max performance fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `PERFORMANCE_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for performance fee.\n    function setMaxPerformanceFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(\n            _fees <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n\n        maxPerformanceFee = _fees;\n        emit SetMaxPerformanceFee(_fees);\n    }\n\n    /// @notice Sets the max management fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `MANAGEMENT_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for management fee.\n    function setMaxManagementFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= MANAGEMENT_FEE_HARD_CAP, \"managementFee too high\");\n\n        maxManagementFee = _fees;\n        emit SetMaxManagementFee(_fees);\n    }\n\n    /// @notice Changes the guardian address.\n    ///         Guardian is an authorized actor that can pause the sett in case of an emergency.\n    ///         This can only be called by governance.\n    /// @param _guardian Address of the new guardian.\n    function setGuardian(address _guardian) external {\n        _onlyGovernance();\n        require(_guardian != address(0), \"Address cannot be 0x0\");\n\n        guardian = _guardian;\n        emit SetGuardian(_guardian);\n    }\n\n    /// @notice Changes the vesting contract address.\n    ///         Vesting contract is used to vest withdrawn tokens linearly over period of 21 days\n    ///         This can only be called by governance.\n    /// @param _vesting Address of the new guardian.\n    function setVesting(address _vesting) external {\n        _onlyGovernance();\n        require(_vesting != address(0), \"Address cannot be 0x0\");\n\n        vesting = _vesting;\n        emit SetVesting(_vesting);\n    }\n\n    /// ===== Permissioned Functions: Trusted Actors =====\n\n    /// @notice Sets the fraction of sett balance (in basis points) that the strategy can borrow.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _newToEarnBps The new maximum cap for management fee.\n    function setToEarnBps(uint256 _newToEarnBps) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_newToEarnBps <= MAX_BPS, \"toEarnBps should be <= MAX_BPS\");\n\n        toEarnBps = _newToEarnBps;\n        emit SetToEarnBps(_newToEarnBps);\n    }\n\n    /// @notice Changes the guestlist address.\n    ///         The guestList is used to gate or limit deposits. If no guestlist is set then anyone can deposit any amount.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _guestList Address of the new guestlist.\n    function setGuestList(address _guestList) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        guestList = IBadgerGuestlist(_guestList);\n        emit SetGuestList(_guestList);\n    }\n\n    /// @notice Sets the withdrawal fee charged by the Sett.\n    ///         The fee is taken at the time of withdrawals in the underlying token which is then used to issue new shares for the treasury.\n    ///         The new withdrawal fee should be less than `maxWithdrawalFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_withdraw` to see how withdrawal fee is charged.\n    /// @param _withdrawalFee The new withdrawal fee.\n    function setWithdrawalFee(uint256 _withdrawalFee) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_withdrawalFee <= maxWithdrawalFee, \"Excessive withdrawal fee\");\n        withdrawalFee = _withdrawalFee;\n        emit SetWithdrawalFee(_withdrawalFee);\n    }\n\n    /// @notice Sets the performance fee taken by the strategist on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the strategist.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeStrategist The new performance fee.\n    function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeStrategist <= maxPerformanceFee,\n            \"Excessive strategist performance fee\"\n        );\n        performanceFeeStrategist = _performanceFeeStrategist;\n        emit SetPerformanceFeeStrategist(_performanceFeeStrategist);\n    }\n\n    /// @notice Sets the performance fee taken by the treasury on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the treasury.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeGovernance The new performance fee.\n    function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeGovernance <= maxPerformanceFee,\n            \"Excessive governance performance fee\"\n        );\n        performanceFeeGovernance = _performanceFeeGovernance;\n        emit SetPerformanceFeeGovernance(_performanceFeeGovernance);\n    }\n\n    /// @notice Sets the management fee taken by the treasury on the AUM in the sett.\n    ///         The fee is calculated at the time of `reportHarvest` and is used to issue new shares for the treasury.\n    ///         The new management fee should be less than `maxManagementFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_handleFees` to see how the management fee is calculated.\n    /// @param _fees The new management fee.\n    function setManagementFee(uint256 _fees) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_fees <= maxManagementFee, \"Excessive management fee\");\n        managementFee = _fees;\n        emit SetManagementFee(_fees);\n    }\n\n    /// === Strategist level operations that can be done even when paused ==\n\n    /// @notice Withdraws all funds from the strategy back to the sett.\n    ///         This can be called by either governance or strategist.\n    /// @dev This calls `_withdrawAll` on the strategy and transfers the balance to the sett.\n    function withdrawToVault() external {\n        _onlyGovernanceOrStrategist();\n        IStrategy(strategy).withdrawToVault();\n    }\n\n    /// @notice Sends balance of any extra token earned by the strategy (from airdrops, donations etc.)\n    ///         to the badgerTree for emissions.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev See `BaseStrategy.emitNonProtectedToken` for details.\n    /// @param _token Address of the token to be emitted.\n    function emitNonProtectedToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n\n        IStrategy(strategy).emitNonProtectedToken(_token);\n    }\n\n    /// @notice Sweeps the balance of an extra token from the vault and strategy and sends it to governance.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev Sweeping doesn't take any fee.\n    /// @param _token Address of the token to be swept.\n    function sweepExtraToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n        require(address(token) != _token, \"No want\");\n\n        IStrategy(strategy).withdrawOther(_token);\n        // Send all `_token` we have\n        // Safe because `withdrawOther` will revert on protected tokens\n        // Done this way works for both a donation to strategy or to vault\n        IERC20Upgradeable(_token).safeTransfer(\n            governance,\n            IERC20Upgradeable(_token).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Deposits the available balance of the underlying token into the strategy.\n    ///         The strategy then uses the amount for yield-generating activities.\n    ///         This can be called by either the keeper or governance.\n    ///         Note that earn cannot be called when deposits are paused.\n    /// @dev Pause is enforced at the Strategy level (this allows to still earn yield when the Vault is paused)\n    function earn() external {\n        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused, we don't earn as well\n        _onlyAuthorizedActors();\n\n        uint256 _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).earn();\n    }\n\n    /// @notice Pauses only deposits.\n    ///         This can be called by either guardian or governance.\n    function pauseDeposits() external {\n        _onlyAuthorizedPausers();\n        pausedDeposit = true;\n        emit PauseDeposits(msg.sender);\n    }\n\n    /// @notice Unpauses deposits.\n    ///         This can only be called by governance.\n    function unpauseDeposits() external {\n        _onlyGovernance();\n        pausedDeposit = false;\n        emit UnpauseDeposits(msg.sender);\n    }\n\n    /// @notice Pauses everything.\n    ///         This can be called by either guardian or governance.\n    function pause() external {\n        _onlyAuthorizedPausers();\n        _pause();\n    }\n\n    /// @notice Unpauses everything\n    ///         This can only be called by governance.\n    function unpause() external {\n        _onlyGovernance();\n        _unpause();\n    }\n\n    /// ===== Internal Implementations =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when `pausedDeposit` is true.\n    /// @dev This is the actual deposit operation.\n    ///      Deposits are based on the realized value of underlying assets between Sett & associated Strategy\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function _depositFor(address _recipient, uint256 _amount)\n        internal\n        nonReentrant\n    {\n        require(_recipient != address(0), \"Address 0\");\n        require(_amount != 0, \"Amount 0\");\n        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused\n\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _mintSharesFor(_recipient, _after - _before, _pool);\n    }\n\n    /// @dev See `_depositWithAuthorization`\n    function _depositWithAuthorization(uint256 _amount, bytes32[] memory proof)\n        internal\n    {\n        _depositForWithAuthorization(msg.sender, _amount, proof);\n    }\n\n    /// @dev Verifies that `_recipient` is authorized to deposit `_amount` based on the guestlist.\n    ///      See `_depositFor` for deposit details.\n    function _depositForWithAuthorization(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) internal {\n        if (address(guestList) != address(0)) {\n            require(\n                guestList.authorized(_recipient, _amount, proof),\n                \"GuestList: Not Authorized\"\n            );\n        }\n        _depositFor(_recipient, _amount);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    /// @dev This is the actual withdraw operation.\n    ///      Withdraws from strategy positions if sett doesn't contain enough tokens to process the withdrawal.\n    ///      Calculates withdrawal fees and issues corresponding shares to treasury.\n    ///      No rebalance implementation for lower fees and faster swaps\n    /// @param _shares Quantity of shares to redeem.\n    function _withdraw(uint256 _shares) internal nonReentrant {\n        require(_shares != 0, \"0 Shares\");\n\n        uint256 r = (balance() * _shares) / totalSupply();\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 b = token.balanceOf(address(this));\n        if (b < r) {\n            uint256 _toWithdraw = r - b;\n            IStrategy(strategy).withdraw(_toWithdraw);\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after - b;\n            if (_diff < _toWithdraw) {\n                r = b + _diff;\n            }\n        }\n\n        uint256 _fee = _calculateFee(r, withdrawalFee);\n        uint256 _amount = r - _fee;\n\n        // Send funds to vesting contract and setup vesting\n        IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);\n        token.safeTransfer(vesting, _amount);\n\n        // After you burned the shares, and you have sent the funds, adding here is equivalent to depositing\n        // Process withdrawal fee\n        if(_fee > 0) {\n            _mintSharesFor(treasury, _fee, balance() - _fee);\n        }\n    }\n\n    /// @dev Helper function to calculate fees.\n    /// @param amount Amount to calculate fee on.\n    /// @param feeBps The fee to be charged in basis points.\n    /// @return Amount of fees to take.\n    function _calculateFee(uint256 amount, uint256 feeBps)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (feeBps == 0) {\n            return 0;\n        }\n        uint256 fee = (amount * feeBps) / MAX_BPS;\n        return fee;\n    }\n\n    /// @dev Helper function to calculate governance and strategist performance fees. Make sure to use it to get paid!\n    /// @param _amount Amount to calculate fee on.\n    /// @return Tuple containing amount of (governance, strategist) fees to take.\n    function _calculatePerformanceFee(uint256 _amount)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        uint256 governancePerformanceFee = _calculateFee(\n            _amount,\n            performanceFeeGovernance\n        );\n\n        uint256 strategistPerformanceFee = _calculateFee(\n            _amount,\n            performanceFeeStrategist\n        );\n\n        return (governancePerformanceFee, strategistPerformanceFee);\n    }\n\n    /// @dev Helper function to issue shares to `recipient` based on an input `_amount` and `_pool` size.\n    /// @param recipient Address to issue shares to.\n    /// @param _amount Amount to issue shares on.\n    /// @param _pool Pool size to use while calculating amount of shares to mint.\n    function _mintSharesFor(\n        address recipient,\n        uint256 _amount,\n        uint256 _pool\n    ) internal {\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply()) / _pool;\n        }\n        _mint(recipient, shares);\n    }\n\n    /// @dev Helper function that issues shares based on performance and management fee when a harvest is reported.\n    /// @param _harvestedAmount The harvested amount to take fee on.\n    /// @param harvestTime Time of harvest (block.timestamp).\n    function _handleFees(uint256 _harvestedAmount, uint256 harvestTime)\n        internal\n    {\n        (\n            uint256 feeGovernance,\n            uint256 feeStrategist\n        ) = _calculatePerformanceFee(_harvestedAmount);\n        uint256 duration = harvestTime - lastHarvestedAt;\n\n        // Management fee is calculated against the assets before harvest, to make it fair to depositors\n        uint256 management_fee = managementFee > 0\n            ? (managementFee * (balance() - _harvestedAmount) * duration) /\n                SECS_PER_YEAR /\n                MAX_BPS\n            : 0;\n        uint256 totalGovernanceFee = feeGovernance + management_fee;\n\n        // Pool size is the size of the pool minus the fees, this way\n        // it's equivalent to sending the tokens as rewards after the harvest\n        // and depositing them again\n        uint256 _pool = balance() - totalGovernanceFee - feeStrategist;\n\n        // uint != is cheaper and equivalent to >\n        if (totalGovernanceFee != 0) {\n            _mintSharesFor(treasury, totalGovernanceFee, _pool);\n        }\n\n        if (feeStrategist != 0 && strategist != address(0)) {\n            /// NOTE: adding feeGovernance backed to _pool as shares would have been issued for it.\n            _mintSharesFor(\n                strategist,\n                feeStrategist,\n                _pool + totalGovernanceFee\n            );\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "StakedCitadel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "_withdraw"
                ],
                "Type": " StakedCitadel: wrong setupVesting function name",
                "Description": "\nIn the _withdraw function of the StakedCitadel contract, the setupVesting function of vesting is called, while in the StakedCitadelVester contract, the function name is vest, which will cause the _withdraw function to fail, so that the user cannot withdraw the tokens.\n\n            IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);\n            token.safeTransfer(vesting, _amount);\n            ...\n        function vest(\n            address recipient,\n            uint256 _amount,\n            uint256 _unlockBegin\n        ) external {\n            require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");\n            require(_amount  0, \"StakedCitadelVester: cannot vest 0\");\n\n            vesting[recipient].lockedAmounts =\n                vesting[recipient].lockedAmounts +\n                _amount;\n            vesting[recipient].unlockBegin = _unlockBegin;\n            vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n            emit Vest(\n                recipient,\n                vesting[recipient].lockedAmounts,\n                _unlockBegin,\n                vesting[recipient].unlockEnd\n            );\n        }\n\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/interfaces/citadel/IVesting.sol#L5\n\n",
                "Repair": "\nUse the correct function name\n\n    interface IVesting {\n        function vest(\n            address recipient,\n            uint256 _amount,\n            uint256 _unlockBegin\n        ) external;\n    }\n    ...\n    IVesting(vesting).vest(msg.sender, _amount, block.timestamp);\n    token.safeTransfer(vesting, _amount);\n\ndapp-whisperer (BadgerDAO) confirmed and resolved(https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/9) \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/PullPayment.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/escrow/Escrow.sol\";\n\n/**\n * @dev Simple implementation of a\n * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]\n * strategy, where the paying contract doesn't interact directly with the\n * receiver account, which must withdraw its payments itself.\n *\n * Pull-payments are often considered the best practice when it comes to sending\n * Ether, security-wise. It prevents recipients from blocking execution, and\n * eliminates reentrancy concerns.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * To use, derive from the `PullPayment` contract, and use {_asyncTransfer}\n * instead of Solidity's `transfer` function. Payees can query their due\n * payments with {payments}, and retrieve them with {withdrawPayments}.\n */\nabstract contract PullPayment {\n    Escrow private immutable _escrow;\n\n    constructor() {\n        _escrow = new Escrow();\n    }\n\n    /**\n     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.\n     *\n     * Note that _any_ account can call this function, not just the `payee`.\n     * This means that contracts unaware of the `PullPayment` protocol can still\n     * receive funds this way, by having a separate account call\n     * {withdrawPayments}.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee Whose payments will be withdrawn.\n     */\n    function withdrawPayments(address payable payee) public virtual {\n        _escrow.withdraw(payee);\n    }\n\n    /**\n     * @dev Returns the payments owed to an address.\n     * @param dest The creditor's address.\n     */\n    function payments(address dest) public view returns (uint256) {\n        return _escrow.depositsOf(dest);\n    }\n\n    /**\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\n     * Funds sent in this way are stored in an intermediate {Escrow} contract, so\n     * there is no danger of them being spent before withdrawal.\n     *\n     * @param dest The destination address of the funds.\n     * @param amount The amount to transfer.\n     */\n    function _asyncTransfer(address dest, uint256 amount) internal virtual {\n        _escrow.deposit{value: amount}(dest);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/SettAccessControl.sol\";\n\nimport {IVault} from \"./interfaces/badger/IVault.sol\";\nimport {IVesting} from \"./interfaces/citadel/IVesting.sol\";\nimport {IStrategy} from \"./interfaces/badger/IStrategy.sol\";\nimport {IERC20} from \"./interfaces/erc20/IERC20.sol\";\nimport {IBadgerGuestlist} from \"./interfaces/badger/IBadgerGuestlist.sol\";\n\n/*\n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n\n    V1.3\n    * Add guest list functionality\n    * All deposits can be optionally gated by external guestList approval logic on set guestList contract\n\n    V1.4\n    * Add depositFor() to deposit on the half of other users. That user will then be blockLocked.\n\n    V1.5\n    * Removed Controller\n        - Removed harvest from vault (only on strategy)\n    * Params added to track autocompounded rewards (lifeTimeEarned, lastHarvestedAt, lastHarvestAmount, assetsAtLastHarvest)\n      this would work in sync with autoCompoundRatio to help us track harvests better.\n    * Fees\n        - Strategy would report the autocompounded harvest amount to the vault\n        - Calculation performanceFeeGovernance, performanceFeeStrategist, withdrawalFee, managementFee moved to the vault.\n        - Vault mints shares for performanceFees and managementFee to the respective recipient (treasury, strategist)\n        - withdrawal fees is transferred to the rewards address set\n    * Permission:\n        - Strategist can now set performance, withdrawal and management fees\n        - Governance will determine maxPerformanceFee, maxWithdrawalFee, maxManagementFee that can be set to prevent rug of funds.\n    * Strategy would take the actors from the vault it is connected to\n    * All governance related fees goes to treasury\n*/\n\ncontract StakedCitadel is\n    ERC20Upgradeable,\n    SettAccessControl,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    uint256 constant ONE_ETH = 1e18;\n\n    /// ===== Storage Variables ====\n\n    IERC20Upgradeable public token; // Token used for deposits\n    IBadgerGuestlist public guestList; // guestlist when vault is in experiment/ guarded state\n\n    bool public pausedDeposit; // false by default Allows to only block deposits, use pause for the normal pause state\n\n    address public strategy; // address of the strategy connected to the vault\n    address public guardian; // guardian of vault and strategy\n    address public treasury; // set by governance ... any fees go there\n\n    address public badgerTree; // Address we send tokens too via reportAdditionalTokens\n    address public vesting; // Address of the vesting contract where after withdrawal we send CTDL to vest for 21 days\n\n    /// @dev name and symbol prefixes for lpcomponent token of vault\n    string internal constant _defaultNamePrefix = \"Staked \";\n    string internal constant _symbolSymbolPrefix = \"x\";\n\n    /// Params to track autocompounded rewards\n    uint256 public lifeTimeEarned; // keeps track of total earnings\n    uint256 public lastHarvestedAt; // timestamp of the last harvest\n    uint256 public lastHarvestAmount; // amount harvested during last harvest\n    uint256 public assetsAtLastHarvest; // assets for which the harvest took place.\n\n    mapping(address => uint256) public additionalTokensEarned;\n    mapping(address => uint256) public lastAdditionalTokenAmount;\n\n    /// Fees ///\n    /// @notice all fees will be in bps\n    uint256 public performanceFeeGovernance; // Perf fee sent to `treasury`\n    uint256 public performanceFeeStrategist; // Perf fee sent to `strategist`\n    uint256 public withdrawalFee; // fee issued to `treasury` on withdrawal\n    uint256 public managementFee; // fee issued to `treasury` on report (typically on harvest, but only if strat is autocompounding)\n\n    uint256 public maxPerformanceFee; // maximum allowed performance fees\n    uint256 public maxWithdrawalFee; // maximum allowed withdrawal fees\n    uint256 public maxManagementFee; // maximum allowed management fees\n\n    uint256 public toEarnBps; // NOTE: in BPS, minimum amount of token to deposit into strategy when earn is called\n\n    /// ===== Constants ====\n\n    uint256 public constant MAX_BPS = 10_000;\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    uint256 public constant WITHDRAWAL_FEE_HARD_CAP = 200; // Never higher than 2%\n    uint256 public constant PERFORMANCE_FEE_HARD_CAP = 3_000; // Never higher than 30% // 30% maximum performance fee // We usually do 20, so this is insanely high already\n    uint256 public constant MANAGEMENT_FEE_HARD_CAP = 200; // Never higher than 2%\n\n    /// ===== Events ====\n\n    // Emitted when a token is sent to the badgerTree for emissions\n    event TreeDistribution(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    // Emitted during a report, when there has been an increase in pricePerFullShare (ppfs)\n    event Harvested(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    event SetTreasury(address indexed newTreasury);\n    event SetStrategy(address indexed newStrategy);\n    event SetToEarnBps(uint256 newEarnToBps);\n    event SetMaxWithdrawalFee(uint256 newMaxWithdrawalFee);\n    event SetMaxPerformanceFee(uint256 newMaxPerformanceFee);\n    event SetMaxManagementFee(uint256 newMaxManagementFee);\n    event SetGuardian(address indexed newGuardian);\n    event SetVesting(address indexed newVesting);\n    event SetGuestList(address indexed newGuestList);\n    event SetWithdrawalFee(uint256 newWithdrawalFee);\n    event SetPerformanceFeeStrategist(uint256 newPerformanceFeeStrategist);\n    event SetPerformanceFeeGovernance(uint256 newPerformanceFeeGovernance);\n    event SetManagementFee(uint256 newManagementFee);\n\n    event PauseDeposits(address indexed pausedBy);\n    event UnpauseDeposits(address indexed pausedBy);\n\n    /// @notice Initializes the Sett. Can only be called once, ideally when the contract is deployed.\n    /// @param _token Address of the token that can be deposited into the sett.\n    /// @param _governance Address authorized as governance.\n    /// @param _keeper Address authorized as keeper.\n    /// @param _guardian Address authorized as guardian.\n    /// @param _treasury Address to distribute governance fees/rewards to.\n    /// @param _strategist Address authorized as strategist.\n    /// @param _badgerTree Address of badgerTree used for emissions.\n    /// @param _name Specify a custom sett name. Leave empty for default value.\n    /// @param _symbol Specify a custom sett symbol. Leave empty for default value.\n    /// @param _feeConfig Values for the 4 different types of fees charges by the sett\n    ///         [performanceFeeGovernance, performanceFeeStrategist, withdrawToVault, managementFee]\n    ///         Each fee should be less than the constant hard-caps defined above.\n    function initialize(\n        address _token,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        address _treasury,\n        address _strategist,\n        address _badgerTree,\n        address _vesting,\n        string memory _name,\n        string memory _symbol,\n        uint256[4] memory _feeConfig\n    ) public initializer whenNotPaused {\n        require(_token != address(0)); // dev: _token address should not be zero\n        require(_governance != address(0)); // dev: _governance address should not be zero\n        require(_keeper != address(0)); // dev: _keeper address should not be zero\n        require(_guardian != address(0)); // dev: _guardian address should not be zero\n        require(_treasury != address(0)); // dev: _treasury address should not be zero\n        require(_strategist != address(0)); // dev: _strategist address should not be zero\n        require(_badgerTree != address(0)); // dev: _badgerTree address should not be zero\n        require(_vesting != address(0)); // dev: _vesting address should not be zero\n\n        // Check for fees being reasonable (see below for interpretation)\n        require(\n            _feeConfig[0] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeGovernance too high\"\n        );\n        require(\n            _feeConfig[1] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n        require(\n            _feeConfig[2] <= WITHDRAWAL_FEE_HARD_CAP,\n            \"withdrawalFee too high\"\n        );\n        require(\n            _feeConfig[3] <= MANAGEMENT_FEE_HARD_CAP,\n            \"managementFee too high\"\n        );\n\n        string memory name;\n        string memory symbol;\n\n        // If they are non empty string we'll use the custom names\n        // Else just add the default prefix\n        IERC20 namedToken = IERC20(_token);\n\n        if (keccak256(abi.encodePacked(_name)) != keccak256(\"\")) {\n            name = _name;\n        } else {\n            name = string(\n                abi.encodePacked(_defaultNamePrefix, namedToken.name())\n            );\n        }\n\n        if (keccak256(abi.encodePacked(_symbol)) != keccak256(\"\")) {\n            symbol = _symbol;\n        } else {\n            symbol = string(\n                abi.encodePacked(_symbolSymbolPrefix, namedToken.symbol())\n            );\n        }\n\n        // Initializing the lpcomponent token\n        __ERC20_init(name, symbol);\n        // Initialize the other contracts\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        treasury = _treasury;\n        strategist = _strategist;\n        keeper = _keeper;\n        guardian = _guardian;\n        badgerTree = _badgerTree;\n        vesting = _vesting;\n\n        lastHarvestedAt = block.timestamp; // setting initial value to the time when the vault was deployed\n\n        performanceFeeGovernance = _feeConfig[0];\n        performanceFeeStrategist = _feeConfig[1];\n        withdrawalFee = _feeConfig[2];\n        managementFee = _feeConfig[3];\n        maxPerformanceFee = PERFORMANCE_FEE_HARD_CAP; // 30% max performance fee\n        maxWithdrawalFee = WITHDRAWAL_FEE_HARD_CAP; // 2% maximum withdrawal fee\n        maxManagementFee = MANAGEMENT_FEE_HARD_CAP; // 2% maximum management fee\n\n        toEarnBps = 9_500; // initial value of toEarnBps // 95% is invested to the strategy, 5% for cheap withdrawals\n    }\n\n    /// ===== Modifiers ====\n\n    /// @notice Checks whether a call is from guardian or governance.\n    function _onlyAuthorizedPausers() internal view {\n        require(\n            msg.sender == guardian || msg.sender == governance,\n            \"onlyPausers\"\n        );\n    }\n\n    /// @notice Checks whether a call is from the strategy.\n    function _onlyStrategy() internal view {\n        require(msg.sender == strategy, \"onlyStrategy\");\n    }\n\n    /// ===== View Functions =====\n\n    /// @notice Used to track the deployed version of the contract.\n    /// @return Current version of the contract.\n    function version() external pure returns (string memory) {\n        return \"1.5\";\n    }\n\n    /// @notice Gives the price for a single Sett share.\n    /// @dev Sett starts with a price per share of 1.\n    /// @return Value of a single share.\n    function getPricePerFullShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return ONE_ETH;\n        }\n        return (balance() * ONE_ETH) / totalSupply();\n    }\n\n    /// @notice Gives the total balance of the underlying token within the sett and strategy system.\n    /// @return Balance of token handled by the sett.\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Defines how much of the Setts' underlying is available for strategy to borrow.\n    /// @return Amount of tokens that the sett can provide to the strategy.\n    function available() public view returns (uint256) {\n        return (token.balanceOf(address(this)) * toEarnBps) / MAX_BPS;\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _amount Quantity of tokens to deposit.\n    function deposit(uint256 _amount) external whenNotPaused {\n        _depositWithAuthorization(_amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling account is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _amount Quantity of tokens to deposit.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function deposit(uint256 _amount, bytes32[] memory proof)\n        external\n        whenNotPaused\n    {\n        _depositWithAuthorization(_amount, proof);\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    function depositAll() external whenNotPaused {\n        _depositWithAuthorization(\n            token.balanceOf(msg.sender),\n            new bytes32[](0)\n        );\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling is authorized to make a full deposit.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function depositAll(bytes32[] memory proof) external whenNotPaused {\n        _depositWithAuthorization(token.balanceOf(msg.sender), proof);\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(address _recipient, uint256 _amount)\n        external\n        whenNotPaused\n    {\n        _depositForWithAuthorization(_recipient, _amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Checks the guestlist to verify that `recipient` is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) external whenNotPaused {\n        _depositForWithAuthorization(_recipient, _amount, proof);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    /// @param _shares Quantity of shares to redeem.\n    function withdraw(uint256 _shares) external whenNotPaused {\n        _withdraw(_shares);\n    }\n\n    /// @notice Redeems all shares, issuing an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    function withdrawAll() external whenNotPaused {\n        _withdraw(balanceOf(msg.sender));\n    }\n\n    /// ===== Permissioned Actions: Strategy =====\n\n    /// @notice Used by the strategy to report a harvest to the sett.\n    ///         Issues shares for the strategist and treasury based on the performance fees and harvested amount.\n    ///         Issues shares for the treasury based on the management fee and the time elapsed since last harvest.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This implicitly trusts that the strategy reports the correct amount.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _harvestedAmount Amount of underlying token harvested by the strategy.\n    function reportHarvest(uint256 _harvestedAmount) external nonReentrant {\n        _onlyStrategy();\n\n        uint256 harvestTime = block.timestamp;\n        uint256 assetsAtHarvest = balance() - _harvestedAmount; // Must be less than or equal or revert\n\n        _handleFees(_harvestedAmount, harvestTime);\n\n        // Updated lastHarvestAmount\n        lastHarvestAmount = _harvestedAmount;\n\n        // if we withdrawAll\n        // we will have some yield left\n        // having 0 for assets will inflate APY\n        // Instead, have the last harvest report with the previous assets\n        // And if you end up harvesting again, that report will have both 0s\n        if (assetsAtHarvest != 0) {\n            assetsAtLastHarvest = assetsAtHarvest;\n        } else if (_harvestedAmount == 0) {\n            // If zero\n            assetsAtLastHarvest = 0;\n        }\n\n        lifeTimeEarned = lifeTimeEarned + _harvestedAmount;\n        // Update time either way\n        lastHarvestedAt = harvestTime;\n\n        emit Harvested(\n            address(token),\n            _harvestedAmount,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// @notice Used by the strategy to report harvest of additional tokens to the sett.\n    ///         Charges performance fees on the additional tokens and transfers fees to treasury and strategist.\n    ///         The remaining amount is sent to badgerTree for emissions.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This function is called after the strategy sends the additional tokens to the sett.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _token Address of additional token harvested by the strategy.\n    function reportAdditionalToken(address _token) external nonReentrant {\n        _onlyStrategy();\n        require(address(token) != _token, \"No want\");\n        uint256 tokenBalance = IERC20Upgradeable(_token).balanceOf(\n            address(this)\n        );\n\n        additionalTokensEarned[_token] =\n            additionalTokensEarned[_token] +\n            tokenBalance;\n        lastAdditionalTokenAmount[_token] = tokenBalance;\n\n        // We may have more, but we still report only what the strat sent\n        uint256 governanceRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeGovernance\n        );\n        uint256 strategistRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeStrategist\n        );\n\n        IERC20Upgradeable(_token).safeTransfer(treasury, governanceRewardsFee);\n        IERC20Upgradeable(_token).safeTransfer(\n            strategist,\n            strategistRewardsFee\n        );\n\n        // Send rest to tree\n        uint256 newBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n        IERC20Upgradeable(_token).safeTransfer(badgerTree, newBalance);\n        emit TreeDistribution(\n            _token,\n            newBalance,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n\n    /// @notice Changes the treasury address.\n    ///         Treasury is recipient of management and governance performance fees.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @param _treasury Address of the new treasury.\n    function setTreasury(address _treasury) external whenNotPaused {\n        _onlyGovernance();\n        require(_treasury != address(0), \"Address 0\");\n\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n    /// @notice Changes the strategy address.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @dev This is a rug vector, pay extremely close attention to the next strategy being set.\n    ///      Changing the strategy should happen only via timelock.\n    ///      This function must not be callable when the sett is paused as this would force depositors into a strategy they may not want to use.\n    /// @param _strategy Address of new strategy.\n    function setStrategy(address _strategy) external whenNotPaused {\n        _onlyGovernance();\n        require(_strategy != address(0), \"Address 0\");\n\n        /// NOTE: Migrate funds if settings strategy when already existing one\n        if (strategy != address(0)) {\n            require(\n                IStrategy(strategy).balanceOf() == 0,\n                \"Please withdrawToVault before changing strat\"\n            );\n        }\n        strategy = _strategy;\n        emit SetStrategy(_strategy);\n    }\n\n    // === Setters that can be called by governance even when paused ===\n\n    /// @notice Sets the max withdrawal fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `WITHDRAWAL_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for withdrawal fee.\n    function setMaxWithdrawalFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= WITHDRAWAL_FEE_HARD_CAP, \"withdrawalFee too high\");\n\n        maxWithdrawalFee = _fees;\n        emit SetMaxWithdrawalFee(_fees);\n    }\n\n    /// @notice Sets the max performance fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `PERFORMANCE_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for performance fee.\n    function setMaxPerformanceFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(\n            _fees <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n\n        maxPerformanceFee = _fees;\n        emit SetMaxPerformanceFee(_fees);\n    }\n\n    /// @notice Sets the max management fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `MANAGEMENT_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for management fee.\n    function setMaxManagementFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= MANAGEMENT_FEE_HARD_CAP, \"managementFee too high\");\n\n        maxManagementFee = _fees;\n        emit SetMaxManagementFee(_fees);\n    }\n\n    /// @notice Changes the guardian address.\n    ///         Guardian is an authorized actor that can pause the sett in case of an emergency.\n    ///         This can only be called by governance.\n    /// @param _guardian Address of the new guardian.\n    function setGuardian(address _guardian) external {\n        _onlyGovernance();\n        require(_guardian != address(0), \"Address cannot be 0x0\");\n\n        guardian = _guardian;\n        emit SetGuardian(_guardian);\n    }\n\n    /// @notice Changes the vesting contract address.\n    ///         Vesting contract is used to vest withdrawn tokens linearly over period of 21 days\n    ///         This can only be called by governance.\n    /// @param _vesting Address of the new guardian.\n    function setVesting(address _vesting) external {\n        _onlyGovernance();\n        require(_vesting != address(0), \"Address cannot be 0x0\");\n\n        vesting = _vesting;\n        emit SetVesting(_vesting);\n    }\n\n    /// ===== Permissioned Functions: Trusted Actors =====\n\n    /// @notice Sets the fraction of sett balance (in basis points) that the strategy can borrow.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _newToEarnBps The new maximum cap for management fee.\n    function setToEarnBps(uint256 _newToEarnBps) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_newToEarnBps <= MAX_BPS, \"toEarnBps should be <= MAX_BPS\");\n\n        toEarnBps = _newToEarnBps;\n        emit SetToEarnBps(_newToEarnBps);\n    }\n\n    /// @notice Changes the guestlist address.\n    ///         The guestList is used to gate or limit deposits. If no guestlist is set then anyone can deposit any amount.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _guestList Address of the new guestlist.\n    function setGuestList(address _guestList) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        guestList = IBadgerGuestlist(_guestList);\n        emit SetGuestList(_guestList);\n    }\n\n    /// @notice Sets the withdrawal fee charged by the Sett.\n    ///         The fee is taken at the time of withdrawals in the underlying token which is then used to issue new shares for the treasury.\n    ///         The new withdrawal fee should be less than `maxWithdrawalFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_withdraw` to see how withdrawal fee is charged.\n    /// @param _withdrawalFee The new withdrawal fee.\n    function setWithdrawalFee(uint256 _withdrawalFee) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_withdrawalFee <= maxWithdrawalFee, \"Excessive withdrawal fee\");\n        withdrawalFee = _withdrawalFee;\n        emit SetWithdrawalFee(_withdrawalFee);\n    }\n\n    /// @notice Sets the performance fee taken by the strategist on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the strategist.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeStrategist The new performance fee.\n    function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeStrategist <= maxPerformanceFee,\n            \"Excessive strategist performance fee\"\n        );\n        performanceFeeStrategist = _performanceFeeStrategist;\n        emit SetPerformanceFeeStrategist(_performanceFeeStrategist);\n    }\n\n    /// @notice Sets the performance fee taken by the treasury on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the treasury.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeGovernance The new performance fee.\n    function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeGovernance <= maxPerformanceFee,\n            \"Excessive governance performance fee\"\n        );\n        performanceFeeGovernance = _performanceFeeGovernance;\n        emit SetPerformanceFeeGovernance(_performanceFeeGovernance);\n    }\n\n    /// @notice Sets the management fee taken by the treasury on the AUM in the sett.\n    ///         The fee is calculated at the time of `reportHarvest` and is used to issue new shares for the treasury.\n    ///         The new management fee should be less than `maxManagementFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_handleFees` to see how the management fee is calculated.\n    /// @param _fees The new management fee.\n    function setManagementFee(uint256 _fees) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_fees <= maxManagementFee, \"Excessive management fee\");\n        managementFee = _fees;\n        emit SetManagementFee(_fees);\n    }\n\n    /// === Strategist level operations that can be done even when paused ==\n\n    /// @notice Withdraws all funds from the strategy back to the sett.\n    ///         This can be called by either governance or strategist.\n    /// @dev This calls `_withdrawAll` on the strategy and transfers the balance to the sett.\n    function withdrawToVault() external {\n        _onlyGovernanceOrStrategist();\n        IStrategy(strategy).withdrawToVault();\n    }\n\n    /// @notice Sends balance of any extra token earned by the strategy (from airdrops, donations etc.)\n    ///         to the badgerTree for emissions.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev See `BaseStrategy.emitNonProtectedToken` for details.\n    /// @param _token Address of the token to be emitted.\n    function emitNonProtectedToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n\n        IStrategy(strategy).emitNonProtectedToken(_token);\n    }\n\n    /// @notice Sweeps the balance of an extra token from the vault and strategy and sends it to governance.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev Sweeping doesn't take any fee.\n    /// @param _token Address of the token to be swept.\n    function sweepExtraToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n        require(address(token) != _token, \"No want\");\n\n        IStrategy(strategy).withdrawOther(_token);\n        // Send all `_token` we have\n        // Safe because `withdrawOther` will revert on protected tokens\n        // Done this way works for both a donation to strategy or to vault\n        IERC20Upgradeable(_token).safeTransfer(\n            governance,\n            IERC20Upgradeable(_token).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Deposits the available balance of the underlying token into the strategy.\n    ///         The strategy then uses the amount for yield-generating activities.\n    ///         This can be called by either the keeper or governance.\n    ///         Note that earn cannot be called when deposits are paused.\n    /// @dev Pause is enforced at the Strategy level (this allows to still earn yield when the Vault is paused)\n    function earn() external {\n        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused, we don't earn as well\n        _onlyAuthorizedActors();\n\n        uint256 _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).earn();\n    }\n\n    /// @notice Pauses only deposits.\n    ///         This can be called by either guardian or governance.\n    function pauseDeposits() external {\n        _onlyAuthorizedPausers();\n        pausedDeposit = true;\n        emit PauseDeposits(msg.sender);\n    }\n\n    /// @notice Unpauses deposits.\n    ///         This can only be called by governance.\n    function unpauseDeposits() external {\n        _onlyGovernance();\n        pausedDeposit = false;\n        emit UnpauseDeposits(msg.sender);\n    }\n\n    /// @notice Pauses everything.\n    ///         This can be called by either guardian or governance.\n    function pause() external {\n        _onlyAuthorizedPausers();\n        _pause();\n    }\n\n    /// @notice Unpauses everything\n    ///         This can only be called by governance.\n    function unpause() external {\n        _onlyGovernance();\n        _unpause();\n    }\n\n    /// ===== Internal Implementations =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when `pausedDeposit` is true.\n    /// @dev This is the actual deposit operation.\n    ///      Deposits are based on the realized value of underlying assets between Sett & associated Strategy\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function _depositFor(address _recipient, uint256 _amount)\n        internal\n        nonReentrant\n    {\n        require(_recipient != address(0), \"Address 0\");\n        require(_amount != 0, \"Amount 0\");\n        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused\n\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _mintSharesFor(_recipient, _after - _before, _pool);\n    }\n\n    /// @dev See `_depositWithAuthorization`\n    function _depositWithAuthorization(uint256 _amount, bytes32[] memory proof)\n        internal\n    {\n        _depositForWithAuthorization(msg.sender, _amount, proof);\n    }\n\n    /// @dev Verifies that `_recipient` is authorized to deposit `_amount` based on the guestlist.\n    ///      See `_depositFor` for deposit details.\n    function _depositForWithAuthorization(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) internal {\n        if (address(guestList) != address(0)) {\n            require(\n                guestList.authorized(_recipient, _amount, proof),\n                \"GuestList: Not Authorized\"\n            );\n        }\n        _depositFor(_recipient, _amount);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    /// @dev This is the actual withdraw operation.\n    ///      Withdraws from strategy positions if sett doesn't contain enough tokens to process the withdrawal.\n    ///      Calculates withdrawal fees and issues corresponding shares to treasury.\n    ///      No rebalance implementation for lower fees and faster swaps\n    /// @param _shares Quantity of shares to redeem.\n    function _withdraw(uint256 _shares) internal nonReentrant {\n        require(_shares != 0, \"0 Shares\");\n\n        uint256 r = (balance() * _shares) / totalSupply();\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 b = token.balanceOf(address(this));\n        if (b < r) {\n            uint256 _toWithdraw = r - b;\n            IStrategy(strategy).withdraw(_toWithdraw);\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after - b;\n            if (_diff < _toWithdraw) {\n                r = b + _diff;\n            }\n        }\n\n        uint256 _fee = _calculateFee(r, withdrawalFee);\n        uint256 _amount = r - _fee;\n\n        // Send funds to vesting contract and setup vesting\n        IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);\n        token.safeTransfer(vesting, _amount);\n\n        // After you burned the shares, and you have sent the funds, adding here is equivalent to depositing\n        // Process withdrawal fee\n        if(_fee > 0) {\n            _mintSharesFor(treasury, _fee, balance() - _fee);\n        }\n    }\n\n    /// @dev Helper function to calculate fees.\n    /// @param amount Amount to calculate fee on.\n    /// @param feeBps The fee to be charged in basis points.\n    /// @return Amount of fees to take.\n    function _calculateFee(uint256 amount, uint256 feeBps)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (feeBps == 0) {\n            return 0;\n        }\n        uint256 fee = (amount * feeBps) / MAX_BPS;\n        return fee;\n    }\n\n    /// @dev Helper function to calculate governance and strategist performance fees. Make sure to use it to get paid!\n    /// @param _amount Amount to calculate fee on.\n    /// @return Tuple containing amount of (governance, strategist) fees to take.\n    function _calculatePerformanceFee(uint256 _amount)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        uint256 governancePerformanceFee = _calculateFee(\n            _amount,\n            performanceFeeGovernance\n        );\n\n        uint256 strategistPerformanceFee = _calculateFee(\n            _amount,\n            performanceFeeStrategist\n        );\n\n        return (governancePerformanceFee, strategistPerformanceFee);\n    }\n\n    /// @dev Helper function to issue shares to `recipient` based on an input `_amount` and `_pool` size.\n    /// @param recipient Address to issue shares to.\n    /// @param _amount Amount to issue shares on.\n    /// @param _pool Pool size to use while calculating amount of shares to mint.\n    function _mintSharesFor(\n        address recipient,\n        uint256 _amount,\n        uint256 _pool\n    ) internal {\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply()) / _pool;\n        }\n        _mint(recipient, shares);\n    }\n\n    /// @dev Helper function that issues shares based on performance and management fee when a harvest is reported.\n    /// @param _harvestedAmount The harvested amount to take fee on.\n    /// @param harvestTime Time of harvest (block.timestamp).\n    function _handleFees(uint256 _harvestedAmount, uint256 harvestTime)\n        internal\n    {\n        (\n            uint256 feeGovernance,\n            uint256 feeStrategist\n        ) = _calculatePerformanceFee(_harvestedAmount);\n        uint256 duration = harvestTime - lastHarvestedAt;\n\n        // Management fee is calculated against the assets before harvest, to make it fair to depositors\n        uint256 management_fee = managementFee > 0\n            ? (managementFee * (balance() - _harvestedAmount) * duration) /\n                SECS_PER_YEAR /\n                MAX_BPS\n            : 0;\n        uint256 totalGovernanceFee = feeGovernance + management_fee;\n\n        // Pool size is the size of the pool minus the fees, this way\n        // it's equivalent to sending the tokens as rewards after the harvest\n        // and depositing them again\n        uint256 _pool = balance() - totalGovernanceFee - feeStrategist;\n\n        // uint != is cheaper and equivalent to >\n        if (totalGovernanceFee != 0) {\n            _mintSharesFor(treasury, totalGovernanceFee, _pool);\n        }\n\n        if (feeStrategist != 0 && strategist != address(0)) {\n            /// NOTE: adding feeGovernance backed to _pool as shares would have been issued for it.\n            _mintSharesFor(\n                strategist,\n                feeStrategist,\n                _pool + totalGovernanceFee\n            );\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PullPayment.sol",
            "StakedCitadel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "deposit(",
                    "_pool = balance()"
                ],
                "Type": " StakedCitadel depositors can be attacked by the first depositor with depressing of vault token denomination",
                "Description": "\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L892\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L293-L295\n\n\nAn attacker can become the first depositor for a recently created StakedCitadel contract, providing a tiny amount of Citadel tokens by calling deposit(1) (raw values here, 1 is 1 wei, 1e18 is 1 Citadel as it has 18 decimals). Then the attacker can directly transfer, for example, 10^6*1e18 1 Citadel to StakedCitadel, effectively setting the cost of 1 of the vault token to be 10^6 * 1e18 Citadel. The attacker will still own 100% of the StakedCitadel's pool being the only depositor.\n\nAll subsequent depositors will have their Citadel token investments rounded to 10^6 * 1e18, due to the lack of precision which initial tiny deposit caused, with the remainder divided between all current depositors, i.e. the subsequent depositors lose value to the attacker.\n\nFor example, if the second depositor brings in 1.9*10^6 * 1e18 Citadel, only 1 of new vault to be issued as 1.9*10^6 * 1e18 divided by 10^6 * 1e18 will yield just 1, which means that 2.9*10^6 * 1e18 total Citadel pool will be divided 50/50 between the second depositor and the attacker, as each have 1 wei of the total 2 wei of vault tokens, i.e. the depositor lost and the attacker gained 0.45*10^6 * 1e18 Citadel tokens.\n\nAs there are no penalties to exit with StakedCitadel.withdraw(), the attacker can remain staked for an arbitrary time, gathering the share of all new deposits' remainder amounts.\n\nPlacing severity to be high as this is principal funds loss scenario for many users (most of depositors), easily executable, albeit only for the new StakedCitadel contract.\n\n\ndeposit() - _depositFor() - _mintSharesFor() call doesn't require minimum amount and mints according to the provided amount:\n\ndeposit:\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L309-L311\n\n_depositFor:\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L764-L777\n\n_mintSharesFor:\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L892\n\nWhen StakedCitadel is new the _pool = balance() is just initially empty contract balance:\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L293-L295\n\nAny deposit lower than total attacker's stake will be fully stolen from the depositor as 0 vault tokens will be issued in this case.\n\n\nThe issue is similar to the TOB-YEARN-003 one of the Trail of Bits audit of Yearn Finance:\n\n<https://github.com/yearn/yearn-security/tree/master/audits/20210719_ToB_yearn_vaultsv2\n\n",
                "Repair": "\nA minimum for deposit value can drastically reduce the economic viability of the attack. I.e. deposit() - ... can require each amount to surpass the threshold, and then an attacker would have to provide too big direct investment to capture any meaningful share of the subsequent deposits.\n\nAn alternative is to require only the first depositor to freeze big enough initial amount of liquidity. This approach has been used long enough by various projects, for example in Uniswap V2:\n\n<https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L121\n\n\nGalloDaSballo (BadgerDAO) acknowledged, disagreed with severity and commented(https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/217#issuecomment-1106938360):\n  Disagree with the dramatic effect the warden is implying.\n \n Agree with the finding as this is a property of vault based systems\n\n  Also worth noting that anyone else can still get more deposits in and get their fair share, it's just that the first deposit would now require a deposit of at least vault.balanceOf in order to get the fair amount of shares (which at this point would be rebased to be 1 = prevBalanceOf) \n\njack-the-pug (judge) commented(https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/217#issuecomment-1140871615):\n  I believe this is a valid High even though the precondition of this attack is quite strict (the attacker has to be the 1st depositor).\n \n The impact is not just a regular precision loss, but with the pricePerShare of the vault being manipulated to an extreme value, all regular users will lose up to the pricePerShare of the deposited amount due to huge precision loss.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]