[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title JPEG'd LP Farming\n/// @notice Users can stake their JPEG'd ecosystem LP tokens to get JPEG rewards\n/// @dev This contract doesn't mint JPEG tokens, instead the owner (the JPEG'd DAO) allocates x amount of JPEG to be distributed as a reward for liquidity providers.\n/// To ensure that enough tokens are allocated, an epoch system is implemented.\n/// The owner is required to allocate enough tokens (`_rewardPerBlock * (_endBlock - _startBlock)`) when creating a new epoch.\n/// When there no epoch is ongoing, the contract stops emitting rewards\ncontract LPFarming is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event ClaimAll(address indexed user, uint256 amount);\n\n    /// @dev Data relative to a user's staking position\n    /// @param amount The amount of LP tokens the user has provided\n    /// @param lastAccRewardPerShare The `accRewardPerShare` pool value at the time of the user's last claim\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastAccRewardPerShare;\n    }\n\n    /// @dev Data relative to an LP pool\n    /// @param lpToken The LP token accepted by the pool\n    /// @param allocPoint Allocation points assigned to the pool. Determines the share of `rewardPerBlock` allocated to this pool\n    /// @param lastRewardBlock Last block number in which reward distribution occurred\n    /// @param accRewardPerShare Accumulated rewards per share, times 1e36. The amount of rewards the pool has accumulated per unit of LP token deposited\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 accRewardPerShare;\n    }\n\n    /// @dev Data relative to an epoch\n    /// @param startBlock The epoch's starting block\n    /// @param endBlock The epoch's starting block\n    /// @param rewardPerBlock The amount of JPEG rewards distributed per block during this epoch\n    struct EpochInfo {\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 rewardPerBlock;\n    }\n\n    /// @notice The reward token, JPEG\n    IERC20 public immutable jpeg;\n\n    /// @notice The current epoch\n    /// @dev We don't need to store data about previous epochs, to simplify logic we only store data about the current epoch\n    EpochInfo public epoch;\n    /// @notice All the LP pools, active and inactive\n    PoolInfo[] public poolInfo;\n    /// @notice User staking positions, divided by PID\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice Sum of the allocation points for all the pools\n    /// @dev Used to calculate the share of `rewardPerBlock` for each pool.\n    uint256 public totalAllocPoint;\n\n    /// @dev User's (total) withdrawable rewards\n    mapping(address => uint256) private userRewards;\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _jpeg The reward token\n    constructor(address _jpeg) {\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the LP farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting liquidity providers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to start a new epoch. Can only be called when there's no ongoing epoch\n    /// @param _startBlock The new epoch's start block. Has to be greater than the previous epoch's `endBlock`\n    /// @param _endBlock The new epoch's end block. Has to be greater than `_startBlock`\n    /// @param _rewardPerBlock The new epoch's amount of rewards to distribute per block. Must be greater than 0\n    function newEpoch(\n        uint256 _startBlock,\n        uint256 _endBlock,\n        uint256 _rewardPerBlock\n    ) external onlyOwner {\n        require(_startBlock >= block.number, \"Invalid start block\");\n        require(_endBlock > _startBlock, \"Invalid end block\");\n        require(_rewardPerBlock > 0, \"Invalid reward per block\");\n\n        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`\n        _massUpdatePools();\n\n        uint256 remainingRewards = epoch.rewardPerBlock *\n            (epoch.endBlock - _blockNumber());\n        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);\n\n        epoch.startBlock = _startBlock;\n        epoch.endBlock = _endBlock;\n        epoch.rewardPerBlock = _rewardPerBlock;\n\n        if (remainingRewards > newRewards) {\n            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);\n        } else if (remainingRewards < newRewards) {\n            jpeg.safeTransferFrom(\n                msg.sender,\n                address(this),\n                newRewards - remainingRewards\n            );\n        }\n    }\n\n    /// @notice Allows the owner to add a new pool\n    /// @param _allocPoint Allocation points to assign to the new pool\n    /// @param _lpToken The LP token accepted by the new pool\n    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 lastRewardBlock = _blockNumber();\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accRewardPerShare: 0\n            })\n        );\n    }\n\n    /// @notice Allows the owner to change a pool's allocation points\n    /// @param _pid The pool id of the pool to modify\n    /// @param _allocPoint The new allocation points\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if (prevAllocPoint != _allocPoint) {\n            totalAllocPoint = totalAllocPoint - prevAllocPoint + _allocPoint;\n        }\n    }\n\n    /// @notice Returns the number of pools available\n    /// @return The length of the `poolInfo` array\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim from the pool with id `_pid`\n    /// @param _pid The pool id\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable from `_pid` by user `_user`\n    function pendingReward(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (blockNumber > lastRewardBlock && lpSupply != 0) {\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            accRewardPerShare += reward / lpSupply;\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of LP tokens in the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _pid The id of the pool to deposit into\n    /// @param _amount The amount of LP tokens to deposit\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n        user.amount = user.amount + _amount;\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of LP tokens from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _pid The id of the pool to withdraw from\n    /// @param _amount The amount of LP tokens to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"insufficient_amount\");\n\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        user.amount -= _amount;\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @dev Normalizes the current `block.number`. See {_normalizeBlockNumber} for more info\n    /// @return Normalized `block.number`\n    function _blockNumber() internal view returns (uint256) {\n        return _normalizeBlockNumber(block.number);\n    }\n\n    /// @dev Normalizes `blockNumber` to fit within the bounds of an epoch.\n    /// This is done to ensure that no rewards are distributed for staking outside of an epoch without modifying the reward logic.\n    /// For example:\n    /// `blockNumber` is 1100, the epoch's `endBlock` is 1000. In this case the function would return 1000. If this value were to be used\n    /// in the {_updatePool} function, where the pool's `lastRewardBlock` is 990, only the rewards from block 990 to block 1000 would be distributed\n    /// @return Normalized `blockNumber`\n    function _normalizeBlockNumber(uint256 blockNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        if (blockNumber < epoch.startBlock) return epoch.startBlock;\n\n        if (blockNumber > epoch.endBlock) return epoch.endBlock;\n\n        return blockNumber;\n    }\n\n    /// @dev Calls {_updatePool} for every pool\n    function _massUpdatePools() internal {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(pid);\n        }\n    }\n\n    /// @dev Updates the state of the pool at index `_pid`\n    /// @param _pid The pool to update\n    function _updatePool(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (pool.allocPoint == 0) {\n            return;\n        }\n\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        if (blockNumber <= lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = blockNumber;\n            return;\n        }\n        uint256 reward = ((blockNumber - lastRewardBlock) *\n            epoch.rewardPerBlock *\n            1e36 *\n            pool.allocPoint) / totalAllocPoint;\n        pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n        pool.lastRewardBlock = blockNumber;\n    }\n\n    /// @dev Updates `msg.sender`'s claimable rewards by adding pending rewards from `_pid`\n    /// @param _pid The pool to withdraw rewards from\n    function _withdrawReward(uint256 _pid) internal returns (uint256) {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 pending = (user.amount *\n            (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n        if (pending > 0) {\n            userRewards[msg.sender] += pending;\n        }\n\n        user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @notice Allows users to claim rewards from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    /// @param _pid The pool to claim rewards from\n    function claim(uint256 _pid) external nonReentrant noContract(msg.sender) {\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit Claim(msg.sender, _pid, rewards);\n    }\n\n    /// @notice Allows users to claim rewards from all pools. Non whitelisted contracts can't call this function\n    /// @dev Emits a {ClaimAll} event\n    function claimAll() external nonReentrant noContract(msg.sender) {\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            _updatePool(i);\n            _withdrawReward(i);\n        }\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit ClaimAll(msg.sender, rewards);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault\n/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).\n/// Non whitelisted contracts can't deposit/withdraw.\n/// Owner is DAO\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    ERC20 public immutable token;\n    IController public controller;\n    \n    address public farm;\n    \n    Rate internal availableTokensRate;\n\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _token The token managed by this vault\n    /// @param _controller The JPEG'd strategies controller\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.\n    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return token.decimals();\n    }\n\n    /// @return The total amount of tokens managed by this vault and the underlying strategy\n    function balance() public view returns (uint256) {\n        return\n            token.balanceOf(address(this)) +\n            controller.balanceOf(address(token));\n    }\n\n    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}\n    function balanceOfJPEG() external view returns (uint256) {\n        return controller.balanceOfJPEG(address(token));\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow\n    /// @param _rate The new rate\n    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {\n        require(\n            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\n            \"INVALID_RATE\"\n        );\n        availableTokensRate = _rate;\n    }\n\n    /// @notice ALlows the owner to set this vault's controller\n    /// @param _controller The new controller\n    function setController(address _controller) public onlyOwner {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        controller = IController(_controller);\n    }\n\n    /// @notice Allows the owner to set the yVault LP farm\n    /// @param _farm The new farm\n    function setFarmingPool(address _farm) public onlyOwner {\n        require(_farm != address(0), \"INVALID_FARMING_POOL\");\n        farm = _farm;\n    }\n\n    /// @return How much the vault allows to be borrowed by the underlying strategy.\n    /// Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view returns (uint256) {\n        return\n            (token.balanceOf(address(this)) * availableTokensRate.numerator) /\n            availableTokensRate.denominator;\n    }\n\n    /// @notice Deposits `token` into the underlying strategy\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n\n    /// @notice Allows users to deposit their entire `token` balance\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to deposit `token`. Contracts can't call this function\n    /// @param _amount The amount to deposit\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw all their deposited balance\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to withdraw tokens. Contracts can't call this function\n    /// @param _shares The amount of shares to burn\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n\n    /// @notice Allows anyone to withdraw JPEG to `farm` \n    function withdrawJPEG() external {\n        require(farm != address(0), \"NO_FARM\");\n        controller.withdrawJPEG(address(token), farm);\n    }\n\n    /// @return The underlying tokens per share\n    function getPricePerFullShare() external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) return 0;\n        return (balance() * 1e18) / supply;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "CodeNames": [
            "LPFarming.sol",
            "yVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "jsx\nit.only(\"will cause 0 share issuance\", async () = {\n  // mint 10k + 1 wei tokens to user1\n  // mint 10k tokens to owner\n  let depositAmount = units(10_000);\n  await token.mint(user1.address, depositAmount.add(1));\n  await token.mint(owner.address, depositAmount);\n  // token approval to yVault\n  await token.connect(user1).approve(yVault.address, 1);\n  await token.connect(owner).approve(yVault.address, depositAmount);\n  \n  // 1. user1 mints 1 wei = 1 share\n  await yVault.connect(user1).deposit(1);\n  \n  // 2. do huge transfer of 10k to strategy\n  // to greatly inflate share price (1 share = 10k + 1 wei)\n  await token.connect(user1).transfer(strategy.address, depositAmount);\n  \n  // 3. owner deposits 10k\n  await yVault.connect(owner).deposit(depositAmount);\n  // receives 0 shares in return\n  expect(await yVault.balanceOf(owner.address)).to.equal(0);\n\n  // user1 withdraws both his and owner's deposits\n  // total amt: 20k + 1 wei\n  await expect(() = yVault.connect(user1).withdrawAll())\n    .to.changeTokenBalance(token, user1, depositAmount.mul(2).add(1));\n});\n"
                ],
                "Type": " yVault: First depositor can break minting of shares",
                "Description": "\nyVault.sol#L148-L153(https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L148-L153)<br\n\nThe attack vector and impact is the same as TOB-YEARN-003(https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.\n\n\n*   Attacker deposits 1 wei to mint 1 share\n*   Attacker transfers exorbitant amount to the StrategyPUSDConvex contract to greatly inflate the share\u2019s price. Note that the strategy deposits its entire balance into Convex when its deposit() function is called.\n*   Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.\n\nInsert this test into yVault.ts(https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/yVault.ts).\n\njsx\nit.only(\"will cause 0 share issuance\", async () = {\n  // mint 10k + 1 wei tokens to user1\n  // mint 10k tokens to owner\n  let depositAmount = units(10_000);\n  await token.mint(user1.address, depositAmount.add(1));\n  await token.mint(owner.address, depositAmount);\n  // token approval to yVault\n  await token.connect(user1).approve(yVault.address, 1);\n  await token.connect(owner).approve(yVault.address, depositAmount);\n  \n  // 1. user1 mints 1 wei = 1 share\n  await yVault.connect(user1).deposit(1);\n  \n  // 2. do huge transfer of 10k to strategy\n  // to greatly inflate share price (1 share = 10k + 1 wei)\n  await token.connect(user1).transfer(strategy.address, depositAmount);\n  \n  // 3. owner deposits 10k\n  await yVault.connect(owner).deposit(depositAmount);\n  // receives 0 shares in return\n  expect(await yVault.balanceOf(owner.address)).to.equal(0);\n\n  // user1 withdraws both his and owner's deposits\n  // total amt: 20k + 1 wei\n  await expect(() = yVault.connect(user1).withdrawAll())\n    .to.changeTokenBalance(token, user1, depositAmount.mul(2).add(1));\n});\n\n\n",
                "Repair": "\n*   Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address(https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when totalSupply() == 0, send the first min liquidity LP tokens to the zero address to enable share dilution.\n*   Ensure the number of shares to be minted is non-zero: require(_shares != 0, \"zero shares minted\");\n\nspaghettieth (JPEG'd) confirmed, but disagreed with High severity(https://github.com/code-423n4/2022-04-jpegd-findings/issues/12)\n\nspaghettieth (JPEG'd) resolved and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/12#issuecomment-1099249025):\n  Fixed in jpegd/core#16(https://github.com/jpegd/core/pull/16).\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "balance() =",
                    "shares = (_amount * supply) / balanceBefore =",
                    "deposit(",
                    "deposit",
                    "withdraw(",
                    "backingTokens = (balance() * _shares) / supply =",
                    "balanceBefore =",
                    "supply =",
                    "token"
                ],
                "Type": " Reentrancy issue in  yVault.deposit ",
                "Description": "\nyVault.sol#L144-L145(https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145)<br\n\nIn deposit, the balance is cached and then a token.transferFrom is triggered which can lead to exploits if the token is a token that gives control to the sender, like ERC777 tokens.\n\n\nInitial state: balance() = 1000, shares supply = 1000.\nDepositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.\n\n*   Outer deposit(500): balanceBefore = 1000. Control is given to attacker ...\n*   Inner deposit(500): balanceBefore = 1000. shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500 shares are minted ...\n*   Outer deposit(500) continues with the mint: shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750 are minted.\n*   Withdrawing the 500 + 750 = 1250 shares via withdraw(1250), the attacker receives backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111. The attacker makes a profit of 1111 1000 = 111 tokens.\n*   They repeat the attack until the vault is drained.\n\n",
                "Repair": "\nThe safeTransferFrom should be the last call in deposit.\n\nspaghettieth (JPEG'd) confirmed(https://github.com/code-423n4/2022-04-jpegd-findings/issues/81)\n\nspaghettieth (JPEG'd) resolved and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/81#issuecomment-1099250750):\n  Fixed in jpegd/core#19(https://github.com/jpegd/core/pull/19).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IJPEGLock.sol\";\n\n/// @title NFT lending vault\n/// @notice This contracts allows users to borrow PUSD using NFTs as collateral.\n/// The floor price of the NFT collection is fetched using a chainlink oracle, while some other more valuable traits\n/// can have an higher price set by the DAO. Users can also increase the price (and thus the borrow limit) of their\n/// NFT by submitting a governance proposal. If the proposal is approved the user can lock a percentage of the new price\n/// worth of JPEG to make it effective\ncontract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    event PositionOpened(address indexed owner, uint256 indexed index);\n    event Borrowed(\n        address indexed owner,\n        uint256 indexed index,\n        uint256 amount\n    );\n    event Repaid(address indexed owner, uint256 indexed index, uint256 amount);\n    event PositionClosed(address indexed owner, uint256 indexed index);\n    event Liquidated(\n        address indexed liquidator,\n        address indexed owner,\n        uint256 indexed index,\n        bool insured\n    );\n    event Repurchased(address indexed owner, uint256 indexed index);\n    event InsuranceExpired(address indexed owner, uint256 indexed index);\n\n    enum BorrowType {\n        NOT_CONFIRMED,\n        NON_INSURANCE,\n        USE_INSURANCE\n    }\n\n    struct Position {\n        BorrowType borrowType;\n        uint256 debtPrincipal;\n        uint256 debtPortion;\n        uint256 debtAmountForRepurchase;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    struct VaultSettings {\n        Rate debtInterestApr;\n        Rate creditLimitRate;\n        Rate liquidationLimitRate;\n        Rate valueIncreaseLockRate;\n        Rate organizationFeeRate;\n        Rate insurancePurchaseRate;\n        Rate insuranceLiquidationPenaltyRate;\n        uint256 insuraceRepurchaseTimeLimit;\n        uint256 borrowAmountCap;\n    }\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n\n    IStableCoin public stablecoin;\n    /// @notice Chainlink ETH/USD price feed\n    IAggregatorV3Interface public ethAggregator;\n    /// @notice Chainlink JPEG/USD price feed\n    IAggregatorV3Interface public jpegAggregator;\n    /// @notice Chainlink NFT floor oracle\n    IAggregatorV3Interface public floorOracle;\n    /// @notice Chainlink NFT fallback floor oracle\n    IAggregatorV3Interface public fallbackOracle;\n    /// @notice JPEGLocker, used by this contract to lock JPEG and increase the value of an NFT\n    IJPEGLock public jpegLocker;\n    IERC721Upgradeable public nftContract;\n\n    /// @notice If true, the floor price won't be fetched using the Chainlink oracle but\n    /// a value set by the DAO will be used instead\n    bool public daoFloorOverride;\n    // @notice If true, the floor price will be fetched using the fallback oracle\n    bool public useFallbackOracle;\n    /// @notice Total outstanding debt\n    uint256 public totalDebtAmount;\n    /// @dev Last time debt was accrued. See {accrue} for more info\n    uint256 public totalDebtAccruedAt;\n    uint256 public totalFeeCollected;\n    uint256 internal totalDebtPortion;\n\n    VaultSettings public settings;\n\n    /// @dev Keeps track of all the NFTs used as collateral for positions\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n    //bytes32(0) is floor\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n    /// @dev Checks if the provided NFT index is valid\n    /// @param nftIndex The index to check\n    modifier validNFTIndex(uint256 nftIndex) {\n        //The standard OZ ERC721 implementation of ownerOf reverts on a non existing nft isntead of returning address(0)\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n\n    /// @param _stablecoin PUSD address\n    /// @param _nftContract The NFT contrat address. It could also be the address of an helper contract\n    /// if the target NFT isn't an ERC721 (CryptoPunks as an example)\n    /// @param _ethAggregator Chainlink ETH/USD price feed address\n    /// @param _jpegAggregator Chainlink JPEG/USD price feed address\n    /// @param _floorOracle Chainlink floor oracle address\n    /// @param _fallbackOracle Chainlink fallback floor oracle address\n    /// @param _typeInitializers Used to initialize NFT categories with their value and NFT indexes.\n    /// Floor NFT shouldn't be initialized this way\n    /// @param _jpegLocker JPEGLock address\n    /// @param _settings Initial settings used by the contract\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    /// @dev The {accrue} function updates the contract's state by calculating\n    /// the additional interest accrued since the last state update\n    function accrue() public {\n        uint256 additionalInterest = _calculateAdditionalInterest();\n\n        totalDebtAccruedAt = block.timestamp;\n\n        totalDebtAmount += additionalInterest;\n        totalFeeCollected += additionalInterest;\n    }\n\n    /// @notice Allows the DAO to change the total debt cap\n    /// @param _borrowAmountCap New total debt cap\n    function setBorrowAmountCap(uint256 _borrowAmountCap)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        settings.borrowAmountCap = _borrowAmountCap;\n    }\n\n    /// @notice Allows the DAO to change the interest APR on borrows\n    /// @param _debtInterestApr The new interest rate\n    function setDebtInterestApr(Rate memory _debtInterestApr)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_debtInterestApr);\n        settings.debtInterestApr = _debtInterestApr;\n    }\n\n    /// @notice Allows the DAO to change the amount of JPEG needed to increase the value of an NFT relative to the desired value\n    /// @param _valueIncreaseLockRate The new rate\n    function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_valueIncreaseLockRate);\n        settings.valueIncreaseLockRate = _valueIncreaseLockRate;\n    }\n\n    /// @notice Allows the DAO to change the max debt to collateral rate for a position\n    /// @param _creditLimitRate The new rate\n    function setCreditLimitRate(Rate memory _creditLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_creditLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            _creditLimitRate,\n            settings.liquidationLimitRate\n        );\n\n        settings.creditLimitRate = _creditLimitRate;\n    }\n\n    /// @notice Allows the DAO to change the minimum debt to collateral rate for a position to be market as liquidatable\n    /// @param _liquidationLimitRate The new rate\n    function setLiquidationLimitRate(Rate memory _liquidationLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_liquidationLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            settings.creditLimitRate,\n            _liquidationLimitRate\n        );\n\n        settings.liquidationLimitRate = _liquidationLimitRate;\n    }\n\n    /// @notice Allows the DAO to toggle the fallback oracle\n    /// @param _useFallback Whether to use the fallback oracle\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    /// @notice Allows the DAO to change the amount of time JPEG tokens need to be locked to change the value of an NFT\n    /// @param _newLockTime The amount new lock time amount\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n    /// @notice Allows the DAO to bypass the floor oracle and override the NFT floor value\n    /// @param _newFloor The new floor\n    function overrideFloor(uint256 _newFloor) external onlyRole(DAO_ROLE) {\n        require(_newFloor > 0, \"Invalid floor\");\n        nftTypeValueETH[bytes32(0)] = _newFloor;\n        daoFloorOverride = true;\n    }\n\n    /// @notice Allows the DAO to stop overriding floor\n    function disableFloorOverride() external onlyRole(DAO_ROLE) {\n        daoFloorOverride = false;\n    }\n\n    /// @notice Allows the DAO to change the static borrow fee\n    /// @param _organizationFeeRate The new fee rate\n    function setOrganizationFeeRate(Rate memory _organizationFeeRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_organizationFeeRate);\n        settings.organizationFeeRate = _organizationFeeRate;\n    }\n\n    /// @notice Allows the DAO to change the cost of insurance\n    /// @param _insurancePurchaseRate The new insurance fee rate\n    function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_insurancePurchaseRate);\n        settings.insurancePurchaseRate = _insurancePurchaseRate;\n    }\n\n    /// @notice Allows the DAO to change the repurchase penalty rate in case of liquidation of an insured NFT\n    /// @param _insuranceLiquidationPenaltyRate The new rate\n    function setInsuranceLiquidationPenaltyRate(\n        Rate memory _insuranceLiquidationPenaltyRate\n    ) external onlyRole(DAO_ROLE) {\n        _validateRate(_insuranceLiquidationPenaltyRate);\n        settings\n            .insuranceLiquidationPenaltyRate = _insuranceLiquidationPenaltyRate;\n    }\n\n    /// @notice Allows the DAO to add an NFT to a specific price category\n    /// @param _nftIndex The index to add to the category\n    /// @param _type The category hash\n    function setNFTType(uint256 _nftIndex, bytes32 _type)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        require(\n            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\n            \"invalid_nftType\"\n        );\n        nftTypes[_nftIndex] = _type;\n    }\n\n    /// @notice Allows the DAO to change the value of an NFT category\n    /// @param _type The category hash\n    /// @param _amountETH The new value, in ETH\n    function setNFTTypeValueETH(bytes32 _type, uint256 _amountETH)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        nftTypeValueETH[_type] = _amountETH;\n    }\n\n    /// @notice Allows the DAO to set the value in ETH of the NFT at index `_nftIndex`.\n    /// A JPEG deposit by a user is required afterwards. See {finalizePendingNFTValueETH} for more details\n    /// @param _nftIndex The index of the NFT to change the value of\n    /// @param _amountETH The new desired ETH value\n    function setPendingNFTValueETH(uint256 _nftIndex, uint256 _amountETH)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        pendingNFTValueETH[_nftIndex] = _amountETH;\n    }\n\n    /// @notice Allows a user to lock up JPEG to make the change in value of an NFT effective.\n    /// Can only be called after {setPendingNFTValueETH}, which requires a governance vote.\n    /// @dev The amount of JPEG that needs to be locked is calculated by applying `valueIncreaseLockRate`\n    /// to the new credit limit of the NFT\n    /// @param _nftIndex The index of the NFT\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n\n    /// @dev Validates the credit limit rate and the liquidation limit rate.\n    /// The credit limit rate must be less than the liquidation rate\n    /// @param _creditLimitRate The credit limit rate to validate\n    /// @param _liquidationLimitRate The liquidation limit rate\n    function _validateCreditLimitAndLiquidationRate(\n        Rate memory _creditLimitRate,\n        Rate memory _liquidationLimitRate\n    ) internal pure {\n        require(\n            _liquidationLimitRate.numerator * _creditLimitRate.denominator >\n                _creditLimitRate.numerator * _liquidationLimitRate.denominator,\n            \"credit_rate_exceeds_or_equals_liquidation_rate\"\n        );\n    }\n\n    /// @dev Validates a rate. The denominator must be greater than zero and greater than or equal to the numerator.\n    /// @param rate The rate to validate\n    function _validateRate(Rate memory rate) internal pure {\n        require(\n            rate.denominator > 0 && rate.denominator >= rate.numerator,\n            \"invalid_rate\"\n        );\n    }\n\n    /// @dev Returns the value in ETH of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT, 18 decimals\n    function _getNFTValueETH(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        bytes32 nftType = nftTypes[_nftIndex];\n\n        if (nftType == bytes32(0) && !daoFloorOverride) {\n            return\n                _normalizeAggregatorAnswer(\n                    useFallbackOracle ? fallbackOracle : floorOracle\n                );\n        } else if (nftType == CUSTOM_NFT_HASH) return nftValueETH[_nftIndex];\n\n        return nftTypeValueETH[nftType];\n    }\n\n    /// @dev Returns the value in USD of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT in USD, 18 decimals\n    function _getNFTValueUSD(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 nft_value = _getNFTValueETH(_nftIndex);\n        return (nft_value * _ethPriceUSD()) / 1 ether;\n    }\n\n    /// @dev Returns the current ETH price in USD\n    /// @return The current ETH price, 18 decimals\n    function _ethPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(ethAggregator);\n    }\n\n    /// @dev Returns the current JPEG price in USD\n    /// @return The current JPEG price, 18 decimals\n    function _jpegPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(jpegAggregator);\n    }\n\n    /// @dev Fetches and converts to 18 decimals precision the latest answer of a Chainlink aggregator\n    /// @param aggregator The aggregator to fetch the answer from\n    /// @return The latest aggregator answer, normalized\n    function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n        internal\n        view\n        returns (uint256)\n    {\n        int256 answer = aggregator.latestAnswer();\n        uint8 decimals = aggregator.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n        //converts the answer to have 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    struct NFTInfo {\n        uint256 index;\n        bytes32 nftType;\n        address owner;\n        uint256 nftValueETH;\n        uint256 nftValueUSD;\n    }\n\n    /// @notice Returns data relative to the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT index\n    /// @return nftInfo The data relative to the NFT\n    function getNFTInfo(uint256 _nftIndex)\n        external\n        view\n        returns (NFTInfo memory nftInfo)\n    {\n        nftInfo = NFTInfo(\n            _nftIndex,\n            nftTypes[_nftIndex],\n            nftContract.ownerOf(_nftIndex),\n            _getNFTValueETH(_nftIndex),\n            _getNFTValueUSD(_nftIndex)\n        );\n    }\n\n    /// @dev Returns the credit limit of an NFT\n    /// @param _nftIndex The NFT to return credit limit of\n    /// @return The NFT credit limit\n    function _getCreditLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator;\n    }\n\n    /// @dev Returns the minimum amount of debt necessary to liquidate an NFT\n    /// @param _nftIndex The index of the NFT\n    /// @return The minimum amount of debt to liquidate the NFT\n    function _getLiquidationLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.liquidationLimitRate.numerator) /\n            settings.liquidationLimitRate.denominator;\n    }\n\n    /// @dev Calculates current outstanding debt of an NFT\n    /// @param _nftIndex The NFT to calculate the outstanding debt of\n    /// @return The outstanding debt value\n    function _getDebtAmount(uint256 _nftIndex) internal view returns (uint256) {\n        uint256 calculatedDebt = _calculateDebt(\n            totalDebtAmount,\n            positions[_nftIndex].debtPortion,\n            totalDebtPortion\n        );\n\n        uint256 principal = positions[_nftIndex].debtPrincipal;\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal when the accrue() function isn't called\n        //in between the first borrow and the _calculateDebt call.\n        return principal > calculatedDebt ? principal : calculatedDebt;\n    }\n\n    /// @dev Calculates the total debt of a position given the global debt, the user's portion of the debt and the total user portions\n    /// @param total The global outstanding debt\n    /// @param userPortion The user's portion of debt\n    /// @param totalPortion The total user portions of debt\n    /// @return The outstanding debt of the position\n    function _calculateDebt(\n        uint256 total,\n        uint256 userPortion,\n        uint256 totalPortion\n    ) internal pure returns (uint256) {\n        return totalPortion == 0 ? 0 : (total * userPortion) / totalPortion;\n    }\n\n    /// @dev Opens a position\n    /// Emits a {PositionOpened} event\n    /// @param _owner The owner of the position to open\n    /// @param _nftIndex The NFT used as collateral for the position\n    function _openPosition(address _owner, uint256 _nftIndex) internal {\n        nftContract.transferFrom(_owner, address(this), _nftIndex);\n\n        positions[_nftIndex] = Position({\n            borrowType: BorrowType.NOT_CONFIRMED,\n            debtPrincipal: 0,\n            debtPortion: 0,\n            debtAmountForRepurchase: 0,\n            liquidatedAt: 0,\n            liquidator: address(0)\n        });\n        positionOwner[_nftIndex] = _owner;\n        positionIndexes.add(_nftIndex);\n\n        emit PositionOpened(_owner, _nftIndex);\n    }\n\n    /// @dev Calculates the additional global interest since last time the contract's state was updated by calling {accrue}\n    /// @return The additional interest value\n    function _calculateAdditionalInterest() internal view returns (uint256) {\n        // Number of seconds since {accrue} was called\n        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;\n        if (elapsedTime == 0) {\n            return 0;\n        }\n\n        if (totalDebtAmount == 0) {\n            return 0;\n        }\n\n        // Accrue interest\n        uint256 interestPerYear = (totalDebtAmount *\n            settings.debtInterestApr.numerator) /\n            settings.debtInterestApr.denominator;\n        uint256 interestPerSec = interestPerYear / 365 days;\n\n        return elapsedTime * interestPerSec;\n    }\n\n    /// @notice Returns the number of open positions\n    /// @return The number of open positions\n    function totalPositions() external view returns (uint256) {\n        return positionIndexes.length();\n    }\n\n    /// @notice Returns all open position NFT indexes\n    /// @return The open position NFT indexes\n    function openPositionsIndexes() external view returns (uint256[] memory) {\n        return positionIndexes.values();\n    }\n\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest;\n        BorrowType borrowType;\n        bool liquidatable;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    /// @notice Returns data relative to a postition, existing or not\n    /// @param _nftIndex The index of the NFT used as collateral for the position\n    /// @return preview See assignment below\n    function showPosition(uint256 _nftIndex)\n        external\n        view\n        validNFTIndex(_nftIndex)\n        returns (PositionPreview memory preview)\n    {\n        address posOwner = positionOwner[_nftIndex];\n\n        uint256 debtPrincipal = positions[_nftIndex].debtPrincipal;\n        uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0\n            ? positions[_nftIndex].debtAmountForRepurchase //calculate updated debt\n            : _calculateDebt(\n                totalDebtAmount + _calculateAdditionalInterest(),\n                positions[_nftIndex].debtPortion,\n                totalDebtPortion\n            );\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal if no time has elapsed in between the first borrow\n        //and the _calculateDebt call.\n        if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;\n\n        preview = PositionPreview({\n            owner: posOwner, //the owner of the position, `address(0)` if the position doesn't exists\n            nftIndex: _nftIndex, //the NFT used as collateral for the position\n            nftType: nftTypes[_nftIndex], //the type of the NFT\n            nftValueUSD: _getNFTValueUSD(_nftIndex), //the value in USD of the NFT\n            vaultSettings: settings, //the current vault's settings\n            creditLimit: _getCreditLimit(_nftIndex), //the NFT's credit limit\n            debtPrincipal: debtPrincipal, //the debt principal for the position, `0` if the position doesn't exists\n            debtInterest: debtAmount - debtPrincipal, //the interest of the position\n            borrowType: positions[_nftIndex].borrowType, //the insurance type of the position, `NOT_CONFIRMED` if it doesn't exist\n            liquidatable: positions[_nftIndex].liquidatedAt == 0 &&\n                debtAmount >= _getLiquidationLimit(_nftIndex), //if the position can be liquidated\n            liquidatedAt: positions[_nftIndex].liquidatedAt, //if the position has been liquidated and it had insurance, the timestamp at which the liquidation happened\n            liquidator: positions[_nftIndex].liquidator //if the position has been liquidated and it had insurance, the address of the liquidator\n        });\n    }\n\n    /// @notice Allows users to open positions and borrow using an NFT\n    /// @dev emits a {Borrowed} event\n    /// @param _nftIndex The index of the NFT to be used as collateral\n    /// @param _amount The amount of PUSD to be borrowed. Note that the user will receive less than the amount requested,\n    /// the borrow fee and insurance automatically get removed from the amount borrowed\n    /// @param _useInsurance Whereter to open an insured position. In case the position has already been opened previously,\n    /// this parameter needs to match the previous insurance mode. To change insurance mode, a user needs to close and reopen the position\n    function borrow(\n        uint256 _nftIndex,\n        uint256 _amount,\n        bool _useInsurance\n    ) external validNFTIndex(_nftIndex) nonReentrant {\n        accrue();\n\n        require(\n            msg.sender == positionOwner[_nftIndex] ||\n                address(0) == positionOwner[_nftIndex],\n            \"unauthorized\"\n        );\n        require(_amount > 0, \"invalid_amount\");\n        require(\n            totalDebtAmount + _amount <= settings.borrowAmountCap,\n            \"debt_cap\"\n        );\n\n        if (positionOwner[_nftIndex] == address(0)) {\n            _openPosition(msg.sender, _nftIndex);\n        }\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n        require(\n            position.borrowType == BorrowType.NOT_CONFIRMED ||\n                (position.borrowType == BorrowType.USE_INSURANCE &&\n                    _useInsurance) ||\n                (position.borrowType == BorrowType.NON_INSURANCE &&\n                    !_useInsurance),\n            \"invalid_insurance_mode\"\n        );\n\n        uint256 creditLimit = _getCreditLimit(_nftIndex);\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount + _amount <= creditLimit, \"insufficient_credit\");\n\n        //calculate the borrow fee\n        uint256 organizationFee = (_amount *\n            settings.organizationFeeRate.numerator) /\n            settings.organizationFeeRate.denominator;\n\n        uint256 feeAmount = organizationFee;\n        //if the position is insured, calculate the insurance fee\n        if (position.borrowType == BorrowType.USE_INSURANCE || _useInsurance) {\n            feeAmount +=\n                (_amount * settings.insurancePurchaseRate.numerator) /\n                settings.insurancePurchaseRate.denominator;\n        }\n        totalFeeCollected += feeAmount;\n        //subtract the fee from the amount borrowed\n        stablecoin.mint(msg.sender, _amount - feeAmount);\n\n        if (position.borrowType == BorrowType.NOT_CONFIRMED) {\n            position.borrowType = _useInsurance\n                ? BorrowType.USE_INSURANCE\n                : BorrowType.NON_INSURANCE;\n        }\n\n        // update debt portion\n        if (totalDebtPortion == 0) {\n            totalDebtPortion = _amount;\n            position.debtPortion = _amount;\n        } else {\n            uint256 plusPortion = (totalDebtPortion * _amount) /\n                totalDebtAmount;\n            totalDebtPortion += plusPortion;\n            position.debtPortion += plusPortion;\n        }\n        position.debtPrincipal += _amount;\n        totalDebtAmount += _amount;\n\n        emit Borrowed(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows users to repay a portion/all of their debt. Note that since interest increases every second,\n    /// a user wanting to repay all of their debt should repay for an amount greater than their current debt to account for the\n    /// additional interest while the repay transaction is pending, the contract will only take what's necessary to repay all the debt\n    /// @dev Emits a {Repaid} event\n    /// @param _nftIndex The NFT used as collateral for the position\n    /// @param _amount The amount of debt to repay. If greater than the position's outstanding debt, only the amount necessary to repay all the debt will be taken\n    function repay(uint256 _nftIndex, uint256 _amount)\n        external\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_amount > 0, \"invalid_amount\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount > 0, \"position_not_borrowed\");\n\n        uint256 debtPrincipal = position.debtPrincipal;\n        uint256 debtInterest = debtAmount - debtPrincipal;\n\n        _amount = _amount > debtAmount ? debtAmount : _amount;\n\n        // burn all payment, the interest is sent to the DAO using the {collect} function\n        stablecoin.burnFrom(msg.sender, _amount);\n\n        uint256 paidPrincipal = _amount > debtInterest\n            ? _amount - debtInterest\n            : 0;\n\n        uint256 minusPortion = paidPrincipal == debtPrincipal\n            ? position.debtPortion\n            : (totalDebtPortion * _amount) / totalDebtAmount;\n\n        totalDebtPortion -= minusPortion;\n        position.debtPortion -= minusPortion;\n        position.debtPrincipal -= paidPrincipal;\n        totalDebtAmount -= _amount;\n\n        emit Repaid(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows a user to close a position and get their collateral back, if the position's outstanding debt is 0\n    /// @dev Emits a {PositionClosed} event\n    /// @param _nftIndex The index of the NFT used as collateral\n    function closePosition(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_getDebtAmount(_nftIndex) == 0, \"position_not_repaid\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        // transfer nft back to owner if nft was deposited\n        if (nftContract.ownerOf(_nftIndex) == address(this)) {\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit PositionClosed(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows members of the `LIQUIDATOR_ROLE` to liquidate a position. Positions can only be liquidated\n    /// once their debt amount exceeds the minimum liquidation debt to collateral value rate.\n    /// In order to liquidate a position, the liquidator needs to repay the user's outstanding debt.\n    /// If the position is not insured, it's closed immediately and the collateral is sent to the liquidator.\n    /// If the position is insured, the position remains open (interest doesn't increase) and the owner of the position has a certain amount of time\n    /// (`insuranceRepurchaseTimeLimit`) to fully repay the liquidator and pay an additional liquidation fee (`insuranceLiquidationPenaltyRate`), if this\n    /// is done in time the user gets back their collateral and their position is automatically closed. If the user doesn't repurchase their collateral\n    /// before the time limit passes, the liquidator can claim the liquidated NFT and the position is closed\n    /// @dev Emits a {Liquidated} event\n    /// @param _nftIndex The NFT to liquidate\n    function liquidate(uint256 _nftIndex)\n        external\n        onlyRole(LIQUIDATOR_ROLE)\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        address posOwner = positionOwner[_nftIndex];\n        require(posOwner != address(0), \"position_not_exist\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(\n            debtAmount >= _getLiquidationLimit(_nftIndex),\n            \"position_not_liquidatable\"\n        );\n\n        // burn all payment\n        stablecoin.burnFrom(msg.sender, debtAmount);\n\n        // update debt portion\n        totalDebtPortion -= position.debtPortion;\n        totalDebtAmount -= debtAmount;\n        position.debtPortion = 0;\n\n        bool insured = position.borrowType == BorrowType.USE_INSURANCE;\n        if (insured) {\n            position.debtAmountForRepurchase = debtAmount;\n            position.liquidatedAt = block.timestamp;\n            position.liquidator = msg.sender;\n        } else {\n            // transfer nft to liquidator\n            positionOwner[_nftIndex] = address(0);\n            delete positions[_nftIndex];\n            positionIndexes.remove(_nftIndex);\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit Liquidated(msg.sender, posOwner, _nftIndex, insured);\n    }\n\n    /// @notice Allows liquidated users who purchased insurance to repurchase their collateral within the time limit\n    /// defined with the `insuranceRepurchaseTimeLimit`. The user needs to pay the liquidator the total amount of debt\n    /// the position had at the time of liquidation, plus an insurance liquidation fee defined with `insuranceLiquidationPenaltyRate`\n    /// @dev Emits a {Repurchased} event\n    /// @param _nftIndex The NFT to repurchase\n    function repurchase(uint256 _nftIndex) external validNFTIndex(_nftIndex) {\n        Position memory position = positions[_nftIndex];\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.borrowType == BorrowType.USE_INSURANCE,\n            \"non_insurance\"\n        );\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit >=\n                block.timestamp,\n            \"insurance_expired\"\n        );\n\n        uint256 debtAmount = position.debtAmountForRepurchase;\n        uint256 penalty = (debtAmount *\n            settings.insuranceLiquidationPenaltyRate.numerator) /\n            settings.insuranceLiquidationPenaltyRate.denominator;\n\n        // transfer payment to liquidator\n        stablecoin.transferFrom(\n            msg.sender,\n            position.liquidator,\n            debtAmount + penalty\n        );\n\n        // transfer nft to user\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit Repurchased(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows the liquidator who liquidated the insured position with NFT at index `_nftIndex` to claim the position's collateral\n    /// after the time period defined with `insuranceRepurchaseTimeLimit` has expired and the position owner has not repurchased the collateral.\n    /// @dev Emits an {InsuranceExpired} event\n    /// @param _nftIndex The NFT to claim\n    function claimExpiredInsuranceNFT(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        Position memory position = positions[_nftIndex];\n        address owner = positionOwner[_nftIndex];\n        require(address(0) != owner, \"no_position\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit <\n                block.timestamp,\n            \"insurance_not_expired\"\n        );\n        require(position.liquidator == msg.sender, \"unauthorized\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit InsuranceExpired(owner, _nftIndex);\n    }\n\n    /// @notice Allows the DAO to collect interest and fees before they are repaid\n    function collect() external nonReentrant onlyRole(DAO_ROLE) {\n        accrue();\n        stablecoin.mint(msg.sender, totalFeeCollected);\n        totalFeeCollected = 0;\n    }\n\n    uint256[50] private __gap;\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n//inspired by https://github.com/thousandetherhomepage/ketherhomepage/blob/master/contracts/KetherNFT.sol\n/// @title FlashEscrow contract \n/// @notice This contract sends and receives non ERC721 NFTs\n/// @dev Deployed for each NFT, its address is calculated by {NFTEscrow} prior to it being deployed to allow atomic non ERC721 transfers \ncontract FlashEscrow {\n\n    /// @dev The contract selfdestructs in the constructor, its only purpose is to perform one call to the `target` address using `payload` as the payload\n    /// @param target The call recipient\n    /// @param payload The payload to use for the call\n    constructor(address target, bytes memory payload) {\n        (bool success, ) = target.call(payload);\n        require(success, \"FlashEscrow: call_failed\");\n\n        selfdestruct(payable(target));\n    }\n}\n\n/// @title Escrow contract for non ERC721 NFTs\n/// @notice Handles atomic non ERC721 NFT transfers by using {FlashEscrow}\n/// @dev NFTEscrow allows an atomic, 2 step mechanism to transfer non ERC721 NFTs without requiring prior reservation.\n/// - Users send the NFT to a precomputed address (calculated using the owner's address as salt) that can be fetched by calling the `precompute` function\n/// - The child contract can then call the `_executeTransfer` function to deploy an instance of the {FlashEscrow} contract, deployed at the address calculated in the previous step\n/// This allows atomic transfers, as the address calculated by the `precompute` function is unique and changes depending by the `_owner` address and the NFT index (`_idx`).\n/// This is an alternative to the classic \"reservation\" method, which requires users to call 3 functions in a specifc order (making the process non atomic)\nabstract contract NFTEscrow is Initializable {\n    /// @notice The address of the non ERC721 NFT supported by the child contract\n    address public nftAddress;\n\n    /// @dev Initializer function, see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @param _nftAddress See `nftAddress`\n    function __NFTEscrow_init(address _nftAddress) internal initializer {\n        nftAddress = _nftAddress;\n    }\n\n    /// @dev Computes the bytecode of the {FlashEscrow} instance to deploy\n    /// @param _idx The index of the NFT that's going to be sent to the {FlashEscrow} instance\n    /// @return The bytecode of the {FlashEscrow} instance relative to the NFT at index `_idx`\n    function _encodeFlashEscrow(uint256 _idx)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                type(FlashEscrow).creationCode,\n                abi.encode(nftAddress, _encodeFlashEscrowPayload(_idx))\n            );\n    }\n\n    /// @dev Virtual function, should return the `payload` to use in {FlashEscrow}'s constructor\n    /// @param _idx The index of the NFT that's going to be sent to the {FlashEscrow} instance\n    function _encodeFlashEscrowPayload(uint256 _idx)\n        internal\n        view\n        virtual\n        returns (bytes memory);\n\n    /// @dev Deploys a {FlashEscrow} instance relative to owner `_owner` and index `_idx`\n    /// @param _owner The owner of the NFT at index `_idx`\n    /// @param _idx The index of the NFT owned by `_owner` \n    function _executeTransfer(address _owner, uint256 _idx) internal {\n        (bytes32 salt, ) = precompute(_owner, _idx);\n        new FlashEscrow{salt: salt}(\n            nftAddress,\n            _encodeFlashEscrowPayload(_idx)\n        );\n    }\n\n    /// @notice This function returns the address where user `_owner` should send the `_idx` NFT to\n    /// @dev `precompute` computes the salt and the address relative to NFT at index `_idx` owned by `_owner`\n    /// @param _owner The owner of the NFT at index `_idx`\n    /// @param _idx The index of the NFT owner by `_owner`\n    /// @return salt The salt that's going to be used to deploy the {FlashEscrow} instance\n    /// @return predictedAddress The address where the {FlashEscrow} instance relative to `_owner` and `_idx` will be deployed to\n    function precompute(address _owner, uint256 _idx)\n        public\n        view\n        returns (bytes32 salt, address predictedAddress)\n    {\n        require(\n            _owner != address(this) && _owner != address(0),\n            \"NFTEscrow: invalid_owner\"\n        );\n\n        salt = sha256(abi.encodePacked(_owner));\n\n        bytes memory bytecode = _encodeFlashEscrow(_idx);\n\n        //hash from which the contract address can be derived\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(bytecode)\n            )\n        );\n\n        predictedAddress = address(uint160(uint256(hash)));\n        return (salt, predictedAddress);\n    }\n\n    uint256[50] private __gap;\n}\n\n\n",
        "CodeNames": [
            "NFTVault.sol",
            "NFTEscrow.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "jsx\nit.only(\"will overwrite existing user's JPEG lock schedule\", async () = {\n  // 0. setup\n  const index = 7000;\n  await erc721.mint(user.address, index);\n  await nftVault\n    .connect(dao)\n    .setPendingNFTValueETH(index, units(50));\n  await jpeg.transfer(user.address, units(150000));\n  await jpeg.connect(user).approve(locker.address, units(500000));\n  await jpeg.connect(owner).approve(locker.address, units(500000));\n\n  // 1. user has JPEG locked for finalization\n  await nftVault.connect(user).finalizePendingNFTValueETH(index);\n\n  // 2. owner submit proposal to further increase NFT value\n  await nftVault\n    .connect(dao)\n    .setPendingNFTValueETH(index, units(100));\n  \n  // 3. owner finalizes, has JPEG locked\n  await nftVault.connect(owner).finalizePendingNFTValueETH(index);\n\n  // user schedule has been overwritten\n  let schedule = await locker.positions(index);\n  expect(schedule.owner).to.equal(owner.address);\n\n  // user tries to unstake\n  // wont be able to because schedule was overwritten\n  await timeTravel(days(366));\n  await expect(locker.connect(user).unlock(index)).to.be.revertedWith(\"unauthorized\");\n});\n"
                ],
                "Type": " Existing user\u2019s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds",
                "Description": "\nNFTVault.sol#L375(https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L375)<br\nJPEGLock.sol#L54-L62(https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/lock/JPEGLock.sol#L54-L62)<br\n\nA user\u2019s JPEG lock schedule can be overwritten by another user\u2019s if he (the other user) submits and finalizes a proposal to change the same NFT index\u2019s value.\n\nThe existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.\n\n\n1.  user successfully proposes and finalizes a proposal to change his NFT\u2019s collateral value\n2.  Another user (owner) does the same for the same NFT index\n3.  user will be unable to withdraw his locked JPEG because schedule has been overwritten\n\nInsert this test case into NFTVault.ts(https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/NFTVault.ts).\n\njsx\nit.only(\"will overwrite existing user's JPEG lock schedule\", async () = {\n  // 0. setup\n  const index = 7000;\n  await erc721.mint(user.address, index);\n  await nftVault\n    .connect(dao)\n    .setPendingNFTValueETH(index, units(50));\n  await jpeg.transfer(user.address, units(150000));\n  await jpeg.connect(user).approve(locker.address, units(500000));\n  await jpeg.connect(owner).approve(locker.address, units(500000));\n\n  // 1. user has JPEG locked for finalization\n  await nftVault.connect(user).finalizePendingNFTValueETH(index);\n\n  // 2. owner submit proposal to further increase NFT value\n  await nftVault\n    .connect(dao)\n    .setPendingNFTValueETH(index, units(100));\n  \n  // 3. owner finalizes, has JPEG locked\n  await nftVault.connect(owner).finalizePendingNFTValueETH(index);\n\n  // user schedule has been overwritten\n  let schedule = await locker.positions(index);\n  expect(schedule.owner).to.equal(owner.address);\n\n  // user tries to unstake\n  // wont be able to because schedule was overwritten\n  await timeTravel(days(366));\n  await expect(locker.connect(user).unlock(index)).to.be.revertedWith(\"unauthorized\");\n});\n\n\n",
                "Repair": "\n1.  Release the tokens of the existing schedule. Simple and elegant.\n\njsx\n// in JPEGLock#lockFor()\nLockPosition memory existingPosition = positions[_nftIndex];\nif (existingPosition.owner != address(0)) {\n  // release jpegs to existing owner\n  jpeg.safeTransfer(existingPosition.owner, existingPosition.lockAmount);\n}\n\n\n2.  Revert in finalizePendingNFTValueETH() there is an existing lock schedule. This is less desirable IMO, as there is a use-case for increasing / decreasing the NFT value.\n\nspaghettieth (JPEG'd) confirmed(https://github.com/code-423n4/2022-04-jpegd-findings/issues/10)\n\nspaghettieth (JPEG'd) resolved and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/10#issuecomment-1099232121):\n  Fixed in jpegd/core#3(https://github.com/jpegd/core/pull/3).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "jsx\n    \"@openzeppelin/contracts\": \"^4.0.0\",\n    \"@openzeppelin/contracts-upgradeable\": \"^4.3.2\",\n",
                    "jsx\ncontracts/helpers/CryptoPunksHelper.sol:\n  19:     function initialize(address punksAddress) external initializer {\n\ncontracts/helpers/EtherRocksHelper.sol:\n  19:     function initialize(address rocksAddress) external initializer {\n\ncontracts/staking/JPEGStaking.sol:\n  21:     function initialize(IERC20Upgradeable _jpeg) external initializer {\n\ncontracts/vaults/FungibleAssetVaultForDAO.sol:\n  71:     ) external initializer {\n\ncontracts/vaults/NFTVault.sol:\n  149:     ) external initializer {\n"
                ],
                "Type": " Update initializer modifier to prevent reentrancy during initialization",
                "Description": "\npackage.json#L18-L19(https://github.com/code-423n4/2022-04-jpegd/blob/main/package.json#L18-L19)<br\n\nThe solution uses:\n\njsx\n    \"@openzeppelin/contracts\": \"^4.0.0\",\n    \"@openzeppelin/contracts-upgradeable\": \"^4.3.2\",\n\n\nThese dependencies have a known high severity vulnerability:\n\n*   <https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177\n*   <https://snyk.io/test/npm/@openzeppelin/contracts-upgradeable/4.3.2#SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177\n*   <https://snyk.io/test/npm/@openzeppelin/contracts/4.0.0#SNYK-JS-OPENZEPPELINCONTRACTS-2320176\n\nWhich makes these contracts vulnerable:\n\njsx\ncontracts/helpers/CryptoPunksHelper.sol:\n  19:     function initialize(address punksAddress) external initializer {\n\ncontracts/helpers/EtherRocksHelper.sol:\n  19:     function initialize(address rocksAddress) external initializer {\n\ncontracts/staking/JPEGStaking.sol:\n  21:     function initialize(IERC20Upgradeable _jpeg) external initializer {\n\ncontracts/vaults/FungibleAssetVaultForDAO.sol:\n  71:     ) external initializer {\n\ncontracts/vaults/NFTVault.sol:\n  149:     ) external initializer {\n\n\n",
                "Repair": "\nUpgrade @openzeppelin/contracts and @openzeppelin/contracts-upgradeable to version 4.4.1 or higher.\n\nspaghettieth (JPEG'd) confirmed, but disagreed with High severity(https://github.com/code-423n4/2022-04-jpegd-findings/issues/227)\n\nspaghettieth (JPEG'd) resolved and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/227#issuecomment-1099246138):\n  Fixed in jpegd/core#11(https://github.com/jpegd/core/pull/11).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title JPEG'd LP Farming\n/// @notice Users can stake their JPEG'd ecosystem LP tokens to get JPEG rewards\n/// @dev This contract doesn't mint JPEG tokens, instead the owner (the JPEG'd DAO) allocates x amount of JPEG to be distributed as a reward for liquidity providers.\n/// To ensure that enough tokens are allocated, an epoch system is implemented.\n/// The owner is required to allocate enough tokens (`_rewardPerBlock * (_endBlock - _startBlock)`) when creating a new epoch.\n/// When there no epoch is ongoing, the contract stops emitting rewards\ncontract LPFarming is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event ClaimAll(address indexed user, uint256 amount);\n\n    /// @dev Data relative to a user's staking position\n    /// @param amount The amount of LP tokens the user has provided\n    /// @param lastAccRewardPerShare The `accRewardPerShare` pool value at the time of the user's last claim\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastAccRewardPerShare;\n    }\n\n    /// @dev Data relative to an LP pool\n    /// @param lpToken The LP token accepted by the pool\n    /// @param allocPoint Allocation points assigned to the pool. Determines the share of `rewardPerBlock` allocated to this pool\n    /// @param lastRewardBlock Last block number in which reward distribution occurred\n    /// @param accRewardPerShare Accumulated rewards per share, times 1e36. The amount of rewards the pool has accumulated per unit of LP token deposited\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 accRewardPerShare;\n    }\n\n    /// @dev Data relative to an epoch\n    /// @param startBlock The epoch's starting block\n    /// @param endBlock The epoch's starting block\n    /// @param rewardPerBlock The amount of JPEG rewards distributed per block during this epoch\n    struct EpochInfo {\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 rewardPerBlock;\n    }\n\n    /// @notice The reward token, JPEG\n    IERC20 public immutable jpeg;\n\n    /// @notice The current epoch\n    /// @dev We don't need to store data about previous epochs, to simplify logic we only store data about the current epoch\n    EpochInfo public epoch;\n    /// @notice All the LP pools, active and inactive\n    PoolInfo[] public poolInfo;\n    /// @notice User staking positions, divided by PID\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice Sum of the allocation points for all the pools\n    /// @dev Used to calculate the share of `rewardPerBlock` for each pool.\n    uint256 public totalAllocPoint;\n\n    /// @dev User's (total) withdrawable rewards\n    mapping(address => uint256) private userRewards;\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _jpeg The reward token\n    constructor(address _jpeg) {\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the LP farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting liquidity providers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to start a new epoch. Can only be called when there's no ongoing epoch\n    /// @param _startBlock The new epoch's start block. Has to be greater than the previous epoch's `endBlock`\n    /// @param _endBlock The new epoch's end block. Has to be greater than `_startBlock`\n    /// @param _rewardPerBlock The new epoch's amount of rewards to distribute per block. Must be greater than 0\n    function newEpoch(\n        uint256 _startBlock,\n        uint256 _endBlock,\n        uint256 _rewardPerBlock\n    ) external onlyOwner {\n        require(_startBlock >= block.number, \"Invalid start block\");\n        require(_endBlock > _startBlock, \"Invalid end block\");\n        require(_rewardPerBlock > 0, \"Invalid reward per block\");\n\n        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`\n        _massUpdatePools();\n\n        uint256 remainingRewards = epoch.rewardPerBlock *\n            (epoch.endBlock - _blockNumber());\n        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);\n\n        epoch.startBlock = _startBlock;\n        epoch.endBlock = _endBlock;\n        epoch.rewardPerBlock = _rewardPerBlock;\n\n        if (remainingRewards > newRewards) {\n            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);\n        } else if (remainingRewards < newRewards) {\n            jpeg.safeTransferFrom(\n                msg.sender,\n                address(this),\n                newRewards - remainingRewards\n            );\n        }\n    }\n\n    /// @notice Allows the owner to add a new pool\n    /// @param _allocPoint Allocation points to assign to the new pool\n    /// @param _lpToken The LP token accepted by the new pool\n    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 lastRewardBlock = _blockNumber();\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accRewardPerShare: 0\n            })\n        );\n    }\n\n    /// @notice Allows the owner to change a pool's allocation points\n    /// @param _pid The pool id of the pool to modify\n    /// @param _allocPoint The new allocation points\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if (prevAllocPoint != _allocPoint) {\n            totalAllocPoint = totalAllocPoint - prevAllocPoint + _allocPoint;\n        }\n    }\n\n    /// @notice Returns the number of pools available\n    /// @return The length of the `poolInfo` array\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim from the pool with id `_pid`\n    /// @param _pid The pool id\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable from `_pid` by user `_user`\n    function pendingReward(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (blockNumber > lastRewardBlock && lpSupply != 0) {\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            accRewardPerShare += reward / lpSupply;\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of LP tokens in the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _pid The id of the pool to deposit into\n    /// @param _amount The amount of LP tokens to deposit\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n        user.amount = user.amount + _amount;\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of LP tokens from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _pid The id of the pool to withdraw from\n    /// @param _amount The amount of LP tokens to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"insufficient_amount\");\n\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        user.amount -= _amount;\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @dev Normalizes the current `block.number`. See {_normalizeBlockNumber} for more info\n    /// @return Normalized `block.number`\n    function _blockNumber() internal view returns (uint256) {\n        return _normalizeBlockNumber(block.number);\n    }\n\n    /// @dev Normalizes `blockNumber` to fit within the bounds of an epoch.\n    /// This is done to ensure that no rewards are distributed for staking outside of an epoch without modifying the reward logic.\n    /// For example:\n    /// `blockNumber` is 1100, the epoch's `endBlock` is 1000. In this case the function would return 1000. If this value were to be used\n    /// in the {_updatePool} function, where the pool's `lastRewardBlock` is 990, only the rewards from block 990 to block 1000 would be distributed\n    /// @return Normalized `blockNumber`\n    function _normalizeBlockNumber(uint256 blockNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        if (blockNumber < epoch.startBlock) return epoch.startBlock;\n\n        if (blockNumber > epoch.endBlock) return epoch.endBlock;\n\n        return blockNumber;\n    }\n\n    /// @dev Calls {_updatePool} for every pool\n    function _massUpdatePools() internal {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(pid);\n        }\n    }\n\n    /// @dev Updates the state of the pool at index `_pid`\n    /// @param _pid The pool to update\n    function _updatePool(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (pool.allocPoint == 0) {\n            return;\n        }\n\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        if (blockNumber <= lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = blockNumber;\n            return;\n        }\n        uint256 reward = ((blockNumber - lastRewardBlock) *\n            epoch.rewardPerBlock *\n            1e36 *\n            pool.allocPoint) / totalAllocPoint;\n        pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n        pool.lastRewardBlock = blockNumber;\n    }\n\n    /// @dev Updates `msg.sender`'s claimable rewards by adding pending rewards from `_pid`\n    /// @param _pid The pool to withdraw rewards from\n    function _withdrawReward(uint256 _pid) internal returns (uint256) {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 pending = (user.amount *\n            (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n        if (pending > 0) {\n            userRewards[msg.sender] += pending;\n        }\n\n        user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @notice Allows users to claim rewards from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    /// @param _pid The pool to claim rewards from\n    function claim(uint256 _pid) external nonReentrant noContract(msg.sender) {\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit Claim(msg.sender, _pid, rewards);\n    }\n\n    /// @notice Allows users to claim rewards from all pools. Non whitelisted contracts can't call this function\n    /// @dev Emits a {ClaimAll} event\n    function claimAll() external nonReentrant noContract(msg.sender) {\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            _updatePool(i);\n            _withdrawReward(i);\n        }\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit ClaimAll(msg.sender, rewards);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault token farm\n/// @notice Users can stake their JPEG'd vault tokens and earn JPEG rewards\n/// @dev The rewards are taken from the PUSD Convex pool and distributed to stakers based on their share of the total staked tokens.\ncontract YVaultLPFarming is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IYVault;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 rewards);\n\n    IYVault public immutable vault;\n    IERC20 public immutable jpeg;\n\n    uint256 public totalStaked;\n\n    uint256 internal lastRewardBlock;\n    uint256 internal previousBalance;\n    uint256 internal accRewardPerShare;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) private userLastAccRewardPerShare;\n    mapping(address => uint256) private userPendingRewards;\n\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    ///@param _vault The yVault address\n    ///@param _jpeg The JPEG token address\n    constructor(address _vault, address _jpeg) {\n        require(_vault != address(0), \"INVALID_VAULT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n\n        vault = IYVault(_vault);\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting farmers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable by user `_user`\n    function pendingReward(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 rewardShare = accRewardPerShare;\n        uint256 staked = totalStaked;\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (block.number > lastRewardBlock && staked > 0) {\n            (rewardShare, ) = _computeUpdate();\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userPendingRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (balanceOf[_user] * (rewardShare - userLastAccRewardPerShare[_user])) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _amount The amount of tokens to deposit\n    function deposit(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        vault.safeTransferFrom(msg.sender, address(this), _amount);\n\n        balanceOf[msg.sender] += _amount;\n        totalStaked += _amount;\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _amount The amount of tokens to withdraw\n    function withdraw(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n        require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        balanceOf[msg.sender] -= _amount;\n        totalStaked -= _amount;\n\n        vault.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to claim rewards. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    function claim() external noContract(msg.sender) {\n        _update();\n        _withdrawReward(msg.sender);\n\n        uint256 rewards = userPendingRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        userPendingRewards[msg.sender] = 0;\n        //we are subtracting the claimed rewards from the previous to have a consistent value next time\n        //{_update is called}\n        previousBalance -= rewards;\n\n        if (jpeg.balanceOf(address(this)) < rewards)\n            vault.withdrawJPEG();\n\n        jpeg.safeTransfer(msg.sender, rewards);\n\n        emit Claim(msg.sender, rewards);\n    }\n\n    /// @dev Updates this contract's rewards state\n    function _update() internal {\n        if (block.number <= lastRewardBlock) return;\n\n        lastRewardBlock = block.number;\n\n        if (totalStaked == 0) return;\n\n        (accRewardPerShare, previousBalance) = _computeUpdate();\n    }\n\n    /// @dev Computes the updated contract state without writing storage\n    /// @return newAccRewardsPerShare The new value of `accRewardsPerShare`\n    /// @return currentBalance The new value of `previousBalance`\n    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {\n        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\n        uint256 newRewards = currentBalance - previousBalance;\n\n        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;\n    }\n\n    /// @dev Updates `account`'s claimable rewards by adding pending rewards\n    /// @param account The account to update\n    function _withdrawReward(address account) internal returns (uint256) {\n        uint256 pending = (balanceOf[account] *\n            (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36;\n\n        if (pending > 0) userPendingRewards[account] += pending;\n\n        userLastAccRewardPerShare[account] = accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "CodeNames": [
            "LPFarming.sol",
            "yVaultLPFarming.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "jsx\nit.only(\"will revert old farms' deposits and withdrawals if yVault migrates farm\", async () = {\n  // 0. setup\n  await token.mint(owner.address, units(1000));\n  await token.approve(yVault.address, units(1000));\n  await yVault.depositAll();\n  await yVault.approve(lpFarming.address, units(1000));\n  // send some JPEG to strategy prior to deposit\n  await jpeg.mint(strategy.address, units(100));\n  // deposit twice, so that the second deposit will invoke _update()\n  await lpFarming.deposit(units(250));\n  await lpFarming.deposit(units(250));\n\t\n  // 1. change farm and call withdrawJPEG()\n  await yVault.setFarmingPool(user1.address);\n  await yVault.withdrawJPEG();\n\t\n  // deposit and withdrawal will fail\n  await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n  await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n});\n"
                ],
                "Type": "  yVaultLPFarming : No guarantee JPEG currentBalance > previousBalance",
                "Description": "\nyVaultLPFarming.sol#L169-L170(https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170)<br\n\nyVault users participating in the farm have to trust that:\n\n*   vault.balanceOfJPEG()  returns the correct claimable JPEG amount by its strategy / strategies\n*   the strategy / strategies will send all claimable JPEG to the farm\n\nShould either of these assumptions break, then it could possibly be the case that currentBalance is less than previousBalance, causing deposits and crucially, withdrawals to fail due to subtraction overflow.\n\n\nFor instance,\n\n*   Farm migration occurs. A new farm is set in yVault, then withdrawJPEG() is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.\n\njsx\nit.only(\"will revert old farms' deposits and withdrawals if yVault migrates farm\", async () = {\n  // 0. setup\n  await token.mint(owner.address, units(1000));\n  await token.approve(yVault.address, units(1000));\n  await yVault.depositAll();\n  await yVault.approve(lpFarming.address, units(1000));\n  // send some JPEG to strategy prior to deposit\n  await jpeg.mint(strategy.address, units(100));\n  // deposit twice, so that the second deposit will invoke _update()\n  await lpFarming.deposit(units(250));\n  await lpFarming.deposit(units(250));\n\t\n  // 1. change farm and call withdrawJPEG()\n  await yVault.setFarmingPool(user1.address);\n  await yVault.withdrawJPEG();\n\t\n  // deposit and withdrawal will fail\n  await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n  await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n});\n\n\n*   Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing vault.balanceOfJPEG() to report a smaller amount than previously recorded\n*   jpeg could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets\n*   A future implementation takes a fee on the jpeg to be claimed\n\n",
                "Repair": "\nA simple fix would be to return if currentBalance \u2264 previousBalance. A full fix would properly handle potential shortfall.\n\njsx\nif (currentBalance <= previousBalance) return;\n\n\nspaghettieth (JPEG'd) confirmed, but disagreed with High severity and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1096865375):\n  The issue can be reproduced, but due to the extremely specific cases in which this happens the severity should be lowered to 2.\n\nspaghettieth (JPEG'd) resolved and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1099243025):\n  Fixed in jpegd/core#7(https://github.com/jpegd/core/pull/7).\n\nLSDan (judge) commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1109877532):\n  I disagree with the sponsor. This is high risk.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title JPEG'd LP Farming\n/// @notice Users can stake their JPEG'd ecosystem LP tokens to get JPEG rewards\n/// @dev This contract doesn't mint JPEG tokens, instead the owner (the JPEG'd DAO) allocates x amount of JPEG to be distributed as a reward for liquidity providers.\n/// To ensure that enough tokens are allocated, an epoch system is implemented.\n/// The owner is required to allocate enough tokens (`_rewardPerBlock * (_endBlock - _startBlock)`) when creating a new epoch.\n/// When there no epoch is ongoing, the contract stops emitting rewards\ncontract LPFarming is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event ClaimAll(address indexed user, uint256 amount);\n\n    /// @dev Data relative to a user's staking position\n    /// @param amount The amount of LP tokens the user has provided\n    /// @param lastAccRewardPerShare The `accRewardPerShare` pool value at the time of the user's last claim\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastAccRewardPerShare;\n    }\n\n    /// @dev Data relative to an LP pool\n    /// @param lpToken The LP token accepted by the pool\n    /// @param allocPoint Allocation points assigned to the pool. Determines the share of `rewardPerBlock` allocated to this pool\n    /// @param lastRewardBlock Last block number in which reward distribution occurred\n    /// @param accRewardPerShare Accumulated rewards per share, times 1e36. The amount of rewards the pool has accumulated per unit of LP token deposited\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 accRewardPerShare;\n    }\n\n    /// @dev Data relative to an epoch\n    /// @param startBlock The epoch's starting block\n    /// @param endBlock The epoch's starting block\n    /// @param rewardPerBlock The amount of JPEG rewards distributed per block during this epoch\n    struct EpochInfo {\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 rewardPerBlock;\n    }\n\n    /// @notice The reward token, JPEG\n    IERC20 public immutable jpeg;\n\n    /// @notice The current epoch\n    /// @dev We don't need to store data about previous epochs, to simplify logic we only store data about the current epoch\n    EpochInfo public epoch;\n    /// @notice All the LP pools, active and inactive\n    PoolInfo[] public poolInfo;\n    /// @notice User staking positions, divided by PID\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice Sum of the allocation points for all the pools\n    /// @dev Used to calculate the share of `rewardPerBlock` for each pool.\n    uint256 public totalAllocPoint;\n\n    /// @dev User's (total) withdrawable rewards\n    mapping(address => uint256) private userRewards;\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _jpeg The reward token\n    constructor(address _jpeg) {\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the LP farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting liquidity providers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to start a new epoch. Can only be called when there's no ongoing epoch\n    /// @param _startBlock The new epoch's start block. Has to be greater than the previous epoch's `endBlock`\n    /// @param _endBlock The new epoch's end block. Has to be greater than `_startBlock`\n    /// @param _rewardPerBlock The new epoch's amount of rewards to distribute per block. Must be greater than 0\n    function newEpoch(\n        uint256 _startBlock,\n        uint256 _endBlock,\n        uint256 _rewardPerBlock\n    ) external onlyOwner {\n        require(_startBlock >= block.number, \"Invalid start block\");\n        require(_endBlock > _startBlock, \"Invalid end block\");\n        require(_rewardPerBlock > 0, \"Invalid reward per block\");\n\n        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`\n        _massUpdatePools();\n\n        uint256 remainingRewards = epoch.rewardPerBlock *\n            (epoch.endBlock - _blockNumber());\n        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);\n\n        epoch.startBlock = _startBlock;\n        epoch.endBlock = _endBlock;\n        epoch.rewardPerBlock = _rewardPerBlock;\n\n        if (remainingRewards > newRewards) {\n            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);\n        } else if (remainingRewards < newRewards) {\n            jpeg.safeTransferFrom(\n                msg.sender,\n                address(this),\n                newRewards - remainingRewards\n            );\n        }\n    }\n\n    /// @notice Allows the owner to add a new pool\n    /// @param _allocPoint Allocation points to assign to the new pool\n    /// @param _lpToken The LP token accepted by the new pool\n    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 lastRewardBlock = _blockNumber();\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accRewardPerShare: 0\n            })\n        );\n    }\n\n    /// @notice Allows the owner to change a pool's allocation points\n    /// @param _pid The pool id of the pool to modify\n    /// @param _allocPoint The new allocation points\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if (prevAllocPoint != _allocPoint) {\n            totalAllocPoint = totalAllocPoint - prevAllocPoint + _allocPoint;\n        }\n    }\n\n    /// @notice Returns the number of pools available\n    /// @return The length of the `poolInfo` array\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim from the pool with id `_pid`\n    /// @param _pid The pool id\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable from `_pid` by user `_user`\n    function pendingReward(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (blockNumber > lastRewardBlock && lpSupply != 0) {\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            accRewardPerShare += reward / lpSupply;\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of LP tokens in the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _pid The id of the pool to deposit into\n    /// @param _amount The amount of LP tokens to deposit\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n        user.amount = user.amount + _amount;\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of LP tokens from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _pid The id of the pool to withdraw from\n    /// @param _amount The amount of LP tokens to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"insufficient_amount\");\n\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        user.amount -= _amount;\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @dev Normalizes the current `block.number`. See {_normalizeBlockNumber} for more info\n    /// @return Normalized `block.number`\n    function _blockNumber() internal view returns (uint256) {\n        return _normalizeBlockNumber(block.number);\n    }\n\n    /// @dev Normalizes `blockNumber` to fit within the bounds of an epoch.\n    /// This is done to ensure that no rewards are distributed for staking outside of an epoch without modifying the reward logic.\n    /// For example:\n    /// `blockNumber` is 1100, the epoch's `endBlock` is 1000. In this case the function would return 1000. If this value were to be used\n    /// in the {_updatePool} function, where the pool's `lastRewardBlock` is 990, only the rewards from block 990 to block 1000 would be distributed\n    /// @return Normalized `blockNumber`\n    function _normalizeBlockNumber(uint256 blockNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        if (blockNumber < epoch.startBlock) return epoch.startBlock;\n\n        if (blockNumber > epoch.endBlock) return epoch.endBlock;\n\n        return blockNumber;\n    }\n\n    /// @dev Calls {_updatePool} for every pool\n    function _massUpdatePools() internal {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(pid);\n        }\n    }\n\n    /// @dev Updates the state of the pool at index `_pid`\n    /// @param _pid The pool to update\n    function _updatePool(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (pool.allocPoint == 0) {\n            return;\n        }\n\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        if (blockNumber <= lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = blockNumber;\n            return;\n        }\n        uint256 reward = ((blockNumber - lastRewardBlock) *\n            epoch.rewardPerBlock *\n            1e36 *\n            pool.allocPoint) / totalAllocPoint;\n        pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n        pool.lastRewardBlock = blockNumber;\n    }\n\n    /// @dev Updates `msg.sender`'s claimable rewards by adding pending rewards from `_pid`\n    /// @param _pid The pool to withdraw rewards from\n    function _withdrawReward(uint256 _pid) internal returns (uint256) {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 pending = (user.amount *\n            (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n        if (pending > 0) {\n            userRewards[msg.sender] += pending;\n        }\n\n        user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @notice Allows users to claim rewards from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    /// @param _pid The pool to claim rewards from\n    function claim(uint256 _pid) external nonReentrant noContract(msg.sender) {\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit Claim(msg.sender, _pid, rewards);\n    }\n\n    /// @notice Allows users to claim rewards from all pools. Non whitelisted contracts can't call this function\n    /// @dev Emits a {ClaimAll} event\n    function claimAll() external nonReentrant noContract(msg.sender) {\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            _updatePool(i);\n            _withdrawReward(i);\n        }\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit ClaimAll(msg.sender, rewards);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault token farm\n/// @notice Users can stake their JPEG'd vault tokens and earn JPEG rewards\n/// @dev The rewards are taken from the PUSD Convex pool and distributed to stakers based on their share of the total staked tokens.\ncontract YVaultLPFarming is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IYVault;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 rewards);\n\n    IYVault public immutable vault;\n    IERC20 public immutable jpeg;\n\n    uint256 public totalStaked;\n\n    uint256 internal lastRewardBlock;\n    uint256 internal previousBalance;\n    uint256 internal accRewardPerShare;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) private userLastAccRewardPerShare;\n    mapping(address => uint256) private userPendingRewards;\n\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    ///@param _vault The yVault address\n    ///@param _jpeg The JPEG token address\n    constructor(address _vault, address _jpeg) {\n        require(_vault != address(0), \"INVALID_VAULT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n\n        vault = IYVault(_vault);\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting farmers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable by user `_user`\n    function pendingReward(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 rewardShare = accRewardPerShare;\n        uint256 staked = totalStaked;\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (block.number > lastRewardBlock && staked > 0) {\n            (rewardShare, ) = _computeUpdate();\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userPendingRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (balanceOf[_user] * (rewardShare - userLastAccRewardPerShare[_user])) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _amount The amount of tokens to deposit\n    function deposit(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        vault.safeTransferFrom(msg.sender, address(this), _amount);\n\n        balanceOf[msg.sender] += _amount;\n        totalStaked += _amount;\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _amount The amount of tokens to withdraw\n    function withdraw(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n        require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        balanceOf[msg.sender] -= _amount;\n        totalStaked -= _amount;\n\n        vault.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to claim rewards. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    function claim() external noContract(msg.sender) {\n        _update();\n        _withdrawReward(msg.sender);\n\n        uint256 rewards = userPendingRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        userPendingRewards[msg.sender] = 0;\n        //we are subtracting the claimed rewards from the previous to have a consistent value next time\n        //{_update is called}\n        previousBalance -= rewards;\n\n        if (jpeg.balanceOf(address(this)) < rewards)\n            vault.withdrawJPEG();\n\n        jpeg.safeTransfer(msg.sender, rewards);\n\n        emit Claim(msg.sender, rewards);\n    }\n\n    /// @dev Updates this contract's rewards state\n    function _update() internal {\n        if (block.number <= lastRewardBlock) return;\n\n        lastRewardBlock = block.number;\n\n        if (totalStaked == 0) return;\n\n        (accRewardPerShare, previousBalance) = _computeUpdate();\n    }\n\n    /// @dev Computes the updated contract state without writing storage\n    /// @return newAccRewardsPerShare The new value of `accRewardsPerShare`\n    /// @return currentBalance The new value of `previousBalance`\n    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {\n        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\n        uint256 newRewards = currentBalance - previousBalance;\n\n        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;\n    }\n\n    /// @dev Updates `account`'s claimable rewards by adding pending rewards\n    /// @param account The account to update\n    function _withdrawReward(address account) internal returns (uint256) {\n        uint256 pending = (balanceOf[account] *\n            (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36;\n\n        if (pending > 0) userPendingRewards[account] += pending;\n\n        userLastAccRewardPerShare[account] = accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault\n/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).\n/// Non whitelisted contracts can't deposit/withdraw.\n/// Owner is DAO\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    ERC20 public immutable token;\n    IController public controller;\n    \n    address public farm;\n    \n    Rate internal availableTokensRate;\n\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _token The token managed by this vault\n    /// @param _controller The JPEG'd strategies controller\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.\n    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return token.decimals();\n    }\n\n    /// @return The total amount of tokens managed by this vault and the underlying strategy\n    function balance() public view returns (uint256) {\n        return\n            token.balanceOf(address(this)) +\n            controller.balanceOf(address(token));\n    }\n\n    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}\n    function balanceOfJPEG() external view returns (uint256) {\n        return controller.balanceOfJPEG(address(token));\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow\n    /// @param _rate The new rate\n    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {\n        require(\n            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\n            \"INVALID_RATE\"\n        );\n        availableTokensRate = _rate;\n    }\n\n    /// @notice ALlows the owner to set this vault's controller\n    /// @param _controller The new controller\n    function setController(address _controller) public onlyOwner {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        controller = IController(_controller);\n    }\n\n    /// @notice Allows the owner to set the yVault LP farm\n    /// @param _farm The new farm\n    function setFarmingPool(address _farm) public onlyOwner {\n        require(_farm != address(0), \"INVALID_FARMING_POOL\");\n        farm = _farm;\n    }\n\n    /// @return How much the vault allows to be borrowed by the underlying strategy.\n    /// Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view returns (uint256) {\n        return\n            (token.balanceOf(address(this)) * availableTokensRate.numerator) /\n            availableTokensRate.denominator;\n    }\n\n    /// @notice Deposits `token` into the underlying strategy\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n\n    /// @notice Allows users to deposit their entire `token` balance\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to deposit `token`. Contracts can't call this function\n    /// @param _amount The amount to deposit\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw all their deposited balance\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to withdraw tokens. Contracts can't call this function\n    /// @param _shares The amount of shares to burn\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n\n    /// @notice Allows anyone to withdraw JPEG to `farm` \n    function withdrawJPEG() external {\n        require(farm != address(0), \"NO_FARM\");\n        controller.withdrawJPEG(address(token), farm);\n    }\n\n    /// @return The underlying tokens per share\n    function getPricePerFullShare() external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) return 0;\n        return (balance() * 1e18) / supply;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "CodeNames": [
            "LPFarming.sol",
            "yVaultLPFarming.sol",
            "yVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\ncurrentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\nuint256 newRewards = currentBalance previousBalance;\n",
                    "//solidity\nfunction setController(address _controller) public onlyOwner {\n    // @audit can reduce balanceofJpeg which breaks other masterchef contract\n    require(_controller != address(0), \"INVALID_CONTROLLER\");\n    controller = IController(_controller);\n}\n\nfunction balanceOfJPEG() external view returns (uint256) {\n    // @audit new controller could return a smaller balance\n    return controller.balanceOfJPEG(address(token));\n}\n"
                ],
                "Type": " Setting new controller can break  YVaultLPFarming ",
                "Description": "\nyVaultLPFarming.sol#L170(https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170)<br\nyVault.sol#L108(https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L108)<br\n\nThe accruals in yVaultLPFarming will fail if currentBalance < previousBalance(https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170) in _computeUpdate.\n\nsolidity\ncurrentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\nuint256 newRewards = currentBalance previousBalance;\n\n\nNo funds can be withdrawn anymore as the withdraw functions first trigger an _update.\n\nThe currentBalance < previousBalance case can, for example, be triggerd by decreasing the vault.balanceOfJPEG() due to calling yVault.setController:\n\nsolidity\nfunction setController(address _controller) public onlyOwner {\n    // @audit can reduce balanceofJpeg which breaks other masterchef contract\n    require(_controller != address(0), \"INVALID_CONTROLLER\");\n    controller = IController(_controller);\n}\n\nfunction balanceOfJPEG() external view returns (uint256) {\n    // @audit new controller could return a smaller balance\n    return controller.balanceOfJPEG(address(token));\n}\n\n\n",
                "Repair": "\nSetting a new controller on a vault must be done very carefully and requires a migration.\n\nLSDan (judge) commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/80#issuecomment-1109891540):\n  This is not a duplicate of H-05. Though both of them deal with issues related to balanceOfJPEG, they describe different causes.\n\nspaghettieth (JPEG'd) acknowledged(https://github.com/code-423n4/2022-04-jpegd-findings/issues/80)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../interfaces/ISwapRouter.sol\";\nimport \"../../../interfaces/IUniswapV2Router.sol\";\nimport \"../../../interfaces/ICurve.sol\";\nimport \"../../../interfaces/IBooster.sol\";\nimport \"../../../interfaces/IBaseRewardPool.sol\";\n\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IFungibleAssetVaultForDAO.sol\";\n\n/// @title JPEG'd PUSD Convex autocompounding strategy\n/// @notice This strategy autocompounds Convex rewards from the PUSD/USDC/USDT/MIM Curve pool.\n/// @dev The strategy deposits either USDC or PUSD in the Curve pool depending on which one has lower liquidity.\n/// The strategy sells reward tokens for USDC. If the pool has less PUSD than USDC, this contract uses the\n/// USDC {FungibleAssetVaultForDAO} to mint PUSD using USDC as collateral\ncontract StrategyPUSDConvex is AccessControl {\n    using SafeERC20 for IERC20;\n\n    event Harvested(uint256 wantEarned);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    /// @param booster Convex Booster's address\n    /// @param baseRewardPool Convex BaseRewardPool's address\n    /// @param pid The Convex pool id for PUSD/USDC/USDT/MIM LP tokens\n    struct ConvexConfig {\n        IBooster booster;\n        IBaseRewardPool baseRewardPool;\n        uint256 pid;\n    }\n\n    /// @param curve Curve's PUSD/USDC/USDT/MIM pool address\n    /// @param usdcIndex The USDC token index in curve's pool\n    /// @param pusdIndex The PUSD token index in curve's pool\n    struct CurveConfig {\n        ICurve curve;\n        uint256 usdcIndex;\n        uint256 pusdIndex;\n    }\n\n    /// @param uniswapV2 The UniswapV2 (or Sushiswap) router address\n    /// @param uniswapV3 The UniswapV3 router address\n    struct DexConfig {\n        IUniswapV2Router uniswapV2;\n        ISwapRouter uniswapV3;\n    }\n\n    /// @param rewardTokens The Convex reward tokens\n    /// @param controller The strategy controller\n    /// @param usdcVault The JPEG'd USDC {FungibleAssetVaultForDAO} address\n    struct StrategyConfig {\n        IERC20[] rewardTokens;\n        IController controller;\n        IFungibleAssetVaultForDAO usdcVault;\n    }\n\n    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\n\n    /// @notice The PUSD/USDC/USDT/MIM Curve LP token\n    IERC20 public immutable want;\n    IERC20 public immutable jpeg;\n    IERC20 public immutable pusd;\n    IERC20 public immutable weth;\n    IERC20 public immutable usdc;\n\n    DexConfig public dexConfig;\n    CurveConfig public curveConfig;\n    ConvexConfig public convexConfig;\n    StrategyConfig public strategyConfig;\n\n    /// @notice The performance fee to be sent to the DAO/strategists\n    Rate public performanceFee;\n\n    /// @notice lifetime strategy earnings denominated in `want` token\n    uint256 public earned;\n\n    /// @param _want The PUSD/USDC/USDT/MIM Curve LP token\n    /// @param _jpeg The JPEG token address\n    /// @param _pusd The PUSD token address\n    /// @param _weth The WETH token address\n    /// @param _usdc The USDC token address\n    /// @param _dexConfig See {DexConfig} struct\n    /// @param _curveConfig See {CurveConfig} struct\n    /// @param _convexConfig See {ConvexConfig} struct\n    /// @param _strategyConfig See {StrategyConfig} struct\n    /// @param _performanceFee The rate of USDC to be sent to the DAO/strategists\n    constructor(\n        address _want,\n        address _jpeg,\n        address _pusd,\n        address _weth,\n        address _usdc,\n        DexConfig memory _dexConfig,\n        CurveConfig memory _curveConfig,\n        ConvexConfig memory _convexConfig,\n        StrategyConfig memory _strategyConfig,\n        Rate memory _performanceFee\n    ) {\n        require(_want != address(0), \"INVALID_WANT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n        require(_pusd != address(0), \"INVALID_PUSD\");\n        require(_weth != address(0), \"INVALID_WETH\");\n        require(_usdc != address(0), \"INVALID_USDC\");\n        require(\n            address(_dexConfig.uniswapV2) != address(0),\n            \"INVALID_UNISWAP_V2\"\n        );\n        require(\n            address(_dexConfig.uniswapV3) != address(0),\n            \"INVALID_UNISWAP_V3\"\n        );\n        require(address(_curveConfig.curve) != address(0), \"INVALID_CURVE\");\n        require(\n            _curveConfig.pusdIndex != _curveConfig.usdcIndex,\n            \"INVALID_CURVE_INDEXES\"\n        );\n        require(_curveConfig.pusdIndex < 4, \"INVALID_PUSD_CURVE_INDEX\");\n        require(_curveConfig.usdcIndex < 4, \"INVALID_USDC_CURVE_INDEX\");\n        require(\n            address(_convexConfig.booster) != address(0),\n            \"INVALID_CONVEX_BOOSTER\"\n        );\n        require(\n            address(_convexConfig.baseRewardPool) != address(0),\n            \"INVALID_CONVEX_BASE_REWARD_POOL\"\n        );\n        require(\n            address(_strategyConfig.controller) != address(0),\n            \"INVALID_CONTROLLER\"\n        );\n        require(\n            address(_strategyConfig.usdcVault) != address(0),\n            \"INVALID_USDC_VAULT\"\n        );\n\n        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\n            require(\n                address(_strategyConfig.rewardTokens[i]) != address(0),\n                \"INVALID_REWARD_TOKEN\"\n            );\n        }\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        setPerformanceFee(_performanceFee);\n\n        want = IERC20(_want);\n        jpeg = IERC20(_jpeg);\n        pusd = IERC20(_pusd);\n        weth = IERC20(_weth);\n        usdc = IERC20(_usdc);\n\n        dexConfig = _dexConfig;\n        curveConfig = _curveConfig;\n        convexConfig = _convexConfig;\n        strategyConfig = _strategyConfig;\n    }\n\n    modifier onlyController() {\n        require(\n            msg.sender == address(strategyConfig.controller),\n            \"NOT_CONTROLLER\"\n        );\n        _;\n    }\n\n    /// @notice Allows the DAO to set the performance fee\n    /// @param _performanceFee The new performance fee\n    function setPerformanceFee(Rate memory _performanceFee)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(\n            _performanceFee.denominator > 0 &&\n                _performanceFee.denominator >= _performanceFee.numerator,\n            \"INVALID_RATE\"\n        );\n        performanceFee = _performanceFee;\n    }\n\n    /// @notice Allows the DAO to set the strategy controller\n    /// @param _controller The new strategy controller\n    function setController(address _controller)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        strategyConfig.controller = IController(_controller);\n    }\n\n    /// @notice Allows the DAO to set the USDC vault\n    /// @param _vault The new USDC vault\n    function setUSDCVault(address _vault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_vault != address(0), \"INVALID_USDC_VAULT\");\n        strategyConfig.usdcVault = IFungibleAssetVaultForDAO(_vault);\n    }\n\n    /// @return The strategy's name\n    function getName() external pure returns (string memory) {\n        return \"StrategyPUSDConvex\";\n    }\n\n    /// @return The amount of `want` tokens held by this contract\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @return The amount of `want` tokens deposited in the Convex pool by this contract\n    function balanceOfPool() public view returns (uint256) {\n        return convexConfig.baseRewardPool.balanceOf(address(this));\n    }\n\n    /// @return The amount of JPEG currently held by this contract and the amount of JPEG\n    /// rewards available from Convex\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n\n    /// @return The total amount of `want` tokens this contract manages (held + deposited)\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant() + balanceOfPool();\n    }\n\n    /// @notice Allows anyone to deposit the total amount of `want` tokens in this contract into Convex\n    function deposit() public {\n        uint256 balance = want.balanceOf(address(this));\n        ConvexConfig memory convex = convexConfig;\n        want.safeIncreaseAllowance(address(convex.booster), balance);\n        convex.booster.depositAll(convex.pid, true);\n    }\n\n    /// @notice Controller only function that allows to withdraw non-strategy tokens (e.g tokens sent accidentally)\n    function withdraw(IERC20 _asset)\n        external\n        onlyController\n        returns (uint256 balance)\n    {\n        require(want != _asset, \"want\");\n        require(pusd != _asset, \"pusd\");\n        require(usdc != _asset, \"usdc\");\n        require(weth != _asset, \"weth\");\n        require(jpeg != _asset, \"jpeg\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(address(strategyConfig.controller), balance);\n    }\n\n    /// @notice Allows the controller to withdraw `want` tokens. Normally used with a vault withdrawal\n    /// @param _amount The amount of `want` tokens to withdraw\n    function withdraw(uint256 _amount) external onlyController {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        uint256 balance = want.balanceOf(address(this));\n        //if the contract doesn't have enough want, withdraw from Convex\n        if (balance < _amount)\n            convexConfig.baseRewardPool.withdrawAndUnwrap(\n                _amount - balance,\n                false\n            );\n\n        want.safeTransfer(vault, _amount);\n    }\n\n    /// @notice Allows the controller to withdraw all `want` tokens. Normally used when migrating strategies\n    /// @return balance The total amount of funds that have been withdrawn\n    function withdrawAll() external onlyController returns (uint256 balance) {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        convexConfig.baseRewardPool.withdrawAllAndUnwrap(false);\n\n        balance = want.balanceOf(address(this));\n        want.safeTransfer(vault, balance);\n    }\n\n    /// @notice Allows the controller to claim JPEG rewards from Convex\n    /// and withdraw JPEG to the `_to` address\n    /// @param _to The address to send JPEG to\n    function withdrawJPEG(address _to) external onlyController {\n        // claim from convex rewards pool\n        convexConfig.baseRewardPool.getReward(address(this), true);\n        jpeg.safeTransfer(_to, jpeg.balanceOf(address(this)));\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to compound Convex rewards into Curve\n    /// @param minOutCurve The minimum amount of `want` tokens to receive\n    function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n        convexConfig.baseRewardPool.getReward(address(this), true);\n\n        //Prevent `Stack too deep` errors\n        {\n            DexConfig memory dex = dexConfig;\n            IERC20[] memory rewardTokens = strategyConfig.rewardTokens;\n            IERC20 _weth = weth;\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = rewardTokens[i].balanceOf(address(this));\n\n                if (balance > 0)\n                    //minOut is not needed here, we already have it on the Curve deposit\n                    _swapUniswapV2(\n                        dex.uniswapV2,\n                        rewardTokens[i],\n                        _weth,\n                        balance,\n                        0\n                    );\n            }\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n            require(wethBalance > 0, \"NOOP\");\n\n            //handle sending jpeg here\n\n            _weth.safeIncreaseAllowance(address(dex.uniswapV3), wethBalance);\n\n            //minOut is not needed here, we already have it on the Curve deposit\n            ISwapRouter.ExactInputParams memory params = ISwapRouter\n                .ExactInputParams(\n                    abi.encodePacked(weth, uint24(500), usdc),\n                    address(this),\n                    block.timestamp,\n                    wethBalance,\n                    0\n                );\n\n            dex.uniswapV3.exactInput(params);\n        }\n\n        StrategyConfig memory strategy = strategyConfig;\n        CurveConfig memory curve = curveConfig;\n\n        uint256 usdcBalance = usdc.balanceOf(address(this));\n\n        //take the performance fee\n        uint256 fee = (usdcBalance * performanceFee.numerator) /\n            performanceFee.denominator;\n        usdc.safeTransfer(strategy.controller.feeAddress(), fee);\n        usdcBalance -= fee;\n\n        uint256 pusdCurveBalance = curve.curve.balances(curve.pusdIndex);\n        //USDC has 6 decimals while PUSD has 18. We need to convert the USDC\n        //balance to 18 decimals to compare it with the PUSD balance\n        uint256 usdcCurveBalance = curve.curve.balances(curve.usdcIndex) *\n            10**12;\n\n        //The curve pool has 4 tokens, we are doing a single asset deposit with either USDC or PUSD\n        uint256[4] memory liquidityAmounts = [uint256(0), 0, 0, 0];\n        if (usdcCurveBalance > pusdCurveBalance) {\n            //if there's more USDC than PUSD in the pool, use USDC as collateral to mint PUSD\n            //and deposit it into the Curve pool\n            usdc.safeIncreaseAllowance(\n                address(strategy.usdcVault),\n                usdcBalance\n            );\n            strategy.usdcVault.deposit(usdcBalance);\n\n            //check the vault's credit limit, it should be 1:1 for USDC\n            uint256 toBorrow = strategy.usdcVault.getCreditLimit(usdcBalance);\n\n            strategy.usdcVault.borrow(toBorrow);\n            liquidityAmounts[curve.pusdIndex] = toBorrow;\n\n            pusd.safeIncreaseAllowance(address(curve.curve), toBorrow);\n        } else {\n            //if there's more PUSD than USDC in the pool, deposit USDC\n            liquidityAmounts[curve.usdcIndex] = usdcBalance;\n            usdc.safeIncreaseAllowance(address(curve.curve), usdcBalance);\n        }\n\n        curve.curve.add_liquidity(liquidityAmounts, minOutCurve);\n\n        uint256 wantBalance = balanceOfWant();\n\n        deposit();\n\n        earned += wantBalance;\n        emit Harvested(wantBalance);\n    }\n\n    /// @dev Swaps `tokenIn` for `tokenOut` on UniswapV2 (or Sushiswap)\n    /// @param router The UniswapV2 (or Sushiswap) router\n    /// @param tokenIn The input token for the swap\n    /// @param tokenOut The output token for the swap\n    /// @param amountIn The amount of `tokenIn` to swap\n    /// @param minOut The minimum amount of `tokenOut` to receive for the TX not to revert\n    function _swapUniswapV2(\n        IUniswapV2Router router,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountIn,\n        uint256 minOut\n    ) internal {\n        tokenIn.safeIncreaseAllowance(address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = address(tokenIn);\n        path[1] = address(tokenOut);\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            minOut,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title JPEG'd LP Farming\n/// @notice Users can stake their JPEG'd ecosystem LP tokens to get JPEG rewards\n/// @dev This contract doesn't mint JPEG tokens, instead the owner (the JPEG'd DAO) allocates x amount of JPEG to be distributed as a reward for liquidity providers.\n/// To ensure that enough tokens are allocated, an epoch system is implemented.\n/// The owner is required to allocate enough tokens (`_rewardPerBlock * (_endBlock - _startBlock)`) when creating a new epoch.\n/// When there no epoch is ongoing, the contract stops emitting rewards\ncontract LPFarming is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event ClaimAll(address indexed user, uint256 amount);\n\n    /// @dev Data relative to a user's staking position\n    /// @param amount The amount of LP tokens the user has provided\n    /// @param lastAccRewardPerShare The `accRewardPerShare` pool value at the time of the user's last claim\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastAccRewardPerShare;\n    }\n\n    /// @dev Data relative to an LP pool\n    /// @param lpToken The LP token accepted by the pool\n    /// @param allocPoint Allocation points assigned to the pool. Determines the share of `rewardPerBlock` allocated to this pool\n    /// @param lastRewardBlock Last block number in which reward distribution occurred\n    /// @param accRewardPerShare Accumulated rewards per share, times 1e36. The amount of rewards the pool has accumulated per unit of LP token deposited\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 accRewardPerShare;\n    }\n\n    /// @dev Data relative to an epoch\n    /// @param startBlock The epoch's starting block\n    /// @param endBlock The epoch's starting block\n    /// @param rewardPerBlock The amount of JPEG rewards distributed per block during this epoch\n    struct EpochInfo {\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 rewardPerBlock;\n    }\n\n    /// @notice The reward token, JPEG\n    IERC20 public immutable jpeg;\n\n    /// @notice The current epoch\n    /// @dev We don't need to store data about previous epochs, to simplify logic we only store data about the current epoch\n    EpochInfo public epoch;\n    /// @notice All the LP pools, active and inactive\n    PoolInfo[] public poolInfo;\n    /// @notice User staking positions, divided by PID\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice Sum of the allocation points for all the pools\n    /// @dev Used to calculate the share of `rewardPerBlock` for each pool.\n    uint256 public totalAllocPoint;\n\n    /// @dev User's (total) withdrawable rewards\n    mapping(address => uint256) private userRewards;\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _jpeg The reward token\n    constructor(address _jpeg) {\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the LP farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting liquidity providers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to start a new epoch. Can only be called when there's no ongoing epoch\n    /// @param _startBlock The new epoch's start block. Has to be greater than the previous epoch's `endBlock`\n    /// @param _endBlock The new epoch's end block. Has to be greater than `_startBlock`\n    /// @param _rewardPerBlock The new epoch's amount of rewards to distribute per block. Must be greater than 0\n    function newEpoch(\n        uint256 _startBlock,\n        uint256 _endBlock,\n        uint256 _rewardPerBlock\n    ) external onlyOwner {\n        require(_startBlock >= block.number, \"Invalid start block\");\n        require(_endBlock > _startBlock, \"Invalid end block\");\n        require(_rewardPerBlock > 0, \"Invalid reward per block\");\n\n        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`\n        _massUpdatePools();\n\n        uint256 remainingRewards = epoch.rewardPerBlock *\n            (epoch.endBlock - _blockNumber());\n        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);\n\n        epoch.startBlock = _startBlock;\n        epoch.endBlock = _endBlock;\n        epoch.rewardPerBlock = _rewardPerBlock;\n\n        if (remainingRewards > newRewards) {\n            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);\n        } else if (remainingRewards < newRewards) {\n            jpeg.safeTransferFrom(\n                msg.sender,\n                address(this),\n                newRewards - remainingRewards\n            );\n        }\n    }\n\n    /// @notice Allows the owner to add a new pool\n    /// @param _allocPoint Allocation points to assign to the new pool\n    /// @param _lpToken The LP token accepted by the new pool\n    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 lastRewardBlock = _blockNumber();\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accRewardPerShare: 0\n            })\n        );\n    }\n\n    /// @notice Allows the owner to change a pool's allocation points\n    /// @param _pid The pool id of the pool to modify\n    /// @param _allocPoint The new allocation points\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if (prevAllocPoint != _allocPoint) {\n            totalAllocPoint = totalAllocPoint - prevAllocPoint + _allocPoint;\n        }\n    }\n\n    /// @notice Returns the number of pools available\n    /// @return The length of the `poolInfo` array\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim from the pool with id `_pid`\n    /// @param _pid The pool id\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable from `_pid` by user `_user`\n    function pendingReward(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (blockNumber > lastRewardBlock && lpSupply != 0) {\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            accRewardPerShare += reward / lpSupply;\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of LP tokens in the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _pid The id of the pool to deposit into\n    /// @param _amount The amount of LP tokens to deposit\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n        user.amount = user.amount + _amount;\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of LP tokens from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _pid The id of the pool to withdraw from\n    /// @param _amount The amount of LP tokens to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"insufficient_amount\");\n\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        user.amount -= _amount;\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @dev Normalizes the current `block.number`. See {_normalizeBlockNumber} for more info\n    /// @return Normalized `block.number`\n    function _blockNumber() internal view returns (uint256) {\n        return _normalizeBlockNumber(block.number);\n    }\n\n    /// @dev Normalizes `blockNumber` to fit within the bounds of an epoch.\n    /// This is done to ensure that no rewards are distributed for staking outside of an epoch without modifying the reward logic.\n    /// For example:\n    /// `blockNumber` is 1100, the epoch's `endBlock` is 1000. In this case the function would return 1000. If this value were to be used\n    /// in the {_updatePool} function, where the pool's `lastRewardBlock` is 990, only the rewards from block 990 to block 1000 would be distributed\n    /// @return Normalized `blockNumber`\n    function _normalizeBlockNumber(uint256 blockNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        if (blockNumber < epoch.startBlock) return epoch.startBlock;\n\n        if (blockNumber > epoch.endBlock) return epoch.endBlock;\n\n        return blockNumber;\n    }\n\n    /// @dev Calls {_updatePool} for every pool\n    function _massUpdatePools() internal {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(pid);\n        }\n    }\n\n    /// @dev Updates the state of the pool at index `_pid`\n    /// @param _pid The pool to update\n    function _updatePool(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (pool.allocPoint == 0) {\n            return;\n        }\n\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        if (blockNumber <= lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = blockNumber;\n            return;\n        }\n        uint256 reward = ((blockNumber - lastRewardBlock) *\n            epoch.rewardPerBlock *\n            1e36 *\n            pool.allocPoint) / totalAllocPoint;\n        pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n        pool.lastRewardBlock = blockNumber;\n    }\n\n    /// @dev Updates `msg.sender`'s claimable rewards by adding pending rewards from `_pid`\n    /// @param _pid The pool to withdraw rewards from\n    function _withdrawReward(uint256 _pid) internal returns (uint256) {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 pending = (user.amount *\n            (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n        if (pending > 0) {\n            userRewards[msg.sender] += pending;\n        }\n\n        user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @notice Allows users to claim rewards from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    /// @param _pid The pool to claim rewards from\n    function claim(uint256 _pid) external nonReentrant noContract(msg.sender) {\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit Claim(msg.sender, _pid, rewards);\n    }\n\n    /// @notice Allows users to claim rewards from all pools. Non whitelisted contracts can't call this function\n    /// @dev Emits a {ClaimAll} event\n    function claimAll() external nonReentrant noContract(msg.sender) {\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            _updatePool(i);\n            _withdrawReward(i);\n        }\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit ClaimAll(msg.sender, rewards);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "CodeNames": [
            "StrategyPUSDConvex.sol",
            "LPFarming.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "jsx\nit.only(\"will revert when attempting to migrate strategy\", async () = {\n  await controller.setVault(want.address, yVault.address);\n  await expect(controller.setStrategy(want.address, strategy.address)).to.be.revertedWith(\"jpeg\");\n});\n"
                ],
                "Type": " Controller: Strategy migration will fail",
                "Description": "\nController.sol#L95(https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/Controller.sol#L95)<br\nStrategyPUSDConvex.sol#L266(https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L266)<br\n\nThe controller calls the withdraw() method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done.\n\nThe migration would therefore revert.\n\n\nInsert this test into StrategyPUSDConvex.ts(https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/StrategyPUSDConvex.ts).\n\njsx\nit.only(\"will revert when attempting to migrate strategy\", async () = {\n  await controller.setVault(want.address, yVault.address);\n  await expect(controller.setStrategy(want.address, strategy.address)).to.be.revertedWith(\"jpeg\");\n});\n\n\n",
                "Repair": "\nReplace _current.withdraw(address(jpeg)); with _current.withdrawJPEG(vaults[_token]).\n\nspaghettieth (JPEG'd) confirmed and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/57#issuecomment-1096633358):\n  The proposed migration steps would modify the intended behaviour, which is to withdraw JPEG to the controller and not the vault. A correct solution would be replacing _current.withdraw(address(jpeg)) with _current.withdrawJPEG(address(this)).\n\nspaghettieth (JPEG'd) resolved and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/57#issuecomment-1099242526):\n  Fixed in jpegd/core#6(https://github.com/jpegd/core/pull/6).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../interfaces/ISwapRouter.sol\";\nimport \"../../../interfaces/IUniswapV2Router.sol\";\nimport \"../../../interfaces/ICurve.sol\";\nimport \"../../../interfaces/IBooster.sol\";\nimport \"../../../interfaces/IBaseRewardPool.sol\";\n\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IFungibleAssetVaultForDAO.sol\";\n\n/// @title JPEG'd PUSD Convex autocompounding strategy\n/// @notice This strategy autocompounds Convex rewards from the PUSD/USDC/USDT/MIM Curve pool.\n/// @dev The strategy deposits either USDC or PUSD in the Curve pool depending on which one has lower liquidity.\n/// The strategy sells reward tokens for USDC. If the pool has less PUSD than USDC, this contract uses the\n/// USDC {FungibleAssetVaultForDAO} to mint PUSD using USDC as collateral\ncontract StrategyPUSDConvex is AccessControl {\n    using SafeERC20 for IERC20;\n\n    event Harvested(uint256 wantEarned);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    /// @param booster Convex Booster's address\n    /// @param baseRewardPool Convex BaseRewardPool's address\n    /// @param pid The Convex pool id for PUSD/USDC/USDT/MIM LP tokens\n    struct ConvexConfig {\n        IBooster booster;\n        IBaseRewardPool baseRewardPool;\n        uint256 pid;\n    }\n\n    /// @param curve Curve's PUSD/USDC/USDT/MIM pool address\n    /// @param usdcIndex The USDC token index in curve's pool\n    /// @param pusdIndex The PUSD token index in curve's pool\n    struct CurveConfig {\n        ICurve curve;\n        uint256 usdcIndex;\n        uint256 pusdIndex;\n    }\n\n    /// @param uniswapV2 The UniswapV2 (or Sushiswap) router address\n    /// @param uniswapV3 The UniswapV3 router address\n    struct DexConfig {\n        IUniswapV2Router uniswapV2;\n        ISwapRouter uniswapV3;\n    }\n\n    /// @param rewardTokens The Convex reward tokens\n    /// @param controller The strategy controller\n    /// @param usdcVault The JPEG'd USDC {FungibleAssetVaultForDAO} address\n    struct StrategyConfig {\n        IERC20[] rewardTokens;\n        IController controller;\n        IFungibleAssetVaultForDAO usdcVault;\n    }\n\n    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\n\n    /// @notice The PUSD/USDC/USDT/MIM Curve LP token\n    IERC20 public immutable want;\n    IERC20 public immutable jpeg;\n    IERC20 public immutable pusd;\n    IERC20 public immutable weth;\n    IERC20 public immutable usdc;\n\n    DexConfig public dexConfig;\n    CurveConfig public curveConfig;\n    ConvexConfig public convexConfig;\n    StrategyConfig public strategyConfig;\n\n    /// @notice The performance fee to be sent to the DAO/strategists\n    Rate public performanceFee;\n\n    /// @notice lifetime strategy earnings denominated in `want` token\n    uint256 public earned;\n\n    /// @param _want The PUSD/USDC/USDT/MIM Curve LP token\n    /// @param _jpeg The JPEG token address\n    /// @param _pusd The PUSD token address\n    /// @param _weth The WETH token address\n    /// @param _usdc The USDC token address\n    /// @param _dexConfig See {DexConfig} struct\n    /// @param _curveConfig See {CurveConfig} struct\n    /// @param _convexConfig See {ConvexConfig} struct\n    /// @param _strategyConfig See {StrategyConfig} struct\n    /// @param _performanceFee The rate of USDC to be sent to the DAO/strategists\n    constructor(\n        address _want,\n        address _jpeg,\n        address _pusd,\n        address _weth,\n        address _usdc,\n        DexConfig memory _dexConfig,\n        CurveConfig memory _curveConfig,\n        ConvexConfig memory _convexConfig,\n        StrategyConfig memory _strategyConfig,\n        Rate memory _performanceFee\n    ) {\n        require(_want != address(0), \"INVALID_WANT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n        require(_pusd != address(0), \"INVALID_PUSD\");\n        require(_weth != address(0), \"INVALID_WETH\");\n        require(_usdc != address(0), \"INVALID_USDC\");\n        require(\n            address(_dexConfig.uniswapV2) != address(0),\n            \"INVALID_UNISWAP_V2\"\n        );\n        require(\n            address(_dexConfig.uniswapV3) != address(0),\n            \"INVALID_UNISWAP_V3\"\n        );\n        require(address(_curveConfig.curve) != address(0), \"INVALID_CURVE\");\n        require(\n            _curveConfig.pusdIndex != _curveConfig.usdcIndex,\n            \"INVALID_CURVE_INDEXES\"\n        );\n        require(_curveConfig.pusdIndex < 4, \"INVALID_PUSD_CURVE_INDEX\");\n        require(_curveConfig.usdcIndex < 4, \"INVALID_USDC_CURVE_INDEX\");\n        require(\n            address(_convexConfig.booster) != address(0),\n            \"INVALID_CONVEX_BOOSTER\"\n        );\n        require(\n            address(_convexConfig.baseRewardPool) != address(0),\n            \"INVALID_CONVEX_BASE_REWARD_POOL\"\n        );\n        require(\n            address(_strategyConfig.controller) != address(0),\n            \"INVALID_CONTROLLER\"\n        );\n        require(\n            address(_strategyConfig.usdcVault) != address(0),\n            \"INVALID_USDC_VAULT\"\n        );\n\n        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\n            require(\n                address(_strategyConfig.rewardTokens[i]) != address(0),\n                \"INVALID_REWARD_TOKEN\"\n            );\n        }\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        setPerformanceFee(_performanceFee);\n\n        want = IERC20(_want);\n        jpeg = IERC20(_jpeg);\n        pusd = IERC20(_pusd);\n        weth = IERC20(_weth);\n        usdc = IERC20(_usdc);\n\n        dexConfig = _dexConfig;\n        curveConfig = _curveConfig;\n        convexConfig = _convexConfig;\n        strategyConfig = _strategyConfig;\n    }\n\n    modifier onlyController() {\n        require(\n            msg.sender == address(strategyConfig.controller),\n            \"NOT_CONTROLLER\"\n        );\n        _;\n    }\n\n    /// @notice Allows the DAO to set the performance fee\n    /// @param _performanceFee The new performance fee\n    function setPerformanceFee(Rate memory _performanceFee)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(\n            _performanceFee.denominator > 0 &&\n                _performanceFee.denominator >= _performanceFee.numerator,\n            \"INVALID_RATE\"\n        );\n        performanceFee = _performanceFee;\n    }\n\n    /// @notice Allows the DAO to set the strategy controller\n    /// @param _controller The new strategy controller\n    function setController(address _controller)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        strategyConfig.controller = IController(_controller);\n    }\n\n    /// @notice Allows the DAO to set the USDC vault\n    /// @param _vault The new USDC vault\n    function setUSDCVault(address _vault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_vault != address(0), \"INVALID_USDC_VAULT\");\n        strategyConfig.usdcVault = IFungibleAssetVaultForDAO(_vault);\n    }\n\n    /// @return The strategy's name\n    function getName() external pure returns (string memory) {\n        return \"StrategyPUSDConvex\";\n    }\n\n    /// @return The amount of `want` tokens held by this contract\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @return The amount of `want` tokens deposited in the Convex pool by this contract\n    function balanceOfPool() public view returns (uint256) {\n        return convexConfig.baseRewardPool.balanceOf(address(this));\n    }\n\n    /// @return The amount of JPEG currently held by this contract and the amount of JPEG\n    /// rewards available from Convex\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n\n    /// @return The total amount of `want` tokens this contract manages (held + deposited)\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant() + balanceOfPool();\n    }\n\n    /// @notice Allows anyone to deposit the total amount of `want` tokens in this contract into Convex\n    function deposit() public {\n        uint256 balance = want.balanceOf(address(this));\n        ConvexConfig memory convex = convexConfig;\n        want.safeIncreaseAllowance(address(convex.booster), balance);\n        convex.booster.depositAll(convex.pid, true);\n    }\n\n    /// @notice Controller only function that allows to withdraw non-strategy tokens (e.g tokens sent accidentally)\n    function withdraw(IERC20 _asset)\n        external\n        onlyController\n        returns (uint256 balance)\n    {\n        require(want != _asset, \"want\");\n        require(pusd != _asset, \"pusd\");\n        require(usdc != _asset, \"usdc\");\n        require(weth != _asset, \"weth\");\n        require(jpeg != _asset, \"jpeg\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(address(strategyConfig.controller), balance);\n    }\n\n    /// @notice Allows the controller to withdraw `want` tokens. Normally used with a vault withdrawal\n    /// @param _amount The amount of `want` tokens to withdraw\n    function withdraw(uint256 _amount) external onlyController {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        uint256 balance = want.balanceOf(address(this));\n        //if the contract doesn't have enough want, withdraw from Convex\n        if (balance < _amount)\n            convexConfig.baseRewardPool.withdrawAndUnwrap(\n                _amount - balance,\n                false\n            );\n\n        want.safeTransfer(vault, _amount);\n    }\n\n    /// @notice Allows the controller to withdraw all `want` tokens. Normally used when migrating strategies\n    /// @return balance The total amount of funds that have been withdrawn\n    function withdrawAll() external onlyController returns (uint256 balance) {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        convexConfig.baseRewardPool.withdrawAllAndUnwrap(false);\n\n        balance = want.balanceOf(address(this));\n        want.safeTransfer(vault, balance);\n    }\n\n    /// @notice Allows the controller to claim JPEG rewards from Convex\n    /// and withdraw JPEG to the `_to` address\n    /// @param _to The address to send JPEG to\n    function withdrawJPEG(address _to) external onlyController {\n        // claim from convex rewards pool\n        convexConfig.baseRewardPool.getReward(address(this), true);\n        jpeg.safeTransfer(_to, jpeg.balanceOf(address(this)));\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to compound Convex rewards into Curve\n    /// @param minOutCurve The minimum amount of `want` tokens to receive\n    function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n        convexConfig.baseRewardPool.getReward(address(this), true);\n\n        //Prevent `Stack too deep` errors\n        {\n            DexConfig memory dex = dexConfig;\n            IERC20[] memory rewardTokens = strategyConfig.rewardTokens;\n            IERC20 _weth = weth;\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = rewardTokens[i].balanceOf(address(this));\n\n                if (balance > 0)\n                    //minOut is not needed here, we already have it on the Curve deposit\n                    _swapUniswapV2(\n                        dex.uniswapV2,\n                        rewardTokens[i],\n                        _weth,\n                        balance,\n                        0\n                    );\n            }\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n            require(wethBalance > 0, \"NOOP\");\n\n            //handle sending jpeg here\n\n            _weth.safeIncreaseAllowance(address(dex.uniswapV3), wethBalance);\n\n            //minOut is not needed here, we already have it on the Curve deposit\n            ISwapRouter.ExactInputParams memory params = ISwapRouter\n                .ExactInputParams(\n                    abi.encodePacked(weth, uint24(500), usdc),\n                    address(this),\n                    block.timestamp,\n                    wethBalance,\n                    0\n                );\n\n            dex.uniswapV3.exactInput(params);\n        }\n\n        StrategyConfig memory strategy = strategyConfig;\n        CurveConfig memory curve = curveConfig;\n\n        uint256 usdcBalance = usdc.balanceOf(address(this));\n\n        //take the performance fee\n        uint256 fee = (usdcBalance * performanceFee.numerator) /\n            performanceFee.denominator;\n        usdc.safeTransfer(strategy.controller.feeAddress(), fee);\n        usdcBalance -= fee;\n\n        uint256 pusdCurveBalance = curve.curve.balances(curve.pusdIndex);\n        //USDC has 6 decimals while PUSD has 18. We need to convert the USDC\n        //balance to 18 decimals to compare it with the PUSD balance\n        uint256 usdcCurveBalance = curve.curve.balances(curve.usdcIndex) *\n            10**12;\n\n        //The curve pool has 4 tokens, we are doing a single asset deposit with either USDC or PUSD\n        uint256[4] memory liquidityAmounts = [uint256(0), 0, 0, 0];\n        if (usdcCurveBalance > pusdCurveBalance) {\n            //if there's more USDC than PUSD in the pool, use USDC as collateral to mint PUSD\n            //and deposit it into the Curve pool\n            usdc.safeIncreaseAllowance(\n                address(strategy.usdcVault),\n                usdcBalance\n            );\n            strategy.usdcVault.deposit(usdcBalance);\n\n            //check the vault's credit limit, it should be 1:1 for USDC\n            uint256 toBorrow = strategy.usdcVault.getCreditLimit(usdcBalance);\n\n            strategy.usdcVault.borrow(toBorrow);\n            liquidityAmounts[curve.pusdIndex] = toBorrow;\n\n            pusd.safeIncreaseAllowance(address(curve.curve), toBorrow);\n        } else {\n            //if there's more PUSD than USDC in the pool, deposit USDC\n            liquidityAmounts[curve.usdcIndex] = usdcBalance;\n            usdc.safeIncreaseAllowance(address(curve.curve), usdcBalance);\n        }\n\n        curve.curve.add_liquidity(liquidityAmounts, minOutCurve);\n\n        uint256 wantBalance = balanceOfWant();\n\n        deposit();\n\n        earned += wantBalance;\n        emit Harvested(wantBalance);\n    }\n\n    /// @dev Swaps `tokenIn` for `tokenOut` on UniswapV2 (or Sushiswap)\n    /// @param router The UniswapV2 (or Sushiswap) router\n    /// @param tokenIn The input token for the swap\n    /// @param tokenOut The output token for the swap\n    /// @param amountIn The amount of `tokenIn` to swap\n    /// @param minOut The minimum amount of `tokenOut` to receive for the TX not to revert\n    function _swapUniswapV2(\n        IUniswapV2Router router,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountIn,\n        uint256 minOut\n    ) internal {\n        tokenIn.safeIncreaseAllowance(address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = address(tokenIn);\n        path[1] = address(tokenOut);\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            minOut,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault token farm\n/// @notice Users can stake their JPEG'd vault tokens and earn JPEG rewards\n/// @dev The rewards are taken from the PUSD Convex pool and distributed to stakers based on their share of the total staked tokens.\ncontract YVaultLPFarming is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IYVault;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 rewards);\n\n    IYVault public immutable vault;\n    IERC20 public immutable jpeg;\n\n    uint256 public totalStaked;\n\n    uint256 internal lastRewardBlock;\n    uint256 internal previousBalance;\n    uint256 internal accRewardPerShare;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) private userLastAccRewardPerShare;\n    mapping(address => uint256) private userPendingRewards;\n\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    ///@param _vault The yVault address\n    ///@param _jpeg The JPEG token address\n    constructor(address _vault, address _jpeg) {\n        require(_vault != address(0), \"INVALID_VAULT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n\n        vault = IYVault(_vault);\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting farmers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable by user `_user`\n    function pendingReward(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 rewardShare = accRewardPerShare;\n        uint256 staked = totalStaked;\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (block.number > lastRewardBlock && staked > 0) {\n            (rewardShare, ) = _computeUpdate();\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userPendingRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (balanceOf[_user] * (rewardShare - userLastAccRewardPerShare[_user])) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _amount The amount of tokens to deposit\n    function deposit(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        vault.safeTransferFrom(msg.sender, address(this), _amount);\n\n        balanceOf[msg.sender] += _amount;\n        totalStaked += _amount;\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _amount The amount of tokens to withdraw\n    function withdraw(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n        require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        balanceOf[msg.sender] -= _amount;\n        totalStaked -= _amount;\n\n        vault.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to claim rewards. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    function claim() external noContract(msg.sender) {\n        _update();\n        _withdrawReward(msg.sender);\n\n        uint256 rewards = userPendingRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        userPendingRewards[msg.sender] = 0;\n        //we are subtracting the claimed rewards from the previous to have a consistent value next time\n        //{_update is called}\n        previousBalance -= rewards;\n\n        if (jpeg.balanceOf(address(this)) < rewards)\n            vault.withdrawJPEG();\n\n        jpeg.safeTransfer(msg.sender, rewards);\n\n        emit Claim(msg.sender, rewards);\n    }\n\n    /// @dev Updates this contract's rewards state\n    function _update() internal {\n        if (block.number <= lastRewardBlock) return;\n\n        lastRewardBlock = block.number;\n\n        if (totalStaked == 0) return;\n\n        (accRewardPerShare, previousBalance) = _computeUpdate();\n    }\n\n    /// @dev Computes the updated contract state without writing storage\n    /// @return newAccRewardsPerShare The new value of `accRewardsPerShare`\n    /// @return currentBalance The new value of `previousBalance`\n    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {\n        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\n        uint256 newRewards = currentBalance - previousBalance;\n\n        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;\n    }\n\n    /// @dev Updates `account`'s claimable rewards by adding pending rewards\n    /// @param account The account to update\n    function _withdrawReward(address account) internal returns (uint256) {\n        uint256 pending = (balanceOf[account] *\n            (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36;\n\n        if (pending > 0) userPendingRewards[account] += pending;\n\n        userLastAccRewardPerShare[account] = accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ninterface IBaseRewardPool {\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        external\n        returns (bool);\n\n    function withdrawAllAndUnwrap(bool claim) external;\n\n    function getReward(address _account, bool _claimExtras)\n        external\n        returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function extraRewards(uint256) external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function earned() external view returns (uint256);\n}\n\n\n",
        "CodeNames": [
            "StrategyPUSDConvex.sol",
            "yVaultLPFarming.sol",
            "IBaseRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "YVault",
                    "balanceOfJPEG",
                    "earned",
                    "earned(address)"
                ],
                "Type": "  StrategyPUSDConvex.balanceOfJPEG  uses incorrect function signature while calling  extraReward.earned , causing the function to unexpectedly revert everytime",
                "Description": "\nStrategyPUSDConvex.sol#L234(https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234)<br\n\nAs specified in Convex BaseRewardPool.sol(https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and VirtualRewardPool.sol(https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of earned is earned(address). However, balanceOfJPEG did not pass any arguments to earned, which would cause balanceOfJPEG to always revert.\n\nThis bug will propagate through Controller and YVault until finally reaching the source of the call in YVaultLPFarming ._computeUpdate, and render the entire farming contract unuseable.\n\n\nBoth BaseRewardPool.earned and VirtualBalanceRewardPool.earned takes an address as argument\n\n        function earned(address account) public view returns (uint256) {\n            return\n                balanceOf(account)\n                    .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                    .div(1e18)\n                    .add(rewards[account]);\n        }\n\n        function earned(address account) public view returns (uint256) {\n            return\n                balanceOf(account)\n                    .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                    .div(1e18)\n                    .add(rewards[account]);\n        }\n\nBut balanceOfJPEG does not pass any address to extraReward.earned, causing the entire function to revert when called\n\n        function balanceOfJPEG() external view returns (uint256) {\n            uint256 availableBalance = jpeg.balanceOf(address(this));\n\n            IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n            uint256 length = baseRewardPool.extraRewardsLength();\n            for (uint256 i = 0; i < length; i++) {\n                IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n                if (address(jpeg) == extraReward.rewardToken()) {\n                    availableBalance += extraReward.earned();\n                    //we found jpeg, no need to continue the loop\n                    break;\n                }\n            }\n\n            return availableBalance;\n        }\n\n\nvim, ganache-cli\n\n",
                "Repair": "\nPass address(this) as argument of earned.\n\nNotice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.\n\n        function balanceOfJPEG() external view returns (uint256) {\n            uint256 availableBalance = jpeg.balanceOf(address(this));\n\n            IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n            availableBalance += baseRewardPool.earned(address(this));\n            uint256 length = baseRewardPool.extraRewardsLength();\n            for (uint256 i = 0; i < length; i++) {\n                IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n                if (address(jpeg) == extraReward.rewardToken()) {\n                    availableBalance += extraReward.earned(address(this));\n                }\n            }\n\n            return availableBalance;\n        }\n\nspaghettieth (JPEG'd) confirmed, but disagreed with High severity(https://github.com/code-423n4/2022-04-jpegd-findings/issues/139)\n\nspaghettieth (JPEG'd) resolved and commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/139#issuecomment-1099248200):\n  Fixed in jpegd/core#15(https://github.com/jpegd/core/pull/15).\n\nLSDan (judge) commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/139#issuecomment-1109915863):\n  Leaving this as high risk. The issue would cause a loss of funds.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IJPEGLock.sol\";\n\n/// @title NFT lending vault\n/// @notice This contracts allows users to borrow PUSD using NFTs as collateral.\n/// The floor price of the NFT collection is fetched using a chainlink oracle, while some other more valuable traits\n/// can have an higher price set by the DAO. Users can also increase the price (and thus the borrow limit) of their\n/// NFT by submitting a governance proposal. If the proposal is approved the user can lock a percentage of the new price\n/// worth of JPEG to make it effective\ncontract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    event PositionOpened(address indexed owner, uint256 indexed index);\n    event Borrowed(\n        address indexed owner,\n        uint256 indexed index,\n        uint256 amount\n    );\n    event Repaid(address indexed owner, uint256 indexed index, uint256 amount);\n    event PositionClosed(address indexed owner, uint256 indexed index);\n    event Liquidated(\n        address indexed liquidator,\n        address indexed owner,\n        uint256 indexed index,\n        bool insured\n    );\n    event Repurchased(address indexed owner, uint256 indexed index);\n    event InsuranceExpired(address indexed owner, uint256 indexed index);\n\n    enum BorrowType {\n        NOT_CONFIRMED,\n        NON_INSURANCE,\n        USE_INSURANCE\n    }\n\n    struct Position {\n        BorrowType borrowType;\n        uint256 debtPrincipal;\n        uint256 debtPortion;\n        uint256 debtAmountForRepurchase;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    struct VaultSettings {\n        Rate debtInterestApr;\n        Rate creditLimitRate;\n        Rate liquidationLimitRate;\n        Rate valueIncreaseLockRate;\n        Rate organizationFeeRate;\n        Rate insurancePurchaseRate;\n        Rate insuranceLiquidationPenaltyRate;\n        uint256 insuraceRepurchaseTimeLimit;\n        uint256 borrowAmountCap;\n    }\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n\n    IStableCoin public stablecoin;\n    /// @notice Chainlink ETH/USD price feed\n    IAggregatorV3Interface public ethAggregator;\n    /// @notice Chainlink JPEG/USD price feed\n    IAggregatorV3Interface public jpegAggregator;\n    /// @notice Chainlink NFT floor oracle\n    IAggregatorV3Interface public floorOracle;\n    /// @notice Chainlink NFT fallback floor oracle\n    IAggregatorV3Interface public fallbackOracle;\n    /// @notice JPEGLocker, used by this contract to lock JPEG and increase the value of an NFT\n    IJPEGLock public jpegLocker;\n    IERC721Upgradeable public nftContract;\n\n    /// @notice If true, the floor price won't be fetched using the Chainlink oracle but\n    /// a value set by the DAO will be used instead\n    bool public daoFloorOverride;\n    // @notice If true, the floor price will be fetched using the fallback oracle\n    bool public useFallbackOracle;\n    /// @notice Total outstanding debt\n    uint256 public totalDebtAmount;\n    /// @dev Last time debt was accrued. See {accrue} for more info\n    uint256 public totalDebtAccruedAt;\n    uint256 public totalFeeCollected;\n    uint256 internal totalDebtPortion;\n\n    VaultSettings public settings;\n\n    /// @dev Keeps track of all the NFTs used as collateral for positions\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n    //bytes32(0) is floor\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n    /// @dev Checks if the provided NFT index is valid\n    /// @param nftIndex The index to check\n    modifier validNFTIndex(uint256 nftIndex) {\n        //The standard OZ ERC721 implementation of ownerOf reverts on a non existing nft isntead of returning address(0)\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n\n    /// @param _stablecoin PUSD address\n    /// @param _nftContract The NFT contrat address. It could also be the address of an helper contract\n    /// if the target NFT isn't an ERC721 (CryptoPunks as an example)\n    /// @param _ethAggregator Chainlink ETH/USD price feed address\n    /// @param _jpegAggregator Chainlink JPEG/USD price feed address\n    /// @param _floorOracle Chainlink floor oracle address\n    /// @param _fallbackOracle Chainlink fallback floor oracle address\n    /// @param _typeInitializers Used to initialize NFT categories with their value and NFT indexes.\n    /// Floor NFT shouldn't be initialized this way\n    /// @param _jpegLocker JPEGLock address\n    /// @param _settings Initial settings used by the contract\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    /// @dev The {accrue} function updates the contract's state by calculating\n    /// the additional interest accrued since the last state update\n    function accrue() public {\n        uint256 additionalInterest = _calculateAdditionalInterest();\n\n        totalDebtAccruedAt = block.timestamp;\n\n        totalDebtAmount += additionalInterest;\n        totalFeeCollected += additionalInterest;\n    }\n\n    /// @notice Allows the DAO to change the total debt cap\n    /// @param _borrowAmountCap New total debt cap\n    function setBorrowAmountCap(uint256 _borrowAmountCap)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        settings.borrowAmountCap = _borrowAmountCap;\n    }\n\n    /// @notice Allows the DAO to change the interest APR on borrows\n    /// @param _debtInterestApr The new interest rate\n    function setDebtInterestApr(Rate memory _debtInterestApr)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_debtInterestApr);\n        settings.debtInterestApr = _debtInterestApr;\n    }\n\n    /// @notice Allows the DAO to change the amount of JPEG needed to increase the value of an NFT relative to the desired value\n    /// @param _valueIncreaseLockRate The new rate\n    function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_valueIncreaseLockRate);\n        settings.valueIncreaseLockRate = _valueIncreaseLockRate;\n    }\n\n    /// @notice Allows the DAO to change the max debt to collateral rate for a position\n    /// @param _creditLimitRate The new rate\n    function setCreditLimitRate(Rate memory _creditLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_creditLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            _creditLimitRate,\n            settings.liquidationLimitRate\n        );\n\n        settings.creditLimitRate = _creditLimitRate;\n    }\n\n    /// @notice Allows the DAO to change the minimum debt to collateral rate for a position to be market as liquidatable\n    /// @param _liquidationLimitRate The new rate\n    function setLiquidationLimitRate(Rate memory _liquidationLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_liquidationLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            settings.creditLimitRate,\n            _liquidationLimitRate\n        );\n\n        settings.liquidationLimitRate = _liquidationLimitRate;\n    }\n\n    /// @notice Allows the DAO to toggle the fallback oracle\n    /// @param _useFallback Whether to use the fallback oracle\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    /// @notice Allows the DAO to change the amount of time JPEG tokens need to be locked to change the value of an NFT\n    /// @param _newLockTime The amount new lock time amount\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n    /// @notice Allows the DAO to bypass the floor oracle and override the NFT floor value\n    /// @param _newFloor The new floor\n    function overrideFloor(uint256 _newFloor) external onlyRole(DAO_ROLE) {\n        require(_newFloor > 0, \"Invalid floor\");\n        nftTypeValueETH[bytes32(0)] = _newFloor;\n        daoFloorOverride = true;\n    }\n\n    /// @notice Allows the DAO to stop overriding floor\n    function disableFloorOverride() external onlyRole(DAO_ROLE) {\n        daoFloorOverride = false;\n    }\n\n    /// @notice Allows the DAO to change the static borrow fee\n    /// @param _organizationFeeRate The new fee rate\n    function setOrganizationFeeRate(Rate memory _organizationFeeRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_organizationFeeRate);\n        settings.organizationFeeRate = _organizationFeeRate;\n    }\n\n    /// @notice Allows the DAO to change the cost of insurance\n    /// @param _insurancePurchaseRate The new insurance fee rate\n    function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_insurancePurchaseRate);\n        settings.insurancePurchaseRate = _insurancePurchaseRate;\n    }\n\n    /// @notice Allows the DAO to change the repurchase penalty rate in case of liquidation of an insured NFT\n    /// @param _insuranceLiquidationPenaltyRate The new rate\n    function setInsuranceLiquidationPenaltyRate(\n        Rate memory _insuranceLiquidationPenaltyRate\n    ) external onlyRole(DAO_ROLE) {\n        _validateRate(_insuranceLiquidationPenaltyRate);\n        settings\n            .insuranceLiquidationPenaltyRate = _insuranceLiquidationPenaltyRate;\n    }\n\n    /// @notice Allows the DAO to add an NFT to a specific price category\n    /// @param _nftIndex The index to add to the category\n    /// @param _type The category hash\n    function setNFTType(uint256 _nftIndex, bytes32 _type)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        require(\n            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\n            \"invalid_nftType\"\n        );\n        nftTypes[_nftIndex] = _type;\n    }\n\n    /// @notice Allows the DAO to change the value of an NFT category\n    /// @param _type The category hash\n    /// @param _amountETH The new value, in ETH\n    function setNFTTypeValueETH(bytes32 _type, uint256 _amountETH)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        nftTypeValueETH[_type] = _amountETH;\n    }\n\n    /// @notice Allows the DAO to set the value in ETH of the NFT at index `_nftIndex`.\n    /// A JPEG deposit by a user is required afterwards. See {finalizePendingNFTValueETH} for more details\n    /// @param _nftIndex The index of the NFT to change the value of\n    /// @param _amountETH The new desired ETH value\n    function setPendingNFTValueETH(uint256 _nftIndex, uint256 _amountETH)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        pendingNFTValueETH[_nftIndex] = _amountETH;\n    }\n\n    /// @notice Allows a user to lock up JPEG to make the change in value of an NFT effective.\n    /// Can only be called after {setPendingNFTValueETH}, which requires a governance vote.\n    /// @dev The amount of JPEG that needs to be locked is calculated by applying `valueIncreaseLockRate`\n    /// to the new credit limit of the NFT\n    /// @param _nftIndex The index of the NFT\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n\n    /// @dev Validates the credit limit rate and the liquidation limit rate.\n    /// The credit limit rate must be less than the liquidation rate\n    /// @param _creditLimitRate The credit limit rate to validate\n    /// @param _liquidationLimitRate The liquidation limit rate\n    function _validateCreditLimitAndLiquidationRate(\n        Rate memory _creditLimitRate,\n        Rate memory _liquidationLimitRate\n    ) internal pure {\n        require(\n            _liquidationLimitRate.numerator * _creditLimitRate.denominator >\n                _creditLimitRate.numerator * _liquidationLimitRate.denominator,\n            \"credit_rate_exceeds_or_equals_liquidation_rate\"\n        );\n    }\n\n    /// @dev Validates a rate. The denominator must be greater than zero and greater than or equal to the numerator.\n    /// @param rate The rate to validate\n    function _validateRate(Rate memory rate) internal pure {\n        require(\n            rate.denominator > 0 && rate.denominator >= rate.numerator,\n            \"invalid_rate\"\n        );\n    }\n\n    /// @dev Returns the value in ETH of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT, 18 decimals\n    function _getNFTValueETH(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        bytes32 nftType = nftTypes[_nftIndex];\n\n        if (nftType == bytes32(0) && !daoFloorOverride) {\n            return\n                _normalizeAggregatorAnswer(\n                    useFallbackOracle ? fallbackOracle : floorOracle\n                );\n        } else if (nftType == CUSTOM_NFT_HASH) return nftValueETH[_nftIndex];\n\n        return nftTypeValueETH[nftType];\n    }\n\n    /// @dev Returns the value in USD of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT in USD, 18 decimals\n    function _getNFTValueUSD(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 nft_value = _getNFTValueETH(_nftIndex);\n        return (nft_value * _ethPriceUSD()) / 1 ether;\n    }\n\n    /// @dev Returns the current ETH price in USD\n    /// @return The current ETH price, 18 decimals\n    function _ethPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(ethAggregator);\n    }\n\n    /// @dev Returns the current JPEG price in USD\n    /// @return The current JPEG price, 18 decimals\n    function _jpegPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(jpegAggregator);\n    }\n\n    /// @dev Fetches and converts to 18 decimals precision the latest answer of a Chainlink aggregator\n    /// @param aggregator The aggregator to fetch the answer from\n    /// @return The latest aggregator answer, normalized\n    function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n        internal\n        view\n        returns (uint256)\n    {\n        int256 answer = aggregator.latestAnswer();\n        uint8 decimals = aggregator.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n        //converts the answer to have 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    struct NFTInfo {\n        uint256 index;\n        bytes32 nftType;\n        address owner;\n        uint256 nftValueETH;\n        uint256 nftValueUSD;\n    }\n\n    /// @notice Returns data relative to the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT index\n    /// @return nftInfo The data relative to the NFT\n    function getNFTInfo(uint256 _nftIndex)\n        external\n        view\n        returns (NFTInfo memory nftInfo)\n    {\n        nftInfo = NFTInfo(\n            _nftIndex,\n            nftTypes[_nftIndex],\n            nftContract.ownerOf(_nftIndex),\n            _getNFTValueETH(_nftIndex),\n            _getNFTValueUSD(_nftIndex)\n        );\n    }\n\n    /// @dev Returns the credit limit of an NFT\n    /// @param _nftIndex The NFT to return credit limit of\n    /// @return The NFT credit limit\n    function _getCreditLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator;\n    }\n\n    /// @dev Returns the minimum amount of debt necessary to liquidate an NFT\n    /// @param _nftIndex The index of the NFT\n    /// @return The minimum amount of debt to liquidate the NFT\n    function _getLiquidationLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.liquidationLimitRate.numerator) /\n            settings.liquidationLimitRate.denominator;\n    }\n\n    /// @dev Calculates current outstanding debt of an NFT\n    /// @param _nftIndex The NFT to calculate the outstanding debt of\n    /// @return The outstanding debt value\n    function _getDebtAmount(uint256 _nftIndex) internal view returns (uint256) {\n        uint256 calculatedDebt = _calculateDebt(\n            totalDebtAmount,\n            positions[_nftIndex].debtPortion,\n            totalDebtPortion\n        );\n\n        uint256 principal = positions[_nftIndex].debtPrincipal;\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal when the accrue() function isn't called\n        //in between the first borrow and the _calculateDebt call.\n        return principal > calculatedDebt ? principal : calculatedDebt;\n    }\n\n    /// @dev Calculates the total debt of a position given the global debt, the user's portion of the debt and the total user portions\n    /// @param total The global outstanding debt\n    /// @param userPortion The user's portion of debt\n    /// @param totalPortion The total user portions of debt\n    /// @return The outstanding debt of the position\n    function _calculateDebt(\n        uint256 total,\n        uint256 userPortion,\n        uint256 totalPortion\n    ) internal pure returns (uint256) {\n        return totalPortion == 0 ? 0 : (total * userPortion) / totalPortion;\n    }\n\n    /// @dev Opens a position\n    /// Emits a {PositionOpened} event\n    /// @param _owner The owner of the position to open\n    /// @param _nftIndex The NFT used as collateral for the position\n    function _openPosition(address _owner, uint256 _nftIndex) internal {\n        nftContract.transferFrom(_owner, address(this), _nftIndex);\n\n        positions[_nftIndex] = Position({\n            borrowType: BorrowType.NOT_CONFIRMED,\n            debtPrincipal: 0,\n            debtPortion: 0,\n            debtAmountForRepurchase: 0,\n            liquidatedAt: 0,\n            liquidator: address(0)\n        });\n        positionOwner[_nftIndex] = _owner;\n        positionIndexes.add(_nftIndex);\n\n        emit PositionOpened(_owner, _nftIndex);\n    }\n\n    /// @dev Calculates the additional global interest since last time the contract's state was updated by calling {accrue}\n    /// @return The additional interest value\n    function _calculateAdditionalInterest() internal view returns (uint256) {\n        // Number of seconds since {accrue} was called\n        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;\n        if (elapsedTime == 0) {\n            return 0;\n        }\n\n        if (totalDebtAmount == 0) {\n            return 0;\n        }\n\n        // Accrue interest\n        uint256 interestPerYear = (totalDebtAmount *\n            settings.debtInterestApr.numerator) /\n            settings.debtInterestApr.denominator;\n        uint256 interestPerSec = interestPerYear / 365 days;\n\n        return elapsedTime * interestPerSec;\n    }\n\n    /// @notice Returns the number of open positions\n    /// @return The number of open positions\n    function totalPositions() external view returns (uint256) {\n        return positionIndexes.length();\n    }\n\n    /// @notice Returns all open position NFT indexes\n    /// @return The open position NFT indexes\n    function openPositionsIndexes() external view returns (uint256[] memory) {\n        return positionIndexes.values();\n    }\n\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest;\n        BorrowType borrowType;\n        bool liquidatable;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    /// @notice Returns data relative to a postition, existing or not\n    /// @param _nftIndex The index of the NFT used as collateral for the position\n    /// @return preview See assignment below\n    function showPosition(uint256 _nftIndex)\n        external\n        view\n        validNFTIndex(_nftIndex)\n        returns (PositionPreview memory preview)\n    {\n        address posOwner = positionOwner[_nftIndex];\n\n        uint256 debtPrincipal = positions[_nftIndex].debtPrincipal;\n        uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0\n            ? positions[_nftIndex].debtAmountForRepurchase //calculate updated debt\n            : _calculateDebt(\n                totalDebtAmount + _calculateAdditionalInterest(),\n                positions[_nftIndex].debtPortion,\n                totalDebtPortion\n            );\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal if no time has elapsed in between the first borrow\n        //and the _calculateDebt call.\n        if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;\n\n        preview = PositionPreview({\n            owner: posOwner, //the owner of the position, `address(0)` if the position doesn't exists\n            nftIndex: _nftIndex, //the NFT used as collateral for the position\n            nftType: nftTypes[_nftIndex], //the type of the NFT\n            nftValueUSD: _getNFTValueUSD(_nftIndex), //the value in USD of the NFT\n            vaultSettings: settings, //the current vault's settings\n            creditLimit: _getCreditLimit(_nftIndex), //the NFT's credit limit\n            debtPrincipal: debtPrincipal, //the debt principal for the position, `0` if the position doesn't exists\n            debtInterest: debtAmount - debtPrincipal, //the interest of the position\n            borrowType: positions[_nftIndex].borrowType, //the insurance type of the position, `NOT_CONFIRMED` if it doesn't exist\n            liquidatable: positions[_nftIndex].liquidatedAt == 0 &&\n                debtAmount >= _getLiquidationLimit(_nftIndex), //if the position can be liquidated\n            liquidatedAt: positions[_nftIndex].liquidatedAt, //if the position has been liquidated and it had insurance, the timestamp at which the liquidation happened\n            liquidator: positions[_nftIndex].liquidator //if the position has been liquidated and it had insurance, the address of the liquidator\n        });\n    }\n\n    /// @notice Allows users to open positions and borrow using an NFT\n    /// @dev emits a {Borrowed} event\n    /// @param _nftIndex The index of the NFT to be used as collateral\n    /// @param _amount The amount of PUSD to be borrowed. Note that the user will receive less than the amount requested,\n    /// the borrow fee and insurance automatically get removed from the amount borrowed\n    /// @param _useInsurance Whereter to open an insured position. In case the position has already been opened previously,\n    /// this parameter needs to match the previous insurance mode. To change insurance mode, a user needs to close and reopen the position\n    function borrow(\n        uint256 _nftIndex,\n        uint256 _amount,\n        bool _useInsurance\n    ) external validNFTIndex(_nftIndex) nonReentrant {\n        accrue();\n\n        require(\n            msg.sender == positionOwner[_nftIndex] ||\n                address(0) == positionOwner[_nftIndex],\n            \"unauthorized\"\n        );\n        require(_amount > 0, \"invalid_amount\");\n        require(\n            totalDebtAmount + _amount <= settings.borrowAmountCap,\n            \"debt_cap\"\n        );\n\n        if (positionOwner[_nftIndex] == address(0)) {\n            _openPosition(msg.sender, _nftIndex);\n        }\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n        require(\n            position.borrowType == BorrowType.NOT_CONFIRMED ||\n                (position.borrowType == BorrowType.USE_INSURANCE &&\n                    _useInsurance) ||\n                (position.borrowType == BorrowType.NON_INSURANCE &&\n                    !_useInsurance),\n            \"invalid_insurance_mode\"\n        );\n\n        uint256 creditLimit = _getCreditLimit(_nftIndex);\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount + _amount <= creditLimit, \"insufficient_credit\");\n\n        //calculate the borrow fee\n        uint256 organizationFee = (_amount *\n            settings.organizationFeeRate.numerator) /\n            settings.organizationFeeRate.denominator;\n\n        uint256 feeAmount = organizationFee;\n        //if the position is insured, calculate the insurance fee\n        if (position.borrowType == BorrowType.USE_INSURANCE || _useInsurance) {\n            feeAmount +=\n                (_amount * settings.insurancePurchaseRate.numerator) /\n                settings.insurancePurchaseRate.denominator;\n        }\n        totalFeeCollected += feeAmount;\n        //subtract the fee from the amount borrowed\n        stablecoin.mint(msg.sender, _amount - feeAmount);\n\n        if (position.borrowType == BorrowType.NOT_CONFIRMED) {\n            position.borrowType = _useInsurance\n                ? BorrowType.USE_INSURANCE\n                : BorrowType.NON_INSURANCE;\n        }\n\n        // update debt portion\n        if (totalDebtPortion == 0) {\n            totalDebtPortion = _amount;\n            position.debtPortion = _amount;\n        } else {\n            uint256 plusPortion = (totalDebtPortion * _amount) /\n                totalDebtAmount;\n            totalDebtPortion += plusPortion;\n            position.debtPortion += plusPortion;\n        }\n        position.debtPrincipal += _amount;\n        totalDebtAmount += _amount;\n\n        emit Borrowed(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows users to repay a portion/all of their debt. Note that since interest increases every second,\n    /// a user wanting to repay all of their debt should repay for an amount greater than their current debt to account for the\n    /// additional interest while the repay transaction is pending, the contract will only take what's necessary to repay all the debt\n    /// @dev Emits a {Repaid} event\n    /// @param _nftIndex The NFT used as collateral for the position\n    /// @param _amount The amount of debt to repay. If greater than the position's outstanding debt, only the amount necessary to repay all the debt will be taken\n    function repay(uint256 _nftIndex, uint256 _amount)\n        external\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_amount > 0, \"invalid_amount\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount > 0, \"position_not_borrowed\");\n\n        uint256 debtPrincipal = position.debtPrincipal;\n        uint256 debtInterest = debtAmount - debtPrincipal;\n\n        _amount = _amount > debtAmount ? debtAmount : _amount;\n\n        // burn all payment, the interest is sent to the DAO using the {collect} function\n        stablecoin.burnFrom(msg.sender, _amount);\n\n        uint256 paidPrincipal = _amount > debtInterest\n            ? _amount - debtInterest\n            : 0;\n\n        uint256 minusPortion = paidPrincipal == debtPrincipal\n            ? position.debtPortion\n            : (totalDebtPortion * _amount) / totalDebtAmount;\n\n        totalDebtPortion -= minusPortion;\n        position.debtPortion -= minusPortion;\n        position.debtPrincipal -= paidPrincipal;\n        totalDebtAmount -= _amount;\n\n        emit Repaid(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows a user to close a position and get their collateral back, if the position's outstanding debt is 0\n    /// @dev Emits a {PositionClosed} event\n    /// @param _nftIndex The index of the NFT used as collateral\n    function closePosition(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_getDebtAmount(_nftIndex) == 0, \"position_not_repaid\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        // transfer nft back to owner if nft was deposited\n        if (nftContract.ownerOf(_nftIndex) == address(this)) {\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit PositionClosed(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows members of the `LIQUIDATOR_ROLE` to liquidate a position. Positions can only be liquidated\n    /// once their debt amount exceeds the minimum liquidation debt to collateral value rate.\n    /// In order to liquidate a position, the liquidator needs to repay the user's outstanding debt.\n    /// If the position is not insured, it's closed immediately and the collateral is sent to the liquidator.\n    /// If the position is insured, the position remains open (interest doesn't increase) and the owner of the position has a certain amount of time\n    /// (`insuranceRepurchaseTimeLimit`) to fully repay the liquidator and pay an additional liquidation fee (`insuranceLiquidationPenaltyRate`), if this\n    /// is done in time the user gets back their collateral and their position is automatically closed. If the user doesn't repurchase their collateral\n    /// before the time limit passes, the liquidator can claim the liquidated NFT and the position is closed\n    /// @dev Emits a {Liquidated} event\n    /// @param _nftIndex The NFT to liquidate\n    function liquidate(uint256 _nftIndex)\n        external\n        onlyRole(LIQUIDATOR_ROLE)\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        address posOwner = positionOwner[_nftIndex];\n        require(posOwner != address(0), \"position_not_exist\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(\n            debtAmount >= _getLiquidationLimit(_nftIndex),\n            \"position_not_liquidatable\"\n        );\n\n        // burn all payment\n        stablecoin.burnFrom(msg.sender, debtAmount);\n\n        // update debt portion\n        totalDebtPortion -= position.debtPortion;\n        totalDebtAmount -= debtAmount;\n        position.debtPortion = 0;\n\n        bool insured = position.borrowType == BorrowType.USE_INSURANCE;\n        if (insured) {\n            position.debtAmountForRepurchase = debtAmount;\n            position.liquidatedAt = block.timestamp;\n            position.liquidator = msg.sender;\n        } else {\n            // transfer nft to liquidator\n            positionOwner[_nftIndex] = address(0);\n            delete positions[_nftIndex];\n            positionIndexes.remove(_nftIndex);\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit Liquidated(msg.sender, posOwner, _nftIndex, insured);\n    }\n\n    /// @notice Allows liquidated users who purchased insurance to repurchase their collateral within the time limit\n    /// defined with the `insuranceRepurchaseTimeLimit`. The user needs to pay the liquidator the total amount of debt\n    /// the position had at the time of liquidation, plus an insurance liquidation fee defined with `insuranceLiquidationPenaltyRate`\n    /// @dev Emits a {Repurchased} event\n    /// @param _nftIndex The NFT to repurchase\n    function repurchase(uint256 _nftIndex) external validNFTIndex(_nftIndex) {\n        Position memory position = positions[_nftIndex];\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.borrowType == BorrowType.USE_INSURANCE,\n            \"non_insurance\"\n        );\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit >=\n                block.timestamp,\n            \"insurance_expired\"\n        );\n\n        uint256 debtAmount = position.debtAmountForRepurchase;\n        uint256 penalty = (debtAmount *\n            settings.insuranceLiquidationPenaltyRate.numerator) /\n            settings.insuranceLiquidationPenaltyRate.denominator;\n\n        // transfer payment to liquidator\n        stablecoin.transferFrom(\n            msg.sender,\n            position.liquidator,\n            debtAmount + penalty\n        );\n\n        // transfer nft to user\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit Repurchased(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows the liquidator who liquidated the insured position with NFT at index `_nftIndex` to claim the position's collateral\n    /// after the time period defined with `insuranceRepurchaseTimeLimit` has expired and the position owner has not repurchased the collateral.\n    /// @dev Emits an {InsuranceExpired} event\n    /// @param _nftIndex The NFT to claim\n    function claimExpiredInsuranceNFT(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        Position memory position = positions[_nftIndex];\n        address owner = positionOwner[_nftIndex];\n        require(address(0) != owner, \"no_position\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit <\n                block.timestamp,\n            \"insurance_not_expired\"\n        );\n        require(position.liquidator == msg.sender, \"unauthorized\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit InsuranceExpired(owner, _nftIndex);\n    }\n\n    /// @notice Allows the DAO to collect interest and fees before they are repaid\n    function collect() external nonReentrant onlyRole(DAO_ROLE) {\n        accrue();\n        stablecoin.mint(msg.sender, totalFeeCollected);\n        totalFeeCollected = 0;\n    }\n\n    uint256[50] private __gap;\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IERC20Decimals.sol\";\n\n/// @title Fungible asset vault (for DAO and ecosystem contracts)\n/// @notice Allows the DAO and other whitelisted addresses to mint PUSD using fungible assets as collateral\n/// @dev The contract only supports one asset, meaning that multiple instances\n/// of this contract are going to be deployed if support for multiple assets is needed.\n/// The credit limit rate of the supported asset is set at deploy time.\n/// This contract doesn't support liquidations. In case of undercollateralization,\n/// the DAO will promptly deposit more collateral.\n/// The vault implements {AccessControlUpgradeable} and only allows whitelisted wallets\n/// to deposit/borrow/withdraw/repay. The contract doesn't keep track of the individual\n/// debt/deposited collateral of each whitelisted address, it instead uses global debt and deposited collateral.\n/// This is intentional and it's done to allow the DAO to repay debt of ecosystem contracts ({StrategyPUSDConvex}, for example)\ncontract FungibleAssetVaultForDAO is\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IStableCoin;\n\n    event Deposit(address indexed user, uint256 depositAmount);\n    event Borrow(address indexed user, uint256 borrowAmount);\n    event Repay(address indexed user, uint256 repayAmount);\n    event Withdraw(address indexed user, uint256 withdrawAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n\n    /// @dev This contract can handle unwrapped ETH if `address(0)` is passed as the `_collateralAsset`\n    /// parameter in the {initialize} function\n    address internal constant ETH = address(0);\n\n    address public collateralAsset;\n    IStableCoin public stablecoin;\n    /// @dev We store the value of a single unit of the collateral asset `10 ** decimals`\n    /// instead of fetching it everytime to save gas\n    uint256 private _collateralUnit;\n\n    IAggregatorV3Interface public oracle;\n\n    Rate public creditLimitRate;\n\n    /// @notice Amount of deposited collateral\n    uint256 public collateralAmount;\n    /// @notice Outstanding debt\n    uint256 public debtAmount;\n\n    /// @param _collateralAsset The address of the collateral asset - `address(0)` for ETH\n    /// @param _stablecoin PUSD address\n    /// @param _oracle Chainlink price feed for `_collateralAsset`/USD\n    /// @param _creditLimitRate Max outstanding debt to collateral ratio\n    function initialize(\n        address _collateralAsset,\n        IStableCoin _stablecoin,\n        IAggregatorV3Interface _oracle,\n        Rate memory _creditLimitRate\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        setCreditLimitRate(_creditLimitRate);\n\n        collateralAsset = _collateralAsset;\n        stablecoin = _stablecoin;\n        if (_collateralAsset == ETH) {\n            _collateralUnit = 1 ether;\n        } else {\n            _collateralUnit = 10**IERC20Decimals(_collateralAsset).decimals();\n        }\n\n        oracle = _oracle;\n    }\n\n    /// @notice Allows members of the `DEFAULT_ADMIN_ROLE` to change the max outstanding debt to collateral ratio\n    /// @param _creditLimitRate The new ratio\n    function setCreditLimitRate(Rate memory _creditLimitRate) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(\n            _creditLimitRate.denominator > 0 &&\n                //denominator can be equal to the numerator in some cases (stablecoins used as collateral)\n                _creditLimitRate.denominator >= _creditLimitRate.numerator,\n            \"invalid_rate\"\n        );\n        creditLimitRate = _creditLimitRate;\n    }\n\n    /// @dev Returns the USD price of one unit of collateral asset, using 18 decimals precision\n    /// @return The USD price\n    function _collateralPriceUsd() internal view returns (uint256) {\n        int256 answer = oracle.latestAnswer();\n        uint8 decimals = oracle.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n\n        //check chainlink's precision and convert it to 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    /// @dev Returns the USD value of `amount` units of collateral, using 18 decimals precision\n    /// @param amount The amount of collateral to calculate the value of\n    /// @return The USD value\n    function _getCollateralValue(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        return (amount * _collateralPriceUsd()) / _collateralUnit;\n    }\n\n    /// @notice Returns the max debt for `amount` of collateral\n    /// @param amount The amount of collateral to calculate max debt for\n    /// @return Max debt value for `amount`\n    function getCreditLimit(uint256 amount) public view returns (uint256) {\n        uint256 collateralValue = _getCollateralValue(amount);\n        return\n            (collateralValue * creditLimitRate.numerator) /\n            creditLimitRate.denominator;\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to deposit `amount` of collateral\n    /// @dev Emits a {Deposit} event\n    /// @param amount The amount of collateral to deposit\n    function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) {\n        require(amount > 0, \"invalid_amount\");\n\n        if (collateralAsset == ETH) {\n            require(msg.value == amount, \"invalid_msg_value\");\n        } else {\n            require(msg.value == 0, \"non_zero_eth_value\");\n            IERC20Upgradeable(collateralAsset).safeTransferFrom(\n                msg.sender,\n                address(this),\n                amount\n            );\n        }\n\n        collateralAmount += amount;\n\n        emit Deposit(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to borrow `amount` of PUSD against the deposited collateral\n    /// @dev Emits a {Borrow} event\n    /// @param amount The amount of PUSD to borrow\n    function borrow(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0, \"invalid_amount\");\n\n        uint256 creditLimit = getCreditLimit(collateralAmount);\n        uint256 newDebtAmount = debtAmount + amount;\n        require(newDebtAmount <= creditLimit, \"insufficient_credit\");\n\n        debtAmount = newDebtAmount;\n        stablecoin.mint(msg.sender, amount);\n\n        emit Borrow(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to repay `amount` of debt using PUSD\n    /// @dev Emits a {Repay} event\n    /// @param amount The amount of debt to repay\n    function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0, \"invalid_amount\");\n\n        amount = amount > debtAmount ? debtAmount : amount;\n\n        debtAmount -= amount;\n        stablecoin.burnFrom(msg.sender, amount);\n\n        emit Repay(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to withdraw `amount` of deposited collateral\n    /// @dev Emits a {Withdraw} event\n    /// @param amount The amount of collateral to withdraw\n    function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");\n\n        uint256 creditLimit = getCreditLimit(collateralAmount - amount);\n        require(creditLimit >= debtAmount, \"insufficient_credit\");\n\n        collateralAmount -= amount;\n\n        if (collateralAsset == ETH) payable(msg.sender).transfer(amount);\n        else\n            IERC20Upgradeable(collateralAsset).safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    uint256[50] private __gap;\n}\n\n\n",
        "CodeNames": [
            "NFTVault.sol",
            "FungibleAssetVaultForDAO.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\nuint256 debtAmount = _getDebtAmount(_nftIndex);\nrequire(\n    debtAmount = _getLiquidationLimit(_nftIndex),\n    \"position_not_liquidatable\"\n);\n\n// burn all payment\nstablecoin.burnFrom(msg.sender, debtAmount);\n"
                ],
                "Type": " Bad debts should not continue to accrue interest",
                "Description": "\nNFTVault.sol#L844-L851(https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L844-L851)<br\n\nsolidity\nuint256 debtAmount = _getDebtAmount(_nftIndex);\nrequire(\n    debtAmount = _getLiquidationLimit(_nftIndex),\n    \"position_not_liquidatable\"\n);\n\n// burn all payment\nstablecoin.burnFrom(msg.sender, debtAmount);\n\n\nIn the current design/implementation, the liquidator must fully repay the user's outstanding debt in order to get the NFT.\n\nWhen the market value of the NFT fell rapidly, the liquidators may not be able to successfully liquidate as they can not sell the NFT for more than the debt amount.\n\nIn that case, the protocol will have positions that are considered bad debts.\n\nHowever, these loans, which may never be repaid, are still accruing interest. And every time the DAO collects interest, new stablecoin will be minted.\n\nWhen the proportion of bad debts is large enough since the interest generated by these bad debts is not backed. It will damage the authenticity of the stablecoin.\n\n\nGiven:\n\n*   NFT 1 worth 30,000 USD\n*   creditLimitRate = 60%\n*   liquidationLimitRate = 50%\n*   debtInterestApr = 10%\n\n1.  Alice borrowed 10,000 USD with NFT #1;\n2.  After 1 year, NFT 1's market value in USD has suddenly dropped to 10,000 USD, no liquidator is willing to repay 11,000 USD for NFT #1;\n3.  The DAO collect() and minted 1,000 stablecoin;\n4.  After 1 year, the DAO call collect() will mint 1,100 stablecoin. and so on...\n\n",
                "Repair": "\nConsider adding a stored value to record the amount of bad debt, and add a public function that allows anyone to mark a bad debt to get some reward. and change accrue to:\n\nsolidity\nuint256 internal badDebtPortion;\n\nfunction accrue() public {\n    uint256 additionalInterest = _calculateAdditionalInterest();\n\n    totalDebtAccruedAt = block.timestamp;\n\n    totalDebtAmount += additionalInterest;\n\n    uint256 collectibleInterest = additionalInterest * (totalDebtPortion badDebtPortion) / totalDebtPortion;\n    totalFeeCollected += collectibleInterest;\n}\n\n\nspaghettieth (JPEG'd) acknowledged, but disagreed with High severity(https://github.com/code-423n4/2022-04-jpegd-findings/issues/167)\n\nLSDan (judge) commented(https://github.com/code-423n4/2022-04-jpegd-findings/issues/167#issuecomment-1109933407):\n  I agree with the warden. Left unchecked, this issue is almost certain to occur and will cause substantial negative impacts on the protocol. The only way this would not occur is if the NFT market never crashes.\n\n\n\n*\n \n\n"
            }
        ]
    }
]