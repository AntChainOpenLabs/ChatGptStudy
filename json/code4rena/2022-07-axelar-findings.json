[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { AxelarExecutable } from '@axelar-network/axelar-utils-solidity/contracts/executables/AxelarExecutable.sol';\nimport { IAxelarGateway } from '@axelar-network/axelar-utils-solidity/contracts/interfaces/IAxelarGateway.sol';\nimport './Upgradable.sol';\nimport { LocalAsset } from './interfaces/LocalAsset.sol';\n\ncontract XC20Wrapper is AxelarExecutable, Upgradable {\n    error TransferFailed();\n    error NotAxelarToken();\n    error NotXc20Token();\n    error InsufficientBalance();\n    error AlreadyWrappingAxelarToken();\n    error AlreadyWrappingXC20Token();\n    error NotOwnerOfXc20();\n\n    mapping(address => address) public wrapped;\n    mapping(address => address) public unwrapped;\n\n    bytes32 public xc20Codehash;\n    address public immutable gatewayAddress;\n\n    constructor(address gatewayAddress_) {\n        gatewayAddress = gatewayAddress_;\n    }\n\n    function gateway() public view override returns (IAxelarGateway) {\n        return IAxelarGateway(gatewayAddress);\n    }\n\n    function _setup(bytes calldata data) internal override {\n        (address owner_, bytes32 codehash_) = abi.decode(data, (address, bytes32));\n        _transferOwnership(owner_);\n        xc20Codehash = codehash_;\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('xc20-wrapper');\n    }\n\n    function setXc20Codehash(bytes32 newCodehash) external onlyOwner {\n        xc20Codehash = newCodehash;\n    }\n\n    function addWrapping(\n        string calldata symbol,\n        address xc20Token,\n        string memory newName,\n        string memory newSymbol\n    ) external payable onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        if (xc20Token.codehash != xc20Codehash) revert('NotXc20Token()');\n        if (wrapped[axelarToken] != address(0)) revert('AlreadyWrappingAxelarToken()');\n        if (unwrapped[xc20Token] != address(0)) revert('AlreadyWrappingXC20Token()');\n        wrapped[axelarToken] = xc20Token;\n        unwrapped[xc20Token] = axelarToken;\n        if (!LocalAsset(xc20Token).set_team(address(this), address(this), address(this))) revert('NotOwner()');\n        if (!LocalAsset(xc20Token).set_metadata(newName, newSymbol, IERC20(axelarToken).decimals())) revert('CannotSetMetadata()');\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function removeWrapping(string calldata symbol) external onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        address xc20Token = wrapped[axelarToken];\n        if (xc20Token == address(0)) revert('NotWrappingToken()');\n        wrapped[axelarToken] = address(0);\n        unwrapped[xc20Token] = address(0);\n    }\n\n    function wrap(address axelarToken, uint256 amount) external {\n        _safeTransferFrom(axelarToken, msg.sender, amount);\n        address wrappedToken = wrapped[axelarToken];\n        if (wrappedToken == address(0)) revert('NotAxelarToken()');\n        if (!LocalAsset(wrappedToken).mint(msg.sender, amount)) revert('CannotMint()');\n    }\n\n    function unwrap(address wrappedToken, uint256 amount) external {\n        address axelarToken = unwrapped[wrappedToken];\n        if (axelarToken == address(0)) revert('NotXc20Token()');\n        if (IERC20(wrappedToken).balanceOf(msg.sender) < amount) revert('InsufficientBalance()');\n        if (!LocalAsset(wrappedToken).burn(msg.sender, amount)) revert('CannotBurn()');\n        _safeTransfer(axelarToken, msg.sender, amount);\n    }\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _executeWithToken(\n        string calldata,\n        string calldata,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal override {\n        address receiver = abi.decode(payload, (address));\n        address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n        address xc20 = wrapped[tokenAddress];\n        if (xc20 == address(0) || !LocalAsset(xc20).mint(receiver, amount)) {\n            _safeTransfer(tokenAddress, receiver, amount);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AdminMultisigBase is EternalStorage {\n    error NotAdmin();\n    error AlreadyVoted();\n    error InvalidAdmins();\n    error InvalidAdminThreshold();\n    error DuplicateAdmin(address admin);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\n\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\n\n    // NOTE: Given the early void return, this modifier should be used with care on functions that return data.\n    modifier onlyAdmin() {\n        uint256 adminEpoch = _adminEpoch();\n\n        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();\n\n        bytes32 topic = keccak256(msg.data);\n\n        // Check that admin has not voted, then record that they have voted.\n        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();\n\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\n\n        // Determine the new vote count and update it.\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\n\n        _;\n\n        // Clear vote count and voted booleans.\n        _setVoteCount(adminEpoch, topic, uint256(0));\n\n        uint256 adminCount = _getAdminCount(adminEpoch);\n\n        for (uint256 i; i < adminCount; ++i) {\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\n    }\n\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\n    }\n\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\n    }\n\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\n    }\n\n    function _getAdminVotedKey(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\n    }\n\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _adminEpoch() internal view returns (uint256) {\n        return getUint(KEY_ADMIN_EPOCH);\n    }\n\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\n        return getAddress(_getAdminKey(adminEpoch, index));\n    }\n\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminCountKey(adminEpoch));\n    }\n\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminThresholdKey(adminEpoch));\n    }\n\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\n    }\n\n    function _hasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal view returns (bool) {\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\n    }\n\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\n        return getBool(_getIsAdminKey(adminEpoch, account));\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setAdminEpoch(uint256 adminEpoch) internal {\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\n    }\n\n    function _setAdmin(\n        uint256 adminEpoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getAdminKey(adminEpoch, index), account);\n    }\n\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\n    }\n\n    function _setAdmins(\n        uint256 adminEpoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 adminLength = accounts.length;\n\n        if (adminLength < threshold) revert InvalidAdmins();\n\n        if (threshold == uint256(0)) revert InvalidAdminThreshold();\n\n        _setAdminThreshold(adminEpoch, threshold);\n        _setAdminCount(adminEpoch, adminLength);\n\n        for (uint256 i; i < adminLength; ++i) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an admin for this epoch.\n            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);\n\n            if (account == address(0)) revert InvalidAdmins();\n\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\n            _setAdmin(adminEpoch, i, account);\n            _setIsAdmin(adminEpoch, account, true);\n        }\n    }\n\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\n    }\n\n    function _setVoteCount(\n        uint256 adminEpoch,\n        bytes32 topic,\n        uint256 voteCount\n    ) internal {\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\n    }\n\n    function _setHasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account,\n        bool voted\n    ) internal {\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\n    }\n\n    function _setIsAdmin(\n        uint256 adminEpoch,\n        address account,\n        bool isAdmin\n    ) internal {\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\n    }\n}\n\n\n",
        "CodeNames": [
            "XC20Wrapper.sol",
            "AdminMultisigBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "unwrapped[wrappedToken]",
                    "addres(",
                    "removeWrapping"
                ],
                "Type": "  removeWrapping  can be called when there are still wrapped tokens",
                "Description": "\nXC20Wrapper.sol#L66(https://github.com/code-423n4/2022-07-axelar/blob/a1205d2ba78e0db583d136f8563e8097860a110f/xc20/contracts/XC20Wrapper.sol#L66)<br\n\nAn owner can call removeWrapping, even if there are still circulating wrapped tokens. This will cause the unwrapping of those tokens to fail, as unwrapped[wrappedToken] will be addres(0).\n\n",
                "Repair": "\nTrack how many wrapped tokens are in circulation, only allow the removal of a wrapped tokens when there are 0 to ensure for users that they will always be able to unwrap.\n\nre1ro (Axelar) confirmed and commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/23#issuecomment-1205933537):\n  Valid observation. We will consider a different approach.\n \n Mitigation<br\n removeWrapping method was removed<br\n https://github.com/axelarnetwork/axelar-xc20-wrapper/pull/4\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/23#issuecomment-1229574297):\n  The warden has shown how the Admin can remove the mapping that allows to redeem bridged tokens, because this will cause the inability to unwrap, and can be operated by the admin, I agree with Medium Severity.\n \n The sponsor has confirmed and they have mitigated by removing the function.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { IAxelarGateway } from './IAxelarGateway.sol';\n\nabstract contract IAxelarExecutable {\n    error NotApprovedByGateway();\n\n    IAxelarGateway public gateway;\n\n    constructor(address gateway_) {\n        gateway = IAxelarGateway(gateway_);\n    }\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash)) revert NotApprovedByGateway();\n        _execute(sourceChain, sourceAddress, payload);\n    }\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n        if (!gateway.validateContractCallAndMint(commandId, sourceChain, sourceAddress, payloadHash, tokenSymbol, amount))\n            revert NotApprovedByGateway();\n\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n    }\n\n    function _execute(\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes calldata payload\n    ) internal virtual {}\n\n    function _executeWithToken(\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes calldata payload,\n        string memory tokenSymbol,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { ERC20Permit } from './ERC20Permit.sol';\nimport { ERC20 } from './ERC20.sol';\nimport { LocalAsset } from './interfaces/LocalAsset.sol';\nimport { Permit } from './interfaces/Permit.sol';\n\ncontract XC20Sample is LocalAsset, ERC20Permit {\n    address public owner;\n    address public issuer;\n    address public admin;\n    address public freezer;\n\n    mapping(address => bool) public frozenAccounts;\n    bool public frozen;\n\n    constructor(address owner_, string memory name) ERC20Permit(name) ERC20('', '', 0) {\n        owner = owner_;\n    }\n\n    function mint(address to, uint256 value) external override returns (bool) {\n        if (msg.sender != owner && msg.sender != issuer) return false;\n        _mint(to, value);\n        return true;\n    }\n\n    /**\n     * @dev Burn tokens from an address\n     * Selector: 9dc29fac\n     * @param from address The address from which you want to burn tokens\n     * @param value uint256 the amount of tokens to be burnt\n     */\n    function burn(address from, uint256 value) external override returns (bool) {\n        if (msg.sender != owner && msg.sender != admin) return false;\n        _burn(from, value);\n        return true;\n    }\n\n    /**\n     * @dev Freeze an account, preventing it from operating with the asset\n     * Selector: 8d1fdf2f\n     * @param account address The address that you want to freeze\n     */\n    function freeze(address account) external override returns (bool) {\n        if (msg.sender != owner && msg.sender != freezer) return false;\n        frozenAccounts[account] = true;\n        // Does nothing because I didn't want to have to implement this.\n        return true;\n    }\n\n    /**\n     * @dev Unfreeze an account, letting it from operating againt with the asset\n     * Selector: 5ea20216\n     * @param account address The address that you want to unfreeze\n     */\n    function thaw(address account) external override returns (bool) {\n        if (msg.sender != owner && msg.sender != admin) return false;\n        frozenAccounts[account] = false;\n        // Does nothing because I didn't want to have to implement this.\n        return true;\n    }\n\n    /**\n     * @dev Freeze the entire asset operations\n     * Selector: 6b8751c1\n     */\n    function freeze_asset() external override returns (bool) {\n        if (msg.sender != owner && msg.sender != freezer) return false;\n        frozen = true;\n        // Does nothing because I didn't want to have to implement this.\n        return true;\n    }\n\n    /**\n     * @dev Unfreeze the entire asset operations\n     * Selector: 1cddec19\n     */\n    function thaw_asset() external override returns (bool) {\n        if (msg.sender != owner && msg.sender != admin) return false;\n        frozen = false;\n        // Does nothing because I didn't want to have to implement this.\n        return true;\n    }\n\n    /**\n     * @dev Transfer the ownership of an asset to a new account\n     * Selector: f0350c04\n     * @param owner_ address The address of the new owner\n     */\n    function transfer_ownership(address owner_) external override returns (bool) {\n        if (msg.sender != owner) return false;\n        owner = owner_;\n        return true;\n    }\n\n    /**\n     * @dev Specify the issuer, admin and freezer of an asset\n     * Selector: f8bf8e95\n     * @param issuer_ address The address capable of issuing tokens\n     * @param admin_ address The address capable of burning tokens and unfreezing accounts/assets\n     * @param freezer_ address The address capable of freezing accounts/asset\n     */\n    function set_team(\n        address issuer_,\n        address admin_,\n        address freezer_\n    ) external override returns (bool) {\n        if (msg.sender != owner) return false;\n        issuer = issuer_;\n        admin = admin_;\n        freezer = freezer_;\n        return true;\n    }\n\n    /**\n     * @dev Specify the name, symbol and decimals of your asset\n     * Selector: ee5dc1e4\n     * @param name_ string The name of the asset\n     * @param symbol_ string The symbol of the asset\n     * @param decimals_ uint8 The number of decimals of your asset\n     */\n    function set_metadata(\n        string calldata name_,\n        string calldata symbol_,\n        uint8 decimals_\n    ) external override returns (bool) {\n        if (msg.sender != owner) return false;\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n        return true;\n    }\n\n    /**\n     * @dev Clear the name, symbol and decimals of your asset\n     * Selector: d3ba4b9e\n     */\n    function clear_metadata() external override returns (bool) {\n        if (msg.sender != owner) return false;\n        name = '';\n        symbol = '';\n        decimals = 0;\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "IAxelarExecutable.sol",
            "XC20Sample.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "_executeWithToken",
                    "LocalAsset(xc"
                ],
                "Type": "  XC20Wrapper  may lose received token forever if  LocalAsset(xc20).mint  is reverted indefinitely",
                "Description": "\nXC20Wrapper.sol#L124-L126(https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/xc20/contracts/XC20Wrapper.sol#L124-L126)<br\n\nXC20Wrapper may lose received token forever if LocalAsset(xc20).mint is reverted indefinitely.\n\nSimilar to ERC20, the spec said that if mint returns false it means minting is failed. But it is commonly revert instead of returning false which is also a minting failure. XC20 may revert on minting as well and common sense also guiding programmers to use the revert pattern instead of returning false.\n\nThis case is not handled if SC20 minting is reverted indefinitely. No matter how hard you retry the GMP message execution, it always fail thus the token get locked forever.\n\n\n        function _executeWithToken(\n            string calldata,\n            string calldata,\n            bytes calldata payload,\n            string calldata tokenSymbol,\n            uint256 amount\n        ) internal override {\n            address receiver = abi.decode(payload, (address));\n            address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n            address xc20 = wrapped[tokenAddress];\n            if (xc20 == address(0) || !LocalAsset(xc20).mint(receiver, amount)) {\n                _safeTransfer(tokenAddress, receiver, amount);\n            }\n        }\n\n*   Token is sent to gateway before executing the message on the destination chain.\n*   If _executeWithToken fail, the token remain inside gateway. The only way to use that token is to execute the _executeWithToken succesfully.\n*   Assume LocalAsset(xc20).mint(...) revert indefinitely, _executeWithToken also revert indefinitely.\n*   As a result, _executeWithToken never success thus the tokens remain inside gateway forever.\n\n",
                "Repair": "\nUse try catch\n\n        function _executeWithToken(\n            string calldata,\n            string calldata,\n            bytes calldata payload,\n            string calldata tokenSymbol,\n            uint256 amount\n        ) internal override {\n            address receiver = abi.decode(payload, (address));\n            address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n            address xc20 = wrapped[tokenAddress];\n            if (xc20 == address(0)) {\n                _safeTransfer(tokenAddress, receiver, amount);\n            }\n\n            try LocalAsset(xc20).mint(receiver, amount) returns (bool success) {\n                if (!success) _safeTransfer(tokenAddress, receiver, amount);\n            } catch { _safeTransfer(tokenAddress, receiver, amount); }\n        }\n\nre1ro (Axelar) acknowledged and commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/176#issuecomment-1206266860):\n  Mitigation<br\n We addressed the issue with introducing _safeMint function<br\n https://github.com/axelarnetwork/axelar-xc20-wrapper/pull/4\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/176#issuecomment-1236396995):\n  The warden states that mint() may fail and cause a revert instead of returning false.\n \n With the code in scope we can check the used ERC20 implementation and we find:\n \n ERC20.sol#L187-L188(https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/xc20/contracts/ERC20.sol#L187-L188)<br\n \n solidity\n         if (account == address(0)) revert InvalidAccount();\n \n \n \n Because a revert can happen, the scenario, which hypothetically would brick the functionality can actually happen.\n \n We may also have reverts due to overflow and underflow.\n \n Because the code is built to assume that no revert can happen, but the warden demonstrated how a revert could factually happen, I do agree with Medium Severity.\n \n The sponsor has mitigated by using _safeMint.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [],
                "Type": " System will not work anymore after EIP-4758",
                "Description": "\nDepositReceiver.sol#L25(https://github.com/code-423n4/2022-07-axelar/blob/a46fa61e73dd0f3469c0263bc6818e682d62fb5f/contracts/deposit-service/DepositReceiver.sol#L25)<br\n\nAfter EIP-4758(https://eips.ethereum.org/EIPS/eip-4758), the SELFDESTRUCT op code will no longer be available. According to the EIP, \"The only use that breaks is where a contract is re-created at the same address using CREATE2 (after a SELFDESTRUCT)\". Axelar is exactly such an application, the current deposit system will no longer work.\n\n",
                "Repair": "\nTo avoid that Axelar simply stops working one day, the architecture should be changed. Instead of generating addresses for every user, the user could directly interact with the deposit service and the deposit service would need to keep track of funds and provide refunds directly.\n\nre1ro (Axelar) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/20#issuecomment-1205926507):\n  Very good spot. We will address this.\n\nre1ro (Axelar) acknowledged(https://github.com/code-423n4/2022-07-axelar-findings/issues/20)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/20#issuecomment-1236399840):\n  The warden has shown a plausible upgrade path for Ethereum that will remove the SELFDESTRUCT opcode, bricking the DepositReceiver functionality.\n \n If the fork was in place today, the code would be broken, and the finding should be of high severity.\n \n Because the fork is not in place, and no clear timeline is defined for \"The Purge\", I think Medium Severity to be correct.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "\u201102",
                "Location": [
                    "//solidity\nFile: contracts/AxelarGateway.sol\n\n/// @audit validateProof()\n268:          bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n/// @audit _unpackLegacyCommands()\n275:          try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n\n/// @audit call()\n320:              (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n/// @audit balanceOf()\n385:                  abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n\n/// @audit burn()\n393:              IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n\n/// @audit mint()\n481:              IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n\n/// @audit depositAddress()\n525:                  IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n\n/// @audit burn()\n532:          IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n\n",
                    "//solidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n/// @audit approve()\n30:           IERC20(wrappedTokenAddress).approve(gateway, amount);\n\n/// @audit tokenAddresses()\n115:              address gatewayToken = IAxelarGateway(gateway).tokenAddresses(tokenSymbol);\n\n",
                    "//solidity\nFile: contracts/deposit-service/DepositReceiver.sol\n\n/// @audit delegatecall()\n/// @audit receiverImplementation()\n12:           (bool success, ) = IAxelarDepositService(msg.sender).receiverImplementation().delegatecall(delegateData);\n\n",
                    "//solidity\nFile: contracts/deposit-service/ReceiverImplementation.sol\n\n/// @audit tokenAddresses()\n25:           address tokenAddress = IAxelarGateway(gateway).tokenAddresses(symbol);\n\n/// @audit refundToken()\n27:           address refund = DepositBase(msg.sender).refundToken();\n\n/// @audit balanceOf()\n29:               _safeTransfer(refund, refundAddress, IERC20(refund).balanceOf(address(this)));\n\n/// @audit balanceOf()\n33:           uint256 amount = IERC20(tokenAddress).balanceOf(address(this));\n\n/// @audit approve()\n38:           IERC20(tokenAddress).approve(gateway, amount);\n\n/// @audit refundToken()\n49:           address refund = DepositBase(msg.sender).refundToken();\n\n/// @audit balanceOf()\n53:               _safeTransfer(refund, refundAddress, IERC20(refund).balanceOf(address(this)));\n\n/// @audit approve()\n64:           IERC20(wrappedTokenAddress).approve(gateway, amount);\n\n/// @audit refundToken()\n74:           address refund = DepositBase(msg.sender).refundToken();\n\n/// @audit balanceOf()\n76:               _safeTransfer(refund, refundAddress, IERC20(refund).balanceOf(address(this)));\n\n/// @audit balanceOf()\n80:           uint256 amount = IERC20(wrappedTokenAddress).balanceOf(address(this));\n\n/// @audit withdraw()\n85:           IWETH9(wrappedTokenAddress).withdraw(amount);\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n/// @audit balanceOf()\n130:                  uint256 amount = IERC20(token).balanceOf(address(this));\n\n"
                ],
                "Type": "  Avoid contract existence checks by using solidity version 0.8.10 or later",
                "Description": "\nPrior to 0.8.10 the compiler inserted extra code, including EXTCODESIZE (100 gas), to check for contract existence for external calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value\n\n*There are 25 instances of this issue:*\n\nsolidity\nFile: contracts/AxelarGateway.sol\n\n/// @audit validateProof()\n268:          bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n/// @audit _unpackLegacyCommands()\n275:          try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n\n/// @audit call()\n320:              (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n/// @audit balanceOf()\n385:                  abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n\n/// @audit burn()\n393:              IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n\n/// @audit mint()\n481:              IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n\n/// @audit depositAddress()\n525:                  IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n\n/// @audit burn()\n532:          IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L268\n\nsolidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n/// @audit approve()\n30:           IERC20(wrappedTokenAddress).approve(gateway, amount);\n\n/// @audit tokenAddresses()\n115:              address gatewayToken = IAxelarGateway(gateway).tokenAddresses(tokenSymbol);\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositService.sol#L30\n\nsolidity\nFile: contracts/deposit-service/DepositReceiver.sol\n\n/// @audit delegatecall()\n/// @audit receiverImplementation()\n12:           (bool success, ) = IAxelarDepositService(msg.sender).receiverImplementation().delegatecall(delegateData);\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/DepositReceiver.sol#L12\n\nsolidity\nFile: contracts/deposit-service/ReceiverImplementation.sol\n\n/// @audit tokenAddresses()\n25:           address tokenAddress = IAxelarGateway(gateway).tokenAddresses(symbol);\n\n/// @audit refundToken()\n27:           address refund = DepositBase(msg.sender).refundToken();\n\n/// @audit balanceOf()\n29:               _safeTransfer(refund, refundAddress, IERC20(refund).balanceOf(address(this)));\n\n/// @audit balanceOf()\n33:           uint256 amount = IERC20(tokenAddress).balanceOf(address(this));\n\n/// @audit approve()\n38:           IERC20(tokenAddress).approve(gateway, amount);\n\n/// @audit refundToken()\n49:           address refund = DepositBase(msg.sender).refundToken();\n\n/// @audit balanceOf()\n53:               _safeTransfer(refund, refundAddress, IERC20(refund).balanceOf(address(this)));\n\n/// @audit approve()\n64:           IERC20(wrappedTokenAddress).approve(gateway, amount);\n\n/// @audit refundToken()\n74:           address refund = DepositBase(msg.sender).refundToken();\n\n/// @audit balanceOf()\n76:               _safeTransfer(refund, refundAddress, IERC20(refund).balanceOf(address(this)));\n\n/// @audit balanceOf()\n80:           uint256 amount = IERC20(wrappedTokenAddress).balanceOf(address(this));\n\n/// @audit withdraw()\n85:           IWETH9(wrappedTokenAddress).withdraw(amount);\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/ReceiverImplementation.sol#L25\n\nsolidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n/// @audit balanceOf()\n130:                  uint256 amount = IERC20(token).balanceOf(address(this));\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L130\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarAuthWeighted } from '../interfaces/IAxelarAuthWeighted.sol';\nimport { ECDSA } from '../ECDSA.sol';\nimport { Ownable } from '../Ownable.sol';\n\ncontract AxelarAuthWeighted is Ownable, IAxelarAuthWeighted {\n    uint256 public currentEpoch;\n    mapping(uint256 => bytes32) public hashForEpoch;\n    mapping(bytes32 => uint256) public epochForHash;\n\n    uint8 internal constant OLD_KEY_RETENTION = 16;\n\n    constructor(bytes[] memory recentOperators) {\n        for (uint256 i; i < recentOperators.length; ++i) {\n            _transferOperatorship(recentOperators[i]);\n        }\n    }\n\n    /**************************\\\n    |* External Functionality *|\n    \\**************************/\n\n    function validateProof(bytes32 messageHash, bytes calldata proof) external view returns (bool currentOperators) {\n        (address[] memory operators, uint256[] memory weights, uint256 threshold, bytes[] memory signatures) = abi.decode(\n            proof,\n            (address[], uint256[], uint256, bytes[])\n        );\n\n        bytes32 operatorsHash = keccak256(abi.encode(operators, weights, threshold));\n        uint256 operatorsEpoch = epochForHash[operatorsHash];\n        uint256 epoch = currentEpoch;\n\n        if (operatorsEpoch == 0 || epoch - operatorsEpoch >= OLD_KEY_RETENTION) revert InvalidOperators();\n\n        _validateSignatures(messageHash, operators, weights, threshold, signatures);\n\n        currentOperators = operatorsEpoch == epoch;\n    }\n\n    /***********************\\\n    |* Owner Functionality *|\n    \\***********************/\n\n    function transferOperatorship(bytes calldata params) external onlyOwner {\n        _transferOperatorship(params);\n    }\n\n    /**************************\\\n    |* Internal Functionality *|\n    \\**************************/\n\n    function _transferOperatorship(bytes memory params) internal {\n        (address[] memory newOperators, uint256[] memory newWeights, uint256 newThreshold) = abi.decode(\n            params,\n            (address[], uint256[], uint256)\n        );\n        uint256 operatorsLength = newOperators.length;\n        uint256 weightsLength = newWeights.length;\n\n        // operators must be sorted binary or alphabetically in lower case\n        if (operatorsLength == 0 || !_isSortedAscAndContainsNoDuplicate(newOperators)) revert InvalidOperators();\n\n        if (weightsLength != operatorsLength) revert InvalidWeights();\n\n        uint256 totalWeight = 0;\n        for (uint256 i = 0; i < weightsLength; ++i) {\n            totalWeight += newWeights[i];\n        }\n        if (newThreshold == 0 || totalWeight < newThreshold) revert InvalidThreshold();\n\n        bytes32 newOperatorsHash = keccak256(params);\n\n        if (epochForHash[newOperatorsHash] > 0) revert SameOperators();\n\n        uint256 epoch = currentEpoch + 1;\n        currentEpoch = epoch;\n        hashForEpoch[epoch] = newOperatorsHash;\n        epochForHash[newOperatorsHash] = epoch;\n\n        emit OperatorshipTransferred(newOperators, newWeights, newThreshold);\n    }\n\n    function _validateSignatures(\n        bytes32 messageHash,\n        address[] memory operators,\n        uint256[] memory weights,\n        uint256 threshold,\n        bytes[] memory signatures\n    ) internal pure {\n        uint256 operatorsLength = operators.length;\n        uint256 operatorIndex = 0;\n        uint256 weight = 0;\n        // looking for signers within operators\n        // assuming that both operators and signatures are sorted\n        for (uint256 i = 0; i < signatures.length; ++i) {\n            address signer = ECDSA.recover(messageHash, signatures[i]);\n            // looping through remaining operators to find a match\n            for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}\n            // checking if we are out of operators\n            if (operatorIndex == operatorsLength) revert MalformedSigners();\n            // return if weight sum above threshold\n            weight += weights[operatorIndex];\n            // weight needs to reach or surpass threshold\n            if (weight >= threshold) return;\n            // increasing operators index if match was found\n            ++operatorIndex;\n        }\n        // if weight sum below threshold\n        revert MalformedSigners();\n    }\n\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n        for (uint256 i; i < accounts.length - 1; ++i) {\n            if (accounts[i] >= accounts[i + 1]) {\n                return false;\n            }\n        }\n\n        return accounts[0] != address(0);\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarAuthWeighted.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\nfunction execute(bytes calldata input) external override {\n    (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n    bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n    // TEST auth and getaway separately\n    bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\t..SNIP..\n}\n",
                    "//solidity\nuint8 internal constant OLD_KEY_RETENTION = 16;\n\nfunction validateProof(bytes32 messageHash, bytes calldata proof) external view returns (bool currentOperators) {\n\t(address[] memory operators, uint256[] memory weights, uint256 threshold, bytes[] memory signatures) = abi.decode(\n\t\tproof,\n\t\t(address[], uint256[], uint256, bytes[])\n\t);\n\n\tbytes32 operatorsHash = keccak256(abi.encode(operators, weights, threshold));\n\tuint256 operatorsEpoch = epochForHash[operatorsHash];\n\tuint256 epoch = currentEpoch;\n\n\tif (operatorsEpoch == 0 || epoch operatorsEpoch = OLD_KEY_RETENTION) revert InvalidOperators();\n\n\t_validateSignatures(messageHash, operators, weights, threshold, signatures);\n\n\tcurrentOperators = operatorsEpoch == epoch;\n}\n"
                ],
                "Type": " Previous {Operators/Weights/Threshold} Are Still Able To Sign Off New Commands After Operatorship Is Transferred",
                "Description": "\nThe administrator will call AxelarAuthWeighted.transferOperatorship function to transfer the operatorship to a new set of {Operators/Weights/Threshold}.\n\nHowever, it was observed that after transferring the operatorship to a new set of {Operators/Weights/Threshold}, the previous sets of {Operators/Weights/Threshold} are still able to generate a valid proof, and subsequently execute the command.\n\nThe following piece of code shows that as long as valid proof is submitted, the commands will be executed by the system.\n\nAxelarGateway.sol#L262(https://github.com/code-423n4/2022-07-axelar/blob/3729dd4aeff8dc2b8b9c3670a1c792c81fc60e7c/contracts/AxelarGateway.sol#L262)<br\n\nsolidity\nfunction execute(bytes calldata input) external override {\n    (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n    bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n    // TEST auth and getaway separately\n    bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\t..SNIP..\n}\n\n\nThe following piece of code shows that the past 16 sets of {Operators/Weights/Threshold} are considered valid and can be used within the AxelarAuthWeighted._validateSignatures(https://github.com/code-423n4/2022-07-axelar/blob/3729dd4aeff8dc2b8b9c3670a1c792c81fc60e7c/contracts/auth/AxelarAuthWeighted.sol#L86) function. Thus, the past 16 sets of {Operators/Weights/Threshold} are able to sign and submit a valid proof, and the proof will be accepted by the AxelarAuthWeighted.validateProof that allows them to execute the commands.\n\nAxelarAuthWeighted.sol#L36(https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/auth/AxelarAuthWeighted.sol#L36)<br\n\nsolidity\nuint8 internal constant OLD_KEY_RETENTION = 16;\n\nfunction validateProof(bytes32 messageHash, bytes calldata proof) external view returns (bool currentOperators) {\n\t(address[] memory operators, uint256[] memory weights, uint256 threshold, bytes[] memory signatures) = abi.decode(\n\t\tproof,\n\t\t(address[], uint256[], uint256, bytes[])\n\t);\n\n\tbytes32 operatorsHash = keccak256(abi.encode(operators, weights, threshold));\n\tuint256 operatorsEpoch = epochForHash[operatorsHash];\n\tuint256 epoch = currentEpoch;\n\n\tif (operatorsEpoch == 0 || epoch operatorsEpoch = OLD_KEY_RETENTION) revert InvalidOperators();\n\n\t_validateSignatures(messageHash, operators, weights, threshold, signatures);\n\n\tcurrentOperators = operatorsEpoch == epoch;\n}\n\n\nUnderstood from the team that the reason for allowing past 16 sets of {Operators/Weights/Threshold} is that after a transfer of operatorship, the commands that were signed recently but have not been executed yet will not become invalid. Further understood from the team the operatorship transfer is performed when there is a significant change in stake distribution on the Axelar network.\n\nIt makes sense for commands that were already signed recently by past operators before the operatorship transfer to be executable. However, based on the current design, it is also possible for the past 16 sets of {Operators/Weights/Threshold} to submit a new valid proof/signature for new commands to be executed after the operatorship transfer, and the AxelarAuthWeighted._validateSignatures function will happily accept the proof/signature, which should not be allowed.\n\nIt was understood that the operatorship transfer is performed when there is a significant change in stake distribution on the Axelar network, therefore, it does not make sense for all the past 16 sets of {Operators/Weights/Threshold} to be still able to sign and execute new commands after the operatorship transfer, because they follow the old stake distribution that is no longer considered as valid.\n\nOnly the current set of operators and its stake distribution should be used to verify any new command signed and issued after the operatorship transfer.\n\n\nAssuming that there are 3 validators (Alice, Bob and Charles)\n\n\nAt T1, the following is the state:\n\n currentEpoch = 1\n\n hashForEpoch[Epoch 1] = {operators: [Alice, Bob, Charles], weights: [0.5, 0.25, 0.25], threshold: 0.5} convert to hash\n\nAt T1, Alice could submit the following input to AxelarGateway.execute(bytes calldata input) function to execute the commands:\n\n input = {\n\n \u200b\tbytes memory data = commands to be executed\n\n \u200b\tbytes memory proof = {operators: [Alice, Bob, Charles], weights: [0.5, 0.25, 0.25], threshold: 0.5, signatures: [Alice's signature]}\n\n }\n\nSince Alice's signature weight is 0.5, having Alice's signature alone is sufficient to meet the threshold of 0.5 and the commands will be executed.\n\n\nAt T2, the Axelar administrator decided to change the stake distribution. The admin called the AxelarAuthWeighted.transferOperatorship and change the state to as follows:\n\n currentEpoch = 2\n\n hashForEpoch[Epoch 2] = {operators: [Alice, Bob, Charles], weights: [0.25, 0.4, 0.4], threshold: 0.5} convert to hash <== newly added\n\n hashForEpoch[Epoch 1] = {operators: [Alice, Bob, Charles], weights: [0.5, 0.25, 0.25], threshold: 0.5} convert to hash\n\nAt T2, Alice's weight has reduced from 0.5 to 0.25. As per the current stake distribution, Alice's signature alone is not sufficient to meet the threshold of 0.5. Thus, she is not able to execute any new command without an additional signature from Bob or Charles.\n\nHowever, note that the past 16 sets of {operators/weights/threshold} are considered valid by the system, so in another word, all the past 16 stake distributions are considered valid too.\n\nThus, Alice simply needs to re-use back to the previous set of {operators/weights/threshold} in Epoch 1 and she can continue to execute new commands without the signature of Bob or Charles, thus bypassing the current stake distribution.\n\nAt T2, Alice could still submit the following input to AxelarGateway.execute(bytes calldata input) function with only Alice's signature to execute the command:\n\n input = {\n\n \u200b\tbytes memory data = commands to be executed\n\n \u200b\tbytes memory proof = {operators: [Alice, Bob, Charles], weights: [0.5, 0.25, 0.25], threshold: 0.5, signatures: [Alice's signature]}\n\n }\n\nNo additional signature from Bob or Charles is needed.\n\nFollowing is from Epoch 1\n\n {operators: [Alice, Bob, Charles], weights: [0.5, 0.25, 0.25], threshold: 0.5\n\n\nNoted from the discord channel the following clarification from the team.\n\n Based on couple of questions I have received, I'd like to clarify one assumption we are making for the contracts (which is enforced at the axelar proof of stake network):\n Operators correspond to validators on the Axelar network. However, the operator address for a given epoch is derived from the validator key along with a nonce that is unique for each operator epoch.\n i.e Whenever operatorship is being transferred, an honest validator will always generate a new operator address (and not reuse their old one) due to a nonce.\n\nWith this control in place, even if the validator has generated a new operator address after the operatorship has been transferred, it is still possible for the validator to re-use back the old operator address and sign the command as the validator is aware of the private key needed to sign on behalf of the old operator address. Thus, the above issue still exists.\n\nAdditionally, there is always a risk of a \"dishonest\" validator not generating a new operator address after operatorship is being transferred if the new stake distribution does not benefit them. In the above example, Alice who has its weightage reduced from 0.5 to 0.25 do not see the benefit of the new stake distribution can decide not to generate a new operator address and continue to use the old operator address that allowed her to sign and execute any command without an additional signature from Bob or Charles.\n\n\nCurrent stake distribution can be bypassed.\n\n",
                "Repair": "\nConsider updating the system to ensure that the following requirements are followed:\n\n*   Command signed by the past 16 sets of {operators/weights/threshold} AFTER the operatorship transfer should not be executable and should be rejected. Only commands signed by the current set of {operators/weights/threshold} AFTER the operatorship transfer should be accepted and executable.\n*   Commands signed by the past 16 sets of {operators/weights/threshold} BEFORE the operatorship transfer should be accepted and executable.\n\nre1ro (Axelar) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/156#issuecomment-1206201357):\n  Good spot.<br\n I think we could include the timestamps to prevent old operators to sing any new commands.\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/156#issuecomment-1236421534):\n  Per the Warden POC Stake Distribution from past epochs is not changed, meaning a transferOperatorship called by the owner with the goal of reducing weights for a specific operator will be circumventable.\n \n This implies:\n Ability to sidestep coded logic and code intent - Broken Invariants\n Inability to kick a malicious operator (unless you use the 16 times transferOperatorship exploit shown from other reports)\n \n The \"need to remove a bad operator\" is definitely contingent on setup, so Medium Severity is definitely fair.\n \n I'll think about raising or keeping as Med.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/156#issuecomment-1238533547):\n  In contrast to other reports, this submission shows a reasonable path forward to invalidate old operators, while allowing them to re-try old commands.\n \n For this reason I think this is distinct from #19(https://github.com/code-423n4/2022-07-axelar-findings/issues/19) etc.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarAuthWeighted } from '../interfaces/IAxelarAuthWeighted.sol';\nimport { ECDSA } from '../ECDSA.sol';\nimport { Ownable } from '../Ownable.sol';\n\ncontract AxelarAuthWeighted is Ownable, IAxelarAuthWeighted {\n    uint256 public currentEpoch;\n    mapping(uint256 => bytes32) public hashForEpoch;\n    mapping(bytes32 => uint256) public epochForHash;\n\n    uint8 internal constant OLD_KEY_RETENTION = 16;\n\n    constructor(bytes[] memory recentOperators) {\n        for (uint256 i; i < recentOperators.length; ++i) {\n            _transferOperatorship(recentOperators[i]);\n        }\n    }\n\n    /**************************\\\n    |* External Functionality *|\n    \\**************************/\n\n    function validateProof(bytes32 messageHash, bytes calldata proof) external view returns (bool currentOperators) {\n        (address[] memory operators, uint256[] memory weights, uint256 threshold, bytes[] memory signatures) = abi.decode(\n            proof,\n            (address[], uint256[], uint256, bytes[])\n        );\n\n        bytes32 operatorsHash = keccak256(abi.encode(operators, weights, threshold));\n        uint256 operatorsEpoch = epochForHash[operatorsHash];\n        uint256 epoch = currentEpoch;\n\n        if (operatorsEpoch == 0 || epoch - operatorsEpoch >= OLD_KEY_RETENTION) revert InvalidOperators();\n\n        _validateSignatures(messageHash, operators, weights, threshold, signatures);\n\n        currentOperators = operatorsEpoch == epoch;\n    }\n\n    /***********************\\\n    |* Owner Functionality *|\n    \\***********************/\n\n    function transferOperatorship(bytes calldata params) external onlyOwner {\n        _transferOperatorship(params);\n    }\n\n    /**************************\\\n    |* Internal Functionality *|\n    \\**************************/\n\n    function _transferOperatorship(bytes memory params) internal {\n        (address[] memory newOperators, uint256[] memory newWeights, uint256 newThreshold) = abi.decode(\n            params,\n            (address[], uint256[], uint256)\n        );\n        uint256 operatorsLength = newOperators.length;\n        uint256 weightsLength = newWeights.length;\n\n        // operators must be sorted binary or alphabetically in lower case\n        if (operatorsLength == 0 || !_isSortedAscAndContainsNoDuplicate(newOperators)) revert InvalidOperators();\n\n        if (weightsLength != operatorsLength) revert InvalidWeights();\n\n        uint256 totalWeight = 0;\n        for (uint256 i = 0; i < weightsLength; ++i) {\n            totalWeight += newWeights[i];\n        }\n        if (newThreshold == 0 || totalWeight < newThreshold) revert InvalidThreshold();\n\n        bytes32 newOperatorsHash = keccak256(params);\n\n        if (epochForHash[newOperatorsHash] > 0) revert SameOperators();\n\n        uint256 epoch = currentEpoch + 1;\n        currentEpoch = epoch;\n        hashForEpoch[epoch] = newOperatorsHash;\n        epochForHash[newOperatorsHash] = epoch;\n\n        emit OperatorshipTransferred(newOperators, newWeights, newThreshold);\n    }\n\n    function _validateSignatures(\n        bytes32 messageHash,\n        address[] memory operators,\n        uint256[] memory weights,\n        uint256 threshold,\n        bytes[] memory signatures\n    ) internal pure {\n        uint256 operatorsLength = operators.length;\n        uint256 operatorIndex = 0;\n        uint256 weight = 0;\n        // looking for signers within operators\n        // assuming that both operators and signatures are sorted\n        for (uint256 i = 0; i < signatures.length; ++i) {\n            address signer = ECDSA.recover(messageHash, signatures[i]);\n            // looping through remaining operators to find a match\n            for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}\n            // checking if we are out of operators\n            if (operatorIndex == operatorsLength) revert MalformedSigners();\n            // return if weight sum above threshold\n            weight += weights[operatorIndex];\n            // weight needs to reach or surpass threshold\n            if (weight >= threshold) return;\n            // increasing operators index if match was found\n            ++operatorIndex;\n        }\n        // if weight sum below threshold\n        revert MalformedSigners();\n    }\n\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n        for (uint256 i; i < accounts.length - 1; ++i) {\n            if (accounts[i] >= accounts[i + 1]) {\n                return false;\n            }\n        }\n\n        return accounts[0] != address(0);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarAuthWeighted.sol",
            "AxelarGateway.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "execute",
                    "transferOperatorship",
                    "OLD_KEY_RETENTION"
                ],
                "Type": " Change of operators possible from old operators",
                "Description": "\nAxelarGateway.sol#L268(https://github.com/code-423n4/2022-07-axelar/blob/3373c48a71c07cfce856b53afc02ef4fc2357f8c/contracts/AxelarGateway.sol#L268)<br\nAxelarGateway.sol#L311(https://github.com/code-423n4/2022-07-axelar/blob/3373c48a71c07cfce856b53afc02ef4fc2357f8c/contracts/AxelarGateway.sol#L311)<br\n\nAccording to the specifications, only the current operators should be able to transfer operatorship. However, there is one way to circumvent this. Because currentOperators is not updated in the loop, when multiple transferOperatorship commands are submitted in the same execute call, all will succeed. After the first one, the operators that signed these commands are no longer the current operators, but the call will still succeed.\n\nThis also means that one set of operators could submit so many transferOperatorship commands in one execute call that OLD_KEY_RETENTION is reached for all other ones, meaning they would control complete set of currently valid operators.\n\n",
                "Repair": "\nSet currentOperators to false when the operators were changed.\n\nre1ro (Axelar) confirmed, but disagreed with severity and commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/19#issuecomment-1205925612):\n  This case would never occur in practice because our command batches are produced and signed by the Axelar nerwork.\n So there would be never 2 transferOperatorship commands in the same batch. \n \n In general if the recent operators turn malicious they can overtake the gateway disregarding this finding.\n \n Mitigation<br\n We still have added the sanity check to set currentOperators to false.<br\n https://github.com/axelarnetwork/axelar-cgp-solidity/pull/138\n\nmilapsheth (Axelar) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/19#issuecomment-1226049092):\n  For more context, the current operators could just easily transfer the operatorship in multiple txs instead. We heavily rely on the assumption the majority of the operators by weight are not malicious.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/19#issuecomment-1236399493):\n  Very interesting find.\n \n Per the warden submission: the operators can sign a transferOperatorship and then still act as if they are the current operator while their calls are being executed.\n \n This can be further extended to perform more than OLD_KEY_RETENTION to invalidate all old keys, which may be desirable or a malicious attack depending on context.\n \n The sponsor disagrees with severity, citing that the main assumption of the code is that operators by weight are non malicious\n \n Personally I think the finding:\n Breaks an assumption of the code (current operators exclusively can transferOperatorship)\n Allows the operators to kick old operators in one tx instead of OLD_KEY_RETENTION txs\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/19#issuecomment-1236440077):\n  With the information that I have, considering that:\n Breaks an assumption of the code (current operators exclusively can transferOperatorship)\n Allows the operators to kick old operators in one tx instead of OLD_KEY_RETENTION txs\n \n Because this is contingent on a malicious majority, and considering that a malicious majority can perform even worse attacks (DOS, TX Censoring, Shutting down the chain)\n \n I believe that Medium Severity is correct.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGasService } from '../interfaces/IAxelarGasService.sol';\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport '../util/Upgradable.sol';\n\n// This should be owned by the microservice that is paying for gas.\ncontract AxelarGasService is Upgradable, IAxelarGasService {\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasPaidForContractCall(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            gasToken,\n            gasFeeAmount,\n            refundAddress\n        );\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string memory symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasPaidForContractCallWithToken(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            symbol,\n            amount,\n            gasToken,\n            gasFeeAmount,\n            refundAddress\n        );\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasPaidForContractCall(sender, destinationChain, destinationAddress, keccak256(payload), msg.value, refundAddress);\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasPaidForContractCallWithToken(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            symbol,\n            amount,\n            msg.value,\n            refundAddress\n        );\n    }\n\n    function addGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasAdded(txHash, logIndex, gasToken, gasFeeAmount, refundAddress);\n    }\n\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasAdded(txHash, logIndex, msg.value, refundAddress);\n    }\n\n    function collectFees(address payable receiver, address[] calldata tokens) external onlyOwner {\n        if (receiver == address(0)) revert InvalidAddress();\n\n        for (uint256 i; i < tokens.length; i++) {\n            address token = tokens[i];\n\n            if (token == address(0)) {\n                uint256 amount = address(this).balance;\n                if (amount > 0) receiver.transfer(amount);\n            } else {\n                uint256 amount = IERC20(token).balanceOf(address(this));\n                if (amount > 0) _safeTransfer(token, receiver, amount);\n            }\n        }\n    }\n\n    function refund(\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external onlyOwner {\n        if (receiver == address(0)) revert InvalidAddress();\n\n        if (token == address(0)) {\n            receiver.transfer(amount);\n        } else {\n            _safeTransfer(token, receiver, amount);\n        }\n    }\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (amount == 0) revert NothingReceived();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        if (amount == 0) revert NothingReceived();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\n    }\n\n    function contractId() external pure returns (bytes32) {\n        return keccak256('axelar-gas-service');\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarGasService.sol",
            "AxelarGateway.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\ncontracts/AxelarGateway.sol\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {}\n    function execute(bytes calldata input) external override {}\n\ncontracts/gas-service/AxelarGasService.sol\n    function addGas() external override {}\n    function addNativeGas() external payable override {}\n"
                ],
                "Type": " Add cancel and refund option for Transaction Recovery",
                "Description": "\nAxelarGateway.sol#L262(https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L262)<br\nAxelarGasService.sol#L98(https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L98)<br\nAxelarGasService.sol#L110(https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L110)<br\n\nTransactions could fail or get stuck, according to the documentation:\n\n Occasionally, transactions can get \"stuck\" in the pipeline from a source to destination chain (e.g. due to one-off issues that arise with relayers that operate on top of the network).\n\n Transactions have typically gotten \"stuck\" in the pipeline due to: (A) The transaction failing to relay from the source chain into the Axelar network for processing. (B) The transaction failing to get executed on the destination chain.\n\nAnd there are several options provided:\n\n*   manual approve\n*   manual execute\n*   add gas\n\nHowever, some transactions' execution depend on the time or certain condition. For example, some transaction has a deadline, it the deadline is passed, the transaction will be invalid. Or some conditions may be temporary, for example, some certain price difference for some token pair. In this case, the failed transactions will be meaningless to redo, the appropriate method is to cancel the transaction and refund. If no such option is provided, users' fund for this transaction would be lock or loss.\n\n\nsolidity\ncontracts/AxelarGateway.sol\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {}\n    function execute(bytes calldata input) external override {}\n\ncontracts/gas-service/AxelarGasService.sol\n    function addGas() external override {}\n    function addNativeGas() external payable override {}\n\n\nThe options are approveContractCall(), execute, addGas() and addNativeGas() are available, but no cancel and refund option.\n\n",
                "Repair": "\nProvide a cancel option if the transaction failed, from the source chain or destination chain, and allow the user to get the gas refund.\n\nre1ro (Axelar) acknowledged and commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/139#issuecomment-1206146400):\n  At this point this functionality can be implemented by the user in their Executable contract by the application. Axelar is providing a ground level cross-chain communication protocol. \n \n Refunds and deadline based cancel are very application specific cases and shouldn't be implemented on the protocol level. Some refunds could require manual intervention and it won't be scaleable for us to provide such support of all the applications built on top of Axelar. Especially considering that data related to expiration or price difference will be encoded inside of the payload and Axelar is not aware of the payload encoding.\n \n It shouldn't be too difficult to implement. In this example we will send it back to the original chain: \n \n     function _executeWithToken(\n         string memory sourceChain,\n         string memory sourceAddress,\n         bytes calldata payload,\n         string memory tokenSymbol,\n         uint256 amount\n     ) internal override {\n         if (price difference for some token pair  limit) {\n             IERC20(token).approve(address(gateway), amount);\n             gateway.sendToken(sourceChain, sourceAddress, tokenSymbol, amount);\n             return;\n         }\n        . . .     \n    }\n \n \n We will consider adding basic implementation of such methods to our AxelarExecutable so it can be adapted by the applications. We will have a better idea of the requirements when there will be more applications built on top. Good spot.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/139#issuecomment-1236442434):\n  The warden has shown that the system in scope has no way to \"cancel and refund\" a transaction, while the details for impact are implementation dependent, allowing canceling tx that are failing to be relayed will help integrators in the worst case.\n \n While impact is hard to quantify because the expected value of the operation by the caller should be higher than the gas paid, the actual loss in the stated case is that of the gas cost of the transaction.\n \n While minor, given the fact that it is not recoverable, given the value of the submission and the acknowledgment by the sponsor, I think Medium Severity to be appropriate.\n\nre1ro (Axelar) disagreed with severity and commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/139#issuecomment-1247489061):\n  We disagree with severity.<br\n Transactions are recoverable/refundable. There is nothing preventing it to be recovered from our protocol perspective. It's just that we don't suggest any default mechanism for this.\n \n Refund and cancel methods are up to the cross-chain app developer to implement. It very application specific and it's not up for us to decide how and what should be recovered/refunded. For some application execution deadline could be a trigger to refund, for others price slippage. Even if transaction reverts it will restore the gateway approval and can be retried or refunded.\n \n Again it is not responsibility of the protocol but rather an application specific logic. We marked it as acknowledged because we agree we should provide some guidelines and examples for this in our docs. But there is no outstanding issue in this regard.\n\nPlease note: the following took place after judging and awarding were finalized.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/139#issuecomment-1268881479):\n  I believe the Sponsor's counterargument to be valid and invite end users to make up their own opinion.\n\n Ultimately the presence or absence of an app-specific refund is dependent on the implementation.\n\n I chose to give Medium Severity in view of the risk for end-users, however, I could have rated with QA given a different context.\n\n I invite end-users to make up their own opinion and thank the sponsor for their insight.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 65 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-07-axelar-findings/issues/8) by oyc&#95;109 received the top score from the judge.\n\n*The following wardens also submitted reports: rbserver(https://github.com/code-423n4/2022-07-axelar-findings/issues/116), IllIllI(https://github.com/code-423n4/2022-07-axelar-findings/issues/121), Bnke0x0(https://github.com/code-423n4/2022-07-axelar-findings/issues/53), defsec(https://github.com/code-423n4/2022-07-axelar-findings/issues/182), xiaoming90(https://github.com/code-423n4/2022-07-axelar-findings/issues/168), horsefacts(https://github.com/code-423n4/2022-07-axelar-findings/issues/187), JC(https://github.com/code-423n4/2022-07-axelar-findings/issues/232), robee(https://github.com/code-423n4/2022-07-axelar-findings/issues/16), 0x52(https://github.com/code-423n4/2022-07-axelar-findings/issues/88), Dravee(https://github.com/code-423n4/2022-07-axelar-findings/issues/226), mics(https://github.com/code-423n4/2022-07-axelar-findings/issues/27), Chom(https://github.com/code-423n4/2022-07-axelar-findings/issues/185), 0x1f8b(https://github.com/code-423n4/2022-07-axelar-findings/issues/120), berndartmueller(https://github.com/code-423n4/2022-07-axelar-findings/issues/138), fatherOfBlocks(https://github.com/code-423n4/2022-07-axelar-findings/issues/52), Sm4rty(https://github.com/code-423n4/2022-07-axelar-findings/issues/198), hansfriese(https://github.com/code-423n4/2022-07-axelar-findings/issues/129), Aymen0909(https://github.com/code-423n4/2022-07-axelar-findings/issues/184), c3phas(https://github.com/code-423n4/2022-07-axelar-findings/issues/213), Deivitto(https://github.com/code-423n4/2022-07-axelar-findings/issues/150), lucacez(https://github.com/code-423n4/2022-07-axelar-findings/issues/70), &#95;&#95;141345&#95;&#95;(https://github.com/code-423n4/2022-07-axelar-findings/issues/146), Rohan16(https://github.com/code-423n4/2022-07-axelar-findings/issues/207), Waze(https://github.com/code-423n4/2022-07-axelar-findings/issues/205), kyteg(https://github.com/code-423n4/2022-07-axelar-findings/issues/103), Rolezn(https://github.com/code-423n4/2022-07-axelar-findings/issues/3), cccz(https://github.com/code-423n4/2022-07-axelar-findings/issues/160), CertoraInc(https://github.com/code-423n4/2022-07-axelar-findings/issues/196), Lambda(https://github.com/code-423n4/2022-07-axelar-findings/issues/21), simon135(https://github.com/code-423n4/2022-07-axelar-findings/issues/172), Respx(https://github.com/code-423n4/2022-07-axelar-findings/issues/131), 0xNazgul(https://github.com/code-423n4/2022-07-axelar-findings/issues/73), ajtra(https://github.com/code-423n4/2022-07-axelar-findings/issues/200), Ruhum(https://github.com/code-423n4/2022-07-axelar-findings/issues/46), benbaessler(https://github.com/code-423n4/2022-07-axelar-findings/issues/153), sseefried(https://github.com/code-423n4/2022-07-axelar-findings/issues/97), bharg4v(https://github.com/code-423n4/2022-07-axelar-findings/issues/217), cryptonue(https://github.com/code-423n4/2022-07-axelar-findings/issues/180), RedOneN(https://github.com/code-423n4/2022-07-axelar-findings/issues/83), 0xf15ers(https://github.com/code-423n4/2022-07-axelar-findings/issues/189), 0xSmartContract(https://github.com/code-423n4/2022-07-axelar-findings/issues/84), 8olidity(https://github.com/code-423n4/2022-07-axelar-findings/issues/12), apostle0x01(https://github.com/code-423n4/2022-07-axelar-findings/issues/169), ashiq0x01(https://github.com/code-423n4/2022-07-axelar-findings/issues/95), bardamu(https://github.com/code-423n4/2022-07-axelar-findings/issues/230), bulej93(https://github.com/code-423n4/2022-07-axelar-findings/issues/107), codexploder(https://github.com/code-423n4/2022-07-axelar-findings/issues/123), CodingNameKiki(https://github.com/code-423n4/2022-07-axelar-findings/issues/81), cryptphi(https://github.com/code-423n4/2022-07-axelar-findings/issues/136), djxploit(https://github.com/code-423n4/2022-07-axelar-findings/issues/183), durianSausage(https://github.com/code-423n4/2022-07-axelar-findings/issues/15), ElKu(https://github.com/code-423n4/2022-07-axelar-findings/issues/93), gogo(https://github.com/code-423n4/2022-07-axelar-findings/issues/209), ignacio(https://github.com/code-423n4/2022-07-axelar-findings/issues/4), Noah3o6(https://github.com/code-423n4/2022-07-axelar-findings/issues/66), sashik&#95;eth(https://github.com/code-423n4/2022-07-axelar-findings/issues/192), tofunmi(https://github.com/code-423n4/2022-07-axelar-findings/issues/60), TomJ(https://github.com/code-423n4/2022-07-axelar-findings/issues/75), Twpony(https://github.com/code-423n4/2022-07-axelar-findings/issues/188), ch13fd357r0y3r(https://github.com/code-423n4/2022-07-axelar-findings/issues/6), NoamYakov(https://github.com/code-423n4/2022-07-axelar-findings/issues/218), ReyAdmirado(https://github.com/code-423n4/2022-07-axelar-findings/issues/48), asutorufos(https://github.com/code-423n4/2022-07-axelar-findings/issues/215), and Yiko(https://github.com/code-423n4/2022-07-axelar-findings/issues/118).*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarDepositService } from '../interfaces/IAxelarDepositService.sol';\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport { IWETH9 } from '../interfaces/IWETH9.sol';\nimport { Upgradable } from '../util/Upgradable.sol';\nimport { DepositBase } from './DepositBase.sol';\nimport { DepositReceiver } from './DepositReceiver.sol';\nimport { ReceiverImplementation } from './ReceiverImplementation.sol';\n\n// This should be owned by the microservice that is paying for gas.\ncontract AxelarDepositService is Upgradable, DepositBase, IAxelarDepositService {\n    address public immutable receiverImplementation;\n\n    constructor(address gateway, string memory wrappedSymbol) DepositBase(gateway, wrappedSymbol) {\n        receiverImplementation = address(new ReceiverImplementation(gateway, wrappedSymbol));\n    }\n\n    // @dev This method is meant to called directly by user to send native token cross-chain\n    function sendNative(string calldata destinationChain, string calldata destinationAddress) external payable {\n        address wrappedTokenAddress = wrappedToken();\n        uint256 amount = msg.value;\n\n        if (amount == 0) revert NothingDeposited();\n\n        IWETH9(wrappedTokenAddress).deposit{ value: amount }();\n        IERC20(wrappedTokenAddress).approve(gateway, amount);\n        IAxelarGateway(gateway).sendToken(destinationChain, destinationAddress, wrappedSymbol(), amount);\n    }\n\n    // @dev Generates a deposit address for sending an ERC20 token cross-chain\n    function addressForTokenDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata tokenSymbol\n    ) external view returns (address) {\n        return\n            _depositAddress(\n                salt,\n                abi.encodeWithSelector(\n                    ReceiverImplementation.receiveAndSendToken.selector,\n                    refundAddress,\n                    destinationChain,\n                    destinationAddress,\n                    tokenSymbol\n                )\n            );\n    }\n\n    // @dev Generates a deposit address for sending native currency cross-chain\n    function addressForNativeDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress\n    ) public view returns (address) {\n        return\n            _depositAddress(\n                salt,\n                abi.encodeWithSelector(\n                    ReceiverImplementation.receiveAndSendNative.selector,\n                    refundAddress,\n                    destinationChain,\n                    destinationAddress\n                )\n            );\n    }\n\n    // @dev Generates a deposit address for unwrapping WETH-like token into native currency\n    function addressForNativeUnwrap(\n        bytes32 salt,\n        address refundAddress,\n        address recipient\n    ) external view returns (address) {\n        return\n            _depositAddress(salt, abi.encodeWithSelector(ReceiverImplementation.receiveAndUnwrapNative.selector, refundAddress, recipient));\n    }\n\n    // @dev Receives ERC20 token from the deposit address and sends it cross-chain\n    function sendTokenDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata tokenSymbol\n    ) external {\n        // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n        new DepositReceiver{ salt: salt }(\n            abi.encodeWithSelector(\n                ReceiverImplementation.receiveAndSendToken.selector,\n                refundAddress,\n                destinationChain,\n                destinationAddress,\n                tokenSymbol\n            )\n        );\n    }\n\n    // @dev Refunds ERC20 tokens from the deposit address if they don't match the intended token\n    // Only refundAddress can refund the token that was intended to go cross-chain (if not sent yet)\n    function refundTokenDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata tokenSymbol,\n        address[] calldata refundTokens\n    ) external {\n        for (uint256 i; i < refundTokens.length; i++) {\n            address gatewayToken = IAxelarGateway(gateway).tokenAddresses(tokenSymbol);\n\n            // Allowing only the refundAddress to refund the intended token\n            if (refundTokens[i] == gatewayToken && msg.sender != refundAddress) continue;\n\n            // Saving to public storage to be accessed by the DepositReceiver\n            refundToken = refundTokens[i];\n            // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n            new DepositReceiver{ salt: salt }(\n                abi.encodeWithSelector(\n                    ReceiverImplementation.receiveAndSendToken.selector,\n                    refundAddress,\n                    destinationChain,\n                    destinationAddress,\n                    tokenSymbol\n                )\n            );\n        }\n\n        refundToken = address(0);\n    }\n\n    // @dev Receives native currency, wraps it into WETH-like token and sends cross-chain\n    function sendNativeDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress\n    ) external {\n        // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n        new DepositReceiver{ salt: salt }(\n            abi.encodeWithSelector(\n                ReceiverImplementation.receiveAndSendNative.selector,\n                refundAddress,\n                destinationChain,\n                destinationAddress\n            )\n        );\n    }\n\n    // @dev Refunds ERC20 tokens from the deposit address after the native deposit was sent\n    // Only refundAddress can refund the native currency intended to go cross-chain (if not sent yet)\n    function refundNativeDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        address[] calldata refundTokens\n    ) external {\n        // Allowing only the refundAddress to refund the native currency\n        if (addressForNativeDeposit(salt, refundAddress, destinationChain, destinationAddress).balance > 0 && msg.sender != refundAddress)\n            return;\n\n        for (uint256 i; i < refundTokens.length; i++) {\n            refundToken = refundTokens[i];\n            // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n            new DepositReceiver{ salt: salt }(\n                abi.encodeWithSelector(\n                    ReceiverImplementation.receiveAndSendNative.selector,\n                    refundAddress,\n                    destinationChain,\n                    destinationAddress\n                )\n            );\n        }\n\n        refundToken = address(0);\n    }\n\n    // @dev Receives WETH-like token, unwraps and send native currency to the recipient\n    function nativeUnwrap(\n        bytes32 salt,\n        address refundAddress,\n        address payable recipient\n    ) external {\n        // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n        new DepositReceiver{ salt: salt }(\n            abi.encodeWithSelector(ReceiverImplementation.receiveAndUnwrapNative.selector, refundAddress, recipient)\n        );\n    }\n\n    // @dev Refunds ERC20 tokens from the deposit address except WETH-like token\n    // Only refundAddress can refund the WETH-like token intended to be unwrapped (if not yet)\n    function refundNativeUnwrap(\n        bytes32 salt,\n        address refundAddress,\n        address payable recipient,\n        address[] calldata refundTokens\n    ) external {\n        for (uint256 i; i < refundTokens.length; i++) {\n            address wrappedTokenAddress = wrappedToken();\n\n            // Allowing only the refundAddress to refund the WETH-like token\n            if (refundTokens[i] == wrappedTokenAddress && msg.sender != refundAddress) continue;\n\n            refundToken = refundTokens[i];\n            // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n            new DepositReceiver{ salt: salt }(\n                abi.encodeWithSelector(ReceiverImplementation.receiveAndUnwrapNative.selector, refundAddress, recipient)\n            );\n        }\n\n        refundToken = address(0);\n    }\n\n    function _depositAddress(bytes32 create2Salt, bytes memory delegateData) internal view returns (address) {\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\n        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                bytes1(0xff),\n                                address(this),\n                                create2Salt,\n                                // Encoding delegateData as a constructor param\n                                keccak256(abi.encodePacked(type(DepositReceiver).creationCode, abi.encode(delegateData)))\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('axelar-deposit-service');\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { AxelarExecutable } from '@axelar-network/axelar-utils-solidity/contracts/executables/AxelarExecutable.sol';\nimport { IAxelarGateway } from '@axelar-network/axelar-utils-solidity/contracts/interfaces/IAxelarGateway.sol';\nimport './Upgradable.sol';\nimport { LocalAsset } from './interfaces/LocalAsset.sol';\n\ncontract XC20Wrapper is AxelarExecutable, Upgradable {\n    error TransferFailed();\n    error NotAxelarToken();\n    error NotXc20Token();\n    error InsufficientBalance();\n    error AlreadyWrappingAxelarToken();\n    error AlreadyWrappingXC20Token();\n    error NotOwnerOfXc20();\n\n    mapping(address => address) public wrapped;\n    mapping(address => address) public unwrapped;\n\n    bytes32 public xc20Codehash;\n    address public immutable gatewayAddress;\n\n    constructor(address gatewayAddress_) {\n        gatewayAddress = gatewayAddress_;\n    }\n\n    function gateway() public view override returns (IAxelarGateway) {\n        return IAxelarGateway(gatewayAddress);\n    }\n\n    function _setup(bytes calldata data) internal override {\n        (address owner_, bytes32 codehash_) = abi.decode(data, (address, bytes32));\n        _transferOwnership(owner_);\n        xc20Codehash = codehash_;\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('xc20-wrapper');\n    }\n\n    function setXc20Codehash(bytes32 newCodehash) external onlyOwner {\n        xc20Codehash = newCodehash;\n    }\n\n    function addWrapping(\n        string calldata symbol,\n        address xc20Token,\n        string memory newName,\n        string memory newSymbol\n    ) external payable onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        if (xc20Token.codehash != xc20Codehash) revert('NotXc20Token()');\n        if (wrapped[axelarToken] != address(0)) revert('AlreadyWrappingAxelarToken()');\n        if (unwrapped[xc20Token] != address(0)) revert('AlreadyWrappingXC20Token()');\n        wrapped[axelarToken] = xc20Token;\n        unwrapped[xc20Token] = axelarToken;\n        if (!LocalAsset(xc20Token).set_team(address(this), address(this), address(this))) revert('NotOwner()');\n        if (!LocalAsset(xc20Token).set_metadata(newName, newSymbol, IERC20(axelarToken).decimals())) revert('CannotSetMetadata()');\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function removeWrapping(string calldata symbol) external onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        address xc20Token = wrapped[axelarToken];\n        if (xc20Token == address(0)) revert('NotWrappingToken()');\n        wrapped[axelarToken] = address(0);\n        unwrapped[xc20Token] = address(0);\n    }\n\n    function wrap(address axelarToken, uint256 amount) external {\n        _safeTransferFrom(axelarToken, msg.sender, amount);\n        address wrappedToken = wrapped[axelarToken];\n        if (wrappedToken == address(0)) revert('NotAxelarToken()');\n        if (!LocalAsset(wrappedToken).mint(msg.sender, amount)) revert('CannotMint()');\n    }\n\n    function unwrap(address wrappedToken, uint256 amount) external {\n        address axelarToken = unwrapped[wrappedToken];\n        if (axelarToken == address(0)) revert('NotXc20Token()');\n        if (IERC20(wrappedToken).balanceOf(msg.sender) < amount) revert('InsufficientBalance()');\n        if (!LocalAsset(wrappedToken).burn(msg.sender, amount)) revert('CannotBurn()');\n        _safeTransfer(axelarToken, msg.sender, amount);\n    }\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _executeWithToken(\n        string calldata,\n        string calldata,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal override {\n        address receiver = abi.decode(payload, (address));\n        address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n        address xc20 = wrapped[tokenAddress];\n        if (xc20 == address(0) || !LocalAsset(xc20).mint(receiver, amount)) {\n            _safeTransfer(tokenAddress, receiver, amount);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AdminMultisigBase is EternalStorage {\n    error NotAdmin();\n    error AlreadyVoted();\n    error InvalidAdmins();\n    error InvalidAdminThreshold();\n    error DuplicateAdmin(address admin);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\n\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\n\n    // NOTE: Given the early void return, this modifier should be used with care on functions that return data.\n    modifier onlyAdmin() {\n        uint256 adminEpoch = _adminEpoch();\n\n        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();\n\n        bytes32 topic = keccak256(msg.data);\n\n        // Check that admin has not voted, then record that they have voted.\n        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();\n\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\n\n        // Determine the new vote count and update it.\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\n\n        _;\n\n        // Clear vote count and voted booleans.\n        _setVoteCount(adminEpoch, topic, uint256(0));\n\n        uint256 adminCount = _getAdminCount(adminEpoch);\n\n        for (uint256 i; i < adminCount; ++i) {\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\n    }\n\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\n    }\n\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\n    }\n\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\n    }\n\n    function _getAdminVotedKey(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\n    }\n\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _adminEpoch() internal view returns (uint256) {\n        return getUint(KEY_ADMIN_EPOCH);\n    }\n\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\n        return getAddress(_getAdminKey(adminEpoch, index));\n    }\n\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminCountKey(adminEpoch));\n    }\n\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminThresholdKey(adminEpoch));\n    }\n\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\n    }\n\n    function _hasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal view returns (bool) {\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\n    }\n\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\n        return getBool(_getIsAdminKey(adminEpoch, account));\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setAdminEpoch(uint256 adminEpoch) internal {\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\n    }\n\n    function _setAdmin(\n        uint256 adminEpoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getAdminKey(adminEpoch, index), account);\n    }\n\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\n    }\n\n    function _setAdmins(\n        uint256 adminEpoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 adminLength = accounts.length;\n\n        if (adminLength < threshold) revert InvalidAdmins();\n\n        if (threshold == uint256(0)) revert InvalidAdminThreshold();\n\n        _setAdminThreshold(adminEpoch, threshold);\n        _setAdminCount(adminEpoch, adminLength);\n\n        for (uint256 i; i < adminLength; ++i) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an admin for this epoch.\n            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);\n\n            if (account == address(0)) revert InvalidAdmins();\n\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\n            _setAdmin(adminEpoch, i, account);\n            _setIsAdmin(adminEpoch, account, true);\n        }\n    }\n\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\n    }\n\n    function _setVoteCount(\n        uint256 adminEpoch,\n        bytes32 topic,\n        uint256 voteCount\n    ) internal {\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\n    }\n\n    function _setHasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account,\n        bool voted\n    ) internal {\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\n    }\n\n    function _setIsAdmin(\n        uint256 adminEpoch,\n        address account,\n        bool isAdmin\n    ) internal {\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AxelarGatewayProxy is EternalStorage {\n    error InvalidImplementation();\n    error SetupFailed();\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    constructor(address gatewayImplementation, bytes memory params) {\n        _setAddress(KEY_IMPLEMENTATION, gatewayImplementation);\n\n        if (gatewayImplementation.code.length == 0) revert InvalidImplementation();\n\n        (bool success, ) = gatewayImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, params));\n\n        if (!success) revert SetupFailed();\n    }\n\n    function setup(bytes calldata params) external {}\n\n    fallback() external payable {\n        address implementation = getAddress(KEY_IMPLEMENTATION);\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {\n        revert('NO_ETHER');\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarDepositService.sol",
            "AxelarGateway.sol",
            "XC20Wrapper.sol",
            "AdminMultisigBase.sol",
            "AxelarGatewayProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-02",
                "Location": [
                    "external",
                    "for",
                    "calldata",
                    "keccak",
                    "++i",
                    "i++",
                    "WETH",
                    "axelarToken",
                    "decimals",
                    "memory",
                    "internal",
                    "receive",
                    "payable"
                ],
                "Type": " Unspecific Compiler Version Pragma",
                "Description": "\nAvoid floating pragmas for non-library contracts.\n\nWhile floating pragmas make sense for libraries to allow them to be included with multiple different versions of applications, it may be a security risk for application implementations.\n\nA known vulnerable compiler version may accidentally be selected or security tools might fall-back to an older compiler version ending up checking a different EVM compilation that is ultimately deployed on the blockchain.\n\nIt is recommended to pin to a concrete compiler version.\n\n    IAxelarAuth.sol::3 = pragma solidity ^0.8.9;\n    IAxelarAuthWeighted.sol::3 = pragma solidity ^0.8.9;\n    IAxelarDepositService.sol::3 = pragma solidity ^0.8.9;\n    IAxelarGasService.sol::3 = pragma solidity ^0.8.9;\n    IDepositBase.sol::3 = pragma solidity ^0.8.9;\n\nre1ro (Axelar) acknowledged and commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/8#issuecomment-1205893984):\n  L-01]<br\n Not applicable. We need receive to receive ether from WETH contract.\n \n L-02]<br\n Not applicable. axelarToken is our own implementation in this context and it implements decimals\n \n L-03]<br\n Nope.\n \n L-04]<br\n Yes.\n \n N-01]<br\n We allow Unspecific Compiler version for our interfaces, so they can be imported by other projects\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/8#issuecomment-1233585799):\n  L-01] Unused receive() function<br\n For the proxy<br\n Low\n \n L-02] decimals() not part of ERC20 standard<br\n Low\n \n L-03] Unsafe use of transfer()/transferFrom() with IERC20<br\n Low\n \n L-04] Missing checks for zero address<br\n Low\n \n N-01] Use a more recent version of solidity<br\n Non-critical\n \n N-02] Unspecific Compiler Version Pragma<br\n Non-critical\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 56 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-07-axelar-findings/issues/122) by IllIllI received the top score from the judge.\n\n*The following wardens also submitted reports: JC(https://github.com/code-423n4/2022-07-axelar-findings/issues/231), Dravee(https://github.com/code-423n4/2022-07-axelar-findings/issues/211), 0x1f8b(https://github.com/code-423n4/2022-07-axelar-findings/issues/113), ajtra(https://github.com/code-423n4/2022-07-axelar-findings/issues/177), Bnke0x0(https://github.com/code-423n4/2022-07-axelar-findings/issues/13), defsec(https://github.com/code-423n4/2022-07-axelar-findings/issues/225), Deivitto(https://github.com/code-423n4/2022-07-axelar-findings/issues/149), fatherOfBlocks(https://github.com/code-423n4/2022-07-axelar-findings/issues/51), oyc&#95;109(https://github.com/code-423n4/2022-07-axelar-findings/issues/7), Aymen0909(https://github.com/code-423n4/2022-07-axelar-findings/issues/173), MiloTruck(https://github.com/code-423n4/2022-07-axelar-findings/issues/174), TomJ(https://github.com/code-423n4/2022-07-axelar-findings/issues/181), Ruhum(https://github.com/code-423n4/2022-07-axelar-findings/issues/45), &#95;&#95;141345&#95;&#95;(https://github.com/code-423n4/2022-07-axelar-findings/issues/148), 0xNazgul(https://github.com/code-423n4/2022-07-axelar-findings/issues/72), 0xsam(https://github.com/code-423n4/2022-07-axelar-findings/issues/64), apostle0x01(https://github.com/code-423n4/2022-07-axelar-findings/issues/170), benbaessler(https://github.com/code-423n4/2022-07-axelar-findings/issues/151), djxploit(https://github.com/code-423n4/2022-07-axelar-findings/issues/179), gerdusx(https://github.com/code-423n4/2022-07-axelar-findings/issues/154), gogo(https://github.com/code-423n4/2022-07-axelar-findings/issues/191), kyteg(https://github.com/code-423n4/2022-07-axelar-findings/issues/104), Lambda(https://github.com/code-423n4/2022-07-axelar-findings/issues/18), lucacez(https://github.com/code-423n4/2022-07-axelar-findings/issues/69), medikko(https://github.com/code-423n4/2022-07-axelar-findings/issues/234), NoamYakov(https://github.com/code-423n4/2022-07-axelar-findings/issues/221), rbserver(https://github.com/code-423n4/2022-07-axelar-findings/issues/126), RedOneN(https://github.com/code-423n4/2022-07-axelar-findings/issues/82), ReyAdmirado(https://github.com/code-423n4/2022-07-axelar-findings/issues/47), robee(https://github.com/code-423n4/2022-07-axelar-findings/issues/17), Rolezn(https://github.com/code-423n4/2022-07-axelar-findings/issues/2), simon135(https://github.com/code-423n4/2022-07-axelar-findings/issues/171), tofunmi(https://github.com/code-423n4/2022-07-axelar-findings/issues/59), Tomio(https://github.com/code-423n4/2022-07-axelar-findings/issues/115), Respx(https://github.com/code-423n4/2022-07-axelar-findings/issues/86), asutorufos(https://github.com/code-423n4/2022-07-axelar-findings/issues/222), bharg4v(https://github.com/code-423n4/2022-07-axelar-findings/issues/223), bulej93(https://github.com/code-423n4/2022-07-axelar-findings/issues/106), Chom(https://github.com/code-423n4/2022-07-axelar-findings/issues/204), CodingNameKiki(https://github.com/code-423n4/2022-07-axelar-findings/issues/57), durianSausage(https://github.com/code-423n4/2022-07-axelar-findings/issues/14), mics(https://github.com/code-423n4/2022-07-axelar-findings/issues/28), owenthurm(https://github.com/code-423n4/2022-07-axelar-findings/issues/92), Rohan16(https://github.com/code-423n4/2022-07-axelar-findings/issues/208), sashik&#95;eth(https://github.com/code-423n4/2022-07-axelar-findings/issues/202), Sm4rty(https://github.com/code-423n4/2022-07-axelar-findings/issues/199), Waze(https://github.com/code-423n4/2022-07-axelar-findings/issues/197), a12jmx(https://github.com/code-423n4/2022-07-axelar-findings/issues/233), Fitraldys(https://github.com/code-423n4/2022-07-axelar-findings/issues/224), 8olidity(https://github.com/code-423n4/2022-07-axelar-findings/issues/11), ak1(https://github.com/code-423n4/2022-07-axelar-findings/issues/190), c3phas(https://github.com/code-423n4/2022-07-axelar-findings/issues/214), ElKu(https://github.com/code-423n4/2022-07-axelar-findings/issues/94), erictee(https://github.com/code-423n4/2022-07-axelar-findings/issues/49), and Noah3o6(https://github.com/code-423n4/2022-07-axelar-findings/issues/67).*\n\n## Summary\n\n|        | Issue                                                                                                                                                      | Instances |\n| -----| :--------------------------------------------------------------------------------------------------------------------------------------------------------| :-------: |\n| G\u201101] | Using calldata instead of memory for read-only arguments in external functions saves gas                                                             |     7     |\n| G\u201102] | Avoid contract existence checks by using solidity version 0.8.10 or later                                                                                  |     25    |\n| G\u201103] | internal functions only called once can be inlined to save gas                                                                                           |     7     |\n| G\u201104] | <array.length should not be looked up in every loop of a for-loop                                                                                     |     7     |\n| G\u201105] | ++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in forand while-loops |     12    |\n| G\u201106] | keccak256() should only need to be called on a specific string literal once                                                                              |     4     |\n| G\u201107] | Optimize names to save gas                                                                                                                                 |     10    |\n| G\u201108] | ++i costs less gas than i++, especially when it's used in for-loops (--i/i-- too)                                                                |     5     |\n| G\u201109] | Empty blocks should be removed or emit something                                                                                                           |     2     |\n| G\u201110] | Functions guaranteed to revert when called by normal users can be marked payable                                                                         |     11    |\n\nTotal: 90 instances over 10 issues\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AdminMultisigBase is EternalStorage {\n    error NotAdmin();\n    error AlreadyVoted();\n    error InvalidAdmins();\n    error InvalidAdminThreshold();\n    error DuplicateAdmin(address admin);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\n\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\n\n    // NOTE: Given the early void return, this modifier should be used with care on functions that return data.\n    modifier onlyAdmin() {\n        uint256 adminEpoch = _adminEpoch();\n\n        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();\n\n        bytes32 topic = keccak256(msg.data);\n\n        // Check that admin has not voted, then record that they have voted.\n        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();\n\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\n\n        // Determine the new vote count and update it.\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\n\n        _;\n\n        // Clear vote count and voted booleans.\n        _setVoteCount(adminEpoch, topic, uint256(0));\n\n        uint256 adminCount = _getAdminCount(adminEpoch);\n\n        for (uint256 i; i < adminCount; ++i) {\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\n    }\n\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\n    }\n\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\n    }\n\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\n    }\n\n    function _getAdminVotedKey(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\n    }\n\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _adminEpoch() internal view returns (uint256) {\n        return getUint(KEY_ADMIN_EPOCH);\n    }\n\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\n        return getAddress(_getAdminKey(adminEpoch, index));\n    }\n\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminCountKey(adminEpoch));\n    }\n\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminThresholdKey(adminEpoch));\n    }\n\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\n    }\n\n    function _hasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal view returns (bool) {\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\n    }\n\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\n        return getBool(_getIsAdminKey(adminEpoch, account));\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setAdminEpoch(uint256 adminEpoch) internal {\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\n    }\n\n    function _setAdmin(\n        uint256 adminEpoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getAdminKey(adminEpoch, index), account);\n    }\n\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\n    }\n\n    function _setAdmins(\n        uint256 adminEpoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 adminLength = accounts.length;\n\n        if (adminLength < threshold) revert InvalidAdmins();\n\n        if (threshold == uint256(0)) revert InvalidAdminThreshold();\n\n        _setAdminThreshold(adminEpoch, threshold);\n        _setAdminCount(adminEpoch, adminLength);\n\n        for (uint256 i; i < adminLength; ++i) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an admin for this epoch.\n            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);\n\n            if (account == address(0)) revert InvalidAdmins();\n\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\n            _setAdmin(adminEpoch, i, account);\n            _setIsAdmin(adminEpoch, account, true);\n        }\n    }\n\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\n    }\n\n    function _setVoteCount(\n        uint256 adminEpoch,\n        bytes32 topic,\n        uint256 voteCount\n    ) internal {\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\n    }\n\n    function _setHasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account,\n        bool voted\n    ) internal {\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\n    }\n\n    function _setIsAdmin(\n        uint256 adminEpoch,\n        address account,\n        bool isAdmin\n    ) internal {\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarGateway.sol",
            "AdminMultisigBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "\u201101",
                "Location": [
                    "//solidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n/// @audit recentOperators\n16:       constructor(bytes[] memory recentOperators) {\n\n",
                    "//solidity\nFile: contracts/AxelarGateway.sol\n\n172:      function tokenFrozen(string memory) external pure override returns (bool) {\n\n/// @audit executeData\n447       function _unpackLegacyCommands(bytes memory executeData)\n448           external\n449           pure\n450           returns (\n451               uint256 chainId,\n452               bytes32[] memory commandIds,\n453               string[] memory commands,\n454:              bytes[] memory params\n\n",
                    "//solidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n/// @audit wrappedSymbol\n18:       constructor(address gateway, string memory wrappedSymbol) DepositBase(gateway, wrappedSymbol) {\n\n",
                    "//solidity\nFile: contracts/deposit-service/DepositReceiver.sol\n\n/// @audit delegateData\n8:        constructor(bytes memory delegateData) {\n\n",
                    "//solidity\nFile: contracts/deposit-service/ReceiverImplementation.sol\n\n/// @audit wrappedSymbol\n12:       constructor(address gateway, string memory wrappedSymbol) DepositBase(gateway, wrappedSymbol) {}\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n/// @audit symbol\n35        function payGasForContractCallWithToken(\n36            address sender,\n37            string calldata destinationChain,\n38            string calldata destinationAddress,\n39            bytes calldata payload,\n40            string memory symbol,\n41            uint256 amount,\n42            address gasToken,\n43            uint256 gasFeeAmount,\n44:           address refundAddress\n\n"
                ],
                "Type": "  Using  calldata  instead of  memory  for read-only arguments in  external  functions saves gas",
                "Description": "\nWhen a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memory index. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array.length). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having memory arguments, it's still valid for implementation contracs to use calldata arguments instead.\n\nIf the array is passed to an internal function which passes the array to another internal function where the array is modified and therefore memory is used in the external call, it's still more gass-efficient to use calldata when the external function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is public but can be marked as external since it's not called by the contract, and cases where a constructor is involved\n\n*There are 7 instances of this issue:*\n\nsolidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n/// @audit recentOperators\n16:       constructor(bytes[] memory recentOperators) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/auth/AxelarAuthWeighted.sol#L16\n\nsolidity\nFile: contracts/AxelarGateway.sol\n\n172:      function tokenFrozen(string memory) external pure override returns (bool) {\n\n/// @audit executeData\n447       function _unpackLegacyCommands(bytes memory executeData)\n448           external\n449           pure\n450           returns (\n451               uint256 chainId,\n452               bytes32[] memory commandIds,\n453               string[] memory commands,\n454:              bytes[] memory params\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L172\n\nsolidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n/// @audit wrappedSymbol\n18:       constructor(address gateway, string memory wrappedSymbol) DepositBase(gateway, wrappedSymbol) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositService.sol#L18\n\nsolidity\nFile: contracts/deposit-service/DepositReceiver.sol\n\n/// @audit delegateData\n8:        constructor(bytes memory delegateData) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/DepositReceiver.sol#L8\n\nsolidity\nFile: contracts/deposit-service/ReceiverImplementation.sol\n\n/// @audit wrappedSymbol\n12:       constructor(address gateway, string memory wrappedSymbol) DepositBase(gateway, wrappedSymbol) {}\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/ReceiverImplementation.sol#L12\n\nsolidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n/// @audit symbol\n35        function payGasForContractCallWithToken(\n36            address sender,\n37            string calldata destinationChain,\n38            string calldata destinationAddress,\n39            bytes calldata payload,\n40            string memory symbol,\n41            uint256 amount,\n42            address gasToken,\n43            uint256 gasFeeAmount,\n44:           address refundAddress\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L35-L44\n\n\n",
                "Repair": ""
            },
            {
                "Name": "\u201106",
                "Location": [
                    "//solidity\nFile: contracts/deposit-service/AxelarDepositServiceProxy.sol\n\n9:            return keccak256('axelar-deposit-service');\n\n",
                    "//solidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n242:          return keccak256('axelar-deposit-service');\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasServiceProxy.sol\n\n10:           return keccak256('axelar-gas-service');\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n181:          return keccak256('axelar-gas-service');\n\n"
                ],
                "Type": "   keccak256()  should only need to be called on a specific string literal once",
                "Description": "\nIt should be saved to an immutable variable, and the variable used instead. If the hash is being used as a part of a function selector, the cast to bytes4 should also only be done once\n\n*There are 4 instances of this issue:*\n\nsolidity\nFile: contracts/deposit-service/AxelarDepositServiceProxy.sol\n\n9:            return keccak256('axelar-deposit-service');\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositServiceProxy.sol#L9\n\nsolidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n242:          return keccak256('axelar-deposit-service');\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositService.sol#L242\n\nsolidity\nFile: contracts/gas-service/AxelarGasServiceProxy.sol\n\n10:           return keccak256('axelar-gas-service');\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasServiceProxy.sol#L10\n\nsolidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n181:          return keccak256('axelar-gas-service');\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L181\n\n\n",
                "Repair": ""
            },
            {
                "Name": "\u201108",
                "Location": [
                    "//solidity\nFile: contracts/AxelarGateway.sol\n\n207:          for (uint256 i = 0; i < symbols.length; i++) {\n\n",
                    "//solidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n114:          for (uint256 i; i < refundTokens.length; i++) {\n\n168:          for (uint256 i; i < refundTokens.length; i++) {\n\n204:          for (uint256 i; i < refundTokens.length; i++) {\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n123:          for (uint256 i; i < tokens.length; i++) {\n\n"
                ],
                "Type": "   ++i  costs less gas than  i++ , especially when it's used in  for -loops ( --i / i--  too)",
                "Description": "\nSaves 5 gas per loop\n\n*There are 5 instances of this issue:*\n\nsolidity\nFile: contracts/AxelarGateway.sol\n\n207:          for (uint256 i = 0; i < symbols.length; i++) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L207\n\nsolidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n114:          for (uint256 i; i < refundTokens.length; i++) {\n\n168:          for (uint256 i; i < refundTokens.length; i++) {\n\n204:          for (uint256 i; i < refundTokens.length; i++) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositService.sol#L114\n\nsolidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n123:          for (uint256 i; i < tokens.length; i++) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L123\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AdminMultisigBase is EternalStorage {\n    error NotAdmin();\n    error AlreadyVoted();\n    error InvalidAdmins();\n    error InvalidAdminThreshold();\n    error DuplicateAdmin(address admin);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\n\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\n\n    // NOTE: Given the early void return, this modifier should be used with care on functions that return data.\n    modifier onlyAdmin() {\n        uint256 adminEpoch = _adminEpoch();\n\n        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();\n\n        bytes32 topic = keccak256(msg.data);\n\n        // Check that admin has not voted, then record that they have voted.\n        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();\n\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\n\n        // Determine the new vote count and update it.\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\n\n        _;\n\n        // Clear vote count and voted booleans.\n        _setVoteCount(adminEpoch, topic, uint256(0));\n\n        uint256 adminCount = _getAdminCount(adminEpoch);\n\n        for (uint256 i; i < adminCount; ++i) {\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\n    }\n\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\n    }\n\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\n    }\n\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\n    }\n\n    function _getAdminVotedKey(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\n    }\n\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _adminEpoch() internal view returns (uint256) {\n        return getUint(KEY_ADMIN_EPOCH);\n    }\n\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\n        return getAddress(_getAdminKey(adminEpoch, index));\n    }\n\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminCountKey(adminEpoch));\n    }\n\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminThresholdKey(adminEpoch));\n    }\n\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\n    }\n\n    function _hasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal view returns (bool) {\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\n    }\n\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\n        return getBool(_getIsAdminKey(adminEpoch, account));\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setAdminEpoch(uint256 adminEpoch) internal {\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\n    }\n\n    function _setAdmin(\n        uint256 adminEpoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getAdminKey(adminEpoch, index), account);\n    }\n\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\n    }\n\n    function _setAdmins(\n        uint256 adminEpoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 adminLength = accounts.length;\n\n        if (adminLength < threshold) revert InvalidAdmins();\n\n        if (threshold == uint256(0)) revert InvalidAdminThreshold();\n\n        _setAdminThreshold(adminEpoch, threshold);\n        _setAdminCount(adminEpoch, adminLength);\n\n        for (uint256 i; i < adminLength; ++i) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an admin for this epoch.\n            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);\n\n            if (account == address(0)) revert InvalidAdmins();\n\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\n            _setAdmin(adminEpoch, i, account);\n            _setIsAdmin(adminEpoch, account, true);\n        }\n    }\n\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\n    }\n\n    function _setVoteCount(\n        uint256 adminEpoch,\n        bytes32 topic,\n        uint256 voteCount\n    ) internal {\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\n    }\n\n    function _setHasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account,\n        bool voted\n    ) internal {\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\n    }\n\n    function _setIsAdmin(\n        uint256 adminEpoch,\n        address account,\n        bool isAdmin\n    ) internal {\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\n    }\n}\n\n\n",
        "CodeNames": [
            "AdminMultisigBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "\u201103",
                "Location": [
                    "//solidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n86        function _validateSignatures(\n87            bytes32 messageHash,\n88            address[] memory operators,\n89            uint256[] memory weights,\n90            uint256 threshold,\n91:           bytes[] memory signatures\n\n115:      function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n\n",
                    "//solidity\nFile: contracts/AxelarGateway.sol\n\n611:      function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n\n622:      function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n\n630       function _setContractCallApproved(\n631           bytes32 commandId,\n632           string memory sourceChain,\n633           string memory sourceAddress,\n634           address contractAddress,\n635:          bytes32 payloadHash\n\n640       function _setContractCallApprovedWithMint(\n641           bytes32 commandId,\n642           string memory sourceChain,\n643           string memory sourceAddress,\n644           address contractAddress,\n645           bytes32 payloadHash,\n646           string memory symbol,\n647:          uint256 amount\n\n655:      function _setImplementation(address newImplementation) internal {\n\n"
                ],
                "Type": "   internal  functions only called once can be inlined to save gas",
                "Description": "\nNot inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\n*There are 7 instances of this issue:*\n\nsolidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n86        function _validateSignatures(\n87            bytes32 messageHash,\n88            address[] memory operators,\n89            uint256[] memory weights,\n90            uint256 threshold,\n91:           bytes[] memory signatures\n\n115:      function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/auth/AxelarAuthWeighted.sol#L86-L91\n\nsolidity\nFile: contracts/AxelarGateway.sol\n\n611:      function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n\n622:      function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n\n630       function _setContractCallApproved(\n631           bytes32 commandId,\n632           string memory sourceChain,\n633           string memory sourceAddress,\n634           address contractAddress,\n635:          bytes32 payloadHash\n\n640       function _setContractCallApprovedWithMint(\n641           bytes32 commandId,\n642           string memory sourceChain,\n643           string memory sourceAddress,\n644           address contractAddress,\n645           bytes32 payloadHash,\n646           string memory symbol,\n647:          uint256 amount\n\n655:      function _setImplementation(address newImplementation) internal {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L611\n\n\n",
                "Repair": ""
            },
            {
                "Name": "\u201104",
                "Location": [
                    "//solidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n17:           for (uint256 i; i < recentOperators.length; ++i) {\n\n98:           for (uint256 i = 0; i < signatures.length; ++i) {\n\n",
                    "//solidity\nFile: contracts/AxelarGateway.sol\n\n207:          for (uint256 i = 0; i < symbols.length; i++) {\n\n",
                    "//solidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n114:          for (uint256 i; i < refundTokens.length; i++) {\n\n168:          for (uint256 i; i < refundTokens.length; i++) {\n\n204:          for (uint256 i; i < refundTokens.length; i++) {\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n123:          for (uint256 i; i < tokens.length; i++) {\n\n"
                ],
                "Type": "   <array>.length  should not be looked up in every loop of a  for -loop",
                "Description": "\nThe overheads outlined below are *PER LOOP*, excluding the first loop\n\n*   storage arrays incur a Gwarmaccess (100 gas)\n*   memory arrays use MLOAD (3 gas)\n*   calldata arrays use CALLDATALOAD (3 gas)\n\nCaching the length changes each of these to a DUP<N (3 gas), and gets rid of the extra DUP<N needed to store the stack offset\n\n*There are 7 instances of this issue:*\n\nsolidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n17:           for (uint256 i; i < recentOperators.length; ++i) {\n\n98:           for (uint256 i = 0; i < signatures.length; ++i) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/auth/AxelarAuthWeighted.sol#L17\n\nsolidity\nFile: contracts/AxelarGateway.sol\n\n207:          for (uint256 i = 0; i < symbols.length; i++) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L207\n\nsolidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n114:          for (uint256 i; i < refundTokens.length; i++) {\n\n168:          for (uint256 i; i < refundTokens.length; i++) {\n\n204:          for (uint256 i; i < refundTokens.length; i++) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositService.sol#L114\n\nsolidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n123:          for (uint256 i; i < tokens.length; i++) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L123\n\n\n",
                "Repair": ""
            },
            {
                "Name": "\u201105",
                "Location": [
                    "//solidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n17:           for (uint256 i; i < recentOperators.length; ++i) {\n\n69:           for (uint256 i = 0; i < weightsLength; ++i) {\n\n98:           for (uint256 i = 0; i < signatures.length; ++i) {\n\n101:              for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}\n\n116:          for (uint256 i; i < accounts.length 1; ++i) {\n\n",
                    "//solidity\nFile: contracts/AxelarGateway.sol\n\n195:          for (uint256 i; i < adminCount; ++i) {\n\n207:          for (uint256 i = 0; i < symbols.length; i++) {\n\n292:          for (uint256 i; i < commandsLength; ++i) {\n\n",
                    "//solidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n114:          for (uint256 i; i < refundTokens.length; i++) {\n\n168:          for (uint256 i; i < refundTokens.length; i++) {\n\n204:          for (uint256 i; i < refundTokens.length; i++) {\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n123:          for (uint256 i; i < tokens.length; i++) {\n\n"
                ],
                "Type": "   ++i / i++  should be  unchecked{++i} / unchecked{i++}  when it is not possible for them to overflow, as is the case when used in  for - and  while -loops",
                "Description": "\nThe unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop(https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)\n\n*There are 12 instances of this issue:*\n\nsolidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n17:           for (uint256 i; i < recentOperators.length; ++i) {\n\n69:           for (uint256 i = 0; i < weightsLength; ++i) {\n\n98:           for (uint256 i = 0; i < signatures.length; ++i) {\n\n101:              for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}\n\n116:          for (uint256 i; i < accounts.length 1; ++i) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/auth/AxelarAuthWeighted.sol#L17\n\nsolidity\nFile: contracts/AxelarGateway.sol\n\n195:          for (uint256 i; i < adminCount; ++i) {\n\n207:          for (uint256 i = 0; i < symbols.length; i++) {\n\n292:          for (uint256 i; i < commandsLength; ++i) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L195\n\nsolidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n114:          for (uint256 i; i < refundTokens.length; i++) {\n\n168:          for (uint256 i; i < refundTokens.length; i++) {\n\n204:          for (uint256 i; i < refundTokens.length; i++) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositService.sol#L114\n\nsolidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n123:          for (uint256 i; i < tokens.length; i++) {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L123\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarGateway.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "\u201107",
                "Location": [
                    "//solidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n/// @audit validateProof(), transferOperatorship()\n9:    contract AxelarAuthWeighted is Ownable, IAxelarAuthWeighted {\n\n",
                    "//solidity\nFile: contracts/AxelarGateway.sol\n\n/// @audit sendToken(), callContract(), callContractWithToken(), deployToken(), mintToken(), burnToken(), approveContractCall(), approveContractCallWithMint(), transferOperatorship(), _unpackLegacyCommands()\n15:   contract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n\n",
                    "//solidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n/// @audit sendNative(), addressForTokenDeposit(), addressForNativeDeposit(), addressForNativeUnwrap(), sendTokenDeposit(), refundTokenDeposit(), sendNativeDeposit(), refundNativeDeposit(), nativeUnwrap(), refundNativeUnwrap(), contractId()\n15:   contract AxelarDepositService is Upgradable, DepositBase, IAxelarDepositService {\n\n",
                    "//solidity\nFile: contracts/deposit-service/ReceiverImplementation.sol\n\n/// @audit receiveAndSendToken(), receiveAndSendNative(), receiveAndUnwrapNative()\n11:   contract ReceiverImplementation is DepositBase {\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n/// @audit collectFees(), refund(), contractId()\n10:   contract AxelarGasService is Upgradable, IAxelarGasService {\n\n",
                    "//solidity\nFile: contracts/interfaces/IAxelarAuth.sol\n\n/// @audit validateProof(), transferOperatorship()\n7:    interface IAxelarAuth is IOwnable {\n\n",
                    "//solidity\nFile: contracts/interfaces/IAxelarAuthWeighted.sol\n\n/// @audit currentEpoch(), hashForEpoch(), epochForHash()\n7:    interface IAxelarAuthWeighted is IAxelarAuth {\n\n",
                    "//solidity\nFile: contracts/interfaces/IAxelarDepositService.sol\n\n/// @audit sendNative(), addressForTokenDeposit(), addressForNativeDeposit(), addressForNativeUnwrap(), sendTokenDeposit(), refundTokenDeposit(), sendNativeDeposit(), refundNativeDeposit(), nativeUnwrap(), refundNativeUnwrap(), receiverImplementation()\n9:    interface IAxelarDepositService is IUpgradable, IDepositBase {\n\n",
                    "//solidity\nFile: contracts/interfaces/IAxelarExecutable.sol\n\n/// @audit execute(), executeWithToken()\n7:    abstract contract IAxelarExecutable {\n\n",
                    "//solidity\nFile: contracts/interfaces/IAxelarGasService.sol\n\n/// @audit payGasForContractCall(), payGasForContractCallWithToken(), payNativeGasForContractCall(), payNativeGasForContractCallWithToken(), addGas(), addNativeGas(), collectFees(), refund()\n8:    interface IAxelarGasService is IUpgradable {\n\n"
                ],
                "Type": "  Optimize names to save gas",
                "Description": "\npublic/external function names and public member variable names can be optimized to save gas. See this(https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save 128 gas each during deployment, and renaming functions to have lower method IDs will save 22 gas per call, per sorted position shifted(https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)\n\n*There are 10 instances of this issue:*\n\nsolidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n/// @audit validateProof(), transferOperatorship()\n9:    contract AxelarAuthWeighted is Ownable, IAxelarAuthWeighted {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/auth/AxelarAuthWeighted.sol#L9\n\nsolidity\nFile: contracts/AxelarGateway.sol\n\n/// @audit sendToken(), callContract(), callContractWithToken(), deployToken(), mintToken(), burnToken(), approveContractCall(), approveContractCallWithMint(), transferOperatorship(), _unpackLegacyCommands()\n15:   contract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L15\n\nsolidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n/// @audit sendNative(), addressForTokenDeposit(), addressForNativeDeposit(), addressForNativeUnwrap(), sendTokenDeposit(), refundTokenDeposit(), sendNativeDeposit(), refundNativeDeposit(), nativeUnwrap(), refundNativeUnwrap(), contractId()\n15:   contract AxelarDepositService is Upgradable, DepositBase, IAxelarDepositService {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositService.sol#L15\n\nsolidity\nFile: contracts/deposit-service/ReceiverImplementation.sol\n\n/// @audit receiveAndSendToken(), receiveAndSendNative(), receiveAndUnwrapNative()\n11:   contract ReceiverImplementation is DepositBase {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/ReceiverImplementation.sol#L11\n\nsolidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n/// @audit collectFees(), refund(), contractId()\n10:   contract AxelarGasService is Upgradable, IAxelarGasService {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L10\n\nsolidity\nFile: contracts/interfaces/IAxelarAuth.sol\n\n/// @audit validateProof(), transferOperatorship()\n7:    interface IAxelarAuth is IOwnable {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/interfaces/IAxelarAuth.sol#L7\n\nsolidity\nFile: contracts/interfaces/IAxelarAuthWeighted.sol\n\n/// @audit currentEpoch(), hashForEpoch(), epochForHash()\n7:    interface IAxelarAuthWeighted is IAxelarAuth {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/interfaces/IAxelarAuthWeighted.sol#L7\n\nsolidity\nFile: contracts/interfaces/IAxelarDepositService.sol\n\n/// @audit sendNative(), addressForTokenDeposit(), addressForNativeDeposit(), addressForNativeUnwrap(), sendTokenDeposit(), refundTokenDeposit(), sendNativeDeposit(), refundNativeDeposit(), nativeUnwrap(), refundNativeUnwrap(), receiverImplementation()\n9:    interface IAxelarDepositService is IUpgradable, IDepositBase {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/interfaces/IAxelarDepositService.sol#L9\n\nsolidity\nFile: contracts/interfaces/IAxelarExecutable.sol\n\n/// @audit execute(), executeWithToken()\n7:    abstract contract IAxelarExecutable {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/interfaces/IAxelarExecutable.sol#L7\n\nsolidity\nFile: contracts/interfaces/IAxelarGasService.sol\n\n/// @audit payGasForContractCall(), payGasForContractCallWithToken(), payNativeGasForContractCall(), payNativeGasForContractCallWithToken(), addGas(), addNativeGas(), collectFees(), refund()\n8:    interface IAxelarGasService is IUpgradable {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/interfaces/IAxelarGasService.sol#L8\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { Permit } from './interfaces/Permit.sol';\n\nimport { ERC20 } from './ERC20.sol';\n\nabstract contract ERC20Permit is IERC20, Permit, ERC20 {\n    error PermitExpired();\n    error InvalidS();\n    error InvalidV();\n    error InvalidSignature();\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\\x19\\x01';\n\n    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH = bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);\n\n    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')\n    bytes32 private constant PERMIT_SIGNATURE_HASH = bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);\n\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory name) {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(DOMAIN_TYPE_SIGNATURE_HASH, keccak256(bytes(name)), keccak256(bytes('1')), block.chainid, address(this))\n        );\n    }\n\n    function permit(\n        address issuer,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        if (block.timestamp > deadline) revert PermitExpired();\n\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();\n\n        if (v != 27 && v != 28) revert InvalidV();\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        if (recoveredAddress != issuer) revert InvalidSignature();\n\n        // _approve will revert if issuer is address(0x0)\n        _approve(issuer, spender, value);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC20Permit.sol",
            "AxelarGateway.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "\u201109",
                "Location": [
                    "//solidity\nFile: contracts/interfaces/IAxelarExecutable.sol\n\n46:       ) internal virtual {}\n\n54:       ) internal virtual {}\n\n"
                ],
                "Type": "  Empty blocks should be removed or emit something",
                "Description": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be abstract and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (if(x){}else if(y){...}else{...} = if(!x){if(y){...}else{...}}). Empty receive()/fallback() payable functions that are not used, can be removed to save deployment gas.\n\n*There are 2 instances of this issue:*\n\nsolidity\nFile: contracts/interfaces/IAxelarExecutable.sol\n\n46:       ) internal virtual {}\n\n54:       ) internal virtual {}\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/interfaces/IAxelarExecutable.sol#L46\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\n\nimport { MintableCappedERC20 } from './MintableCappedERC20.sol';\nimport { DepositHandler } from './DepositHandler.sol';\n\ncontract BurnableMintableCappedERC20 is IBurnableMintableCappedERC20, MintableCappedERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 capacity\n    ) MintableCappedERC20(name, symbol, decimals, capacity) {}\n\n    function depositAddress(bytes32 salt) public view returns (address) {\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\n        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(bytes1(0xff), owner, salt, keccak256(abi.encodePacked(type(DepositHandler).creationCode)))\n                        )\n                    )\n                )\n            );\n    }\n\n    function burn(bytes32 salt) external onlyOwner {\n        address account = depositAddress(salt);\n        _burn(account, balanceOf[account]);\n    }\n\n    function burnFrom(address account, uint256 amount) external onlyOwner {\n        uint256 _allowance = allowance[account][msg.sender];\n        if (_allowance != type(uint256).max) {\n            _approve(account, msg.sender, _allowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AxelarGatewayProxy is EternalStorage {\n    error InvalidImplementation();\n    error SetupFailed();\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    constructor(address gatewayImplementation, bytes memory params) {\n        _setAddress(KEY_IMPLEMENTATION, gatewayImplementation);\n\n        if (gatewayImplementation.code.length == 0) revert InvalidImplementation();\n\n        (bool success, ) = gatewayImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, params));\n\n        if (!success) revert SetupFailed();\n    }\n\n    function setup(bytes calldata params) external {}\n\n    fallback() external payable {\n        address implementation = getAddress(KEY_IMPLEMENTATION);\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {\n        revert('NO_ETHER');\n    }\n}\n\n\n",
        "CodeNames": [
            "BurnableMintableCappedERC20.sol",
            "AxelarGatewayProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "\u201110",
                "Location": [
                    "//solidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n47:       function transferOperatorship(bytes calldata params) external onlyOwner {\n\n",
                    "//solidity\nFile: contracts/AxelarGateway.sol\n\n204:      function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n\n217       function upgrade(\n218           address newImplementation,\n219           bytes32 newImplementationCodeHash,\n220           bytes calldata setupParams\n221:      ) external override onlyAdmin {\n\n331:      function deployToken(bytes calldata params, bytes32) external onlySelf {\n\n367:      function mintToken(bytes calldata params, bytes32) external onlySelf {\n\n373:      function burnToken(bytes calldata params, bytes32) external onlySelf {\n\n397:      function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n\n411:      function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n\n437:      function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n\n",
                    "//solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n120:      function collectFees(address payable receiver, address[] calldata tokens) external onlyOwner {\n\n136       function refund(\n137           address payable receiver,\n138           address token,\n139           uint256 amount\n140:      ) external onlyOwner {\n\n"
                ],
                "Type": "  Functions guaranteed to revert when called by normal users can be marked  payable ",
                "Description": "\nIf a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\nCALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost\n\n*There are 11 instances of this issue:*\n\nsolidity\nFile: contracts/auth/AxelarAuthWeighted.sol\n\n47:       function transferOperatorship(bytes calldata params) external onlyOwner {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/auth/AxelarAuthWeighted.sol#L47\n\nsolidity\nFile: contracts/AxelarGateway.sol\n\n204:      function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n\n217       function upgrade(\n218           address newImplementation,\n219           bytes32 newImplementationCodeHash,\n220           bytes calldata setupParams\n221:      ) external override onlyAdmin {\n\n331:      function deployToken(bytes calldata params, bytes32) external onlySelf {\n\n367:      function mintToken(bytes calldata params, bytes32) external onlySelf {\n\n373:      function burnToken(bytes calldata params, bytes32) external onlySelf {\n\n397:      function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n\n411:      function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n\n437:      function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/AxelarGateway.sol#L204\n\nsolidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n120:      function collectFees(address payable receiver, address[] calldata tokens) external onlyOwner {\n\n136       function refund(\n137           address payable receiver,\n138           address token,\n139           uint256 amount\n140:      ) external onlyOwner {\n\n\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L120\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-07-axelar-findings/issues/122#issuecomment-1226666802):\n  G\u201101] Using calldata instead of memory for read-only arguments in external functions saves gas<br\n 60 for the array of bytes\n \n G\u201102] Avoid contract existence checks by using solidity version 0.8.10 or later<br\n 100 gas per instance<br\n 2500\n \n G\u201103] internal functions only called once can be inlined to save gas<br\n 20 per instance<br\n 140\n \n G\u201104] <array.length should not be looked up in every loop of a for-loop + G-05]<br\n Giving 300 consistently with rest of submissions\n \n G\u201106] keccak256() should only need to be called on a specific string literal once<br\n 30 gas per instance<br\n 120\n \n Rest is too opinionated for me :P\n \n Great report as usual, would love to see a couple customized suggestion (packing or similar) and benchmarks, but still really good.\n \n 3120 gas saved\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    }
]