[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction buyAndSwap1155WETH(\n  uint256 vaultId,\n  uint256[] memory idsIn,\n  uint256[] memory amounts,\n  uint256[] memory specificIds,\n  uint256 maxWethIn,\n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i <idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount 0, \"Transferring <1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count-specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n",
                    "//solidity\nfunction _buyVaultToken(\n  address vault,\n  uint256 minTokenOut,\n  uint256 maxWethIn,\n  address[] calldata path\n) internal returns (uint256[] memory) {\n  uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n    minTokenOut,\n    maxWethIn,\n    path,\n    address(this),\n    block.timestamp\n  );\n\n  return amounts;\n}\n"
                ],
                "Type": " buyAndSwap1155WETH() function may cause loss of user assets",
                "Description": "\nIn the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail.\nsolidity\nfunction buyAndSwap1155WETH(\n  uint256 vaultId,\n  uint256[] memory idsIn,\n  uint256[] memory amounts,\n  uint256[] memory specificIds,\n  uint256 maxWethIn,\n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i <idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount 0, \"Transferring <1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count-specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n\n\nIn extreme cases, when the user provides both ETH and WETH (the user approves the contract WETH in advance and calls the buyAndSwap1155WETH function instead of the buyAndSwap1155 function by mistake), the _buyVaultToken function will execute successfully, but because the buyAndSwap1155WETH function will not convert ETH to WETH, The user\u2019s ETH will be locked in the contract, causing loss of user assets.\nsolidity\nfunction _buyVaultToken(\n  address vault,\n  uint256 minTokenOut,\n  uint256 maxWethIn,\n  address[] calldata path\n) internal returns (uint256[] memory) {\n  uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n    minTokenOut,\n    maxWethIn,\n    path,\n    address(this),\n    block.timestamp\n  );\n\n  return amounts;\n}\n\n\n",
                "Repair": "solidity\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  + uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n\n\n0xKiwi (NFTX) confirmed and resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/2)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction distribute(uint256 vaultId) external override virtual nonReentrant {\n  require(nftxVaultFactory != address(0));\n  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n  if (distributionPaused || allocTotal == 0) {\n    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n    return;\n  }\n\n  uint256 length = feeReceivers.length;\n  uint256 leftover;\n  for (uint256 i = 0; i <length; i++) {\n    FeeReceiver memory _feeReceiver = feeReceivers[i];\n    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    amountToSend = amountToSend currentTokenBalance? currentTokenBalance: amountToSend;\n    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n    if (!complete) {\n      leftover = amountToSend;\n    } else {\n      leftover = 0;\n    }\n  }\n",
                    "//solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success,) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n"
                ],
                "Type": " The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees",
                "Description": "\nIn the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.\n\nsolidity\nfunction distribute(uint256 vaultId) external override virtual nonReentrant {\n  require(nftxVaultFactory != address(0));\n  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n  if (distributionPaused || allocTotal == 0) {\n    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n    return;\n  }\n\n  uint256 length = feeReceivers.length;\n  uint256 leftover;\n  for (uint256 i = 0; i <length; i++) {\n    FeeReceiver memory _feeReceiver = feeReceivers[i];\n    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    amountToSend = amountToSend currentTokenBalance? currentTokenBalance: amountToSend;\n    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n    if (!complete) {\n      leftover = amountToSend;\n    } else {\n      leftover = 0;\n    }\n  }\n\n\nIn the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.\nsolidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success,) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67\n\n",
                "Repair": "solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success, ) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    + return IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n\n0xKiwi (NFTX) confirmed, but disagreed with high severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/67#issuecomment-1003192355):\n  Good catch, thank you. Disagreeing with severity though since this is a permissioned contract, no user funds are at risk and this would most likely cause some failures.\n \n We aren't using any EOAs as receivers in production or testing, so this has not been caught. Thank you.\n\n0xKiwi (NFTX) resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/67)\n\nLSDan (judge) commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/67#issuecomment-1064471042):\n  I agree with the warden on this one. Funds are directly at risk and the likelihood of this occurring is 100%. I'm not sure if it matters if the funds are user funds or protocol funds. This would eventually have become a big problem that affected the protocol's ability to function.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "bash\n  NFTXMarketplaceZap.sol, receive is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, __SimpleFeeDistributor__init__ is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, addReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, initializeVaultReceivers is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAlloc is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, removeReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setTreasuryAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setLPStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setInventoryStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setNFTXVaultFactory is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, pauseFeeDistribution is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, rescueTokens is missing a reentrancy modifier\n  NFTXStakingZap.sol, setLPLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, setInventoryLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, receive is missing a reentrancy modifier\n  NFTXStakingZap.sol, rescue is missing a reentrancy modifier\n  NFTXV1Buyout.sol, __NFTXV1Buyout_init is missing a reentrancy modifier\n  NFTXV1Buyout.sol, emergencyWithdraw is missing a reentrancy modifier\n  NFTXV1Buyout.sol, clearBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, addBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, removeBuyout is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, __NFTXVault_init is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, finalizeVault is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultMetadata is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, assignDefaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, disableVaultFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, deployEligibilityStorage is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setManager is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, mint is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, redeem is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, swap is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, flashLoan is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, setLockTime is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, receive is missing a reentrancy modifier\n"
                ],
                "Type": " Missing non reentrancy modifier",
                "Description": "\nThe following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer.\nEven though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..\n\nbash\n  NFTXMarketplaceZap.sol, receive is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, __SimpleFeeDistributor__init__ is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, addReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, initializeVaultReceivers is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAlloc is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, removeReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setTreasuryAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setLPStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setInventoryStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setNFTXVaultFactory is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, pauseFeeDistribution is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, rescueTokens is missing a reentrancy modifier\n  NFTXStakingZap.sol, setLPLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, setInventoryLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, receive is missing a reentrancy modifier\n  NFTXStakingZap.sol, rescue is missing a reentrancy modifier\n  NFTXV1Buyout.sol, __NFTXV1Buyout_init is missing a reentrancy modifier\n  NFTXV1Buyout.sol, emergencyWithdraw is missing a reentrancy modifier\n  NFTXV1Buyout.sol, clearBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, addBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, removeBuyout is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, __NFTXVault_init is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, finalizeVault is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultMetadata is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, assignDefaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, disableVaultFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, deployEligibilityStorage is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setManager is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, mint is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, redeem is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, swap is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, flashLoan is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, setLockTime is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, receive is missing a reentrancy modifier\n\n0xKiwi (NFTX) disputed(https://github.com/code-423n4/2021-12-nftx-findings/issues/37)\n\nLSDan (judge) increased severity to medium and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/37#issuecomment-1064587166):\n  I'm updating this from a low] to a medium. Reentrancy represents a real and significant risk (as evident by ETC existing) and should be protected against regardless of if you can foresee the external event that causes lack of protection to be an issue.\n \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-16",
                "Location": [
                    "//solidity\nfunction distribute(uint256 vaultId) external override virtual nonReentrant {\n  require(nftxVaultFactory != address(0));\n  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n  if (distributionPaused || allocTotal == 0) {\n    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n    return;\n  }\n\n  uint256 length = feeReceivers.length;\n  uint256 leftover;\n  for (uint256 i = 0; i <length; i++) {\n    FeeReceiver memory _feeReceiver = feeReceivers[i];\n    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    amountToSend = amountToSend currentTokenBalance? currentTokenBalance: amountToSend;\n    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n    if (!complete) {\n      leftover = amountToSend;\n    } else {\n      leftover = 0;\n    }\n  }\n",
                    "//solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success,) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n"
                ],
                "Type": " Malicious receiver can make distribute function denial of service",
                "Description": "\nIn the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee\n\nsolidity\nfunction distribute(uint256 vaultId) external override virtual nonReentrant {\n  require(nftxVaultFactory != address(0));\n  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n  if (distributionPaused || allocTotal == 0) {\n    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n    return;\n  }\n\n  uint256 length = feeReceivers.length;\n  uint256 leftover;\n  for (uint256 i = 0; i <length; i++) {\n    FeeReceiver memory _feeReceiver = feeReceivers[i];\n    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    amountToSend = amountToSend currentTokenBalance? currentTokenBalance: amountToSend;\n    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n    if (!complete) {\n      leftover = amountToSend;\n    } else {\n      leftover = 0;\n    }\n  }\n\n\nIn the _sendForReceiver function, when the _receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.\n\nsolidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success,) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n\n\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L166\n\n",
                "Repair": "\nThe contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.\n\n0xKiwi (NFTX) confirmed, but disagreed with high severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/69#issuecomment-1003192680):\n  This is a permissioned entity, but this is a valid concern. User funds not at risk and the dao can remove the malciious receiver (if it ever gets there in the first place). Good thinking. \n\n0xKiwi (NFTX) resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/69)\n\nLSDan (judge) decreased severity to medium and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/69#issuecomment-1064475286):\n  This is a medium risk, not high. The attack has external requirements and is relatively easy for the DAO to mitigate.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-17",
                "Location": [
                    "//solidity\nNFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken); \nNFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); \nPalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn); \nPalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth); \nPalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn); \nPalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth); \nPalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken); \nXTokenUpgradeable.sol, 54, baseToken.transfer(who, what); \nNFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);\n"
                ],
                "Type": " transfer return value is ignored",
                "Description": "\nNeed to use safeTransfer instead of transfer. As there are popular tokens, such as USDT that transfer/transferFrom method doesn\u2019t return anything. The transfer return value has to be checked (as there are some other tokens that returns false instead revert), that means you must\n\n1.  Check the transfer return value\n\nAnother popular possibility is to add a whiteList.\nThose are the appearances (solidity file, line number, actual line):\n\nsolidity\nNFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken); \nNFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); \nPalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn); \nPalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth); \nPalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn); \nPalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth); \nPalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken); \nXTokenUpgradeable.sol, 54, baseToken.transfer(who, what); \nNFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);\n\n\n0xKiwi (NFTX) confirmed, but disagreed with high severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/40#issuecomment-1003186753):\n  Disagreeing with the severity, but will make sure I stick to safeTransferFrom, thank you.\n\n0xKiwi (NFTX) resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/40)\n\nLSDan (judge) decreased severity to medium and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/40#issuecomment-1064472797):\n  This is medium risk, not high. Loss of funds requires external factors.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n  function balanceOf(address to) external view returns (uint256);\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 constant BASE = 10**18;\n\n  event Buy(uint256 count, uint256 ethSpent, address to);\n  event Sell(uint256 count, uint256 ethReceived, address to);\n  event Swap(uint256 count, uint256 ethSpent, address to);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function mintAndSell721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function mintAndSell721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function buyAndSwap721(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndSwap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap1155WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndRedeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndRedeemWETH(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function mintAndSell1155(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function mintAndSell1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function _mint721(\n    uint256 vaultId, \n    uint256[] memory ids\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); \n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _swap721(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < idsIn.length; i++) {\n      transferFromERC721(assetAddress, idsIn[i], vault);\n      approveERC721(assetAddress, vault, idsIn[i]);\n    }\n    uint256[] memory emptyIds;\n    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _swap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory amounts,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _redeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds,\n    address to\n  ) internal {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n    INFTXVault(vault).redeemTo(amount, specificIds, to);\n  }\n\n  function _mint1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _buyVaultToken(\n    address vault, \n    uint256 minTokenOut, \n    uint256 maxWethIn, \n    address[] calldata path\n  ) internal returns (uint256[] memory) {\n    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n      minTokenOut,\n      maxWethIn,\n      path, \n      address(this),\n      block.timestamp\n    );\n\n    return amounts;\n  }\n  function _sellVaultTokenWETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function _sellVaultTokenETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXSimpleFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXInventoryStaking public immutable inventoryStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 public lpLockTime = 48 hours; \n  uint256 public inventoryLockTime = 7 days; \n  uint256 constant BASE = 10**18;\n\n  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {\n    require(newLPLockTime <= 7 days, \"Lock too long\");\n    lpLockTime = newLPLockTime;\n  } \n\n  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {\n    require(newInventoryLockTime <= 14 days, \"Lock too long\");\n    inventoryLockTime = newInventoryLockTime;\n  }\n\n  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {\n    uint256 count = tokenIds.length;\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    uint256[] memory amounts = new uint256[](0);\n    address assetAddress = vault.assetAddress();\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      transferFromERC721(assetAddress, tokenIds[i], address(vault));\n      approveERC721(assetAddress, address(vault), tokenIds[i]);\n    }\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {\n    uint256 count;\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      count += amounts[i];\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());\n    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, \"\");\n    nft.setApprovalForAll(address(vault), true);\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function addLiquidity721ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn\n  ) public payable returns (uint256) {\n    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);\n  }\n\n  function addLiquidity721ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn\n  ) public payable returns (uint256) {\n    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);\n  }\n\n  function addLiquidity1155ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    // Finish this.\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity721To(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity1155To(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function _addLiquidity721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidity1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidityAndLock(\n    uint256 vaultId, \n    address vault, \n    uint256 minTokenIn, \n    uint256 minWethIn, \n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    // Provide liquidity.\n    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);\n    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(\n      address(vault), \n      sushiRouter.WETH(),\n      minTokenIn, \n      wethIn, \n      minTokenIn,\n      minWethIn,\n      address(this), \n      block.timestamp\n    );\n\n    // Stake in LP rewards contract \n    address lpToken = pairFor(vault, address(WETH));\n    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);\n    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);\n    \n    if (amountToken < minTokenIn) {\n      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);\n    }\n\n    uint256 lockEndTime = block.timestamp + lpLockTime;\n    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);\n    return (amountToken, amountEth, liquidity);\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n\n  function rescue(address token) external onlyOwner {\n    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTXMarketplaceZap.sol",
            "NFTXStakingZap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "jsx\nrequire(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n"
                ],
                "Type": " A vault can be locked from MarketplaceZap and StakingZap",
                "Description": "\nAny user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.\n\nEvery operation performed by the marketplace, that deals with vToken minting, performs this check:\n\njsx\nrequire(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n\n\nA malicious user could transfer any amount  0 of a vault\u2019vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace\n\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421\n\n",
                "Repair": "\nRemove this logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)\n\n0xKiwi (NFTX) confirmed, but disagreed with high severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/107#issuecomment-1003193410):\n  Valid concern, confirmed. And disagreeing with severity.\n\n0xKiwi (NFTX) resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/107)\n\nLSDan (judge) commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/107#issuecomment-1064511914):\n  In this case I agree with the warden's severity. The attack would cause user funds to be locked and is incredibly easy to perform.\n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXSimpleFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/SafeMathUpgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/ReentrancyGuardUpgradeable.sol\";\n\ncontract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  bool public distributionPaused;\n\n  address public override nftxVaultFactory;\n  address public override lpStaking;\n  address public override treasury;\n\n  // Total allocation points per vault. \n  uint256 public override allocTotal;\n  FeeReceiver[] public feeReceivers;\n\n  address public override inventoryStaking;\n\n  event UpdateTreasuryAddress(address newTreasury);\n  event UpdateLPStakingAddress(address newLPStaking);\n  event UpdateInventoryStakingAddress(address newInventoryStaking);\n  event UpdateNFTXVaultFactory(address factory);\n  event PauseDistribution(bool paused); \n\n  event AddFeeReceiver(address receiver, uint256 allocPoint);\n  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);\n  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);\n  event RemoveFeeReceiver(address receiver);\n  \n  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {\n    __Pausable_init();\n    setTreasuryAddress(_treasury);\n    setLPStakingAddress(_lpStaking);\n\n    _addReceiver(0.8 ether, lpStaking, true);\n  }\n\n  function distribute(uint256 vaultId) external override virtual nonReentrant {\n    require(nftxVaultFactory != address(0));\n    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n    if (distributionPaused || allocTotal == 0) {\n      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n      return;\n    } \n\n    uint256 length = feeReceivers.length;\n    uint256 leftover;\n    for (uint256 i = 0; i < length; i++) {\n      FeeReceiver memory _feeReceiver = feeReceivers[i];\n      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;\n      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n      if (!complete) {\n        leftover = amountToSend;\n      } else {\n        leftover = 0;\n      }\n    }\n\n    if (leftover > 0) {\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);\n    }\n  }\n\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {\n    _addReceiver(_allocPoint, _receiver, _isContract);\n  }\n\n  function initializeVaultReceivers(uint256 _vaultId) external override {\n    require(msg.sender == nftxVaultFactory, \"FeeReceiver: not factory\");\n    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);\n    if (inventoryStaking != address(0))\n      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);\n  }\n\n  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    allocTotal -= feeReceiver.allocPoint;\n    feeReceiver.allocPoint = _allocPoint;\n    allocTotal += _allocPoint;\n    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);\n  }\n\n  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    address oldReceiver = feeReceiver.receiver;\n    feeReceiver.receiver = _address;\n    feeReceiver.isContract = _isContract;\n    emit UpdateFeeReceiverAddress(oldReceiver, _address);\n  }\n\n  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {\n    uint256 arrLength = feeReceivers.length;\n    require(_receiverIdx < arrLength, \"FeeDistributor: Out of bounds\");\n    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);\n    allocTotal -= feeReceivers[_receiverIdx].allocPoint;\n    // Copy the last element to what is being removed and remove the last element.\n    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];\n    feeReceivers.pop();\n  }\n\n  function setTreasuryAddress(address _treasury) public override onlyOwner {\n    require(_treasury != address(0), \"Treasury != address(0)\");\n    treasury = _treasury;\n    emit UpdateTreasuryAddress(_treasury);\n  }\n\n  function setLPStakingAddress(address _lpStaking) public override onlyOwner {\n    require(_lpStaking != address(0), \"LPStaking != address(0)\");\n    lpStaking = _lpStaking;\n    emit UpdateLPStakingAddress(_lpStaking);\n  }\n\n  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {\n    inventoryStaking = _inventoryStaking;\n    emit UpdateInventoryStakingAddress(_inventoryStaking);\n  }\n\n  function setNFTXVaultFactory(address _factory) external override onlyOwner {\n    nftxVaultFactory = _factory;\n    emit UpdateNFTXVaultFactory(_factory);\n  }\n\n  function pauseFeeDistribution(bool pause) external onlyOwner {\n    distributionPaused = pause;\n    emit PauseDistribution(pause);\n  }\n\n  function rescueTokens(address _address) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\n    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);\n  }\n\n  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\n    feeReceivers.push(_feeReceiver);\n    allocTotal += _allocPoint;\n    emit AddFeeReceiver(_receiver, _allocPoint);\n  }\n\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n      // If the receive is not properly processed, send it to the treasury instead.\n       \n      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, ) = address(_receiver.receiver).call(payload);\n\n      // If the allowance has not been spent, it means we can pass it forward to next.\n      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n    } else {\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    }\n  }\n} \n\n",
        "CodeNames": [
            "NFTXSimpleFeeDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "addReceiver()",
                    "_receiver"
                ],
                "Type": " NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver",
                "Description": "\nThe addReceiver() function fails to check if the _receiver already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.\n\nThe receiver would receive more than expected (until the duplicate entry has been removed).\n\n",
                "Repair": "\nHave a mapping address = bool isReceiver that will update whenever receivers are added, modified to a new address or removed.\n\n0xKiwi (NFTX) acknowledged, but disagreed with medium severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/230#issuecomment-1003210641):\n  Valid concern, but this is a permissioned function.\n\nLSDan (judge) commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/230#issuecomment-1064558228):\n  I think this one is much more likely. I would suggest adding a check because the problem is easy to create and much harder to notice.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n  function balanceOf(address to) external view returns (uint256);\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 constant BASE = 10**18;\n\n  event Buy(uint256 count, uint256 ethSpent, address to);\n  event Sell(uint256 count, uint256 ethReceived, address to);\n  event Swap(uint256 count, uint256 ethSpent, address to);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function mintAndSell721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function mintAndSell721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function buyAndSwap721(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndSwap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap1155WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndRedeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndRedeemWETH(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function mintAndSell1155(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function mintAndSell1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function _mint721(\n    uint256 vaultId, \n    uint256[] memory ids\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); \n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _swap721(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < idsIn.length; i++) {\n      transferFromERC721(assetAddress, idsIn[i], vault);\n      approveERC721(assetAddress, vault, idsIn[i]);\n    }\n    uint256[] memory emptyIds;\n    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _swap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory amounts,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _redeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds,\n    address to\n  ) internal {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n    INFTXVault(vault).redeemTo(amount, specificIds, to);\n  }\n\n  function _mint1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _buyVaultToken(\n    address vault, \n    uint256 minTokenOut, \n    uint256 maxWethIn, \n    address[] calldata path\n  ) internal returns (uint256[] memory) {\n    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n      minTokenOut,\n      maxWethIn,\n      path, \n      address(this),\n      block.timestamp\n    );\n\n    return amounts;\n  }\n  function _sellVaultTokenWETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function _sellVaultTokenETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTXMarketplaceZap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nfunction buyAndSwap721WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (idsIn.length specificIds.length)\n  );\n  uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n  _swap721(vaultId, idsIn, specificIds, to);\n\n  emit Swap(idsIn.length, amounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n"
                ],
                "Type": "  NFTXMarketplaceZap.sol#buyAnd*()  should return unused weth/eth back to  msg.sender  instead of  to ",
                "Description": "\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L226-L249\n\nsolidity\nfunction buyAndSwap721WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (idsIn.length specificIds.length)\n  );\n  uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n  _swap721(vaultId, idsIn, specificIds, to);\n\n  emit Swap(idsIn.length, amounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n\n\nFor example:\n\nIf Alice calls buyAndSwap721WETH() to buy some ERC721 and send to Bob, for slippage control, Alice put 1000 ETH as maxWethIn, the actual cost should be lower.\n\nLet's say the actual cost is 900 ETH.\n\nExpected Results: Alice spend only for the amount of the actual cost (900 ETH).\n\nActual Results: Alice spent 1000 ETH.\n\n0xKiwi (NFTX) acknowledged, but disagreed with medium severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/161#issuecomment-1003214046):\n  I think the idea in this is that if a contract is buying for someone else, the zap handles the refund instead of the contract originating the purchase.\n But this is a valid concern, thank you\n\nLSDan (judge) commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/161#issuecomment-1064555316):\n  This does result in a loss of funds if the user sends the wrong amount. I agree with the warden's severity rating.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-08",
                "Location": [
                    "payable(to).call{value: msg.value-amountEth}",
                    "addLiquidity"
                ],
                "Type": " Low-level call return value not checked",
                "Description": "\nThe NFTXStakingZap.addLiquidity721ETHTo function performs a low-level .call in payable(to).call{value: msg.value-amountEth} but does not check the return value if the call succeeded.\n\n\nIf the call fails, the refunds did not succeed and the caller will lose all refunds of msg.value amountEth.\n\n",
                "Repair": "\nRevert the entire transaction if the refund call fails by checking that the success return value of the payable(to).call(...) returns true.\n\n0xKiwi (NFTX) confirmed and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/140#issuecomment-1003224022):\n  Nice catch, thank you. Confirmed.\n\n0xKiwi (NFTX) resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/140)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n  function balanceOf(address to) external view returns (uint256);\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 constant BASE = 10**18;\n\n  event Buy(uint256 count, uint256 ethSpent, address to);\n  event Sell(uint256 count, uint256 ethReceived, address to);\n  event Swap(uint256 count, uint256 ethSpent, address to);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function mintAndSell721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function mintAndSell721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function buyAndSwap721(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndSwap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap1155WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndRedeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndRedeemWETH(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function mintAndSell1155(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function mintAndSell1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function _mint721(\n    uint256 vaultId, \n    uint256[] memory ids\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); \n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _swap721(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < idsIn.length; i++) {\n      transferFromERC721(assetAddress, idsIn[i], vault);\n      approveERC721(assetAddress, vault, idsIn[i]);\n    }\n    uint256[] memory emptyIds;\n    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _swap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory amounts,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _redeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds,\n    address to\n  ) internal {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n    INFTXVault(vault).redeemTo(amount, specificIds, to);\n  }\n\n  function _mint1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _buyVaultToken(\n    address vault, \n    uint256 minTokenOut, \n    uint256 maxWethIn, \n    address[] calldata path\n  ) internal returns (uint256[] memory) {\n    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n      minTokenOut,\n      maxWethIn,\n      path, \n      address(this),\n      block.timestamp\n    );\n\n    return amounts;\n  }\n  function _sellVaultTokenWETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function _sellVaultTokenETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXEligibility.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\nimport \"./proxy/ClonesUpgradeable.sol\";\n\ncontract NFTXEligibilityManager is OwnableUpgradeable {\n    struct EligibilityModule {\n        address implementation;\n        address targetAsset;\n        string name;\n    }\n    EligibilityModule[] public modules;\n\n    event ModuleAdded(\n        address implementation,\n        address targetAsset,\n        string name,\n        bool finalizedOnDeploy\n    );\n    event ModuleUpdated(\n        address implementation,\n        string name,\n        bool finalizedOnDeploy\n    );\n\n    function __NFTXEligibilityManager_init() public initializer {\n        __Ownable_init();\n    }\n\n    function addModule(address implementation) external onlyOwner {\n        require(implementation != address(0), \"Impl != address(0)\");\n        INFTXEligibility elig = INFTXEligibility(implementation);\n        string memory name = elig.name();\n        EligibilityModule memory module = EligibilityModule(\n            implementation,\n            elig.targetAsset(),\n            name\n        );\n        modules.push(module);\n        emit ModuleAdded(\n            implementation,\n            module.targetAsset,\n            name,\n            elig.finalized()\n        );\n    }\n\n    function updateModule(uint256 moduleIndex, address implementation)\n        external\n        onlyOwner\n    {\n        require(moduleIndex < modules.length, \"Out of bounds\");\n        require(implementation != address(0), \"Impl != address(0)\");\n        modules[moduleIndex].implementation = implementation;\n        INFTXEligibility elig = INFTXEligibility(implementation);\n        emit ModuleUpdated(implementation, elig.name(), elig.finalized());\n    }\n\n    function deployEligibility(uint256 moduleIndex, bytes calldata configData)\n        external\n        virtual\n        returns (address)\n    {\n        require(moduleIndex < modules.length, \"Out of bounds\");\n        address eligImpl = modules[moduleIndex].implementation;\n        address eligibilityClone = ClonesUpgradeable.clone(eligImpl);\n        INFTXEligibility(eligibilityClone).__NFTXEligibility_init_bytes(\n            configData\n        );\n        return eligibilityClone;\n    }\n\n    function allModules() external view returns (EligibilityModule[] memory) {\n        return modules;\n    }\n\n    function allModuleNames() external view returns (string[] memory) {\n        EligibilityModule[] memory modulesCopy = modules;\n        string[] memory names = new string[](modulesCopy.length);\n        for (uint256 i = 0; i < modulesCopy.length; i++) {\n            names[i] = modulesCopy[i].name;\n        }\n        return names;\n    }\n}\n\n\n",
        "CodeNames": [
            "NFTXMarketplaceZap.sol",
            "NFTXEligibilityManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "transferFromERC",
                    "address(this)"
                ],
                "Type": " NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address",
                "Description": "\ntransferFromERC721(address assetAddr, uint256 tokenId, address to) should transfer from msg.sender to to.\nIt transfers to address(this) instead when ERC721 is Cryptokitties.\nAs there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).\n\n\nNFTXStakingZap:\ntransferFromERC721\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416\n\nNFTXMarketplaceZap:\ntransferFromERC721\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556\n\nBoth functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.\n\n",
                "Repair": "\nFix the address:\n\nNow:\n\nsolidity\n  // Cryptokitties.\n  data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n\n\nTo be:\nsolidity\n  // Cryptokitties.\n  data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n\n\n0xKiwi (NFTX) confirmed, but disagreed with medium severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/185#issuecomment-1003211591):\n  This was intentional, as I thought it was needed for the contract to require custody, but it should work fine to send directly to the vault.\n\n0xKiwi (NFTX) resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/185)\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n  function balanceOf(address to) external view returns (uint256);\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 constant BASE = 10**18;\n\n  event Buy(uint256 count, uint256 ethSpent, address to);\n  event Sell(uint256 count, uint256 ethReceived, address to);\n  event Swap(uint256 count, uint256 ethSpent, address to);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function mintAndSell721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function mintAndSell721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function buyAndSwap721(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndSwap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap1155WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndRedeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndRedeemWETH(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function mintAndSell1155(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function mintAndSell1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function _mint721(\n    uint256 vaultId, \n    uint256[] memory ids\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); \n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _swap721(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < idsIn.length; i++) {\n      transferFromERC721(assetAddress, idsIn[i], vault);\n      approveERC721(assetAddress, vault, idsIn[i]);\n    }\n    uint256[] memory emptyIds;\n    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _swap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory amounts,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _redeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds,\n    address to\n  ) internal {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n    INFTXVault(vault).redeemTo(amount, specificIds, to);\n  }\n\n  function _mint1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _buyVaultToken(\n    address vault, \n    uint256 minTokenOut, \n    uint256 maxWethIn, \n    address[] calldata path\n  ) internal returns (uint256[] memory) {\n    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n      minTokenOut,\n      maxWethIn,\n      path, \n      address(this),\n      block.timestamp\n    );\n\n    return amounts;\n  }\n  function _sellVaultTokenWETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function _sellVaultTokenETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/IERC20Metadata.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/Address.sol\";\nimport \"./util/Create2.sol\";\nimport \"./proxy/Initializable.sol\";\nimport \"./proxy/UpgradeableBeacon.sol\";\nimport \"./proxy/Create2BeaconProxy.sol\";\nimport \"./token/XTokenUpgradeable.sol\";\n\n// Author: 0xKiwi.\n\n// Pausing codes for inventory staking are:\n// 10: Deposit\n\ncontract NFTXInventoryStaking is PausableUpgradeable, UpgradeableBeacon, INFTXInventoryStaking {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant BASE = 10**18;\n    // Small locktime to prevent flash deposits.\n    uint256 public constant DEFAULT_LOCKTIME = 2;\n\n    INFTXVaultFactory public override nftxVaultFactory;\n    mapping(uint256 => address) internal UNUSED;\n\n    event XTokenCreated(uint256 vaultId, address baseToken, address xToken);\n    event Deposit(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, uint256 timelockUntil, address sender);\n    event Withdraw(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, address sender);\n\n    function __NFTXInventoryStaking_init(address _nftxVaultFactory) external virtual override initializer {\n        __Ownable_init();\n        nftxVaultFactory = INFTXVaultFactory(_nftxVaultFactory);\n        address xTokenImpl = address(new XTokenUpgradeable());\n        __UpgradeableBeacon__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == nftxVaultFactory.feeDistributor(), \"LPStaking: Not authorized\");\n        _;\n    }\n    \n    function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit XTokenCreated(vaultId, baseToken, xToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n        \n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!isContract(deployedXToken) || XTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        return true;\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) public virtual override {\n        onlyOwnerIfPaused(10);\n\n        (IERC20Upgradeable baseToken, XTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, DEFAULT_LOCKTIME);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit Deposit(vaultId, _amount, xTokensMinted, DEFAULT_LOCKTIME, msg.sender);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        require(nftxVaultFactory.excludedFromFees(msg.sender), \"Not a zap\");\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit Deposit(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) public virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit Withdraw(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n        require(address(xToken) != address(0), \"XToken not deployed\");\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0 \n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply() \n            : multiplier;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n    \n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        require(isContract(xToken), \"XToken not deployed\");\n        return xToken;\n    } \n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, XTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n\n    function _deployXToken(address vaultToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(vaultToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(vaultToken));\n        address deployedXToken = Create2.deploy(0, salt, type(Create2BeaconProxy).creationCode);\n        XTokenUpgradeable(deployedXToken).__XToken_init(vaultToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n",
        "CodeNames": [
            "NFTXMarketplaceZap.sol",
            "NFTXInventoryStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "xToken",
                    "shares",
                    "approve",
                    "transferFrom"
                ],
                "Type": "  xToken  Approvals Allow Spenders To Spend More Tokens",
                "Description": "\nThe approve function has not been overridden and therefore uses xToken shares instead of the equivalent rebalanced amount, i.e. the underlying vault token amount.\n\n\nThe approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing as rewards continue to be distributed to the XTokenUpgradeable contract.\n\nMany contracts also use the same amount for the approve call as for the amount they want to have transferred in a subsequent transferFrom call, and in this case, they approve an amount that is too large (as the approved shares amount yields a higher rebalanced amount).\n\n",
                "Repair": "\nThe _allowances field should track the rebalanced amounts (i.e. the equivalent vault token amount) such that the approval value does not grow.\n\nThe transferFrom needs to be overridden and approvals should then be subtracted by the transferred vault token amount, not shares.\n\n0xKiwi (NFTX) acknowledged, but disagreed with high severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/58#issuecomment-1003191456):\n  Not sure if I agree with this severity. If I approve for xTokens, I'm using xTokens, not the underlying token.\n\nLSDan (judge) decreased severity to medium and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/58#issuecomment-1064497035):\n  This is a medium risk, not high. External assumptions (malicious contracts) are requires for any attack regarding the approval being too high. \n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-12",
                "Location": [
                    "//solidity\nfunction buyAndSwap1155WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory amounts, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i < idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount  0, \"Transferring < 1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n  emit Swap(count, swapAmounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n"
                ],
                "Type": "  buyAndSwap1155WETH  Does Not Work As Intended",
                "Description": "\nThe buyAndSwap1155WETH function in NFTXMarketplaceZap aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the msg.sender account and use these tokens in purchasing vault tokens. However, the _buyVaultToken call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.\n\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314\n\nsolidity\nfunction buyAndSwap1155WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory amounts, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i < idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount  0, \"Transferring < 1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n  emit Swap(count, swapAmounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n\n\n\nManual code review.\nDiscussions with Kiwi.\n\n",
                "Repair": "\nConsider updating the buyAndSwap1155WETH function such that the following line of code is used instead of this(https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).\n\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n\n0xKiwi (NFTX) confirmed and resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/45)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/IERC20Metadata.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/Address.sol\";\nimport \"./util/Create2.sol\";\nimport \"./proxy/Initializable.sol\";\nimport \"./proxy/UpgradeableBeacon.sol\";\nimport \"./proxy/Create2BeaconProxy.sol\";\nimport \"./token/XTokenUpgradeable.sol\";\n\n// Author: 0xKiwi.\n\n// Pausing codes for inventory staking are:\n// 10: Deposit\n\ncontract NFTXInventoryStaking is PausableUpgradeable, UpgradeableBeacon, INFTXInventoryStaking {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant BASE = 10**18;\n    // Small locktime to prevent flash deposits.\n    uint256 public constant DEFAULT_LOCKTIME = 2;\n\n    INFTXVaultFactory public override nftxVaultFactory;\n    mapping(uint256 => address) internal UNUSED;\n\n    event XTokenCreated(uint256 vaultId, address baseToken, address xToken);\n    event Deposit(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, uint256 timelockUntil, address sender);\n    event Withdraw(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, address sender);\n\n    function __NFTXInventoryStaking_init(address _nftxVaultFactory) external virtual override initializer {\n        __Ownable_init();\n        nftxVaultFactory = INFTXVaultFactory(_nftxVaultFactory);\n        address xTokenImpl = address(new XTokenUpgradeable());\n        __UpgradeableBeacon__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == nftxVaultFactory.feeDistributor(), \"LPStaking: Not authorized\");\n        _;\n    }\n    \n    function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit XTokenCreated(vaultId, baseToken, xToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n        \n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!isContract(deployedXToken) || XTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        return true;\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) public virtual override {\n        onlyOwnerIfPaused(10);\n\n        (IERC20Upgradeable baseToken, XTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, DEFAULT_LOCKTIME);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit Deposit(vaultId, _amount, xTokensMinted, DEFAULT_LOCKTIME, msg.sender);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        require(nftxVaultFactory.excludedFromFees(msg.sender), \"Not a zap\");\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit Deposit(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) public virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit Withdraw(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n        require(address(xToken) != address(0), \"XToken not deployed\");\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0 \n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply() \n            : multiplier;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n    \n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        require(isContract(xToken), \"XToken not deployed\");\n        return xToken;\n    } \n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, XTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n\n    function _deployXToken(address vaultToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(vaultToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(vaultToken));\n        address deployedXToken = Create2.deploy(0, salt, type(Create2BeaconProxy).creationCode);\n        XTokenUpgradeable(deployedXToken).__XToken_init(vaultToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n",
        "CodeNames": [
            "NFTXInventoryStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "receiveRewards",
                    "deposit"
                ],
                "Type": " Rewards can be stolen",
                "Description": "\nThe NFTXInventoryStaking contract distributes new rewards to all previous stakers when the owner calls the receiveRewards function.\nThis allows an attacker to frontrun this receiveRewards transaction when they see it in the mem pool with a deposit function.\nThe attacker will receive the rewards pro-rata to their deposits.\nThe deposit will be locked for 2 seconds only (DEFAULT_LOCKTIME) after which the depositor can withdraw their initial deposit & the rewards again for a profit.\n\nThe rewards can be gamed this way and one does not actually have to *stake*, only be in the staking contract at the time of reward distribution for 2 seconds.\nThe rest of the time they can be used for other purposes.\n\n",
                "Repair": "\nDistribute the rewards equally over time to the stakers instead of in a single chunk on each receiveRewards call.\nThis is more of a \"streaming rewards\" approach.\n\n0xKiwi (NFTX) confirmed and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/136#issuecomment-1003225759):\n  Thanks for the report. \n \n This is unfortunately unavoidable but streaming isn't a bad idea. Will consider. Thank you.\n \n Confirming.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "shares",
                    "xTokens",
                    "xToken",
                    "base tokens",
                    "distribute",
                    "deposit"
                ],
                "Type": " Dishonest Stakers Can Siphon Rewards From  xToken  Holders Through The  deposit  Function In  NFTXInventoryStaking ",
                "Description": "\nxTokens is intended to be a representation of staked vault tokens. As the protocol's vaults accrue fees from users, these fees are intended to be distributed to users in an inconsistent fashion. NFTXInventoryStaking is one of the ways users can stake vault tokens. Deposits are timelocked for 2 seconds by default, essentially rendering flash loan attacks redundant. However, it is more than likely that the same user could withdraw their xToken deposit in the next block (assuming an average block time of just over 13 seconds).\n\nHence, if a well-funded attacker sees a transaction to distribute rewards to xToken holders, they could deposit a large sum of vault tokens and receive a majority share of the rewards before withdrawing their tokens in the following block. Additionally, the attacker can force distribute rewards in NFTXSimpleFeeDistributor as there is no access control on the distribute function.\n\nThis issue allows users to siphon user's rewards from the protocol, intended to be distributed to honest vault token stakers.\n\n\nConsider the following exploit scenario:\n\n*   Currently there are 1000 shares and 1000 base tokens in the XTokenUpgradeable contract.\n*   Honest actor, Alice, calls distribute in NFTXSimpleFeeDistributor which attempts to send 200 base tokens as rewards for xToken holders accrued via protocol usage.\n*   Bob sees a transaction to reward xToken holders and frontruns this transaction by staking vault tokens, minting 1000 shares and 1000 base tokens.\n*   Rewards are distributed such that XTokenUpgradeable has 2000 shares and 2200 base tokens.\n*   Bob unstakes his tokens and exits the pool, redeeming his 1000 shares for 1100 base tokens.\n*   As a result, Bob was able to siphon off 100 base tokens without having to stake their tokens for the same time period that Alice had staked her tokens for.\n*   This unfair distribution can be abused again and again to essentially reward dishonest actors over honest staking participants such as Alice.\n\n\nManual code review.\nDiscussions with Kiwi.\n\n",
                "Repair": "\nConsider adding a delay to users token deposits into the XTokenUpgradeable such that miners cannot feasibly censor a transaction for the specified time interval and users cannot frontrun a transaction to distribute rewards. The interval should be chosen such that enough time is provided for the transaction to be included in a block, given poor network conditions.\n\nI.e. If the chosen interval is 20 blocks. Miners must be able to censor the rewards distribution for 20 blocks. This is unlikely as there would need to be sufficient miner collusion for value to be extracted from the protocol. Additionally, an interval of 20 blocks means that stakers who attempt to enter the pool upon seeing the transaction in the mempool won't be rewarded for such behaviour.\n\nIt is also essential that the distribute function in NFTXSimpleFeeDistributor is restricted to a given role, ensuring malicious users cannot control at what point rewards are distributed.\n\nAlternatively, PoolTogether has a Time-Weighted-Average-Balance (TWAB) implementation which can be used as reference(https://v4.docs.pooltogether.com/protocol/concepts/time-weight-average-balance/). This would ensure the fairest distribution of rewards to stakers, however, there are additional gas costs associated with this implementation. Hence, unless the protocol intends to be used primarily on L2 protocols, this solution should be avoided.\n\n0xKiwi (NFTX) acknowledged, but disagreed with high severity and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/57#issuecomment-1007912676):\n  While this attack is possible, without available flash liquidity, this attack vector requires a lot of (possibly difficult to acquire) capital to execute. Disagreeing with severity and acknowledging.\n\nLSDan (judge) decreased severity to medium and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/57#issuecomment-1064495218):\n  I agree with the sponsor that the risk of this happening is almost zero. Yes it's technically possible but the funds lost are going to be minimal and the attacker will almost definitely pay more in slippage and gas fees than they make. That said, this is a direct attack which results in a loss of user funds so making it less than medium risk seems disingenuous.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./ERC20Upgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../interface/IRewardDistributionToken.sol\";\nimport \"../util/OwnableUpgradeable.sol\";\nimport \"../util/SafeERC20Upgradeable.sol\";\nimport \"../util/SafeMathUpgradeable.sol\";\nimport \"../util/SafeMathInt.sol\";\n\n/// @title Reward-Paying Token (renamed from Dividend)\n/// @author Roger Wu (https://github.com/roger-wu)\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute a target token\n///  to token holders as dividends and allows token holders to withdraw their dividends.\n///  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\ncontract TimelockRewardDistributionTokenImpl is OwnableUpgradeable, ERC20Upgradeable {\n  using SafeMathUpgradeable for uint256;\n  using SafeMathInt for int256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  \n  IERC20Upgradeable public target;\n\n  // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\n  // For more discussion about choosing the value of `magnitude`,\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n  uint256 constant internal magnitude = 2**128;\n\n  uint256 internal magnifiedRewardPerShare;\n\n  // About dividendCorrection:\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\n  //   `dividendOf(_user)` should not be changed,\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\n  mapping(address => int256) internal magnifiedRewardCorrections;\n  mapping(address => uint256) internal withdrawnRewards;\n\n  mapping(address => uint256) internal timelock;\n\n  event Timelocked(address user, uint256 amount, uint256 until);\n\n  function __TimelockRewardDistributionToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) public initializer {\n    __Ownable_init();\n    __ERC20_init(_name, _symbol);\n    target = _target;\n  }\n\n  function transfer(address recipient, uint256 amount)\n      public\n      virtual\n      override\n      returns (bool)\n  {\n      _transfer(_msgSender(), recipient, amount);\n      return true;\n  }\n\n  /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Emits an {Approval} event indicating the updated allowance. This is not\n    * required by the EIP. See the note at the beginning of {ERC20}.\n    *\n    * Requirements:\n    *\n    * - `sender` and `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    * - the caller must have allowance for ``sender``'s tokens of at least\n    * `amount`.\n    */\n  function transferFrom(address sender, address recipient, uint256 amount)\n      public\n      virtual\n      override\n      returns (bool)\n  {\n      _transfer(sender, recipient, amount);\n      _approve(\n          sender,\n          _msgSender(),\n          allowance(sender, _msgSender()).sub(\n              amount,\n              \"ERC20: transfer amount exceeds allowance\"\n          )\n      );\n      return true;\n  }\n\n  function mint(address account, uint256 amount) public onlyOwner virtual {\n      _mint(account, amount);\n  }\n\n  function timelockMint(address account, uint256 amount, uint256 timelockLength) public onlyOwner virtual {\n    uint256 timelockFinish = block.timestamp + timelockLength;\n    timelock[account] = timelockFinish;\n    emit Timelocked(account, amount, timelockFinish);\n    _mint(account, amount);\n  }\n\n  function timelockUntil(address account) public view returns (uint256) {\n    return timelock[account];\n  }\n\n  /**\n    * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n    * allowance.\n    *\n    * See {ERC20-_burn} and {ERC20-allowance}.\n    *\n    * Requirements:\n    *\n    * - the caller must have allowance for ``accounts``'s tokens of at least\n    * `amount`.\n    */\n  function burnFrom(address account, uint256 amount) public virtual onlyOwner {\n      _burn(account, amount);\n  }\n\n  /// @notice Distributes target to token holders as dividends.\n  /// @dev It reverts if the total supply of tokens is 0.\n  /// It emits the `RewardsDistributed` event if the amount of received target is greater than 0.\n  /// About undistributed target tokens:\n  ///   In each distribution, there is a small amount of target not distributed,\n  ///     the magnified amount of which is\n  ///     `(amount * magnitude) % totalSupply()`.\n  ///   With a well-chosen `magnitude`, the amount of undistributed target\n  ///     (de-magnified) in a distribution can be less than 1 wei.\n  ///   We can actually keep track of the undistributed target in a distribution\n  ///     and try to distribute it in the next distribution,\n  ///     but keeping track of such data on-chain costs much more than\n  ///     the saved target, so we don't do that.\n  function distributeRewards(uint amount) external virtual onlyOwner {\n    require(totalSupply() > 0, \"RewardDist: 0 supply\");\n    require(amount > 0, \"RewardDist: 0 amount\");\n\n    // Because we receive the tokens from the staking contract, we assume the tokens have been received.\n    magnifiedRewardPerShare = magnifiedRewardPerShare.add(\n      (amount).mul(magnitude) / totalSupply()\n    );\n\n    emit RewardsDistributed(msg.sender, amount);\n  }\n\n  /// @notice Withdraws the target distributed to the sender.\n  /// @dev It emits a `RewardWithdrawn` event if the amount of withdrawn target is greater than 0.\n  function withdrawReward(address user) external onlyOwner {\n    uint256 _withdrawableReward = withdrawableRewardOf(user);\n    if (_withdrawableReward > 0) {\n      withdrawnRewards[user] = withdrawnRewards[user].add(_withdrawableReward);\n      target.safeTransfer(user, _withdrawableReward);\n      emit RewardWithdrawn(user, _withdrawableReward);\n    }\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function dividendOf(address _owner) public view returns(uint256) {\n    return withdrawableRewardOf(_owner);\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function withdrawableRewardOf(address _owner) internal view returns(uint256) {\n    return accumulativeRewardOf(_owner).sub(withdrawnRewards[_owner]);\n  }\n\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\n  function withdrawnRewardOf(address _owner) public view returns(uint256) {\n    return withdrawnRewards[_owner];\n  }\n\n\n  /// @notice View the amount of dividend in wei that an address has earned in total.\n  /// @dev accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner)\n  /// = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\n  function accumulativeRewardOf(address _owner) public view returns(uint256) {\n    return magnifiedRewardPerShare.mul(balanceOf(_owner)).toInt256()\n      .add(magnifiedRewardCorrections[_owner]).toUint256Safe() / magnitude;\n  }\n\n  /// @dev Internal function that transfer tokens from one address to another.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param from The address to transfer from.\n  /// @param to The address to transfer to.\n  /// @param value The amount to be transferred.\n  function _transfer(address from, address to, uint256 value) internal override {\n    require(block.timestamp > timelock[from], \"User locked\");\n    super._transfer(from, to, value);\n\n    int256 _magCorrection = magnifiedRewardPerShare.mul(value).toInt256();\n    magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from].add(_magCorrection);\n    magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to].sub(_magCorrection);\n  }\n\n  /// @dev Internal function that mints tokens to an account.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param account The account that will receive the created tokens.\n  /// @param value The amount that will be created.\n  function _mint(address account, uint256 value) internal override {\n    super._mint(account, value);\n\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account]\n      .sub( (magnifiedRewardPerShare.mul(value)).toInt256() );\n  }\n\n  /// @dev Internal function that burns an amount of the token of a given account.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param account The account whose tokens will be burnt.\n  /// @param value The amount that will be burnt.\n  function _burn(address account, uint256 value) internal override {\n    require(block.timestamp > timelock[account], \"User locked\");\n    super._burn(account, value);\n\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account]\n      .add( (magnifiedRewardPerShare.mul(value)).toInt256() );\n  }\n\n  /// @dev This event MUST emit when target is distributed to token holders.\n  /// @param from The address which sends target to this contract.\n  /// @param weiAmount The amount of distributed target in wei.\n  event RewardsDistributed(\n    address indexed from,\n    uint256 weiAmount\n  );\n\n  /// @dev This event MUST emit when an address withdraws their dividend.\n  /// @param to The address which withdraws target from this contract.\n  /// @param weiAmount The amount of withdrawn target in wei.\n  event RewardWithdrawn(\n    address indexed to,\n    uint256 weiAmount\n  );\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/IERC20Metadata.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/Address.sol\";\nimport \"./util/Create2.sol\";\nimport \"./proxy/Initializable.sol\";\nimport \"./proxy/UpgradeableBeacon.sol\";\nimport \"./proxy/Create2BeaconProxy.sol\";\nimport \"./token/XTokenUpgradeable.sol\";\n\n// Author: 0xKiwi.\n\n// Pausing codes for inventory staking are:\n// 10: Deposit\n\ncontract NFTXInventoryStaking is PausableUpgradeable, UpgradeableBeacon, INFTXInventoryStaking {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant BASE = 10**18;\n    // Small locktime to prevent flash deposits.\n    uint256 public constant DEFAULT_LOCKTIME = 2;\n\n    INFTXVaultFactory public override nftxVaultFactory;\n    mapping(uint256 => address) internal UNUSED;\n\n    event XTokenCreated(uint256 vaultId, address baseToken, address xToken);\n    event Deposit(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, uint256 timelockUntil, address sender);\n    event Withdraw(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, address sender);\n\n    function __NFTXInventoryStaking_init(address _nftxVaultFactory) external virtual override initializer {\n        __Ownable_init();\n        nftxVaultFactory = INFTXVaultFactory(_nftxVaultFactory);\n        address xTokenImpl = address(new XTokenUpgradeable());\n        __UpgradeableBeacon__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == nftxVaultFactory.feeDistributor(), \"LPStaking: Not authorized\");\n        _;\n    }\n    \n    function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit XTokenCreated(vaultId, baseToken, xToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n        \n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!isContract(deployedXToken) || XTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        return true;\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) public virtual override {\n        onlyOwnerIfPaused(10);\n\n        (IERC20Upgradeable baseToken, XTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, DEFAULT_LOCKTIME);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit Deposit(vaultId, _amount, xTokensMinted, DEFAULT_LOCKTIME, msg.sender);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        require(nftxVaultFactory.excludedFromFees(msg.sender), \"Not a zap\");\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit Deposit(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) public virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit Withdraw(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n        require(address(xToken) != address(0), \"XToken not deployed\");\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0 \n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply() \n            : multiplier;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n    \n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        require(isContract(xToken), \"XToken not deployed\");\n        return xToken;\n    } \n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, XTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n\n    function _deployXToken(address vaultToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(vaultToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(vaultToken));\n        address deployedXToken = Create2.deploy(0, salt, type(Create2BeaconProxy).creationCode);\n        XTokenUpgradeable(deployedXToken).__XToken_init(vaultToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXSimpleFeeDistributor.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./interface/ITimelockRewardDistributionToken.sol\";\nimport \"./interface/IUniswapV2Router01.sol\";\nimport \"./testing/IERC721.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\n\n// Authors: @0xKiwi_.\n\ninterface IWETH {\n  function deposit() external payable;\n  function transfer(address to, uint value) external returns (bool);\n  function withdraw(uint) external;\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXInventoryStaking public immutable inventoryStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 public lpLockTime = 48 hours; \n  uint256 public inventoryLockTime = 7 days; \n  uint256 constant BASE = 10**18;\n\n  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {\n    require(newLPLockTime <= 7 days, \"Lock too long\");\n    lpLockTime = newLPLockTime;\n  } \n\n  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {\n    require(newInventoryLockTime <= 14 days, \"Lock too long\");\n    inventoryLockTime = newInventoryLockTime;\n  }\n\n  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {\n    uint256 count = tokenIds.length;\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    uint256[] memory amounts = new uint256[](0);\n    address assetAddress = vault.assetAddress();\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      transferFromERC721(assetAddress, tokenIds[i], address(vault));\n      approveERC721(assetAddress, address(vault), tokenIds[i]);\n    }\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {\n    uint256 count;\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      count += amounts[i];\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());\n    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, \"\");\n    nft.setApprovalForAll(address(vault), true);\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function addLiquidity721ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn\n  ) public payable returns (uint256) {\n    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);\n  }\n\n  function addLiquidity721ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn\n  ) public payable returns (uint256) {\n    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);\n  }\n\n  function addLiquidity1155ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    // Finish this.\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity721To(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity1155To(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function _addLiquidity721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidity1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidityAndLock(\n    uint256 vaultId, \n    address vault, \n    uint256 minTokenIn, \n    uint256 minWethIn, \n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    // Provide liquidity.\n    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);\n    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(\n      address(vault), \n      sushiRouter.WETH(),\n      minTokenIn, \n      wethIn, \n      minTokenIn,\n      minWethIn,\n      address(this), \n      block.timestamp\n    );\n\n    // Stake in LP rewards contract \n    address lpToken = pairFor(vault, address(WETH));\n    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);\n    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);\n    \n    if (amountToken < minTokenIn) {\n      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);\n    }\n\n    uint256 lockEndTime = block.timestamp + lpLockTime;\n    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);\n    return (amountToken, amountEth, liquidity);\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n\n  function rescue(address token) external onlyOwner {\n    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));\n  }\n}\n\n\n",
        "CodeNames": [
            "TimelockRewardDistributionTokenImpl.sol",
            "NFTXInventoryStaking.sol",
            "NFTXStakingZap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "//solidity\nfunction _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n  uint256 timelockFinish = block.timestamp + timelockLength;\n  timelock[account] = timelockFinish;\n  emit Timelocked(account, timelockFinish);\n  _mint(account, amount);\n}\n"
                ],
                "Type": " Bypass zap timelock",
                "Description": "\nThe default value of inventoryLockTime in NFTXStakingZap is 7 days while DEFAULT_LOCKTIME in NFTXInventoryStaking is 2 ms. These timelock value are used in NFTXInventoryStaking to eventually call _timelockMint in XTokenUpgradeable.\n\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74\n\nsolidity\nfunction _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n  uint256 timelockFinish = block.timestamp + timelockLength;\n  timelock[account] = timelockFinish;\n  emit Timelocked(account, timelockFinish);\n  _mint(account, amount);\n}\n\n\nThe applicable timelock is calculated by block.timestamp + timelockLength, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling deposit in NFTXInventoryStaking\n\n\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L160\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L30\n\n",
                "Repair": "\nsolidity\nfunction _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n  uint256 timelockFinish = block.timestamp + timelockLength;\n  if(timelockFinish  timelock[account]){\n    timelock[account] = timelockFinish;\n    emit Timelocked(account, timelockFinish);\n  }\n  _mint(account, amount);\n}\n\n\n0xKiwi (NFTX) disputed(https://github.com/code-423n4/2021-12-nftx-findings/issues/178)\n\n0xKiwi (NFTX) confirmed and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/178#issuecomment-1007082108):\n  After taking another look, this is definitely accurate. Thank you!\n\n0xKiwi (NFTX) resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/178)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXSimpleFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/SafeMathUpgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/ReentrancyGuardUpgradeable.sol\";\n\ncontract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  bool public distributionPaused;\n\n  address public override nftxVaultFactory;\n  address public override lpStaking;\n  address public override treasury;\n\n  // Total allocation points per vault. \n  uint256 public override allocTotal;\n  FeeReceiver[] public feeReceivers;\n\n  address public override inventoryStaking;\n\n  event UpdateTreasuryAddress(address newTreasury);\n  event UpdateLPStakingAddress(address newLPStaking);\n  event UpdateInventoryStakingAddress(address newInventoryStaking);\n  event UpdateNFTXVaultFactory(address factory);\n  event PauseDistribution(bool paused); \n\n  event AddFeeReceiver(address receiver, uint256 allocPoint);\n  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);\n  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);\n  event RemoveFeeReceiver(address receiver);\n  \n  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {\n    __Pausable_init();\n    setTreasuryAddress(_treasury);\n    setLPStakingAddress(_lpStaking);\n\n    _addReceiver(0.8 ether, lpStaking, true);\n  }\n\n  function distribute(uint256 vaultId) external override virtual nonReentrant {\n    require(nftxVaultFactory != address(0));\n    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n    if (distributionPaused || allocTotal == 0) {\n      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n      return;\n    } \n\n    uint256 length = feeReceivers.length;\n    uint256 leftover;\n    for (uint256 i = 0; i < length; i++) {\n      FeeReceiver memory _feeReceiver = feeReceivers[i];\n      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;\n      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n      if (!complete) {\n        leftover = amountToSend;\n      } else {\n        leftover = 0;\n      }\n    }\n\n    if (leftover > 0) {\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);\n    }\n  }\n\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {\n    _addReceiver(_allocPoint, _receiver, _isContract);\n  }\n\n  function initializeVaultReceivers(uint256 _vaultId) external override {\n    require(msg.sender == nftxVaultFactory, \"FeeReceiver: not factory\");\n    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);\n    if (inventoryStaking != address(0))\n      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);\n  }\n\n  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    allocTotal -= feeReceiver.allocPoint;\n    feeReceiver.allocPoint = _allocPoint;\n    allocTotal += _allocPoint;\n    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);\n  }\n\n  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    address oldReceiver = feeReceiver.receiver;\n    feeReceiver.receiver = _address;\n    feeReceiver.isContract = _isContract;\n    emit UpdateFeeReceiverAddress(oldReceiver, _address);\n  }\n\n  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {\n    uint256 arrLength = feeReceivers.length;\n    require(_receiverIdx < arrLength, \"FeeDistributor: Out of bounds\");\n    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);\n    allocTotal -= feeReceivers[_receiverIdx].allocPoint;\n    // Copy the last element to what is being removed and remove the last element.\n    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];\n    feeReceivers.pop();\n  }\n\n  function setTreasuryAddress(address _treasury) public override onlyOwner {\n    require(_treasury != address(0), \"Treasury != address(0)\");\n    treasury = _treasury;\n    emit UpdateTreasuryAddress(_treasury);\n  }\n\n  function setLPStakingAddress(address _lpStaking) public override onlyOwner {\n    require(_lpStaking != address(0), \"LPStaking != address(0)\");\n    lpStaking = _lpStaking;\n    emit UpdateLPStakingAddress(_lpStaking);\n  }\n\n  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {\n    inventoryStaking = _inventoryStaking;\n    emit UpdateInventoryStakingAddress(_inventoryStaking);\n  }\n\n  function setNFTXVaultFactory(address _factory) external override onlyOwner {\n    nftxVaultFactory = _factory;\n    emit UpdateNFTXVaultFactory(_factory);\n  }\n\n  function pauseFeeDistribution(bool pause) external onlyOwner {\n    distributionPaused = pause;\n    emit PauseDistribution(pause);\n  }\n\n  function rescueTokens(address _address) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\n    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);\n  }\n\n  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\n    feeReceivers.push(_feeReceiver);\n    allocTotal += _allocPoint;\n    emit AddFeeReceiver(_receiver, _allocPoint);\n  }\n\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n      // If the receive is not properly processed, send it to the treasury instead.\n       \n      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, ) = address(_receiver.receiver).call(payload);\n\n      // If the allowance has not been spent, it means we can pass it forward to next.\n      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n    } else {\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    }\n  }\n} \n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/IERC20Metadata.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/Address.sol\";\nimport \"./util/Create2.sol\";\nimport \"./proxy/Initializable.sol\";\nimport \"./proxy/UpgradeableBeacon.sol\";\nimport \"./proxy/Create2BeaconProxy.sol\";\nimport \"./token/XTokenUpgradeable.sol\";\n\n// Author: 0xKiwi.\n\n// Pausing codes for inventory staking are:\n// 10: Deposit\n\ncontract NFTXInventoryStaking is PausableUpgradeable, UpgradeableBeacon, INFTXInventoryStaking {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant BASE = 10**18;\n    // Small locktime to prevent flash deposits.\n    uint256 public constant DEFAULT_LOCKTIME = 2;\n\n    INFTXVaultFactory public override nftxVaultFactory;\n    mapping(uint256 => address) internal UNUSED;\n\n    event XTokenCreated(uint256 vaultId, address baseToken, address xToken);\n    event Deposit(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, uint256 timelockUntil, address sender);\n    event Withdraw(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, address sender);\n\n    function __NFTXInventoryStaking_init(address _nftxVaultFactory) external virtual override initializer {\n        __Ownable_init();\n        nftxVaultFactory = INFTXVaultFactory(_nftxVaultFactory);\n        address xTokenImpl = address(new XTokenUpgradeable());\n        __UpgradeableBeacon__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == nftxVaultFactory.feeDistributor(), \"LPStaking: Not authorized\");\n        _;\n    }\n    \n    function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit XTokenCreated(vaultId, baseToken, xToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n        \n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!isContract(deployedXToken) || XTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        return true;\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) public virtual override {\n        onlyOwnerIfPaused(10);\n\n        (IERC20Upgradeable baseToken, XTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, DEFAULT_LOCKTIME);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit Deposit(vaultId, _amount, xTokensMinted, DEFAULT_LOCKTIME, msg.sender);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        require(nftxVaultFactory.excludedFromFees(msg.sender), \"Not a zap\");\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit Deposit(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) public virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit Withdraw(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n        require(address(xToken) != address(0), \"XToken not deployed\");\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0 \n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply() \n            : multiplier;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n    \n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        require(isContract(xToken), \"XToken not deployed\");\n        return xToken;\n    } \n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, XTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n\n    function _deployXToken(address vaultToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(vaultToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(vaultToken));\n        address deployedXToken = Create2.deploy(0, salt, type(Create2BeaconProxy).creationCode);\n        XTokenUpgradeable(deployedXToken).__XToken_init(vaultToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n",
        "CodeNames": [
            "NFTXSimpleFeeDistributor.sol",
            "NFTXInventoryStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-10",
                "Location": [
                    "false",
                    "feeReceivers",
                    "_sendForReceiver",
                    "safeTransfer",
                    "distribute",
                    "amountToSend"
                ],
                "Type": " NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract",
                "Description": "\nDouble spending of fees being distributed will happen in favor of the first fee receivers in the feeReceivers list at the expense of the last ones.\nAs _sendForReceiver doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.\n\n\ndistribute use _sendForReceiver to transfer current vault balance across feeReceivers:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67\n\n_sendForReceiver returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed.\nWhen _receiver.isContract is false nothing is returned, while safeTransfer is done:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168\n\nThis way _sendForReceiver will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the amountToSend will be spent twice:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64\n\n",
                "Repair": "\nNow:\n\nsolidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n  ...\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n\n\nTo be:\nsolidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n  ...\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    return true;\n  }\n}\n\n\n0xKiwi (NFTX) confirmed and resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/105)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-14",
                "Location": [
                    "else",
                    "_addReceiver",
                    "currentTokenBalance",
                    "isContract",
                    "amountToSend",
                    "distribute()",
                    "_sendForReceiver()"
                ],
                "Type": " Return variable can remain unassigned in _sendForReceiver",
                "Description": "\nThe _sendForReceiver() function only sets a return function in the \"if\" code block, not the \"else\" case. If the \"else\" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover  0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns(https://github.com/ethereum/solidity/issues/2951), so if no bool value is explicitly returned, the default bool value of False will be returned.\n\nThis problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.\n\n\nThe else block is missing a return value\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L167-L169\n\n\nVS Code \"Solidity Visual Developer\" extension\n\n",
                "Repair": "\nVerify that functions with a return value do actually return a value in all cases. Adding the line return true; can be added to the end of the else block as one way to resolve this.\n\nAlternatively, if isContract should never be set to False, the code should be designed to prevent a receiver from being added with this value.\n\n0xKiwi (NFTX) confirmed and resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/121#issuecomment-1003228547)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXEligibility.sol\";\nimport \"./util/OwnableUpgradeable.sol\";\nimport \"./proxy/ClonesUpgradeable.sol\";\n\ncontract NFTXEligibilityManager is OwnableUpgradeable {\n    struct EligibilityModule {\n        address implementation;\n        address targetAsset;\n        string name;\n    }\n    EligibilityModule[] public modules;\n\n    event ModuleAdded(\n        address implementation,\n        address targetAsset,\n        string name,\n        bool finalizedOnDeploy\n    );\n    event ModuleUpdated(\n        address implementation,\n        string name,\n        bool finalizedOnDeploy\n    );\n\n    function __NFTXEligibilityManager_init() public initializer {\n        __Ownable_init();\n    }\n\n    function addModule(address implementation) external onlyOwner {\n        require(implementation != address(0), \"Impl != address(0)\");\n        INFTXEligibility elig = INFTXEligibility(implementation);\n        string memory name = elig.name();\n        EligibilityModule memory module = EligibilityModule(\n            implementation,\n            elig.targetAsset(),\n            name\n        );\n        modules.push(module);\n        emit ModuleAdded(\n            implementation,\n            module.targetAsset,\n            name,\n            elig.finalized()\n        );\n    }\n\n    function updateModule(uint256 moduleIndex, address implementation)\n        external\n        onlyOwner\n    {\n        require(moduleIndex < modules.length, \"Out of bounds\");\n        require(implementation != address(0), \"Impl != address(0)\");\n        modules[moduleIndex].implementation = implementation;\n        INFTXEligibility elig = INFTXEligibility(implementation);\n        emit ModuleUpdated(implementation, elig.name(), elig.finalized());\n    }\n\n    function deployEligibility(uint256 moduleIndex, bytes calldata configData)\n        external\n        virtual\n        returns (address)\n    {\n        require(moduleIndex < modules.length, \"Out of bounds\");\n        address eligImpl = modules[moduleIndex].implementation;\n        address eligibilityClone = ClonesUpgradeable.clone(eligImpl);\n        INFTXEligibility(eligibilityClone).__NFTXEligibility_init_bytes(\n            configData\n        );\n        return eligibilityClone;\n    }\n\n    function allModules() external view returns (EligibilityModule[] memory) {\n        return modules;\n    }\n\n    function allModuleNames() external view returns (string[] memory) {\n        EligibilityModule[] memory modulesCopy = modules;\n        string[] memory names = new string[](modulesCopy.length);\n        for (uint256 i = 0; i < modulesCopy.length; i++) {\n            names[i] = modulesCopy[i].name;\n        }\n        return names;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXVault.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXInventoryStaking.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./token/IERC20Metadata.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/Address.sol\";\nimport \"./util/Create2.sol\";\nimport \"./proxy/Initializable.sol\";\nimport \"./proxy/UpgradeableBeacon.sol\";\nimport \"./proxy/Create2BeaconProxy.sol\";\nimport \"./token/XTokenUpgradeable.sol\";\n\n// Author: 0xKiwi.\n\n// Pausing codes for inventory staking are:\n// 10: Deposit\n\ncontract NFTXInventoryStaking is PausableUpgradeable, UpgradeableBeacon, INFTXInventoryStaking {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant BASE = 10**18;\n    // Small locktime to prevent flash deposits.\n    uint256 public constant DEFAULT_LOCKTIME = 2;\n\n    INFTXVaultFactory public override nftxVaultFactory;\n    mapping(uint256 => address) internal UNUSED;\n\n    event XTokenCreated(uint256 vaultId, address baseToken, address xToken);\n    event Deposit(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, uint256 timelockUntil, address sender);\n    event Withdraw(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, address sender);\n\n    function __NFTXInventoryStaking_init(address _nftxVaultFactory) external virtual override initializer {\n        __Ownable_init();\n        nftxVaultFactory = INFTXVaultFactory(_nftxVaultFactory);\n        address xTokenImpl = address(new XTokenUpgradeable());\n        __UpgradeableBeacon__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == nftxVaultFactory.feeDistributor(), \"LPStaking: Not authorized\");\n        _;\n    }\n    \n    function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit XTokenCreated(vaultId, baseToken, xToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n        \n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!isContract(deployedXToken) || XTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        return true;\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) public virtual override {\n        onlyOwnerIfPaused(10);\n\n        (IERC20Upgradeable baseToken, XTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, DEFAULT_LOCKTIME);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit Deposit(vaultId, _amount, xTokensMinted, DEFAULT_LOCKTIME, msg.sender);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        require(nftxVaultFactory.excludedFromFees(msg.sender), \"Not a zap\");\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit Deposit(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) public virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit Withdraw(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n        require(address(xToken) != address(0), \"XToken not deployed\");\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0 \n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply() \n            : multiplier;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n    \n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        require(isContract(xToken), \"XToken not deployed\");\n        return xToken;\n    } \n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, XTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n\n    function _deployXToken(address vaultToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(vaultToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(vaultToken));\n        address deployedXToken = Create2.deploy(0, salt, type(Create2BeaconProxy).creationCode);\n        XTokenUpgradeable(deployedXToken).__XToken_init(vaultToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n",
        "CodeNames": [
            "NFTXEligibilityManager.sol",
            "NFTXInventoryStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [
                    "nftxVaultFactory",
                    "setNFTXVaultFactory",
                    "NFTXVaultFactory"
                ],
                "Type": " NFTXVaultFactoryUpgradeable implementation can be replaced in production breaking the system",
                "Description": "\nNFTXVaultFactory contract holds information regarding vaults, assets and permissions (vaults, _vaultsForAsset and excludedFromFees mappings).\nAs there is no mechanics present that transfers this information to another implementation, the switch of nftxVaultFactory to another address performed while in production will break the system.\n\n\nsetNFTXVaultFactory function allows an owner to reset nftxVaultFactory without restrictions in the following contracts:\n\nNFTXLPStaking\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L59\n\nNFTXInventoryStaking\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L51\n\nNFTXSimpleFeeDistributor\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L135\n\n",
                "Repair": "\nEither restrict the ability to change the factory implementation to pre-production stages or make nftxVaultFactory immutable by allowing changing it only once:\n\nNow:\nsolidity\nfunction setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n  require(newFactory != address(0));\n  nftxVaultFactory = INFTXVaultFactory(newFactory);\n}\n\n\nTo be:\nsolidity\nfunction setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n  require(nftxVaultFactory == address(0), \"nftxVaultFactory is immutable\");\n  nftxVaultFactory = INFTXVaultFactory(newFactory);\n}\n\n\nIf the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.\n\n0xKiwi (NFTX) confirmed and commented(https://github.com/code-423n4/2021-12-nftx-findings/issues/177#issuecomment-1003213811):\n  This is not a contract that is designed to be replaced, but upgraded. But it is a valid concern that these assistant contracts can have their factory be changed and rendered broken. (even if it were permissioned)<br\n Confirming.\n\n0xKiwi (NFTX) resolved(https://github.com/code-423n4/2021-12-nftx-findings/issues/177)\n\n\n\n*\n\n\n"
            }
        ]
    }
]