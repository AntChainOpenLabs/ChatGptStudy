[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"../../utils/access/AccessControl.sol\";\nimport \"../../interfaces/vault/IOracle.sol\";\nimport \"../../math/CastBytes32Bytes6.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\n\n/**\n * @title ChainlinkMultiOracle\n */\ncontract ChainlinkMultiOracle is IOracle, AccessControl {\n    using CastBytes32Bytes6 for bytes32;\n\n    uint8 public constant override decimals = 18;   // All prices are converted to 18 decimals\n\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);\n\n    struct Source {\n        address source;\n        uint8 decimals;\n        bool inverse;\n    }\n\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n\n    /**\n     * @notice Set or reset an oracle source and its inverse\n     */\n    function setSource(bytes6 base, bytes6 quote, address source) external auth {\n        _setSource(base, quote, source);\n    }\n\n    /**\n     * @notice Set or reset a number of oracle sources and their inverses\n     */\n    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) external auth {\n        require(\n            bases.length == quotes.length && \n            bases.length == sources_.length,\n            \"Mismatched inputs\"\n        );\n        for (uint256 i = 0; i < bases.length; i++) {\n            _setSource(bases[i], quotes[i], sources_[i]);\n        }\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount)\n        external view virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), quote.b6());\n        value = price * amount / 1e18;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.. Same as `peek` for this oracle.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount)\n        external virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), quote.b6());\n        value = price * amount / 1e18;\n    }\n\n    function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {\n        int rawPrice;\n        uint80 roundId;\n        uint80 answeredInRound;\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n        (roundId, rawPrice,, updateTime, answeredInRound) = AggregatorV3Interface(source.source).latestRoundData();\n        require(rawPrice > 0, \"Chainlink price <= 0\");\n        require(updateTime != 0, \"Incomplete round\");\n        require(answeredInRound >= roundId, \"Stale price\");\n        if (source.inverse == true) {\n            price = 10 ** (source.decimals + 18) / uint(rawPrice);\n        } else {\n            price = uint(rawPrice) * 10 ** (18 - source.decimals);\n        }  \n    }\n\n    function _setSource(bytes6 base, bytes6 quote, address source) internal {\n        uint8 decimals_ = AggregatorV3Interface(source).decimals();\n        require (decimals_ <= 18, \"Unsupported decimals\");\n        sources[base][quote] = Source({\n            source: source,\n            decimals: decimals_,\n            inverse: false\n        });\n        sources[quote][base] = Source({\n            source: source,\n            decimals: decimals_,\n            inverse: true\n        });\n        emit SourceSet(base, quote, source);\n        emit SourceSet(quote, base, source);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"../../utils/access/AccessControl.sol\";\nimport \"../../interfaces/vault/IOracle.sol\";\nimport \"../../math/CastBytes32Bytes6.sol\";\n\n\n/**\n * @title CompositeMultiOracle\n */\ncontract CompositeMultiOracle is IOracle, AccessControl {\n    using CastBytes32Bytes6 for bytes32;\n\n    uint8 public constant override decimals = 18;   // All prices are converted to 18 decimals\n\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);\n    event PathSet(bytes6 indexed baseId, bytes6 indexed quoteId, bytes6[] indexed path);\n\n    struct Source {\n        address source;\n        uint8 decimals;\n    }\n\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n    mapping(bytes6 => mapping(bytes6 => bytes6[])) public paths;\n\n    /**\n     * @notice Set or reset an oracle source\n     */\n    function setSource(bytes6 base, bytes6 quote, address source) external auth {\n        _setSource(base, quote, source);\n    }\n\n    /**\n     * @notice Set or reset a number of oracle sources\n     */\n    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) external auth {\n        require(\n            bases.length == quotes.length && \n            bases.length == sources_.length,\n            \"Mismatched inputs\"\n        );\n        for (uint256 i = 0; i < bases.length; i++) {\n            _setSource(bases[i], quotes[i], sources_[i]);\n        }\n    }\n\n    /**\n     * @notice Set or reset an price path\n     */\n    function setPath(bytes6 base, bytes6 quote, bytes6[] memory path) external auth {\n        _setPath(base, quote, path);\n    }\n\n    /**\n     * @notice Set or reset a number of price paths\n     */\n    function setPaths(bytes6[] memory bases, bytes6[] memory quotes, bytes6[][] memory paths_) external auth {\n        require(\n            bases.length == quotes.length && \n            bases.length == paths_.length,\n            \"Mismatched inputs\"\n        );\n        for (uint256 i = 0; i < bases.length; i++) {\n            _setPath(bases[i], quotes[i], paths_[i]);\n        }\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount)\n        external view virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price = 1e18;\n        bytes6 base_ = base.b6();\n        bytes6 quote_ = quote.b6();\n        bytes6[] memory path = paths[base_][quote_];\n        for (uint256 p = 0; p < path.length; p++) {\n            (price, updateTime) = _peek(base_, path[p], price, updateTime);\n            base_ = path[p];\n        }\n        (price, updateTime) = _peek(base_, quote_, price, updateTime);\n        value = price * amount / 1e18;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.. Same as `peek` for this oracle.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount)\n        external virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price = 1e18;\n        bytes6 base_ = base.b6();\n        bytes6 quote_ = quote.b6();\n        bytes6[] memory path = paths[base_][quote_];\n        for (uint256 p = 0; p < path.length; p++) {\n            (price, updateTime) = _get(base_, path[p], price, updateTime);\n            base_ = path[p];\n        }\n        (price, updateTime) = _get(base_, quote_, price, updateTime);\n        value = price * amount / 1e18;\n    }\n\n    function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n        private view returns (uint priceOut, uint updateTimeOut)\n    {\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n        (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);   // Get price for one unit\n        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       // Fixed point according to decimals\n        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time\n    }\n\n    function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n        private returns (uint priceOut, uint updateTimeOut)\n    {\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n        (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit\n        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       // Fixed point according to decimals\n        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time\n    }\n\n    function _setSource(bytes6 base, bytes6 quote, address source) internal {\n        uint8 decimals_ = IOracle(source).decimals();\n        require (decimals_ <= 18, \"Unsupported decimals\");\n        sources[base][quote] = Source({\n            source: source,\n            decimals: decimals_\n        });\n        emit SourceSet(base, quote, source);\n    }\n\n    function _setPath(bytes6 base, bytes6 quote, bytes6[] memory path) internal {\n        bytes6 base_ = base;\n        for (uint256 p = 0; p < path.length; p++) {\n            require (sources[base_][path[p]].source != address(0), \"Source not found\");\n            base_ = path[p];\n        }\n        paths[base][quote] = path;\n        emit PathSet(base, quote, path);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /**\n     * @notice Doesn't refresh the price, but returns the latest value available without doing any transactional operations:\n     * @return value in wei\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount) external view returns (uint256 value, uint256 updateTime);\n\n    /**\n     * @notice Does whatever work or queries will yield the most up-to-date price, and returns it.\n     * @return value in wei\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount) external returns (uint256 value, uint256 updateTime);\n\n    /**\n     * @notice Number of decimals in the amounts returned by the oracle.\n     */\n    function decimals() external view returns (uint8);\n}\n\n\n",
        "CodeNames": [
            "ChainlinkMultiOracle.sol",
            "CompositeMultiOracle.sol",
            "IOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n(priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10  source.decimals);   // Get price for one unit\n// @audit shouldn't this divide by 10  IOracle(source.source).decimals() instead?\npriceOut = priceIn * priceOut / (10  source.decimals);\n"
                ],
                "Type": "  CompositeMultiOracle  returns wrong decimals for prices?",
                "Description": "\nThe CompositeMultiOracle.peek/get functions seem to return wrong prices.\nIt's unclear what decimals source.decimals refers to in this case. Does it refer to source.source token decimals?\n\nIt chains the price arguments through _peek function calls and a single price is computed as:\n\nsolidity\n(priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10  source.decimals);   // Get price for one unit\n// @audit shouldn't this divide by 10  IOracle(source.source).decimals() instead?\npriceOut = priceIn * priceOut / (10  source.decimals);\n\n\nAssume all oracles use 18 decimals (oracle.decimals() returns 18) and source.decimals refers to the _token decimals_ of source.source.\n\nThen going from USDC - DAI - USDT (path = DAI]) starts with a price of 1e18 in peek:\n_peek(USDC, DAI, 1e18): Gets the price of 1e6 USDC (as USDC has 6 decimals) in DAI with 18 decimals precision (because all oracle precision is set to 18): priceOut = priceIn * 1e18 / 1e6 = 1e18 * 1e18 / 1e6 = 1e30\n_peek(DAI, USDT, 1e30): Gets the price of 1e18 DAI (DAI has 18 decimals) with 18 decimals precision: priceOut = priceIn * 1e18 / 1e18 = priceIn = 1e30\n\nIt then uses 1e30 as the price to go from USDC to USDT: value = price * amount / 1e18 = 1e30 * (1.0 USDC) / 1e18 = 1e30 * 1e6 / 1e18 = 1e18 = 1e12 * 1e6 = 1_000_000_000_000.0 USDT. Inflating the actual USDT amount.\n\nThe issue is that peek assumes that the final price is in 18 decimals in the value = price * amount / 1e18 division by 1e18.\nBut _peek (and _get) don't enforce this.\n\n",
                "Repair": "Recommend that _peek should scale the prices to 1e18 by doing:\n\nsolidity\n(priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10  source.decimals);\n// priceOut will have same decimals as priceIn if we divide by oracle decimals\npriceOut = priceIn * priceOut / (10  IOracle(source.source).decimals());\n\n\nIt does not need to divide by the source.source _token precision_ (source.decimals), but by the oracle precision (IOracle(source.source).decimals()).\n\nalcueca (Yield) acknowledged(https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-898819530):\n  It's confusing to deal with all these decimals, I should at least comment the code better, and try to make it easier to understand.\n\n  It's unclear what decimals source.decimals refers to in this case. Does it refer to source.source token decimals?\n\n CompositeMultiOracle takes IOracle contracts as sources, so source.decimals refers to the token decimals of the oracle, not of the data source one level below.\n\n  It does not need to divide by the source.source token precision (source.decimals), but by the oracle precision (IOracle(source.source).decimals()).\n\n The source.source token precision would be IChainlinkAggregatorV3(source.source()).decimals(), the source oracle precision is source.decimals(). CompositeMultiOracle cannot make an assumption on any fields present on source.source, and must  work only with the underlying source IOracles.\n\n I'm still not disputing this finding. I need to dig further to make sure the decimals are right when different IOracle sources have different decimals, and I've hardcoded a few 1e18 in there. Those are code smells.\n\nalcueca (Yield) patched(https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-900850053):\n  Sent me into a wild goose chase to support IOracle of multiple decimals as sources to CompositeMultiOracle, only to realize that we create all IOracles and we always create them with 18 decimals, converting from the underlying data source if needed.\n\n Ended up making CompositeMultiOracle require that underlying oracles have 18 decimals. Done(https://github.com/yieldprotocol/vault-v2/commit/621b680f893436f88f7668164b2942dbb94d1ca2).\n\nalcueca (Yield) further patched(https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-900850053):\n  Further refactored all oracles so that decimals are handled properly(https://github.com/yieldprotocol/vault-v2/pull/276), and work on taking an amount of base as input, and returning an amount of quote as output. Our oracles don't have decimals themselves anymore as a state variable, since the return values are in the decimals of quote. This means that CompositeMultiOracle is agnostic with regards to decimals, and doesn't even need to know about them.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"./ERC20Permit.sol\";\nimport \"../access/AccessControl.sol\";\nimport \"../RevertMsgExtractor.sol\";\n\n\nlibrary CastU256U32 {\n    /// @dev Safely cast an uint256 to an uint32\n    function u32(uint256 x) internal pure returns (uint32 y) {\n        require (x <= type(uint32).max, \"Cast overflow\");\n        y = uint32(x);\n    }\n}\n\nlibrary CastU256U128 {\n    /// @dev Safely cast an uint256 to an uint128\n    function u128(uint256 x) internal pure returns (uint128 y) {\n        require (x <= type(uint128).max, \"Cast overflow\");\n        y = uint128(x);\n    }\n}\n\n/// @dev A token inheriting from ERC20Rewards will reward token holders with a rewards token.\n/// The rewarded amount will be a fixed wei per second, distributed proportionally to token holders\n/// by the size of their holdings.\ncontract ERC20Rewards is AccessControl, ERC20Permit {\n    using CastU256U32 for uint256;\n    using CastU256U128 for uint256;\n\n    event RewardsSet(IERC20 rewardsToken, uint32 start, uint32 end, uint256 rate);\n    event RewardsPerTokenUpdated(uint256 accumulated);\n    event UserRewardsUpdated(address user, uint256 userRewards, uint256 paidRewardPerToken);\n    event Claimed(address receiver, uint256 claimed);\n\n    struct RewardsPeriod {\n        uint32 start;                                   // Start time for the current rewardsToken schedule\n        uint32 end;                                     // End time for the current rewardsToken schedule\n    }\n\n    struct RewardsPerToken {\n        uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n        uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n        uint96 rate;                                    // Wei rewarded per second among all token holders\n    }\n\n    struct UserRewards {\n        uint128 accumulated;                            // Accumulated rewards for the user until the checkpoint\n        uint128 checkpoint;                             // RewardsPerToken the last time the user rewards were updated\n    }\n\n    IERC20 public rewardsToken;                         // Token used as rewards\n    RewardsPeriod public rewardsPeriod;                 // Period in which rewards are accumulated by users\n\n    RewardsPerToken public rewardsPerToken;             // Accumulator to track rewards per token               \n    mapping (address => UserRewards) public rewards;    // Rewards accumulated by users\n    \n    constructor(string memory name, string memory symbol, uint8 decimals)\n        ERC20Permit(name, symbol, decimals)\n    { }\n\n    /// @dev Return the earliest of two timestamps\n    function earliest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x < y) ? x : y;\n    }\n\n    /// @dev Return the latest of two timestamps\n    function latest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x > y) ? x : y;\n    }\n\n    /// @dev Set a rewards schedule\n    function setRewards(IERC20 rewardsToken_, uint32 start, uint32 end, uint96 rate)\n        public\n        auth\n    {\n        // A new rewards program can be set if one is not running\n        require(\n            block.timestamp.u32() < rewardsPeriod.start || block.timestamp.u32() > rewardsPeriod.end,\n            \"Ongoing rewards\"\n        );\n\n        // If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token\n        rewardsToken = rewardsToken_;\n\n        rewardsPeriod.start = start;\n        rewardsPeriod.end = end;\n\n        // If setting up a new rewards program, the rewardsPerToken.accumulated is used and built upon\n        // New rewards start accumulating from the new rewards program start\n        // Any unaccounted rewards from last program can still be added to the user rewards\n        // Any unclaimed rewards can still be claimed\n        rewardsPerToken.lastUpdated = start;\n        rewardsPerToken.rate = rate;\n\n        emit RewardsSet(rewardsToken, start, end, rate);\n    }\n\n    /// @dev Update the rewards per token accumulator.\n    /// @notice Needs to be called on each liquidity event\n    function _updateRewardsPerToken() internal returns (uint128) {\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        RewardsPeriod memory rewardsPeriod_ = rewardsPeriod;\n\n        // We skip the calculations if we can\n        if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod_.start) return 0;\n        if (rewardsPerToken_.lastUpdated >= rewardsPeriod_.end) return rewardsPerToken_.accumulated;\n\n        // Find out the unaccounted period\n        uint32 end = earliest(block.timestamp.u32(), rewardsPeriod_.end);\n        uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated; // Cast to uint256 to avoid overflows later on\n\n        // Calculate and update the new value of the accumulator. timeSinceLastUpdated casts it into uint256, which is desired.\n        rewardsPerToken_.accumulated = (rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply).u128(); // The rewards per token are scaled up for precision\n        rewardsPerToken_.lastUpdated = end;\n        rewardsPerToken = rewardsPerToken_;\n        \n        emit RewardsPerTokenUpdated(rewardsPerToken_.accumulated);\n\n        return rewardsPerToken_.accumulated;\n    }\n\n    /// @dev Accumulate rewards for an user.\n    /// @notice Needs to be called on each liquidity event, or when user balances change.\n    function _updateUserRewards(address user) internal returns (uint128) {\n        UserRewards memory userRewards_ = rewards[user];\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        \n        // Calculate and update the new value user reserves. _balanceOf[user] casts it into uint256, which is desired.\n        userRewards_.accumulated = (userRewards_.accumulated + _balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint) / 1e18).u128(); // We must scale down the rewards by the precision factor\n        userRewards_.checkpoint = rewardsPerToken_.accumulated;\n        rewards[user] = userRewards_;\n        emit UserRewardsUpdated(user, userRewards_.accumulated, userRewards_.checkpoint);\n\n        return userRewards_.accumulated;\n    }\n\n    /// @dev Mint tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _mint(address dst, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(dst);\n        return super._mint(dst, wad);\n    }\n\n    /// @dev Burn tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _burn(address src, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        return super._burn(src, wad);\n    }\n\n    /// @dev Transfer tokens, after updating rewards for source and destination.\n    function _transfer(address src, address dst, uint wad) internal virtual override returns (bool) {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        _updateUserRewards(dst);\n        return super._transfer(src, dst, wad);\n    }\n\n    /// @dev Claim all rewards from caller into a given address\n    function claim(address to)\n        external\n        returns (uint256 claiming)\n    {\n        _updateRewardsPerToken();\n        claiming = _updateUserRewards(msg.sender);\n        rewards[msg.sender].accumulated = 0; // A Claimed event implies the rewards were set to zero\n        rewardsToken.transfer(to, claiming);\n        emit Claimed(to, claiming);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"./utils/token/ERC20Permit.sol\";\nimport \"./utils/token/SafeERC20Namer.sol\";\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./constants/Constants.sol\";\n\n\ncontract FYToken is IFYToken, IERC3156FlashLender, AccessControl(), ERC20Permit, Constants {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event SeriesMatured(uint256 chiAtMaturity);\n    event Redeemed(address indexed from, address indexed to, uint256 amount, uint256 redeemed);\n    event OracleSet(address indexed oracle);\n\n    uint256 constant CHI_NOT_SET = type(uint256).max;\n\n    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IOracle public oracle;                                      // Oracle for the savings rate.\n    IJoin public immutable join;                                // Source of redemption funds.\n    address public immutable override underlying;\n    bytes6 public immutable underlyingId;                             // Needed to access the oracle\n    uint256 public immutable override maturity;\n    uint256 public chiAtMaturity = CHI_NOT_SET;           // Spot price (exchange rate) between the base and an interest accruing token at maturity \n\n    constructor(\n        bytes6 underlyingId_,\n        IOracle oracle_, // Underlying vs its interest-bearing version\n        IJoin join_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    ) ERC20Permit(name, symbol, SafeERC20Namer.tokenDecimals(address(IJoin(join_).asset()))) { // The join asset is this fyToken's underlying, from which we inherit the decimals\n        uint256 now_ = block.timestamp;\n        require(\n            maturity_ > now_ &&\n            maturity_ < now_ + MAX_TIME_TO_MATURITY &&\n            maturity_ < type(uint32).max,\n            \"Invalid maturity\"\n        );\n\n        underlyingId = underlyingId_;\n        join = join_;\n        maturity = maturity_;\n        underlying = address(IJoin(join_).asset());\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    modifier afterMaturity() {\n        require(\n            uint32(block.timestamp) >= maturity,\n            \"Only after maturity\"\n        );\n        _;\n    }\n\n    modifier beforeMaturity() {\n        require(\n            uint32(block.timestamp) < maturity,\n            \"Only before maturity\"\n        );\n        _;\n    }\n\n    /// @dev Set the oracle parameter\n    function setOracle(IOracle oracle_)\n        external\n        auth    \n    {\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    /// If called more than once, it will revert.\n    function mature()\n        external override\n        afterMaturity\n    {\n        require (chiAtMaturity == CHI_NOT_SET, \"Already matured\");\n        _mature();\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    function _mature() \n        private\n        returns (uint256 _chiAtMaturity)\n    {\n        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);\n        chiAtMaturity = _chiAtMaturity;\n        emit SeriesMatured(_chiAtMaturity);\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    function accrual()\n        external\n        afterMaturity\n        returns (uint256)\n    {\n        return _accrual();\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual()\n        private\n        returns (uint256 accrual_)\n    {\n        if (chiAtMaturity == CHI_NOT_SET) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\n            _mature();\n        } else {\n            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);\n            accrual_ = chi.wdiv(chiAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Burn the fyToken after maturity for an amount that increases according to `chi`\n    function redeem(address to, uint256 amount)\n        external override\n        afterMaturity\n        returns (uint256 redeemed)\n    {\n        _burn(msg.sender, amount);\n        redeemed = amount.wmul(_accrual());\n        join.exit(to, redeemed.u128());\n        \n        emit Redeemed(msg.sender, to, amount, redeemed);\n    }\n\n    /// @dev Mint fyTokens.\n    function mint(address to, uint256 amount)\n        external override\n        beforeMaturity\n        auth\n    {\n        _mint(to, amount);\n    }\n\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them. \n    function burn(address from, uint256 amount)\n        external override\n        auth\n    {\n        _burn(from, amount);\n    }\n\n    /// @dev Burn fyTokens. \n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\n    function _burn(address from, uint256 amount)\n        internal override\n        returns (bool)\n    {\n        // First use any tokens locked in this contract\n        uint256 available = _balanceOf[address(this)];\n        if (available >= amount) {\n            return super._burn(address(this), amount);\n        } else {\n            if (available > 0 ) super._burn(address(this), available);\n            unchecked { _decreaseAllowance(from, amount - available); }\n            unchecked { return super._burn(from, amount - available); }\n        }\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be a FYDai.\n     * param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        return 0;\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        beforeMaturity\n        returns(bool)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n        _burn(address(receiver), amount);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC20Rewards.sol",
            "FYToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "claim",
                    "_updateUserRewards",
                    "ERC",
                    "_updateRewardsPerToken",
                    "setRewards",
                    "totalSupply == 0",
                    "_mint",
                    "totalSupply"
                ],
                "Type": "  ERC20Rewards  returns wrong rewards if no tokens initially exist",
                "Description": "\nThe ERC20Rewards._updateRewardsPerToken function exits without updating rewardsPerToken_.lastUpdated if totalSupply is zero, i.e., if there are no tokens initially.\n\nThis leads to an error if there is an active rewards period but no tokens have been minted yet.\n\nExample: rewardsPeriod.start: 1 month ago, rewardsPeriod.end: in 1 month, totalSupply == 0.\n\nThe first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case).\n_mint is called, calls _updateRewardsPerToken which short-circuits. rewardsPerToken.lastUpdated is still set to rewardsPeriod.start from the constructor. Then _updateUserRewards is called and does not currently yield any rewards. (because both balance and the index diff are zero). User has now minted the tokens, totalSupply increases and user balance is set.\nUser performs a claim: _updateRewardsPerToken is called and timeSinceLastUpdated = end rewardsPerToken_.lastUpdated = block.timestamp rewardsPeriod.start = 1 month. Contract \"issues\" rewards for the past month. The first mintee receives all of it.\n\nThe first mintee receives all pending rewards when they should not receive any past rewards.\nThis can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet.\nNote that setRewards also allows setting a date in the past which would also be fatal in this case.\n\n",
                "Repair": "Recommend that the rewardsPerToken_.lastUpdated field must always be updated in _updateRewardsPerToken to the current time (or end) even if _totalSupply == 0. Don't return early.\n\nalcueca (Yield) confirmed(https://github.com/code-423n4/2021-08-yield-findings/issues/28#issuecomment-898824250):\n  You are right, that's a great finding. For the record, I think that this is what this line in Unipool.sol(https://github.com/k06a/Unipool/blob/bb1843b454bbb10b3b1ccf48edf5e72a80b2acfe/contracts/Unipool.sol#L70) does:\nsolidity\nfunction rewardPerToken() public view returns (uint256) {\n  if (totalSupply() == 0) {\n    return rewardPerTokenStored;\n  }\n\n\n I'll apply the mitigation step suggested, with a conditional to not do the rewardsPerToken_.accumulated math that would revert.\n\n Now I know the feeling of the devs that fork a known project and leave a pesky conditional out, thanks again :D\n\n\nalcueca (Yield) patched(https://github.com/code-423n4/2021-08-yield-findings/issues/28#issuecomment-899370816):\n  Fix(https://github.com/yieldprotocol/yield-utils-v2/commit/d2ad343f40d375baf492131d9b1c7e288b5825d6)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.8.0;\n\n\nlibrary PoolDataTypes {\n  enum Operation {\n    ROUTE, // 0\n    TRANSFER_TO_POOL, // 1\n    FORWARD_PERMIT, // 2\n    FORWARD_DAI_PERMIT, // 3\n    JOIN_ETHER, // 4\n    EXIT_ETHER // 5\n  }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"./ERC20Permit.sol\";\nimport \"../access/AccessControl.sol\";\nimport \"../RevertMsgExtractor.sol\";\n\n\nlibrary CastU256U32 {\n    /// @dev Safely cast an uint256 to an uint32\n    function u32(uint256 x) internal pure returns (uint32 y) {\n        require (x <= type(uint32).max, \"Cast overflow\");\n        y = uint32(x);\n    }\n}\n\nlibrary CastU256U128 {\n    /// @dev Safely cast an uint256 to an uint128\n    function u128(uint256 x) internal pure returns (uint128 y) {\n        require (x <= type(uint128).max, \"Cast overflow\");\n        y = uint128(x);\n    }\n}\n\n/// @dev A token inheriting from ERC20Rewards will reward token holders with a rewards token.\n/// The rewarded amount will be a fixed wei per second, distributed proportionally to token holders\n/// by the size of their holdings.\ncontract ERC20Rewards is AccessControl, ERC20Permit {\n    using CastU256U32 for uint256;\n    using CastU256U128 for uint256;\n\n    event RewardsSet(IERC20 rewardsToken, uint32 start, uint32 end, uint256 rate);\n    event RewardsPerTokenUpdated(uint256 accumulated);\n    event UserRewardsUpdated(address user, uint256 userRewards, uint256 paidRewardPerToken);\n    event Claimed(address receiver, uint256 claimed);\n\n    struct RewardsPeriod {\n        uint32 start;                                   // Start time for the current rewardsToken schedule\n        uint32 end;                                     // End time for the current rewardsToken schedule\n    }\n\n    struct RewardsPerToken {\n        uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n        uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n        uint96 rate;                                    // Wei rewarded per second among all token holders\n    }\n\n    struct UserRewards {\n        uint128 accumulated;                            // Accumulated rewards for the user until the checkpoint\n        uint128 checkpoint;                             // RewardsPerToken the last time the user rewards were updated\n    }\n\n    IERC20 public rewardsToken;                         // Token used as rewards\n    RewardsPeriod public rewardsPeriod;                 // Period in which rewards are accumulated by users\n\n    RewardsPerToken public rewardsPerToken;             // Accumulator to track rewards per token               \n    mapping (address => UserRewards) public rewards;    // Rewards accumulated by users\n    \n    constructor(string memory name, string memory symbol, uint8 decimals)\n        ERC20Permit(name, symbol, decimals)\n    { }\n\n    /// @dev Return the earliest of two timestamps\n    function earliest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x < y) ? x : y;\n    }\n\n    /// @dev Return the latest of two timestamps\n    function latest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x > y) ? x : y;\n    }\n\n    /// @dev Set a rewards schedule\n    function setRewards(IERC20 rewardsToken_, uint32 start, uint32 end, uint96 rate)\n        public\n        auth\n    {\n        // A new rewards program can be set if one is not running\n        require(\n            block.timestamp.u32() < rewardsPeriod.start || block.timestamp.u32() > rewardsPeriod.end,\n            \"Ongoing rewards\"\n        );\n\n        // If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token\n        rewardsToken = rewardsToken_;\n\n        rewardsPeriod.start = start;\n        rewardsPeriod.end = end;\n\n        // If setting up a new rewards program, the rewardsPerToken.accumulated is used and built upon\n        // New rewards start accumulating from the new rewards program start\n        // Any unaccounted rewards from last program can still be added to the user rewards\n        // Any unclaimed rewards can still be claimed\n        rewardsPerToken.lastUpdated = start;\n        rewardsPerToken.rate = rate;\n\n        emit RewardsSet(rewardsToken, start, end, rate);\n    }\n\n    /// @dev Update the rewards per token accumulator.\n    /// @notice Needs to be called on each liquidity event\n    function _updateRewardsPerToken() internal returns (uint128) {\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        RewardsPeriod memory rewardsPeriod_ = rewardsPeriod;\n\n        // We skip the calculations if we can\n        if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod_.start) return 0;\n        if (rewardsPerToken_.lastUpdated >= rewardsPeriod_.end) return rewardsPerToken_.accumulated;\n\n        // Find out the unaccounted period\n        uint32 end = earliest(block.timestamp.u32(), rewardsPeriod_.end);\n        uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated; // Cast to uint256 to avoid overflows later on\n\n        // Calculate and update the new value of the accumulator. timeSinceLastUpdated casts it into uint256, which is desired.\n        rewardsPerToken_.accumulated = (rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply).u128(); // The rewards per token are scaled up for precision\n        rewardsPerToken_.lastUpdated = end;\n        rewardsPerToken = rewardsPerToken_;\n        \n        emit RewardsPerTokenUpdated(rewardsPerToken_.accumulated);\n\n        return rewardsPerToken_.accumulated;\n    }\n\n    /// @dev Accumulate rewards for an user.\n    /// @notice Needs to be called on each liquidity event, or when user balances change.\n    function _updateUserRewards(address user) internal returns (uint128) {\n        UserRewards memory userRewards_ = rewards[user];\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        \n        // Calculate and update the new value user reserves. _balanceOf[user] casts it into uint256, which is desired.\n        userRewards_.accumulated = (userRewards_.accumulated + _balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint) / 1e18).u128(); // We must scale down the rewards by the precision factor\n        userRewards_.checkpoint = rewardsPerToken_.accumulated;\n        rewards[user] = userRewards_;\n        emit UserRewardsUpdated(user, userRewards_.accumulated, userRewards_.checkpoint);\n\n        return userRewards_.accumulated;\n    }\n\n    /// @dev Mint tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _mint(address dst, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(dst);\n        return super._mint(dst, wad);\n    }\n\n    /// @dev Burn tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _burn(address src, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        return super._burn(src, wad);\n    }\n\n    /// @dev Transfer tokens, after updating rewards for source and destination.\n    function _transfer(address src, address dst, uint wad) internal virtual override returns (bool) {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        _updateUserRewards(dst);\n        return super._transfer(src, dst, wad);\n    }\n\n    /// @dev Claim all rewards from caller into a given address\n    function claim(address to)\n        external\n        returns (uint256 claiming)\n    {\n        _updateRewardsPerToken();\n        claiming = _updateUserRewards(msg.sender);\n        rewards[msg.sender].accumulated = 0; // A Claimed event implies the rewards were set to zero\n        rewardsToken.transfer(to, claiming);\n        emit Claimed(to, claiming);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"./utils/token/ERC20Permit.sol\";\nimport \"./utils/token/SafeERC20Namer.sol\";\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./constants/Constants.sol\";\n\n\ncontract FYToken is IFYToken, IERC3156FlashLender, AccessControl(), ERC20Permit, Constants {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event SeriesMatured(uint256 chiAtMaturity);\n    event Redeemed(address indexed from, address indexed to, uint256 amount, uint256 redeemed);\n    event OracleSet(address indexed oracle);\n\n    uint256 constant CHI_NOT_SET = type(uint256).max;\n\n    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IOracle public oracle;                                      // Oracle for the savings rate.\n    IJoin public immutable join;                                // Source of redemption funds.\n    address public immutable override underlying;\n    bytes6 public immutable underlyingId;                             // Needed to access the oracle\n    uint256 public immutable override maturity;\n    uint256 public chiAtMaturity = CHI_NOT_SET;           // Spot price (exchange rate) between the base and an interest accruing token at maturity \n\n    constructor(\n        bytes6 underlyingId_,\n        IOracle oracle_, // Underlying vs its interest-bearing version\n        IJoin join_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    ) ERC20Permit(name, symbol, SafeERC20Namer.tokenDecimals(address(IJoin(join_).asset()))) { // The join asset is this fyToken's underlying, from which we inherit the decimals\n        uint256 now_ = block.timestamp;\n        require(\n            maturity_ > now_ &&\n            maturity_ < now_ + MAX_TIME_TO_MATURITY &&\n            maturity_ < type(uint32).max,\n            \"Invalid maturity\"\n        );\n\n        underlyingId = underlyingId_;\n        join = join_;\n        maturity = maturity_;\n        underlying = address(IJoin(join_).asset());\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    modifier afterMaturity() {\n        require(\n            uint32(block.timestamp) >= maturity,\n            \"Only after maturity\"\n        );\n        _;\n    }\n\n    modifier beforeMaturity() {\n        require(\n            uint32(block.timestamp) < maturity,\n            \"Only before maturity\"\n        );\n        _;\n    }\n\n    /// @dev Set the oracle parameter\n    function setOracle(IOracle oracle_)\n        external\n        auth    \n    {\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    /// If called more than once, it will revert.\n    function mature()\n        external override\n        afterMaturity\n    {\n        require (chiAtMaturity == CHI_NOT_SET, \"Already matured\");\n        _mature();\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    function _mature() \n        private\n        returns (uint256 _chiAtMaturity)\n    {\n        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);\n        chiAtMaturity = _chiAtMaturity;\n        emit SeriesMatured(_chiAtMaturity);\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    function accrual()\n        external\n        afterMaturity\n        returns (uint256)\n    {\n        return _accrual();\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual()\n        private\n        returns (uint256 accrual_)\n    {\n        if (chiAtMaturity == CHI_NOT_SET) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\n            _mature();\n        } else {\n            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);\n            accrual_ = chi.wdiv(chiAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Burn the fyToken after maturity for an amount that increases according to `chi`\n    function redeem(address to, uint256 amount)\n        external override\n        afterMaturity\n        returns (uint256 redeemed)\n    {\n        _burn(msg.sender, amount);\n        redeemed = amount.wmul(_accrual());\n        join.exit(to, redeemed.u128());\n        \n        emit Redeemed(msg.sender, to, amount, redeemed);\n    }\n\n    /// @dev Mint fyTokens.\n    function mint(address to, uint256 amount)\n        external override\n        beforeMaturity\n        auth\n    {\n        _mint(to, amount);\n    }\n\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them. \n    function burn(address from, uint256 amount)\n        external override\n        auth\n    {\n        _burn(from, amount);\n    }\n\n    /// @dev Burn fyTokens. \n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\n    function _burn(address from, uint256 amount)\n        internal override\n        returns (bool)\n    {\n        // First use any tokens locked in this contract\n        uint256 available = _balanceOf[address(this)];\n        if (available >= amount) {\n            return super._burn(address(this), amount);\n        } else {\n            if (available > 0 ) super._burn(address(this), available);\n            unchecked { _decreaseAllowance(from, amount - available); }\n            unchecked { return super._burn(from, amount - available); }\n        }\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be a FYDai.\n     * param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        return 0;\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        beforeMaturity\n        returns(bool)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n        _burn(address(receiver), amount);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolDataTypes.sol",
            "ERC20Rewards.sol",
            "FYToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "setRewards",
                    "DAI",
                    "claim",
                    "ERC"
                ],
                "Type": "  ERC20Rewards  breaks when setting a different token",
                "Description": "\nThe setRewards function allows setting a different token.\nHolders of a previous reward period cannot all be paid out and will receive their old reward amount in the new token.\n\nThis leads to issues when the new token is more (less) valuable, or uses different decimals.\n\nExample: Assume the first reward period paid out in DAI which has 18 decimals. Someone would have received 1.0 DAI = 1e18 DAI if they called claim now. Instead, they wait until the new period starts with USDC (using only 6 decimals) and can claim their 1e18 reward amount in USDC which would equal 1e12 USDC, one trillion USD.\n\nChanging the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.\n\n",
                "Repair": "Recommend disallowing changing the reward token, or clearing user's pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.\n\nalcueca (Yield) confirmed(https://github.com/code-423n4/2021-08-yield-findings/issues/29#issuecomment-898821371):\n  Maybe I should have used stronger language:\n // If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token\n\n The issue is known, but you are right in pointing it out. There are few situations in which changing the rewards token would make sense (such as replacing a faulty rewards token by a fixed one). I think it would be best to just disallow changing the token.\n\nalcueca (Yield) patched(https://github.com/code-423n4/2021-08-yield-findings/issues/29#issuecomment-899366677):\n  Fix(https://github.com/yieldprotocol/yield-utils-v2/commit/6df51f81a36e8f9b26b4946ac1aeda90eff6ffda)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastI128U128 for int128;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (seriesId != bytes12(0), \"Series id is zero\");\n        require (ilkId != bytes12(0), \"Ilk id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (vault.seriesId != bytes6(0), \"Series id is zero\");\n        require (vault.ilkId != bytes6(0), \"Ilk id is zero\");\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Convert a debt amount for a series from base to fyToken terms.\n    /// @notice Think about rounding if using, since we are dividing.\n    function debtFromBase(bytes6 seriesId, uint128 base)\n        external\n        returns (uint128 art)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            art = uint256(base).wdiv(_accrual(seriesId, series_)).u128();\n        } else {\n            art = base;\n        }\n    }\n\n    /// @dev Convert a debt amount for a series from fyToken to base terms\n    function debtToBase(bytes6 seriesId, uint128 art)\n        external\n        returns (uint128 base)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            base = uint256(art).wmul(_accrual(seriesId, series_)).u128();\n        } else {\n            base = art;\n        }\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        require (from != to, \"Identical vaults\");\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give an uncollateralized vault to another user.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n        _give(vaultId, receiver);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId)\n        external\n        returns (int256)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        external\n    {\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        DataTypes.Series memory series_ = series[seriesId];\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        external\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"./ERC20Permit.sol\";\nimport \"../access/AccessControl.sol\";\nimport \"../RevertMsgExtractor.sol\";\n\n\nlibrary CastU256U32 {\n    /// @dev Safely cast an uint256 to an uint32\n    function u32(uint256 x) internal pure returns (uint32 y) {\n        require (x <= type(uint32).max, \"Cast overflow\");\n        y = uint32(x);\n    }\n}\n\nlibrary CastU256U128 {\n    /// @dev Safely cast an uint256 to an uint128\n    function u128(uint256 x) internal pure returns (uint128 y) {\n        require (x <= type(uint128).max, \"Cast overflow\");\n        y = uint128(x);\n    }\n}\n\n/// @dev A token inheriting from ERC20Rewards will reward token holders with a rewards token.\n/// The rewarded amount will be a fixed wei per second, distributed proportionally to token holders\n/// by the size of their holdings.\ncontract ERC20Rewards is AccessControl, ERC20Permit {\n    using CastU256U32 for uint256;\n    using CastU256U128 for uint256;\n\n    event RewardsSet(IERC20 rewardsToken, uint32 start, uint32 end, uint256 rate);\n    event RewardsPerTokenUpdated(uint256 accumulated);\n    event UserRewardsUpdated(address user, uint256 userRewards, uint256 paidRewardPerToken);\n    event Claimed(address receiver, uint256 claimed);\n\n    struct RewardsPeriod {\n        uint32 start;                                   // Start time for the current rewardsToken schedule\n        uint32 end;                                     // End time for the current rewardsToken schedule\n    }\n\n    struct RewardsPerToken {\n        uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n        uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n        uint96 rate;                                    // Wei rewarded per second among all token holders\n    }\n\n    struct UserRewards {\n        uint128 accumulated;                            // Accumulated rewards for the user until the checkpoint\n        uint128 checkpoint;                             // RewardsPerToken the last time the user rewards were updated\n    }\n\n    IERC20 public rewardsToken;                         // Token used as rewards\n    RewardsPeriod public rewardsPeriod;                 // Period in which rewards are accumulated by users\n\n    RewardsPerToken public rewardsPerToken;             // Accumulator to track rewards per token               \n    mapping (address => UserRewards) public rewards;    // Rewards accumulated by users\n    \n    constructor(string memory name, string memory symbol, uint8 decimals)\n        ERC20Permit(name, symbol, decimals)\n    { }\n\n    /// @dev Return the earliest of two timestamps\n    function earliest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x < y) ? x : y;\n    }\n\n    /// @dev Return the latest of two timestamps\n    function latest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x > y) ? x : y;\n    }\n\n    /// @dev Set a rewards schedule\n    function setRewards(IERC20 rewardsToken_, uint32 start, uint32 end, uint96 rate)\n        public\n        auth\n    {\n        // A new rewards program can be set if one is not running\n        require(\n            block.timestamp.u32() < rewardsPeriod.start || block.timestamp.u32() > rewardsPeriod.end,\n            \"Ongoing rewards\"\n        );\n\n        // If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token\n        rewardsToken = rewardsToken_;\n\n        rewardsPeriod.start = start;\n        rewardsPeriod.end = end;\n\n        // If setting up a new rewards program, the rewardsPerToken.accumulated is used and built upon\n        // New rewards start accumulating from the new rewards program start\n        // Any unaccounted rewards from last program can still be added to the user rewards\n        // Any unclaimed rewards can still be claimed\n        rewardsPerToken.lastUpdated = start;\n        rewardsPerToken.rate = rate;\n\n        emit RewardsSet(rewardsToken, start, end, rate);\n    }\n\n    /// @dev Update the rewards per token accumulator.\n    /// @notice Needs to be called on each liquidity event\n    function _updateRewardsPerToken() internal returns (uint128) {\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        RewardsPeriod memory rewardsPeriod_ = rewardsPeriod;\n\n        // We skip the calculations if we can\n        if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod_.start) return 0;\n        if (rewardsPerToken_.lastUpdated >= rewardsPeriod_.end) return rewardsPerToken_.accumulated;\n\n        // Find out the unaccounted period\n        uint32 end = earliest(block.timestamp.u32(), rewardsPeriod_.end);\n        uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated; // Cast to uint256 to avoid overflows later on\n\n        // Calculate and update the new value of the accumulator. timeSinceLastUpdated casts it into uint256, which is desired.\n        rewardsPerToken_.accumulated = (rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply).u128(); // The rewards per token are scaled up for precision\n        rewardsPerToken_.lastUpdated = end;\n        rewardsPerToken = rewardsPerToken_;\n        \n        emit RewardsPerTokenUpdated(rewardsPerToken_.accumulated);\n\n        return rewardsPerToken_.accumulated;\n    }\n\n    /// @dev Accumulate rewards for an user.\n    /// @notice Needs to be called on each liquidity event, or when user balances change.\n    function _updateUserRewards(address user) internal returns (uint128) {\n        UserRewards memory userRewards_ = rewards[user];\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        \n        // Calculate and update the new value user reserves. _balanceOf[user] casts it into uint256, which is desired.\n        userRewards_.accumulated = (userRewards_.accumulated + _balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint) / 1e18).u128(); // We must scale down the rewards by the precision factor\n        userRewards_.checkpoint = rewardsPerToken_.accumulated;\n        rewards[user] = userRewards_;\n        emit UserRewardsUpdated(user, userRewards_.accumulated, userRewards_.checkpoint);\n\n        return userRewards_.accumulated;\n    }\n\n    /// @dev Mint tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _mint(address dst, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(dst);\n        return super._mint(dst, wad);\n    }\n\n    /// @dev Burn tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _burn(address src, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        return super._burn(src, wad);\n    }\n\n    /// @dev Transfer tokens, after updating rewards for source and destination.\n    function _transfer(address src, address dst, uint wad) internal virtual override returns (bool) {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        _updateUserRewards(dst);\n        return super._transfer(src, dst, wad);\n    }\n\n    /// @dev Claim all rewards from caller into a given address\n    function claim(address to)\n        external\n        returns (uint256 claiming)\n    {\n        _updateRewardsPerToken();\n        claiming = _updateUserRewards(msg.sender);\n        rewards[msg.sender].accumulated = 0; // A Claimed event implies the rewards were set to zero\n        rewardsToken.transfer(to, claiming);\n        emit Claimed(to, claiming);\n    }\n}\n\n\n",
        "CodeNames": [
            "Cauldron.sol",
            "ERC20Rewards.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply\n",
                    "//solidity\nstruct RewardsPerToken {\n  uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n  uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n  uint96 rate;                                    // Wei rewarded per second among all token holders\n}\n"
                ],
                "Type": " Rewards accumulated can stay constant and often not increment",
                "Description": "\nrewardsPerToken_.accumulated can stay constant while rewardsPerToken_.lastUpdated is continually updated, leading to no actual rewards being distributed. I.e. No rewards accumulate.\n\nLine 115, rewardsPerToken_.accumulated could stay constant if there are very quick update intervals, a relatively low rewardsPerToken_.rate and a decent supply of the ERC20 token.\n\nI.e. imagine the token supply is 1 billion tokens (quite a common amount, note even if a supply of only say 1 million tokens this is still relevant). i.e. 1e27 wei.\n\nLine 115 has\nsolidity\n1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply\n\n\ntimeSinceLastUpdated can be crafted to be arbitrarily small by simply transferring or burning tokens, so lets exclude this term (it could be 10 seconds etc). Imagine total supply is 1e27 as mentioned.\n\nTherefore, 1e18 * rewardsPerToken_.rate / 1e27, which shows that if the rewardsPerToken_.rate is < 1e9, something which is very likely, then the accumulated amount won't increment, as there are no decimals in solidity and this line of code will evaluate to adding zero. While this is rounded down to zero, critically,  rewardsPerToken_.lastUpdated = end; is updated.\n\nThe reason I have labelled this as a high risk is the express purpose of this contract is to reward users with tokens, yet a user could potentially quite easily exploit this line to ensure no one ever gets rewards and the accumulated amount never increases.\n\nGiven a fairly large token supply, and a relatively low emissions rate is set, that satisfies the above equation, for the entire duration of the rewards period, the user simply sends tokens back and forth every couple seconds (gas limitations, but layer 2), to keep the delta timeSinceLastUpdated close to 1.\n\nThis way the accumulated amount will never tick up, but time keeps being counted.\n\nFurthermore, I would say this is high risk as this wouldn't even need an attacker. Given the transfer function is likely often being called by users, timeSinceLastUpdated will naturally be very low anyways.\n\nEven if not so extreme as the above case, Alberto points out that \"rounding can eat into the rewards\" which is likely to be prevalent in the current scenario and make a big impact over time on the targeted vs actual distribution.\n\nAgain, this problem is more likely to occur in naturally liquid tokens where lots of transfer, mint or burn events occur.\n\nAs suggested by Alberto, the simplest it to probably not update the rewardsPerToken_.lastUpdated field if rewardsPerToken_.accumulated does not change. Although this change should be closely scrutinized to see it doesn't introduce bugs elsewhere.\n\nalcueca (Yield) acknowledged and disagreed with severity(https://github.com/code-423n4/2021-08-yield-findings/issues/65#issuecomment-900485268):\n  While the issue exists, it's not as severe as portrayed, and doesn't need fixing.\n\n There is an error in the assessment, and it is that the rate refers to the rewards amount distributed per second among all token holders. It is not the rewards amount distributed per token per second (that's dynamically calculated).\n\n Also, it needs to be taken into account that rewardsPerToken.accumulated is stored scaled up by 1e18, to avoid losing much ground to rounding.\n\nsolidity\nstruct RewardsPerToken {\n  uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n  uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n  uint96 rate;                                    // Wei rewarded per second among all token holders\n}\n\n\n One of the largest cap tokens is Dai, with a distribution close to 1e28.\n If ERC20Rewards were to distribute 1 cent/second among all token holders (which wouldn't be very exciting), and block times were of 1 second, the accumulator would still accumulate.\n\n accumulator += 1e18 (scaling) * 1 (seconds per block) * 1e16 (Dai wei / second) / 1e28 (Dai total supply)\n The increase to the accumulator is of 1e6, which gives plenty of precision. I would expect a rewards program on Dai holders would be at least 1e6 larger per second.\n\n On the other hand, accumulator is an uint128, which holds amounts of up to 1e38. To overflow it we would need a low cap token (let's say USDC, with 1e15), and a high distribution (1e12 per second, which is unreal), and we run the program for 3 years, or 1e9, to make it easy.\n\n The accumulator at the end of the ten years would be:\n accumulator = 1e18 (scaling) * 1e9 (seconds) * 1e12 (distribution) / 1e15 (supply) = 1e24\n Which doesn't overflow.\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-08-yield-findings/issues/65#issuecomment-913864410):\n  I'll keep high risk as there should be no scenario where the math breaks.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"../../utils/access/AccessControl.sol\";\nimport \"../../interfaces/vault/IOracle.sol\";\nimport \"../../constants/Constants.sol\";\nimport \"../../math/CastBytes32Bytes6.sol\";\nimport \"./CTokenInterface.sol\";\n\n\ncontract CompoundMultiOracle is IOracle, AccessControl, Constants {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed kind, address indexed source);\n\n    uint public constant SCALE_FACTOR = 1; // I think we don't need scaling for rate and chi oracles\n    uint8 public constant override decimals = 18;\n\n    mapping(bytes6 => mapping(bytes6 => address)) public sources;\n\n    /**\n     * @notice Set or reset one source\n     */\n    function setSource(bytes6 base, bytes6 kind, address source) external auth {\n        _setSource(base, kind, source);\n    }\n\n    /**\n     * @notice Set or reset an oracle source\n     */\n    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) external auth {\n        require(bases.length == kinds.length && kinds.length == sources_.length, \"Mismatched inputs\");\n        for (uint256 i = 0; i < bases.length; i++)\n            _setSource(bases[i], kinds[i], sources_[i]);\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 kind, uint256 amount)\n        external view virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), kind.b6());\n        value = price * amount / 1e18;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 kind, uint256 amount)\n        external virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), kind.b6());\n        value = price * amount / 1e18;\n    }\n\n    function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {\n        uint256 rawPrice;\n        address source = sources[base][kind];\n        require (source != address(0), \"Source not found\");\n\n        if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();\n        else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();\n        else revert(\"Unknown oracle type\");\n\n        require(rawPrice > 0, \"Compound price is zero\");\n\n        price = rawPrice * SCALE_FACTOR;\n        updateTime = block.timestamp;\n    }\n\n    function _setSource(bytes6 base, bytes6 kind, address source) internal {\n        sources[base][kind] = source;\n        emit SourceSet(base, kind, source);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.16;\n\ninterface CTokenInterface {\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    function borrowIndex() external view returns (uint);\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() external returns (uint);\n    \n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view returns (uint);\n}\n\n",
        "CodeNames": [
            "CompoundMultiOracle.sol",
            "CTokenInterface.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "exchangeRateStored",
                    "exchangeRateCurrent"
                ],
                "Type": " Exchange rates from Compound are assumed with 18 decimals",
                "Description": "\nThe CTokenMultiOracle contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the Compound documentation(https://compound.finance/docs/ctokens#exchange-rate), the exchange rate returned from the exchangeRateCurrent function is scaled by 1 * 10^(18 8 + Underlying Token Decimals) (and so does exchangeRateStored). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens. See CTokenMultiOracle.sol #L110(https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110).\n\n",
                "Repair": "Recommend following the documentation and getting the decimals of the underlying tokens to set the correct decimal of a Source.\n\nalcueca (Yield) confirmed(https://github.com/code-423n4/2021-08-yield-findings/issues/38#issuecomment-899063337):\n  Thanks a lot for coming up with this. I had looked into how Compound defined the decimals and couldn't find it.\n\nalcueca (Yield) patched(https://github.com/code-423n4/2021-08-yield-findings/issues/38#issuecomment-901201555):\n  Fix(https://github.com/yieldprotocol/vault-v2/commit/e9c1ee5532c946e9ab2fc8912039829e190fbb64)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastI128U128 for int128;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (seriesId != bytes12(0), \"Series id is zero\");\n        require (ilkId != bytes12(0), \"Ilk id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (vault.seriesId != bytes6(0), \"Series id is zero\");\n        require (vault.ilkId != bytes6(0), \"Ilk id is zero\");\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Convert a debt amount for a series from base to fyToken terms.\n    /// @notice Think about rounding if using, since we are dividing.\n    function debtFromBase(bytes6 seriesId, uint128 base)\n        external\n        returns (uint128 art)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            art = uint256(base).wdiv(_accrual(seriesId, series_)).u128();\n        } else {\n            art = base;\n        }\n    }\n\n    /// @dev Convert a debt amount for a series from fyToken to base terms\n    function debtToBase(bytes6 seriesId, uint128 art)\n        external\n        returns (uint128 base)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            base = uint256(art).wmul(_accrual(seriesId, series_)).u128();\n        } else {\n            base = art;\n        }\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        require (from != to, \"Identical vaults\");\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give an uncollateralized vault to another user.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n        _give(vaultId, receiver);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId)\n        external\n        returns (int256)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        external\n    {\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        DataTypes.Series memory series_ = series[seriesId];\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        external\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"./ERC20Permit.sol\";\nimport \"../access/AccessControl.sol\";\nimport \"../RevertMsgExtractor.sol\";\n\n\nlibrary CastU256U32 {\n    /// @dev Safely cast an uint256 to an uint32\n    function u32(uint256 x) internal pure returns (uint32 y) {\n        require (x <= type(uint32).max, \"Cast overflow\");\n        y = uint32(x);\n    }\n}\n\nlibrary CastU256U128 {\n    /// @dev Safely cast an uint256 to an uint128\n    function u128(uint256 x) internal pure returns (uint128 y) {\n        require (x <= type(uint128).max, \"Cast overflow\");\n        y = uint128(x);\n    }\n}\n\n/// @dev A token inheriting from ERC20Rewards will reward token holders with a rewards token.\n/// The rewarded amount will be a fixed wei per second, distributed proportionally to token holders\n/// by the size of their holdings.\ncontract ERC20Rewards is AccessControl, ERC20Permit {\n    using CastU256U32 for uint256;\n    using CastU256U128 for uint256;\n\n    event RewardsSet(IERC20 rewardsToken, uint32 start, uint32 end, uint256 rate);\n    event RewardsPerTokenUpdated(uint256 accumulated);\n    event UserRewardsUpdated(address user, uint256 userRewards, uint256 paidRewardPerToken);\n    event Claimed(address receiver, uint256 claimed);\n\n    struct RewardsPeriod {\n        uint32 start;                                   // Start time for the current rewardsToken schedule\n        uint32 end;                                     // End time for the current rewardsToken schedule\n    }\n\n    struct RewardsPerToken {\n        uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n        uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n        uint96 rate;                                    // Wei rewarded per second among all token holders\n    }\n\n    struct UserRewards {\n        uint128 accumulated;                            // Accumulated rewards for the user until the checkpoint\n        uint128 checkpoint;                             // RewardsPerToken the last time the user rewards were updated\n    }\n\n    IERC20 public rewardsToken;                         // Token used as rewards\n    RewardsPeriod public rewardsPeriod;                 // Period in which rewards are accumulated by users\n\n    RewardsPerToken public rewardsPerToken;             // Accumulator to track rewards per token               \n    mapping (address => UserRewards) public rewards;    // Rewards accumulated by users\n    \n    constructor(string memory name, string memory symbol, uint8 decimals)\n        ERC20Permit(name, symbol, decimals)\n    { }\n\n    /// @dev Return the earliest of two timestamps\n    function earliest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x < y) ? x : y;\n    }\n\n    /// @dev Return the latest of two timestamps\n    function latest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x > y) ? x : y;\n    }\n\n    /// @dev Set a rewards schedule\n    function setRewards(IERC20 rewardsToken_, uint32 start, uint32 end, uint96 rate)\n        public\n        auth\n    {\n        // A new rewards program can be set if one is not running\n        require(\n            block.timestamp.u32() < rewardsPeriod.start || block.timestamp.u32() > rewardsPeriod.end,\n            \"Ongoing rewards\"\n        );\n\n        // If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token\n        rewardsToken = rewardsToken_;\n\n        rewardsPeriod.start = start;\n        rewardsPeriod.end = end;\n\n        // If setting up a new rewards program, the rewardsPerToken.accumulated is used and built upon\n        // New rewards start accumulating from the new rewards program start\n        // Any unaccounted rewards from last program can still be added to the user rewards\n        // Any unclaimed rewards can still be claimed\n        rewardsPerToken.lastUpdated = start;\n        rewardsPerToken.rate = rate;\n\n        emit RewardsSet(rewardsToken, start, end, rate);\n    }\n\n    /// @dev Update the rewards per token accumulator.\n    /// @notice Needs to be called on each liquidity event\n    function _updateRewardsPerToken() internal returns (uint128) {\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        RewardsPeriod memory rewardsPeriod_ = rewardsPeriod;\n\n        // We skip the calculations if we can\n        if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod_.start) return 0;\n        if (rewardsPerToken_.lastUpdated >= rewardsPeriod_.end) return rewardsPerToken_.accumulated;\n\n        // Find out the unaccounted period\n        uint32 end = earliest(block.timestamp.u32(), rewardsPeriod_.end);\n        uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated; // Cast to uint256 to avoid overflows later on\n\n        // Calculate and update the new value of the accumulator. timeSinceLastUpdated casts it into uint256, which is desired.\n        rewardsPerToken_.accumulated = (rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply).u128(); // The rewards per token are scaled up for precision\n        rewardsPerToken_.lastUpdated = end;\n        rewardsPerToken = rewardsPerToken_;\n        \n        emit RewardsPerTokenUpdated(rewardsPerToken_.accumulated);\n\n        return rewardsPerToken_.accumulated;\n    }\n\n    /// @dev Accumulate rewards for an user.\n    /// @notice Needs to be called on each liquidity event, or when user balances change.\n    function _updateUserRewards(address user) internal returns (uint128) {\n        UserRewards memory userRewards_ = rewards[user];\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        \n        // Calculate and update the new value user reserves. _balanceOf[user] casts it into uint256, which is desired.\n        userRewards_.accumulated = (userRewards_.accumulated + _balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint) / 1e18).u128(); // We must scale down the rewards by the precision factor\n        userRewards_.checkpoint = rewardsPerToken_.accumulated;\n        rewards[user] = userRewards_;\n        emit UserRewardsUpdated(user, userRewards_.accumulated, userRewards_.checkpoint);\n\n        return userRewards_.accumulated;\n    }\n\n    /// @dev Mint tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _mint(address dst, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(dst);\n        return super._mint(dst, wad);\n    }\n\n    /// @dev Burn tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _burn(address src, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        return super._burn(src, wad);\n    }\n\n    /// @dev Transfer tokens, after updating rewards for source and destination.\n    function _transfer(address src, address dst, uint wad) internal virtual override returns (bool) {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        _updateUserRewards(dst);\n        return super._transfer(src, dst, wad);\n    }\n\n    /// @dev Claim all rewards from caller into a given address\n    function claim(address to)\n        external\n        returns (uint256 claiming)\n    {\n        _updateRewardsPerToken();\n        claiming = _updateUserRewards(msg.sender);\n        rewards[msg.sender].accumulated = 0; // A Claimed event implies the rewards were set to zero\n        rewardsToken.transfer(to, claiming);\n        emit Claimed(to, claiming);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"./utils/token/ERC20Permit.sol\";\nimport \"./utils/token/SafeERC20Namer.sol\";\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./constants/Constants.sol\";\n\n\ncontract FYToken is IFYToken, IERC3156FlashLender, AccessControl(), ERC20Permit, Constants {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event SeriesMatured(uint256 chiAtMaturity);\n    event Redeemed(address indexed from, address indexed to, uint256 amount, uint256 redeemed);\n    event OracleSet(address indexed oracle);\n\n    uint256 constant CHI_NOT_SET = type(uint256).max;\n\n    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IOracle public oracle;                                      // Oracle for the savings rate.\n    IJoin public immutable join;                                // Source of redemption funds.\n    address public immutable override underlying;\n    bytes6 public immutable underlyingId;                             // Needed to access the oracle\n    uint256 public immutable override maturity;\n    uint256 public chiAtMaturity = CHI_NOT_SET;           // Spot price (exchange rate) between the base and an interest accruing token at maturity \n\n    constructor(\n        bytes6 underlyingId_,\n        IOracle oracle_, // Underlying vs its interest-bearing version\n        IJoin join_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    ) ERC20Permit(name, symbol, SafeERC20Namer.tokenDecimals(address(IJoin(join_).asset()))) { // The join asset is this fyToken's underlying, from which we inherit the decimals\n        uint256 now_ = block.timestamp;\n        require(\n            maturity_ > now_ &&\n            maturity_ < now_ + MAX_TIME_TO_MATURITY &&\n            maturity_ < type(uint32).max,\n            \"Invalid maturity\"\n        );\n\n        underlyingId = underlyingId_;\n        join = join_;\n        maturity = maturity_;\n        underlying = address(IJoin(join_).asset());\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    modifier afterMaturity() {\n        require(\n            uint32(block.timestamp) >= maturity,\n            \"Only after maturity\"\n        );\n        _;\n    }\n\n    modifier beforeMaturity() {\n        require(\n            uint32(block.timestamp) < maturity,\n            \"Only before maturity\"\n        );\n        _;\n    }\n\n    /// @dev Set the oracle parameter\n    function setOracle(IOracle oracle_)\n        external\n        auth    \n    {\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    /// If called more than once, it will revert.\n    function mature()\n        external override\n        afterMaturity\n    {\n        require (chiAtMaturity == CHI_NOT_SET, \"Already matured\");\n        _mature();\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    function _mature() \n        private\n        returns (uint256 _chiAtMaturity)\n    {\n        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);\n        chiAtMaturity = _chiAtMaturity;\n        emit SeriesMatured(_chiAtMaturity);\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    function accrual()\n        external\n        afterMaturity\n        returns (uint256)\n    {\n        return _accrual();\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual()\n        private\n        returns (uint256 accrual_)\n    {\n        if (chiAtMaturity == CHI_NOT_SET) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\n            _mature();\n        } else {\n            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);\n            accrual_ = chi.wdiv(chiAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Burn the fyToken after maturity for an amount that increases according to `chi`\n    function redeem(address to, uint256 amount)\n        external override\n        afterMaturity\n        returns (uint256 redeemed)\n    {\n        _burn(msg.sender, amount);\n        redeemed = amount.wmul(_accrual());\n        join.exit(to, redeemed.u128());\n        \n        emit Redeemed(msg.sender, to, amount, redeemed);\n    }\n\n    /// @dev Mint fyTokens.\n    function mint(address to, uint256 amount)\n        external override\n        beforeMaturity\n        auth\n    {\n        _mint(to, amount);\n    }\n\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them. \n    function burn(address from, uint256 amount)\n        external override\n        auth\n    {\n        _burn(from, amount);\n    }\n\n    /// @dev Burn fyTokens. \n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\n    function _burn(address from, uint256 amount)\n        internal override\n        returns (bool)\n    {\n        // First use any tokens locked in this contract\n        uint256 available = _balanceOf[address(this)];\n        if (available >= amount) {\n            return super._burn(address(this), amount);\n        } else {\n            if (available > 0 ) super._burn(address(this), available);\n            unchecked { _decreaseAllowance(from, amount - available); }\n            unchecked { return super._burn(from, amount - available); }\n        }\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be a FYDai.\n     * param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        return 0;\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        beforeMaturity\n        returns(bool)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n        _burn(address(receiver), amount);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "Cauldron.sol",
            "ERC20Rewards.sol",
            "FYToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "false",
                    "transfer",
                    "claim",
                    "ERC",
                    "rewardsToken.transfer(to, claiming);",
                    "void"
                ],
                "Type": " No ERC20 safe* versions called",
                "Description": "\nThe claim function performs an ERC20 transfer rewardsToken.transfer(to, claiming); but does not check the return value, nor does it work with all legacy tokens.\n\nSome tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/transferFrom function return void instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.\n\nThe ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success. This parameter needs to be checked for success.\nSome tokens do not revert if the transfer failed but return false instead.\n\nTokens that don't actually perform the transfer and return false are still counted as a correct transfer and tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.\n\n",
                "Repair": "Recommend using OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.\n\nalcueca (Yield) confirmed(https://github.com/code-423n4/2021-08-yield-findings/issues/31#issuecomment-898826857):\n  True, thanks for spotting it!\n\nalcueca (Yield) patched(https://github.com/code-423n4/2021-08-yield-findings/issues/31#issuecomment-899365841):\n  Fix(https://github.com/yieldprotocol/yield-utils-v2/commit/3715140ab7d6fbde593257c7542a661bc9191d8c)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"./access/AccessControl.sol\";\n\n\ninterface IEmergencyBrake {\n    function plan(address target, address[] memory contacts, bytes4[][] memory permissions) external returns (bytes32 txHash);\n    function cancel(address target, address[] memory contacts, bytes4[][] memory permissions) external;\n    function execute(address target, address[] memory contacts, bytes4[][] memory permissions) external;\n    function restore(address target, address[] memory contacts, bytes4[][] memory permissions) external;\n    function terminate(address target, address[] memory contacts, bytes4[][] memory permissions) external;\n}\n\n/// @dev EmergencyBrake allows to plan for and execute transactions that remove access permissions for a target\n/// contract. In an permissioned environment this can be used for pausing components.\n/// All contracts in scope of emergency plans must grant ROOT permissions to EmergencyBrake. To mitigate the risk\n/// of governance capture, EmergencyBrake has very limited functionality, being able only to revoke existing roles\n/// and to restore previously revoked roles. Thus EmergencyBrake cannot grant permissions that weren't there in the \n/// first place. As an additional safeguard, EmergencyBrake cannot revoke or grant ROOT roles.\n/// In addition, there is a separation of concerns between the planner and the executor accounts, so that both of them\n/// must be compromised simultaneously to execute non-approved emergency plans, and then only creating a denial of service.\ncontract EmergencyBrake is AccessControl, IEmergencyBrake {\n    enum State {UNKNOWN, PLANNED, EXECUTED, TERMINATED}\n\n    event Planned(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);\n    event Cancelled(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);\n    event Executed(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);\n    event Restored(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);\n    event Terminated(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);\n\n    mapping (bytes32 => State) public plans;\n\n    constructor(address planner, address executor) AccessControl() {\n        _grantRole(IEmergencyBrake.plan.selector, planner);\n        _grantRole(IEmergencyBrake.cancel.selector, planner);\n        _grantRole(IEmergencyBrake.execute.selector, executor);\n        _grantRole(IEmergencyBrake.restore.selector, planner);\n        _grantRole(IEmergencyBrake.terminate.selector, planner);\n\n        // Granting roles (plan, cancel, execute, restore, terminate) is reserved to ROOT\n    }\n\n    /// @dev Register an access removal transaction\n    function plan(address target, address[] memory contacts, bytes4[][] memory permissions)\n        external override auth\n        returns (bytes32 txHash)\n    {\n        require(contacts.length == permissions.length, \"Mismatched inputs\");\n        // Removing or granting ROOT permissions is out of bounds for EmergencyBrake\n        for (uint256 i = 0; i < contacts.length; i++){\n            for (uint256 j = 0; j < permissions[i].length; j++){\n                require(\n                    permissions[i][j] != ROOT,\n                    \"Can't remove ROOT\"\n                );\n            }\n        }\n        txHash = keccak256(abi.encode(target, contacts, permissions));\n        require(plans[txHash] == State.UNKNOWN, \"Emergency already planned for.\");\n        plans[txHash] = State.PLANNED;\n        emit Planned(txHash, target, contacts, permissions);\n    }\n\n    /// @dev Erase a planned access removal transaction\n    function cancel(address target, address[] memory contacts, bytes4[][] memory permissions)\n        external override auth\n    {\n        require(contacts.length == permissions.length, \"Mismatched inputs\");\n        bytes32 txHash = keccak256(abi.encode(target, contacts, permissions));\n        require(plans[txHash] == State.PLANNED, \"Emergency not planned for.\");\n        plans[txHash] = State.UNKNOWN;\n        emit Cancelled(txHash, target, contacts, permissions);\n    }\n\n    /// @dev Execute an access removal transaction\n    function execute(address target, address[] memory contacts, bytes4[][] memory permissions)\n        external override auth\n    {\n        require(contacts.length == permissions.length, \"Mismatched inputs\");\n        bytes32 txHash = keccak256(abi.encode(target, contacts, permissions));\n        require(plans[txHash] == State.PLANNED, \"Emergency not planned for.\");\n        plans[txHash] = State.EXECUTED;\n\n        for (uint256 i = 0; i < contacts.length; i++){\n            // AccessControl.sol doesn't revert if revoking permissions that haven't been granted\n            // If we don't check, planner and executor can collude to gain access to contacts\n            for (uint256 j = 0; j < permissions[i].length; j++){\n                require(\n                    AccessControl(contacts[i]).hasRole(permissions[i][j], target),\n                    \"Permission not found\"\n                );\n            }\n            // Now revoke the permissions\n            AccessControl(contacts[i]).revokeRoles(permissions[i], target);\n        }\n        emit Executed(txHash, target, contacts, permissions);\n    }\n\n    /// @dev Restore the orchestration from an isolated target\n    function restore(address target, address[] memory contacts, bytes4[][] memory permissions)\n        external override auth\n    {\n        require(contacts.length == permissions.length, \"Mismatched inputs\");\n        bytes32 txHash = keccak256(abi.encode(target, contacts, permissions));\n        require(plans[txHash] == State.EXECUTED, \"Emergency plan not executed.\");\n        plans[txHash] = State.PLANNED;\n\n        for (uint256 i = 0; i < contacts.length; i++){\n            AccessControl(contacts[i]).grantRoles(permissions[i], target);\n        }\n        emit Restored(txHash, target, contacts, permissions);\n    }\n\n    /// @dev Remove the restoring option from an isolated target\n    function terminate(address target, address[] memory contacts, bytes4[][] memory permissions)\n        external override auth\n    {\n        require(contacts.length == permissions.length, \"Mismatched inputs\");\n        bytes32 txHash = keccak256(abi.encode(target, contacts, permissions));\n        require(plans[txHash] == State.EXECUTED, \"Emergency plan not executed.\");\n        plans[txHash] = State.TERMINATED;\n        emit Terminated(txHash, target, contacts, permissions);\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastI128U128 for int128;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (seriesId != bytes12(0), \"Series id is zero\");\n        require (ilkId != bytes12(0), \"Ilk id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (vault.seriesId != bytes6(0), \"Series id is zero\");\n        require (vault.ilkId != bytes6(0), \"Ilk id is zero\");\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Convert a debt amount for a series from base to fyToken terms.\n    /// @notice Think about rounding if using, since we are dividing.\n    function debtFromBase(bytes6 seriesId, uint128 base)\n        external\n        returns (uint128 art)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            art = uint256(base).wdiv(_accrual(seriesId, series_)).u128();\n        } else {\n            art = base;\n        }\n    }\n\n    /// @dev Convert a debt amount for a series from fyToken to base terms\n    function debtToBase(bytes6 seriesId, uint128 art)\n        external\n        returns (uint128 base)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            base = uint256(art).wmul(_accrual(seriesId, series_)).u128();\n        } else {\n            base = art;\n        }\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        require (from != to, \"Identical vaults\");\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give an uncollateralized vault to another user.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n        _give(vaultId, receiver);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId)\n        external\n        returns (int256)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        external\n    {\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        DataTypes.Series memory series_ = series[seriesId];\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        external\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n// SPDX-License-Identifier: MIT\n// Inspired on TimeLock.sol from Compound.\n\npragma solidity ^0.8.0;\nimport \"./access/AccessControl.sol\";\nimport \"./RevertMsgExtractor.sol\";\n\ninterface ITimeLock {\n    function setDelay(uint256 delay_) external;\n    function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta) external returns (bytes32 txHash);\n    function cancel(address[] calldata targets, bytes[] calldata data) external;\n    function execute(address[] calldata targets, bytes[] calldata data) external returns (bytes[] calldata results);\n}\n\ncontract TimeLock is ITimeLock, AccessControl {\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    event DelaySet(uint256 indexed delay);\n    event Cancelled(bytes32 indexed txHash, address[] indexed targets, bytes[] data);\n    event Executed(bytes32 indexed txHash, address[] indexed targets, bytes[] data);\n    event Scheduled(bytes32 indexed txHash, address[] indexed targets, bytes[] data, uint256 eta);\n\n    uint256 public delay;\n    mapping (bytes32 => uint256) public transactions;\n\n    constructor(address scheduler, address executor) AccessControl() {\n        delay = MINIMUM_DELAY;\n\n        // scheduler can schedule and cancel, executor can execute\n        _grantRole(ITimeLock.schedule.selector, scheduler); // bytes4(keccak256(\"schedule(address[],bytes[],uint256)\"))\n        _grantRole(ITimeLock.cancel.selector, scheduler); // bytes4(keccak256(\"cancel(address[],bytes[],uint256)\"))\n        _grantRole(ITimeLock.execute.selector, executor); // bytes4(keccak256(\"execute(address[],bytes[],uint256)\"))\n\n        // Changing the delay must now be executed through this TimeLock contract\n        _grantRole(ITimeLock.setDelay.selector, address(this)); // bytes4(keccak256(\"setDelay(uint256)\"))\n\n        // Granting roles (schedule, cancel, execute, setDelay) must now be executed through this TimeLock contract\n        _grantRole(ROOT, address(this));\n        _revokeRole(ROOT, msg.sender);\n    }\n\n    /// @dev Change the delay for queueing and executing transactions\n    function setDelay(uint256 delay_) external override auth {\n        require(delay_ >= MINIMUM_DELAY, \"Must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit DelaySet(delay);\n    }\n\n    /// @dev Schedule a transaction batch for execution between `eta` and `eta + GRACE_PERIOD`\n    function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta)\n        external override auth returns (bytes32 txHash)\n    {\n        require(targets.length == data.length, \"Mismatched inputs\");\n        require(eta >= block.timestamp + delay, \"Must satisfy delay.\"); // This also prevents setting eta = 0 and messing up the state\n        txHash = keccak256(abi.encode(targets, data));\n        require(transactions[txHash] == 0, \"Transaction not unknown.\");\n        transactions[txHash] = eta;\n        emit Scheduled(txHash, targets, data, eta);\n    }\n\n    /// @dev Cancel a scheduled transaction batch\n    function cancel(address[] calldata targets, bytes[] calldata data)\n        external override auth\n    {\n        require(targets.length == data.length, \"Mismatched inputs\");\n        bytes32 txHash = keccak256(abi.encode(targets, data));\n        require(transactions[txHash] != 0, \"Transaction hasn't been scheduled.\");\n        delete transactions[txHash];\n        emit Cancelled(txHash, targets, data);\n    }\n\n    /// @dev Execute a transaction batch\n    function execute(address[] calldata targets, bytes[] calldata data)\n        external override auth returns (bytes[] memory results)\n    {\n        require(targets.length == data.length, \"Mismatched inputs\");\n        bytes32 txHash = keccak256(abi.encode(targets, data));\n        uint256 eta = transactions[txHash];\n\n        require(eta != 0, \"Transaction hasn't been scheduled.\");\n        require(block.timestamp >= eta, \"ETA not reached.\");\n        require(block.timestamp <= eta + GRACE_PERIOD, \"Transaction is stale.\");\n\n        delete transactions[txHash];\n\n        results = new bytes[](targets.length);\n        for (uint256 i = 0; i < targets.length; i++){\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n            results[i] = result;\n        }\n        emit Executed(txHash, targets, data);\n    }\n}\n\n",
        "CodeNames": [
            "EmergencyBrake.sol",
            "Cauldron.sol",
            "TimeLock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "targets",
                    "txHash",
                    "schedule",
                    "data"
                ],
                "Type": "  TimeLock  cannot schedule the same calls multiple times",
                "Description": "\nThe TimeLock.schedule function reverts if the same targets and data fields are used as the txHash will be the same.\nThis means one cannot schedule the same transactions multiple times.\n\nImagine the delay is set to 30 days, but a contractor needs to be paid every 2 weeks. One needs to wait 30 days before scheduling the second payment to them.\n\n",
                "Repair": "Recommend also including eta in the hash. (Compound's Timelock does it as well.) This way the same transaction data can be used by specifying a different eta.\n\nalcueca (Yield) confirmed(https://github.com/code-423n4/2021-08-yield-findings/issues/27#issuecomment-898830142):\n  Funny, BoringCrypto was quite negative about including the eta in the txHash(https://twitter.com/Boring_Crypto/status/1425401221091762189). At the time I couldn't think of a reason to repeat the same call with the same data, but you are right that sometimes it might make sense, and storing off-chain the expected eta of each timelocked transaction is something you should do anyway.\n\n I'll confirm this issue, and will bring it for public discussion once the contest is over.\n\nalcueca (Yield) patched(https://github.com/code-423n4/2021-08-yield-findings/issues/27#issuecomment-921487023):\n I ended up refactoring the Timelock(https://github.com/yieldprotocol/yield-utils-v2/blob/main/contracts/utils/Timelock.sol) so that the eta is not included in the parameters, but repeated proposals are allowed.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"./ERC20Permit.sol\";\nimport \"../access/AccessControl.sol\";\nimport \"../RevertMsgExtractor.sol\";\n\n\nlibrary CastU256U32 {\n    /// @dev Safely cast an uint256 to an uint32\n    function u32(uint256 x) internal pure returns (uint32 y) {\n        require (x <= type(uint32).max, \"Cast overflow\");\n        y = uint32(x);\n    }\n}\n\nlibrary CastU256U128 {\n    /// @dev Safely cast an uint256 to an uint128\n    function u128(uint256 x) internal pure returns (uint128 y) {\n        require (x <= type(uint128).max, \"Cast overflow\");\n        y = uint128(x);\n    }\n}\n\n/// @dev A token inheriting from ERC20Rewards will reward token holders with a rewards token.\n/// The rewarded amount will be a fixed wei per second, distributed proportionally to token holders\n/// by the size of their holdings.\ncontract ERC20Rewards is AccessControl, ERC20Permit {\n    using CastU256U32 for uint256;\n    using CastU256U128 for uint256;\n\n    event RewardsSet(IERC20 rewardsToken, uint32 start, uint32 end, uint256 rate);\n    event RewardsPerTokenUpdated(uint256 accumulated);\n    event UserRewardsUpdated(address user, uint256 userRewards, uint256 paidRewardPerToken);\n    event Claimed(address receiver, uint256 claimed);\n\n    struct RewardsPeriod {\n        uint32 start;                                   // Start time for the current rewardsToken schedule\n        uint32 end;                                     // End time for the current rewardsToken schedule\n    }\n\n    struct RewardsPerToken {\n        uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n        uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n        uint96 rate;                                    // Wei rewarded per second among all token holders\n    }\n\n    struct UserRewards {\n        uint128 accumulated;                            // Accumulated rewards for the user until the checkpoint\n        uint128 checkpoint;                             // RewardsPerToken the last time the user rewards were updated\n    }\n\n    IERC20 public rewardsToken;                         // Token used as rewards\n    RewardsPeriod public rewardsPeriod;                 // Period in which rewards are accumulated by users\n\n    RewardsPerToken public rewardsPerToken;             // Accumulator to track rewards per token               \n    mapping (address => UserRewards) public rewards;    // Rewards accumulated by users\n    \n    constructor(string memory name, string memory symbol, uint8 decimals)\n        ERC20Permit(name, symbol, decimals)\n    { }\n\n    /// @dev Return the earliest of two timestamps\n    function earliest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x < y) ? x : y;\n    }\n\n    /// @dev Return the latest of two timestamps\n    function latest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x > y) ? x : y;\n    }\n\n    /// @dev Set a rewards schedule\n    function setRewards(IERC20 rewardsToken_, uint32 start, uint32 end, uint96 rate)\n        public\n        auth\n    {\n        // A new rewards program can be set if one is not running\n        require(\n            block.timestamp.u32() < rewardsPeriod.start || block.timestamp.u32() > rewardsPeriod.end,\n            \"Ongoing rewards\"\n        );\n\n        // If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token\n        rewardsToken = rewardsToken_;\n\n        rewardsPeriod.start = start;\n        rewardsPeriod.end = end;\n\n        // If setting up a new rewards program, the rewardsPerToken.accumulated is used and built upon\n        // New rewards start accumulating from the new rewards program start\n        // Any unaccounted rewards from last program can still be added to the user rewards\n        // Any unclaimed rewards can still be claimed\n        rewardsPerToken.lastUpdated = start;\n        rewardsPerToken.rate = rate;\n\n        emit RewardsSet(rewardsToken, start, end, rate);\n    }\n\n    /// @dev Update the rewards per token accumulator.\n    /// @notice Needs to be called on each liquidity event\n    function _updateRewardsPerToken() internal returns (uint128) {\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        RewardsPeriod memory rewardsPeriod_ = rewardsPeriod;\n\n        // We skip the calculations if we can\n        if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod_.start) return 0;\n        if (rewardsPerToken_.lastUpdated >= rewardsPeriod_.end) return rewardsPerToken_.accumulated;\n\n        // Find out the unaccounted period\n        uint32 end = earliest(block.timestamp.u32(), rewardsPeriod_.end);\n        uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated; // Cast to uint256 to avoid overflows later on\n\n        // Calculate and update the new value of the accumulator. timeSinceLastUpdated casts it into uint256, which is desired.\n        rewardsPerToken_.accumulated = (rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply).u128(); // The rewards per token are scaled up for precision\n        rewardsPerToken_.lastUpdated = end;\n        rewardsPerToken = rewardsPerToken_;\n        \n        emit RewardsPerTokenUpdated(rewardsPerToken_.accumulated);\n\n        return rewardsPerToken_.accumulated;\n    }\n\n    /// @dev Accumulate rewards for an user.\n    /// @notice Needs to be called on each liquidity event, or when user balances change.\n    function _updateUserRewards(address user) internal returns (uint128) {\n        UserRewards memory userRewards_ = rewards[user];\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        \n        // Calculate and update the new value user reserves. _balanceOf[user] casts it into uint256, which is desired.\n        userRewards_.accumulated = (userRewards_.accumulated + _balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint) / 1e18).u128(); // We must scale down the rewards by the precision factor\n        userRewards_.checkpoint = rewardsPerToken_.accumulated;\n        rewards[user] = userRewards_;\n        emit UserRewardsUpdated(user, userRewards_.accumulated, userRewards_.checkpoint);\n\n        return userRewards_.accumulated;\n    }\n\n    /// @dev Mint tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _mint(address dst, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(dst);\n        return super._mint(dst, wad);\n    }\n\n    /// @dev Burn tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _burn(address src, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        return super._burn(src, wad);\n    }\n\n    /// @dev Transfer tokens, after updating rewards for source and destination.\n    function _transfer(address src, address dst, uint wad) internal virtual override returns (bool) {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        _updateUserRewards(dst);\n        return super._transfer(src, dst, wad);\n    }\n\n    /// @dev Claim all rewards from caller into a given address\n    function claim(address to)\n        external\n        returns (uint256 claiming)\n    {\n        _updateRewardsPerToken();\n        claiming = _updateUserRewards(msg.sender);\n        rewards[msg.sender].accumulated = 0; // A Claimed event implies the rewards were set to zero\n        rewardsToken.transfer(to, claiming);\n        emit Claimed(to, claiming);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC20Rewards.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "setRewards",
                    "claim"
                ],
                "Type": " Rewards squatting - setting rewards in different ERC20 tokens opens various economic attacks. ",
                "Description": "\nUsers essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.\n\nAlthough stated on line 84, it does not take into account the implications the lock in this contract will have on the future value of new tokens able to be issued via rewards.\n\nSmart users will monitor the mempool for setRewards transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they can  front run this transaction by calling claim. Otherwise, they let their accrued 'token a' roll into rewards of of the more valuable 'token b'.\n\nGiven loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards.\n\nEconomically, and given the above, it makes sense that the value of new reward tokens, i.e. 'token b' should always be less than that of 'token a'. This is undesirable in a rewards token contract, as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.\n\ni.e. You could not issue a more valuable token in future (for example, if we wanted to run a rewards period issuing an asset like WETH rewards for 10 days) after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.\n\nP.s. This is one of the slickest contracts I've read. Love how awesome it is.Just believe this should be fixed, then its good to go.\n\nIt is true you could probably write a script to manually go call claim on thousands of squatting token addresses but this is a poor solution.\n\n",
                "Repair": "Recommend instead, that a simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).\n\nalcueca (Yield) confirmed(https://github.com/code-423n4/2021-08-yield-findings/issues/64#issuecomment-899068756):\n  Thanks! I agree that allowing to change the rewards token is just too troublesome.\n\nalcueca (Yield) patched(https://github.com/code-423n4/2021-08-yield-findings/issues/64#issuecomment-899270061):\n  Fix(https://github.com/yieldprotocol/yield-utils-v2/commit/6df51f81a36e8f9b26b4946ac1aeda90eff6ffda)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastI128U128 for int128;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (seriesId != bytes12(0), \"Series id is zero\");\n        require (ilkId != bytes12(0), \"Ilk id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (vault.seriesId != bytes6(0), \"Series id is zero\");\n        require (vault.ilkId != bytes6(0), \"Ilk id is zero\");\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Convert a debt amount for a series from base to fyToken terms.\n    /// @notice Think about rounding if using, since we are dividing.\n    function debtFromBase(bytes6 seriesId, uint128 base)\n        external\n        returns (uint128 art)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            art = uint256(base).wdiv(_accrual(seriesId, series_)).u128();\n        } else {\n            art = base;\n        }\n    }\n\n    /// @dev Convert a debt amount for a series from fyToken to base terms\n    function debtToBase(bytes6 seriesId, uint128 art)\n        external\n        returns (uint128 base)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            base = uint256(art).wmul(_accrual(seriesId, series_)).u128();\n        } else {\n            base = art;\n        }\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        require (from != to, \"Identical vaults\");\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give an uncollateralized vault to another user.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n        _give(vaultId, receiver);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId)\n        external\n        returns (int256)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        external\n    {\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        DataTypes.Series memory series_ = series[seriesId];\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        external\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/IJoinFactory.sol\";\nimport \"./interfaces/external/IERC20.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./utils/token/TransferHelper.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/CastU256U128.sol\";\n\n\ncontract Join is IJoin, IERC3156FlashLender, AccessControl() {\n    using TransferHelper for IERC20;\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n\n    event FlashFeeFactorSet(uint256 indexed fee);\n\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    uint256 constant FLASH_LOANS_DISABLED = type(uint256).max;\n\n    address public immutable override asset;\n    uint256 public storedBalance;\n    uint256 public flashFeeFactor = FLASH_LOANS_DISABLED; // Fee on flash loans, as a percentage in fixed point with 18 decimals. Flash loans disabled by default.\n\n    constructor(address asset_) {\n        asset = asset_;\n    }\n\n    /// @dev Set the flash loan fee factor\n    function setFlashFeeFactor(uint256 flashFeeFactor_)\n        external\n        auth\n    {\n        flashFeeFactor = flashFeeFactor_;\n        emit FlashFeeFactorSet(flashFeeFactor_);\n    }\n\n    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.\n    function join(address user, uint128 amount)\n        external override\n        auth\n        returns (uint128)\n    {\n        return _join(user, amount);\n    }\n\n    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.\n    function _join(address user, uint128 amount)\n        internal\n        returns (uint128)\n    {\n        IERC20 token = IERC20(asset);\n        uint256 _storedBalance = storedBalance;\n        uint256 available = token.balanceOf(address(this)) - _storedBalance; // Fine to panic if this underflows\n        storedBalance = _storedBalance + amount;\n        unchecked { if (available < amount) token.safeTransferFrom(user, address(this), amount - available); }\n        return amount;        \n    }\n\n    /// @dev Transfer `amount` `asset` to `user`\n    function exit(address user, uint128 amount)\n        external override\n        auth\n        returns (uint128)\n    {\n        return _exit(user, amount);\n    }\n\n    /// @dev Transfer `amount` `asset` to `user`\n    function _exit(address user, uint128 amount)\n        internal\n        returns (uint128)\n    {\n        IERC20 token = IERC20(asset);\n        storedBalance -= amount;\n        token.safeTransfer(user, amount);\n        return amount;\n    }\n\n    /// @dev Retrieve any tokens other than the `asset`. Useful for airdropped tokens.\n    function retrieve(IERC20 token, address to)\n        external\n        auth\n    {\n        require(address(token) != address(asset), \"Use exit for asset\");\n        token.safeTransfer(to, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        returns (uint256)\n    {\n        return token == asset ? storedBalance : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be the asset.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount)\n        external view override\n        returns (uint256)\n    {\n        require(token == asset, \"Unsupported currency\");\n        return _flashFee(amount);\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function _flashFee(uint256 amount) internal view returns (uint256) {\n        return amount.wmul(flashFeeFactor);\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` `asset` to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * If the principal + fee are transferred to this contract, they won't be pulled from the receiver.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        returns(bool)\n    {\n        require(token == asset, \"Unsupported currency\");\n        uint128 _amount = amount.u128();\n        uint128 _fee = _flashFee(amount).u128();\n        _exit(address(receiver), _amount);\n\n        require(receiver.onFlashLoan(msg.sender, token, _amount, _fee, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n\n        _join(address(receiver), _amount + _fee);\n        return true;\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"./utils/token/ERC20Permit.sol\";\nimport \"./utils/token/SafeERC20Namer.sol\";\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./constants/Constants.sol\";\n\n\ncontract FYToken is IFYToken, IERC3156FlashLender, AccessControl(), ERC20Permit, Constants {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event SeriesMatured(uint256 chiAtMaturity);\n    event Redeemed(address indexed from, address indexed to, uint256 amount, uint256 redeemed);\n    event OracleSet(address indexed oracle);\n\n    uint256 constant CHI_NOT_SET = type(uint256).max;\n\n    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IOracle public oracle;                                      // Oracle for the savings rate.\n    IJoin public immutable join;                                // Source of redemption funds.\n    address public immutable override underlying;\n    bytes6 public immutable underlyingId;                             // Needed to access the oracle\n    uint256 public immutable override maturity;\n    uint256 public chiAtMaturity = CHI_NOT_SET;           // Spot price (exchange rate) between the base and an interest accruing token at maturity \n\n    constructor(\n        bytes6 underlyingId_,\n        IOracle oracle_, // Underlying vs its interest-bearing version\n        IJoin join_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    ) ERC20Permit(name, symbol, SafeERC20Namer.tokenDecimals(address(IJoin(join_).asset()))) { // The join asset is this fyToken's underlying, from which we inherit the decimals\n        uint256 now_ = block.timestamp;\n        require(\n            maturity_ > now_ &&\n            maturity_ < now_ + MAX_TIME_TO_MATURITY &&\n            maturity_ < type(uint32).max,\n            \"Invalid maturity\"\n        );\n\n        underlyingId = underlyingId_;\n        join = join_;\n        maturity = maturity_;\n        underlying = address(IJoin(join_).asset());\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    modifier afterMaturity() {\n        require(\n            uint32(block.timestamp) >= maturity,\n            \"Only after maturity\"\n        );\n        _;\n    }\n\n    modifier beforeMaturity() {\n        require(\n            uint32(block.timestamp) < maturity,\n            \"Only before maturity\"\n        );\n        _;\n    }\n\n    /// @dev Set the oracle parameter\n    function setOracle(IOracle oracle_)\n        external\n        auth    \n    {\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    /// If called more than once, it will revert.\n    function mature()\n        external override\n        afterMaturity\n    {\n        require (chiAtMaturity == CHI_NOT_SET, \"Already matured\");\n        _mature();\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    function _mature() \n        private\n        returns (uint256 _chiAtMaturity)\n    {\n        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);\n        chiAtMaturity = _chiAtMaturity;\n        emit SeriesMatured(_chiAtMaturity);\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    function accrual()\n        external\n        afterMaturity\n        returns (uint256)\n    {\n        return _accrual();\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual()\n        private\n        returns (uint256 accrual_)\n    {\n        if (chiAtMaturity == CHI_NOT_SET) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\n            _mature();\n        } else {\n            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);\n            accrual_ = chi.wdiv(chiAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Burn the fyToken after maturity for an amount that increases according to `chi`\n    function redeem(address to, uint256 amount)\n        external override\n        afterMaturity\n        returns (uint256 redeemed)\n    {\n        _burn(msg.sender, amount);\n        redeemed = amount.wmul(_accrual());\n        join.exit(to, redeemed.u128());\n        \n        emit Redeemed(msg.sender, to, amount, redeemed);\n    }\n\n    /// @dev Mint fyTokens.\n    function mint(address to, uint256 amount)\n        external override\n        beforeMaturity\n        auth\n    {\n        _mint(to, amount);\n    }\n\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them. \n    function burn(address from, uint256 amount)\n        external override\n        auth\n    {\n        _burn(from, amount);\n    }\n\n    /// @dev Burn fyTokens. \n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\n    function _burn(address from, uint256 amount)\n        internal override\n        returns (bool)\n    {\n        // First use any tokens locked in this contract\n        uint256 available = _balanceOf[address(this)];\n        if (available >= amount) {\n            return super._burn(address(this), amount);\n        } else {\n            if (available > 0 ) super._burn(address(this), available);\n            unchecked { _decreaseAllowance(from, amount - available); }\n            unchecked { return super._burn(from, amount - available); }\n        }\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be a FYDai.\n     * param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        return 0;\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        beforeMaturity\n        returns(bool)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n        _burn(address(receiver), amount);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "Cauldron.sol",
            "Join.sol",
            "FYToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "safeTransfer",
                    "false",
                    "returns (bool success)",
                    "transfer"
                ],
                "Type": " Use  safeTransfer  instead of  transfer ",
                "Description": "\nTokens not compliant with the ERC20 specification could return false from the transfer function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the EIP-20(https://eips.ethereum.org/EIPS/eip-20) specification:\n Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!\n\nSee ERC20Rewards.sol L175(https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175).\n\n",
                "Repair": "Recommend using the SafeERC20 library implementation(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin and calling safeTransfer or safeTransferFrom when transferring ERC20 tokens.\n\nalcueca (Yield) confirmed and patched(https://github.com/code-423n4/2021-08-yield-findings/issues/36#issuecomment-899365631):\n  Fix(https://github.com/yieldprotocol/yield-utils-v2/commit/3715140ab7d6fbde593257c7542a661bc9191d8c)\n\n\n"
            }
        ]
    }
]