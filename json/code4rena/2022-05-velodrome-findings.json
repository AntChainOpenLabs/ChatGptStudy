[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\ncontract Velo {\n\n    string public constant name = \"Velodrome\";\n    string public constant symbol = \"VELO\";\n    uint8 public constant decimals = 18;\n    uint public totalSupply = 0;\n\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    address public minter;\n    address public redemptionReceiver;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    constructor() {\n        minter = msg.sender;\n        _mint(msg.sender, 0);\n    }\n\n    // No checks as its meant to be once off to set minting rights to BaseV1 Minter\n    function setMinter(address _minter) external {\n        require(msg.sender == minter);\n        minter = _minter;\n    }\n\n    function setRedemptionReceiver(address _receiver) external {\n        require(msg.sender == minter);\n        redemptionReceiver = _receiver;\n    }\n\n    function approve(address _spender, uint _value) external returns (bool) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function _mint(address _to, uint _amount) internal returns (bool) {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n        emit Transfer(address(0x0), _to, _amount);\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal returns (bool) {\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) external returns (bool) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) external returns (bool) {\n        uint allowed_from = allowance[_from][msg.sender];\n        if (allowed_from != type(uint).max) {\n            allowance[_from][msg.sender] -= _value;\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    function mint(address account, uint amount) external returns (bool) {\n        require(msg.sender == minter);\n        _mint(account, amount);\n        return true;\n    }\n\n    function mintToRedemptionReceiver(uint256 amount) external returns (bool) {\n        require(msg.sender == redemptionReceiver);\n        _mint(redemptionReceiver, amount);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./libraries/Math.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IVelo.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\n\n// codifies the minting rules as per ve(3,3), abstracted from the token to support any token that allows minting\n// TODO: decide on whether to abstract from VELO or not. currently it's only somewhat abstracted (e.g. L38)\n\ncontract Minter {\n    uint internal constant WEEK = 86400 * 7; // allows minting once per week (reset every Thursday 00:00 UTC)\n    uint internal constant EMISSION = 990;\n    uint internal constant TAIL_EMISSION = 2;\n    uint internal constant PRECISION = 1000;\n    IVelo public immutable _velo;\n    IVoter public immutable _voter;\n    IVotingEscrow public immutable _ve;\n    IRewardsDistributor public immutable _rewards_distributor;\n    uint public weekly = 15000000e18;\n    uint public active_period;\n    uint internal constant LOCK = 86400 * 7 * 52 * 4;\n\n    address internal initializer;\n    address public team;\n    address public pendingTeam;\n    uint public teamRate;\n    uint public constant MAX_TEAM_RATE = 50; // 50 bps = 0.05%\n\n    event Mint(address indexed sender, uint weekly, uint circulating_supply, uint circulating_emission);\n\n    constructor(\n        address __voter, // the voting & distribution system\n        address __ve, // the ve(3,3) system that will be locked into\n        address __rewards_distributor // the distribution system that ensures users aren't diluted\n    ) {\n        initializer = msg.sender;\n        team = msg.sender;\n        teamRate = 30; // 30 bps = 0.03%\n        _velo = IVelo(IVotingEscrow(__ve).token());\n        _voter = IVoter(__voter);\n        _ve = IVotingEscrow(__ve);\n        _rewards_distributor = IRewardsDistributor(__rewards_distributor);\n        active_period = ((block.timestamp + (2 * WEEK)) / WEEK) * WEEK;\n    }\n\n    function initialize(\n        address[] memory claimants,\n        uint[] memory amounts,\n        uint max // sum amounts / max = % ownership of top protocols, so if initial 20m is distributed, and target is 25% protocol ownership, then max - 4 x 20m = 80m\n    ) external {\n        require(initializer == msg.sender);\n        _velo.mint(address(this), max);\n        _velo.approve(address(_ve), type(uint).max);\n        for (uint i = 0; i < claimants.length; i++) {\n            _ve.create_lock_for(amounts[i], LOCK, claimants[i]);\n        }\n        initializer = address(0);\n        active_period = ((block.timestamp + WEEK) / WEEK) * WEEK;\n    }\n\n    function setTeam(address _team) external {\n        require(msg.sender == team, \"not team\");\n        pendingTeam = _team;\n    }\n\n    function acceptTeam() external {\n        require(msg.sender == pendingTeam, \"not pending team\");\n        team = pendingTeam;\n    }\n\n    function setTeamRate(uint _teamRate) external {\n        require(msg.sender == team, \"not team\");\n        require(_teamRate <= MAX_TEAM_RATE, \"rate too high\");\n        teamRate = _teamRate;\n    }\n\n    // calculate circulating supply as total token supply - locked supply\n    function circulating_supply() public view returns (uint) {\n        return _velo.totalSupply() - _ve.totalSupply();\n    }\n\n    // emission calculation is 2% of available supply to mint adjusted by circulating / total supply\n    function calculate_emission() public view returns (uint) {\n        return weekly * EMISSION * circulating_supply() / PRECISION / _velo.totalSupply();\n    }\n\n    // weekly emission takes the max of calculated (aka target) emission versus circulating tail end emission\n    function weekly_emission() public view returns (uint) {\n        return Math.max(calculate_emission(), circulating_emission());\n    }\n\n    // calculates tail end (infinity) emissions as 0.2% of total supply\n    function circulating_emission() public view returns (uint) {\n        return (circulating_supply() * TAIL_EMISSION) / PRECISION;\n    }\n\n    // calculate inflation and adjust ve balances accordingly\n    function calculate_growth(uint _minted) public view returns (uint) {\n        uint _veTotal = _ve.totalSupply();\n        uint _veloTotal = _velo.totalSupply();\n        return\n            (((((_minted * _veTotal) / _veloTotal) * _veTotal) / _veloTotal) *\n                _veTotal) /\n            _veloTotal /\n            2;\n    }\n\n    // update period can only be called once per cycle (1 week)\n    function update_period() external returns (uint) {\n        uint _period = active_period;\n        if (block.timestamp >= _period + WEEK && initializer == address(0)) { // only trigger if new week\n            _period = (block.timestamp / WEEK) * WEEK;\n            active_period = _period;\n            weekly = weekly_emission();\n\n            uint _growth = calculate_growth(weekly);\n            uint _teamEmissions = (teamRate * (_growth + weekly)) /\n                (PRECISION - teamRate);\n            uint _required = _growth + weekly + _teamEmissions;\n            uint _balanceOf = _velo.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                _velo.mint(address(this), _required - _balanceOf);\n            }\n\n            require(_velo.transfer(team, _teamEmissions));\n            require(_velo.transfer(address(_rewards_distributor), _growth));\n            _rewards_distributor.checkpoint_token(); // checkpoint token balance that was just minted in rewards distributor\n            _rewards_distributor.checkpoint_total_supply(); // checkpoint supply\n\n            _velo.approve(address(_voter), weekly);\n            _voter.notifyRewardAmount(weekly);\n\n            emit Mint(msg.sender, weekly, circulating_supply(), circulating_emission());\n        }\n        return _period;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPairCallee.sol';\nimport './factories/PairFactory.sol';\nimport './PairFees.sol';\n\n// The base pair of pools, either stable or volatile\ncontract Pair {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    // Used to denote stable or volatile pair, not immutable since construction happens in the initialize method for CREATE2 deterministic addresses\n    bool public immutable stable;\n\n    uint public totalSupply = 0;\n\n    mapping(address => mapping (address => uint)) public allowance;\n    mapping(address => uint) public balanceOf;\n\n    bytes32 internal DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n\n    address public immutable token0;\n    address public immutable token1;\n    address public immutable fees;\n    address immutable factory;\n\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint timestamp;\n        uint reserve0Cumulative;\n        uint reserve1Cumulative;\n    }\n\n    // Capture oracle reading every 30 minutes\n    uint constant periodSize = 1800;\n\n    Observation[] public observations;\n\n    uint internal immutable decimals0;\n    uint internal immutable decimals1;\n\n    uint public reserve0;\n    uint public reserve1;\n    uint public blockTimestampLast;\n\n    uint public reserve0CumulativeLast;\n    uint public reserve1CumulativeLast;\n\n    // index0 and index1 are used to accumulate fees, this is split out from normal trades to keep the swap \"clean\"\n    // this further allows LP holders to easily claim fees for tokens they have/staked\n    uint public index0 = 0;\n    uint public index1 = 0;\n\n    // position assigned to each LP to track their current index0 & index1 vs the global position\n    mapping(address => uint) public supplyIndex0;\n    mapping(address => uint) public supplyIndex1;\n\n    // tracks the amount of unclaimed, but claimable tokens off of fees for token0 and token1\n    mapping(address => uint) public claimable0;\n    mapping(address => uint) public claimable1;\n\n    event Fees(address indexed sender, uint amount0, uint amount1);\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint reserve0, uint reserve1);\n    event Claim(address indexed sender, address indexed recipient, uint amount0, uint amount1);\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    constructor() {\n        factory = msg.sender;\n        (address _token0, address _token1, bool _stable) = PairFactory(msg.sender).getInitializable();\n        (token0, token1, stable) = (_token0, _token1, _stable);\n        fees = address(new PairFees(_token0, _token1));\n        if (_stable) {\n            name = string(abi.encodePacked(\"StableV1 AMM - \", IERC20(_token0).symbol(), \"/\", IERC20(_token1).symbol()));\n            symbol = string(abi.encodePacked(\"sAMM-\", IERC20(_token0).symbol(), \"/\", IERC20(_token1).symbol()));\n        } else {\n            name = string(abi.encodePacked(\"VolatileV1 AMM - \", IERC20(_token0).symbol(), \"/\", IERC20(_token1).symbol()));\n            symbol = string(abi.encodePacked(\"vAMM-\", IERC20(_token0).symbol(), \"/\", IERC20(_token1).symbol()));\n        }\n\n        decimals0 = 10**IERC20(_token0).decimals();\n        decimals1 = 10**IERC20(_token1).decimals();\n\n        observations.push(Observation(block.timestamp, 0, 0));\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function observationLength() external view returns (uint) {\n        return observations.length;\n    }\n\n    function lastObservation() public view returns (Observation memory) {\n        return observations[observations.length-1];\n    }\n\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n        return (decimals0, decimals1, reserve0, reserve1, stable, token0, token1);\n    }\n\n    function tokens() external view returns (address, address) {\n        return (token0, token1);\n    }\n\n    // claim accumulated but unclaimed fees (viewable via claimable0 and claimable1)\n    function claimFees() external returns (uint claimed0, uint claimed1) {\n        _updateFor(msg.sender);\n\n        claimed0 = claimable0[msg.sender];\n        claimed1 = claimable1[msg.sender];\n\n        if (claimed0 > 0 || claimed1 > 0) {\n            claimable0[msg.sender] = 0;\n            claimable1[msg.sender] = 0;\n\n            PairFees(fees).claimFeesFor(msg.sender, claimed0, claimed1);\n\n            emit Claim(msg.sender, msg.sender, claimed0, claimed1);\n        }\n    }\n\n    // Accrue fees on token0\n    function _update0(uint amount) internal {\n        _safeTransfer(token0, fees, amount); // transfer the fees out to PairFees\n        uint256 _ratio = amount * 1e18 / totalSupply; // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index0 += _ratio;\n        }\n        emit Fees(msg.sender, amount, 0);\n    }\n\n    // Accrue fees on token1\n    function _update1(uint amount) internal {\n        _safeTransfer(token1, fees, amount);\n        uint256 _ratio = amount * 1e18 / totalSupply;\n        if (_ratio > 0) {\n            index1 += _ratio;\n        }\n        emit Fees(msg.sender, 0, amount);\n    }\n\n    // this function MUST be called on any balance changes, otherwise can be used to infinitely claim fees\n    // Fees are segregated from core funds, so fees can never put liquidity at risk\n    function _updateFor(address recipient) internal {\n        uint _supplied = balanceOf[recipient]; // get LP balance of `recipient`\n        if (_supplied > 0) {\n            uint _supplyIndex0 = supplyIndex0[recipient]; // get last adjusted index0 for recipient\n            uint _supplyIndex1 = supplyIndex1[recipient];\n            uint _index0 = index0; // get global index0 for accumulated fees\n            uint _index1 = index1;\n            supplyIndex0[recipient] = _index0; // update user current position to global position\n            supplyIndex1[recipient] = _index1;\n            uint _delta0 = _index0 - _supplyIndex0; // see if there is any difference that need to be accrued\n            uint _delta1 = _index1 - _supplyIndex1;\n            if (_delta0 > 0) {\n                uint _share = _supplied * _delta0 / 1e18; // add accrued difference for each supplied token\n                claimable0[recipient] += _share;\n            }\n            if (_delta1 > 0) {\n                uint _share = _supplied * _delta1 / 1e18;\n                claimable1[recipient] += _share;\n            }\n        } else {\n            supplyIndex0[recipient] = index0; // new users are set to the default global state\n            supplyIndex1[recipient] = index1;\n        }\n    }\n\n    function getReserves() public view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint _reserve0, uint _reserve1) internal {\n        uint blockTimestamp = block.timestamp;\n        uint timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\n        }\n\n        Observation memory _point = lastObservation();\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\n        if (timeElapsed > periodSize) {\n            observations.push(Observation(blockTimestamp, reserve0CumulativeLast, reserve1CumulativeLast));\n        }\n        reserve0 = balance0;\n        reserve1 = balance1;\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices() public view returns (uint reserve0Cumulative, uint reserve1Cumulative, uint blockTimestamp) {\n        blockTimestamp = block.timestamp;\n        reserve0Cumulative = reserve0CumulativeLast;\n        reserve1Cumulative = reserve1CumulativeLast;\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint _reserve0, uint _reserve1, uint _blockTimestampLast) = getReserves();\n        if (_blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint timeElapsed = blockTimestamp - _blockTimestampLast;\n            reserve0Cumulative += _reserve0 * timeElapsed;\n            reserve1Cumulative += _reserve1 * timeElapsed;\n        }\n    }\n\n    // gives the current twap price measured from amountIn * tokenIn gives amountOut\n    function current(address tokenIn, uint amountIn) external view returns (uint amountOut) {\n        Observation memory _observation = lastObservation();\n        (uint reserve0Cumulative, uint reserve1Cumulative,) = currentCumulativePrices();\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[observations.length-2];\n        }\n\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        uint _reserve0 = (reserve0Cumulative - _observation.reserve0Cumulative) / timeElapsed;\n        uint _reserve1 = (reserve1Cumulative - _observation.reserve1Cumulative) / timeElapsed;\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    // as per `current`, however allows user configured granularity, up to the full window size\n    function quote(address tokenIn, uint amountIn, uint granularity) external view returns (uint amountOut) {\n        uint [] memory _prices = sample(tokenIn, amountIn, granularity, 1);\n        uint priceAverageCumulative;\n        for (uint i = 0; i < _prices.length; i++) {\n            priceAverageCumulative += _prices[i];\n        }\n        return priceAverageCumulative / granularity;\n    }\n\n    // returns a memory set of twap prices\n    function prices(address tokenIn, uint amountIn, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, uint points, uint window) public view returns (uint[] memory) {\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations.length-1;\n        uint i = length - (points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        for (; i < length; i+=window) {\n            nextIndex = i + window;\n            uint timeElapsed = observations[nextIndex].timestamp - observations[i].timestamp;\n            uint _reserve0 = (observations[nextIndex].reserve0Cumulative - observations[i].reserve0Cumulative) / timeElapsed;\n            uint _reserve1 = (observations[nextIndex].reserve1Cumulative - observations[i].reserve1Cumulative) / timeElapsed;\n            _prices[index] = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n            index = index + 1;\n        }\n        return _prices;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // standard uniswap v2 implementation\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        uint _balance0 = IERC20(token0).balanceOf(address(this));\n        uint _balance1 = IERC20(token1).balanceOf(address(this));\n        uint _amount0 = _balance0 - _reserve0;\n        uint _amount1 = _balance1 - _reserve1;\n\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(_amount0 * _totalSupply / _reserve0, _amount1 * _totalSupply / _reserve1);\n        }\n        require(liquidity > 0, 'ILM'); // Pair: INSUFFICIENT_LIQUIDITY_MINTED\n        _mint(to, liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, _amount0, _amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // standard uniswap v2 implementation\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        uint _balance0 = IERC20(_token0).balanceOf(address(this));\n        uint _balance1 = IERC20(_token1).balanceOf(address(this));\n        uint _liquidity = balanceOf[address(this)];\n\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = _liquidity * _balance0 / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = _liquidity * _balance1 / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'ILB'); // Pair: INSUFFICIENT_LIQUIDITY_BURNED\n        _burn(address(this), _liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        _balance0 = IERC20(_token0).balanceOf(address(this));\n        _balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(!PairFactory(factory).isPaused());\n        require(amount0Out > 0 || amount1Out > 0, 'IOA'); // Pair: INSUFFICIENT_OUTPUT_AMOUNT\n        (uint _reserve0, uint _reserve1) =  (reserve0, reserve1);\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'IL'); // Pair: INSUFFICIENT_LIQUIDITY\n\n        uint _balance0;\n        uint _balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        (address _token0, address _token1) = (token0, token1);\n        require(to != _token0 && to != _token1, 'IT'); // Pair: INVALID_TO\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IPairCallee(to).hook(msg.sender, amount0Out, amount1Out, data); // callback, used for flash loans\n        _balance0 = IERC20(_token0).balanceOf(address(this));\n        _balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = _balance0 > _reserve0 - amount0Out ? _balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = _balance1 > _reserve1 - amount1Out ? _balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'IIA'); // Pair: INSUFFICIENT_INPUT_AMOUNT\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        (address _token0, address _token1) = (token0, token1);\n        if (amount0In > 0) _update0(amount0In * PairFactory(factory).getFee(stable) / 10000); // accrue fees for token0 and move them out of pool\n        if (amount1In > 0) _update1(amount1In * PairFactory(factory).getFee(stable) / 10000); // accrue fees for token1 and move them out of pool\n        _balance0 = IERC20(_token0).balanceOf(address(this)); // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\n        _balance1 = IERC20(_token1).balanceOf(address(this));\n        // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\n        require(_k(_balance0, _balance1) >= _k(_reserve0, _reserve1), 'K'); // Pair: K\n        }\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        (address _token0, address _token1) = (token0, token1);\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - (reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - (reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n\n    function _f(uint x0, uint y) internal pure returns (uint) {\n        return x0*(y*y/1e18*y/1e18)/1e18+(x0*x0/1e18*x0/1e18)*y/1e18;\n    }\n\n    function _d(uint x0, uint y) internal pure returns (uint) {\n        return 3*x0*(y*y/1e18)/1e18+(x0*x0/1e18*x0/1e18);\n    }\n\n    function _get_y(uint x0, uint xy, uint y) internal pure returns (uint) {\n        for (uint i = 0; i < 255; i++) {\n            uint y_prev = y;\n            uint k = _f(x0, y);\n            if (k < xy) {\n                uint dy = (xy - k)*1e18/_d(x0, y);\n                y = y + dy;\n            } else {\n                uint dy = (k - xy)*1e18/_d(x0, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function getAmountOut(uint amountIn, address tokenIn) external view returns (uint) {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        amountIn -= amountIn * PairFactory(factory).getFee(stable) / 10000; // remove fee from amount received\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function _getAmountOut(uint amountIn, address tokenIn, uint _reserve0, uint _reserve1) internal view returns (uint) {\n        if (stable) {\n            uint xy =  _k(_reserve0, _reserve1);\n            _reserve0 = _reserve0 * 1e18 / decimals0;\n            _reserve1 = _reserve1 * 1e18 / decimals1;\n            (uint reserveA, uint reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0 ? amountIn * 1e18 / decimals0 : amountIn * 1e18 / decimals1;\n            uint y = reserveB - _get_y(amountIn+reserveA, xy, reserveB);\n            return y * (tokenIn == token0 ? decimals1 : decimals0) / 1e18;\n        } else {\n            (uint reserveA, uint reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n            return amountIn * reserveB / (reserveA + amountIn);\n        }\n    }\n\n    function _k(uint x, uint y) internal view returns (uint) {\n        if (stable) {\n            uint _x = x * 1e18 / decimals0;\n            uint _y = y * 1e18 / decimals1;\n            uint _a = (_x * _y) / 1e18;\n            uint _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return _a * _b / 1e18;  // x3y+y3x >= k\n        } else {\n            return x * y; // xy >= k\n        }\n    }\n\n    function _mint(address dst, uint amount) internal {\n        _updateFor(dst); // balances must be updated on mint/burn/transfer\n        totalSupply += amount;\n        balanceOf[dst] += amount;\n        emit Transfer(address(0), dst, amount);\n    }\n\n    function _burn(address dst, uint amount) internal {\n        _updateFor(dst);\n        totalSupply -= amount;\n        balanceOf[dst] -= amount;\n        emit Transfer(dst, address(0), amount);\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'Pair: EXPIRED');\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Pair: INVALID_SIGNATURE');\n        allowance[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function transfer(address dst, uint amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\n        address spender = msg.sender;\n        uint spenderAllowance = allowance[src][spender];\n\n        if (spender != src && spenderAllowance != type(uint).max) {\n            uint newAllowance = spenderAllowance - amount;\n            allowance[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    function _transferTokens(address src, address dst, uint amount) internal {\n        _updateFor(src); // update fee position for src\n        _updateFor(dst); // update fee position for dst\n\n        balanceOf[src] -= amount;\n        balanceOf[dst] += amount;\n\n        emit Transfer(src, dst, amount);\n    }\n\n    function _safeTransfer(address token,address to,uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Base64} from \"./libraries/Base64.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\n\n/// @title Voting Escrow\n/// @notice veNFT implementation that escrows ERC-20 tokens in the form of an ERC-721 NFT\n/// @notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for)\n/// @author Modified from Solidly (https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol)\n/// @author Modified from Curve (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n/// @author Modified from Nouns DAO (https://github.com/withtally/my-nft-dao-project/blob/main/contracts/ERC721Checkpointable.sol)\n/// @dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (4 years).\ncontract VotingEscrow is IERC721, IERC721Metadata, IVotes {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    struct LockedBalance {\n        int128 amount;\n        uint end;\n    }\n\n    struct Point {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint ts;\n        uint blk; // block\n    }\n    /* We cannot really do block numbers per se b/c slope is per time, not per block\n     * and per block could be fairly bad b/c Ethereum changes blocktimes.\n     * What we can do is to extrapolate ***At functions */\n\n    /// @notice A checkpoint for marking delegated tokenIds from a given timestamp\n    struct Checkpoint {\n        uint timestamp;\n        uint[] tokenIds;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed provider,\n        uint tokenId,\n        uint value,\n        uint indexed locktime,\n        DepositType deposit_type,\n        uint ts\n    );\n    event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\n    event Supply(uint prevSupply, uint supply);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable token;\n    address public voter;\n    mapping(uint => Point) public point_history; // epoch -> unsigned point\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev Current count of token\n    uint internal tokenId;\n\n    /// @notice Contract constructor\n    /// @param token_addr `VELO` token address\n    constructor(address token_addr) {\n        token = token_addr;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev reentrancy guard\n    uint8 internal constant _not_entered = 1;\n    uint8 internal constant _entered = 2;\n    uint8 internal _entered_state = 1;\n    modifier nonreentrant() {\n        require(_entered_state == _not_entered);\n        _entered_state = _entered;\n        _;\n        _entered_state = _not_entered;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string constant public name = \"veNFT\";\n    string constant public symbol = \"veNFT\";\n    string constant public version = \"1.0.0\";\n    uint8 constant public decimals = 18;\n\n    function toString(uint value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function _tokenURI(uint _tokenId, uint _balanceOf, uint _locked_end, uint _value) internal pure returns (string memory output) {\n        output = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width=\"100%\" height=\"100%\" fill=\"black\" /><text x=\"10\" y=\"20\" class=\"base\">';\n        output = string(abi.encodePacked(output, \"token \", toString(_tokenId), '</text><text x=\"10\" y=\"40\" class=\"base\">'));\n        output = string(abi.encodePacked(output, \"balanceOf \", toString(_balanceOf), '</text><text x=\"10\" y=\"60\" class=\"base\">'));\n        output = string(abi.encodePacked(output, \"locked_end \", toString(_locked_end), '</text><text x=\"10\" y=\"80\" class=\"base\">'));\n        output = string(abi.encodePacked(output, \"value \", toString(_value), '</text></svg>'));\n\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\"name\": \"lock #', toString(_tokenId), '\", \"description\": \"Velodrome locks, can be used to boost gauge yields, vote on token emission, and receive bribes\", \"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\"}'))));\n        output = string(abi.encodePacked('data:application/json;base64,', json));\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function tokenURI(uint _tokenId) external view returns (string memory) {\n        require(idToOwner[_tokenId] != address(0), \"Query for nonexistent token\");\n        LockedBalance memory _locked = locked[_tokenId];\n        return\n        _tokenURI(\n            _tokenId,\n            _balanceOfNFT(_tokenId, block.timestamp),\n            _locked.end,\n            uint(int256(_locked.amount))\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal idToOwner;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal ownerToNFTokenCount;\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint _tokenId) public view returns (address) {\n        return idToOwner[_tokenId];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view returns (uint) {\n        return _balance(_owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal idToApprovals;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    mapping(uint => uint) public ownership_change;\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function getApproved(uint _tokenId) external view returns (address) {\n        return idToApprovals[_tokenId];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function approve(address _approved, uint _tokenId) public {\n        address owner = idToOwner[_tokenId];\n        // Throws if `_tokenId` is not a valid NFT\n        require(owner != address(0));\n        // Throws if `_approved` is the current owner\n        require(_approved != owner);\n        // Check requirements\n        bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n        require(senderIsOwner || senderIsApprovedForAll);\n        // Set the approval\n        idToApprovals[_tokenId] = _approved;\n        emit Approval(owner, _approved, _tokenId);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function setApprovalForAll(address _operator, bool _approved) external {\n        // Throws if `_operator` is the `msg.sender`\n        assert(_operator != msg.sender);\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /* TRANSFER FUNCTIONS */\n    /// @dev Clear an approval of a given address\n    ///      Throws if `_owner` is not the current owner.\n    function _clearApproval(address _owner, uint _tokenId) internal {\n        // Throws if `_owner` is not the current owner\n        assert(idToOwner[_tokenId] == _owner);\n        if (idToApprovals[_tokenId] != address(0)) {\n            // Reset approvals\n            idToApprovals[_tokenId] = address(0);\n        }\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\n        address owner = idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function isApprovedOrOwner(address _spender, uint _tokenId) external view returns (bool) {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        address _sender\n    ) internal {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // TODO delegates\n        // auto re-delegate\n        _moveTokenDelegates(delegates(_from), delegates(_to), _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n    ///        they maybe be permanently lost.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        bytes memory _data\n    ) public {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n\n        if (_isContract(_to)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (\n                bytes memory reason\n            ) {\n                if (reason.length == 0) {\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) internal tokenToOwnerIndex;\n\n    /// @dev  Get token by index\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n        uint current_count = _balance(_to);\n\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = current_count;\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _addTokenTo(address _to, uint _tokenId) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(idToOwner[_tokenId] == address(0));\n        // Change the owner\n        idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\n        // Throws if `_to` is zero address\n        assert(_to != address(0));\n        // TODO add delegates\n        // checkpoint for gov\n        _moveTokenDelegates(address(0), delegates(_to), _tokenId);\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _addTokenTo(_to, _tokenId);\n        emit Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n        // Delete\n        uint current_count = _balance(_from) - 1;\n        uint current_index = tokenToOwnerIndex[_tokenId];\n\n        if (current_count == current_index) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = current_index;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\n    function _burn(uint _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // TODO add delegates\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => uint) public user_point_epoch;\n    mapping(uint => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n    mapping(uint => LockedBalance) public locked;\n    uint public epoch;\n    mapping(uint => int128) public slope_changes; // time -> signed slope change\n    uint public supply;\n\n    uint internal constant WEEK = 1 weeks;\n    uint internal constant MAXTIME = 4 * 365 * 86400;\n    int128 internal constant iMAXTIME = 4 * 365 * 86400;\n    uint internal constant MULTIPLIER = 1 ether;\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function get_last_user_slope(uint _tokenId) external view returns (int128) {\n        uint uepoch = user_point_epoch[_tokenId];\n        return user_point_history[_tokenId][uepoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function user_point_history__ts(uint _tokenId, uint _idx) external view returns (uint) {\n        return user_point_history[_tokenId][_idx].ts;\n    }\n\n    /// @notice Get timestamp when `_tokenId`'s lock finishes\n    /// @param _tokenId User NFT\n    /// @return Epoch time of the lock end\n    function locked__end(uint _tokenId) external view returns (uint) {\n        return locked[_tokenId].end;\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param old_locked Pevious locked amount / end lock time for the user\n    /// @param new_locked New locked amount / end lock time for the user\n    function _checkpoint(\n        uint _tokenId,\n        LockedBalance memory old_locked,\n        LockedBalance memory new_locked\n    ) internal {\n        Point memory u_old;\n        Point memory u_new;\n        int128 old_dslope = 0;\n        int128 new_dslope = 0;\n        uint _epoch = epoch;\n\n        if (_tokenId != 0) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\n                u_old.slope = old_locked.amount / iMAXTIME;\n                u_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\n            }\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\n                u_new.slope = new_locked.amount / iMAXTIME;\n                u_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // old_locked.end can be in the past and in the future\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            old_dslope = slope_changes[old_locked.end];\n            if (new_locked.end != 0) {\n                if (new_locked.end == old_locked.end) {\n                    new_dslope = old_dslope;\n                } else {\n                    new_dslope = slope_changes[new_locked.end];\n                }\n            }\n        }\n\n        Point memory last_point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n        if (_epoch > 0) {\n            last_point = point_history[_epoch];\n        }\n        uint last_checkpoint = last_point.ts;\n        // initial_last_point is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initial_last_point = last_point;\n        uint block_slope = 0; // dblock/dt\n        if (block.timestamp > last_point.ts) {\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint t_i = (last_checkpoint / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                t_i += WEEK;\n                int128 d_slope = 0;\n                if (t_i > block.timestamp) {\n                    t_i = block.timestamp;\n                } else {\n                    d_slope = slope_changes[t_i];\n                }\n                last_point.bias -= last_point.slope * int128(int256(t_i - last_checkpoint));\n                last_point.slope += d_slope;\n                if (last_point.bias < 0) {\n                    // This can happen\n                    last_point.bias = 0;\n                }\n                if (last_point.slope < 0) {\n                    // This cannot happen - just in case\n                    last_point.slope = 0;\n                }\n                last_checkpoint = t_i;\n                last_point.ts = t_i;\n                last_point.blk = initial_last_point.blk + (block_slope * (t_i - initial_last_point.ts)) / MULTIPLIER;\n                _epoch += 1;\n                if (t_i == block.timestamp) {\n                    last_point.blk = block.number;\n                    break;\n                } else {\n                    point_history[_epoch] = last_point;\n                }\n            }\n        }\n\n        epoch = _epoch;\n        // Now point_history is filled until t=now\n\n        if (_tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            last_point.slope += (u_new.slope - u_old.slope);\n            last_point.bias += (u_new.bias - u_old.bias);\n            if (last_point.slope < 0) {\n                last_point.slope = 0;\n            }\n            if (last_point.bias < 0) {\n                last_point.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        point_history[_epoch] = last_point;\n\n        if (_tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (old_locked.end > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                old_dslope += u_old.slope;\n                if (new_locked.end == old_locked.end) {\n                    old_dslope -= u_new.slope; // It was a new deposit, not extension\n                }\n                slope_changes[old_locked.end] = old_dslope;\n            }\n\n            if (new_locked.end > block.timestamp) {\n                if (new_locked.end > old_locked.end) {\n                    new_dslope -= u_new.slope; // old slope disappeared at this point\n                    slope_changes[new_locked.end] = new_dslope;\n                }\n                // else: we recorded it already in old_dslope\n            }\n            // Now handle user history\n            uint user_epoch = user_point_epoch[_tokenId] + 1;\n\n            user_point_epoch[_tokenId] = user_epoch;\n            u_new.ts = block.timestamp;\n            u_new.blk = block.number;\n            user_point_history[_tokenId][user_epoch] = u_new;\n        }\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    /// @param locked_balance Previous locked amount / timestamp\n    /// @param deposit_type The type of deposit\n    function _deposit_for(\n        uint _tokenId,\n        uint _value,\n        uint unlock_time,\n        LockedBalance memory locked_balance,\n        DepositType deposit_type\n    ) internal {\n        LockedBalance memory _locked = locked_balance;\n        uint supply_before = supply;\n\n        supply = supply_before + _value;\n        LockedBalance memory old_locked;\n        (old_locked.amount, old_locked.end) = (_locked.amount, _locked.end);\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        _locked.amount += int128(int256(_value));\n        if (unlock_time != 0) {\n            _locked.end = unlock_time;\n        }\n        locked[_tokenId] = _locked;\n\n        // Possibilities:\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n        _checkpoint(_tokenId, old_locked, _locked);\n\n        address from = msg.sender;\n        if (_value != 0 && deposit_type != DepositType.MERGE_TYPE) {\n            assert(IERC20(token).transferFrom(from, address(this), _value));\n        }\n\n        emit Deposit(from, _tokenId, _value, _locked.end, deposit_type, block.timestamp);\n        emit Supply(supply_before, supply_before + _value);\n    }\n\n    function block_number() external view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Record global data to checkpoint\n    function checkpoint() external {\n        _checkpoint(0, LockedBalance(0, 0), LockedBalance(0, 0));\n    }\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function deposit_for(uint _tokenId, uint _value) external nonreentrant {\n        LockedBalance memory _locked = locked[_tokenId];\n\n        require(_value > 0); // dev: need non-zero value\n        require(_locked.amount > 0, 'No existing lock found');\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _create_lock(uint _value, uint _lock_duration, address _to) internal returns (uint) {\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_value > 0); // dev: need non-zero value\n        require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n        ++tokenId;\n        uint _tokenId = tokenId;\n        _mint(_to, _tokenId);\n\n        _deposit_for(_tokenId, _value, unlock_time, locked[_tokenId], DepositType.CREATE_LOCK_TYPE);\n        return _tokenId;\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    function create_lock(uint _value, uint _lock_duration) external nonreentrant returns (uint) {\n        return _create_lock(_value, _lock_duration, msg.sender);\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external nonreentrant returns (uint) {\n        return _create_lock(_value, _lock_duration, _to);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function increase_amount(uint _tokenId, uint _value) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n        LockedBalance memory _locked = locked[_tokenId];\n\n        assert(_value > 0); // dev: need non-zero value\n        require(_locked.amount > 0, 'No existing lock found');\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _lock_duration New number of seconds until tokens unlock\n    function increase_unlock_time(uint _tokenId, uint _lock_duration) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n        LockedBalance memory _locked = locked[_tokenId];\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_locked.end > block.timestamp, 'Lock expired');\n        require(_locked.amount > 0, 'Nothing is locked');\n        require(unlock_time > _locked.end, 'Can only increase lock duration');\n        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n        _deposit_for(_tokenId, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\n    }\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(uint _tokenId) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n\n        LockedBalance memory _locked = locked[_tokenId];\n        require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n        uint value = uint(int256(_locked.amount));\n\n        locked[_tokenId] = LockedBalance(0,0);\n        uint supply_before = supply;\n        supply = supply_before - value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(_tokenId, _locked, LockedBalance(0,0));\n\n        assert(IERC20(token).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _burn(_tokenId);\n\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\n        emit Supply(supply_before, supply_before - value);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    /// @notice Binary search to estimate timestamp for block number\n    /// @param _block Block to find\n    /// @param max_epoch Don't go beyond this epoch\n    /// @return Approximate timestamp for block\n    function _find_block_epoch(uint _block, uint max_epoch) internal view returns (uint) {\n        // Binary search\n        uint _min = 0;\n        uint _max = max_epoch;\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (point_history[_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    /// @notice Get the current voting power for `_tokenId`\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    /// @param _tokenId NFT for lock\n    /// @param _t Epoch time to return voting power at\n    /// @return User voting power\n    function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\n        uint _epoch = user_point_epoch[_tokenId];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory last_point = user_point_history[_tokenId][_epoch];\n            last_point.bias -= last_point.slope * int128(int256(_t) - int256(last_point.ts));\n            if (last_point.bias < 0) {\n                last_point.bias = 0;\n            }\n            return uint(int256(last_point.bias));\n        }\n    }\n\n    function balanceOfNFT(uint _tokenId) external view returns (uint) {\n        if (ownership_change[_tokenId] == block.number) return 0;\n        return _balanceOfNFT(_tokenId, block.timestamp);\n    }\n\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\n        return _balanceOfNFT(_tokenId, _t);\n    }\n\n    /// @notice Measure voting power of `_tokenId` at block height `_block`\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n    /// @param _tokenId User's wallet NFT\n    /// @param _block Block to calculate the voting power at\n    /// @return Voting power\n    function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\n        // Copying and pasting totalSupply code because Vyper cannot pass by\n        // reference yet\n        assert(_block <= block.number);\n\n        // Binary search\n        uint _min = 0;\n        uint _max = user_point_epoch[_tokenId];\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (user_point_history[_tokenId][_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n\n        Point memory upoint = user_point_history[_tokenId][_min];\n\n        uint max_epoch = epoch;\n        uint _epoch = _find_block_epoch(_block, max_epoch);\n        Point memory point_0 = point_history[_epoch];\n        uint d_block = 0;\n        uint d_t = 0;\n        if (_epoch < max_epoch) {\n            Point memory point_1 = point_history[_epoch + 1];\n            d_block = point_1.blk - point_0.blk;\n            d_t = point_1.ts - point_0.ts;\n        } else {\n            d_block = block.number - point_0.blk;\n            d_t = block.timestamp - point_0.ts;\n        }\n        uint block_time = point_0.ts;\n        if (d_block != 0) {\n            block_time += (d_t * (_block - point_0.blk)) / d_block;\n        }\n\n        upoint.bias -= upoint.slope * int128(int256(block_time - upoint.ts));\n        if (upoint.bias >= 0) {\n            return uint(uint128(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\n        return _balanceOfAtNFT(_tokenId, _block);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function totalSupplyAt(uint _block) external view returns (uint) {\n        assert(_block <= block.number);\n        uint _epoch = epoch;\n        uint target_epoch = _find_block_epoch(_block, _epoch);\n\n        Point memory point = point_history[target_epoch];\n        uint dt = 0;\n        if (target_epoch < _epoch) {\n            Point memory point_next = point_history[target_epoch + 1];\n            if (point.blk != point_next.blk) {\n                dt = ((_block - point.blk) * (point_next.ts - point.ts)) / (point_next.blk - point.blk);\n            }\n        } else {\n            if (point.blk != block.number) {\n                dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\n            }\n        }\n        // Now dt contains info on how far are we beyond point\n        return _supply_at(point, point.ts + dt);\n    }\n    /// @notice Calculate total voting power at some point in the past\n    /// @param point The point (bias/slope) to start search from\n    /// @param t Time to calculate the total voting power at\n    /// @return Total voting power at that time\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\n        Point memory last_point = point;\n        uint t_i = (last_point.ts / WEEK) * WEEK;\n        for (uint i = 0; i < 255; ++i) {\n            t_i += WEEK;\n            int128 d_slope = 0;\n            if (t_i > t) {\n                t_i = t;\n            } else {\n                d_slope = slope_changes[t_i];\n            }\n            last_point.bias -= last_point.slope * int128(int256(t_i - last_point.ts));\n            if (t_i == t) {\n                break;\n            }\n            last_point.slope += d_slope;\n            last_point.ts = t_i;\n        }\n\n        if (last_point.bias < 0) {\n            last_point.bias = 0;\n        }\n        return uint(uint128(last_point.bias));\n    }\n\n    function totalSupply() external view returns (uint) {\n        return totalSupplyAtT(block.timestamp);\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function totalSupplyAtT(uint t) public view returns (uint) {\n        uint _epoch = epoch;\n        Point memory last_point = point_history[_epoch];\n        return _supply_at(last_point, t);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => uint) public attachments;\n    mapping(uint => bool) public voted;\n\n    function setVoter(address _voter) external {\n        require(msg.sender == voter);\n        voter = _voter;\n    }\n\n    function voting(uint _tokenId) external {\n        require(msg.sender == voter);\n        voted[_tokenId] = true;\n    }\n\n    function abstain(uint _tokenId) external {\n        require(msg.sender == voter);\n        voted[_tokenId] = false;\n    }\n\n    function attach(uint _tokenId) external {\n        require(msg.sender == voter);\n        attachments[_tokenId] = attachments[_tokenId] + 1;\n    }\n\n    function detach(uint _tokenId) external {\n        require(msg.sender == voter);\n        attachments[_tokenId] = attachments[_tokenId] - 1;\n    }\n\n    function merge(uint _from, uint _to) external {\n        require(attachments[_from] == 0 && !voted[_from], \"attached\");\n        require(_from != _to);\n        require(_isApprovedOrOwner(msg.sender, _from));\n        require(_isApprovedOrOwner(msg.sender, _to));\n\n        LockedBalance memory _locked0 = locked[_from];\n        LockedBalance memory _locked1 = locked[_to];\n        uint value0 = uint(int256(_locked0.amount));\n        uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = LockedBalance(0, 0);\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\n        _burn(_from);\n        _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) private _delegates;\n    uint public constant MAX_DELEGATES = 1024; // avoid too much gas\n\n    /// @notice A record of delegated token checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint) public nonces;\n\n    /**\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\n     * the delegator's own address if they haven't delegated.\n     * This avoids having to delegate to oneself.\n     */\n    function delegates(address delegator) public view returns (address) {\n        address current = _delegates[delegator];\n        return current == address(0) ? delegator : current;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(address account) external view returns (uint) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n        uint[] storage _tokenIds = checkpoints[account][nCheckpoints - 1].tokenIds;\n        uint votes = 0;\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint tId = _tokenIds[i];\n            votes = votes + _balanceOfNFT(tId, block.timestamp);\n        }\n        return votes;\n    }\n\n    function getPastVotesIndex(address account, uint timestamp) public view returns (uint32) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint storage cp = checkpoints[account][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPastVotes(address account, uint timestamp)\n        public\n        view\n        returns (uint)\n    {\n        uint32 _checkIndex = getPastVotesIndex(account, timestamp);\n        // Sum votes\n        uint[] storage _tokenIds = checkpoints[account][_checkIndex].tokenIds;\n        uint votes = 0;\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint tId = _tokenIds[i];\n            // Use the provided input timestamp here to get the right decay\n            votes = votes + _balanceOfNFT(tId, timestamp);\n        }\n        return votes;\n    }\n\n    function getPastTotalSupply(uint256 timestamp) external view returns (uint) {\n        return totalSupplyAtT(timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _moveTokenDelegates(\n        address srcRep,\n        address dstRep,\n        uint _tokenId\n    ) internal {\n        if (srcRep != dstRep && _tokenId > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint[] storage srcRepOld = srcRepNum > 0\n                    ? checkpoints[srcRep][srcRepNum - 1].tokenIds\n                    : checkpoints[srcRep][0].tokenIds;\n                uint32 nextSrcRepNum = _findWhatCheckpointToWrite(srcRep);\n                uint[] storage srcRepNew = checkpoints[srcRep][\n                    nextSrcRepNum\n                ].tokenIds;\n                // All the same except _tokenId\n                for (uint i = 0; i < srcRepOld.length; i++) {\n                    uint tId = srcRepOld[i];\n                    if (tId != _tokenId) {\n                        srcRepNew.push(tId);\n                    }\n                }\n\n                numCheckpoints[srcRep] = srcRepNum + 1;\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint[] storage dstRepOld = dstRepNum > 0\n                    ? checkpoints[dstRep][dstRepNum - 1].tokenIds\n                    : checkpoints[dstRep][0].tokenIds;\n                uint32 nextDstRepNum = _findWhatCheckpointToWrite(dstRep);\n                uint[] storage dstRepNew = checkpoints[dstRep][\n                    nextDstRepNum\n                ].tokenIds;\n                // All the same plus _tokenId\n                require(\n                    dstRepOld.length + 1 <= MAX_DELEGATES,\n                    \"dstRep would have too many tokenIds\"\n                );\n                for (uint i = 0; i < dstRepOld.length; i++) {\n                    uint tId = dstRepOld[i];\n                    dstRepNew.push(tId);\n                }\n                dstRepNew.push(_tokenId);\n\n                numCheckpoints[dstRep] = dstRepNum + 1;\n            }\n        }\n    }\n\n    function _findWhatCheckpointToWrite(address account)\n        internal\n        view\n        returns (uint32)\n    {\n        uint _timestamp = block.timestamp;\n        uint32 _nCheckPoints = numCheckpoints[account];\n\n        if (\n            _nCheckPoints > 0 &&\n            checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp\n        ) {\n            return _nCheckPoints - 1;\n        } else {\n            return _nCheckPoints;\n        }\n    }\n\n    function _moveAllDelegates(\n        address owner,\n        address srcRep,\n        address dstRep\n    ) internal {\n        // You can only redelegate what you own\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint[] storage srcRepOld = srcRepNum > 0\n                    ? checkpoints[srcRep][srcRepNum - 1].tokenIds\n                    : checkpoints[srcRep][0].tokenIds;\n                uint32 nextSrcRepNum = _findWhatCheckpointToWrite(srcRep);\n                uint[] storage srcRepNew = checkpoints[srcRep][\n                    nextSrcRepNum\n                ].tokenIds;\n                // All the same except what owner owns\n                for (uint i = 0; i < srcRepOld.length; i++) {\n                    uint tId = srcRepOld[i];\n                    if (idToOwner[tId] != owner) {\n                        srcRepNew.push(tId);\n                    }\n                }\n\n                numCheckpoints[srcRep] = srcRepNum + 1;\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint[] storage dstRepOld = dstRepNum > 0\n                    ? checkpoints[dstRep][dstRepNum - 1].tokenIds\n                    : checkpoints[dstRep][0].tokenIds;\n                uint32 nextDstRepNum = _findWhatCheckpointToWrite(dstRep);\n                uint[] storage dstRepNew = checkpoints[dstRep][\n                    nextDstRepNum\n                ].tokenIds;\n                uint ownerTokenCount = ownerToNFTokenCount[owner];\n                require(\n                    dstRepOld.length + ownerTokenCount <= MAX_DELEGATES,\n                    \"dstRep would have too many tokenIds\"\n                );\n                // All the same\n                for (uint i = 0; i < dstRepOld.length; i++) {\n                    uint tId = dstRepOld[i];\n                    dstRepNew.push(tId);\n                }\n                // Plus all that's owned\n                for (uint i = 0; i < ownerTokenCount; i++) {\n                    uint tId = ownerToNFTokenIdList[owner][i];\n                    dstRepNew.push(tId);\n                }\n\n                numCheckpoints[dstRep] = dstRepNum + 1;\n            }\n        }\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n        address currentDelegate = delegates(delegator);\n\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveAllDelegates(delegator, currentDelegate, delegatee);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        if (delegatee == address(0)) delegatee = msg.sender;\n        return _delegate(msg.sender, delegatee);\n    }\n\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        address signatory = ecrecover(digest, v, r, s);\n        require(\n            signatory != address(0),\n            \"VotingEscrow::delegateBySig: invalid signature\"\n        );\n        require(\n            nonce == nonces[signatory]++,\n            \"VotingEscrow::delegateBySig: invalid nonce\"\n        );\n        require(\n            block.timestamp <= expiry,\n            \"VotingEscrow::delegateBySig: signature expired\"\n        );\n        return _delegate(signatory, delegatee);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n/*\n\n@title Curve Fee Distribution modified for ve(3,3) emissions\n@author Curve Finance, andrecronje\n@license MIT\n\n*/\n\ncontract RewardsDistributor {\n\n    event CheckpointToken(\n        uint time,\n        uint tokens\n    );\n\n    event Claimed(\n        uint tokenId,\n        uint amount,\n        uint claim_epoch,\n        uint max_epoch\n    );\n\n    uint constant WEEK = 7 * 86400;\n\n    uint public start_time;\n    uint public time_cursor;\n    mapping(uint => uint) public time_cursor_of;\n    mapping(uint => uint) public user_epoch_of;\n\n    uint public last_token_time;\n    uint[1000000000000000] public tokens_per_week;\n\n    address public voting_escrow;\n    address public token;\n    uint public token_last_balance;\n\n    uint[1000000000000000] public ve_supply;\n\n    address public depositor;\n\n    constructor(address _voting_escrow) {\n        uint _t = block.timestamp / WEEK * WEEK;\n        start_time = _t;\n        last_token_time = _t;\n        time_cursor = _t;\n        address _token = IVotingEscrow(_voting_escrow).token();\n        token = _token;\n        voting_escrow = _voting_escrow;\n        depositor = msg.sender;\n        IERC20(_token).approve(_voting_escrow, type(uint).max);\n    }\n\n    function timestamp() external view returns (uint) {\n        return block.timestamp / WEEK * WEEK;\n    }\n\n    function _checkpoint_token() internal {\n        uint token_balance = IERC20(token).balanceOf(address(this));\n        uint to_distribute = token_balance - token_last_balance;\n        token_last_balance = token_balance;\n\n        uint t = last_token_time;\n        uint since_last = block.timestamp - t;\n        last_token_time = block.timestamp;\n        uint this_week = t / WEEK * WEEK;\n        uint next_week = 0;\n\n        for (uint i = 0; i < 20; i++) {\n            next_week = this_week + WEEK;\n            if (block.timestamp < next_week) {\n                if (since_last == 0 && block.timestamp == t) {\n                    tokens_per_week[this_week] += to_distribute;\n                } else {\n                    tokens_per_week[this_week] += to_distribute * (block.timestamp - t) / since_last;\n                }\n                break;\n            } else {\n                if (since_last == 0 && next_week == t) {\n                    tokens_per_week[this_week] += to_distribute;\n                } else {\n                    tokens_per_week[this_week] += to_distribute * (next_week - t) / since_last;\n                }\n            }\n            t = next_week;\n            this_week = next_week;\n        }\n        emit CheckpointToken(block.timestamp, to_distribute);\n    }\n\n    function checkpoint_token() external {\n        assert(msg.sender == depositor);\n        _checkpoint_token();\n    }\n\n    function _find_timestamp_epoch(address ve, uint _timestamp) internal view returns (uint) {\n        uint _min = 0;\n        uint _max = IVotingEscrow(ve).epoch();\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(_mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function _find_timestamp_user_epoch(address ve, uint tokenId, uint _timestamp, uint max_user_epoch) internal view returns (uint) {\n        uint _min = 0;\n        uint _max = max_user_epoch;\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).user_point_history(tokenId, _mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid -1;\n            }\n        }\n        return _min;\n    }\n\n    function ve_for_at(uint _tokenId, uint _timestamp) external view returns (uint) {\n        address ve = voting_escrow;\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint epoch = _find_timestamp_user_epoch(ve, _tokenId, _timestamp, max_user_epoch);\n        IVotingEscrow.Point memory pt = IVotingEscrow(ve).user_point_history(_tokenId, epoch);\n        return Math.max(uint(int256(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))), 0);\n    }\n\n    function _checkpoint_total_supply() internal {\n        address ve = voting_escrow;\n        uint t = time_cursor;\n        uint rounded_timestamp = block.timestamp / WEEK * WEEK;\n        IVotingEscrow(ve).checkpoint();\n\n        for (uint i = 0; i < 20; i++) {\n            if (t > rounded_timestamp) {\n                break;\n            } else {\n                uint epoch = _find_timestamp_epoch(ve, t);\n                IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(epoch);\n                int128 dt = 0;\n                if (t > pt.ts) {\n                    dt = int128(int256(t - pt.ts));\n                }\n                ve_supply[t] = Math.max(uint(int256(pt.bias - pt.slope * dt)), 0);\n            }\n            t += WEEK;\n        }\n        time_cursor = t;\n    }\n\n    function checkpoint_total_supply() external {\n        _checkpoint_total_supply();\n    }\n\n    function _claim(uint _tokenId, address ve, uint _last_token_time) internal returns (uint) {\n        uint user_epoch = 0;\n        uint to_distribute = 0;\n\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint _start_time = start_time;\n\n        if (max_user_epoch == 0) return 0;\n\n        uint week_cursor = time_cursor_of[_tokenId];\n        if (week_cursor == 0) {\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\n        } else {\n            user_epoch = user_epoch_of[_tokenId];\n        }\n\n        if (user_epoch == 0) user_epoch = 1;\n\n        IVotingEscrow.Point memory user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n\n        if (week_cursor == 0) week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK;\n        if (week_cursor >= last_token_time) return 0;\n        if (week_cursor < _start_time) week_cursor = _start_time;\n\n        IVotingEscrow.Point memory old_user_point;\n\n        for (uint i = 0; i < 50; i++) {\n            if (week_cursor >= _last_token_time) break;\n\n            if (week_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\n                user_epoch += 1;\n                old_user_point = user_point;\n                if (user_epoch > max_user_epoch) {\n                    user_point = IVotingEscrow.Point(0,0,0,0);\n                } else {\n                    user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n                }\n            } else {\n                int128 dt = int128(int256(week_cursor - old_user_point.ts));\n                uint balance_of = Math.max(uint(int256(old_user_point.bias - dt * old_user_point.slope)), 0);\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\n                if (balance_of != 0) {\n                    to_distribute += balance_of * tokens_per_week[week_cursor] / ve_supply[week_cursor];\n                }\n                week_cursor += WEEK;\n            }\n        }\n\n        user_epoch = Math.min(max_user_epoch, user_epoch - 1);\n        user_epoch_of[_tokenId] = user_epoch;\n        time_cursor_of[_tokenId] = week_cursor;\n\n        emit Claimed(_tokenId, to_distribute, user_epoch, max_user_epoch);\n\n        return to_distribute;\n    }\n\n    function _claimable(uint _tokenId, address ve, uint _last_token_time) internal view returns (uint) {\n        uint user_epoch = 0;\n        uint to_distribute = 0;\n\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint _start_time = start_time;\n\n        if (max_user_epoch == 0) return 0;\n\n        uint week_cursor = time_cursor_of[_tokenId];\n        if (week_cursor == 0) {\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\n        } else {\n            user_epoch = user_epoch_of[_tokenId];\n        }\n\n        if (user_epoch == 0) user_epoch = 1;\n\n        IVotingEscrow.Point memory user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n\n        if (week_cursor == 0) week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK;\n        if (week_cursor >= last_token_time) return 0;\n        if (week_cursor < _start_time) week_cursor = _start_time;\n\n        IVotingEscrow.Point memory old_user_point;\n\n        for (uint i = 0; i < 50; i++) {\n            if (week_cursor >= _last_token_time) break;\n\n            if (week_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\n                user_epoch += 1;\n                old_user_point = user_point;\n                if (user_epoch > max_user_epoch) {\n                    user_point = IVotingEscrow.Point(0,0,0,0);\n                } else {\n                    user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n                }\n            } else {\n                int128 dt = int128(int256(week_cursor - old_user_point.ts));\n                uint balance_of = Math.max(uint(int256(old_user_point.bias - dt * old_user_point.slope)), 0);\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\n                if (balance_of != 0) {\n                    to_distribute += balance_of * tokens_per_week[week_cursor] / ve_supply[week_cursor];\n                }\n                week_cursor += WEEK;\n            }\n        }\n\n        return to_distribute;\n    }\n\n    function claimable(uint _tokenId) external view returns (uint) {\n        uint _last_token_time = last_token_time / WEEK * WEEK;\n        return _claimable(_tokenId, voting_escrow, _last_token_time);\n    }\n\n    function claim(uint _tokenId) external returns (uint) {\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\n        uint _last_token_time = last_token_time;\n        _last_token_time = _last_token_time / WEEK * WEEK;\n        uint amount = _claim(_tokenId, voting_escrow, _last_token_time);\n        if (amount != 0) {\n            IVotingEscrow(voting_escrow).deposit_for(_tokenId, amount);\n            token_last_balance -= amount;\n        }\n        return amount;\n    }\n\n    function claim_many(uint[] memory _tokenIds) external returns (bool) {\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\n        uint _last_token_time = last_token_time;\n        _last_token_time = _last_token_time / WEEK * WEEK;\n        address _voting_escrow = voting_escrow;\n        uint total = 0;\n\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint _tokenId = _tokenIds[i];\n            if (_tokenId == 0) break;\n            uint amount = _claim(_tokenId, _voting_escrow, _last_token_time);\n            if (amount != 0) {\n                IVotingEscrow(_voting_escrow).deposit_for(_tokenId, amount);\n                total += amount;\n            }\n        }\n        if (total != 0) {\n            token_last_balance -= total;\n        }\n\n        return true;\n    }\n\n    // Once off event on contract initialize\n    function setDepositor(address _depositor) external {\n        require(msg.sender == depositor);\n        depositor = _depositor;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {\n                _notifyBribeAmount(token, epochRewards, bribeStart);\n            }\n        }\n    }\n\n    function setVoteStatus(address account, bool voted) external {\n        require(msg.sender == voter);\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            checkpoints[account][0] = Checkpoint(block.timestamp, 0, voted);\n            numCheckpoints[account] = 1;\n        } else {\n            checkpoints[account][nCheckpoints - 1].voted = voted;\n        }\n    }\n\n    /**\n    * @notice Determine the prior balance for an account as of a block number\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    * @param account The address of the account to check\n    * @param timestamp The timestamp to get the balance at\n    * @return The balance the account had as of the given block\n    */\n    function getPriorBalanceIndex(address account, uint timestamp) public view returns (uint) {\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\n        uint nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (supplyCheckpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\n        if (nCheckpoints == 0) {\n            return (0,0);\n        }\n\n        // First check most recent balance\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\n        }\n\n        // Next check implicit zero balance\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\n            return (0,0);\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\n            if (cp.timestamp == timestamp) {\n                return (cp.rewardPerToken, cp.timestamp);\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\n    }\n\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\n\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\n        } else {\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint _nCheckPoints = supplyNumCheckpoints;\n        uint _timestamp = block.timestamp;\n\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\n            supplyCheckpoints[_nCheckPoints - 1].supply = derivedSupply;\n        } else {\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, derivedSupply);\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n\n    function rewardsListLength() external view returns (uint) {\n        return rewards.length;\n    }\n\n    // returns the last time the reward was modified or periodFinish if the reward has ended\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish[token]);\n    }\n\n    function getReward(address account, address[] memory tokens) external lock {\n        require(msg.sender == account || msg.sender == voter);\n        _unlocked = 1;\n        IVoter(voter).distribute(address(this));\n        _unlocked = 2;\n\n        for (uint i = 0; i < tokens.length; i++) {\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\n\n            uint _reward = earned(tokens[i], account);\n            lastEarn[tokens[i]][account] = block.timestamp;\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[tokens[i]];\n            if (_reward > 0) _safeTransfer(tokens[i], account, _reward);\n\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\n        }\n\n        uint _derivedBalance = derivedBalances[account];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(account, derivedBalances[account]);\n        _writeSupplyCheckpoint();\n    }\n\n\n    function rewardPerToken(address token) public view returns (uint) {\n        if (derivedSupply == 0) {\n            return rewardPerTokenStored[token];\n        }\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\n    }\n\n    function derivedBalance(address account) public view returns (uint) {\n        return balanceOf[account];\n    }\n\n    function batchRewardPerToken(address token, uint maxRuns) external {\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\n    }\n\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\n\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n            if (sp0.supply > 0) {\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                reward += _reward;\n                _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                _startTimestamp = _endTime;\n            }\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\n        uint endTime = Math.max(timestamp1, startTimestamp);\n        return (((Math.min(endTime, periodFinish[token]) - Math.min(Math.max(timestamp0, startTimestamp), periodFinish[token])) * rewardRate[token] * PRECISION / supply), endTime);\n    }\n\n    function _updateRewardForAllTokens() internal {\n        uint length = rewards.length;\n        for (uint i; i < length; i++) {\n            address token = rewards[i];\n            (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        }\n    }\n\n    function _updateRewardPerToken(address token) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = supplyNumCheckpoints-1;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n                if (sp0.supply > 0) {\n                    SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                    reward += _reward;\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                    _startTimestamp = _endTime;\n                }\n            }\n        }\n\n        SupplyCheckpoint memory sp = supplyCheckpoints[_endIndex];\n        if (sp.supply > 0) {\n            (uint _reward,) = _calcRewardPerToken(token, lastTimeRewardApplicable(token), Math.max(sp.timestamp, _startTimestamp), sp.supply, _startTimestamp);\n            reward += _reward;\n            _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\n            _startTimestamp = block.timestamp;\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    // earned is an estimation, it won't be exact till the supply > rewardPerToken calculations have run\n    function earned(address token, address account) public view returns (uint) {\n        uint _startTimestamp = Math.max(lastEarn[token][account], rewardPerTokenCheckpoints[token][0].timestamp);\n        if (numCheckpoints[account] == 0) {\n            return 0;\n        }\n\n        uint _startIndex = getPriorBalanceIndex(account, _startTimestamp);\n        uint _endIndex = numCheckpoints[account]-1;\n\n        uint reward = 0;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp - (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp > lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n\n        return reward;\n    }\n\n    function depositAll(uint tokenId) external {\n        deposit(IERC20(stake).balanceOf(msg.sender), tokenId);\n    }\n\n    function deposit(uint amount, uint tokenId) public lock {\n        require(amount > 0);\n\n        _updateRewardForAllTokens();\n\n        _safeTransferFrom(stake, msg.sender, address(this), amount);\n        totalSupply += amount;\n        balanceOf[msg.sender] += amount;\n\n        if (tokenId > 0) {\n            require(IVotingEscrow(_ve).ownerOf(tokenId) == msg.sender);\n            if (tokenIds[msg.sender] == 0) {\n                tokenIds[msg.sender] = tokenId;\n                IVoter(voter).attachTokenToGauge(tokenId, msg.sender);\n            }\n            require(tokenIds[msg.sender] == tokenId);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, _derivedBalance);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitDeposit(tokenId, msg.sender, amount);\n        emit Deposit(msg.sender, tokenId, amount);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf[msg.sender]);\n    }\n\n    function withdraw(uint amount) public {\n        _updateRewardForAllTokens();\n\n        uint tokenId = 0;\n        if (amount == balanceOf[msg.sender]) {\n            tokenId = tokenIds[msg.sender];\n        }\n        withdrawToken(amount, tokenId);\n    }\n\n    function withdrawToken(uint amount, uint tokenId) public lock {\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n\n        if (tokenId > 0) {\n            require(tokenId == tokenIds[msg.sender]);\n            tokenIds[msg.sender] = 0;\n            IVoter(voter).detachTokenFromGauge(tokenId, msg.sender);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, derivedBalances[msg.sender]);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitWithdraw(tokenId, msg.sender, amount);\n        emit Withdraw(msg.sender, tokenId, amount);\n    }\n\n    function left(address token) external view returns (uint) {\n        if (block.timestamp >= periodFinish[token]) return 0;\n        uint _remaining = periodFinish[token] - block.timestamp;\n        return _remaining * rewardRate[token];\n    }\n\n    function notifyRewardAmount(address token, uint amount) external lock {\n        require(token != stake);\n        require(amount > 0);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n        }\n        // rewards accrue only during the bribe period\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;\n        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);\n        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        _claimFees();\n\n        if (block.timestamp >= periodFinish[token]) {\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n        require(rewardRate[token] > 0);\n        uint balance = IERC20(token).balanceOf(address(this));\n        require(rewardRate[token] <= balance / DURATION, \"Provided reward too high\");\n        periodFinish[token] = adjustedTstamp + DURATION;\n        if (!isReward[token]) {\n            isReward[token] = true;\n            rewards.push(token);\n            IBribe(bribe).addRewardToken(token);\n        }\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        require(rewards[i] == oldToken);\n        isReward[oldToken] = false;\n        isReward[newToken] = true;\n        rewards[i] = newToken;\n    }\n\n    function swapOutBribeRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        IBribe(bribe).swapOutRewardToken(i, oldToken, newToken);\n    }\n\n    function addBribeRewardToken(address token) external {\n        require(msg.sender == bribe);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n            isReward[token] = true;\n            rewards.push(token);\n        }\n    }\n\n    function _notifyBribeAmount(address token, uint amount, uint epochStart) internal {\n        if (block.timestamp >= periodFinish[token]) {\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n\n        lastUpdateTime[token] = epochStart;\n        periodFinish[token] = epochStart + DURATION;\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeApprove(address token, address spender, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGauge.sol';\n\ncontract Bribe is IBribe {\n  uint internal constant DURATION = 5 days; // rewards are released over the voting period\n  uint internal constant BRIBE_LAG = 1 days;\n  uint internal constant COOLDOWN = 12 hours;\n  uint internal constant MAX_REWARD_TOKENS = 16;\n\n  address public gauge;\n  mapping(address => mapping(uint => uint)) public tokenRewardsPerEpoch;\n  address[] public rewards;\n  mapping(address => bool) public isReward;\n\n  event NotifyReward(address indexed from, address indexed reward, uint epoch, uint amount);\n\n  // simple re-entrancy check\n  uint internal _unlocked = 1;\n  modifier lock() {\n      require(_unlocked == 1);\n      _unlocked = 2;\n      _;\n      _unlocked = 1;\n  }\n\n  function setGauge(address _gauge) external {\n    require(gauge == address(0), \"gauge already set\");\n    gauge = _gauge;\n  }\n\n  function getEpochStart(uint timestamp) public view returns (uint) {\n    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;\n    uint bribeEnd = bribeStart + DURATION - COOLDOWN;\n    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n  }\n\n  function notifyRewardAmount(address token, uint amount) external lock {\n      require(amount > 0);\n      if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      }\n      // bribes kick in at the start of next bribe period\n      uint adjustedTstamp = getEpochStart(block.timestamp);\n      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n      _safeTransferFrom(token, msg.sender, address(this), amount);\n      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n      if (!isReward[token]) {\n          isReward[token] = true;\n          rewards.push(token);\n          IGauge(gauge).addBribeRewardToken(token);\n      }\n\n      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n  }\n\n  function rewardsListLength() external view returns (uint) {\n      return rewards.length;\n  }\n\n  function addRewardToken(address token) external {\n    require(msg.sender == gauge);\n    if (!isReward[token]) {\n      require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      isReward[token] = true;\n      rewards.push(token);\n    }\n  }\n\n  function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n    require(msg.sender == gauge);\n    require(rewards[i] == oldToken);\n    isReward[oldToken] = false;\n    isReward[newToken] = true;\n    rewards[i] = newToken;\n  }\n\n  function deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n      _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n  }\n\n  function _safeTransfer(address token, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}\n\n\n",
        "CodeNames": [
            "Velo.sol",
            "Minter.sol",
            "Pair.sol",
            "VotingEscrow.sol",
            "RewardsDistributor.sol",
            "Gauge.sol",
            "Bribe.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nFile: contracts/contracts/VotingEscrow.sol   #1\n\n462       function _mint(address _to, uint _tokenId) internal returns (bool) {\n463           // Throws if `_to` is zero address\n464           assert(_to != address(0));\n465           // TODO add delegates\n466           // checkpoint for gov\n467           _moveTokenDelegates(address(0), delegates(_to), _tokenId);\n",
                    "//solidity\nFile: contracts/contracts/VotingEscrow.sol   #2\n\n301       function _transferFrom(\n302           address _from,\n303           address _to,\n304           uint _tokenId,\n305           address _sender\n306       ) internal {\n307           require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n308           // Check requirements\n309           require(_isApprovedOrOwner(_sender, _tokenId));\n310           // Clear approval. Throws if `_from` is not the current owner\n311           _clearApproval(_from, _tokenId);\n312           // Remove NFT. Throws if `_tokenId` is not a valid NFT\n313           _removeTokenFrom(_from, _tokenId);\n314           // TODO delegates\n315           // auto re-delegate\n316           _moveTokenDelegates(delegates(_from), delegates(_to), _tokenId);\n",
                    "//solidity\nFile: contracts/contracts/VotingEscrow.sol   #3\n\n517       function _burn(uint _tokenId) internal {\n518           require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");\n519   \n520           address owner = ownerOf(_tokenId);\n521   \n522           // Clear approval\n523           approve(address(0), _tokenId);\n524           // TODO add delegates\n525           // Remove token\n526           _removeTokenFrom(msg.sender, _tokenId);\n527           emit Transfer(owner, address(0), _tokenId);\n528       }\n"
                ],
                "Type": " Users can get unlimited votes",
                "Description": "\nUsers can get unlimited votes which leads to them:\n\n1.  gaining control over governance\n2.  getting undeserved rewards\n3.  having their pools favored due to gauge values\n\n\n_mint() calls _moveTokenDelegates() to set up delegation...\n\nsolidity\nFile: contracts/contracts/VotingEscrow.sol   #1\n\n462       function _mint(address _to, uint _tokenId) internal returns (bool) {\n463           // Throws if _to is zero address\n464           assert(_to != address(0));\n465           // TODO add delegates\n466           // checkpoint for gov\n467           _moveTokenDelegates(address(0), delegates(_to), _tokenId);\n\n\nVotingEscrow.sol#L462-L467(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L462-L467)<br\n\nand _transferFrom() calls _moveTokenDelegates() to transfer delegates...\n\nsolidity\nFile: contracts/contracts/VotingEscrow.sol   #2\n\n301       function _transferFrom(\n302           address _from,\n303           address _to,\n304           uint _tokenId,\n305           address _sender\n306       ) internal {\n307           require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n308           // Check requirements\n309           require(_isApprovedOrOwner(_sender, _tokenId));\n310           // Clear approval. Throws if _from is not the current owner\n311           _clearApproval(_from, _tokenId);\n312           // Remove NFT. Throws if _tokenId is not a valid NFT\n313           _removeTokenFrom(_from, _tokenId);\n314           // TODO delegates\n315           // auto re-delegate\n316           _moveTokenDelegates(delegates(_from), delegates(_to), _tokenId);\n\n\nVotingEscrow.sol#L301-L316(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L301-L316)<br\n\nbut _burn() does not transfer them back to address(0)\n\nsolidity\nFile: contracts/contracts/VotingEscrow.sol   #3\n\n517       function _burn(uint _tokenId) internal {\n518           require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");\n519   \n520           address owner = ownerOf(_tokenId);\n521   \n522           // Clear approval\n523           approve(address(0), _tokenId);\n524           // TODO add delegates\n525           // Remove token\n526           _removeTokenFrom(msg.sender, _tokenId);\n527           emit Transfer(owner, address(0), _tokenId);\n528       }\n\n\nVotingEscrow.sol#L517-L528(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528)<br\n\nA user can deposit a token, lock it, wait for the lock to expire, transfer the token to another address, and repeat. During each iteration, a new NFT is minted and checkpointed. Calls to getPastVotes() will show the wrong values, since it will think the account still holds the delegation of the burnt NFT. Bribes and gauges also look at the checkpoints and will also have the wrong information\n\n",
                "Repair": "\nCall _moveTokenDelegates(owner,address(0)) in _burn()\n\npooltypes (Velodrome) confirmed and commented(https://github.com/code-423n4/2022-05-velodrome-findings/issues/129#issuecomment-1151863086):\n  Nice catch! We intended to fix this issue (see TODO(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L524)), included in our mainnet deploy. Thanks for surfacing.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-05-velodrome-findings/issues/129#issuecomment-1166679734):\n  The warden has shown an exploit that, leveraging the _moveTokenDelegates function, which is not present in burn can allow any attacker to inflate their votes.\n \n The sponsor has confirmed and they indeed have mitigated the issue in their deployed code(https://optimistic.etherscan.io/address/0x9c7305eb78a432ced5C4D14Cac27E8Ed569A2e26#code#L873).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\ncontract Velo {\n\n    string public constant name = \"Velodrome\";\n    string public constant symbol = \"VELO\";\n    uint8 public constant decimals = 18;\n    uint public totalSupply = 0;\n\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    address public minter;\n    address public redemptionReceiver;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    constructor() {\n        minter = msg.sender;\n        _mint(msg.sender, 0);\n    }\n\n    // No checks as its meant to be once off to set minting rights to BaseV1 Minter\n    function setMinter(address _minter) external {\n        require(msg.sender == minter);\n        minter = _minter;\n    }\n\n    function setRedemptionReceiver(address _receiver) external {\n        require(msg.sender == minter);\n        redemptionReceiver = _receiver;\n    }\n\n    function approve(address _spender, uint _value) external returns (bool) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function _mint(address _to, uint _amount) internal returns (bool) {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n        emit Transfer(address(0x0), _to, _amount);\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal returns (bool) {\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) external returns (bool) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) external returns (bool) {\n        uint allowed_from = allowance[_from][msg.sender];\n        if (allowed_from != type(uint).max) {\n            allowance[_from][msg.sender] -= _value;\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    function mint(address account, uint amount) external returns (bool) {\n        require(msg.sender == minter);\n        _mint(account, amount);\n        return true;\n    }\n\n    function mintToRedemptionReceiver(uint256 amount) external returns (bool) {\n        require(msg.sender == redemptionReceiver);\n        _mint(redemptionReceiver, amount);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n/*\n\n@title Curve Fee Distribution modified for ve(3,3) emissions\n@author Curve Finance, andrecronje\n@license MIT\n\n*/\n\ncontract RewardsDistributor {\n\n    event CheckpointToken(\n        uint time,\n        uint tokens\n    );\n\n    event Claimed(\n        uint tokenId,\n        uint amount,\n        uint claim_epoch,\n        uint max_epoch\n    );\n\n    uint constant WEEK = 7 * 86400;\n\n    uint public start_time;\n    uint public time_cursor;\n    mapping(uint => uint) public time_cursor_of;\n    mapping(uint => uint) public user_epoch_of;\n\n    uint public last_token_time;\n    uint[1000000000000000] public tokens_per_week;\n\n    address public voting_escrow;\n    address public token;\n    uint public token_last_balance;\n\n    uint[1000000000000000] public ve_supply;\n\n    address public depositor;\n\n    constructor(address _voting_escrow) {\n        uint _t = block.timestamp / WEEK * WEEK;\n        start_time = _t;\n        last_token_time = _t;\n        time_cursor = _t;\n        address _token = IVotingEscrow(_voting_escrow).token();\n        token = _token;\n        voting_escrow = _voting_escrow;\n        depositor = msg.sender;\n        IERC20(_token).approve(_voting_escrow, type(uint).max);\n    }\n\n    function timestamp() external view returns (uint) {\n        return block.timestamp / WEEK * WEEK;\n    }\n\n    function _checkpoint_token() internal {\n        uint token_balance = IERC20(token).balanceOf(address(this));\n        uint to_distribute = token_balance - token_last_balance;\n        token_last_balance = token_balance;\n\n        uint t = last_token_time;\n        uint since_last = block.timestamp - t;\n        last_token_time = block.timestamp;\n        uint this_week = t / WEEK * WEEK;\n        uint next_week = 0;\n\n        for (uint i = 0; i < 20; i++) {\n            next_week = this_week + WEEK;\n            if (block.timestamp < next_week) {\n                if (since_last == 0 && block.timestamp == t) {\n                    tokens_per_week[this_week] += to_distribute;\n                } else {\n                    tokens_per_week[this_week] += to_distribute * (block.timestamp - t) / since_last;\n                }\n                break;\n            } else {\n                if (since_last == 0 && next_week == t) {\n                    tokens_per_week[this_week] += to_distribute;\n                } else {\n                    tokens_per_week[this_week] += to_distribute * (next_week - t) / since_last;\n                }\n            }\n            t = next_week;\n            this_week = next_week;\n        }\n        emit CheckpointToken(block.timestamp, to_distribute);\n    }\n\n    function checkpoint_token() external {\n        assert(msg.sender == depositor);\n        _checkpoint_token();\n    }\n\n    function _find_timestamp_epoch(address ve, uint _timestamp) internal view returns (uint) {\n        uint _min = 0;\n        uint _max = IVotingEscrow(ve).epoch();\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(_mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function _find_timestamp_user_epoch(address ve, uint tokenId, uint _timestamp, uint max_user_epoch) internal view returns (uint) {\n        uint _min = 0;\n        uint _max = max_user_epoch;\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).user_point_history(tokenId, _mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid -1;\n            }\n        }\n        return _min;\n    }\n\n    function ve_for_at(uint _tokenId, uint _timestamp) external view returns (uint) {\n        address ve = voting_escrow;\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint epoch = _find_timestamp_user_epoch(ve, _tokenId, _timestamp, max_user_epoch);\n        IVotingEscrow.Point memory pt = IVotingEscrow(ve).user_point_history(_tokenId, epoch);\n        return Math.max(uint(int256(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))), 0);\n    }\n\n    function _checkpoint_total_supply() internal {\n        address ve = voting_escrow;\n        uint t = time_cursor;\n        uint rounded_timestamp = block.timestamp / WEEK * WEEK;\n        IVotingEscrow(ve).checkpoint();\n\n        for (uint i = 0; i < 20; i++) {\n            if (t > rounded_timestamp) {\n                break;\n            } else {\n                uint epoch = _find_timestamp_epoch(ve, t);\n                IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(epoch);\n                int128 dt = 0;\n                if (t > pt.ts) {\n                    dt = int128(int256(t - pt.ts));\n                }\n                ve_supply[t] = Math.max(uint(int256(pt.bias - pt.slope * dt)), 0);\n            }\n            t += WEEK;\n        }\n        time_cursor = t;\n    }\n\n    function checkpoint_total_supply() external {\n        _checkpoint_total_supply();\n    }\n\n    function _claim(uint _tokenId, address ve, uint _last_token_time) internal returns (uint) {\n        uint user_epoch = 0;\n        uint to_distribute = 0;\n\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint _start_time = start_time;\n\n        if (max_user_epoch == 0) return 0;\n\n        uint week_cursor = time_cursor_of[_tokenId];\n        if (week_cursor == 0) {\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\n        } else {\n            user_epoch = user_epoch_of[_tokenId];\n        }\n\n        if (user_epoch == 0) user_epoch = 1;\n\n        IVotingEscrow.Point memory user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n\n        if (week_cursor == 0) week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK;\n        if (week_cursor >= last_token_time) return 0;\n        if (week_cursor < _start_time) week_cursor = _start_time;\n\n        IVotingEscrow.Point memory old_user_point;\n\n        for (uint i = 0; i < 50; i++) {\n            if (week_cursor >= _last_token_time) break;\n\n            if (week_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\n                user_epoch += 1;\n                old_user_point = user_point;\n                if (user_epoch > max_user_epoch) {\n                    user_point = IVotingEscrow.Point(0,0,0,0);\n                } else {\n                    user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n                }\n            } else {\n                int128 dt = int128(int256(week_cursor - old_user_point.ts));\n                uint balance_of = Math.max(uint(int256(old_user_point.bias - dt * old_user_point.slope)), 0);\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\n                if (balance_of != 0) {\n                    to_distribute += balance_of * tokens_per_week[week_cursor] / ve_supply[week_cursor];\n                }\n                week_cursor += WEEK;\n            }\n        }\n\n        user_epoch = Math.min(max_user_epoch, user_epoch - 1);\n        user_epoch_of[_tokenId] = user_epoch;\n        time_cursor_of[_tokenId] = week_cursor;\n\n        emit Claimed(_tokenId, to_distribute, user_epoch, max_user_epoch);\n\n        return to_distribute;\n    }\n\n    function _claimable(uint _tokenId, address ve, uint _last_token_time) internal view returns (uint) {\n        uint user_epoch = 0;\n        uint to_distribute = 0;\n\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint _start_time = start_time;\n\n        if (max_user_epoch == 0) return 0;\n\n        uint week_cursor = time_cursor_of[_tokenId];\n        if (week_cursor == 0) {\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\n        } else {\n            user_epoch = user_epoch_of[_tokenId];\n        }\n\n        if (user_epoch == 0) user_epoch = 1;\n\n        IVotingEscrow.Point memory user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n\n        if (week_cursor == 0) week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK;\n        if (week_cursor >= last_token_time) return 0;\n        if (week_cursor < _start_time) week_cursor = _start_time;\n\n        IVotingEscrow.Point memory old_user_point;\n\n        for (uint i = 0; i < 50; i++) {\n            if (week_cursor >= _last_token_time) break;\n\n            if (week_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\n                user_epoch += 1;\n                old_user_point = user_point;\n                if (user_epoch > max_user_epoch) {\n                    user_point = IVotingEscrow.Point(0,0,0,0);\n                } else {\n                    user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n                }\n            } else {\n                int128 dt = int128(int256(week_cursor - old_user_point.ts));\n                uint balance_of = Math.max(uint(int256(old_user_point.bias - dt * old_user_point.slope)), 0);\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\n                if (balance_of != 0) {\n                    to_distribute += balance_of * tokens_per_week[week_cursor] / ve_supply[week_cursor];\n                }\n                week_cursor += WEEK;\n            }\n        }\n\n        return to_distribute;\n    }\n\n    function claimable(uint _tokenId) external view returns (uint) {\n        uint _last_token_time = last_token_time / WEEK * WEEK;\n        return _claimable(_tokenId, voting_escrow, _last_token_time);\n    }\n\n    function claim(uint _tokenId) external returns (uint) {\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\n        uint _last_token_time = last_token_time;\n        _last_token_time = _last_token_time / WEEK * WEEK;\n        uint amount = _claim(_tokenId, voting_escrow, _last_token_time);\n        if (amount != 0) {\n            IVotingEscrow(voting_escrow).deposit_for(_tokenId, amount);\n            token_last_balance -= amount;\n        }\n        return amount;\n    }\n\n    function claim_many(uint[] memory _tokenIds) external returns (bool) {\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\n        uint _last_token_time = last_token_time;\n        _last_token_time = _last_token_time / WEEK * WEEK;\n        address _voting_escrow = voting_escrow;\n        uint total = 0;\n\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint _tokenId = _tokenIds[i];\n            if (_tokenId == 0) break;\n            uint amount = _claim(_tokenId, _voting_escrow, _last_token_time);\n            if (amount != 0) {\n                IVotingEscrow(_voting_escrow).deposit_for(_tokenId, amount);\n                total += amount;\n            }\n        }\n        if (total != 0) {\n            token_last_balance -= total;\n        }\n\n        return true;\n    }\n\n    // Once off event on contract initialize\n    function setDepositor(address _depositor) external {\n        require(msg.sender == depositor);\n        depositor = _depositor;\n    }\n}\n\n\n",
        "CodeNames": [
            "Velo.sol",
            "RewardsDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n",
                    "//solidity\n    function _burn(uint _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // TODO add delegates\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n",
                    "//solidity\n    function merge(uint _from, uint _to) external {\n        require(attachments[_from] == 0 && !voted[_from], \"attached\");\n        require(_from != _to);\n        require(_isApprovedOrOwner(msg.sender, _from));\n        require(_isApprovedOrOwner(msg.sender, _to));\n\n        LockedBalance memory _locked0 = locked[_from];\n        LockedBalance memory _locked1 = locked[_to];\n        uint value0 = uint(int256(_locked0.amount));\n        uint end = _locked0.end = _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = LockedBalance(0, 0);\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\n        _burn(_from);\n",
                    "//solidity\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(uint _tokenId) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n\n        LockedBalance memory _locked = locked[_tokenId];\n        require(block.timestamp = _locked.end, \"The lock didn't expire\");\n        uint value = uint(int256(_locked.amount));\n\n        locked[_tokenId] = LockedBalance(0,0);\n        uint supply_before = supply;\n        supply = supply_before value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have = 0 amount\n        _checkpoint(_tokenId, _locked, LockedBalance(0,0));\n\n        assert(IERC20(token).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _burn(_tokenId);\n"
                ],
                "Type": "  VotingEscrow 's merge and withdraw aren't available for approved users",
                "Description": "\nUsers who are approved, but do not own a particular NFT, are supposed to be eligible to call merge and withdraw from the NFT.\n\nCurrently _burn(), used by merge() and withdraw() to remove the NFT from the system, will revert unless the sender is the owner of NFT as the function tries to update the accounting for the sender, not the owner.\n\nSetting the severity to medium as the impact is merge() and withdraw() permanent unavailability for any approved sender, who isn't the owner of the involved NFT.\n\n\n_removeTokenFrom() requires _from to be the NFT owner as it removes _tokenId from the _from account:\n\nVotingEscrow.sol#L504-L515(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L504-L515)<br\n\nsolidity\n    /// @dev Remove a NFT from a given address\n    ///      Throws if _from is not the current owner.\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n        // Throws if _from is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\n\n_burn() allows _tokenId to approved or owner, but calls _removeTokenFrom() with msg.sender as _from:\n\nVotingEscrow.sol#L517-L528(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528)<br\n\nsolidity\n    function _burn(uint _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // TODO add delegates\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n\nThis way if _burn() is called by an approved account who isn't an owner, it will revert on _removeTokenFrom()'s assert(idToOwner[_tokenId] == _from) check.\n\nNow burn() is used by merge():\n\nVotingEscrow.sol#L1084-L1097(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L1084-L1097)<br\n\nsolidity\n    function merge(uint _from, uint _to) external {\n        require(attachments[_from] == 0 && !voted[_from], \"attached\");\n        require(_from != _to);\n        require(_isApprovedOrOwner(msg.sender, _from));\n        require(_isApprovedOrOwner(msg.sender, _to));\n\n        LockedBalance memory _locked0 = locked[_from];\n        LockedBalance memory _locked1 = locked[_to];\n        uint value0 = uint(int256(_locked0.amount));\n        uint end = _locked0.end = _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = LockedBalance(0, 0);\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\n        _burn(_from);\n\n\nAnd withdraw():\n\nVotingEscrow.sol#L842-L864(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L842-L864)<br\n\nsolidity\n    /// @notice Withdraw all tokens for _tokenId\n    /// @dev Only possible if the lock has expired\n    function withdraw(uint _tokenId) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n\n        LockedBalance memory _locked = locked[_tokenId];\n        require(block.timestamp = _locked.end, \"The lock didn't expire\");\n        uint value = uint(int256(_locked.amount));\n\n        locked[_tokenId] = LockedBalance(0,0);\n        uint supply_before = supply;\n        supply = supply_before value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have = 0 amount\n        _checkpoint(_tokenId, _locked, LockedBalance(0,0));\n\n        assert(IERC20(token).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _burn(_tokenId);\n\n\n",
                "Repair": "\nConsider changing _removeTokenFrom() argument to be the owner:\n\nVotingEscrow.sol#L517-L528(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528)<br\n\nsolidity\n    function _burn(uint _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // TODO add delegates\n        // Remove token\n      _removeTokenFrom(msg.sender, _tokenId);\n+       _removeTokenFrom(owner, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n\npooltypes (Velodrome) disputed(https://github.com/code-423n4/2022-05-velodrome-findings/issues/66)\n\nAlex the Entreprenerd (judge) increased severity to High and commented(https://github.com/code-423n4/2022-05-velodrome-findings/issues/66#issuecomment-1170428345):\n  The warden has shown how an approved user is unable to execute ordinary operations due to a logic flaw. While the impact may make Medium Severity valid, as the owner can still operate, but delegated users cannot, I believe the finding shows a logical flaw in the system in that it doesn't work as intended.\n \n For that reason I believe this finding is of High Severity.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {\n                _notifyBribeAmount(token, epochRewards, bribeStart);\n            }\n        }\n    }\n\n    function setVoteStatus(address account, bool voted) external {\n        require(msg.sender == voter);\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            checkpoints[account][0] = Checkpoint(block.timestamp, 0, voted);\n            numCheckpoints[account] = 1;\n        } else {\n            checkpoints[account][nCheckpoints - 1].voted = voted;\n        }\n    }\n\n    /**\n    * @notice Determine the prior balance for an account as of a block number\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    * @param account The address of the account to check\n    * @param timestamp The timestamp to get the balance at\n    * @return The balance the account had as of the given block\n    */\n    function getPriorBalanceIndex(address account, uint timestamp) public view returns (uint) {\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\n        uint nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (supplyCheckpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\n        if (nCheckpoints == 0) {\n            return (0,0);\n        }\n\n        // First check most recent balance\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\n        }\n\n        // Next check implicit zero balance\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\n            return (0,0);\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\n            if (cp.timestamp == timestamp) {\n                return (cp.rewardPerToken, cp.timestamp);\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\n    }\n\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\n\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\n        } else {\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint _nCheckPoints = supplyNumCheckpoints;\n        uint _timestamp = block.timestamp;\n\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\n            supplyCheckpoints[_nCheckPoints - 1].supply = derivedSupply;\n        } else {\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, derivedSupply);\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n\n    function rewardsListLength() external view returns (uint) {\n        return rewards.length;\n    }\n\n    // returns the last time the reward was modified or periodFinish if the reward has ended\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish[token]);\n    }\n\n    function getReward(address account, address[] memory tokens) external lock {\n        require(msg.sender == account || msg.sender == voter);\n        _unlocked = 1;\n        IVoter(voter).distribute(address(this));\n        _unlocked = 2;\n\n        for (uint i = 0; i < tokens.length; i++) {\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\n\n            uint _reward = earned(tokens[i], account);\n            lastEarn[tokens[i]][account] = block.timestamp;\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[tokens[i]];\n            if (_reward > 0) _safeTransfer(tokens[i], account, _reward);\n\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\n        }\n\n        uint _derivedBalance = derivedBalances[account];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(account, derivedBalances[account]);\n        _writeSupplyCheckpoint();\n    }\n\n\n    function rewardPerToken(address token) public view returns (uint) {\n        if (derivedSupply == 0) {\n            return rewardPerTokenStored[token];\n        }\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\n    }\n\n    function derivedBalance(address account) public view returns (uint) {\n        return balanceOf[account];\n    }\n\n    function batchRewardPerToken(address token, uint maxRuns) external {\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\n    }\n\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\n\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n            if (sp0.supply > 0) {\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                reward += _reward;\n                _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                _startTimestamp = _endTime;\n            }\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\n        uint endTime = Math.max(timestamp1, startTimestamp);\n        return (((Math.min(endTime, periodFinish[token]) - Math.min(Math.max(timestamp0, startTimestamp), periodFinish[token])) * rewardRate[token] * PRECISION / supply), endTime);\n    }\n\n    function _updateRewardForAllTokens() internal {\n        uint length = rewards.length;\n        for (uint i; i < length; i++) {\n            address token = rewards[i];\n            (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        }\n    }\n\n    function _updateRewardPerToken(address token) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = supplyNumCheckpoints-1;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n                if (sp0.supply > 0) {\n                    SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                    reward += _reward;\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                    _startTimestamp = _endTime;\n                }\n            }\n        }\n\n        SupplyCheckpoint memory sp = supplyCheckpoints[_endIndex];\n        if (sp.supply > 0) {\n            (uint _reward,) = _calcRewardPerToken(token, lastTimeRewardApplicable(token), Math.max(sp.timestamp, _startTimestamp), sp.supply, _startTimestamp);\n            reward += _reward;\n            _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\n            _startTimestamp = block.timestamp;\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    // earned is an estimation, it won't be exact till the supply > rewardPerToken calculations have run\n    function earned(address token, address account) public view returns (uint) {\n        uint _startTimestamp = Math.max(lastEarn[token][account], rewardPerTokenCheckpoints[token][0].timestamp);\n        if (numCheckpoints[account] == 0) {\n            return 0;\n        }\n\n        uint _startIndex = getPriorBalanceIndex(account, _startTimestamp);\n        uint _endIndex = numCheckpoints[account]-1;\n\n        uint reward = 0;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp - (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp > lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n\n        return reward;\n    }\n\n    function depositAll(uint tokenId) external {\n        deposit(IERC20(stake).balanceOf(msg.sender), tokenId);\n    }\n\n    function deposit(uint amount, uint tokenId) public lock {\n        require(amount > 0);\n\n        _updateRewardForAllTokens();\n\n        _safeTransferFrom(stake, msg.sender, address(this), amount);\n        totalSupply += amount;\n        balanceOf[msg.sender] += amount;\n\n        if (tokenId > 0) {\n            require(IVotingEscrow(_ve).ownerOf(tokenId) == msg.sender);\n            if (tokenIds[msg.sender] == 0) {\n                tokenIds[msg.sender] = tokenId;\n                IVoter(voter).attachTokenToGauge(tokenId, msg.sender);\n            }\n            require(tokenIds[msg.sender] == tokenId);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, _derivedBalance);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitDeposit(tokenId, msg.sender, amount);\n        emit Deposit(msg.sender, tokenId, amount);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf[msg.sender]);\n    }\n\n    function withdraw(uint amount) public {\n        _updateRewardForAllTokens();\n\n        uint tokenId = 0;\n        if (amount == balanceOf[msg.sender]) {\n            tokenId = tokenIds[msg.sender];\n        }\n        withdrawToken(amount, tokenId);\n    }\n\n    function withdrawToken(uint amount, uint tokenId) public lock {\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n\n        if (tokenId > 0) {\n            require(tokenId == tokenIds[msg.sender]);\n            tokenIds[msg.sender] = 0;\n            IVoter(voter).detachTokenFromGauge(tokenId, msg.sender);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, derivedBalances[msg.sender]);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitWithdraw(tokenId, msg.sender, amount);\n        emit Withdraw(msg.sender, tokenId, amount);\n    }\n\n    function left(address token) external view returns (uint) {\n        if (block.timestamp >= periodFinish[token]) return 0;\n        uint _remaining = periodFinish[token] - block.timestamp;\n        return _remaining * rewardRate[token];\n    }\n\n    function notifyRewardAmount(address token, uint amount) external lock {\n        require(token != stake);\n        require(amount > 0);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n        }\n        // rewards accrue only during the bribe period\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;\n        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);\n        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        _claimFees();\n\n        if (block.timestamp >= periodFinish[token]) {\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n        require(rewardRate[token] > 0);\n        uint balance = IERC20(token).balanceOf(address(this));\n        require(rewardRate[token] <= balance / DURATION, \"Provided reward too high\");\n        periodFinish[token] = adjustedTstamp + DURATION;\n        if (!isReward[token]) {\n            isReward[token] = true;\n            rewards.push(token);\n            IBribe(bribe).addRewardToken(token);\n        }\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        require(rewards[i] == oldToken);\n        isReward[oldToken] = false;\n        isReward[newToken] = true;\n        rewards[i] = newToken;\n    }\n\n    function swapOutBribeRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        IBribe(bribe).swapOutRewardToken(i, oldToken, newToken);\n    }\n\n    function addBribeRewardToken(address token) external {\n        require(msg.sender == bribe);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n            isReward[token] = true;\n            rewards.push(token);\n        }\n    }\n\n    function _notifyBribeAmount(address token, uint amount, uint epochStart) internal {\n        if (block.timestamp >= periodFinish[token]) {\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n\n        lastUpdateTime[token] = epochStart;\n        periodFinish[token] = epochStart + DURATION;\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeApprove(address token, address spender, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGauge.sol';\n\ncontract Bribe is IBribe {\n  uint internal constant DURATION = 5 days; // rewards are released over the voting period\n  uint internal constant BRIBE_LAG = 1 days;\n  uint internal constant COOLDOWN = 12 hours;\n  uint internal constant MAX_REWARD_TOKENS = 16;\n\n  address public gauge;\n  mapping(address => mapping(uint => uint)) public tokenRewardsPerEpoch;\n  address[] public rewards;\n  mapping(address => bool) public isReward;\n\n  event NotifyReward(address indexed from, address indexed reward, uint epoch, uint amount);\n\n  // simple re-entrancy check\n  uint internal _unlocked = 1;\n  modifier lock() {\n      require(_unlocked == 1);\n      _unlocked = 2;\n      _;\n      _unlocked = 1;\n  }\n\n  function setGauge(address _gauge) external {\n    require(gauge == address(0), \"gauge already set\");\n    gauge = _gauge;\n  }\n\n  function getEpochStart(uint timestamp) public view returns (uint) {\n    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;\n    uint bribeEnd = bribeStart + DURATION - COOLDOWN;\n    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n  }\n\n  function notifyRewardAmount(address token, uint amount) external lock {\n      require(amount > 0);\n      if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      }\n      // bribes kick in at the start of next bribe period\n      uint adjustedTstamp = getEpochStart(block.timestamp);\n      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n      _safeTransferFrom(token, msg.sender, address(this), amount);\n      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n      if (!isReward[token]) {\n          isReward[token] = true;\n          rewards.push(token);\n          IGauge(gauge).addBribeRewardToken(token);\n      }\n\n      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n  }\n\n  function rewardsListLength() external view returns (uint) {\n      return rewards.length;\n  }\n\n  function addRewardToken(address token) external {\n    require(msg.sender == gauge);\n    if (!isReward[token]) {\n      require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      isReward[token] = true;\n      rewards.push(token);\n    }\n  }\n\n  function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n    require(msg.sender == gauge);\n    require(rewards[i] == oldToken);\n    isReward[oldToken] = false;\n    isReward[newToken] = true;\n    rewards[i] = newToken;\n  }\n\n  function deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n      _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n  }\n\n  function _safeTransfer(address token, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}\n\n\n",
        "CodeNames": [
            "Gauge.sol",
            "Bribe.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints  0 && checkpoints[account][_nCheckPoints 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints  0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n",
                    "//solidity\n\tbool prevVoteStatus = (_nCheckPoints  0) ? checkpoints[account][_nCheckPoints].voted : false;\n",
                    "//solidity\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address = mapping (uint = Checkpoint)) public checkpoints;\n",
                    "//solidity\n        if (_endIndex  0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp  lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n"
                ],
                "Type": " User rewards stop accruing after any  _writeCheckpoint  calling action",
                "Description": "*Submitted by hyh, also found by smiling_heretic, unforgiven, and xiaoming90*\n\nAny user balance affecting action, i.e. deposit, withdraw/withdrawToken or getReward, calls _writeCheckpoint to update the balance records used for the earned reward estimation. The issue is that _writeCheckpoint always sets false to voted flag for the each new checkpoint due to wrong index used in the mapping access, while only voted periods are eligible for accruing the rewards.\n\nThis way any balance changing action of a voted user will lead to stopping of the rewards accrual for the user, until next vote will be cast. I.e. any action that has no relation to voting and should have only balance change as the reward accruing process impact, in fact removes any future rewards from the user until the next vote.\n\nSetting the severity to be high as the impact here violates system logic and means next periods accrued rewards loss for a user.\n\n\n_writeCheckpoint adds a new checkpoint if block.timestamp is not found in the last checkpoint:\n\nGauge.sol#L302-L313(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L302-L313)<br\n\nsolidity\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints  0 && checkpoints[account][_nCheckPoints 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints  0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n\nHowever, instead of moving vote status from the previous checkpoint it records false to prevVoteStatus all the time as last status is checkpoints[account][_nCheckPoints-1].voted, while checkpoints[account][_nCheckPoints] isn't created yet and is empty:\n\nGauge.sol#L309(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L309)<br\n\nsolidity\n\tbool prevVoteStatus = (_nCheckPoints  0) ? checkpoints[account][_nCheckPoints].voted : false;\n\n\nNotice that checkpoints is a mapping and no range check violation happens:\n\nGauge.sol#L74-L75(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L74-L75)<br\n\nsolidity\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address = mapping (uint = Checkpoint)) public checkpoints;\n\n\nThis will effectively lead to rewards removal on any user action, as earned() used in rewards estimation counts only voted periods:\n\nGauge.sol#L483-L502(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L483-L502)<br\n\nsolidity\n        if (_endIndex  0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp  lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n\n\nI.e. if a user has voted, then performed any of the operations that call _writeCheckpoint update: deposit, withdraw/withdrawToken or getReward, then this user will not have any rewards for the period between this operation and the next vote as all checkpoints that were created by _writeCheckpoint will have voted == false.\n\n",
                "Repair": "\nUpdate the index to be _nCheckPoints-1:\n\n<https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L309\n\nsolidity\n-\tbool prevVoteStatus = (_nCheckPoints  0) ? checkpoints[account][_nCheckPoints].voted : false;\n+\tbool prevVoteStatus = (_nCheckPoints  0) ? checkpoints[account][_nCheckPoints 1].voted : false;\n\n\npooltypes (Velodrome) disputed(https://github.com/code-423n4/2022-05-velodrome-findings/issues/59)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-05-velodrome-findings/issues/59#issuecomment-1171780662):\n  Due to 1 typo / oversight in the line \n bool prevVoteStatus = (_nCheckPoints  0) ? checkpoints[account][_nCheckPoints].voted : false;\n All future checkpoints are registered as having voted set to false.\n \n Due to a configuration choice (or mistake as detailed in other findings), having voted set to false causes all rewards to not be receiveable.\n \n While the impact is loss of Yield (typically a medium finding), the finding shows how this bug will systematically impact all gauges for all users.\n \n Because of that, I believe High Severity to be appropriate.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {\n                _notifyBribeAmount(token, epochRewards, bribeStart);\n            }\n        }\n    }\n\n    function setVoteStatus(address account, bool voted) external {\n        require(msg.sender == voter);\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            checkpoints[account][0] = Checkpoint(block.timestamp, 0, voted);\n            numCheckpoints[account] = 1;\n        } else {\n            checkpoints[account][nCheckpoints - 1].voted = voted;\n        }\n    }\n\n    /**\n    * @notice Determine the prior balance for an account as of a block number\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    * @param account The address of the account to check\n    * @param timestamp The timestamp to get the balance at\n    * @return The balance the account had as of the given block\n    */\n    function getPriorBalanceIndex(address account, uint timestamp) public view returns (uint) {\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\n        uint nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (supplyCheckpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\n        if (nCheckpoints == 0) {\n            return (0,0);\n        }\n\n        // First check most recent balance\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\n        }\n\n        // Next check implicit zero balance\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\n            return (0,0);\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\n            if (cp.timestamp == timestamp) {\n                return (cp.rewardPerToken, cp.timestamp);\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\n    }\n\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\n\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\n        } else {\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint _nCheckPoints = supplyNumCheckpoints;\n        uint _timestamp = block.timestamp;\n\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\n            supplyCheckpoints[_nCheckPoints - 1].supply = derivedSupply;\n        } else {\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, derivedSupply);\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n\n    function rewardsListLength() external view returns (uint) {\n        return rewards.length;\n    }\n\n    // returns the last time the reward was modified or periodFinish if the reward has ended\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish[token]);\n    }\n\n    function getReward(address account, address[] memory tokens) external lock {\n        require(msg.sender == account || msg.sender == voter);\n        _unlocked = 1;\n        IVoter(voter).distribute(address(this));\n        _unlocked = 2;\n\n        for (uint i = 0; i < tokens.length; i++) {\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\n\n            uint _reward = earned(tokens[i], account);\n            lastEarn[tokens[i]][account] = block.timestamp;\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[tokens[i]];\n            if (_reward > 0) _safeTransfer(tokens[i], account, _reward);\n\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\n        }\n\n        uint _derivedBalance = derivedBalances[account];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(account, derivedBalances[account]);\n        _writeSupplyCheckpoint();\n    }\n\n\n    function rewardPerToken(address token) public view returns (uint) {\n        if (derivedSupply == 0) {\n            return rewardPerTokenStored[token];\n        }\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\n    }\n\n    function derivedBalance(address account) public view returns (uint) {\n        return balanceOf[account];\n    }\n\n    function batchRewardPerToken(address token, uint maxRuns) external {\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\n    }\n\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\n\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n            if (sp0.supply > 0) {\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                reward += _reward;\n                _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                _startTimestamp = _endTime;\n            }\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\n        uint endTime = Math.max(timestamp1, startTimestamp);\n        return (((Math.min(endTime, periodFinish[token]) - Math.min(Math.max(timestamp0, startTimestamp), periodFinish[token])) * rewardRate[token] * PRECISION / supply), endTime);\n    }\n\n    function _updateRewardForAllTokens() internal {\n        uint length = rewards.length;\n        for (uint i; i < length; i++) {\n            address token = rewards[i];\n            (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        }\n    }\n\n    function _updateRewardPerToken(address token) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = supplyNumCheckpoints-1;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n                if (sp0.supply > 0) {\n                    SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                    reward += _reward;\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                    _startTimestamp = _endTime;\n                }\n            }\n        }\n\n        SupplyCheckpoint memory sp = supplyCheckpoints[_endIndex];\n        if (sp.supply > 0) {\n            (uint _reward,) = _calcRewardPerToken(token, lastTimeRewardApplicable(token), Math.max(sp.timestamp, _startTimestamp), sp.supply, _startTimestamp);\n            reward += _reward;\n            _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\n            _startTimestamp = block.timestamp;\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    // earned is an estimation, it won't be exact till the supply > rewardPerToken calculations have run\n    function earned(address token, address account) public view returns (uint) {\n        uint _startTimestamp = Math.max(lastEarn[token][account], rewardPerTokenCheckpoints[token][0].timestamp);\n        if (numCheckpoints[account] == 0) {\n            return 0;\n        }\n\n        uint _startIndex = getPriorBalanceIndex(account, _startTimestamp);\n        uint _endIndex = numCheckpoints[account]-1;\n\n        uint reward = 0;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp - (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp > lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n\n        return reward;\n    }\n\n    function depositAll(uint tokenId) external {\n        deposit(IERC20(stake).balanceOf(msg.sender), tokenId);\n    }\n\n    function deposit(uint amount, uint tokenId) public lock {\n        require(amount > 0);\n\n        _updateRewardForAllTokens();\n\n        _safeTransferFrom(stake, msg.sender, address(this), amount);\n        totalSupply += amount;\n        balanceOf[msg.sender] += amount;\n\n        if (tokenId > 0) {\n            require(IVotingEscrow(_ve).ownerOf(tokenId) == msg.sender);\n            if (tokenIds[msg.sender] == 0) {\n                tokenIds[msg.sender] = tokenId;\n                IVoter(voter).attachTokenToGauge(tokenId, msg.sender);\n            }\n            require(tokenIds[msg.sender] == tokenId);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, _derivedBalance);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitDeposit(tokenId, msg.sender, amount);\n        emit Deposit(msg.sender, tokenId, amount);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf[msg.sender]);\n    }\n\n    function withdraw(uint amount) public {\n        _updateRewardForAllTokens();\n\n        uint tokenId = 0;\n        if (amount == balanceOf[msg.sender]) {\n            tokenId = tokenIds[msg.sender];\n        }\n        withdrawToken(amount, tokenId);\n    }\n\n    function withdrawToken(uint amount, uint tokenId) public lock {\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n\n        if (tokenId > 0) {\n            require(tokenId == tokenIds[msg.sender]);\n            tokenIds[msg.sender] = 0;\n            IVoter(voter).detachTokenFromGauge(tokenId, msg.sender);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, derivedBalances[msg.sender]);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitWithdraw(tokenId, msg.sender, amount);\n        emit Withdraw(msg.sender, tokenId, amount);\n    }\n\n    function left(address token) external view returns (uint) {\n        if (block.timestamp >= periodFinish[token]) return 0;\n        uint _remaining = periodFinish[token] - block.timestamp;\n        return _remaining * rewardRate[token];\n    }\n\n    function notifyRewardAmount(address token, uint amount) external lock {\n        require(token != stake);\n        require(amount > 0);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n        }\n        // rewards accrue only during the bribe period\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;\n        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);\n        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        _claimFees();\n\n        if (block.timestamp >= periodFinish[token]) {\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n        require(rewardRate[token] > 0);\n        uint balance = IERC20(token).balanceOf(address(this));\n        require(rewardRate[token] <= balance / DURATION, \"Provided reward too high\");\n        periodFinish[token] = adjustedTstamp + DURATION;\n        if (!isReward[token]) {\n            isReward[token] = true;\n            rewards.push(token);\n            IBribe(bribe).addRewardToken(token);\n        }\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        require(rewards[i] == oldToken);\n        isReward[oldToken] = false;\n        isReward[newToken] = true;\n        rewards[i] = newToken;\n    }\n\n    function swapOutBribeRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        IBribe(bribe).swapOutRewardToken(i, oldToken, newToken);\n    }\n\n    function addBribeRewardToken(address token) external {\n        require(msg.sender == bribe);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n            isReward[token] = true;\n            rewards.push(token);\n        }\n    }\n\n    function _notifyBribeAmount(address token, uint amount, uint epochStart) internal {\n        if (block.timestamp >= periodFinish[token]) {\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n\n        lastUpdateTime[token] = epochStart;\n        periodFinish[token] = epochStart + DURATION;\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeApprove(address token, address spender, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGauge.sol';\n\ncontract Bribe is IBribe {\n  uint internal constant DURATION = 5 days; // rewards are released over the voting period\n  uint internal constant BRIBE_LAG = 1 days;\n  uint internal constant COOLDOWN = 12 hours;\n  uint internal constant MAX_REWARD_TOKENS = 16;\n\n  address public gauge;\n  mapping(address => mapping(uint => uint)) public tokenRewardsPerEpoch;\n  address[] public rewards;\n  mapping(address => bool) public isReward;\n\n  event NotifyReward(address indexed from, address indexed reward, uint epoch, uint amount);\n\n  // simple re-entrancy check\n  uint internal _unlocked = 1;\n  modifier lock() {\n      require(_unlocked == 1);\n      _unlocked = 2;\n      _;\n      _unlocked = 1;\n  }\n\n  function setGauge(address _gauge) external {\n    require(gauge == address(0), \"gauge already set\");\n    gauge = _gauge;\n  }\n\n  function getEpochStart(uint timestamp) public view returns (uint) {\n    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;\n    uint bribeEnd = bribeStart + DURATION - COOLDOWN;\n    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n  }\n\n  function notifyRewardAmount(address token, uint amount) external lock {\n      require(amount > 0);\n      if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      }\n      // bribes kick in at the start of next bribe period\n      uint adjustedTstamp = getEpochStart(block.timestamp);\n      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n      _safeTransferFrom(token, msg.sender, address(this), amount);\n      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n      if (!isReward[token]) {\n          isReward[token] = true;\n          rewards.push(token);\n          IGauge(gauge).addBribeRewardToken(token);\n      }\n\n      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n  }\n\n  function rewardsListLength() external view returns (uint) {\n      return rewards.length;\n  }\n\n  function addRewardToken(address token) external {\n    require(msg.sender == gauge);\n    if (!isReward[token]) {\n      require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      isReward[token] = true;\n      rewards.push(token);\n    }\n  }\n\n  function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n    require(msg.sender == gauge);\n    require(rewards[i] == oldToken);\n    isReward[oldToken] = false;\n    isReward[newToken] = true;\n    rewards[i] = newToken;\n  }\n\n  function deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n      _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n  }\n\n  function _safeTransfer(address token, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n/*\n\n@title Curve Fee Distribution modified for ve(3,3) emissions\n@author Curve Finance, andrecronje\n@license MIT\n\n*/\n\ncontract RewardsDistributor {\n\n    event CheckpointToken(\n        uint time,\n        uint tokens\n    );\n\n    event Claimed(\n        uint tokenId,\n        uint amount,\n        uint claim_epoch,\n        uint max_epoch\n    );\n\n    uint constant WEEK = 7 * 86400;\n\n    uint public start_time;\n    uint public time_cursor;\n    mapping(uint => uint) public time_cursor_of;\n    mapping(uint => uint) public user_epoch_of;\n\n    uint public last_token_time;\n    uint[1000000000000000] public tokens_per_week;\n\n    address public voting_escrow;\n    address public token;\n    uint public token_last_balance;\n\n    uint[1000000000000000] public ve_supply;\n\n    address public depositor;\n\n    constructor(address _voting_escrow) {\n        uint _t = block.timestamp / WEEK * WEEK;\n        start_time = _t;\n        last_token_time = _t;\n        time_cursor = _t;\n        address _token = IVotingEscrow(_voting_escrow).token();\n        token = _token;\n        voting_escrow = _voting_escrow;\n        depositor = msg.sender;\n        IERC20(_token).approve(_voting_escrow, type(uint).max);\n    }\n\n    function timestamp() external view returns (uint) {\n        return block.timestamp / WEEK * WEEK;\n    }\n\n    function _checkpoint_token() internal {\n        uint token_balance = IERC20(token).balanceOf(address(this));\n        uint to_distribute = token_balance - token_last_balance;\n        token_last_balance = token_balance;\n\n        uint t = last_token_time;\n        uint since_last = block.timestamp - t;\n        last_token_time = block.timestamp;\n        uint this_week = t / WEEK * WEEK;\n        uint next_week = 0;\n\n        for (uint i = 0; i < 20; i++) {\n            next_week = this_week + WEEK;\n            if (block.timestamp < next_week) {\n                if (since_last == 0 && block.timestamp == t) {\n                    tokens_per_week[this_week] += to_distribute;\n                } else {\n                    tokens_per_week[this_week] += to_distribute * (block.timestamp - t) / since_last;\n                }\n                break;\n            } else {\n                if (since_last == 0 && next_week == t) {\n                    tokens_per_week[this_week] += to_distribute;\n                } else {\n                    tokens_per_week[this_week] += to_distribute * (next_week - t) / since_last;\n                }\n            }\n            t = next_week;\n            this_week = next_week;\n        }\n        emit CheckpointToken(block.timestamp, to_distribute);\n    }\n\n    function checkpoint_token() external {\n        assert(msg.sender == depositor);\n        _checkpoint_token();\n    }\n\n    function _find_timestamp_epoch(address ve, uint _timestamp) internal view returns (uint) {\n        uint _min = 0;\n        uint _max = IVotingEscrow(ve).epoch();\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(_mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function _find_timestamp_user_epoch(address ve, uint tokenId, uint _timestamp, uint max_user_epoch) internal view returns (uint) {\n        uint _min = 0;\n        uint _max = max_user_epoch;\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).user_point_history(tokenId, _mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid -1;\n            }\n        }\n        return _min;\n    }\n\n    function ve_for_at(uint _tokenId, uint _timestamp) external view returns (uint) {\n        address ve = voting_escrow;\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint epoch = _find_timestamp_user_epoch(ve, _tokenId, _timestamp, max_user_epoch);\n        IVotingEscrow.Point memory pt = IVotingEscrow(ve).user_point_history(_tokenId, epoch);\n        return Math.max(uint(int256(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))), 0);\n    }\n\n    function _checkpoint_total_supply() internal {\n        address ve = voting_escrow;\n        uint t = time_cursor;\n        uint rounded_timestamp = block.timestamp / WEEK * WEEK;\n        IVotingEscrow(ve).checkpoint();\n\n        for (uint i = 0; i < 20; i++) {\n            if (t > rounded_timestamp) {\n                break;\n            } else {\n                uint epoch = _find_timestamp_epoch(ve, t);\n                IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(epoch);\n                int128 dt = 0;\n                if (t > pt.ts) {\n                    dt = int128(int256(t - pt.ts));\n                }\n                ve_supply[t] = Math.max(uint(int256(pt.bias - pt.slope * dt)), 0);\n            }\n            t += WEEK;\n        }\n        time_cursor = t;\n    }\n\n    function checkpoint_total_supply() external {\n        _checkpoint_total_supply();\n    }\n\n    function _claim(uint _tokenId, address ve, uint _last_token_time) internal returns (uint) {\n        uint user_epoch = 0;\n        uint to_distribute = 0;\n\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint _start_time = start_time;\n\n        if (max_user_epoch == 0) return 0;\n\n        uint week_cursor = time_cursor_of[_tokenId];\n        if (week_cursor == 0) {\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\n        } else {\n            user_epoch = user_epoch_of[_tokenId];\n        }\n\n        if (user_epoch == 0) user_epoch = 1;\n\n        IVotingEscrow.Point memory user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n\n        if (week_cursor == 0) week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK;\n        if (week_cursor >= last_token_time) return 0;\n        if (week_cursor < _start_time) week_cursor = _start_time;\n\n        IVotingEscrow.Point memory old_user_point;\n\n        for (uint i = 0; i < 50; i++) {\n            if (week_cursor >= _last_token_time) break;\n\n            if (week_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\n                user_epoch += 1;\n                old_user_point = user_point;\n                if (user_epoch > max_user_epoch) {\n                    user_point = IVotingEscrow.Point(0,0,0,0);\n                } else {\n                    user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n                }\n            } else {\n                int128 dt = int128(int256(week_cursor - old_user_point.ts));\n                uint balance_of = Math.max(uint(int256(old_user_point.bias - dt * old_user_point.slope)), 0);\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\n                if (balance_of != 0) {\n                    to_distribute += balance_of * tokens_per_week[week_cursor] / ve_supply[week_cursor];\n                }\n                week_cursor += WEEK;\n            }\n        }\n\n        user_epoch = Math.min(max_user_epoch, user_epoch - 1);\n        user_epoch_of[_tokenId] = user_epoch;\n        time_cursor_of[_tokenId] = week_cursor;\n\n        emit Claimed(_tokenId, to_distribute, user_epoch, max_user_epoch);\n\n        return to_distribute;\n    }\n\n    function _claimable(uint _tokenId, address ve, uint _last_token_time) internal view returns (uint) {\n        uint user_epoch = 0;\n        uint to_distribute = 0;\n\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\n        uint _start_time = start_time;\n\n        if (max_user_epoch == 0) return 0;\n\n        uint week_cursor = time_cursor_of[_tokenId];\n        if (week_cursor == 0) {\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\n        } else {\n            user_epoch = user_epoch_of[_tokenId];\n        }\n\n        if (user_epoch == 0) user_epoch = 1;\n\n        IVotingEscrow.Point memory user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n\n        if (week_cursor == 0) week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK;\n        if (week_cursor >= last_token_time) return 0;\n        if (week_cursor < _start_time) week_cursor = _start_time;\n\n        IVotingEscrow.Point memory old_user_point;\n\n        for (uint i = 0; i < 50; i++) {\n            if (week_cursor >= _last_token_time) break;\n\n            if (week_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\n                user_epoch += 1;\n                old_user_point = user_point;\n                if (user_epoch > max_user_epoch) {\n                    user_point = IVotingEscrow.Point(0,0,0,0);\n                } else {\n                    user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\n                }\n            } else {\n                int128 dt = int128(int256(week_cursor - old_user_point.ts));\n                uint balance_of = Math.max(uint(int256(old_user_point.bias - dt * old_user_point.slope)), 0);\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\n                if (balance_of != 0) {\n                    to_distribute += balance_of * tokens_per_week[week_cursor] / ve_supply[week_cursor];\n                }\n                week_cursor += WEEK;\n            }\n        }\n\n        return to_distribute;\n    }\n\n    function claimable(uint _tokenId) external view returns (uint) {\n        uint _last_token_time = last_token_time / WEEK * WEEK;\n        return _claimable(_tokenId, voting_escrow, _last_token_time);\n    }\n\n    function claim(uint _tokenId) external returns (uint) {\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\n        uint _last_token_time = last_token_time;\n        _last_token_time = _last_token_time / WEEK * WEEK;\n        uint amount = _claim(_tokenId, voting_escrow, _last_token_time);\n        if (amount != 0) {\n            IVotingEscrow(voting_escrow).deposit_for(_tokenId, amount);\n            token_last_balance -= amount;\n        }\n        return amount;\n    }\n\n    function claim_many(uint[] memory _tokenIds) external returns (bool) {\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\n        uint _last_token_time = last_token_time;\n        _last_token_time = _last_token_time / WEEK * WEEK;\n        address _voting_escrow = voting_escrow;\n        uint total = 0;\n\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint _tokenId = _tokenIds[i];\n            if (_tokenId == 0) break;\n            uint amount = _claim(_tokenId, _voting_escrow, _last_token_time);\n            if (amount != 0) {\n                IVotingEscrow(_voting_escrow).deposit_for(_tokenId, amount);\n                total += amount;\n            }\n        }\n        if (total != 0) {\n            token_last_balance -= total;\n        }\n\n        return true;\n    }\n\n    // Once off event on contract initialize\n    function setDepositor(address _depositor) external {\n        require(msg.sender == depositor);\n        depositor = _depositor;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribeFactory.sol';\nimport './interfaces/IGauge.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IMinter.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVotingEscrow.sol';\n\ncontract Voter {\n\n    address public immutable _ve; // the ve token that governs these contracts\n    address public immutable factory; // the PairFactory\n    address internal immutable base;\n    address public immutable gaugefactory;\n    address public immutable bribefactory;\n    uint internal constant DURATION = 5 days; // rewards are released over 5 days\n    uint internal constant BRIBE_LAG = 1 days;\n    address public minter;\n    address public governor; // should be set to an IGovernor\n    address public emergencyCouncil; // credibly neutral party similar to Curve's Emergency DAO\n\n    uint public totalWeight; // total voting weight\n\n    address[] public pools; // all pools viable for incentives\n    mapping(address => address) public gauges; // pool => gauge\n    mapping(address => address) public poolForGauge; // gauge => pool\n    mapping(address => address) public bribes; // gauge => bribe\n    mapping(address => uint256) public weights; // pool => weight\n    mapping(uint => mapping(address => uint256)) public votes; // nft => pool => votes\n    mapping(uint => address[]) public poolVote; // nft => pools\n    mapping(uint => uint) public usedWeights;  // nft => total voting weight of user\n    mapping(address => bool) public isGauge;\n    mapping(address => bool) public isWhitelisted;\n    mapping(address => bool) public isAlive;\n\n    event GaugeCreated(address indexed gauge, address creator, address indexed bribe, address indexed pool);\n    event GaugeKilled(address indexed gauge);\n    event GaugeRevived(address indexed gauge);\n    event Voted(address indexed voter, uint tokenId, uint256 weight);\n    event Abstained(uint tokenId, uint256 weight);\n    event Deposit(address indexed lp, address indexed gauge, uint tokenId, uint amount);\n    event Withdraw(address indexed lp, address indexed gauge, uint tokenId, uint amount);\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\n    event Whitelisted(address indexed whitelister, address indexed token);\n\n    constructor(address __ve, address _factory, address  _gauges, address _bribes) {\n        _ve = __ve;\n        factory = _factory;\n        base = IVotingEscrow(__ve).token();\n        gaugefactory = _gauges;\n        bribefactory = _bribes;\n        minter = msg.sender;\n        governor = msg.sender;\n        emergencyCouncil = msg.sender;\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function initialize(address[] memory _tokens, address _minter) external {\n        require(msg.sender == minter);\n        for (uint i = 0; i < _tokens.length; i++) {\n            _whitelist(_tokens[i]);\n        }\n        minter = _minter;\n    }\n\n    function setGovernor(address _governor) public {\n        require(msg.sender == governor);\n        governor = _governor;\n    }\n\n    function setEmergencyCouncil(address _council) public {\n        require(msg.sender == emergencyCouncil);\n        emergencyCouncil = _council;\n    }\n\n    function reset(uint _tokenId) external {\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        _reset(_tokenId);\n        IVotingEscrow(_ve).abstain(_tokenId);\n    }\n\n    function _reset(uint _tokenId) internal {\n        address[] storage _poolVote = poolVote[_tokenId];\n        uint _poolVoteCnt = _poolVote.length;\n        uint256 _totalWeight = 0;\n\n        for (uint i = 0; i < _poolVoteCnt; i ++) {\n            address _pool = _poolVote[i];\n            uint256 _votes = votes[_tokenId][_pool];\n\n            if (_votes != 0) {\n                _updateFor(gauges[_pool]);\n                weights[_pool] -= _votes;\n                votes[_tokenId][_pool] -= _votes;\n                if (_votes > 0) {\n                    _totalWeight += _votes;\n                }\n                IGauge(gauges[_pool]).setVoteStatus(IVotingEscrow(_ve).ownerOf(_tokenId), false);\n                emit Abstained(_tokenId, _votes);\n            }\n        }\n        totalWeight -= uint256(_totalWeight);\n        usedWeights[_tokenId] = 0;\n        delete poolVote[_tokenId];\n    }\n\n    function poke(uint _tokenId) external {\n        address[] memory _poolVote = poolVote[_tokenId];\n        uint _poolCnt = _poolVote.length;\n        uint256[] memory _weights = new uint256[](_poolCnt);\n\n        for (uint i = 0; i < _poolCnt; i ++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n        }\n\n        _vote(_tokenId, _poolVote, _weights);\n    }\n\n    function _vote(uint _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\n        _reset(_tokenId);\n        uint _poolCnt = _poolVote.length;\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\n        uint256 _totalVoteWeight = 0;\n        uint256 _totalWeight = 0;\n        uint256 _usedWeight = 0;\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            _totalVoteWeight += _weights[i];\n        }\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            address _pool = _poolVote[i];\n            address _gauge = gauges[_pool];\n\n            if (isGauge[_gauge]) {\n                uint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight;\n                require(votes[_tokenId][_pool] == 0);\n                require(_poolWeight != 0);\n                _updateFor(_gauge);\n\n                poolVote[_tokenId].push(_pool);\n\n                weights[_pool] += _poolWeight;\n                votes[_tokenId][_pool] += _poolWeight;\n                _usedWeight += _poolWeight;\n                _totalWeight += _poolWeight;\n                IGauge(gauges[_pool]).setVoteStatus(IVotingEscrow(_ve).ownerOf(_tokenId), true);\n                emit Voted(msg.sender, _tokenId, _poolWeight);\n            }\n        }\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\n        totalWeight += uint256(_totalWeight);\n        usedWeights[_tokenId] = uint256(_usedWeight);\n    }\n\n    function vote(uint tokenId, address[] calldata _poolVote, uint256[] calldata _weights) external {\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, tokenId));\n        require(_poolVote.length == _weights.length);\n        _vote(tokenId, _poolVote, _weights);\n    }\n\n    function whitelist(address _token) public {\n        require(msg.sender == governor);\n        _whitelist(_token);\n    }\n\n    function _whitelist(address _token) internal {\n        require(!isWhitelisted[_token]);\n        isWhitelisted[_token] = true;\n        emit Whitelisted(msg.sender, _token);\n    }\n\n    function createGauge(address _pool) external returns (address) {\n        require(gauges[_pool] == address(0x0), \"exists\");\n        if (msg.sender != governor) { // gov can create for any pool, even non-Velodrome pairs\n            require(IPairFactory(factory).isPair(_pool), \"!_pool\");\n            (address tokenA, address tokenB) = IPair(_pool).tokens();\n            require(isWhitelisted[tokenA] && isWhitelisted[tokenB], \"!whitelisted\");\n        }\n        address _bribe = IBribeFactory(bribefactory).createBribe();\n        address _gauge = IGaugeFactory(gaugefactory).createGauge(_pool, _bribe, _ve);\n        IERC20(base).approve(_gauge, type(uint).max);\n        bribes[_gauge] = _bribe;\n        gauges[_pool] = _gauge;\n        poolForGauge[_gauge] = _pool;\n        isGauge[_gauge] = true;\n        isAlive[_gauge] = true;\n        _updateFor(_gauge);\n        pools.push(_pool);\n        emit GaugeCreated(_gauge, msg.sender, _bribe, _pool);\n        return _gauge;\n    }\n\n    function killGauge(address _gauge) external {\n        require(msg.sender == emergencyCouncil, \"not emergency council\");\n        require(isAlive[_gauge], \"gauge already dead\");\n        isAlive[_gauge] = false;\n        emit GaugeKilled(_gauge);\n    }\n\n    function reviveGauge(address _gauge) external {\n        require(msg.sender == emergencyCouncil, \"not emergency council\");\n        require(!isAlive[_gauge], \"gauge already alive\");\n        isAlive[_gauge] = true;\n        emit GaugeRevived(_gauge);\n    }\n\n    function attachTokenToGauge(uint tokenId, address account) external {\n        require(isGauge[msg.sender]);\n        require(isAlive[msg.sender]); // killed gauges cannot attach tokens to themselves\n        if (tokenId > 0) IVotingEscrow(_ve).attach(tokenId);\n        emit Attach(account, msg.sender, tokenId);\n    }\n\n    function emitDeposit(uint tokenId, address account, uint amount) external {\n        require(isGauge[msg.sender]);\n        require(isAlive[msg.sender]);\n        emit Deposit(account, msg.sender, tokenId, amount);\n    }\n\n    function detachTokenFromGauge(uint tokenId, address account) external {\n        require(isGauge[msg.sender]);\n        if (tokenId > 0) IVotingEscrow(_ve).detach(tokenId);\n        emit Detach(account, msg.sender, tokenId);\n    }\n\n    function emitWithdraw(uint tokenId, address account, uint amount) external {\n        require(isGauge[msg.sender]);\n        emit Withdraw(account, msg.sender, tokenId, amount);\n    }\n\n    function length() external view returns (uint) {\n        return pools.length;\n    }\n\n    uint internal index;\n    mapping(address => uint) internal supplyIndex;\n    mapping(address => uint) public claimable;\n\n    function notifyRewardAmount(uint amount) external {\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\n        uint256 _ratio = amount * 1e18 / totalWeight; // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n        emit NotifyReward(msg.sender, base, amount);\n    }\n\n    function updateFor(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            _updateFor(_gauges[i]);\n        }\n    }\n\n    function updateForRange(uint start, uint end) public {\n        for (uint i = start; i < end; i++) {\n            _updateFor(gauges[pools[i]]);\n        }\n    }\n\n    function updateAll() external {\n        updateForRange(0, pools.length);\n    }\n\n    function updateGauge(address _gauge) external {\n        _updateFor(_gauge);\n    }\n\n    function _updateFor(address _gauge) internal {\n        require(isAlive[_gauge]); // killed gauges cannot be updated\n        address _pool = poolForGauge[_gauge];\n        uint256 _supplied = weights[_pool];\n        if (_supplied > 0) {\n            uint _supplyIndex = supplyIndex[_gauge];\n            uint _index = index; // get global index0 for accumulated distro\n            supplyIndex[_gauge] = _index; // update _gauge current position to global position\n            uint _delta = _index - _supplyIndex; // see if there is any difference that need to be accrued\n            if (_delta > 0) {\n                uint _share = uint(_supplied) * _delta / 1e18; // add accrued difference for each supplied token\n                claimable[_gauge] += _share;\n            }\n        } else {\n            supplyIndex[_gauge] = index; // new users are set to the default global state\n        }\n    }\n\n    function claimRewards(address[] memory _gauges, address[][] memory _tokens) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]);\n        }\n    }\n\n    function distributeFees(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).claimFees();\n        }\n    }\n\n    function distribute(address _gauge) public lock {\n        require(isAlive[_gauge]); // killed gauges cannot distribute\n        uint dayCalc = block.timestamp % (7 days);\n        require((dayCalc < BRIBE_LAG) || (dayCalc > (DURATION + BRIBE_LAG)), \"cannot claim during votes period\");\n        IMinter(minter).update_period();\n        _updateFor(_gauge);\n        uint _claimable = claimable[_gauge];\n        if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {\n            claimable[_gauge] = 0;\n            IGauge(_gauge).notifyRewardAmount(base, _claimable);\n            emit DistributeReward(msg.sender, _gauge, _claimable);\n            // distribute bribes & fees too\n            IGauge(_gauge).deliverBribes();\n        }\n    }\n\n    function distro() external {\n        distribute(0, pools.length);\n    }\n\n    function distribute() external {\n        distribute(0, pools.length);\n    }\n\n    function distribute(uint start, uint finish) public {\n        for (uint x = start; x < finish; x++) {\n            distribute(gauges[pools[x]]);\n        }\n    }\n\n    function distribute(address[] memory _gauges) external {\n        for (uint x = 0; x < _gauges.length; x++) {\n            distribute(_gauges[x]);\n        }\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n\n\n",
        "CodeNames": [
            "Gauge.sol",
            "Bribe.sol",
            "RewardsDistributor.sol",
            "Voter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction getEpochStart(uint timestamp) public view returns (uint) {\n\tuint bribeStart = timestamp (timestamp % (7 days)) + BRIBE_LAG;\n\tuint bribeEnd = bribeStart + DURATION COOLDOWN;\n\treturn timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n}\n",
                    "//solidity\nfunction notifyRewardAmount(address token, uint amount) external lock {\n  require(amount  0);\n  if (!isReward[token]) {\n\trequire(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n  }\n  // bribes kick in at the start of next bribe period\n  uint adjustedTstamp = getEpochStart(block.timestamp);\n  uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n  _safeTransferFrom(token, msg.sender, address(this), amount);\n  tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n  if (!isReward[token]) {\n\t  isReward[token] = true;\n\t  rewards.push(token);\n\t  IGauge(gauge).addBribeRewardToken(token);\n  }\n\n  emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n}\n",
                    "//solidity\nfunction distribute(address _gauge) public lock {\n\trequire(isAlive[_gauge]); // killed gauges cannot distribute\n\tuint dayCalc = block.timestamp % (7 days);\n\trequire((dayCalc < BRIBE_LAG) || (dayCalc  (DURATION + BRIBE_LAG)), \"cannot claim during votes period\");\n\tIMinter(minter).update_period();\n\t_updateFor(_gauge);\n\tuint _claimable = claimable[_gauge];\n\tif (_claimable  IGauge(_gauge).left(base) && _claimable / DURATION  0) {\n\t\tclaimable[_gauge] = 0;\n\t\tIGauge(_gauge).notifyRewardAmount(base, _claimable);\n\t\temit DistributeReward(msg.sender, _gauge, _claimable);\n\t\t// distribute bribes & fees too\n\t\tIGauge(_gauge).deliverBribes();\n\t}\n}\n",
                    "//solidity\nfunction deliverBribes() external lock {\n\trequire(msg.sender == voter);\n\tIBribe sb = IBribe(bribe);\n\tuint bribeStart = block.timestamp (block.timestamp % (7 days)) + BRIBE_LAG;\n\tuint numRewards = sb.rewardsListLength();\n\n\tfor (uint i = 0; i < numRewards; i++) {\n\t\taddress token = sb.rewards(i);\n\t\tuint epochRewards = sb.deliverReward(token, bribeStart);\n\t\tif (epochRewards  0) {\n\t\t\t_notifyBribeAmount(token, epochRewards, bribeStart);\n\t\t}\n\t}\n}\n",
                    "//solidity\nfunction deliverReward(address token, uint epochStart) external lock returns (uint) {\n\trequire(msg.sender == gauge);\n\tuint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n\tif (rewardPerEpoch  0) {\n\t  _safeTransfer(token, address(gauge), rewardPerEpoch);\n\t}\n\treturn rewardPerEpoch;\n}\n"
                ],
                "Type": " Bribe Rewards Struck In Contract If Deposited During First Epoch",
                "Description": "\nBribe rewards added to the Bribe contract in the first epoch will not be claimable by any voters, and the rewards will struck in the Bribe contract.\n\n\nAssume that the current epoch is epoch 0, and start date of epoch 0 is Day 0.\n\nWhen a briber adds a new rewards by calling Bribe.notifyRewardAmount(), the Bribe.getEpochStart() will return the start date of current epoch (epoch 0) + 1 day (Bribe Lag)\n\nThus, adjustedTstamp will be set to Day 1. tokenRewardsPerEpoch[token][adjustedTstamp] will evaluate to tokenRewardsPerEpoch[DAI][Day 1] and the briber's rewards will be stored in tokenRewardsPerEpoch[DAI][Day 1]\n\nBribe.sol#L35(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L35)<br\n\nsolidity\nfunction getEpochStart(uint timestamp) public view returns (uint) {\n\tuint bribeStart = timestamp (timestamp % (7 days)) + BRIBE_LAG;\n\tuint bribeEnd = bribeStart + DURATION COOLDOWN;\n\treturn timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n}\n\n\nBribe.sol#L41(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41)<br\n\nsolidity\nfunction notifyRewardAmount(address token, uint amount) external lock {\n  require(amount  0);\n  if (!isReward[token]) {\n\trequire(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n  }\n  // bribes kick in at the start of next bribe period\n  uint adjustedTstamp = getEpochStart(block.timestamp);\n  uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n  _safeTransferFrom(token, msg.sender, address(this), amount);\n  tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n  if (!isReward[token]) {\n\t  isReward[token] = true;\n\t  rewards.push(token);\n\t  IGauge(gauge).addBribeRewardToken(token);\n  }\n\n  emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n}\n\n\nOn Day 6, the voting phase has ended and the state is currently in the reward phase. Alice decided to call the Voter.distribute to trigger the distribution of bribe rewards.\n\nHowever, the main issue is that calling the Voter.distribute  function on Epoch 0's Day 6 (Reward Phase) will not executed theGauge.deliverBribes() because claimable[_gauge] or _claimable is currently 0.\n\nGauge.deliverBribes() is the main function responsible for distributing bribe rewards. Since Gauge.deliverBribes() cannot be triggered, the bribe rewards are forever struck in the Bribe Contract.\n\nclaimable[_gauge] will always be zero on the first epoch because the gauge rewards will only come in the later epoch. The value ofclaimable[_gauge] will only increase when the Minter.update_period() function starts minting VELO and distribute them to the gauges. Per the source code of Minter(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Minter.sol#L46) contract, the VELO emission will only start from third epoch onwards (active_period = ((block.timestamp + (2 * WEEK)) / WEEK) * WEEK;). Thus, before the VELO emission, claimable[_gauge]will always remain at 0.\n\nVoter.sol#L315(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Voter.sol#L315)<br\n\nsolidity\nfunction distribute(address _gauge) public lock {\n\trequire(isAlive[_gauge]); // killed gauges cannot distribute\n\tuint dayCalc = block.timestamp % (7 days);\n\trequire((dayCalc < BRIBE_LAG) || (dayCalc  (DURATION + BRIBE_LAG)), \"cannot claim during votes period\");\n\tIMinter(minter).update_period();\n\t_updateFor(_gauge);\n\tuint _claimable = claimable[_gauge];\n\tif (_claimable  IGauge(_gauge).left(base) && _claimable / DURATION  0) {\n\t\tclaimable[_gauge] = 0;\n\t\tIGauge(_gauge).notifyRewardAmount(base, _claimable);\n\t\temit DistributeReward(msg.sender, _gauge, _claimable);\n\t\t// distribute bribes & fees too\n\t\tIGauge(_gauge).deliverBribes();\n\t}\n}\n\n\nIf someone attempt to call Voter.distribute() on epoch 1 or subsequent epoch, it will fetch the bribe rewards in their respective epoch.\n\nIn the Gauge.deliverBribes function, the code uint bribeStart = block.timestamp (block.timestamp % (7 days)) + BRIBE_LAG; will calculate the start date of current epoch + BRIBE_LAG (1 day). So, if someone call Gauge.deliverBribes in epoch 1, the bribeStart variable will be set to the Epoch 1 + 1 day, which is equivalent to Day 9. There is no way to fetch the bribe rewards struck in epoch 0.\n\nGauge.sol#L173(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L173)<br\n\nsolidity\nfunction deliverBribes() external lock {\n\trequire(msg.sender == voter);\n\tIBribe sb = IBribe(bribe);\n\tuint bribeStart = block.timestamp (block.timestamp % (7 days)) + BRIBE_LAG;\n\tuint numRewards = sb.rewardsListLength();\n\n\tfor (uint i = 0; i < numRewards; i++) {\n\t\taddress token = sb.rewards(i);\n\t\tuint epochRewards = sb.deliverReward(token, bribeStart);\n\t\tif (epochRewards  0) {\n\t\t\t_notifyBribeAmount(token, epochRewards, bribeStart);\n\t\t}\n\t}\n}\n\n\nBribe.sol#L83(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L83)<br\n\nsolidity\nfunction deliverReward(address token, uint epochStart) external lock returns (uint) {\n\trequire(msg.sender == gauge);\n\tuint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n\tif (rewardPerEpoch  0) {\n\t  _safeTransfer(token, address(gauge), rewardPerEpoch);\n\t}\n\treturn rewardPerEpoch;\n}\n\n\n",
                "Repair": "\nImplement logic to handle the edge case where bribe rewards are added during first epoch. Consider aligning the start of bribe period with VELO emission period.\n\npooltypes (Velodrome) acknowledged(https://github.com/code-423n4/2022-05-velodrome-findings/issues/168)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-05-velodrome-findings/issues/168#issuecomment-1171789235):\n  The warden has shown how tokens can be stuck in the Bribes Contract indefinitely.\n \n This is because bribes can be added at the beginning (day 0), while rewards can be received only after a delay (7 days), due to the need for a minimum amount of rewards to be available in order for bribes to be claimable, the logic will prevent the bribes deposited on day 0 to be claimable.\n \n I'm conflicted on the severity as technically this can only happen for the first week, however the loss of tokens is irreversible as there's no code that would allow rescuing them.\n \n On further consideration, because the deployment of new Bribes and Gauges is mostly permissioneless(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Voter.sol#L189), this bug will be present for every new pair of deployed contract, and it is highly likely that a new protocol would want to add rewards immediately.\n \n For those reasons, I believe High Severity to be appropriate.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "\n            if (cp0.voted) {\n                reward += cp0.balanceOf * (_rewardPerTokenStored1 _rewardPerTokenStored0) / PRECISION;\n"
                ],
                "Type": " Voting overwrites  checkpoint.voted  in last checkpoint, so users can just vote right before claiming rewards",
                "Description": "*Submitted by smiling_heretic*\n\nGauge.sol#L195(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L195)<br\nGauge.sol#L489-L490(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L489-L490)<br\nGauge.sol#L499-L500(https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L499-L500)\n\n\n            if (cp0.voted) {\n                reward += cp0.balanceOf * (_rewardPerTokenStored1 _rewardPerTokenStored0) / PRECISION;\n\n\nthis line in gauge.earned function looks like the intention here is to incentivize users to keep their escrow.balanceOfNft voted for this gauge.\n\nHowever, it's enough to vote just before claiming rewards (even in the same transaction) and voter.reset just after receiving rewards to pass this if and get rewards for full period since last interaction with the gauge.\n\n\nSee original submission(https://github.com/code-423n4/2022-05-velodrome-findings/issues/206) for test file.\n\nNote, that Bob kept his votes for this gauge for full 6-day period but Alice just voted before claiming rewards. In logs, we can see that they both received the same (non-zero) amount of VELO tokens.\n\nAlice can reset her votes in the same transaction after claiming rewards, if she decides to do so.\n\n\nFoundry\n\n",
                "Repair": "\nA partial solution would be to create a new checkpoint each time user's voted status changes (setVoteStatus is called) instead of overwriting the voted in last one.\n\nHowever, even then, users can just assign very small weight to this gauge, and lock very little VELO, so I don't think this if statement helps with anything. I think, it's better to rethink how to incentivize users to vote for specific gauges.\n\npooltypes (Velodrome) acknowledged and commented(https://github.com/code-423n4/2022-05-velodrome-findings/issues/206#issuecomment-1154110744):\n  Patched in mainnet deployment.\n\nAlex the Entreprenerd (judge) increased severity to High and commented(https://github.com/code-423n4/2022-05-velodrome-findings/issues/206#issuecomment-1171828685):\n  The warden has found a way to sidestep the loss of rewards that automatically happens due to the faulty checkpoint system that always sets voted to false.\n \n In doing so they also showed how the system can fall apart and provided a POC to replicate.\n \n Because I've rated issues related to the voted checkpoints and loss of rewards with High Severity, at this time I believe this finding should also be bumped as it shows how the system is broken and the way to avoid a loss of rewards.\n\n  The sponsor seems to have remedied by deleting the voted logic.\n\n\n\n*\n\n\n"
            }
        ]
    }
]