[
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IController.sol\";\nimport \"./IConverter.sol\";\nimport \"./IMetaVault.sol\";\n\n/**\n * @title MetaVault (yAxisMetaVault)\n * @notice The metavault is where users deposit and withdraw stablecoins\n * @dev This metavault will pay YAX incentive for depositors and stakers\n * It does not need minter key of YAX. Governance multisig will mint total\n * of 34000 YAX and send into the vault in the beginning\n */\ncontract MetaVault is ERC20, IMetaVault {\n    using Address for address;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv\n\n    IERC20 public token3CRV;\n    IERC20 public tokenYAX;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV\n    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\n\n    address public governance;\n    address public controller;\n    uint public insurance;\n    IVaultManager public vaultManager;\n    IConverter public converter;\n\n    bool public acceptContractDepositor = false; // dont accept contract at beginning\n\n    struct UserInfo {\n        uint amount;\n        uint yaxRewardDebt;\n        uint accEarned;\n    }\n\n    uint public lastRewardBlock;\n    uint public accYaxPerShare;\n\n    uint public yaxPerBlock;\n\n    mapping(address => UserInfo) public userInfo;\n\n    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;\n\n    uint public constant BLOCKS_PER_WEEK = 46500;\n\n    // Block number when each epoch ends.\n    uint[5] public epochEndBlocks;\n\n    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)\n    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];\n\n    /**\n     * @notice Emitted when a user deposits funds\n     */\n    event Deposit(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when a user withdraws funds\n     */\n    event Withdraw(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when YAX is paid to a user\n     */\n    event RewardPaid(address indexed user, uint reward);\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _tokenYAX The address of the YAX token\n     * @param _yaxPerBlock The amount of YAX rewarded per block\n     * @param _startBlock The starting block for rewards\n     */\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,\n        uint _yaxPerBlock, uint _startBlock) public ERC20(\"yAxis.io:MetaVault:3CRV\", \"MVLT\") {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        inputTokens[3] = _token3CRV;\n        token3CRV = _token3CRV;\n        tokenYAX = _tokenYAX;\n        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)\n        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)\n        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2\n        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4\n        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2\n        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4\n        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6\n        governance = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by a contract and we are not allowing.\n     */\n    modifier checkContract() {\n        if (!acceptContractDepositor) {\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance\n     * @dev Ignore insurance fund for balance calculations\n     */\n    function balance() public override view returns (uint) {\n        uint bal = token3CRV.balanceOf(address(this));\n        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));\n        return bal.sub(insurance);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for min\n     * @param _min The new min value\n     */\n    function setMin(uint _min) external {\n        require(msg.sender == governance, \"!governance\");\n        min = _min;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the governance address\n     * @param _governance The new governance value\n     */\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the controller address\n     * @param _controller The new controller value\n     */\n    function setController(address _controller) public override {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the converter address\n     * @param _converter The new converter value\n     * @dev Requires that the return address of token() from the converter is the\n     * same as token3CRV\n     */\n    function setConverter(IConverter _converter) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_converter.token() == address(token3CRV), \"!token3CRV\");\n        converter = _converter;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the vaultManager address\n     * @param _vaultManager The new vaultManager value\n     */\n    function setVaultManager(IVaultManager _vaultManager) public {\n        require(msg.sender == governance, \"!governance\");\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the earnLowerlimit\n     * @dev earnLowerlimit determines the minimum balance of this contract for earn\n     * to be called\n     * @param _earnLowerlimit The new earnLowerlimit value\n     */\n    function setEarnLowerlimit(uint _earnLowerlimit) public {\n        require(msg.sender == governance, \"!governance\");\n        earnLowerlimit = _earnLowerlimit;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(uint _totalDepositCap) public {\n        require(msg.sender == governance, \"!governance\");\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for acceptContractDepositor\n     * @dev acceptContractDepositor allows the metavault to accept deposits from\n     * smart contract addresses\n     * @param _acceptContractDepositor The new acceptContractDepositor value\n     */\n    function setAcceptContractDepositor(bool _acceptContractDepositor) public {\n        require(msg.sender == governance, \"!governance\");\n        acceptContractDepositor = _acceptContractDepositor;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for yaxPerBlock\n     * @dev Makes a call to updateReward()\n     * @param _yaxPerBlock The new yaxPerBlock value\n     */\n    function setYaxPerBlock(uint _yaxPerBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        updateReward();\n        yaxPerBlock = _yaxPerBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochEndBlocks at the given index\n     * @dev Throws if _index >= 5\n     * @dev Throws if _epochEndBlock > the current block.number\n     * @dev Throws if the stored block.number at the given index is > the current block.number\n     * @param _index The index to set of epochEndBlocks\n     * @param _epochEndBlock The new epochEndBlocks value at the index\n     */\n    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index < 5, \"_index out of range\");\n        require(_epochEndBlock > block.number, \"Too late to update\");\n        require(epochEndBlocks[_index] > block.number, \"Too late to update\");\n        epochEndBlocks[_index] = _epochEndBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index\n     * @dev Throws if _index < 1 or > 5\n     * @dev Throws if the stored block.number at the previous index is > the current block.number\n     * @param _index The index to set of epochRewardMultiplers\n     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index\n     */\n    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index > 0 && _index < 6, \"Index out of range\");\n        require(epochEndBlocks[_index - 1] > block.number, \"Too late to update\");\n        epochRewardMultiplers[_index] = _epochRewardMultipler;\n    }\n\n    /**\n     * @notice Return reward multiplier over the given _from to _to block.\n     * @param _from The from block\n     * @param _to The to block\n     */\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        // start at the end of the epochs\n        for (uint8 epochId = 5; epochId >= 1; --epochId) {\n            // if _to (the current block number if called within this contract) is after the previous epoch ends\n            if (_to >= epochEndBlocks[epochId - 1]) {\n                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier\n                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);\n                // get the multiplier amount for the remaining reward of the current epoch\n                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);\n                // if epoch is 1: return the remaining current epoch reward with the first epoch reward\n                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n                // for all epochs in between the first and current epoch\n                for (epochId = epochId - 1; epochId >= 1; --epochId) {\n                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch\n                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));\n                    // accumulate the multipler with the reward from the epoch\n                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));\n                }\n                // return the accumulated multiplier with the reward from the first epoch\n                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n            }\n        }\n        // return the reward amount between _from and _to in the first epoch\n        return _to.sub(_from).mul(epochRewardMultiplers[0]);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the treasuryWallet\n     * @param _treasuryWallet The new treasuryWallet value\n     */\n    function setTreasuryWallet(address _treasuryWallet) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryWallet = _treasuryWallet;\n    }\n\n    /**\n     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund\n     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare\n     */\n    function claimInsurance() external override {\n        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)\n        // otherwise send the fund to treasuryWallet\n        if (msg.sender != controller) {\n            // claim by governance for insurance\n            require(msg.sender == governance, \"!governance\");\n            token3CRV.safeTransfer(treasuryWallet, insurance);\n        }\n        insurance = 0;\n    }\n\n    /**\n     * @notice Get the address of the 3CRV token\n     */\n    function token() public override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Get the amount that the metavault allows to be borrowed\n     * @dev min and max are used to keep small withdrawals cheap\n     */\n    function available() public override view returns (uint) {\n        return token3CRV.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /**\n     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount\n     * @param _amount The amount being queried to withdraw\n     */\n    function withdrawFee(uint _amount) public override view returns (uint) {\n        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn() public override {\n        if (controller != address(0)) {\n            IController _contrl = IController(controller);\n            if (_contrl.investEnabled()) {\n                uint _bal = available();\n                token3CRV.safeTransfer(controller, _bal);\n                _contrl.earn(address(token3CRV), _bal);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV given for the amounts deposited\n     * @param amounts The stablecoin amounts being deposited\n     */\n    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {\n        return converter.calc_token_amount(amounts, true);\n    }\n\n    /**\n     * @notice Returns the amount given in the desired token for the given shares\n     * @param _shares The amount of shares to withdraw\n     * @param _output The desired token to withdraw\n     */\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\n        uint _withdrawFee = withdrawFee(_shares);\n        if (_withdrawFee > 0) {\n            _shares = _shares.mul(10000 - _withdrawFee).div(10000);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        if (_output == address(token3CRV)) {\n            return r;\n        }\n        return converter.calc_token_amount_withdraw(r, _output);\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens\n     * @param _input The stablecoin to convert to 3CRV\n     * @param _amount The amount of stablecoin to convert\n     */\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\n        return converter.convert_rate(_input, address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Deposit a single stablecoin to the metavault\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amount The amount of the stablecoin to deposit\n     * @param _input The address of the stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {\n        require(_amount > 0, \"!_amount\");\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        if (_input == address(token3CRV)) {\n            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {\n            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);\n            converter.convert(_input, address(token3CRV), _amount);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_amount >= _min_mint_amount, \"slippage\");\n        if (_amount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _amount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _amount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits multiple stablecoins simultaneously to the metavault\n     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amounts The amounts of each stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        bool hasStables = false;\n        for (uint8 i = 0; i < 4; i++) {\n            uint _inputAmount = _amounts[i];\n            if (_inputAmount > 0) {\n                if (i == 3) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);\n                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);\n                    hasStables = true;\n                }\n            }\n        }\n        if (hasStables) {\n            uint[3] memory _stablesAmounts;\n            _stablesAmounts[0] = _amounts[0];\n            _stablesAmounts[1] = _amounts[1];\n            _stablesAmounts[2] = _amounts[2];\n            converter.convert_stables(_stablesAmounts);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_totalDepositAmount >= _min_mint_amount, \"slippage\");\n        if (_totalDepositAmount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _totalDepositAmount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Stakes metavault shares\n     * @param _shares The amount of shares to stake\n     */\n    function stakeShares(uint _shares) external {\n        uint _before = balanceOf(address(this));\n        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);\n        uint _after = balanceOf(address(this));\n        _shares = _after.sub(_before);\n        // Additional check for deflationary tokens\n        _stakeShares(_shares);\n    }\n\n    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _insuranceFee = vaultManager.insuranceFee();\n            if (_insuranceFee > 0) {\n                uint _insurance = _amount.mul(_insuranceFee).div(10000);\n                _amount = _amount.sub(_insurance);\n                insurance = insurance.add(_insurance);\n            }\n        }\n\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        if (_shares > 0) {\n            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {\n                earn();\n            }\n            _mint(_mintTo, _shares);\n        }\n    }\n\n    function _stakeShares(uint _shares) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        updateReward();\n        _getReward();\n        user.amount = user.amount.add(_shares);\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Returns the pending YAXs for a given account\n     * @param _account The address to query\n     */\n    function pendingYax(address _account) public view returns (uint _pending) {\n        UserInfo storage user = userInfo[_account];\n        uint _accYaxPerShare = accYaxPerShare;\n        uint lpSupply = balanceOf(address(this));\n        if (block.number > lastRewardBlock && lpSupply != 0) {\n            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        }\n        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n    }\n\n    /**\n     * @notice Sets the lastRewardBlock and accYaxPerShare\n     */\n    function updateReward() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = balanceOf(address(this));\n        if (lpSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        lastRewardBlock = block.number;\n    }\n\n    function _getReward() internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n        if (_pendingYax > 0) {\n            user.accEarned = user.accEarned.add(_pendingYax);\n            safeYaxTransfer(msg.sender, _pendingYax);\n            emit RewardPaid(msg.sender, _pendingYax);\n        }\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired stablecoin to receive\n     */\n    function withdrawAll(address _output) external {\n        unstake(userInfo[msg.sender].amount);\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n     * @param reserve The address of the token to swap to 3CRV\n     * @param amount The amount to swap\n     */\n    function harvest(address reserve, uint amount) external override {\n        require(msg.sender == controller, \"!controller\");\n        require(reserve != address(token3CRV), \"token3CRV\");\n        IERC20(reserve).safeTransfer(controller, amount);\n    }\n\n    /**\n     * @notice Unstakes the given shares from the metavault\n     * @dev call unstake(0) to only receive the reward\n     * @param _amount The amount to unstake\n     */\n    function unstake(uint _amount) public {\n        updateReward();\n        _getReward();\n        UserInfo storage user = userInfo[msg.sender];\n        if (_amount > 0) {\n            require(user.amount >= _amount, \"stakedBal < _amount\");\n            user.amount = user.amount.sub(_amount);\n            IERC20(address(this)).transfer(msg.sender, _amount);\n        }\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output stablecoin\n     * @dev No rebalance implementation for lower fees and faster swaps\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the stablecoin to receive\n     */\n    function withdraw(uint _shares, address _output) public override {\n        uint _userBal = balanceOf(msg.sender);\n        if (_shares > _userBal) {\n            uint _need = _shares.sub(_userBal);\n            require(_need <= userInfo[msg.sender].amount, \"_userBal+staked < _shares\");\n            unstake(_need);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();\n            if (_withdrawalProtectionFee > 0) {\n                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);\n                r = r.sub(_withdrawalProtection);\n            }\n        }\n\n        // Check balance\n        uint b = token3CRV.balanceOf(address(this));\n        if (b < r) {\n            uint _toWithdraw = r.sub(b);\n            if (controller != address(0)) {\n                IController(controller).withdraw(address(token3CRV), _toWithdraw);\n            }\n            uint _after = token3CRV.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        if (_output == address(token3CRV)) {\n            token3CRV.safeTransfer(msg.sender, r);\n        } else {\n            require(converter.convert_rate(address(token3CRV), _output, r) > 0, \"rate=0\");\n            token3CRV.safeTransfer(address(converter), r);\n            uint _outputAmount = converter.convert(address(token3CRV), _output, r);\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function want() external override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Returns the rate of earnings of a single share\n     */\n    function getPricePerFullShare() external override view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @notice Transfers YAX from the metavault to a given address\n     * @dev Ensures the metavault has enough balance to transfer\n     * @param _to The address to transfer to\n     * @param _amount The amount to transfer\n     */\n    function safeYaxTransfer(address _to, uint _amount) internal {\n        uint _tokenBal = tokenYAX.balanceOf(address(this));\n        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);\n    }\n\n    /**\n     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV\n     * @param _token The address to convert\n     */\n    function earnExtra(address _token) public {\n        require(msg.sender == governance, \"!governance\");\n        require(address(_token) != address(token3CRV), \"3crv\");\n        require(address(_token) != address(this), \"mlvt\");\n        uint _amount = IERC20(_token).balanceOf(address(this));\n        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, \"rate=0\");\n        IERC20(_token).safeTransfer(address(converter), _amount);\n        converter.convert(_token, address(token3CRV), _amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IVault {\n    function token() external view returns (address);\n    function priceE18() external view returns (uint);\n    function deposit(uint) external;\n    function withdraw(uint) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n\n\n",
        "CodeNames": [
            "MetaVault.sol",
            "FlamIncome.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n// @audit why not sub _diff?\n_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);\n"
                ],
                "Type": "  Controller.setCap  sets wrong vault balance",
                "Description": "\nThe Controller.setCap function sets a cap for a strategy and withdraws any excess amounts (_diff).\nThe vault balance is decreased by the entire strategy balance instead of by this _diff:\n\nsolidity\n// @audit why not sub _diff?\n_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);\n\n\nThe _vaultDetails[_vault].balance variable does not correctly track the actual vault balances anymore, it will usually underestimate the vault balance.\nThis variable is used in Controller.balanceOf(), which in turn is used in Vault.balance(), which in turn is used to determine how many shares to mint / amount to receive when redeeming shares.\nIf the value is less, users will lose money as they can redeem fewer tokens.\nAlso, an attacker can deposit and will receive more shares than they should receive. They can then wait until the balance is correctly updated again and withdraw their shares for a higher amount than they deposited. This leads to the vault losing tokens.\n\n",
                "Repair": "Sub the _diff instead of the balance: _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n\nHaz077 (yAxis) confirmed and patched(https://github.com/code-423n4/2021-09-yaxis-findings/issues/128#issuecomment-931659339):\n  Already fixed in code-423n4/2021-09-yaxis#1\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/128#issuecomment-943538237):\n  Finding is valid, has been mitigated by sponsor as of 14 days ago\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IHarvester.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IManager.sol\";\n\n/**\n * @title Controller\n * @notice This controller allows multiple strategies to be used\n * for a single vault supporting multiple tokens.\n */\ncontract Controller is IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IManager public immutable override manager;\n\n    bool public globalInvestEnabled;\n    uint256 public maxStrategies;\n\n    struct VaultDetail {\n        address converter;\n        uint256 balance;\n        address[] strategies;\n        mapping(address => uint256) balances;\n        mapping(address => uint256) index;\n        mapping(address => uint256) caps;\n    }\n\n    // vault => Vault\n    mapping(address => VaultDetail) internal _vaultDetails;\n    // strategy => vault\n    mapping(address => address) internal _vaultStrategies;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(address indexed strategy);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy);\n\n    /**\n     * @notice Logged when strategies are reordered for a vault\n     */\n    event StrategiesReordered(\n        address indexed vault,\n        address indexed strategy1,\n        address indexed strategy2\n    );\n\n    /**\n     * @param _manager The address of the manager\n     */\n    constructor(\n        address _manager\n    )\n        public\n    {\n        manager = IManager(_manager);\n        globalInvestEnabled = true;\n        maxStrategies = 10;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The cap of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultDetails[_vault].converter != address(0), \"!converter\");\n        // checking if strategy is already added\n        require(_vaultStrategies[_strategy] == address(0), \"Strategy is already added\"); \n        // get the index of the newly added strategy\n        uint256 index = _vaultDetails[_vault].strategies.length;\n        // ensure we haven't added too many strategies already\n        require(index < maxStrategies, \"!maxStrategies\");\n        // push the strategy to the array of strategies\n        _vaultDetails[_vault].strategies.push(_strategy);\n        // set the cap\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        // set the index\n        _vaultDetails[_vault].index[_strategy] = index;\n        // store the mapping of strategy to the vault\n        _vaultStrategies[_strategy] = _vault;\n        if (_timeout > 0) {\n            // add it to the harvester\n            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);\n        }\n        emit StrategyAdded(_vault, _strategy, _cap);\n    }\n\n    /**\n     * @notice Withdraws token from a strategy to the treasury address as returned by the manager\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     */\n    function inCaseStrategyGetStuck(\n        address _strategy,\n        address _token\n    )\n        external\n        onlyStrategist\n    {\n        IStrategy(_strategy).withdraw(_token);\n        IERC20(_token).safeTransfer(\n            manager.treasury(),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Withdraws token from the controller to the treasury\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function inCaseTokensGetStuck(\n        address _token,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        IERC20(_token).safeTransfer(manager.treasury(), _amount);\n    }\n\n    /**\n     * @notice Removes a strategy for a given token\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the index of the strategy to remove\n        uint256 index = vaultDetail.index[_strategy];\n        // get the index of the last strategy\n        uint256 tail = vaultDetail.strategies.length.sub(1);\n        // get the address of the last strategy\n        address replace = vaultDetail.strategies[tail];\n        // replace the removed strategy with the tail\n        vaultDetail.strategies[index] = replace;\n        // set the new index for the replaced strategy\n        vaultDetail.index[replace] = index;\n        // remove the duplicate replaced strategy\n        vaultDetail.strategies.pop();\n        // remove the strategy's index\n        delete vaultDetail.index[_strategy];\n        // remove the strategy's cap\n        delete vaultDetail.caps[_strategy];\n        // remove the strategy's balance\n        delete vaultDetail.balances[_strategy];\n        // remove the mapping of strategy to the vault\n        delete _vaultStrategies[_strategy];\n        // pull funds from the removed strategy to the vault\n        IStrategy(_strategy).withdrawAll();\n        // remove the strategy from the harvester\n        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);\n        emit StrategyRemoved(_vault, _strategy);\n    }\n\n    /**\n     * @notice Reorders two strategies for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy1 The address of the first strategy\n     * @param _strategy2 The address of the second strategy\n     */\n    function reorderStrategies(\n        address _vault,\n        address _strategy1,\n        address _strategy2\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultStrategies[_strategy1] == _vault, \"!_strategy1\");\n        require(_vaultStrategies[_strategy2] == _vault, \"!_strategy2\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the indexes of the strategies\n        uint256 index1 = vaultDetail.index[_strategy1];\n        uint256 index2 = vaultDetail.index[_strategy2];\n        // set the new addresses at their indexes\n        vaultDetail.strategies[index1] = _strategy2;\n        vaultDetail.strategies[index2] = _strategy1;\n        // update indexes\n        vaultDetail.index[_strategy1] = index2;\n        vaultDetail.index[_strategy2] = index1;\n        emit StrategiesReordered(_vault, _strategy1, _strategy2);\n    }\n\n    /**\n     * @notice Sets/updates the cap of a strategy for a vault\n     * @dev If the balance of the strategy is greater than the new cap (except if\n     * the cap is 0), then withdraw the difference from the strategy to the vault.\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The new cap of the strategy\n     */\n    function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets/updates the converter for a given vault\n     * @param _vault The address of the vault\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _vault,\n        address _converter\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedConverters(_converter), \"!allowedConverters\");\n        _vaultDetails[_vault].converter = _converter;\n    }\n\n    /**\n     * @notice Sets/updates the global invest enabled flag\n     * @param _investEnabled The new bool of the invest enabled flag\n     */\n    function setInvestEnabled(\n        bool _investEnabled\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        globalInvestEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Sets/updates the maximum number of strategies for a vault\n     * @param _maxStrategies The new value of the maximum strategies\n     */\n    function setMaxStrategies(\n        uint256 _maxStrategies\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        maxStrategies = _maxStrategies;\n    }\n\n    function skim(\n        address _strategy\n    )\n        external\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).skim();\n        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Withdraws all funds from a strategy\n     * @param _strategy The address of the strategy\n     * @param _convert The token address to convert to\n     */\n    function withdrawAll(\n        address _strategy,\n        address _convert\n    )\n        external\n        override\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).withdrawAll();\n        uint256 _amount = IERC20(_want).balanceOf(address(this));\n        address _vault = _vaultStrategies[_strategy];\n        updateBalance(_vault, _strategy);\n        if (_convert != address(0)) {\n            IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n            IERC20(_want).safeTransfer(address(_converter), _amount);\n            _amount = _converter.convert(_want, _convert, _amount, 1);\n            IERC20(_convert).safeTransfer(_vault, _amount);\n        } else {\n            IERC20(_want).safeTransfer(_vault, _amount);\n        }\n        uint256 _balance = _vaultDetails[_vault].balance;\n        if (_balance >= _amount) {\n            _vaultDetails[_vault].balance = _balance.sub(_amount);\n        } else {\n            _vaultDetails[_vault].balance = 0;\n        }\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests the specified strategy\n     * @param _strategy The address of the strategy\n     */\n    function harvestStrategy(\n        address _strategy,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n        override\n        notHalted\n        onlyHarvester\n        onlyStrategy(_strategy)\n    {\n        uint256 _before = IStrategy(_strategy).balanceOf();\n        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);\n        uint256 _after = IStrategy(_strategy).balanceOf();\n        address _vault = _vaultStrategies[_strategy];\n        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n        _vaultDetails[_vault].balances[_strategy] = _after;\n        emit Harvest(_strategy);\n    }\n\n    /**\n     * VAULT-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Invests funds into a strategy\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function earn(\n        address _strategy,\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        notHalted\n        onlyStrategy(_strategy)\n        onlyVault(_token)\n    {\n        // get the want token of the strategy\n        address _want = IStrategy(_strategy).want();\n        if (_want != _token) {\n            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);\n            IERC20(_token).safeTransfer(address(_converter), _amount);\n            // TODO: do estimation for received\n            _amount = _converter.convert(_token, _want, _amount, 1);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);\n        // call the strategy deposit function\n        IStrategy(_strategy).deposit();\n        updateBalance(msg.sender, _strategy);\n    }\n\n    /**\n     * @notice Withdraws funds from a strategy\n     * @dev If the withdraw amount is greater than the first strategy given\n     * by getBestStrategyWithdraw, this function will loop over strategies\n     * until the requested amount is met.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdraw(\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault(_token)\n    {\n        (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        ) = getBestStrategyWithdraw(_token, _amount);\n        for (uint i = 0; i < _strategies.length; i++) {\n            // getBestStrategyWithdraw will return arrays larger than needed\n            // if this happens, simply exit the loop\n            if (_strategies[i] == address(0)) {\n                break;\n            }\n            IStrategy(_strategies[i]).withdraw(_amounts[i]);\n            updateBalance(msg.sender, _strategies[i]);\n            address _want = IStrategy(_strategies[i]).want();\n            if (_want != _token) {\n                address _converter = _vaultDetails[msg.sender].converter;\n                IERC20(_want).safeTransfer(_converter, _amounts[i]);\n                // TODO: do estimation for received\n                IConverter(_converter).convert(_want, _token, _amounts[i], 1);\n            }\n        }\n        _amount = IERC20(_token).balanceOf(address(this));\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the rough balance of the sum of all strategies for a given vault\n     * @dev This function is optimized to prevent looping over all strategy balances,\n     * and instead the controller tracks the earn, withdraw, and harvest amounts.\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return _vaultDetails[msg.sender].balance;\n    }\n\n    /**\n     * @notice Returns the converter assigned for the given vault\n     * @param _vault Address of the vault\n     */\n    function converter(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return _vaultDetails[_vault].converter;\n    }\n\n    /**\n     * @notice Returns the cap of a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function getCap(\n        address _vault,\n        address _strategy\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _vaultDetails[_vault].caps[_strategy];\n    }\n\n    /**\n     * @notice Returns whether investing is enabled for the calling vault\n     * @dev Should be called by the vault\n     */\n    function investEnabled()\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (globalInvestEnabled) {\n            return _vaultDetails[msg.sender].strategies.length > 0;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategies(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return _vaultDetails[_vault].strategies;\n    }\n\n    /**\n     * @notice Returns the length of the strategies of the calling vault\n     * @dev This function is expected to be called by a vault\n     */\n    function strategies()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _vaultDetails[msg.sender].strategies.length;\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from\n     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays\n     * from this function will always be the same length as the amount of strategies for\n     * a token. Check that _strategies[i] != address(0) when consuming to know when to\n     * break out of the loop.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function getBestStrategyWithdraw(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        )\n    {\n        // get the length of strategies for a single token\n        address _vault = manager.vaults(_token);\n        uint256 k = _vaultDetails[_vault].strategies.length;\n        // initialize fixed-length memory arrays\n        _strategies = new address[](k);\n        _amounts = new uint256[](k);\n        address _strategy;\n        uint256 _balance;\n        // scan forward from the the beginning of strategies\n        for (uint i = 0; i < k; i++) {\n            _strategy = _vaultDetails[_vault].strategies[i];\n            _strategies[i] = _strategy;\n            // get the balance of the strategy\n            _balance = _vaultDetails[_vault].balances[_strategy];\n            // if the strategy doesn't have the balance to cover the withdraw\n            if (_balance < _amount) {\n                // withdraw what we can and add to the _amounts\n                _amounts[i] = _balance;\n                _amount = _amount.sub(_balance);\n            } else {\n                // stop scanning if the balance is more than the withdraw amount\n                _amounts[i] = _amount;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the stored balance of a given strategy for a vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function updateBalance(\n        address _vault,\n        address _strategy\n    )\n        internal\n    {\n        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @notice Reverts if the protocol is halted\n     */\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not governance\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the strategy is not allowed in the manager\n     */\n    modifier onlyStrategy(address _strategy) {\n        require(manager.allowedStrategies(_strategy), \"!allowedStrategy\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the harvester\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the vault for the given token\n     */\n    modifier onlyVault(address _token) {\n        require(msg.sender == manager.vaults(_token), \"!vault\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "python\nstrategy_balance = strategy.functions.balanceOf().call()\ncontroller.functions.setCap(vault.address, strategy.address, strategy_balance 1, dai.address).transact()\n\n## this would be reverted\nvault.functions.withdrawAll(dai.address).transact()\n"
                ],
                "Type": "  set cap breaks vault's Balance",
                "Description": "\nIn controller.sol's function setCap, the contract wrongly handles _vaultDetails[_vault].balance. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. See Controller.sol L262-L278(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278).\n_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);\n\nThis would result in vaultDetails[_vault].balance being far smaller than the strategy's value. A user would trigger the assertion at Controller.sol#475(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L475) and the fund would be locked in the strategy.\n\nThough setCap is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.\n\nWe can trigger the issue by setting the cap 1 wei smaller than the strategy's balance.\n\npython\nstrategy_balance = strategy.functions.balanceOf().call()\ncontroller.functions.setCap(vault.address, strategy.address, strategy_balance 1, dai.address).transact()\n\n## this would be reverted\nvault.functions.withdrawAll(dai.address).transact()\n\n\nHardhat\n\n",
                "Repair": "I believe the dev would spot the issue in the test if _vaultDetails[_vault].balance is a public variable.\n\nOne possible fix is to subtract the difference of the balance.\n\nsolidity\nuint previousBalance = IStrategy(_strategy).balanceOf();\n_vaultDetails[_vault].balance.sub(previousBalance.sub(_amount));\n\n\ntransferAndCall (yAxis) confirmed and patched(https://github.com/code-423n4/2021-09-yaxis-findings/issues/1#issuecomment-917659418):\n  Please review https://github.com/code-423n4/2021-09-yaxis/pull/1 to verify resolution.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/1#issuecomment-941742896):\n  High risk vulnerability due to incorrect logic which can impact protocol functionality\n\n Sponsor has mitigated\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "updateBalance(_vault, _strategy)",
                    "withdraw",
                    "inCaseStrategyGetStuck",
                    "getBestStrategyWithdraw"
                ],
                "Type": "  Controller.inCaseStrategyGetStuck  does not update balance",
                "Description": "\nThe Controller.inCaseStrategyGetStuck withdraws from a strategy but does not call updateBalance(_vault, _strategy) afterwards.\n\nThe _vaultDetails[_vault].balances[_strategy] variable does not correctly track the actual strategy balance anymore.\nI'm not sure what exactly this field is used for besides getting the withdraw amounts per strategy in getBestStrategyWithdraw.\nAs the strategy contains a lower amount than stored in the field, Controller.withdraw will attempt to withdraw too much.\n\n",
                "Repair": "Call updateBalance(_vault, _strategy) in inCaseStrategyGetStuck.\n\nHaz077 (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/130)\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/130#issuecomment-943400238):\n  Agree with finding, I also believe inCaseStrategyGetStuck and inCaseTokenGetStuck are vectors for admin rugging, may want to add checks to ensure only non strategy token can be withdrawn from the vaults and strats\n\nBobbyYaxis (yAxis) noted:\n It's a needed function for the strategist. The risk of these functions are mitigated as the strategies and controller should never have a balance of any tokens regardless. So there should be nothing/meaningful for the strategist to ever \"rug\" in that sense. But we can make this a governance-only feature, rather than strategist.\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "reorderStrategies()"
                ],
                "Type": "  manager.allowedVaults  check missing for add/remove strategy",
                "Description": "\nThe manager.allowedVaults check is missing for add/remove strategy like how it is used in reorderStrategies(). This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.\n\nGiven the critical access control that is missing on vaults here, this is classified as medium severity.\n\nController.sol#L101 L130(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L101-L130)\nController.sol#L172 L207(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L172-L207)\nController.sol L224(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L224)\nManager.sol#L210 L221(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L210-L221)\n\nManual Analysis\n\n",
                "Repair": "Add manager.allowedVaults check in addStrategy() and removeStrategy()\n\nGainsGoblin (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/50)\n\nHaz077 (yAxis) confirmed(https://github.com/code-423n4/2021-09-yaxis-findings/issues/50)\n\nuN2RVw5q commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/50#issuecomment-933009311):\n  Implemented in https://github.com/code-423n4/2021-09-yaxis/pull/36\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/50#issuecomment-943479681):\n  Sponsor has acknowledged and mitigated by adding further access control checks\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable max-states-count\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title Manager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract Manager is IManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;\n    uint256 public constant MAX_TOKENS = 256;\n\n    address public immutable override yaxis;\n\n    bool public override halted;\n\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override pendingStrategist;\n    address public override treasury;\n\n    // The following fees are all mutable.\n    // They are updated by governance (community vote).\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n\n    uint256 private setPendingStrategistTime;\n\n    // Governance must first allow the following properties before\n    // the strategist can make use of them\n    mapping(address => bool) public override allowedControllers;\n    mapping(address => bool) public override allowedConverters;\n    mapping(address => bool) public override allowedStrategies;\n    mapping(address => bool) public override allowedTokens;\n    mapping(address => bool) public override allowedVaults;\n\n    // vault => controller\n    mapping(address => address) public override controllers;\n    // vault => tokens[]\n    mapping(address => address[]) public override tokens;\n    // token => vault\n    mapping(address => address) public override vaults;\n\n    event AllowedController(\n        address indexed _controller,\n        bool _allowed\n    );\n    event AllowedConverter(\n        address indexed _converter,\n        bool _allowed\n    );\n    event AllowedStrategy(\n        address indexed _strategy,\n        bool _allowed\n    );\n    event AllowedToken(\n        address indexed _token,\n        bool _allowed\n    );\n    event AllowedVault(\n        address indexed _vault,\n        bool _allowed\n    );\n    event Halted();\n    event SetController(\n        address indexed _vault,\n        address indexed _controller\n    );\n    event SetGovernance(\n        address indexed _governance\n    );\n    event SetPendingStrategist(\n        address indexed _strategist\n    );\n    event SetStrategist(\n        address indexed _strategist\n    );\n    event TokenAdded(\n        address indexed _vault,\n        address indexed _token\n    );\n    event TokenRemoved(\n        address indexed _vault,\n        address indexed _token\n    );\n\n    /**\n     * @param _yaxis The address of the YAX token\n     */\n    constructor(\n        address _yaxis\n    )\n        public\n    {\n        require(_yaxis != address(0), \"!_yaxis\");\n        yaxis = _yaxis;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        treasury = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the permission for the given controller\n     * @param _controller The address of the controller\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedController(\n        address _controller,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IController(_controller).manager()) == address(this), \"!manager\");\n        allowedControllers[_controller] = _allowed;\n        emit AllowedController(_controller, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given converter\n     * @param _converter The address of the converter\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedConverter(\n        address _converter,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IConverter(_converter).manager()) == address(this), \"!manager\");\n        allowedConverters[_converter] = _allowed;\n        emit AllowedConverter(_converter, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given strategy\n     * @param _strategy The address of the strategy\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedStrategy(\n        address _strategy,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IStrategy(_strategy).manager()) == address(this), \"!manager\");\n        allowedStrategies[_strategy] = _allowed;\n        emit AllowedStrategy(_strategy, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given token\n     * @param _token The address of the token\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedToken(\n        address _token,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        allowedTokens[_token] = _allowed;\n        emit AllowedToken(_token, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given vault\n     * @param _vault The address of the vault\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedVault(\n        address _vault,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IVault(_vault).manager()) == address(this), \"!manager\");\n        allowedVaults[_vault] = _allowed;\n        emit AllowedVault(_vault, _allowed);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(\n        address _governance\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        governance = _governance;\n        emit SetGovernance(_governance);\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(\n        address _harvester\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IHarvester(_harvester).manager()) == address(this), \"!manager\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(\n        uint256 _insuranceFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(\n        address _insurancePool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(\n        uint256 _insurancePoolFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(\n        address _stakingPool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(\n        uint256 _stakingPoolShareFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the pending strategist and the timestamp\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(\n        address _strategist\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_strategist != address(0), \"!_strategist\");\n        pendingStrategist = _strategist;\n        // solhint-disable-next-line not-rely-on-time\n        setPendingStrategistTime = block.timestamp;\n        emit SetPendingStrategist(_strategist);\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(\n        address _treasury\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasury != address(0), \"!_treasury\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(\n        uint256 _treasuryFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasuryFee <= 2000, \"_treasuryFee over 20%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(\n        uint256 _withdrawalProtectionFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Updates the strategist to the pending strategist\n     * @dev This can only be called after the pending strategist timelock (7 days)\n     */\n    function acceptStrategist()\n        external\n        notHalted\n    {\n        require(msg.sender == pendingStrategist, \"!pendingStrategist\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), \"PENDING_STRATEGIST_TIMELOCK\");\n        delete pendingStrategist;\n        delete setPendingStrategistTime;\n        strategist = msg.sender;\n        emit SetStrategist(msg.sender);\n    }\n\n    /**\n     * @notice Adds a token to be able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function addToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(allowedTokens[_token], \"!allowedTokens\");\n        require(allowedVaults[_vault], \"!allowedVaults\");\n        require(tokens[_vault].length < MAX_TOKENS, \">tokens\");\n        require(vaults[_token] == address(0), \"!_token\");\n        vaults[_token] = _vault;\n        tokens[_vault].push(_token);\n        emit TokenAdded(_vault, _token);\n    }\n\n    /**\n     * @notice Allows the strategist to pull tokens out of this contract\n     * @dev This contract should never hold tokens\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function recoverToken(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Removes a token from being able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function removeToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        uint256 k = tokens[_vault].length;\n        uint256 index;\n        bool found;\n\n        for (uint i = 0; i < k; i++) {\n            if (tokens[_vault][i] == _token) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        // TODO: Verify added check\n        if (found) {\n            tokens[_vault][index] = tokens[_vault][k-1];\n            tokens[_vault].pop();\n            delete vaults[_token];\n            emit TokenRemoved(_vault, _token);\n        }\n    }\n\n    /**\n     * @notice Sets the vault address for a controller\n     * @param _vault The address of the vault\n     * @param _controller The address of the controller\n     */\n    function setController(\n        address _vault,\n        address _controller\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!_vault\");\n        require(allowedControllers[_controller], \"!_controller\");\n        controllers[_vault] = _controller;\n        emit SetController(_vault, _controller);\n    }\n\n    /**\n     * @notice Sets the protocol as halted, disallowing all deposits forever\n     * @dev Withdraws will still work, allowing users to exit the protocol\n     */\n    function setHalted()\n        external\n        notHalted\n        onlyStrategist\n    {\n        halted = true;\n        emit Halted();\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns an array of token addresses for a given vault\n     * @param _vault The address of the vault\n     */\n    function getTokens(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return tokens[_vault];\n    }\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAXIS token address,\n     *     Treasury address,\n     *     Treasury fee\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (\n            yaxis,\n            treasury,\n            treasuryFee\n        );\n    }\n\n    modifier notHalted() {\n        require(!halted, \"halted\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == strategist, \"!strategist\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Manager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n    manager.functions.addToken(vault.address, dai.address).transact()\n    manager.functions.addToken(vault.address, dai.address).transact()\n"
                ],
                "Type": " No safety check in  addToken ",
                "Description": "\nThere's no safety check in Manager.sol addToken. There are two possible cases that might happen.\n\n1.  One token being added twice in a Vault. Token would be counted doubly in the vault. Ref: Vault.sol#L293-L303(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303). There would be two item in the array when querying manager.getTokens(address(this));.\n\n2.  A token first being added to two vaults. The value calculation of the first vault would be broken. As vaults[_token] = _vault; would point to the other vault.\n\nPermission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there's likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.\n\nAdding same token twice would not raise any error here.\nsolidity\n    manager.functions.addToken(vault.address, dai.address).transact()\n    manager.functions.addToken(vault.address, dai.address).transact()\n\nHardhat\n\n",
                "Repair": "I recommend to add two checks\n\nsolidity\nrequire(vaults[_token] == address(0));\nbool notFound = True;\nfor(uint256 i; i < tokens[_vault].length; i++) {\n    if (tokens[_vault] == _token) {\n        notFound = False;\n    }\n}\nrequire(notFound, \"duplicate token\");\n\n\ntransferAndCall (yAxis) confirmed and patched(https://github.com/code-423n4/2021-09-yaxis-findings/issues/3#issuecomment-917665371):\n  Please review https://github.com/code-423n4/2021-09-yaxis/pull/2 to verify resolution.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/3#issuecomment-942792919):\n  Lack of check for duplicates can cause undefined behaviour, sponsor mitigated by adding a require check\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "python\ndeposit_amount = 100000 * 1018\nuser = w3.eth.accounts[0]\nget_token(dai, user, deposit_amount)\ndai.functions.approve(vault.address, deposit_amount + margin_deposit).transact()\nvault.functions.deposit(dai.address, deposit_amount).transact()\nvault.functions.withdrawAll(usdt.address).transact()\n\n#\nprint(\"usdt amount: \", usdt.functions.balanceOf(user).call())\n"
                ],
                "Type": " Controller does not raise an error when there's insufficient liquidity",
                "Description": "\nWhen a user tries to withdraw the token from the vault, the vault would withdraw the token from the controller if there's insufficient liquidity in the vault. However, the controller does not raise an error when there's insufficient liquidity in the controller/ strategies. The user would lose his shares while getting nothing.\n\nAn MEV searcher could apply this attack on any withdrawal. When an attacker found an unconfirmed tx that tries to withdraw 1M dai, he can do such sandwich attack.\n\n1.  Deposits USDC into the vault.\n2.  Withdraw all dai left in the vault/controller/strategy.\n3.  Place the vitims tx here. The victim would get zero dai while burning 1 M share. This would pump the share price.\n4.  Withdraw all liquidity.\n\nAll users would be vulnerable to MEV attackers. I consider this is a high-risk issue.\n\nHere's web3.py script to reproduce the issue.\n\npython\ndeposit_amount = 100000 * 1018\nuser = w3.eth.accounts[0]\nget_token(dai, user, deposit_amount)\ndai.functions.approve(vault.address, deposit_amount + margin_deposit).transact()\nvault.functions.deposit(dai.address, deposit_amount).transact()\nvault.functions.withdrawAll(usdt.address).transact()\n\n#\nprint(\"usdt amount: \", usdt.functions.balanceOf(user).call())\n\n\n",
                "Repair": "There are two issues involved.\nFirst, users pay the slippage when they try to withdraw. I do not find this fair. Users have to pay extra gas to withdraw liquidity from strategy, convert the token, and still paying the slippage. I recommend writing a view function for the frontend to display how much slippage the user has to pay ([Controler.sol L448-L479(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L448-L479)).\n\nSecond, the controller does not revert the transaction there's insufficient liquidity ([Controller.sol#L577-L622(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L577-L622)).\n\nRecommend to revert the transaction when _amount is not equal to zero after the loop finishes.\n\nGainsGoblin (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/28)\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/28#issuecomment-943384332):\n  Agree with warden finding, this shows the path for an attack that is based on the Vault treating all tokens equally\n Since the finding shows a specific attack, the finding is unique\n\n Recommend the sponsor mitigates Single Sided Exposure risks to avoid this attack\n\nBobbyYaxis (yAxis) noted:\n We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n\n\n"
            },
            {
                "Name": "H-10",
                "Location": [
                    "//solidity\nfunction balanceOfThis()\n    public\n    view\n    returns (uint256 _balance)\n{\n    address[] memory _tokens = manager.getTokens(address(this));\n    for (uint8 i; i < _tokens.length; i++) {\n        address _token = _tokens[i];\n        _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n    }\n}\n",
                    "//solidity\nfunction harvestStrategy(\n    address _strategy,\n    uint256 _estimatedWETH,\n    uint256 _estimatedYAXIS\n)\n    external\n    override\n    notHalted\n    onlyHarvester\n    onlyStrategy(_strategy)\n{\n    uint256 _before = IStrategy(_strategy).balanceOf();\n    IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);\n    uint256 _after = IStrategy(_strategy).balanceOf();\n    address _vault = _vaultStrategies[_strategy];\n    _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n    _vaultDetails[_vault].balances[_strategy] = _after;\n    emit Harvest(_strategy);\n}\n",
                    "//solidity\n/\n * @notice Returns the total balance of the vault, including strategies\n */\nfunction balance()\n    public\n    view\n    override\n    returns (uint256 _balance)\n{\n    return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n}\n"
                ],
                "Type": " An attacker can steal funds from multi-token vaults",
                "Description": "\nThe total balance should NOT be simply added from different tokens' tokenAmounts, considering that the price of tokens may not be the same.\n\nVault.sol L324(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Vault.sol#L324)\n\nsolidity\nfunction balanceOfThis()\n    public\n    view\n    returns (uint256 _balance)\n{\n    address[] memory _tokens = manager.getTokens(address(this));\n    for (uint8 i; i < _tokens.length; i++) {\n        address _token = _tokens[i];\n        _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n    }\n}\n\n\nController.sol L396(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L396)\nsolidity\nfunction harvestStrategy(\n    address _strategy,\n    uint256 _estimatedWETH,\n    uint256 _estimatedYAXIS\n)\n    external\n    override\n    notHalted\n    onlyHarvester\n    onlyStrategy(_strategy)\n{\n    uint256 _before = IStrategy(_strategy).balanceOf();\n    IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);\n    uint256 _after = IStrategy(_strategy).balanceOf();\n    address _vault = _vaultStrategies[_strategy];\n    _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n    _vaultDetails[_vault].balances[_strategy] = _after;\n    emit Harvest(_strategy);\n}\n\n\nVault.sol L310(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Vault.sol#L310)\nsolidity\n/\n * @notice Returns the total balance of the vault, including strategies\n */\nfunction balance()\n    public\n    view\n    override\n    returns (uint256 _balance)\n{\n    return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n}\n\n\nAn attacker can steal funds from multi-token vaults. Resulting in fund loss of all other users.\n\nIf there is a multi-token vault with 3 tokens: DAI, USDC, USDT, and their price in USD is now 1.05, 0.98, and 0.95. If the current balances are: 2M, 1M, and 0.5M.\n\nAn attacker may do the following steps:\n\n1.  Deposit 3M of USDT;\n2.  Withdraw 3M, receive 2M in DAI and 1M in USDC.\n\nAs 2M of DAI + 1M of USDC worth much more than 3M of USDT. The attacker will profit and all other users will be losing funds.\n\n",
                "Repair": "Always consider the price differences between tokens.\n\nBobbyYaxis (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/77)\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/77#issuecomment-942445062):\n  Fully agree with the finding, assuming price of tokens is the same exposes the Vault and all depositors to risk of Single Sided Exposure\n\n This risk has been exploited multiple times, notably in the Yearn Exploit\n\n The solution for for managing tokens with multiple values while avoiding being rekt is to have an index that ensures your LP  Token maintains it's peg, curve's solution is called virtual_price\n\n Having a virtual price would allow to maintain the Vault Architecture, while mitigating exploits that directly use balances\n\nBobbyYaxis (yAxis) noted:\n We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IVaultManager {\n    function controllers(address) external view returns (bool);\n    function getHarvestFeeInfo() external view returns (address, address, uint256, address, uint256, address, uint256);\n    function governance() external view returns (address);\n    function harvester() external view returns (address);\n    function insuranceFee() external view returns (uint256);\n    function insurancePool() external view returns (address);\n    function insurancePoolFee() external view returns (uint256);\n    function stakingPool() external view returns (address);\n    function stakingPoolShareFee() external view returns (uint256);\n    function strategist() external view returns (address);\n    function treasury() external view returns (address);\n    function treasuryBalance() external view returns (uint256);\n    function treasuryFee() external view returns (uint256);\n    function vaults(address) external view returns (bool);\n    function withdrawalProtectionFee() external view returns (uint256);\n    function yax() external view returns (address);\n}\n\n\n",
        "CodeNames": [
            "IVaultManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\n_shares = _shares.add(_amount);\n",
                    "//solidity\nuint256 _amount = (balance().mul(_shares)).div(totalSupply());\n",
                    "python\ndeposit_amount = 100000 * 106\nuser = w3.eth.accounts[0]\nget_token(usdt, user, deposit_amount)\nusdt.functions.approve(vault.address, deposit_amount).transact()\nvault.functions.deposit(usdt.address, deposit_amount).transact()\nvault.functions.withdrawAll(t3crv.address).transact()\n# user can remove liquiditiy and get the profit.\n"
                ],
                "Type": " Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.",
                "Description": "\nThe v3 vault treats all valid tokens exactly the same. Depositing 1M DAI would get the same share as depositing 1M USDT. User can withdraw their share in another token. Though there's withdrawalProtectionFee (0.1 percent), the vault is still a no slippage stable coin exchange.\n\nAlso, I notice that 3crv_token is added to the vault in the test. Treating 3crv_token and all other stable coins the same would make the vault vulnerable to flashloan attack. 3crv_token is an lp token and at the point of writing, the price of it is 1.01. The arbitrage space is about 0.8 percent and makes the vault vulnerable to flashloan attacks.\n\nThough the team may not add crv_token and dai to the same vault, its design makes the vault vulnerable. Strategies need to be designed with super caution or the vault would be vulnerable to attackers.\n\nGiven the possibility of a flashloan attack, I consider this a high-risk issue.\n\nThe issue locates at the deposit function ([Vault.sol#L147-L180(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L147-L180)).\nThe share is minted according to the calculation here\n\nsolidity\n_shares = _shares.add(_amount);\n\n\nThe share is burned at Vault.sol L217(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217)\nsolidity\nuint256 _amount = (balance().mul(_shares)).div(totalSupply());\n\n\nHere's a sample exploit in web3.py.\n\npython\ndeposit_amount = 100000 * 106\nuser = w3.eth.accounts[0]\nget_token(usdt, user, deposit_amount)\nusdt.functions.approve(vault.address, deposit_amount).transact()\nvault.functions.deposit(usdt.address, deposit_amount).transact()\nvault.functions.withdrawAll(t3crv.address).transact()\n# user can remove liquiditiy and get the profit.\n\n\nHardhat\n\n",
                "Repair": "Given the protocols' scenario, I feel like we can take iearn token's architect as a Ref. yDdai(https://etherscan.io/address/0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01#code)\n\nyDai handles multiple tokens (cDai/ aDai/ dydx/ fulcrum). Though four tokens are pretty much the same, the contract still needs to calculate the price of each token.\n\nOr, creating a vault for each token might be an easier quick fix.\n\nHaz077 (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/2)\n\ntransferAndCall (yAxis) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-917660280):\n  The design of the v3 vaults is to intentionally assume that all allowed tokens are of equal value. I do not see us enabling the 3CRV token in our Vault test, though if we did, that doesn't mean we would in reality. Using a separate vault per token is an architecture we want to avoid.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-942441532):\n  Anecdotal example from warden makes sense.\n\n Assuming that 3CRV is worth the same as a stablecoin is in principle very similar to assuming that a swap between each stable on curve will yield a balanced trade\n\n This reminds me of the Single Sided Exposure Exploit that Yearn Suffered, and would recommend mitigating by checking the virtual_price on the 3CRV token\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-942441854):\n  TODO: Review and check duplicates, need to read yaxis vault code and use cases before can judge this\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-943418352):\n  After reviewing the code and the submissions, I have to agree that the vault creates arbitrage opportunities, since it heavily relies on 3CRV you may want to use it's virtual_price as a way to mitigate potential exploits, alternatively you can roll your own pricing oracle solution\n\n Not mitigating this opportunity means that an attacker will exploit it at the detriment of the depositors\n\nBobbyYaxis (yAxis) noted:\n We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IMetaVault {\n    function balance() external view returns (uint);\n    function setController(address _controller) external;\n    function claimInsurance() external;\n    function token() external view returns (address);\n    function available() external view returns (uint);\n    function withdrawFee(uint _amount) external view returns (uint);\n    function earn() external;\n    function calc_token_amount_deposit(uint[3] calldata amounts) external view returns (uint);\n    function calc_token_amount_withdraw(uint _shares, address _output) external view returns (uint);\n    function convert_rate(address _input, uint _amount) external view returns (uint);\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external;\n    function harvest(address reserve, uint amount) external;\n    function withdraw(uint _shares, address _output) external;\n    function want() external view returns (address);\n    function getPricePerFullShare() external view returns (uint);\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Gauge.sol\";\nimport \"../../interfaces/Balancer.sol\";\n\nimport \"../interfaces/ExtendedIERC20.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract NativeStrategyCurve3Crv is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    Mintr public immutable crvMintr;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    Gauge public immutable gauge; // 3Crv Gauge\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        Gauge _gauge,\n        Mintr _crvMintr,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _manager,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _manager, _want, _weth, _router)\n    {\n        crv = _crv;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        stableSwap3Pool = _stableSwap3Pool;\n        gauge = _gauge;\n        crvMintr = _crvMintr;\n        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit()\n        internal\n        override\n    {\n        uint256 _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit [want] to Gauge\n            gauge.deposit(_wantBal);\n        }\n    }\n\n    function _claimReward()\n        internal\n    {\n        crvMintr.mint(address(gauge));\n    }\n\n    function _addLiquidity()\n        internal\n    {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium()\n        public\n        view\n        returns (address, uint256)\n    {\n        uint daiBalance = stableSwap3Pool.balances(0);\n        // USDC - Supports a change up to the 18 decimal standard\n        uint usdcBalance = stableSwap3Pool.balances(1).mul(10**18).div(10**(ExtendedIERC20(usdc).decimals()));\n        uint usdtBalance = stableSwap3Pool.balances(2).mul(10**12);\n\n        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {\n            return (dai, 0);\n        }\n\n        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {\n            return (usdc, 1);\n        }\n\n        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        override\n    {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity();\n\n            _deposit();\n        }\n    }\n\n    function _withdrawAll()\n        internal\n        override\n    {\n        uint256 _bal = gauge.balanceOf(address(this));\n        _withdraw(_bal);\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        override\n    {\n        gauge.withdraw(_amount);\n    }\n\n    function balanceOfPool()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return gauge.balanceOf(address(this));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n\n\n",
        "CodeNames": [
            "IMetaVault.sol",
            "NativeStrategyCurve3Crv.sol",
            "YaxisVotePower.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "python\nprevious_price = vault.functions.getPricePerFullShare().call()\nvault.functions.available(dai.address).call()\nvault.functions.earn(dai.address, strategy.address).transact()\ncurrent_price = vault.functions.getPricePerFullShare().call()\nprint(previous_price)\nprint(current_price)\n"
                ],
                "Type": " earn results in decreasing share price",
                "Description": "\nFor a dai vault that pairs with NativeStrategyCurve3Crv, every time earn() is called, shareholders would lose money. (about 2%)\n\nThere are two issues involved. The Vault contract and the controller contract doesn't handle the price difference between the want token and other tokens.\n\nAt Vault.sol L293(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303), when a vault calculates its value, it sums up all tokens balance. However, when the controller calculates vaults' value (at Controller.sol L410-L436(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L410-L436)), it only adds the amount of strategy.want it received. (in this case, it's t3crv).\n\nUnder the current design, users who deposit dai to the vault would not get yield. Instead, they would keep losing money. I consider this a high-risk issue\n\nI trigger the bug with the following web3.py script:\n\npython\nprevious_price = vault.functions.getPricePerFullShare().call()\nvault.functions.available(dai.address).call()\nvault.functions.earn(dai.address, strategy.address).transact()\ncurrent_price = vault.functions.getPricePerFullShare().call()\nprint(previous_price)\nprint(current_price)\n\n\nHardhat\n\n",
                "Repair": "\nThe protocol should decide what the balance sheet in each contract stands for and make it consistent in all cases. Take, for example, if _vaultDetails[_vault].balance; stands for the amount of 'want' token the vault owns, there shouldn't exist two different want in all the strategies the vault has. Also, when the vault queries controllers function balanceOf(), they should always multiply it by the price.\n\ntransferAndCall (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/9)\n\ngpersoon commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/9#issuecomment-931250424):\n  I think this is also related to the underlying problem that all coins are assumed to have the same value.\n See also #2, #8 and #158\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/9#issuecomment-943490025):\n  Agree with wardens finding and acknowledge it's similitude with other issues\n\n Personally this is a different vulnerability that can be solved by solving the same underlying problem\n\n Marking this as unique finding as it's a specific exploit the protocol could face\n\nBobbyYaxis (yAxis) noted:\n We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./VaultToken.sol\";\n\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ExtendedIERC20.sol\";\n\n/**\n * @title Vault\n * @notice The vault is where users deposit and withdraw\n * like-kind assets that have been added by governance.\n */\ncontract Vault is VaultToken, IVault {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX = 10000;\n\n    IManager public immutable override manager;\n\n    // Strategist-updated variables\n    address public override gauge;\n    uint256 public min;\n    uint256 public totalDepositCap;\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event Earn(address indexed token, uint256 amount);\n\n    /**\n     * @param _name The name of the vault token for depositors\n     * @param _symbol The symbol of the vault token for depositors\n     * @param _manager The address of the vault manager contract\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _manager\n    )\n        public\n        VaultToken(_name, _symbol)\n    {\n        manager = IManager(_manager);\n        min = 9500;\n        totalDepositCap = 10000000 ether;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the value of this vault's gauge\n     * @dev Allow to be unset with the zero address\n     * @param _gauge The address of the gauge\n     */\n    function setGauge(\n        address _gauge\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        gauge = _gauge;\n    }\n\n    /**\n     * @notice Sets the value for min\n     * @dev min is the minimum percent of funds to keep small withdrawals cheap\n     * @param _min The new min value\n     */\n    function setMin(\n        uint256 _min\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(_min <= MAX, \"!_min\");\n        min = _min;\n    }\n\n    /**\n     * @notice Sets the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(\n        uint256 _totalDepositCap\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Swaps tokens held within the vault\n     * @param _token0 The token address to swap out\n     * @param _token1 The token address to to\n     * @param _expectedAmount The expected amount of _token1 to receive\n     */\n    function swap(\n        address _token0,\n        address _token1,\n        uint256 _expectedAmount\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n        returns (uint256 _balance)\n    {\n        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));\n        _balance = IERC20(_token0).balanceOf(address(this));\n        IERC20(_token0).safeTransfer(address(_converter), _balance);\n        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn(\n        address _token,\n        address _strategy\n    )\n        external\n        override\n        checkToken(_token)\n        notHalted\n        onlyHarvester\n    {\n        require(manager.allowedStrategies(_strategy), \"!_strategy\");\n        IController _controller = IController(manager.controllers(address(this)));\n        if (_controller.investEnabled()) {\n            uint256 _balance = available(_token);\n            IERC20(_token).safeTransfer(address(_controller), _balance);\n            _controller.earn(_strategy, _token, _balance);\n            emit Earn(_token, _balance);\n        }\n    }\n\n    /**\n     * USER-FACING FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits the given token into the vault\n     * @param _token The address of the token\n     * @param _amount The amount of tokens to deposit\n     */\n     function deposit(\n        address _token,\n        uint256 _amount\n     )\n        public\n        override\n        checkToken(_token)\n        notHalted\n        returns (uint256 _shares)\n    {\n        require(_amount > 0, \"!_amount\");\n\n        uint256 _balance = balance();\n\n        uint256 _before = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);\n\n        if (_amount > 0) {\n            _amount = _normalizeDecimals(_token, _amount);\n\n            if (totalSupply() > 0) {\n                _amount = (_amount.mul(totalSupply())).div(_balance);\n            }\n\n            _shares = _amount;\n        }\n\n        if (_shares > 0) {\n            _mint(msg.sender, _shares);\n            require(totalSupply() <= totalDepositCap, \">totalDepositCap\");\n            emit Deposit(msg.sender, _shares);\n        }\n    }\n\n    /**\n     * @notice Deposits multiple tokens simultaneously to the vault\n     * @dev Users must approve the vault to spend their stablecoin\n     * @param _tokens The addresses of each token being deposited\n     * @param _amounts The amounts of each token being deposited\n     */\n    function depositMultiple(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    )\n        external\n        override\n        returns (uint256 _shares)\n    {\n        require(_tokens.length == _amounts.length, \"!length\");\n\n        for (uint8 i; i < _amounts.length; i++) {\n            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));\n        }\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output token\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the token to receive\n     */\n    function withdraw(\n        uint256 _shares,\n        address _output\n    )\n        public\n        override\n        checkToken(_output)\n    {\n        uint256 _amount = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();\n        if (_withdrawalProtectionFee > 0) {\n            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);\n            _amount = _amount.sub(_withdrawalProtection);\n        }\n\n        uint256 _balance = IERC20(_output).balanceOf(address(this));\n        if (_balance < _amount) {\n            IController _controller = IController(manager.controllers(address(this)));\n            uint256 _toWithdraw = _amount.sub(_balance);\n            if (_controller.strategies() > 0) {\n                _controller.withdraw(_output, _toWithdraw);\n            }\n            uint256 _after = IERC20(_output).balanceOf(address(this));\n            uint256 _diff = _after.sub(_balance);\n            if (_diff < _toWithdraw) {\n                _amount = _after;\n            }\n        }\n\n        IERC20(_output).safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired token to receive\n     */\n    function withdrawAll(\n        address _output\n    )\n        external\n        override\n    {\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * VIEWS\n     */\n\n    /**\n     * @notice Returns the amount of tokens available to be sent to strategies\n     * @dev Custom logic in here for how much the vault allows to be borrowed\n     * @dev Sets minimum required on-hand to keep small withdrawals cheap\n     * @param _token The address of the token\n     */\n    function available(\n        address _token\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);\n    }\n\n    /**\n     * @notice Returns the total balance of the vault, including strategies\n     */\n    function balance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n    }\n\n    /**\n     * @notice Returns the balance of allowed tokens present on the vault only\n     */\n    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }\n\n    /**\n     * @notice Returns the rate of vault shares\n     */\n    function getPricePerFullShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() > 0) {\n            return balance().mul(1e18).div(totalSupply());\n        } else {\n            return balance();\n        }\n    }\n\n    /**\n     * @notice Returns an array of the tokens for this vault\n     */\n    function getTokens()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return manager.getTokens(address(this));\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing the given amount\n     * @param _amount The amount to withdraw\n     */\n    function withdrawFee(\n        uint256 _amount\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);\n    }\n\n    function _normalizeDecimals(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());\n        if (_decimals < 18) {\n            _amount = _amount.mul(10**(18-_decimals));\n        }\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier checkToken(address _token) {\n        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), \"!_token\");\n        _;\n    }\n\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVoteProxy {\n    IVoteProxy public voteProxy;\n    address public governance;\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function name() external pure returns (string memory) {\n        return \"YAXIS Vote Power\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"YAX VP\";\n    }\n\n    function decimals() external view returns (uint8) {\n        return voteProxy.decimals();\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return voteProxy.totalSupply();\n    }\n\n    function balanceOf(address _voter) external view returns (uint256) {\n        return voteProxy.balanceOf(_voter);\n    }\n\n    function setVoteProxy(IVoteProxy _voteProxy) external {\n        require(msg.sender == governance, \"!governance\");\n        voteProxy = _voteProxy;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n\n\n/**\n * This function allows governance to take unsupported tokens out of the contract.\n * This is in an effort to make someone whole, should they seriously mess up.\n * There is no guarantee governance will vote to return these.\n * It also allows for removal of airdropped tokens.\n */\n    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\n        require(msg.sender == governance, \"!governance\");\n        _token.transfer(to, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IVault {\n    function token() external view returns (address);\n    function priceE18() external view returns (uint);\n    function deposit(uint) external;\n    function withdraw(uint) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "YaxisVoteProxy.sol",
            "YaxisVotePower.sol",
            "FlamIncome.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "//solidity\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n"
                ],
                "Type": "  Vault.balance()  mixes normalized and standard amounts",
                "Description": "\nThe Vault.balance function uses the balanceOfThis function which scales (\"normalizes\") all balances to 18 decimals.\nsolidity\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n\nNote that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized.\nThe code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).\n\nThe result is that the balance() will be under-reported.\nThis leads to receiving wrong shares when depositing tokens, and a wrong amount when redeeming tokens.\n\n",
                "Repair": "The second term IController(manager.controllers(address(this))).balanceOf() must also be normalized before adding it.\nIController(manager.controllers(address(this))).balanceOf() uses _vaultDetails[msg.sender].balance which directly uses the raw token amounts which are not normalized.\n\nGainsGoblin (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/132)\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/132#issuecomment-943499944):\n  balance and balanceOfThis mixes the usage of decimals by alternatingly using _normalizeDecimals\n This can break accounting as well as create opportunities for abuse\n A consistent usage of _normalizeDecimals would mitigate\n\nBobbyYaxis (yAxis) noted:\n Mitigated in PR 114: https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IConverter {\n    function manager() external view returns (IManager);\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount,\n        uint256 _estimatedOutput\n    ) external returns (uint256 _outputAmount);\n    function expected(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external view returns (uint256 _outputAmount);\n}\n\n\n// SPDX-License-Identifier: MIT\n// solhint-disable\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IController.sol\";\nimport \"./IConverter.sol\";\nimport \"./IMetaVault.sol\";\n\n/**\n * @title MetaVault (yAxisMetaVault)\n * @notice The metavault is where users deposit and withdraw stablecoins\n * @dev This metavault will pay YAX incentive for depositors and stakers\n * It does not need minter key of YAX. Governance multisig will mint total\n * of 34000 YAX and send into the vault in the beginning\n */\ncontract MetaVault is ERC20, IMetaVault {\n    using Address for address;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv\n\n    IERC20 public token3CRV;\n    IERC20 public tokenYAX;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV\n    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\n\n    address public governance;\n    address public controller;\n    uint public insurance;\n    IVaultManager public vaultManager;\n    IConverter public converter;\n\n    bool public acceptContractDepositor = false; // dont accept contract at beginning\n\n    struct UserInfo {\n        uint amount;\n        uint yaxRewardDebt;\n        uint accEarned;\n    }\n\n    uint public lastRewardBlock;\n    uint public accYaxPerShare;\n\n    uint public yaxPerBlock;\n\n    mapping(address => UserInfo) public userInfo;\n\n    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;\n\n    uint public constant BLOCKS_PER_WEEK = 46500;\n\n    // Block number when each epoch ends.\n    uint[5] public epochEndBlocks;\n\n    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)\n    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];\n\n    /**\n     * @notice Emitted when a user deposits funds\n     */\n    event Deposit(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when a user withdraws funds\n     */\n    event Withdraw(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when YAX is paid to a user\n     */\n    event RewardPaid(address indexed user, uint reward);\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _tokenYAX The address of the YAX token\n     * @param _yaxPerBlock The amount of YAX rewarded per block\n     * @param _startBlock The starting block for rewards\n     */\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,\n        uint _yaxPerBlock, uint _startBlock) public ERC20(\"yAxis.io:MetaVault:3CRV\", \"MVLT\") {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        inputTokens[3] = _token3CRV;\n        token3CRV = _token3CRV;\n        tokenYAX = _tokenYAX;\n        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)\n        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)\n        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2\n        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4\n        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2\n        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4\n        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6\n        governance = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by a contract and we are not allowing.\n     */\n    modifier checkContract() {\n        if (!acceptContractDepositor) {\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance\n     * @dev Ignore insurance fund for balance calculations\n     */\n    function balance() public override view returns (uint) {\n        uint bal = token3CRV.balanceOf(address(this));\n        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));\n        return bal.sub(insurance);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for min\n     * @param _min The new min value\n     */\n    function setMin(uint _min) external {\n        require(msg.sender == governance, \"!governance\");\n        min = _min;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the governance address\n     * @param _governance The new governance value\n     */\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the controller address\n     * @param _controller The new controller value\n     */\n    function setController(address _controller) public override {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the converter address\n     * @param _converter The new converter value\n     * @dev Requires that the return address of token() from the converter is the\n     * same as token3CRV\n     */\n    function setConverter(IConverter _converter) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_converter.token() == address(token3CRV), \"!token3CRV\");\n        converter = _converter;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the vaultManager address\n     * @param _vaultManager The new vaultManager value\n     */\n    function setVaultManager(IVaultManager _vaultManager) public {\n        require(msg.sender == governance, \"!governance\");\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the earnLowerlimit\n     * @dev earnLowerlimit determines the minimum balance of this contract for earn\n     * to be called\n     * @param _earnLowerlimit The new earnLowerlimit value\n     */\n    function setEarnLowerlimit(uint _earnLowerlimit) public {\n        require(msg.sender == governance, \"!governance\");\n        earnLowerlimit = _earnLowerlimit;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(uint _totalDepositCap) public {\n        require(msg.sender == governance, \"!governance\");\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for acceptContractDepositor\n     * @dev acceptContractDepositor allows the metavault to accept deposits from\n     * smart contract addresses\n     * @param _acceptContractDepositor The new acceptContractDepositor value\n     */\n    function setAcceptContractDepositor(bool _acceptContractDepositor) public {\n        require(msg.sender == governance, \"!governance\");\n        acceptContractDepositor = _acceptContractDepositor;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for yaxPerBlock\n     * @dev Makes a call to updateReward()\n     * @param _yaxPerBlock The new yaxPerBlock value\n     */\n    function setYaxPerBlock(uint _yaxPerBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        updateReward();\n        yaxPerBlock = _yaxPerBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochEndBlocks at the given index\n     * @dev Throws if _index >= 5\n     * @dev Throws if _epochEndBlock > the current block.number\n     * @dev Throws if the stored block.number at the given index is > the current block.number\n     * @param _index The index to set of epochEndBlocks\n     * @param _epochEndBlock The new epochEndBlocks value at the index\n     */\n    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index < 5, \"_index out of range\");\n        require(_epochEndBlock > block.number, \"Too late to update\");\n        require(epochEndBlocks[_index] > block.number, \"Too late to update\");\n        epochEndBlocks[_index] = _epochEndBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index\n     * @dev Throws if _index < 1 or > 5\n     * @dev Throws if the stored block.number at the previous index is > the current block.number\n     * @param _index The index to set of epochRewardMultiplers\n     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index\n     */\n    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index > 0 && _index < 6, \"Index out of range\");\n        require(epochEndBlocks[_index - 1] > block.number, \"Too late to update\");\n        epochRewardMultiplers[_index] = _epochRewardMultipler;\n    }\n\n    /**\n     * @notice Return reward multiplier over the given _from to _to block.\n     * @param _from The from block\n     * @param _to The to block\n     */\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        // start at the end of the epochs\n        for (uint8 epochId = 5; epochId >= 1; --epochId) {\n            // if _to (the current block number if called within this contract) is after the previous epoch ends\n            if (_to >= epochEndBlocks[epochId - 1]) {\n                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier\n                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);\n                // get the multiplier amount for the remaining reward of the current epoch\n                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);\n                // if epoch is 1: return the remaining current epoch reward with the first epoch reward\n                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n                // for all epochs in between the first and current epoch\n                for (epochId = epochId - 1; epochId >= 1; --epochId) {\n                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch\n                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));\n                    // accumulate the multipler with the reward from the epoch\n                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));\n                }\n                // return the accumulated multiplier with the reward from the first epoch\n                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n            }\n        }\n        // return the reward amount between _from and _to in the first epoch\n        return _to.sub(_from).mul(epochRewardMultiplers[0]);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the treasuryWallet\n     * @param _treasuryWallet The new treasuryWallet value\n     */\n    function setTreasuryWallet(address _treasuryWallet) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryWallet = _treasuryWallet;\n    }\n\n    /**\n     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund\n     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare\n     */\n    function claimInsurance() external override {\n        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)\n        // otherwise send the fund to treasuryWallet\n        if (msg.sender != controller) {\n            // claim by governance for insurance\n            require(msg.sender == governance, \"!governance\");\n            token3CRV.safeTransfer(treasuryWallet, insurance);\n        }\n        insurance = 0;\n    }\n\n    /**\n     * @notice Get the address of the 3CRV token\n     */\n    function token() public override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Get the amount that the metavault allows to be borrowed\n     * @dev min and max are used to keep small withdrawals cheap\n     */\n    function available() public override view returns (uint) {\n        return token3CRV.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /**\n     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount\n     * @param _amount The amount being queried to withdraw\n     */\n    function withdrawFee(uint _amount) public override view returns (uint) {\n        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn() public override {\n        if (controller != address(0)) {\n            IController _contrl = IController(controller);\n            if (_contrl.investEnabled()) {\n                uint _bal = available();\n                token3CRV.safeTransfer(controller, _bal);\n                _contrl.earn(address(token3CRV), _bal);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV given for the amounts deposited\n     * @param amounts The stablecoin amounts being deposited\n     */\n    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {\n        return converter.calc_token_amount(amounts, true);\n    }\n\n    /**\n     * @notice Returns the amount given in the desired token for the given shares\n     * @param _shares The amount of shares to withdraw\n     * @param _output The desired token to withdraw\n     */\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\n        uint _withdrawFee = withdrawFee(_shares);\n        if (_withdrawFee > 0) {\n            _shares = _shares.mul(10000 - _withdrawFee).div(10000);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        if (_output == address(token3CRV)) {\n            return r;\n        }\n        return converter.calc_token_amount_withdraw(r, _output);\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens\n     * @param _input The stablecoin to convert to 3CRV\n     * @param _amount The amount of stablecoin to convert\n     */\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\n        return converter.convert_rate(_input, address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Deposit a single stablecoin to the metavault\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amount The amount of the stablecoin to deposit\n     * @param _input The address of the stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {\n        require(_amount > 0, \"!_amount\");\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        if (_input == address(token3CRV)) {\n            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {\n            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);\n            converter.convert(_input, address(token3CRV), _amount);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_amount >= _min_mint_amount, \"slippage\");\n        if (_amount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _amount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _amount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits multiple stablecoins simultaneously to the metavault\n     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amounts The amounts of each stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        bool hasStables = false;\n        for (uint8 i = 0; i < 4; i++) {\n            uint _inputAmount = _amounts[i];\n            if (_inputAmount > 0) {\n                if (i == 3) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);\n                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);\n                    hasStables = true;\n                }\n            }\n        }\n        if (hasStables) {\n            uint[3] memory _stablesAmounts;\n            _stablesAmounts[0] = _amounts[0];\n            _stablesAmounts[1] = _amounts[1];\n            _stablesAmounts[2] = _amounts[2];\n            converter.convert_stables(_stablesAmounts);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_totalDepositAmount >= _min_mint_amount, \"slippage\");\n        if (_totalDepositAmount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _totalDepositAmount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Stakes metavault shares\n     * @param _shares The amount of shares to stake\n     */\n    function stakeShares(uint _shares) external {\n        uint _before = balanceOf(address(this));\n        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);\n        uint _after = balanceOf(address(this));\n        _shares = _after.sub(_before);\n        // Additional check for deflationary tokens\n        _stakeShares(_shares);\n    }\n\n    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _insuranceFee = vaultManager.insuranceFee();\n            if (_insuranceFee > 0) {\n                uint _insurance = _amount.mul(_insuranceFee).div(10000);\n                _amount = _amount.sub(_insurance);\n                insurance = insurance.add(_insurance);\n            }\n        }\n\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        if (_shares > 0) {\n            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {\n                earn();\n            }\n            _mint(_mintTo, _shares);\n        }\n    }\n\n    function _stakeShares(uint _shares) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        updateReward();\n        _getReward();\n        user.amount = user.amount.add(_shares);\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Returns the pending YAXs for a given account\n     * @param _account The address to query\n     */\n    function pendingYax(address _account) public view returns (uint _pending) {\n        UserInfo storage user = userInfo[_account];\n        uint _accYaxPerShare = accYaxPerShare;\n        uint lpSupply = balanceOf(address(this));\n        if (block.number > lastRewardBlock && lpSupply != 0) {\n            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        }\n        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n    }\n\n    /**\n     * @notice Sets the lastRewardBlock and accYaxPerShare\n     */\n    function updateReward() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = balanceOf(address(this));\n        if (lpSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        lastRewardBlock = block.number;\n    }\n\n    function _getReward() internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n        if (_pendingYax > 0) {\n            user.accEarned = user.accEarned.add(_pendingYax);\n            safeYaxTransfer(msg.sender, _pendingYax);\n            emit RewardPaid(msg.sender, _pendingYax);\n        }\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired stablecoin to receive\n     */\n    function withdrawAll(address _output) external {\n        unstake(userInfo[msg.sender].amount);\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n     * @param reserve The address of the token to swap to 3CRV\n     * @param amount The amount to swap\n     */\n    function harvest(address reserve, uint amount) external override {\n        require(msg.sender == controller, \"!controller\");\n        require(reserve != address(token3CRV), \"token3CRV\");\n        IERC20(reserve).safeTransfer(controller, amount);\n    }\n\n    /**\n     * @notice Unstakes the given shares from the metavault\n     * @dev call unstake(0) to only receive the reward\n     * @param _amount The amount to unstake\n     */\n    function unstake(uint _amount) public {\n        updateReward();\n        _getReward();\n        UserInfo storage user = userInfo[msg.sender];\n        if (_amount > 0) {\n            require(user.amount >= _amount, \"stakedBal < _amount\");\n            user.amount = user.amount.sub(_amount);\n            IERC20(address(this)).transfer(msg.sender, _amount);\n        }\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output stablecoin\n     * @dev No rebalance implementation for lower fees and faster swaps\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the stablecoin to receive\n     */\n    function withdraw(uint _shares, address _output) public override {\n        uint _userBal = balanceOf(msg.sender);\n        if (_shares > _userBal) {\n            uint _need = _shares.sub(_userBal);\n            require(_need <= userInfo[msg.sender].amount, \"_userBal+staked < _shares\");\n            unstake(_need);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();\n            if (_withdrawalProtectionFee > 0) {\n                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);\n                r = r.sub(_withdrawalProtection);\n            }\n        }\n\n        // Check balance\n        uint b = token3CRV.balanceOf(address(this));\n        if (b < r) {\n            uint _toWithdraw = r.sub(b);\n            if (controller != address(0)) {\n                IController(controller).withdraw(address(token3CRV), _toWithdraw);\n            }\n            uint _after = token3CRV.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        if (_output == address(token3CRV)) {\n            token3CRV.safeTransfer(msg.sender, r);\n        } else {\n            require(converter.convert_rate(address(token3CRV), _output, r) > 0, \"rate=0\");\n            token3CRV.safeTransfer(address(converter), r);\n            uint _outputAmount = converter.convert(address(token3CRV), _output, r);\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function want() external override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Returns the rate of earnings of a single share\n     */\n    function getPricePerFullShare() external override view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @notice Transfers YAX from the metavault to a given address\n     * @dev Ensures the metavault has enough balance to transfer\n     * @param _to The address to transfer to\n     * @param _amount The amount to transfer\n     */\n    function safeYaxTransfer(address _to, uint _amount) internal {\n        uint _tokenBal = tokenYAX.balanceOf(address(this));\n        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);\n    }\n\n    /**\n     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV\n     * @param _token The address to convert\n     */\n    function earnExtra(address _token) public {\n        require(msg.sender == governance, \"!governance\");\n        require(address(_token) != address(token3CRV), \"3crv\");\n        require(address(_token) != address(this), \"mlvt\");\n        uint _amount = IERC20(_token).balanceOf(address(this));\n        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, \"rate=0\");\n        IERC20(_token).safeTransfer(address(converter), _amount);\n        converter.convert(_token, address(token3CRV), _amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./VaultToken.sol\";\n\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ExtendedIERC20.sol\";\n\n/**\n * @title Vault\n * @notice The vault is where users deposit and withdraw\n * like-kind assets that have been added by governance.\n */\ncontract Vault is VaultToken, IVault {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX = 10000;\n\n    IManager public immutable override manager;\n\n    // Strategist-updated variables\n    address public override gauge;\n    uint256 public min;\n    uint256 public totalDepositCap;\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event Earn(address indexed token, uint256 amount);\n\n    /**\n     * @param _name The name of the vault token for depositors\n     * @param _symbol The symbol of the vault token for depositors\n     * @param _manager The address of the vault manager contract\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _manager\n    )\n        public\n        VaultToken(_name, _symbol)\n    {\n        manager = IManager(_manager);\n        min = 9500;\n        totalDepositCap = 10000000 ether;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the value of this vault's gauge\n     * @dev Allow to be unset with the zero address\n     * @param _gauge The address of the gauge\n     */\n    function setGauge(\n        address _gauge\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        gauge = _gauge;\n    }\n\n    /**\n     * @notice Sets the value for min\n     * @dev min is the minimum percent of funds to keep small withdrawals cheap\n     * @param _min The new min value\n     */\n    function setMin(\n        uint256 _min\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(_min <= MAX, \"!_min\");\n        min = _min;\n    }\n\n    /**\n     * @notice Sets the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(\n        uint256 _totalDepositCap\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Swaps tokens held within the vault\n     * @param _token0 The token address to swap out\n     * @param _token1 The token address to to\n     * @param _expectedAmount The expected amount of _token1 to receive\n     */\n    function swap(\n        address _token0,\n        address _token1,\n        uint256 _expectedAmount\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n        returns (uint256 _balance)\n    {\n        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));\n        _balance = IERC20(_token0).balanceOf(address(this));\n        IERC20(_token0).safeTransfer(address(_converter), _balance);\n        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn(\n        address _token,\n        address _strategy\n    )\n        external\n        override\n        checkToken(_token)\n        notHalted\n        onlyHarvester\n    {\n        require(manager.allowedStrategies(_strategy), \"!_strategy\");\n        IController _controller = IController(manager.controllers(address(this)));\n        if (_controller.investEnabled()) {\n            uint256 _balance = available(_token);\n            IERC20(_token).safeTransfer(address(_controller), _balance);\n            _controller.earn(_strategy, _token, _balance);\n            emit Earn(_token, _balance);\n        }\n    }\n\n    /**\n     * USER-FACING FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits the given token into the vault\n     * @param _token The address of the token\n     * @param _amount The amount of tokens to deposit\n     */\n     function deposit(\n        address _token,\n        uint256 _amount\n     )\n        public\n        override\n        checkToken(_token)\n        notHalted\n        returns (uint256 _shares)\n    {\n        require(_amount > 0, \"!_amount\");\n\n        uint256 _balance = balance();\n\n        uint256 _before = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);\n\n        if (_amount > 0) {\n            _amount = _normalizeDecimals(_token, _amount);\n\n            if (totalSupply() > 0) {\n                _amount = (_amount.mul(totalSupply())).div(_balance);\n            }\n\n            _shares = _amount;\n        }\n\n        if (_shares > 0) {\n            _mint(msg.sender, _shares);\n            require(totalSupply() <= totalDepositCap, \">totalDepositCap\");\n            emit Deposit(msg.sender, _shares);\n        }\n    }\n\n    /**\n     * @notice Deposits multiple tokens simultaneously to the vault\n     * @dev Users must approve the vault to spend their stablecoin\n     * @param _tokens The addresses of each token being deposited\n     * @param _amounts The amounts of each token being deposited\n     */\n    function depositMultiple(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    )\n        external\n        override\n        returns (uint256 _shares)\n    {\n        require(_tokens.length == _amounts.length, \"!length\");\n\n        for (uint8 i; i < _amounts.length; i++) {\n            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));\n        }\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output token\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the token to receive\n     */\n    function withdraw(\n        uint256 _shares,\n        address _output\n    )\n        public\n        override\n        checkToken(_output)\n    {\n        uint256 _amount = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();\n        if (_withdrawalProtectionFee > 0) {\n            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);\n            _amount = _amount.sub(_withdrawalProtection);\n        }\n\n        uint256 _balance = IERC20(_output).balanceOf(address(this));\n        if (_balance < _amount) {\n            IController _controller = IController(manager.controllers(address(this)));\n            uint256 _toWithdraw = _amount.sub(_balance);\n            if (_controller.strategies() > 0) {\n                _controller.withdraw(_output, _toWithdraw);\n            }\n            uint256 _after = IERC20(_output).balanceOf(address(this));\n            uint256 _diff = _after.sub(_balance);\n            if (_diff < _toWithdraw) {\n                _amount = _after;\n            }\n        }\n\n        IERC20(_output).safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired token to receive\n     */\n    function withdrawAll(\n        address _output\n    )\n        external\n        override\n    {\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * VIEWS\n     */\n\n    /**\n     * @notice Returns the amount of tokens available to be sent to strategies\n     * @dev Custom logic in here for how much the vault allows to be borrowed\n     * @dev Sets minimum required on-hand to keep small withdrawals cheap\n     * @param _token The address of the token\n     */\n    function available(\n        address _token\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);\n    }\n\n    /**\n     * @notice Returns the total balance of the vault, including strategies\n     */\n    function balance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n    }\n\n    /**\n     * @notice Returns the balance of allowed tokens present on the vault only\n     */\n    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }\n\n    /**\n     * @notice Returns the rate of vault shares\n     */\n    function getPricePerFullShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() > 0) {\n            return balance().mul(1e18).div(totalSupply());\n        } else {\n            return balance();\n        }\n    }\n\n    /**\n     * @notice Returns an array of the tokens for this vault\n     */\n    function getTokens()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return manager.getTokens(address(this));\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing the given amount\n     * @param _amount The amount to withdraw\n     */\n    function withdrawFee(\n        uint256 _amount\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);\n    }\n\n    function _normalizeDecimals(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());\n        if (_decimals < 18) {\n            _amount = _amount.mul(10**(18-_decimals));\n        }\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier checkToken(address _token) {\n        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), \"!_token\");\n        _;\n    }\n\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface dRewards {\n    function withdraw(uint) external;\n    function getReward() external;\n    function stake(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function exit() external;\n}\n\ninterface dERC20 {\n  function mint(address, uint256) external;\n  function redeem(address, uint) external;\n  function getTokenBalance(address) external view returns (uint);\n  function getExchangeRate() external view returns (uint);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Aave {\n    function borrow(address _reserve, uint _amount, uint _interestRateModel, uint16 _referralCode) external;\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;\n    function repay(address _reserve, uint _amount, address payable _onBehalfOf) external payable;\n    function getUserAccountData(address _user)\n        external\n        view\n        returns (\n            uint totalLiquidityETH,\n            uint totalCollateralETH,\n            uint totalBorrowsETH,\n            uint totalFeesETH,\n            uint availableBorrowsETH,\n            uint currentLiquidationThreshold,\n            uint ltv,\n            uint healthFactor\n        );\n    function getUserReserveData(address _reserve, address _user)\n        external\n        view\n        returns (\n            uint currentATokenBalance,\n            uint currentBorrowBalance,\n            uint principalBorrowBalance,\n            uint borrowRateMode,\n            uint borrowRate,\n            uint liquidityRate,\n            uint originationFee,\n            uint variableBorrowIndex,\n            uint lastUpdateTimestamp,\n            bool usageAsCollateralEnabled\n        );\n}\n\ninterface LendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n    function getLendingPoolCore() external view returns (address);\n    function getPriceOracle() external view returns (address);\n}\n\ninterface AaveToken {\n    function underlyingAssetAddress() external view returns (address);\n}\n\ninterface Oracle {\n    function getAssetPrice(address reserve) external view returns (uint);\n    function latestAnswer() external view returns (uint);\n}\n\n\n",
        "CodeNames": [
            "IConverter.sol",
            "MetaVault.sol",
            "Vault.sol",
            "YaxisVotePower.sol",
            "DForce.sol",
            "Aave.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "//solidity\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n",
                    "//solidity\n// @audit compares unnormalzied output to normalized output\nif (_balance < _amount) {\n    IController _controller = IController(manager.controllers(address(this)));\n    // @audit cannot directly subtract unnormalized\n    uint256 _toWithdraw = _amount.sub(_balance);\n    if (_controller.strategies()  0) {\n        _controller.withdraw(_output, _toWithdraw);\n    }\n    uint256 _after = IERC20(_output).balanceOf(address(this));\n    uint256 _diff = _after.sub(_balance);\n    if (_diff < _toWithdraw) {\n        _amount = _balance.add(_diff);\n    }\n}\n"
                ],
                "Type": "  Vault.withdraw  mixes normalized and standard amounts",
                "Description": "\nThe Vault.balance function uses the balanceOfThis function which scales (\"normalizes\") all balances to 18 decimals.\nsolidity\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n\nNote that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized, but it must be.\n\nThis leads to many issues through the contracts that use balance but don't treat these values as normalized values.\nFor example, in Vault.withdraw, the computed _amount value is normalized (in 18 decimals).\nBut the uint256 _balance = IERC20(_output).balanceOf(address(this)); value is not normalized but compared to the normalized _amount and even subtracted:\n\nsolidity\n// @audit compares unnormalzied output to normalized output\nif (_balance < _amount) {\n    IController _controller = IController(manager.controllers(address(this)));\n    // @audit cannot directly subtract unnormalized\n    uint256 _toWithdraw = _amount.sub(_balance);\n    if (_controller.strategies()  0) {\n        _controller.withdraw(_output, _toWithdraw);\n    }\n    uint256 _after = IERC20(_output).balanceOf(address(this));\n    uint256 _diff = _after.sub(_balance);\n    if (_diff < _toWithdraw) {\n        _amount = _balance.add(_diff);\n    }\n}\n\n\nImagine in withdraw, the output is USDC with 6 decimals, then the normalized _toWithdraw with 18 decimals (due to using _amount) will be a huge number and attempt to withdraw an inflated amount.\nAn attacker can steal tokens this way by withdrawing a tiny amount of shares and receive an inflated USDC or USDT amount (or any _output token with less than 18 decimals).\n\n",
                "Repair": "Whenever using anything involving vault.balanceOfThis() or vault.balance() one needs to be sure that any derived token amount needs to be denormalized again before using them.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/131#issuecomment-943502860):\n  An inconsistent usage of _normalizeDecimals will cause accounting issues and potentially paths for an exploit\n\nBobbyYaxis (yAxis) noted:\n Mitigated in PR 114: https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable max-states-count\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title Manager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract Manager is IManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;\n    uint256 public constant MAX_TOKENS = 256;\n\n    address public immutable override yaxis;\n\n    bool public override halted;\n\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override pendingStrategist;\n    address public override treasury;\n\n    // The following fees are all mutable.\n    // They are updated by governance (community vote).\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n\n    uint256 private setPendingStrategistTime;\n\n    // Governance must first allow the following properties before\n    // the strategist can make use of them\n    mapping(address => bool) public override allowedControllers;\n    mapping(address => bool) public override allowedConverters;\n    mapping(address => bool) public override allowedStrategies;\n    mapping(address => bool) public override allowedTokens;\n    mapping(address => bool) public override allowedVaults;\n\n    // vault => controller\n    mapping(address => address) public override controllers;\n    // vault => tokens[]\n    mapping(address => address[]) public override tokens;\n    // token => vault\n    mapping(address => address) public override vaults;\n\n    event AllowedController(\n        address indexed _controller,\n        bool _allowed\n    );\n    event AllowedConverter(\n        address indexed _converter,\n        bool _allowed\n    );\n    event AllowedStrategy(\n        address indexed _strategy,\n        bool _allowed\n    );\n    event AllowedToken(\n        address indexed _token,\n        bool _allowed\n    );\n    event AllowedVault(\n        address indexed _vault,\n        bool _allowed\n    );\n    event Halted();\n    event SetController(\n        address indexed _vault,\n        address indexed _controller\n    );\n    event SetGovernance(\n        address indexed _governance\n    );\n    event SetPendingStrategist(\n        address indexed _strategist\n    );\n    event SetStrategist(\n        address indexed _strategist\n    );\n    event TokenAdded(\n        address indexed _vault,\n        address indexed _token\n    );\n    event TokenRemoved(\n        address indexed _vault,\n        address indexed _token\n    );\n\n    /**\n     * @param _yaxis The address of the YAX token\n     */\n    constructor(\n        address _yaxis\n    )\n        public\n    {\n        require(_yaxis != address(0), \"!_yaxis\");\n        yaxis = _yaxis;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        treasury = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the permission for the given controller\n     * @param _controller The address of the controller\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedController(\n        address _controller,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IController(_controller).manager()) == address(this), \"!manager\");\n        allowedControllers[_controller] = _allowed;\n        emit AllowedController(_controller, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given converter\n     * @param _converter The address of the converter\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedConverter(\n        address _converter,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IConverter(_converter).manager()) == address(this), \"!manager\");\n        allowedConverters[_converter] = _allowed;\n        emit AllowedConverter(_converter, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given strategy\n     * @param _strategy The address of the strategy\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedStrategy(\n        address _strategy,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IStrategy(_strategy).manager()) == address(this), \"!manager\");\n        allowedStrategies[_strategy] = _allowed;\n        emit AllowedStrategy(_strategy, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given token\n     * @param _token The address of the token\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedToken(\n        address _token,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        allowedTokens[_token] = _allowed;\n        emit AllowedToken(_token, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given vault\n     * @param _vault The address of the vault\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedVault(\n        address _vault,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IVault(_vault).manager()) == address(this), \"!manager\");\n        allowedVaults[_vault] = _allowed;\n        emit AllowedVault(_vault, _allowed);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(\n        address _governance\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        governance = _governance;\n        emit SetGovernance(_governance);\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(\n        address _harvester\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IHarvester(_harvester).manager()) == address(this), \"!manager\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(\n        uint256 _insuranceFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(\n        address _insurancePool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(\n        uint256 _insurancePoolFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(\n        address _stakingPool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(\n        uint256 _stakingPoolShareFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the pending strategist and the timestamp\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(\n        address _strategist\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_strategist != address(0), \"!_strategist\");\n        pendingStrategist = _strategist;\n        // solhint-disable-next-line not-rely-on-time\n        setPendingStrategistTime = block.timestamp;\n        emit SetPendingStrategist(_strategist);\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(\n        address _treasury\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasury != address(0), \"!_treasury\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(\n        uint256 _treasuryFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasuryFee <= 2000, \"_treasuryFee over 20%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(\n        uint256 _withdrawalProtectionFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Updates the strategist to the pending strategist\n     * @dev This can only be called after the pending strategist timelock (7 days)\n     */\n    function acceptStrategist()\n        external\n        notHalted\n    {\n        require(msg.sender == pendingStrategist, \"!pendingStrategist\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), \"PENDING_STRATEGIST_TIMELOCK\");\n        delete pendingStrategist;\n        delete setPendingStrategistTime;\n        strategist = msg.sender;\n        emit SetStrategist(msg.sender);\n    }\n\n    /**\n     * @notice Adds a token to be able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function addToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(allowedTokens[_token], \"!allowedTokens\");\n        require(allowedVaults[_vault], \"!allowedVaults\");\n        require(tokens[_vault].length < MAX_TOKENS, \">tokens\");\n        require(vaults[_token] == address(0), \"!_token\");\n        vaults[_token] = _vault;\n        tokens[_vault].push(_token);\n        emit TokenAdded(_vault, _token);\n    }\n\n    /**\n     * @notice Allows the strategist to pull tokens out of this contract\n     * @dev This contract should never hold tokens\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function recoverToken(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Removes a token from being able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function removeToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        uint256 k = tokens[_vault].length;\n        uint256 index;\n        bool found;\n\n        for (uint i = 0; i < k; i++) {\n            if (tokens[_vault][i] == _token) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        // TODO: Verify added check\n        if (found) {\n            tokens[_vault][index] = tokens[_vault][k-1];\n            tokens[_vault].pop();\n            delete vaults[_token];\n            emit TokenRemoved(_vault, _token);\n        }\n    }\n\n    /**\n     * @notice Sets the vault address for a controller\n     * @param _vault The address of the vault\n     * @param _controller The address of the controller\n     */\n    function setController(\n        address _vault,\n        address _controller\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!_vault\");\n        require(allowedControllers[_controller], \"!_controller\");\n        controllers[_vault] = _controller;\n        emit SetController(_vault, _controller);\n    }\n\n    /**\n     * @notice Sets the protocol as halted, disallowing all deposits forever\n     * @dev Withdraws will still work, allowing users to exit the protocol\n     */\n    function setHalted()\n        external\n        notHalted\n        onlyStrategist\n    {\n        halted = true;\n        emit Halted();\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns an array of token addresses for a given vault\n     * @param _vault The address of the vault\n     */\n    function getTokens(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return tokens[_vault];\n    }\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAXIS token address,\n     *     Treasury address,\n     *     Treasury fee\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (\n            yaxis,\n            treasury,\n            treasuryFee\n        );\n    }\n\n    modifier notHalted() {\n        require(!halted, \"halted\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == strategist, \"!strategist\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n\n\n",
        "CodeNames": [
            "Manager.sol",
            "YaxisVotePower.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "python\nprint(vault.functions.balanceOfThis().call())\nprint(vault.functions.totalSupply().call())\nmanager.functions.removeToken(vault.address, dai.address).transact()\nprint(vault.functions.balanceOfThis().call())\nprint(vault.functions.totalSupply().call())\n"
                ],
                "Type": "  removeToken  would break the vault/protocol.",
                "Description": "\nThere's no safety check in Manager.sol's removeToken. Manager.sol#L454-L487(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L454-L487)\n\n1.  The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost.\n2.  Controller's balanceOf would no longer reflects the real value. Controller.sol#L488-L495(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L488-L495) While _vaultDetails[msg.sender].balance; remains the same, user can nolonger withdraw those amount.\n3.  Share price in the vault would decrease drastically. The share price is calculated as totalValue / totalSupply Vault.sol#L217(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217). While the totalSupply of the share remains the same, the total balance has drastically decreased.\n\nCalling removeToken way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.\n\nWe can see how the vault would be affected with below web3.py script.\n\npython\nprint(vault.functions.balanceOfThis().call())\nprint(vault.functions.totalSupply().call())\nmanager.functions.removeToken(vault.address, dai.address).transact()\nprint(vault.functions.balanceOfThis().call())\nprint(vault.functions.totalSupply().call())\n\n\noutput\n\n    100000000000000000000000\n    100000000000000000000000\n    0\n    100000000000000000000000\n\nHardhat\n\n",
                "Repair": "Remove tokens from a vault would be a really critical job. I recommend the team cover all possible cases and check all components' states (all vault/ strategy/ controller's state) in the test.\n\nSome steps that I try to come up with that is required to remove TokenA from a vault.\n\n1.  Withdraw all tokenA from all strategies (and handle it correctly in the controller).\n2.  Withdraw all tokenA from the vault.\n3.  Convert all tokenA that's collected in the previous step into tokenB.\n4.  Transfer tokenB to the vault and compensate the transaction fee/slippage cost to the vault.\n\ntransferAndCall (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-917676694):\n  Removing a token is understood as a critical (and possibly nuclear) operation within this architecture. We knew we would have to first withdraw all of the identified token from strategies, but what was missed was converting that token to another (without withdrawing, as that would be too much centralization).\n\n Proposed method of resolution:\n Withdraw all tokenA from all strategies (this sends it to the vault)\n Swap tokenA for tokenB in the vault (requires implementing a new function to be called by the strategist)\n Remove the token via the Manager function\n\ntransferAndCall (yAxis) confirmed and patched(https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-917695184):\n  Please review https://github.com/code-423n4/2021-09-yaxis/pull/5 to check resolution.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-943519688):\n  Removing a token can cause accounting errors, stuck funds and break some of the functionality\n\n Adding additional checks to prevent removing the token until all tokens have been migrated may be the simplest path forward\n\n Sponsor has mitigated by adding custom functionality, however it is up to them to enforce that the vault has no token left before removing it, adding a couple extra checks may provide a guarantee against admin privileged abuses\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IController.sol\";\nimport \"./IConverter.sol\";\nimport \"./IMetaVault.sol\";\n\n/**\n * @title MetaVault (yAxisMetaVault)\n * @notice The metavault is where users deposit and withdraw stablecoins\n * @dev This metavault will pay YAX incentive for depositors and stakers\n * It does not need minter key of YAX. Governance multisig will mint total\n * of 34000 YAX and send into the vault in the beginning\n */\ncontract MetaVault is ERC20, IMetaVault {\n    using Address for address;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv\n\n    IERC20 public token3CRV;\n    IERC20 public tokenYAX;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV\n    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\n\n    address public governance;\n    address public controller;\n    uint public insurance;\n    IVaultManager public vaultManager;\n    IConverter public converter;\n\n    bool public acceptContractDepositor = false; // dont accept contract at beginning\n\n    struct UserInfo {\n        uint amount;\n        uint yaxRewardDebt;\n        uint accEarned;\n    }\n\n    uint public lastRewardBlock;\n    uint public accYaxPerShare;\n\n    uint public yaxPerBlock;\n\n    mapping(address => UserInfo) public userInfo;\n\n    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;\n\n    uint public constant BLOCKS_PER_WEEK = 46500;\n\n    // Block number when each epoch ends.\n    uint[5] public epochEndBlocks;\n\n    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)\n    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];\n\n    /**\n     * @notice Emitted when a user deposits funds\n     */\n    event Deposit(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when a user withdraws funds\n     */\n    event Withdraw(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when YAX is paid to a user\n     */\n    event RewardPaid(address indexed user, uint reward);\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _tokenYAX The address of the YAX token\n     * @param _yaxPerBlock The amount of YAX rewarded per block\n     * @param _startBlock The starting block for rewards\n     */\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,\n        uint _yaxPerBlock, uint _startBlock) public ERC20(\"yAxis.io:MetaVault:3CRV\", \"MVLT\") {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        inputTokens[3] = _token3CRV;\n        token3CRV = _token3CRV;\n        tokenYAX = _tokenYAX;\n        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)\n        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)\n        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2\n        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4\n        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2\n        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4\n        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6\n        governance = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by a contract and we are not allowing.\n     */\n    modifier checkContract() {\n        if (!acceptContractDepositor) {\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance\n     * @dev Ignore insurance fund for balance calculations\n     */\n    function balance() public override view returns (uint) {\n        uint bal = token3CRV.balanceOf(address(this));\n        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));\n        return bal.sub(insurance);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for min\n     * @param _min The new min value\n     */\n    function setMin(uint _min) external {\n        require(msg.sender == governance, \"!governance\");\n        min = _min;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the governance address\n     * @param _governance The new governance value\n     */\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the controller address\n     * @param _controller The new controller value\n     */\n    function setController(address _controller) public override {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the converter address\n     * @param _converter The new converter value\n     * @dev Requires that the return address of token() from the converter is the\n     * same as token3CRV\n     */\n    function setConverter(IConverter _converter) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_converter.token() == address(token3CRV), \"!token3CRV\");\n        converter = _converter;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the vaultManager address\n     * @param _vaultManager The new vaultManager value\n     */\n    function setVaultManager(IVaultManager _vaultManager) public {\n        require(msg.sender == governance, \"!governance\");\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the earnLowerlimit\n     * @dev earnLowerlimit determines the minimum balance of this contract for earn\n     * to be called\n     * @param _earnLowerlimit The new earnLowerlimit value\n     */\n    function setEarnLowerlimit(uint _earnLowerlimit) public {\n        require(msg.sender == governance, \"!governance\");\n        earnLowerlimit = _earnLowerlimit;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(uint _totalDepositCap) public {\n        require(msg.sender == governance, \"!governance\");\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for acceptContractDepositor\n     * @dev acceptContractDepositor allows the metavault to accept deposits from\n     * smart contract addresses\n     * @param _acceptContractDepositor The new acceptContractDepositor value\n     */\n    function setAcceptContractDepositor(bool _acceptContractDepositor) public {\n        require(msg.sender == governance, \"!governance\");\n        acceptContractDepositor = _acceptContractDepositor;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for yaxPerBlock\n     * @dev Makes a call to updateReward()\n     * @param _yaxPerBlock The new yaxPerBlock value\n     */\n    function setYaxPerBlock(uint _yaxPerBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        updateReward();\n        yaxPerBlock = _yaxPerBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochEndBlocks at the given index\n     * @dev Throws if _index >= 5\n     * @dev Throws if _epochEndBlock > the current block.number\n     * @dev Throws if the stored block.number at the given index is > the current block.number\n     * @param _index The index to set of epochEndBlocks\n     * @param _epochEndBlock The new epochEndBlocks value at the index\n     */\n    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index < 5, \"_index out of range\");\n        require(_epochEndBlock > block.number, \"Too late to update\");\n        require(epochEndBlocks[_index] > block.number, \"Too late to update\");\n        epochEndBlocks[_index] = _epochEndBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index\n     * @dev Throws if _index < 1 or > 5\n     * @dev Throws if the stored block.number at the previous index is > the current block.number\n     * @param _index The index to set of epochRewardMultiplers\n     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index\n     */\n    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index > 0 && _index < 6, \"Index out of range\");\n        require(epochEndBlocks[_index - 1] > block.number, \"Too late to update\");\n        epochRewardMultiplers[_index] = _epochRewardMultipler;\n    }\n\n    /**\n     * @notice Return reward multiplier over the given _from to _to block.\n     * @param _from The from block\n     * @param _to The to block\n     */\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        // start at the end of the epochs\n        for (uint8 epochId = 5; epochId >= 1; --epochId) {\n            // if _to (the current block number if called within this contract) is after the previous epoch ends\n            if (_to >= epochEndBlocks[epochId - 1]) {\n                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier\n                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);\n                // get the multiplier amount for the remaining reward of the current epoch\n                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);\n                // if epoch is 1: return the remaining current epoch reward with the first epoch reward\n                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n                // for all epochs in between the first and current epoch\n                for (epochId = epochId - 1; epochId >= 1; --epochId) {\n                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch\n                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));\n                    // accumulate the multipler with the reward from the epoch\n                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));\n                }\n                // return the accumulated multiplier with the reward from the first epoch\n                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n            }\n        }\n        // return the reward amount between _from and _to in the first epoch\n        return _to.sub(_from).mul(epochRewardMultiplers[0]);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the treasuryWallet\n     * @param _treasuryWallet The new treasuryWallet value\n     */\n    function setTreasuryWallet(address _treasuryWallet) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryWallet = _treasuryWallet;\n    }\n\n    /**\n     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund\n     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare\n     */\n    function claimInsurance() external override {\n        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)\n        // otherwise send the fund to treasuryWallet\n        if (msg.sender != controller) {\n            // claim by governance for insurance\n            require(msg.sender == governance, \"!governance\");\n            token3CRV.safeTransfer(treasuryWallet, insurance);\n        }\n        insurance = 0;\n    }\n\n    /**\n     * @notice Get the address of the 3CRV token\n     */\n    function token() public override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Get the amount that the metavault allows to be borrowed\n     * @dev min and max are used to keep small withdrawals cheap\n     */\n    function available() public override view returns (uint) {\n        return token3CRV.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /**\n     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount\n     * @param _amount The amount being queried to withdraw\n     */\n    function withdrawFee(uint _amount) public override view returns (uint) {\n        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn() public override {\n        if (controller != address(0)) {\n            IController _contrl = IController(controller);\n            if (_contrl.investEnabled()) {\n                uint _bal = available();\n                token3CRV.safeTransfer(controller, _bal);\n                _contrl.earn(address(token3CRV), _bal);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV given for the amounts deposited\n     * @param amounts The stablecoin amounts being deposited\n     */\n    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {\n        return converter.calc_token_amount(amounts, true);\n    }\n\n    /**\n     * @notice Returns the amount given in the desired token for the given shares\n     * @param _shares The amount of shares to withdraw\n     * @param _output The desired token to withdraw\n     */\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\n        uint _withdrawFee = withdrawFee(_shares);\n        if (_withdrawFee > 0) {\n            _shares = _shares.mul(10000 - _withdrawFee).div(10000);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        if (_output == address(token3CRV)) {\n            return r;\n        }\n        return converter.calc_token_amount_withdraw(r, _output);\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens\n     * @param _input The stablecoin to convert to 3CRV\n     * @param _amount The amount of stablecoin to convert\n     */\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\n        return converter.convert_rate(_input, address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Deposit a single stablecoin to the metavault\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amount The amount of the stablecoin to deposit\n     * @param _input The address of the stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {\n        require(_amount > 0, \"!_amount\");\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        if (_input == address(token3CRV)) {\n            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {\n            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);\n            converter.convert(_input, address(token3CRV), _amount);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_amount >= _min_mint_amount, \"slippage\");\n        if (_amount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _amount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _amount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits multiple stablecoins simultaneously to the metavault\n     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amounts The amounts of each stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        bool hasStables = false;\n        for (uint8 i = 0; i < 4; i++) {\n            uint _inputAmount = _amounts[i];\n            if (_inputAmount > 0) {\n                if (i == 3) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);\n                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);\n                    hasStables = true;\n                }\n            }\n        }\n        if (hasStables) {\n            uint[3] memory _stablesAmounts;\n            _stablesAmounts[0] = _amounts[0];\n            _stablesAmounts[1] = _amounts[1];\n            _stablesAmounts[2] = _amounts[2];\n            converter.convert_stables(_stablesAmounts);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_totalDepositAmount >= _min_mint_amount, \"slippage\");\n        if (_totalDepositAmount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _totalDepositAmount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Stakes metavault shares\n     * @param _shares The amount of shares to stake\n     */\n    function stakeShares(uint _shares) external {\n        uint _before = balanceOf(address(this));\n        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);\n        uint _after = balanceOf(address(this));\n        _shares = _after.sub(_before);\n        // Additional check for deflationary tokens\n        _stakeShares(_shares);\n    }\n\n    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _insuranceFee = vaultManager.insuranceFee();\n            if (_insuranceFee > 0) {\n                uint _insurance = _amount.mul(_insuranceFee).div(10000);\n                _amount = _amount.sub(_insurance);\n                insurance = insurance.add(_insurance);\n            }\n        }\n\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        if (_shares > 0) {\n            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {\n                earn();\n            }\n            _mint(_mintTo, _shares);\n        }\n    }\n\n    function _stakeShares(uint _shares) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        updateReward();\n        _getReward();\n        user.amount = user.amount.add(_shares);\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Returns the pending YAXs for a given account\n     * @param _account The address to query\n     */\n    function pendingYax(address _account) public view returns (uint _pending) {\n        UserInfo storage user = userInfo[_account];\n        uint _accYaxPerShare = accYaxPerShare;\n        uint lpSupply = balanceOf(address(this));\n        if (block.number > lastRewardBlock && lpSupply != 0) {\n            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        }\n        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n    }\n\n    /**\n     * @notice Sets the lastRewardBlock and accYaxPerShare\n     */\n    function updateReward() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = balanceOf(address(this));\n        if (lpSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        lastRewardBlock = block.number;\n    }\n\n    function _getReward() internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n        if (_pendingYax > 0) {\n            user.accEarned = user.accEarned.add(_pendingYax);\n            safeYaxTransfer(msg.sender, _pendingYax);\n            emit RewardPaid(msg.sender, _pendingYax);\n        }\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired stablecoin to receive\n     */\n    function withdrawAll(address _output) external {\n        unstake(userInfo[msg.sender].amount);\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n     * @param reserve The address of the token to swap to 3CRV\n     * @param amount The amount to swap\n     */\n    function harvest(address reserve, uint amount) external override {\n        require(msg.sender == controller, \"!controller\");\n        require(reserve != address(token3CRV), \"token3CRV\");\n        IERC20(reserve).safeTransfer(controller, amount);\n    }\n\n    /**\n     * @notice Unstakes the given shares from the metavault\n     * @dev call unstake(0) to only receive the reward\n     * @param _amount The amount to unstake\n     */\n    function unstake(uint _amount) public {\n        updateReward();\n        _getReward();\n        UserInfo storage user = userInfo[msg.sender];\n        if (_amount > 0) {\n            require(user.amount >= _amount, \"stakedBal < _amount\");\n            user.amount = user.amount.sub(_amount);\n            IERC20(address(this)).transfer(msg.sender, _amount);\n        }\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output stablecoin\n     * @dev No rebalance implementation for lower fees and faster swaps\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the stablecoin to receive\n     */\n    function withdraw(uint _shares, address _output) public override {\n        uint _userBal = balanceOf(msg.sender);\n        if (_shares > _userBal) {\n            uint _need = _shares.sub(_userBal);\n            require(_need <= userInfo[msg.sender].amount, \"_userBal+staked < _shares\");\n            unstake(_need);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();\n            if (_withdrawalProtectionFee > 0) {\n                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);\n                r = r.sub(_withdrawalProtection);\n            }\n        }\n\n        // Check balance\n        uint b = token3CRV.balanceOf(address(this));\n        if (b < r) {\n            uint _toWithdraw = r.sub(b);\n            if (controller != address(0)) {\n                IController(controller).withdraw(address(token3CRV), _toWithdraw);\n            }\n            uint _after = token3CRV.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        if (_output == address(token3CRV)) {\n            token3CRV.safeTransfer(msg.sender, r);\n        } else {\n            require(converter.convert_rate(address(token3CRV), _output, r) > 0, \"rate=0\");\n            token3CRV.safeTransfer(address(converter), r);\n            uint _outputAmount = converter.convert(address(token3CRV), _output, r);\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function want() external override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Returns the rate of earnings of a single share\n     */\n    function getPricePerFullShare() external override view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @notice Transfers YAX from the metavault to a given address\n     * @dev Ensures the metavault has enough balance to transfer\n     * @param _to The address to transfer to\n     * @param _amount The amount to transfer\n     */\n    function safeYaxTransfer(address _to, uint _amount) internal {\n        uint _tokenBal = tokenYAX.balanceOf(address(this));\n        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);\n    }\n\n    /**\n     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV\n     * @param _token The address to convert\n     */\n    function earnExtra(address _token) public {\n        require(msg.sender == governance, \"!governance\");\n        require(address(_token) != address(token3CRV), \"3crv\");\n        require(address(_token) != address(this), \"mlvt\");\n        uint _amount = IERC20(_token).balanceOf(address(this));\n        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, \"rate=0\");\n        IERC20(_token).safeTransfer(address(converter), _amount);\n        converter.convert(_token, address(token3CRV), _amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Aave {\n    function borrow(address _reserve, uint _amount, uint _interestRateModel, uint16 _referralCode) external;\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;\n    function repay(address _reserve, uint _amount, address payable _onBehalfOf) external payable;\n    function getUserAccountData(address _user)\n        external\n        view\n        returns (\n            uint totalLiquidityETH,\n            uint totalCollateralETH,\n            uint totalBorrowsETH,\n            uint totalFeesETH,\n            uint availableBorrowsETH,\n            uint currentLiquidationThreshold,\n            uint ltv,\n            uint healthFactor\n        );\n    function getUserReserveData(address _reserve, address _user)\n        external\n        view\n        returns (\n            uint currentATokenBalance,\n            uint currentBorrowBalance,\n            uint principalBorrowBalance,\n            uint borrowRateMode,\n            uint borrowRate,\n            uint liquidityRate,\n            uint originationFee,\n            uint variableBorrowIndex,\n            uint lastUpdateTimestamp,\n            bool usageAsCollateralEnabled\n        );\n}\n\ninterface LendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n    function getLendingPoolCore() external view returns (address);\n    function getPriceOracle() external view returns (address);\n}\n\ninterface AaveToken {\n    function underlyingAssetAddress() external view returns (address);\n}\n\ninterface Oracle {\n    function getAssetPrice(address reserve) external view returns (uint);\n    function latestAnswer() external view returns (uint);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVoteProxy {\n    IVoteProxy public voteProxy;\n    address public governance;\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function name() external pure returns (string memory) {\n        return \"YAXIS Vote Power\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"YAX VP\";\n    }\n\n    function decimals() external view returns (uint8) {\n        return voteProxy.decimals();\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return voteProxy.totalSupply();\n    }\n\n    function balanceOf(address _voter) external view returns (uint256) {\n        return voteProxy.balanceOf(_voter);\n    }\n\n    function setVoteProxy(IVoteProxy _voteProxy) external {\n        require(msg.sender == governance, \"!governance\");\n        voteProxy = _voteProxy;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n\n\n/**\n * This function allows governance to take unsupported tokens out of the contract.\n * This is in an effort to make someone whole, should they seriously mess up.\n * There is no guarantee governance will vote to return these.\n * It also allows for removal of airdropped tokens.\n */\n    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\n        require(msg.sender == governance, \"!governance\");\n        _token.transfer(to, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IVault {\n    function token() external view returns (address);\n    function priceE18() external view returns (uint);\n    function deposit(uint) external;\n    function withdraw(uint) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILiquidityGaugeV2.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title VaultHelper\n * @notice The VaultHelper acts as a single contract that users may set\n * token approvals on for any token of any vault.\n * @dev This contract has no state and could be deployed by anyone if\n * they didn't trust the original deployer.\n */\ncontract VaultHelper {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Deposits the given token into the specified vault\n     * @dev Users must approve the vault helper to spend their token\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     * @param _amount The amount of tokens to deposit\n     */\n    function depositVault(\n        address _vault,\n        address _token,\n        uint256 _amount\n    )\n        external\n    {\n        require(_amount > 0, \"!_amount\");\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(_token).safeApprove(_vault, 0);\n        IERC20(_token).safeApprove(_vault, _amount);\n        uint256 _shares = IVault(_vault).deposit(_token, _amount);\n        address _gauge = IVault(_vault).gauge();\n        if (_gauge != address(0)) {\n            IERC20(_vault).safeApprove(_gauge, 0);\n            IERC20(_vault).safeApprove(_gauge, _shares);\n            ILiquidityGaugeV2(_gauge).deposit(_shares);\n            IERC20(_gauge).safeTransfer(msg.sender, _shares);\n        } else {\n            IERC20(_vault).safeTransfer(msg.sender, _shares);\n        }\n    }\n\n    /**\n     * @notice Deposits multiple tokens simultaneously to the specified vault\n     * @dev Users must approve the vault helper to spend their tokens\n     * @param _vault The address of the vault\n     * @param _tokens The addresses of each token being deposited\n     * @param _amounts The amounts of each token being deposited\n     */\n    function depositMultipleVault(\n        address _vault,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    )\n        external\n    {\n        require(_tokens.length == _amounts.length, \"!length\");\n\n        for (uint8 i = 0; i < _amounts.length; i++) {\n            require(_amounts[i] > 0, \"!_amounts\");\n            IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);\n            IERC20(_tokens[i]).safeApprove(_vault, 0);\n            IERC20(_tokens[i]).safeApprove(_vault, _amounts[i]);\n        }\n        uint256 _shares = IVault(_vault).depositMultiple(_tokens, _amounts);\n        address _gauge = IVault(_vault).gauge();\n        if (_gauge != address(0)) {\n            IERC20(_vault).safeApprove(_gauge, 0);\n            IERC20(_vault).safeApprove(_gauge, _shares);\n            ILiquidityGaugeV2(_gauge).deposit(_shares);\n            IERC20(_gauge).safeTransfer(msg.sender, _shares);\n        } else {\n            IERC20(_vault).safeTransfer(msg.sender, _shares);\n        }\n    }\n\n    function withdrawVault(\n        address _vault,\n        address _toToken,\n        uint256 _amount\n    )\n        external\n    {\n        address _gauge = IVault(_vault).gauge();\n        if (_gauge != address(0)) {\n            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);\n            ILiquidityGaugeV2(_gauge).withdraw(_amount);\n            IVault(_vault).withdraw(IERC20(_vault).balanceOf(address(this)), _toToken);\n            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));\n        } else {\n            IERC20(_vault).safeTransferFrom(msg.sender, address(this), _amount);\n            IVault(_vault).withdraw(_amount, _toToken);\n            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "MetaVault.sol",
            "YaxisVotePower.sol",
            "Aave.sol",
            "YaxisVoteProxy.sol",
            "FlamIncome.sol",
            "VaultHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "transferFrom()",
                    "transfer()",
                    "this",
                    "depositVault()",
                    "_amount",
                    "depositMultipleVault",
                    "IVault(_vault).deposit(_token, _amount);",
                    "IERC"
                ],
                "Type": "  VaultHelper  deposits don't work with fee-on transfer tokens",
                "Description": "\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom().\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).\n\nThe VaultHelper's depositVault() and depositMultipleVault functions transfer _amount to this contract using IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);.\nThis could have a fee, and less than _amount ends up in the contract.\nThe next actual vault deposit using IVault(_vault).deposit(_token, _amount); will then try to transfer more than the this contract actually has and will revert the transaction.\n\n",
                "Repair": "One possible mitigation is to measure the asset change right before and after the asset-transferring routines.\nThis is already done correctly in the Vault.deposit function.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/127#issuecomment-941740332):\n  Agree with finding, checking actual balance of contract would mitigate vulnerability\n Additionally ensuring the protocol never uses rebasing or tokens with feeOnTransfer can be enough to mitigate\n\n The vulnerability can brick the protocol\n However it can be sidestepped by simply not using feeOnTransfer tokens\n Downgrading to medium\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IController.sol\";\nimport \"./IConverter.sol\";\nimport \"./IMetaVault.sol\";\n\n/**\n * @title MetaVault (yAxisMetaVault)\n * @notice The metavault is where users deposit and withdraw stablecoins\n * @dev This metavault will pay YAX incentive for depositors and stakers\n * It does not need minter key of YAX. Governance multisig will mint total\n * of 34000 YAX and send into the vault in the beginning\n */\ncontract MetaVault is ERC20, IMetaVault {\n    using Address for address;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv\n\n    IERC20 public token3CRV;\n    IERC20 public tokenYAX;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV\n    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\n\n    address public governance;\n    address public controller;\n    uint public insurance;\n    IVaultManager public vaultManager;\n    IConverter public converter;\n\n    bool public acceptContractDepositor = false; // dont accept contract at beginning\n\n    struct UserInfo {\n        uint amount;\n        uint yaxRewardDebt;\n        uint accEarned;\n    }\n\n    uint public lastRewardBlock;\n    uint public accYaxPerShare;\n\n    uint public yaxPerBlock;\n\n    mapping(address => UserInfo) public userInfo;\n\n    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;\n\n    uint public constant BLOCKS_PER_WEEK = 46500;\n\n    // Block number when each epoch ends.\n    uint[5] public epochEndBlocks;\n\n    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)\n    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];\n\n    /**\n     * @notice Emitted when a user deposits funds\n     */\n    event Deposit(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when a user withdraws funds\n     */\n    event Withdraw(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when YAX is paid to a user\n     */\n    event RewardPaid(address indexed user, uint reward);\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _tokenYAX The address of the YAX token\n     * @param _yaxPerBlock The amount of YAX rewarded per block\n     * @param _startBlock The starting block for rewards\n     */\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,\n        uint _yaxPerBlock, uint _startBlock) public ERC20(\"yAxis.io:MetaVault:3CRV\", \"MVLT\") {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        inputTokens[3] = _token3CRV;\n        token3CRV = _token3CRV;\n        tokenYAX = _tokenYAX;\n        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)\n        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)\n        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2\n        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4\n        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2\n        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4\n        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6\n        governance = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by a contract and we are not allowing.\n     */\n    modifier checkContract() {\n        if (!acceptContractDepositor) {\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance\n     * @dev Ignore insurance fund for balance calculations\n     */\n    function balance() public override view returns (uint) {\n        uint bal = token3CRV.balanceOf(address(this));\n        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));\n        return bal.sub(insurance);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for min\n     * @param _min The new min value\n     */\n    function setMin(uint _min) external {\n        require(msg.sender == governance, \"!governance\");\n        min = _min;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the governance address\n     * @param _governance The new governance value\n     */\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the controller address\n     * @param _controller The new controller value\n     */\n    function setController(address _controller) public override {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the converter address\n     * @param _converter The new converter value\n     * @dev Requires that the return address of token() from the converter is the\n     * same as token3CRV\n     */\n    function setConverter(IConverter _converter) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_converter.token() == address(token3CRV), \"!token3CRV\");\n        converter = _converter;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the vaultManager address\n     * @param _vaultManager The new vaultManager value\n     */\n    function setVaultManager(IVaultManager _vaultManager) public {\n        require(msg.sender == governance, \"!governance\");\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the earnLowerlimit\n     * @dev earnLowerlimit determines the minimum balance of this contract for earn\n     * to be called\n     * @param _earnLowerlimit The new earnLowerlimit value\n     */\n    function setEarnLowerlimit(uint _earnLowerlimit) public {\n        require(msg.sender == governance, \"!governance\");\n        earnLowerlimit = _earnLowerlimit;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(uint _totalDepositCap) public {\n        require(msg.sender == governance, \"!governance\");\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for acceptContractDepositor\n     * @dev acceptContractDepositor allows the metavault to accept deposits from\n     * smart contract addresses\n     * @param _acceptContractDepositor The new acceptContractDepositor value\n     */\n    function setAcceptContractDepositor(bool _acceptContractDepositor) public {\n        require(msg.sender == governance, \"!governance\");\n        acceptContractDepositor = _acceptContractDepositor;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for yaxPerBlock\n     * @dev Makes a call to updateReward()\n     * @param _yaxPerBlock The new yaxPerBlock value\n     */\n    function setYaxPerBlock(uint _yaxPerBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        updateReward();\n        yaxPerBlock = _yaxPerBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochEndBlocks at the given index\n     * @dev Throws if _index >= 5\n     * @dev Throws if _epochEndBlock > the current block.number\n     * @dev Throws if the stored block.number at the given index is > the current block.number\n     * @param _index The index to set of epochEndBlocks\n     * @param _epochEndBlock The new epochEndBlocks value at the index\n     */\n    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index < 5, \"_index out of range\");\n        require(_epochEndBlock > block.number, \"Too late to update\");\n        require(epochEndBlocks[_index] > block.number, \"Too late to update\");\n        epochEndBlocks[_index] = _epochEndBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index\n     * @dev Throws if _index < 1 or > 5\n     * @dev Throws if the stored block.number at the previous index is > the current block.number\n     * @param _index The index to set of epochRewardMultiplers\n     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index\n     */\n    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index > 0 && _index < 6, \"Index out of range\");\n        require(epochEndBlocks[_index - 1] > block.number, \"Too late to update\");\n        epochRewardMultiplers[_index] = _epochRewardMultipler;\n    }\n\n    /**\n     * @notice Return reward multiplier over the given _from to _to block.\n     * @param _from The from block\n     * @param _to The to block\n     */\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        // start at the end of the epochs\n        for (uint8 epochId = 5; epochId >= 1; --epochId) {\n            // if _to (the current block number if called within this contract) is after the previous epoch ends\n            if (_to >= epochEndBlocks[epochId - 1]) {\n                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier\n                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);\n                // get the multiplier amount for the remaining reward of the current epoch\n                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);\n                // if epoch is 1: return the remaining current epoch reward with the first epoch reward\n                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n                // for all epochs in between the first and current epoch\n                for (epochId = epochId - 1; epochId >= 1; --epochId) {\n                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch\n                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));\n                    // accumulate the multipler with the reward from the epoch\n                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));\n                }\n                // return the accumulated multiplier with the reward from the first epoch\n                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n            }\n        }\n        // return the reward amount between _from and _to in the first epoch\n        return _to.sub(_from).mul(epochRewardMultiplers[0]);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the treasuryWallet\n     * @param _treasuryWallet The new treasuryWallet value\n     */\n    function setTreasuryWallet(address _treasuryWallet) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryWallet = _treasuryWallet;\n    }\n\n    /**\n     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund\n     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare\n     */\n    function claimInsurance() external override {\n        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)\n        // otherwise send the fund to treasuryWallet\n        if (msg.sender != controller) {\n            // claim by governance for insurance\n            require(msg.sender == governance, \"!governance\");\n            token3CRV.safeTransfer(treasuryWallet, insurance);\n        }\n        insurance = 0;\n    }\n\n    /**\n     * @notice Get the address of the 3CRV token\n     */\n    function token() public override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Get the amount that the metavault allows to be borrowed\n     * @dev min and max are used to keep small withdrawals cheap\n     */\n    function available() public override view returns (uint) {\n        return token3CRV.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /**\n     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount\n     * @param _amount The amount being queried to withdraw\n     */\n    function withdrawFee(uint _amount) public override view returns (uint) {\n        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn() public override {\n        if (controller != address(0)) {\n            IController _contrl = IController(controller);\n            if (_contrl.investEnabled()) {\n                uint _bal = available();\n                token3CRV.safeTransfer(controller, _bal);\n                _contrl.earn(address(token3CRV), _bal);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV given for the amounts deposited\n     * @param amounts The stablecoin amounts being deposited\n     */\n    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {\n        return converter.calc_token_amount(amounts, true);\n    }\n\n    /**\n     * @notice Returns the amount given in the desired token for the given shares\n     * @param _shares The amount of shares to withdraw\n     * @param _output The desired token to withdraw\n     */\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\n        uint _withdrawFee = withdrawFee(_shares);\n        if (_withdrawFee > 0) {\n            _shares = _shares.mul(10000 - _withdrawFee).div(10000);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        if (_output == address(token3CRV)) {\n            return r;\n        }\n        return converter.calc_token_amount_withdraw(r, _output);\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens\n     * @param _input The stablecoin to convert to 3CRV\n     * @param _amount The amount of stablecoin to convert\n     */\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\n        return converter.convert_rate(_input, address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Deposit a single stablecoin to the metavault\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amount The amount of the stablecoin to deposit\n     * @param _input The address of the stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {\n        require(_amount > 0, \"!_amount\");\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        if (_input == address(token3CRV)) {\n            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {\n            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);\n            converter.convert(_input, address(token3CRV), _amount);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_amount >= _min_mint_amount, \"slippage\");\n        if (_amount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _amount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _amount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits multiple stablecoins simultaneously to the metavault\n     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amounts The amounts of each stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        bool hasStables = false;\n        for (uint8 i = 0; i < 4; i++) {\n            uint _inputAmount = _amounts[i];\n            if (_inputAmount > 0) {\n                if (i == 3) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);\n                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);\n                    hasStables = true;\n                }\n            }\n        }\n        if (hasStables) {\n            uint[3] memory _stablesAmounts;\n            _stablesAmounts[0] = _amounts[0];\n            _stablesAmounts[1] = _amounts[1];\n            _stablesAmounts[2] = _amounts[2];\n            converter.convert_stables(_stablesAmounts);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_totalDepositAmount >= _min_mint_amount, \"slippage\");\n        if (_totalDepositAmount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _totalDepositAmount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Stakes metavault shares\n     * @param _shares The amount of shares to stake\n     */\n    function stakeShares(uint _shares) external {\n        uint _before = balanceOf(address(this));\n        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);\n        uint _after = balanceOf(address(this));\n        _shares = _after.sub(_before);\n        // Additional check for deflationary tokens\n        _stakeShares(_shares);\n    }\n\n    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _insuranceFee = vaultManager.insuranceFee();\n            if (_insuranceFee > 0) {\n                uint _insurance = _amount.mul(_insuranceFee).div(10000);\n                _amount = _amount.sub(_insurance);\n                insurance = insurance.add(_insurance);\n            }\n        }\n\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        if (_shares > 0) {\n            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {\n                earn();\n            }\n            _mint(_mintTo, _shares);\n        }\n    }\n\n    function _stakeShares(uint _shares) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        updateReward();\n        _getReward();\n        user.amount = user.amount.add(_shares);\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Returns the pending YAXs for a given account\n     * @param _account The address to query\n     */\n    function pendingYax(address _account) public view returns (uint _pending) {\n        UserInfo storage user = userInfo[_account];\n        uint _accYaxPerShare = accYaxPerShare;\n        uint lpSupply = balanceOf(address(this));\n        if (block.number > lastRewardBlock && lpSupply != 0) {\n            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        }\n        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n    }\n\n    /**\n     * @notice Sets the lastRewardBlock and accYaxPerShare\n     */\n    function updateReward() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = balanceOf(address(this));\n        if (lpSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        lastRewardBlock = block.number;\n    }\n\n    function _getReward() internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n        if (_pendingYax > 0) {\n            user.accEarned = user.accEarned.add(_pendingYax);\n            safeYaxTransfer(msg.sender, _pendingYax);\n            emit RewardPaid(msg.sender, _pendingYax);\n        }\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired stablecoin to receive\n     */\n    function withdrawAll(address _output) external {\n        unstake(userInfo[msg.sender].amount);\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n     * @param reserve The address of the token to swap to 3CRV\n     * @param amount The amount to swap\n     */\n    function harvest(address reserve, uint amount) external override {\n        require(msg.sender == controller, \"!controller\");\n        require(reserve != address(token3CRV), \"token3CRV\");\n        IERC20(reserve).safeTransfer(controller, amount);\n    }\n\n    /**\n     * @notice Unstakes the given shares from the metavault\n     * @dev call unstake(0) to only receive the reward\n     * @param _amount The amount to unstake\n     */\n    function unstake(uint _amount) public {\n        updateReward();\n        _getReward();\n        UserInfo storage user = userInfo[msg.sender];\n        if (_amount > 0) {\n            require(user.amount >= _amount, \"stakedBal < _amount\");\n            user.amount = user.amount.sub(_amount);\n            IERC20(address(this)).transfer(msg.sender, _amount);\n        }\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output stablecoin\n     * @dev No rebalance implementation for lower fees and faster swaps\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the stablecoin to receive\n     */\n    function withdraw(uint _shares, address _output) public override {\n        uint _userBal = balanceOf(msg.sender);\n        if (_shares > _userBal) {\n            uint _need = _shares.sub(_userBal);\n            require(_need <= userInfo[msg.sender].amount, \"_userBal+staked < _shares\");\n            unstake(_need);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();\n            if (_withdrawalProtectionFee > 0) {\n                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);\n                r = r.sub(_withdrawalProtection);\n            }\n        }\n\n        // Check balance\n        uint b = token3CRV.balanceOf(address(this));\n        if (b < r) {\n            uint _toWithdraw = r.sub(b);\n            if (controller != address(0)) {\n                IController(controller).withdraw(address(token3CRV), _toWithdraw);\n            }\n            uint _after = token3CRV.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        if (_output == address(token3CRV)) {\n            token3CRV.safeTransfer(msg.sender, r);\n        } else {\n            require(converter.convert_rate(address(token3CRV), _output, r) > 0, \"rate=0\");\n            token3CRV.safeTransfer(address(converter), r);\n            uint _outputAmount = converter.convert(address(token3CRV), _output, r);\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function want() external override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Returns the rate of earnings of a single share\n     */\n    function getPricePerFullShare() external override view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @notice Transfers YAX from the metavault to a given address\n     * @dev Ensures the metavault has enough balance to transfer\n     * @param _to The address to transfer to\n     * @param _amount The amount to transfer\n     */\n    function safeYaxTransfer(address _to, uint _amount) internal {\n        uint _tokenBal = tokenYAX.balanceOf(address(this));\n        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);\n    }\n\n    /**\n     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV\n     * @param _token The address to convert\n     */\n    function earnExtra(address _token) public {\n        require(msg.sender == governance, \"!governance\");\n        require(address(_token) != address(token3CRV), \"3crv\");\n        require(address(_token) != address(this), \"mlvt\");\n        uint _amount = IERC20(_token).balanceOf(address(this));\n        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, \"rate=0\");\n        IERC20(_token).safeTransfer(address(converter), _amount);\n        converter.convert(_token, address(token3CRV), _amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n\n\n",
        "CodeNames": [
            "MetaVault.sol",
            "YaxisVotePower.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "recoverToken",
                    "ERC",
                    "false"
                ],
                "Type": " ERC20 return values not checked",
                "Description": "\nThe ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success. This parameter needs to be checked for success.\nSome tokens do not revert if the transfer failed but return false instead.\n\nThe Manager.recoverToken function does not check the return value of this function.\n\nTokens that don't actually perform the transfer and return false are still counted as a correct transfer.\nFurthermore, tokens that do not correctly implement the EIP20 standard, like USDT which does not return a success boolean, will revert.\n\n",
                "Repair": "We recommend using OpenZeppelin\u2019s SafeERC20(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.\n\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/114#issuecomment-942781687):\n  Agree with finding, using a non reverting token can potentially cause issues to the protocol accounting\n\n Sponsor can check each token on a case by case basis, or simply use OpenZeppelin's safeERC20\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IController.sol\";\nimport \"./IConverter.sol\";\nimport \"./IMetaVault.sol\";\n\n/**\n * @title MetaVault (yAxisMetaVault)\n * @notice The metavault is where users deposit and withdraw stablecoins\n * @dev This metavault will pay YAX incentive for depositors and stakers\n * It does not need minter key of YAX. Governance multisig will mint total\n * of 34000 YAX and send into the vault in the beginning\n */\ncontract MetaVault is ERC20, IMetaVault {\n    using Address for address;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv\n\n    IERC20 public token3CRV;\n    IERC20 public tokenYAX;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV\n    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\n\n    address public governance;\n    address public controller;\n    uint public insurance;\n    IVaultManager public vaultManager;\n    IConverter public converter;\n\n    bool public acceptContractDepositor = false; // dont accept contract at beginning\n\n    struct UserInfo {\n        uint amount;\n        uint yaxRewardDebt;\n        uint accEarned;\n    }\n\n    uint public lastRewardBlock;\n    uint public accYaxPerShare;\n\n    uint public yaxPerBlock;\n\n    mapping(address => UserInfo) public userInfo;\n\n    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;\n\n    uint public constant BLOCKS_PER_WEEK = 46500;\n\n    // Block number when each epoch ends.\n    uint[5] public epochEndBlocks;\n\n    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)\n    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];\n\n    /**\n     * @notice Emitted when a user deposits funds\n     */\n    event Deposit(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when a user withdraws funds\n     */\n    event Withdraw(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when YAX is paid to a user\n     */\n    event RewardPaid(address indexed user, uint reward);\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _tokenYAX The address of the YAX token\n     * @param _yaxPerBlock The amount of YAX rewarded per block\n     * @param _startBlock The starting block for rewards\n     */\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,\n        uint _yaxPerBlock, uint _startBlock) public ERC20(\"yAxis.io:MetaVault:3CRV\", \"MVLT\") {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        inputTokens[3] = _token3CRV;\n        token3CRV = _token3CRV;\n        tokenYAX = _tokenYAX;\n        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)\n        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)\n        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2\n        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4\n        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2\n        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4\n        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6\n        governance = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by a contract and we are not allowing.\n     */\n    modifier checkContract() {\n        if (!acceptContractDepositor) {\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance\n     * @dev Ignore insurance fund for balance calculations\n     */\n    function balance() public override view returns (uint) {\n        uint bal = token3CRV.balanceOf(address(this));\n        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));\n        return bal.sub(insurance);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for min\n     * @param _min The new min value\n     */\n    function setMin(uint _min) external {\n        require(msg.sender == governance, \"!governance\");\n        min = _min;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the governance address\n     * @param _governance The new governance value\n     */\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the controller address\n     * @param _controller The new controller value\n     */\n    function setController(address _controller) public override {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the converter address\n     * @param _converter The new converter value\n     * @dev Requires that the return address of token() from the converter is the\n     * same as token3CRV\n     */\n    function setConverter(IConverter _converter) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_converter.token() == address(token3CRV), \"!token3CRV\");\n        converter = _converter;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the vaultManager address\n     * @param _vaultManager The new vaultManager value\n     */\n    function setVaultManager(IVaultManager _vaultManager) public {\n        require(msg.sender == governance, \"!governance\");\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the earnLowerlimit\n     * @dev earnLowerlimit determines the minimum balance of this contract for earn\n     * to be called\n     * @param _earnLowerlimit The new earnLowerlimit value\n     */\n    function setEarnLowerlimit(uint _earnLowerlimit) public {\n        require(msg.sender == governance, \"!governance\");\n        earnLowerlimit = _earnLowerlimit;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(uint _totalDepositCap) public {\n        require(msg.sender == governance, \"!governance\");\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for acceptContractDepositor\n     * @dev acceptContractDepositor allows the metavault to accept deposits from\n     * smart contract addresses\n     * @param _acceptContractDepositor The new acceptContractDepositor value\n     */\n    function setAcceptContractDepositor(bool _acceptContractDepositor) public {\n        require(msg.sender == governance, \"!governance\");\n        acceptContractDepositor = _acceptContractDepositor;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for yaxPerBlock\n     * @dev Makes a call to updateReward()\n     * @param _yaxPerBlock The new yaxPerBlock value\n     */\n    function setYaxPerBlock(uint _yaxPerBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        updateReward();\n        yaxPerBlock = _yaxPerBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochEndBlocks at the given index\n     * @dev Throws if _index >= 5\n     * @dev Throws if _epochEndBlock > the current block.number\n     * @dev Throws if the stored block.number at the given index is > the current block.number\n     * @param _index The index to set of epochEndBlocks\n     * @param _epochEndBlock The new epochEndBlocks value at the index\n     */\n    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index < 5, \"_index out of range\");\n        require(_epochEndBlock > block.number, \"Too late to update\");\n        require(epochEndBlocks[_index] > block.number, \"Too late to update\");\n        epochEndBlocks[_index] = _epochEndBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index\n     * @dev Throws if _index < 1 or > 5\n     * @dev Throws if the stored block.number at the previous index is > the current block.number\n     * @param _index The index to set of epochRewardMultiplers\n     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index\n     */\n    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index > 0 && _index < 6, \"Index out of range\");\n        require(epochEndBlocks[_index - 1] > block.number, \"Too late to update\");\n        epochRewardMultiplers[_index] = _epochRewardMultipler;\n    }\n\n    /**\n     * @notice Return reward multiplier over the given _from to _to block.\n     * @param _from The from block\n     * @param _to The to block\n     */\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        // start at the end of the epochs\n        for (uint8 epochId = 5; epochId >= 1; --epochId) {\n            // if _to (the current block number if called within this contract) is after the previous epoch ends\n            if (_to >= epochEndBlocks[epochId - 1]) {\n                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier\n                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);\n                // get the multiplier amount for the remaining reward of the current epoch\n                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);\n                // if epoch is 1: return the remaining current epoch reward with the first epoch reward\n                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n                // for all epochs in between the first and current epoch\n                for (epochId = epochId - 1; epochId >= 1; --epochId) {\n                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch\n                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));\n                    // accumulate the multipler with the reward from the epoch\n                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));\n                }\n                // return the accumulated multiplier with the reward from the first epoch\n                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n            }\n        }\n        // return the reward amount between _from and _to in the first epoch\n        return _to.sub(_from).mul(epochRewardMultiplers[0]);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the treasuryWallet\n     * @param _treasuryWallet The new treasuryWallet value\n     */\n    function setTreasuryWallet(address _treasuryWallet) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryWallet = _treasuryWallet;\n    }\n\n    /**\n     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund\n     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare\n     */\n    function claimInsurance() external override {\n        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)\n        // otherwise send the fund to treasuryWallet\n        if (msg.sender != controller) {\n            // claim by governance for insurance\n            require(msg.sender == governance, \"!governance\");\n            token3CRV.safeTransfer(treasuryWallet, insurance);\n        }\n        insurance = 0;\n    }\n\n    /**\n     * @notice Get the address of the 3CRV token\n     */\n    function token() public override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Get the amount that the metavault allows to be borrowed\n     * @dev min and max are used to keep small withdrawals cheap\n     */\n    function available() public override view returns (uint) {\n        return token3CRV.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /**\n     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount\n     * @param _amount The amount being queried to withdraw\n     */\n    function withdrawFee(uint _amount) public override view returns (uint) {\n        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn() public override {\n        if (controller != address(0)) {\n            IController _contrl = IController(controller);\n            if (_contrl.investEnabled()) {\n                uint _bal = available();\n                token3CRV.safeTransfer(controller, _bal);\n                _contrl.earn(address(token3CRV), _bal);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV given for the amounts deposited\n     * @param amounts The stablecoin amounts being deposited\n     */\n    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {\n        return converter.calc_token_amount(amounts, true);\n    }\n\n    /**\n     * @notice Returns the amount given in the desired token for the given shares\n     * @param _shares The amount of shares to withdraw\n     * @param _output The desired token to withdraw\n     */\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\n        uint _withdrawFee = withdrawFee(_shares);\n        if (_withdrawFee > 0) {\n            _shares = _shares.mul(10000 - _withdrawFee).div(10000);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        if (_output == address(token3CRV)) {\n            return r;\n        }\n        return converter.calc_token_amount_withdraw(r, _output);\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens\n     * @param _input The stablecoin to convert to 3CRV\n     * @param _amount The amount of stablecoin to convert\n     */\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\n        return converter.convert_rate(_input, address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Deposit a single stablecoin to the metavault\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amount The amount of the stablecoin to deposit\n     * @param _input The address of the stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {\n        require(_amount > 0, \"!_amount\");\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        if (_input == address(token3CRV)) {\n            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {\n            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);\n            converter.convert(_input, address(token3CRV), _amount);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_amount >= _min_mint_amount, \"slippage\");\n        if (_amount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _amount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _amount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits multiple stablecoins simultaneously to the metavault\n     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amounts The amounts of each stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        bool hasStables = false;\n        for (uint8 i = 0; i < 4; i++) {\n            uint _inputAmount = _amounts[i];\n            if (_inputAmount > 0) {\n                if (i == 3) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);\n                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);\n                    hasStables = true;\n                }\n            }\n        }\n        if (hasStables) {\n            uint[3] memory _stablesAmounts;\n            _stablesAmounts[0] = _amounts[0];\n            _stablesAmounts[1] = _amounts[1];\n            _stablesAmounts[2] = _amounts[2];\n            converter.convert_stables(_stablesAmounts);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_totalDepositAmount >= _min_mint_amount, \"slippage\");\n        if (_totalDepositAmount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _totalDepositAmount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Stakes metavault shares\n     * @param _shares The amount of shares to stake\n     */\n    function stakeShares(uint _shares) external {\n        uint _before = balanceOf(address(this));\n        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);\n        uint _after = balanceOf(address(this));\n        _shares = _after.sub(_before);\n        // Additional check for deflationary tokens\n        _stakeShares(_shares);\n    }\n\n    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _insuranceFee = vaultManager.insuranceFee();\n            if (_insuranceFee > 0) {\n                uint _insurance = _amount.mul(_insuranceFee).div(10000);\n                _amount = _amount.sub(_insurance);\n                insurance = insurance.add(_insurance);\n            }\n        }\n\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        if (_shares > 0) {\n            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {\n                earn();\n            }\n            _mint(_mintTo, _shares);\n        }\n    }\n\n    function _stakeShares(uint _shares) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        updateReward();\n        _getReward();\n        user.amount = user.amount.add(_shares);\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Returns the pending YAXs for a given account\n     * @param _account The address to query\n     */\n    function pendingYax(address _account) public view returns (uint _pending) {\n        UserInfo storage user = userInfo[_account];\n        uint _accYaxPerShare = accYaxPerShare;\n        uint lpSupply = balanceOf(address(this));\n        if (block.number > lastRewardBlock && lpSupply != 0) {\n            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        }\n        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n    }\n\n    /**\n     * @notice Sets the lastRewardBlock and accYaxPerShare\n     */\n    function updateReward() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = balanceOf(address(this));\n        if (lpSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        lastRewardBlock = block.number;\n    }\n\n    function _getReward() internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n        if (_pendingYax > 0) {\n            user.accEarned = user.accEarned.add(_pendingYax);\n            safeYaxTransfer(msg.sender, _pendingYax);\n            emit RewardPaid(msg.sender, _pendingYax);\n        }\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired stablecoin to receive\n     */\n    function withdrawAll(address _output) external {\n        unstake(userInfo[msg.sender].amount);\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n     * @param reserve The address of the token to swap to 3CRV\n     * @param amount The amount to swap\n     */\n    function harvest(address reserve, uint amount) external override {\n        require(msg.sender == controller, \"!controller\");\n        require(reserve != address(token3CRV), \"token3CRV\");\n        IERC20(reserve).safeTransfer(controller, amount);\n    }\n\n    /**\n     * @notice Unstakes the given shares from the metavault\n     * @dev call unstake(0) to only receive the reward\n     * @param _amount The amount to unstake\n     */\n    function unstake(uint _amount) public {\n        updateReward();\n        _getReward();\n        UserInfo storage user = userInfo[msg.sender];\n        if (_amount > 0) {\n            require(user.amount >= _amount, \"stakedBal < _amount\");\n            user.amount = user.amount.sub(_amount);\n            IERC20(address(this)).transfer(msg.sender, _amount);\n        }\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output stablecoin\n     * @dev No rebalance implementation for lower fees and faster swaps\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the stablecoin to receive\n     */\n    function withdraw(uint _shares, address _output) public override {\n        uint _userBal = balanceOf(msg.sender);\n        if (_shares > _userBal) {\n            uint _need = _shares.sub(_userBal);\n            require(_need <= userInfo[msg.sender].amount, \"_userBal+staked < _shares\");\n            unstake(_need);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();\n            if (_withdrawalProtectionFee > 0) {\n                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);\n                r = r.sub(_withdrawalProtection);\n            }\n        }\n\n        // Check balance\n        uint b = token3CRV.balanceOf(address(this));\n        if (b < r) {\n            uint _toWithdraw = r.sub(b);\n            if (controller != address(0)) {\n                IController(controller).withdraw(address(token3CRV), _toWithdraw);\n            }\n            uint _after = token3CRV.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        if (_output == address(token3CRV)) {\n            token3CRV.safeTransfer(msg.sender, r);\n        } else {\n            require(converter.convert_rate(address(token3CRV), _output, r) > 0, \"rate=0\");\n            token3CRV.safeTransfer(address(converter), r);\n            uint _outputAmount = converter.convert(address(token3CRV), _output, r);\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function want() external override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Returns the rate of earnings of a single share\n     */\n    function getPricePerFullShare() external override view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @notice Transfers YAX from the metavault to a given address\n     * @dev Ensures the metavault has enough balance to transfer\n     * @param _to The address to transfer to\n     * @param _amount The amount to transfer\n     */\n    function safeYaxTransfer(address _to, uint _amount) internal {\n        uint _tokenBal = tokenYAX.balanceOf(address(this));\n        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);\n    }\n\n    /**\n     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV\n     * @param _token The address to convert\n     */\n    function earnExtra(address _token) public {\n        require(msg.sender == governance, \"!governance\");\n        require(address(_token) != address(token3CRV), \"3crv\");\n        require(address(_token) != address(this), \"mlvt\");\n        uint _amount = IERC20(_token).balanceOf(address(this));\n        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, \"rate=0\");\n        IERC20(_token).safeTransfer(address(converter), _amount);\n        converter.convert(_token, address(token3CRV), _amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Aave {\n    function borrow(address _reserve, uint _amount, uint _interestRateModel, uint16 _referralCode) external;\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;\n    function repay(address _reserve, uint _amount, address payable _onBehalfOf) external payable;\n    function getUserAccountData(address _user)\n        external\n        view\n        returns (\n            uint totalLiquidityETH,\n            uint totalCollateralETH,\n            uint totalBorrowsETH,\n            uint totalFeesETH,\n            uint availableBorrowsETH,\n            uint currentLiquidationThreshold,\n            uint ltv,\n            uint healthFactor\n        );\n    function getUserReserveData(address _reserve, address _user)\n        external\n        view\n        returns (\n            uint currentATokenBalance,\n            uint currentBorrowBalance,\n            uint principalBorrowBalance,\n            uint borrowRateMode,\n            uint borrowRate,\n            uint liquidityRate,\n            uint originationFee,\n            uint variableBorrowIndex,\n            uint lastUpdateTimestamp,\n            bool usageAsCollateralEnabled\n        );\n}\n\ninterface LendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n    function getLendingPoolCore() external view returns (address);\n    function getPriceOracle() external view returns (address);\n}\n\ninterface AaveToken {\n    function underlyingAssetAddress() external view returns (address);\n}\n\ninterface Oracle {\n    function getAssetPrice(address reserve) external view returns (uint);\n    function latestAnswer() external view returns (uint);\n}\n\n\n",
        "CodeNames": [
            "MetaVault.sol",
            "Aave.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nif (_diff < _toWithdraw) {\n    // @audit burns too many shares for a below fair-share amount\n    _amount = _balance.add(_diff);\n}\n"
                ],
                "Type": "  Vault.withdraw  sometimes burns too many shares",
                "Description": "\nThe Vault.withdraw function attempts to withdraw funds from the controller if there are not enough in the vault already.\nIn the case the controller could not withdraw enough, i.e., where _diff < _toWithdraw, the user will receive less output tokens than their fair share would entitle them to (the initial _amount).\n\nsolidity\nif (_diff < _toWithdraw) {\n    // @audit burns too many shares for a below fair-share amount\n    _amount = _balance.add(_diff);\n}\n\n\nThe withdrawer receives fewer output tokens than they were entitled to.\n\n",
                "Repair": "In the mentioned case, the _shares should be recomputed to match the actual withdrawn _amount tokens:\n\nsolidity\nif (_diff < _toWithdraw) {\n    _amount = _balance.add(_diff);\n    // recompute _shares to burn based on the lower payout\n    // should be something like this, better to cache balance() once at the start and use that cached value\n    _shares = (totalSupply().mul(_amount)).div(_balance);\n}\n\n\nOnly these shares should then be burned.\n\nuN2RVw5q commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/121#issuecomment-932776915):\n  Duplicate of https://github.com/code-423n4/2021-09-yaxis-findings/issues/41 and https://github.com/code-423n4/2021-09-yaxis-findings/issues/136\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/121#issuecomment-942790860):\n  Agree with the finding\n\n Anytime the strategy incurs a loss during withdrawal, the person that triggered that withdrawal will get less for their shares than what they may expect.\n\n Since amount of shares is computed by checking balance in strategy, and controller enacts this withdrawal, adding a check in the controller to compare expected withdrawal vs actual shares received would be a clean way to mitigate\n\nBobbyYaxis (yAxis) noted:\n We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Gauge.sol\";\nimport \"../../interfaces/Balancer.sol\";\n\nimport \"../interfaces/ExtendedIERC20.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract NativeStrategyCurve3Crv is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    Mintr public immutable crvMintr;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    Gauge public immutable gauge; // 3Crv Gauge\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        Gauge _gauge,\n        Mintr _crvMintr,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _manager,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _manager, _want, _weth, _router)\n    {\n        crv = _crv;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        stableSwap3Pool = _stableSwap3Pool;\n        gauge = _gauge;\n        crvMintr = _crvMintr;\n        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit()\n        internal\n        override\n    {\n        uint256 _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit [want] to Gauge\n            gauge.deposit(_wantBal);\n        }\n    }\n\n    function _claimReward()\n        internal\n    {\n        crvMintr.mint(address(gauge));\n    }\n\n    function _addLiquidity()\n        internal\n    {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium()\n        public\n        view\n        returns (address, uint256)\n    {\n        uint daiBalance = stableSwap3Pool.balances(0);\n        // USDC - Supports a change up to the 18 decimal standard\n        uint usdcBalance = stableSwap3Pool.balances(1).mul(10**18).div(10**(ExtendedIERC20(usdc).decimals()));\n        uint usdtBalance = stableSwap3Pool.balances(2).mul(10**12);\n\n        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {\n            return (dai, 0);\n        }\n\n        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {\n            return (usdc, 1);\n        }\n\n        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        override\n    {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity();\n\n            _deposit();\n        }\n    }\n\n    function _withdrawAll()\n        internal\n        override\n    {\n        uint256 _bal = gauge.balanceOf(address(this));\n        _withdraw(_bal);\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        override\n    {\n        gauge.withdraw(_amount);\n    }\n\n    function balanceOfPool()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return gauge.balanceOf(address(this));\n    }\n}\n\n\n",
        "CodeNames": [
            "NativeStrategyCurve3Crv.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "_addLiquidity"
                ],
                "Type": " Adding asymmetric liquidity in  _addLiquidity  results in fewer LP tokens minted than what should be wanted",
                "Description": "\nBecause the call in _addLiquidity forwards the entire balances of the 3 stablecoins without checking the ratio.\nbetween the 3, less liquidity is minted than what should be wanted. Furthermore, an attacker can abuse this arbitrage the forwarded balances if the discrepancy is large enough.\n\nFor example, suppose the contract holds $10K each of usdc, usdt, dai. An attacker deposits $100K worth of DAI\nand get credited with $100K worth of shares in the protocol. Liquidity is added, but since the ratio is now skewed\n11:1:1, a lot less liquidity is minted by the stableswap algorithm to the protocol. The attacker can now arbitrage the curve pool for an additional profit.\n\nThere doesn't even need to be an attacker, just an unbalanced amount of user deposits will also lead to lower liquidity minted.\n\nNativeStrategyCurve3Crv.sol L73(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L73)\n\n",
                "Repair": "Adding liquidity should probably be managed more manually, it should be added in equal proportion to the curve pool balances, not the contract balances.\n\ngpersoon commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/158#issuecomment-930142403):\n  Seems the same as #2\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/158#issuecomment-943488554):\n  Agree on the finding\n This finding claims that adding liquidity on Curve while treating each token to have the same weight is a surefire way to get less tokens than expected\n\n While #2 addresses a similar (IMO higher risk) vulnerability\n\n This finding shows how the vault can have a loss of value through how it deals with token accounting\n\n To me this is a unique finding, however am downgrading it to medium\n\nBobbyYaxis (yAxis) noted:\n We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IVault {\n    function token() external view returns (address);\n    function priceE18() external view returns (uint);\n    function deposit(uint) external;\n    function withdraw(uint) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n\n\n",
        "CodeNames": [
            "FlamIncome.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "withdrawAll"
                ],
                "Type": "  # Controller is vulnerable to sandwich attack",
                "Description": "\nThe protocol frequently interacts with crv a lot. However, the contract doesn't specify the minimum return amount.\nGiven the fact that there's a lot of MEV searchers, calling swap without specifying the minimum return amount really puts user funds in danger.\n\nFor example, controller's withdrawAll is designed to transfer all the funds in a strategy.[Controller.sol#L360(https://github.com/code-423n4/2021-09-yaxis/blob/a78d392156b90f8ac27de6d57cb0de2697d480d5/contracts/v3/controllers/Controller.sol#L360) The arbitrage space is enough for a searcher to sandwich this trade.\n\nManager.sol#L442-L452(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L442-L452)\n\nController.sol#L273(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L273)\n\n",
                "Repair": "Always calculates an estimate return when calling to crv.\n\ntransferAndCall (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/7)\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/7#issuecomment-942827851):\n  Agree with finding, agree with severity as this allows to \"leak value\"\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IGenericVault {\n    function token() external view returns (address);\n    function getPricePerFullShare() external view returns (uint256);\n    function deposit(uint256) external;\n    function withdraw(uint256) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./VaultToken.sol\";\n\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ExtendedIERC20.sol\";\n\n/**\n * @title Vault\n * @notice The vault is where users deposit and withdraw\n * like-kind assets that have been added by governance.\n */\ncontract Vault is VaultToken, IVault {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX = 10000;\n\n    IManager public immutable override manager;\n\n    // Strategist-updated variables\n    address public override gauge;\n    uint256 public min;\n    uint256 public totalDepositCap;\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event Earn(address indexed token, uint256 amount);\n\n    /**\n     * @param _name The name of the vault token for depositors\n     * @param _symbol The symbol of the vault token for depositors\n     * @param _manager The address of the vault manager contract\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _manager\n    )\n        public\n        VaultToken(_name, _symbol)\n    {\n        manager = IManager(_manager);\n        min = 9500;\n        totalDepositCap = 10000000 ether;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the value of this vault's gauge\n     * @dev Allow to be unset with the zero address\n     * @param _gauge The address of the gauge\n     */\n    function setGauge(\n        address _gauge\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        gauge = _gauge;\n    }\n\n    /**\n     * @notice Sets the value for min\n     * @dev min is the minimum percent of funds to keep small withdrawals cheap\n     * @param _min The new min value\n     */\n    function setMin(\n        uint256 _min\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(_min <= MAX, \"!_min\");\n        min = _min;\n    }\n\n    /**\n     * @notice Sets the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(\n        uint256 _totalDepositCap\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Swaps tokens held within the vault\n     * @param _token0 The token address to swap out\n     * @param _token1 The token address to to\n     * @param _expectedAmount The expected amount of _token1 to receive\n     */\n    function swap(\n        address _token0,\n        address _token1,\n        uint256 _expectedAmount\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n        returns (uint256 _balance)\n    {\n        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));\n        _balance = IERC20(_token0).balanceOf(address(this));\n        IERC20(_token0).safeTransfer(address(_converter), _balance);\n        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn(\n        address _token,\n        address _strategy\n    )\n        external\n        override\n        checkToken(_token)\n        notHalted\n        onlyHarvester\n    {\n        require(manager.allowedStrategies(_strategy), \"!_strategy\");\n        IController _controller = IController(manager.controllers(address(this)));\n        if (_controller.investEnabled()) {\n            uint256 _balance = available(_token);\n            IERC20(_token).safeTransfer(address(_controller), _balance);\n            _controller.earn(_strategy, _token, _balance);\n            emit Earn(_token, _balance);\n        }\n    }\n\n    /**\n     * USER-FACING FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits the given token into the vault\n     * @param _token The address of the token\n     * @param _amount The amount of tokens to deposit\n     */\n     function deposit(\n        address _token,\n        uint256 _amount\n     )\n        public\n        override\n        checkToken(_token)\n        notHalted\n        returns (uint256 _shares)\n    {\n        require(_amount > 0, \"!_amount\");\n\n        uint256 _balance = balance();\n\n        uint256 _before = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);\n\n        if (_amount > 0) {\n            _amount = _normalizeDecimals(_token, _amount);\n\n            if (totalSupply() > 0) {\n                _amount = (_amount.mul(totalSupply())).div(_balance);\n            }\n\n            _shares = _amount;\n        }\n\n        if (_shares > 0) {\n            _mint(msg.sender, _shares);\n            require(totalSupply() <= totalDepositCap, \">totalDepositCap\");\n            emit Deposit(msg.sender, _shares);\n        }\n    }\n\n    /**\n     * @notice Deposits multiple tokens simultaneously to the vault\n     * @dev Users must approve the vault to spend their stablecoin\n     * @param _tokens The addresses of each token being deposited\n     * @param _amounts The amounts of each token being deposited\n     */\n    function depositMultiple(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    )\n        external\n        override\n        returns (uint256 _shares)\n    {\n        require(_tokens.length == _amounts.length, \"!length\");\n\n        for (uint8 i; i < _amounts.length; i++) {\n            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));\n        }\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output token\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the token to receive\n     */\n    function withdraw(\n        uint256 _shares,\n        address _output\n    )\n        public\n        override\n        checkToken(_output)\n    {\n        uint256 _amount = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();\n        if (_withdrawalProtectionFee > 0) {\n            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);\n            _amount = _amount.sub(_withdrawalProtection);\n        }\n\n        uint256 _balance = IERC20(_output).balanceOf(address(this));\n        if (_balance < _amount) {\n            IController _controller = IController(manager.controllers(address(this)));\n            uint256 _toWithdraw = _amount.sub(_balance);\n            if (_controller.strategies() > 0) {\n                _controller.withdraw(_output, _toWithdraw);\n            }\n            uint256 _after = IERC20(_output).balanceOf(address(this));\n            uint256 _diff = _after.sub(_balance);\n            if (_diff < _toWithdraw) {\n                _amount = _after;\n            }\n        }\n\n        IERC20(_output).safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired token to receive\n     */\n    function withdrawAll(\n        address _output\n    )\n        external\n        override\n    {\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * VIEWS\n     */\n\n    /**\n     * @notice Returns the amount of tokens available to be sent to strategies\n     * @dev Custom logic in here for how much the vault allows to be borrowed\n     * @dev Sets minimum required on-hand to keep small withdrawals cheap\n     * @param _token The address of the token\n     */\n    function available(\n        address _token\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);\n    }\n\n    /**\n     * @notice Returns the total balance of the vault, including strategies\n     */\n    function balance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n    }\n\n    /**\n     * @notice Returns the balance of allowed tokens present on the vault only\n     */\n    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }\n\n    /**\n     * @notice Returns the rate of vault shares\n     */\n    function getPricePerFullShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() > 0) {\n            return balance().mul(1e18).div(totalSupply());\n        } else {\n            return balance();\n        }\n    }\n\n    /**\n     * @notice Returns an array of the tokens for this vault\n     */\n    function getTokens()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return manager.getTokens(address(this));\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing the given amount\n     * @param _amount The amount to withdraw\n     */\n    function withdrawFee(\n        uint256 _amount\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);\n    }\n\n    function _normalizeDecimals(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());\n        if (_decimals < 18) {\n            _amount = _amount.mul(10**(18-_decimals));\n        }\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier checkToken(address _token) {\n        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), \"!_token\");\n        _;\n    }\n\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IVault {\n    function token() external view returns (address);\n    function priceE18() external view returns (uint);\n    function deposit(uint) external;\n    function withdraw(uint) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n\n\n",
        "CodeNames": [
            "GenericVault.sol",
            "Vault.sol",
            "FlamIncome.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "withdrawAll()",
                    "_controller.strategies() = 0",
                    "getPricePerFullShare()"
                ],
                "Type": " Vault: Withdrawals can be frontrun to cause users to burn tokens without receiving funds in return",
                "Description": "\nLet us assume either of the following cases:\n\n1.  The vault / protocol is to be winded down or migrated, where either the protocol is halted and withdrawAll() has been called on all active strategies to transfer funds into the vault.\n2.  There are 0 strategies. Specifically, _controller.strategies() = 0\n\nAttempted withdrawals can be frontrun such that users will receive less, or even no funds in exchange for burning vault tokens. This is primarily enabled by the feature of having deposits in multiple stablecoins.\n\n1.  Assume getPricePerFullShare() of 1e18 (1 vault token = 1 stablecoin). Alice has 1000 vault tokens, while Mallory has 2000 vault tokens, with the vault holdings being 1000 USDC, 1000 USDT and 1000 DAI.\n2.  Alice attempts to withdraw her deposit in a desired stablecoin (Eg. USDC).\n3.  Mallory frontruns Alice's transaction and exchanges 1000 vault tokens for the targeted stablecoin (USDC). The vault now holds 1000 USDT and 1000 DAI.\n4.  Alice receives nothing in return for her deposit because the vault no longer has any USDC. getPricePerFullShare() now returns 2e18.\n5.  Mallory splits his withdrawals evenly, by burning 500 vault tokens for 1000 USDT and the other 500 vault tokens for 1000 DAI.\n\nHence, Mallory is able to steal Alice's funds by frontrunning her withdrawal transaction.\n\n",
                "Repair": "The withdrawal amount could be checked against getPricePerFullShare(), perhaps with reasonable slippage.\n\nGainsGoblin (yAxis) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-931750516):\n  Duplicate of #28\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-943385674):\n  Disagree with duplicate label as this shows a Value Extraction, front-running exploit.\n Medium severity as it's a way to \"leak value\"\n\n This can be mitigated through addressing the \"Vault value all tokens equally\" issue\n\nGainsGoblin (yAxis) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-943707545):\n  The issue is exactly the same as #28. Both issues present the exact same front-running example.\n\nBobbyYaxis (yAxis) noted:\n We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable max-states-count\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title Manager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract Manager is IManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;\n    uint256 public constant MAX_TOKENS = 256;\n\n    address public immutable override yaxis;\n\n    bool public override halted;\n\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override pendingStrategist;\n    address public override treasury;\n\n    // The following fees are all mutable.\n    // They are updated by governance (community vote).\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n\n    uint256 private setPendingStrategistTime;\n\n    // Governance must first allow the following properties before\n    // the strategist can make use of them\n    mapping(address => bool) public override allowedControllers;\n    mapping(address => bool) public override allowedConverters;\n    mapping(address => bool) public override allowedStrategies;\n    mapping(address => bool) public override allowedTokens;\n    mapping(address => bool) public override allowedVaults;\n\n    // vault => controller\n    mapping(address => address) public override controllers;\n    // vault => tokens[]\n    mapping(address => address[]) public override tokens;\n    // token => vault\n    mapping(address => address) public override vaults;\n\n    event AllowedController(\n        address indexed _controller,\n        bool _allowed\n    );\n    event AllowedConverter(\n        address indexed _converter,\n        bool _allowed\n    );\n    event AllowedStrategy(\n        address indexed _strategy,\n        bool _allowed\n    );\n    event AllowedToken(\n        address indexed _token,\n        bool _allowed\n    );\n    event AllowedVault(\n        address indexed _vault,\n        bool _allowed\n    );\n    event Halted();\n    event SetController(\n        address indexed _vault,\n        address indexed _controller\n    );\n    event SetGovernance(\n        address indexed _governance\n    );\n    event SetPendingStrategist(\n        address indexed _strategist\n    );\n    event SetStrategist(\n        address indexed _strategist\n    );\n    event TokenAdded(\n        address indexed _vault,\n        address indexed _token\n    );\n    event TokenRemoved(\n        address indexed _vault,\n        address indexed _token\n    );\n\n    /**\n     * @param _yaxis The address of the YAX token\n     */\n    constructor(\n        address _yaxis\n    )\n        public\n    {\n        require(_yaxis != address(0), \"!_yaxis\");\n        yaxis = _yaxis;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        treasury = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the permission for the given controller\n     * @param _controller The address of the controller\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedController(\n        address _controller,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IController(_controller).manager()) == address(this), \"!manager\");\n        allowedControllers[_controller] = _allowed;\n        emit AllowedController(_controller, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given converter\n     * @param _converter The address of the converter\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedConverter(\n        address _converter,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IConverter(_converter).manager()) == address(this), \"!manager\");\n        allowedConverters[_converter] = _allowed;\n        emit AllowedConverter(_converter, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given strategy\n     * @param _strategy The address of the strategy\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedStrategy(\n        address _strategy,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IStrategy(_strategy).manager()) == address(this), \"!manager\");\n        allowedStrategies[_strategy] = _allowed;\n        emit AllowedStrategy(_strategy, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given token\n     * @param _token The address of the token\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedToken(\n        address _token,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        allowedTokens[_token] = _allowed;\n        emit AllowedToken(_token, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given vault\n     * @param _vault The address of the vault\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedVault(\n        address _vault,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IVault(_vault).manager()) == address(this), \"!manager\");\n        allowedVaults[_vault] = _allowed;\n        emit AllowedVault(_vault, _allowed);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(\n        address _governance\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        governance = _governance;\n        emit SetGovernance(_governance);\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(\n        address _harvester\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IHarvester(_harvester).manager()) == address(this), \"!manager\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(\n        uint256 _insuranceFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(\n        address _insurancePool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(\n        uint256 _insurancePoolFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(\n        address _stakingPool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(\n        uint256 _stakingPoolShareFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the pending strategist and the timestamp\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(\n        address _strategist\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_strategist != address(0), \"!_strategist\");\n        pendingStrategist = _strategist;\n        // solhint-disable-next-line not-rely-on-time\n        setPendingStrategistTime = block.timestamp;\n        emit SetPendingStrategist(_strategist);\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(\n        address _treasury\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasury != address(0), \"!_treasury\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(\n        uint256 _treasuryFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasuryFee <= 2000, \"_treasuryFee over 20%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(\n        uint256 _withdrawalProtectionFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Updates the strategist to the pending strategist\n     * @dev This can only be called after the pending strategist timelock (7 days)\n     */\n    function acceptStrategist()\n        external\n        notHalted\n    {\n        require(msg.sender == pendingStrategist, \"!pendingStrategist\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), \"PENDING_STRATEGIST_TIMELOCK\");\n        delete pendingStrategist;\n        delete setPendingStrategistTime;\n        strategist = msg.sender;\n        emit SetStrategist(msg.sender);\n    }\n\n    /**\n     * @notice Adds a token to be able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function addToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(allowedTokens[_token], \"!allowedTokens\");\n        require(allowedVaults[_vault], \"!allowedVaults\");\n        require(tokens[_vault].length < MAX_TOKENS, \">tokens\");\n        require(vaults[_token] == address(0), \"!_token\");\n        vaults[_token] = _vault;\n        tokens[_vault].push(_token);\n        emit TokenAdded(_vault, _token);\n    }\n\n    /**\n     * @notice Allows the strategist to pull tokens out of this contract\n     * @dev This contract should never hold tokens\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function recoverToken(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Removes a token from being able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function removeToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        uint256 k = tokens[_vault].length;\n        uint256 index;\n        bool found;\n\n        for (uint i = 0; i < k; i++) {\n            if (tokens[_vault][i] == _token) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        // TODO: Verify added check\n        if (found) {\n            tokens[_vault][index] = tokens[_vault][k-1];\n            tokens[_vault].pop();\n            delete vaults[_token];\n            emit TokenRemoved(_vault, _token);\n        }\n    }\n\n    /**\n     * @notice Sets the vault address for a controller\n     * @param _vault The address of the vault\n     * @param _controller The address of the controller\n     */\n    function setController(\n        address _vault,\n        address _controller\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!_vault\");\n        require(allowedControllers[_controller], \"!_controller\");\n        controllers[_vault] = _controller;\n        emit SetController(_vault, _controller);\n    }\n\n    /**\n     * @notice Sets the protocol as halted, disallowing all deposits forever\n     * @dev Withdraws will still work, allowing users to exit the protocol\n     */\n    function setHalted()\n        external\n        notHalted\n        onlyStrategist\n    {\n        halted = true;\n        emit Halted();\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns an array of token addresses for a given vault\n     * @param _vault The address of the vault\n     */\n    function getTokens(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return tokens[_vault];\n    }\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAXIS token address,\n     *     Treasury address,\n     *     Treasury fee\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (\n            yaxis,\n            treasury,\n            treasuryFee\n        );\n    }\n\n    modifier notHalted() {\n        require(!halted, \"halted\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == strategist, \"!strategist\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVoteProxy {\n    IVoteProxy public voteProxy;\n    address public governance;\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function name() external pure returns (string memory) {\n        return \"YAXIS Vote Power\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"YAX VP\";\n    }\n\n    function decimals() external view returns (uint8) {\n        return voteProxy.decimals();\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return voteProxy.totalSupply();\n    }\n\n    function balanceOf(address _voter) external view returns (uint256) {\n        return voteProxy.balanceOf(_voter);\n    }\n\n    function setVoteProxy(IVoteProxy _voteProxy) external {\n        require(msg.sender == governance, \"!governance\");\n        voteProxy = _voteProxy;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n\n\n/**\n * This function allows governance to take unsupported tokens out of the contract.\n * This is in an effort to make someone whole, should they seriously mess up.\n * There is no guarantee governance will vote to return these.\n * It also allows for removal of airdropped tokens.\n */\n    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\n        require(msg.sender == governance, \"!governance\");\n        _token.transfer(to, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IHarvester.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IManager.sol\";\n\n/**\n * @title Controller\n * @notice This controller allows multiple strategies to be used\n * for a single vault supporting multiple tokens.\n */\ncontract Controller is IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IManager public immutable override manager;\n\n    bool public globalInvestEnabled;\n    uint256 public maxStrategies;\n\n    struct VaultDetail {\n        address converter;\n        uint256 balance;\n        address[] strategies;\n        mapping(address => uint256) balances;\n        mapping(address => uint256) index;\n        mapping(address => uint256) caps;\n    }\n\n    // vault => Vault\n    mapping(address => VaultDetail) internal _vaultDetails;\n    // strategy => vault\n    mapping(address => address) internal _vaultStrategies;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(address indexed strategy);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy);\n\n    /**\n     * @notice Logged when strategies are reordered for a vault\n     */\n    event StrategiesReordered(\n        address indexed vault,\n        address indexed strategy1,\n        address indexed strategy2\n    );\n\n    /**\n     * @param _manager The address of the manager\n     */\n    constructor(\n        address _manager\n    )\n        public\n    {\n        manager = IManager(_manager);\n        globalInvestEnabled = true;\n        maxStrategies = 10;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The cap of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultDetails[_vault].converter != address(0), \"!converter\");\n        // checking if strategy is already added\n        require(_vaultStrategies[_strategy] == address(0), \"Strategy is already added\"); \n        // get the index of the newly added strategy\n        uint256 index = _vaultDetails[_vault].strategies.length;\n        // ensure we haven't added too many strategies already\n        require(index < maxStrategies, \"!maxStrategies\");\n        // push the strategy to the array of strategies\n        _vaultDetails[_vault].strategies.push(_strategy);\n        // set the cap\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        // set the index\n        _vaultDetails[_vault].index[_strategy] = index;\n        // store the mapping of strategy to the vault\n        _vaultStrategies[_strategy] = _vault;\n        if (_timeout > 0) {\n            // add it to the harvester\n            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);\n        }\n        emit StrategyAdded(_vault, _strategy, _cap);\n    }\n\n    /**\n     * @notice Withdraws token from a strategy to the treasury address as returned by the manager\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     */\n    function inCaseStrategyGetStuck(\n        address _strategy,\n        address _token\n    )\n        external\n        onlyStrategist\n    {\n        IStrategy(_strategy).withdraw(_token);\n        IERC20(_token).safeTransfer(\n            manager.treasury(),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Withdraws token from the controller to the treasury\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function inCaseTokensGetStuck(\n        address _token,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        IERC20(_token).safeTransfer(manager.treasury(), _amount);\n    }\n\n    /**\n     * @notice Removes a strategy for a given token\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the index of the strategy to remove\n        uint256 index = vaultDetail.index[_strategy];\n        // get the index of the last strategy\n        uint256 tail = vaultDetail.strategies.length.sub(1);\n        // get the address of the last strategy\n        address replace = vaultDetail.strategies[tail];\n        // replace the removed strategy with the tail\n        vaultDetail.strategies[index] = replace;\n        // set the new index for the replaced strategy\n        vaultDetail.index[replace] = index;\n        // remove the duplicate replaced strategy\n        vaultDetail.strategies.pop();\n        // remove the strategy's index\n        delete vaultDetail.index[_strategy];\n        // remove the strategy's cap\n        delete vaultDetail.caps[_strategy];\n        // remove the strategy's balance\n        delete vaultDetail.balances[_strategy];\n        // remove the mapping of strategy to the vault\n        delete _vaultStrategies[_strategy];\n        // pull funds from the removed strategy to the vault\n        IStrategy(_strategy).withdrawAll();\n        // remove the strategy from the harvester\n        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);\n        emit StrategyRemoved(_vault, _strategy);\n    }\n\n    /**\n     * @notice Reorders two strategies for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy1 The address of the first strategy\n     * @param _strategy2 The address of the second strategy\n     */\n    function reorderStrategies(\n        address _vault,\n        address _strategy1,\n        address _strategy2\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultStrategies[_strategy1] == _vault, \"!_strategy1\");\n        require(_vaultStrategies[_strategy2] == _vault, \"!_strategy2\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the indexes of the strategies\n        uint256 index1 = vaultDetail.index[_strategy1];\n        uint256 index2 = vaultDetail.index[_strategy2];\n        // set the new addresses at their indexes\n        vaultDetail.strategies[index1] = _strategy2;\n        vaultDetail.strategies[index2] = _strategy1;\n        // update indexes\n        vaultDetail.index[_strategy1] = index2;\n        vaultDetail.index[_strategy2] = index1;\n        emit StrategiesReordered(_vault, _strategy1, _strategy2);\n    }\n\n    /**\n     * @notice Sets/updates the cap of a strategy for a vault\n     * @dev If the balance of the strategy is greater than the new cap (except if\n     * the cap is 0), then withdraw the difference from the strategy to the vault.\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The new cap of the strategy\n     */\n    function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets/updates the converter for a given vault\n     * @param _vault The address of the vault\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _vault,\n        address _converter\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedConverters(_converter), \"!allowedConverters\");\n        _vaultDetails[_vault].converter = _converter;\n    }\n\n    /**\n     * @notice Sets/updates the global invest enabled flag\n     * @param _investEnabled The new bool of the invest enabled flag\n     */\n    function setInvestEnabled(\n        bool _investEnabled\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        globalInvestEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Sets/updates the maximum number of strategies for a vault\n     * @param _maxStrategies The new value of the maximum strategies\n     */\n    function setMaxStrategies(\n        uint256 _maxStrategies\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        maxStrategies = _maxStrategies;\n    }\n\n    function skim(\n        address _strategy\n    )\n        external\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).skim();\n        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Withdraws all funds from a strategy\n     * @param _strategy The address of the strategy\n     * @param _convert The token address to convert to\n     */\n    function withdrawAll(\n        address _strategy,\n        address _convert\n    )\n        external\n        override\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).withdrawAll();\n        uint256 _amount = IERC20(_want).balanceOf(address(this));\n        address _vault = _vaultStrategies[_strategy];\n        updateBalance(_vault, _strategy);\n        if (_convert != address(0)) {\n            IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n            IERC20(_want).safeTransfer(address(_converter), _amount);\n            _amount = _converter.convert(_want, _convert, _amount, 1);\n            IERC20(_convert).safeTransfer(_vault, _amount);\n        } else {\n            IERC20(_want).safeTransfer(_vault, _amount);\n        }\n        uint256 _balance = _vaultDetails[_vault].balance;\n        if (_balance >= _amount) {\n            _vaultDetails[_vault].balance = _balance.sub(_amount);\n        } else {\n            _vaultDetails[_vault].balance = 0;\n        }\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests the specified strategy\n     * @param _strategy The address of the strategy\n     */\n    function harvestStrategy(\n        address _strategy,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n        override\n        notHalted\n        onlyHarvester\n        onlyStrategy(_strategy)\n    {\n        uint256 _before = IStrategy(_strategy).balanceOf();\n        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);\n        uint256 _after = IStrategy(_strategy).balanceOf();\n        address _vault = _vaultStrategies[_strategy];\n        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n        _vaultDetails[_vault].balances[_strategy] = _after;\n        emit Harvest(_strategy);\n    }\n\n    /**\n     * VAULT-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Invests funds into a strategy\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function earn(\n        address _strategy,\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        notHalted\n        onlyStrategy(_strategy)\n        onlyVault(_token)\n    {\n        // get the want token of the strategy\n        address _want = IStrategy(_strategy).want();\n        if (_want != _token) {\n            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);\n            IERC20(_token).safeTransfer(address(_converter), _amount);\n            // TODO: do estimation for received\n            _amount = _converter.convert(_token, _want, _amount, 1);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);\n        // call the strategy deposit function\n        IStrategy(_strategy).deposit();\n        updateBalance(msg.sender, _strategy);\n    }\n\n    /**\n     * @notice Withdraws funds from a strategy\n     * @dev If the withdraw amount is greater than the first strategy given\n     * by getBestStrategyWithdraw, this function will loop over strategies\n     * until the requested amount is met.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdraw(\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault(_token)\n    {\n        (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        ) = getBestStrategyWithdraw(_token, _amount);\n        for (uint i = 0; i < _strategies.length; i++) {\n            // getBestStrategyWithdraw will return arrays larger than needed\n            // if this happens, simply exit the loop\n            if (_strategies[i] == address(0)) {\n                break;\n            }\n            IStrategy(_strategies[i]).withdraw(_amounts[i]);\n            updateBalance(msg.sender, _strategies[i]);\n            address _want = IStrategy(_strategies[i]).want();\n            if (_want != _token) {\n                address _converter = _vaultDetails[msg.sender].converter;\n                IERC20(_want).safeTransfer(_converter, _amounts[i]);\n                // TODO: do estimation for received\n                IConverter(_converter).convert(_want, _token, _amounts[i], 1);\n            }\n        }\n        _amount = IERC20(_token).balanceOf(address(this));\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the rough balance of the sum of all strategies for a given vault\n     * @dev This function is optimized to prevent looping over all strategy balances,\n     * and instead the controller tracks the earn, withdraw, and harvest amounts.\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return _vaultDetails[msg.sender].balance;\n    }\n\n    /**\n     * @notice Returns the converter assigned for the given vault\n     * @param _vault Address of the vault\n     */\n    function converter(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return _vaultDetails[_vault].converter;\n    }\n\n    /**\n     * @notice Returns the cap of a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function getCap(\n        address _vault,\n        address _strategy\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _vaultDetails[_vault].caps[_strategy];\n    }\n\n    /**\n     * @notice Returns whether investing is enabled for the calling vault\n     * @dev Should be called by the vault\n     */\n    function investEnabled()\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (globalInvestEnabled) {\n            return _vaultDetails[msg.sender].strategies.length > 0;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategies(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return _vaultDetails[_vault].strategies;\n    }\n\n    /**\n     * @notice Returns the length of the strategies of the calling vault\n     * @dev This function is expected to be called by a vault\n     */\n    function strategies()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _vaultDetails[msg.sender].strategies.length;\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from\n     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays\n     * from this function will always be the same length as the amount of strategies for\n     * a token. Check that _strategies[i] != address(0) when consuming to know when to\n     * break out of the loop.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function getBestStrategyWithdraw(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        )\n    {\n        // get the length of strategies for a single token\n        address _vault = manager.vaults(_token);\n        uint256 k = _vaultDetails[_vault].strategies.length;\n        // initialize fixed-length memory arrays\n        _strategies = new address[](k);\n        _amounts = new uint256[](k);\n        address _strategy;\n        uint256 _balance;\n        // scan forward from the the beginning of strategies\n        for (uint i = 0; i < k; i++) {\n            _strategy = _vaultDetails[_vault].strategies[i];\n            _strategies[i] = _strategy;\n            // get the balance of the strategy\n            _balance = _vaultDetails[_vault].balances[_strategy];\n            // if the strategy doesn't have the balance to cover the withdraw\n            if (_balance < _amount) {\n                // withdraw what we can and add to the _amounts\n                _amounts[i] = _balance;\n                _amount = _amount.sub(_balance);\n            } else {\n                // stop scanning if the balance is more than the withdraw amount\n                _amounts[i] = _amount;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the stored balance of a given strategy for a vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function updateBalance(\n        address _vault,\n        address _strategy\n    )\n        internal\n    {\n        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @notice Reverts if the protocol is halted\n     */\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not governance\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the strategy is not allowed in the manager\n     */\n    modifier onlyStrategy(address _strategy) {\n        require(manager.allowedStrategies(_strategy), \"!allowedStrategy\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the harvester\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the vault for the given token\n     */\n    modifier onlyVault(address _token) {\n        require(msg.sender == manager.vaults(_token), \"!vault\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Manager.sol",
            "YaxisVoteProxy.sol",
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "addToken",
                    "vaults[_token] = _vault",
                    "onlyVault",
                    "getBestStrategyWithdraw",
                    "vaults[_token]",
                    "token"
                ],
                "Type": " token -> vault mapping can be overwritten",
                "Description": "\nOne vault can have many tokens, but each token should only be assigned to a single vault.\nThe Manager contract keeps a mapping of tokens to vaults in the vaults[_token] = _vault map, and a mapping of vault to tokens in tokens[vault] = token[].\n\nThe addToken function can assign any token to a single vault and allows overwriting an existing vaults[_token] map entry with a different vault.\nThis indirectly disassociates the previous vault for the token.\nNote that the previous vault's tokens[_previousVault] map still contains the token.\n\nThe token disappears from the system for the previous vault but the actual tokens are still in there, getting stuck.\nOnly the new vault is considered for the token anymore, which leads to many issues, see Controller.getBestStrategyWithdraw and the onlyVault modifier that doesn't work correctly anymore.\n\n",
                "Repair": "It should check if the token is already used in a map, and either revert or correctly remove the token from the vault from the tokens array.\nIt should do the same cleanup procedure as in removeToken:\n\nsolidity\nif (found) {\n    // remove the token from the vault\n    tokens[_vault][index] = tokens[_vault][k-1];\n    tokens[_vault].pop();\n    delete vaults[_token];\n    emit TokenRemoved(_vault, _token);\n}\n\n\naddToken should also check that the token is not already in the tokens[_vault] array.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/126#issuecomment-943460833):\n  Mapping mismatch can cause undefined behaviour\n\n Recommend having one source of truth to keep things simple\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n\n\n",
        "CodeNames": [
            "YaxisVotePower.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-10",
                "Location": [
                    "//solidity\n(uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\nint256 _lpStakingYax = _yaxReserves\n    .mul(_stakeAmount)\n    .div(_supply)\n    .add(rewardsYaxisEth.earned(_voter));\n"
                ],
                "Type": "  YAxisVotePower.balanceOf  can be manipulated",
                "Description": "\nThe YAxisVotePower.balanceOf contract uses the Uniswap pool reserves to compute a _lpStakingYax reward:\n\nsolidity\n(uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\nint256 _lpStakingYax = _yaxReserves\n    .mul(_stakeAmount)\n    .div(_supply)\n    .add(rewardsYaxisEth.earned(_voter));\n\n\nThe pool can be temporarily manipulated to increase the _yaxReserves amount.\n\nIf this voting power is used for governance proposals, an attacker can increase their voting power and pass a proposal.\n\n",
                "Repair": "One could build a TWAP-style contract that tracks a time-weighted-average reserve amount (instead of the price in traditional TWAPs).\nThis can then not be manipulated by flashloans.\n\nuN2RVw5q commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/113#issuecomment-932350186):\n  I disagree with the \"sponsor disputed\" tag.\n\n I think this is a valid issue and makes balanceOf(_voter) susceptible to flashloan attacks. However, as long as balanceOf(_voter) is always called by a trusted EOA during governance vote counts, this should not be a problem. I assume this is the case for governance proposals. If that is not the case, I would recommend changing the code. Otherwise, changing the risk to \"documentation\" would be reasonable.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/113#issuecomment-943463853):\n  Agree with original warden finding, as well as severity\n\n The ability to trigger the count at any time does prevent a flashloan attack (as flashloans are atomic)\n It would allow the privilege of the flashloan attack to the trusted EOA (admin privilege)\n\n Additionally the voting power can still be frontrun, while you cannot manipulate that voting power via a flashloan, you can just buy and sell your position on the same block as when the count is being taken\n\n Due to this I will up the severity back to medium as this is a legitimate vector to extract value\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IController {\n    function balanceOf() external view returns (uint256);\n    function converter(address _vault) external view returns (address);\n    function earn(address _strategy, address _token, uint256 _amount) external;\n    function investEnabled() external view returns (bool);\n    function harvestStrategy(address _strategy, uint256 _estimatedWETH, uint256 _estimatedYAXIS) external;\n    function manager() external view returns (IManager);\n    function strategies() external view returns (uint256);\n    function withdraw(address _token, uint256 _amount) external;\n    function withdrawAll(address _strategy, address _convert) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVoteProxy {\n    IVoteProxy public voteProxy;\n    address public governance;\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function name() external pure returns (string memory) {\n        return \"YAXIS Vote Power\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"YAX VP\";\n    }\n\n    function decimals() external view returns (uint8) {\n        return voteProxy.decimals();\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return voteProxy.totalSupply();\n    }\n\n    function balanceOf(address _voter) external view returns (uint256) {\n        return voteProxy.balanceOf(_voter);\n    }\n\n    function setVoteProxy(IVoteProxy _voteProxy) external {\n        require(msg.sender == governance, \"!governance\");\n        voteProxy = _voteProxy;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n\n\n/**\n * This function allows governance to take unsupported tokens out of the contract.\n * This is in an effort to make someone whole, should they seriously mess up.\n * There is no guarantee governance will vote to return these.\n * It also allows for removal of airdropped tokens.\n */\n    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\n        require(msg.sender == governance, \"!governance\");\n        _token.transfer(to, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/ILegacyController.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/ISwap.sol\";\n\n/**\n * @title Harvester\n * @notice This contract is to be used as a central point to call\n * harvest on all strategies for any given vault. It has its own\n * permissions for harvesters (set by the strategist or governance).\n */\ncontract Harvester is IHarvester {\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    IManager public immutable override manager;\n    IController public immutable controller;\n    ILegacyController public immutable legacyController;\n\n    uint256 public slippage;\n\n    struct Strategy {\n        uint256 timeout;\n        uint256 lastCalled;\n        address[] addresses;\n    }\n\n    mapping(address => Strategy) public strategies;\n    mapping(address => bool) public isHarvester;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(\n        address indexed controller,\n        address indexed strategy\n    );\n\n    /**\n     * @notice Logged when a harvester is set\n     */\n    event HarvesterSet(address indexed harvester, bool status);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 timeout);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy, uint256 timeout);\n\n    /**\n     * @param _manager The address of the yAxisMetaVaultManager contract\n     * @param _controller The address of the controller\n     */\n    constructor(\n        address _manager,\n        address _controller,\n        address _legacyController\n    )\n        public\n    {\n        manager = IManager(_manager);\n        controller = IController(_controller);\n        legacyController = ILegacyController(_legacyController);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy to the rotation for a given vault and sets a timeout\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        override\n        onlyController\n    {\n        strategies[_vault].addresses.push(_strategy);\n        strategies[_vault].timeout = _timeout;\n        emit StrategyAdded(_vault, _strategy, _timeout);\n    }\n\n    /**\n     * @notice Removes a strategy from the rotation for a given vault and sets a timeout\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        override\n        onlyController\n    {\n        uint256 tail = strategies[_vault].addresses.length;\n        uint256 index;\n        bool found;\n        for (uint i; i < tail; i++) {\n            if (strategies[_vault].addresses[i] == _strategy) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            strategies[_vault].addresses[index] = strategies[_vault].addresses[tail.sub(1)];\n            strategies[_vault].addresses.pop();\n            strategies[_vault].timeout = _timeout;\n            emit StrategyRemoved(_vault, _strategy, _timeout);\n        }\n    }\n\n    /**\n     * @notice Sets the status of a harvester address to be able to call harvest functions\n     * @param _harvester The address of the harvester\n     * @param _status The status to allow the harvester to harvest\n     */\n    function setHarvester(\n        address _harvester,\n        bool _status\n    )\n        external\n        onlyStrategist\n    {\n        isHarvester[_harvester] = _status;\n        emit HarvesterSet(_harvester, _status);\n    }\n\n    function setSlippage(\n        uint256 _slippage\n    )\n        external\n        onlyStrategist\n    {\n        require(_slippage < ONE_HUNDRED_PERCENT, \"!_slippage\");\n        slippage = _slippage;\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    function earn(\n        address _strategy,\n        IVault _vault,\n        address _token\n    )\n        external\n        onlyHarvester\n    {\n        _vault.earn(_token, _strategy);\n    }\n\n    /**\n     * @notice Harvests a given strategy on the provided controller\n     * @dev This function ignores the timeout\n     * @param _controller The address of the controller\n     * @param _strategy The address of the strategy\n     */\n    function harvest(\n        IController _controller,\n        address _strategy,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        public\n        onlyHarvester\n    {\n        _controller.harvestStrategy(_strategy, _estimatedWETH, _estimatedYAXIS);\n        emit Harvest(address(_controller), _strategy);\n    }\n\n    /**\n     * @notice Harvests the next available strategy for a given vault and\n     * rotates the strategies\n     * @param _vault The address of the vault\n     */\n    function harvestNextStrategy(\n        address _vault,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n    {\n        require(canHarvest(_vault), \"!canHarvest\");\n        address strategy = strategies[_vault].addresses[0];\n        harvest(controller, strategy, _estimatedWETH, _estimatedYAXIS);\n        uint256 k = strategies[_vault].addresses.length;\n        if (k > 1) {\n            address[] memory _strategies = new address[](k);\n            for (uint i; i < k-1; i++) {\n                _strategies[i] = strategies[_vault].addresses[i+1];\n            }\n            _strategies[k-1] = strategy;\n            strategies[_vault].addresses = _strategies;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        strategies[_vault].lastCalled = block.timestamp;\n    }\n\n    /**\n     * @notice Earns tokens in the LegacyController to the v3 vault\n     * @param _token The address of the token\n     * @param _expected The expected amount to deposit after conversion\n     */\n    function legacyEarn(\n        address _token,\n        uint256 _expected\n    )\n        external\n        onlyHarvester\n    {\n        legacyController.legacyDeposit(_token, _expected);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the addresses of the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategyAddresses(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return strategies[_vault].addresses;\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the availability of a vault's strategy to be harvested\n     * @param _vault The address of the vault\n     */\n    function canHarvest(\n        address _vault\n    )\n        public\n        view\n        returns (bool)\n    {\n        Strategy storage strategy = strategies[_vault];\n        // only can harvest if there are strategies, and when sufficient time has elapsed\n        return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout));\n    }\n\n    /**\n     * @notice Returns the estimated amount of WETH and YAXIS for the given strategy\n     * @param _strategy The address of the strategy\n     */\n    function getEstimates(\n        address _strategy\n    )\n        public\n        view\n        returns (uint256 _estimatedWETH, uint256 _estimatedYAXIS)\n    {\n        ISwap _router = IStrategy(_strategy).router();\n        address[] memory _path;\n        _path[0] = IStrategy(_strategy).want();\n        _path[1] = IStrategy(_strategy).weth();\n        uint256[] memory _amounts = _router.getAmountsOut(\n            IStrategy(_strategy).balanceOfPool(),\n            _path\n        );\n        _estimatedWETH = _amounts[1];\n        uint256 _slippage = slippage;\n        if (_slippage > 0) {\n            _estimatedWETH = _estimatedWETH.mul(_slippage).div(ONE_HUNDRED_PERCENT);\n        }\n        _path[0] = manager.yaxis();\n        uint256 _fee = _estimatedWETH.mul(manager.treasuryFee()).div(ONE_HUNDRED_PERCENT);\n        _amounts = _router.getAmountsOut(_fee, _path);\n        _estimatedYAXIS = _amounts[1];\n        if (_slippage > 0) {\n            _estimatedYAXIS = _estimatedYAXIS.mul(_slippage).div(ONE_HUNDRED_PERCENT);\n        }\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyController() {\n        require(manager.allowedControllers(msg.sender), \"!controller\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(isHarvester[msg.sender], \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "IController.sol",
            "YaxisVoteProxy.sol",
            "YaxisVotePower.sol",
            "Harvester.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [
                    "//solidity\naddress[] memory _path;\n_path[0] = IStrategy(_strategy).want();\n_path[1] = IStrategy(_strategy).weth();\n// ...\n\n_path[0] = manager.yaxis();\n// path is YAXIS - WETH now\n// fee is a WETH precision value\nuint256 _fee = _estimatedWETH.mul(manager.treasuryFee()).div(ONE_HUNDRED_PERCENT);\n// this will return wrong trade amounts\n_amounts = _router.getAmountsOut(_fee, _path);\n_estimatedYAXIS = _amounts[1];\n"
                ],
                "Type": " wrong YAXIS estimates",
                "Description": "\nThe Harvester.getEstimates contract tries to estimate a YAXIS amount but uses the wrong path and/or amount.\n\nIt currently uses a WETH input amount to compute a YAXIS - WETH trade.\n\nsolidity\naddress[] memory _path;\n_path[0] = IStrategy(_strategy).want();\n_path[1] = IStrategy(_strategy).weth();\n// ...\n\n_path[0] = manager.yaxis();\n// path is YAXIS - WETH now\n// fee is a WETH precision value\nuint256 _fee = _estimatedWETH.mul(manager.treasuryFee()).div(ONE_HUNDRED_PERCENT);\n// this will return wrong trade amounts\n_amounts = _router.getAmountsOut(_fee, _path);\n_estimatedYAXIS = _amounts[1];\n\n\nThe estimations from getEstimates are wrong.\nThey seem to be used to provide min. amount slippage values (_estimatedWETH, _estimatedYAXIS) for the harvester when calling Controller._estimatedYAXIS.\nThese are then used in BaseStrategy._payHarvestFees and can revert the harvest transactions if the wrongly computed _estimatedYAXIS value is above the actual trade value.\nOr they can allow a large slippage if the _estimatedYAXIS value is below the actual trade value, which can then be used for a sandwich attack.\n\n",
                "Repair": "Fix the estimations computations.\n\nAs the estimations are used in BaseStrategy._payHarvestFees, the expected behavior seems to be trading WETH to YAXIS.\nThe path should therefore be changed to path[0] = WETH; path[1] = YAXIS in Harvester.getEstimates.\n\n\nHaz077 (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/112)\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/112#issuecomment-943475050):\n  Price estimates on Uniswap are dependent on which side of the swap you're making\n\n Sponsor has mitigated in later PR\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IStableSwap3Pool.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"../interfaces/IManager.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IController.sol\";\n\n/**\n * @title BaseStrategy\n * @notice The BaseStrategy is an abstract contract which all\n * yAxis strategies should inherit functionality from. It gives\n * specific security properties which make it hard to write an\n * insecure strategy.\n * @notice All state-changing functions implemented in the strategy\n * should be internal, since any public or externally-facing functions\n * are already handled in the BaseStrategy.\n * @notice The following functions must be implemented by a strategy:\n * - function _deposit() internal virtual;\n * - function _harvest() internal virtual;\n * - function _withdraw(uint256 _amount) internal virtual;\n * - function _withdrawAll() internal virtual;\n * - function balanceOfPool() public view override virtual returns (uint256);\n */\nabstract contract BaseStrategy is IStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    address public immutable override want;\n    address public immutable override weth;\n    address public immutable controller;\n    IManager public immutable override manager;\n    string public override name;\n    ISwap public override router;\n\n    /**\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _want The desired token of the strategy\n     * @param _weth The address of WETH\n     * @param _router The address of the router for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _controller,\n        address _manager,\n        address _want,\n        address _weth,\n        address _router\n    ) public {\n        name = _name;\n        want = _want;\n        controller = _controller;\n        manager = IManager(_manager);\n        weth = _weth;\n        router = ISwap(_router);\n        IERC20(_weth).safeApprove(address(_router), type(uint256).max);\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Approves a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    )\n        external\n    {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _token.safeApprove(_spender, 0);\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Sets the address of the ISwap-compatible router\n     * @param _router The address of the router\n     */\n    function setRouter(\n        address _router\n    )\n        external\n    {\n        require(msg.sender == manager.governance(), \"!governance\");\n        router = ISwap(_router);\n        IERC20(weth).safeApprove(address(_router), 0);\n        IERC20(weth).safeApprove(address(_router), type(uint256).max);\n    }\n\n    /**\n     * CONTROLLER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits funds to the strategy's pool\n     */\n    function deposit()\n        external\n        override\n        onlyController\n    {\n        _deposit();\n    }\n\n    /**\n     * @notice Harvest funds in the strategy's pool\n     */\n    function harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n        override\n        onlyController\n    {\n        _harvest(_estimatedWETH, _estimatedYAXIS);\n    }\n\n    /**\n     * @notice Sends stuck want tokens in the strategy to the controller\n     */\n    function skim()\n        external\n        override\n        onlyController\n    {\n        IERC20(want).safeTransfer(controller, balanceOfWant());\n    }\n\n    /**\n     * @notice Sends stuck tokens in the strategy to the controller\n     * @param _asset The address of the token to withdraw\n     */\n    function withdraw(\n        address _asset\n    )\n        external\n        override\n        onlyController\n    {\n        require(want != _asset, \"want\");\n\n        IERC20 _assetToken = IERC20(_asset);\n        uint256 _balance = _assetToken.balanceOf(address(this));\n        _assetToken.safeTransfer(controller, _balance);\n    }\n\n    /**\n     * @notice Initiated from a vault, withdraws funds from the pool\n     * @param _amount The amount of the want token to withdraw\n     */\n    function withdraw(\n        uint256 _amount\n    )\n        external\n        override\n        onlyController\n    {\n        uint256 _balance = balanceOfWant();\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        IERC20(want).safeTransfer(controller, _amount);\n    }\n\n    /**\n     * @notice Withdraws all funds from the strategy\n     */\n    function withdrawAll()\n        external\n        override\n        onlyController\n    {\n        _withdrawAll();\n\n        uint256 _balance = IERC20(want).balanceOf(address(this));\n\n        IERC20(want).safeTransfer(controller, _balance);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the strategy's balance of the want token plus the balance of pool\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the balance of the pool\n     * @dev Must be implemented by the strategy\n     */\n    function balanceOfPool()\n        public\n        view\n        virtual\n        override\n        returns (uint256);\n\n    /**\n     * @notice Returns the balance of the want token on the strategy\n     */\n    function balanceOfWant()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    function _deposit()\n        internal\n        virtual;\n\n    function _harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        virtual;\n\n    function _payHarvestFees(\n        address _poolToken,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        returns (uint256 _wethBal)\n    {\n        uint256 _amount = IERC20(_poolToken).balanceOf(address(this));\n        _swapTokens(_poolToken, weth, _amount, _estimatedWETH);\n        _wethBal = IERC20(weth).balanceOf(address(this));\n\n        if (_wethBal > 0) {\n            // get all the necessary variables in a single call\n            (\n                address yaxis,\n                address treasury,\n                uint256 treasuryFee\n            ) = manager.getHarvestFeeInfo();\n\n            uint256 _fee;\n\n            // pay the treasury with YAX\n            if (treasuryFee > 0 && treasury != address(0)) {\n                _fee = _wethBal.mul(treasuryFee).div(ONE_HUNDRED_PERCENT);\n                _swapTokens(weth, yaxis, _fee, _estimatedYAXIS);\n                IERC20(yaxis).safeTransfer(treasury, IERC20(yaxis).balanceOf(address(this)));\n            }\n\n            // return the remaining WETH balance\n            _wethBal = IERC20(weth).balanceOf(address(this));\n        }\n    }\n\n    function _swapTokens(\n        address _input,\n        address _output,\n        uint256 _amount,\n        uint256 _expected\n    )\n        internal\n    {\n        address[] memory path = new address[](2);\n        path[0] = _input;\n        path[1] = _output;\n        router.swapExactTokensForTokens(\n            _amount,\n            _expected,\n            path,\n            address(this),\n            // The deadline is a hardcoded value that is far in the future.\n            1e10\n        );\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        virtual;\n\n    function _withdrawAll()\n        internal\n        virtual;\n\n    function _withdrawSome(\n        uint256 _amount\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 _before = IERC20(want).balanceOf(address(this));\n        _withdraw(_amount);\n        uint256 _after = IERC20(want).balanceOf(address(this));\n        _amount = _after.sub(_before);\n\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"!controller\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IManager.sol\";\nimport \"../interfaces/ICurve3Pool.sol\";\n\n/**\n * @title StablesConverter\n */\ncontract StablesConverter is IConverter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IManager public immutable override manager;\n    ICurve3Pool public immutable stableSwap3Pool;\n    IERC20 public immutable token3CRV; // 3Crv\n\n    IERC20[3] public tokens; // DAI, USDC, USDT\n\n    mapping(address => int128) internal indices;\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _stableSwap3Pool The address of 3Pool\n     * @param _manager The address of the Vault Manager\n     */\n    constructor(\n        IERC20 _tokenDAI,\n        IERC20 _tokenUSDC,\n        IERC20 _tokenUSDT,\n        IERC20 _token3CRV,\n        ICurve3Pool _stableSwap3Pool,\n        IManager _manager\n    ) public {\n        tokens[0] = _tokenDAI;\n        tokens[1] = _tokenUSDC;\n        tokens[2] = _tokenUSDT;\n        indices[address(_tokenDAI)] = 0;\n        indices[address(_tokenUSDC)] = 1;\n        indices[address(_tokenUSDT)] = 2;\n        token3CRV = _token3CRV;\n        stableSwap3Pool = _stableSwap3Pool;\n        tokens[0].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        tokens[1].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        tokens[2].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        _token3CRV.safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        manager = _manager;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Called by the strategist to approve a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        _token.safeApprove(_spender, 0);\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Allows the strategist to withdraw tokens from the converter\n     * @dev This contract should never have any tokens in it at the end of a transaction\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to receive the tokens\n     */\n    function recoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * AUTHORIZED-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Converts the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     * @param _estimatedOutput The estimated output tokens after converting\n     */\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount,\n        uint256 _estimatedOutput\n    )\n        external\n        override\n        onlyAuthorized\n        returns (uint256 _outputAmount)\n    {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    uint256 _before = token3CRV.balanceOf(address(this));\n                    stableSwap3Pool.add_liquidity(amounts, _estimatedOutput);\n                    uint256 _after = token3CRV.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    token3CRV.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            // A temporary cache, used to save gas.\n            IERC20 _token;\n            for (uint8 i = 0; i < 3; i++) {\n                _token = tokens[i];\n                if (_output == address(_token) {\n                    uint256 _before = _token.balanceOf(address(this));\n                    stableSwap3Pool.remove_liquidity_one_coin(\n                        _inputAmount,\n                        i,\n                        _estimatedOutput\n                    );\n                    uint256 _after = _token.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    _token.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else {\n            stableSwap3Pool.exchange(\n                indices[_input],\n                indices[_output],\n                _inputAmount,\n                _estimatedOutput\n            );\n            _outputAmount = IERC20(_output).balanceOf(address(this));\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n            return _outputAmount;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Checks the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     */\n    function expected(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    )\n        external\n        override\n        view\n        returns (uint256)\n    {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    return stableSwap3Pool.calc_token_amount(amounts, true);\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            for (uint8 i = 0; i < 3; i++) {\n                if (_output == address(tokens[i])) {\n                    // @dev this is for UI reference only, the actual share price\n                    // (stable/CRV) will be re-calculated on-chain when we do convert()\n                    return stableSwap3Pool.calc_withdraw_one_coin(_inputAmount, i);\n                }\n            }\n        } else {\n            return stableSwap3Pool.get_dy(indices[_input], indices[_output], _inputAmount);\n        }\n        return 0;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @dev Throws if not called by an allowed vault, controller, or strategy\n     */\n    modifier onlyAuthorized() {\n        require(manager.allowedVaults(msg.sender)\n            || manager.allowedControllers(msg.sender)\n            || manager.allowedStrategies(msg.sender),\n            \"!authorized\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if not called by the strategist\n     */\n    modifier onlyStrategist {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Gauge.sol\";\nimport \"../../interfaces/Balancer.sol\";\n\nimport \"../interfaces/ExtendedIERC20.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract NativeStrategyCurve3Crv is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    Mintr public immutable crvMintr;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    Gauge public immutable gauge; // 3Crv Gauge\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        Gauge _gauge,\n        Mintr _crvMintr,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _manager,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _manager, _want, _weth, _router)\n    {\n        crv = _crv;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        stableSwap3Pool = _stableSwap3Pool;\n        gauge = _gauge;\n        crvMintr = _crvMintr;\n        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit()\n        internal\n        override\n    {\n        uint256 _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit [want] to Gauge\n            gauge.deposit(_wantBal);\n        }\n    }\n\n    function _claimReward()\n        internal\n    {\n        crvMintr.mint(address(gauge));\n    }\n\n    function _addLiquidity()\n        internal\n    {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium()\n        public\n        view\n        returns (address, uint256)\n    {\n        uint daiBalance = stableSwap3Pool.balances(0);\n        // USDC - Supports a change up to the 18 decimal standard\n        uint usdcBalance = stableSwap3Pool.balances(1).mul(10**18).div(10**(ExtendedIERC20(usdc).decimals()));\n        uint usdtBalance = stableSwap3Pool.balances(2).mul(10**12);\n\n        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {\n            return (dai, 0);\n        }\n\n        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {\n            return (usdc, 1);\n        }\n\n        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        override\n    {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity();\n\n            _deposit();\n        }\n    }\n\n    function _withdrawAll()\n        internal\n        override\n    {\n        uint256 _bal = gauge.balanceOf(address(this));\n        _withdraw(_bal);\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        override\n    {\n        gauge.withdraw(_amount);\n    }\n\n    function balanceOfPool()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return gauge.balanceOf(address(this));\n    }\n}\n\n\n",
        "CodeNames": [
            "BaseStrategy.sol",
            "StablesConverter.sol",
            "NativeStrategyCurve3Crv.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "stableSwap",
                    "_addLiquidity",
                    "_swapTokens(weth, _stableCoin, _remainingWeth,",
                    "NativeStrategyCurve"
                ],
                "Type": " Harvest can be frontrun",
                "Description": "\nIn the NativeStrategyCurve3Crv._harvest there are two instances that a bad actor could use to frontrun the harvest.\n\nFirst, when we are swapping WETH to a stablecoin by calling _swapTokens(weth, _stableCoin, _remainingWeth, 1) the function isn't checking the slippage, leading to the risk to a frontun (by imbalancing the Uniswap pair) and losing part of the harvesting profits.\n\nSecond, during the _addLiquidity internal function: this calls stableSwap3Pool.add_liquidity(amounts, 1) not considering the slippage when minting the 3CRV tokens.\n\nNativeStrategyCurve3Crv.sol L108(https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L108)\n\neditor\n\n",
                "Repair": "In the function _harvest(_estimatedWETH, _estimatedYAXIS) consider adding two additional estimated quantities: one for the swapped-out stablecoin and one for the minted 3CRV.\n\nBobbyYaxis (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/140)\n\nuN2RVw5q commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/140#issuecomment-932765993):\n  On second thought, I think this is a valid issue.\n\n  consider adding two additional estimated quantities: one for the swapped-out stablecoin and one for the minted 3CRV.\n\n This suggestion should be considered.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/140#issuecomment-943477587):\n  Warden identified two paths for front-running\n\n Since these are ways to extract value, severity is Medium\n\nBobbyYaxis (yAxis) noted:\n Mitigated in PR 114: https://github.com/yaxis-project/metavault/pull/114\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable max-states-count\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title Manager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract Manager is IManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;\n    uint256 public constant MAX_TOKENS = 256;\n\n    address public immutable override yaxis;\n\n    bool public override halted;\n\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override pendingStrategist;\n    address public override treasury;\n\n    // The following fees are all mutable.\n    // They are updated by governance (community vote).\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n\n    uint256 private setPendingStrategistTime;\n\n    // Governance must first allow the following properties before\n    // the strategist can make use of them\n    mapping(address => bool) public override allowedControllers;\n    mapping(address => bool) public override allowedConverters;\n    mapping(address => bool) public override allowedStrategies;\n    mapping(address => bool) public override allowedTokens;\n    mapping(address => bool) public override allowedVaults;\n\n    // vault => controller\n    mapping(address => address) public override controllers;\n    // vault => tokens[]\n    mapping(address => address[]) public override tokens;\n    // token => vault\n    mapping(address => address) public override vaults;\n\n    event AllowedController(\n        address indexed _controller,\n        bool _allowed\n    );\n    event AllowedConverter(\n        address indexed _converter,\n        bool _allowed\n    );\n    event AllowedStrategy(\n        address indexed _strategy,\n        bool _allowed\n    );\n    event AllowedToken(\n        address indexed _token,\n        bool _allowed\n    );\n    event AllowedVault(\n        address indexed _vault,\n        bool _allowed\n    );\n    event Halted();\n    event SetController(\n        address indexed _vault,\n        address indexed _controller\n    );\n    event SetGovernance(\n        address indexed _governance\n    );\n    event SetPendingStrategist(\n        address indexed _strategist\n    );\n    event SetStrategist(\n        address indexed _strategist\n    );\n    event TokenAdded(\n        address indexed _vault,\n        address indexed _token\n    );\n    event TokenRemoved(\n        address indexed _vault,\n        address indexed _token\n    );\n\n    /**\n     * @param _yaxis The address of the YAX token\n     */\n    constructor(\n        address _yaxis\n    )\n        public\n    {\n        require(_yaxis != address(0), \"!_yaxis\");\n        yaxis = _yaxis;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        treasury = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the permission for the given controller\n     * @param _controller The address of the controller\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedController(\n        address _controller,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IController(_controller).manager()) == address(this), \"!manager\");\n        allowedControllers[_controller] = _allowed;\n        emit AllowedController(_controller, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given converter\n     * @param _converter The address of the converter\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedConverter(\n        address _converter,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IConverter(_converter).manager()) == address(this), \"!manager\");\n        allowedConverters[_converter] = _allowed;\n        emit AllowedConverter(_converter, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given strategy\n     * @param _strategy The address of the strategy\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedStrategy(\n        address _strategy,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IStrategy(_strategy).manager()) == address(this), \"!manager\");\n        allowedStrategies[_strategy] = _allowed;\n        emit AllowedStrategy(_strategy, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given token\n     * @param _token The address of the token\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedToken(\n        address _token,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        allowedTokens[_token] = _allowed;\n        emit AllowedToken(_token, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given vault\n     * @param _vault The address of the vault\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedVault(\n        address _vault,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IVault(_vault).manager()) == address(this), \"!manager\");\n        allowedVaults[_vault] = _allowed;\n        emit AllowedVault(_vault, _allowed);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(\n        address _governance\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        governance = _governance;\n        emit SetGovernance(_governance);\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(\n        address _harvester\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IHarvester(_harvester).manager()) == address(this), \"!manager\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(\n        uint256 _insuranceFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(\n        address _insurancePool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(\n        uint256 _insurancePoolFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(\n        address _stakingPool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(\n        uint256 _stakingPoolShareFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the pending strategist and the timestamp\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(\n        address _strategist\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_strategist != address(0), \"!_strategist\");\n        pendingStrategist = _strategist;\n        // solhint-disable-next-line not-rely-on-time\n        setPendingStrategistTime = block.timestamp;\n        emit SetPendingStrategist(_strategist);\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(\n        address _treasury\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasury != address(0), \"!_treasury\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(\n        uint256 _treasuryFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasuryFee <= 2000, \"_treasuryFee over 20%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(\n        uint256 _withdrawalProtectionFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Updates the strategist to the pending strategist\n     * @dev This can only be called after the pending strategist timelock (7 days)\n     */\n    function acceptStrategist()\n        external\n        notHalted\n    {\n        require(msg.sender == pendingStrategist, \"!pendingStrategist\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), \"PENDING_STRATEGIST_TIMELOCK\");\n        delete pendingStrategist;\n        delete setPendingStrategistTime;\n        strategist = msg.sender;\n        emit SetStrategist(msg.sender);\n    }\n\n    /**\n     * @notice Adds a token to be able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function addToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(allowedTokens[_token], \"!allowedTokens\");\n        require(allowedVaults[_vault], \"!allowedVaults\");\n        require(tokens[_vault].length < MAX_TOKENS, \">tokens\");\n        require(vaults[_token] == address(0), \"!_token\");\n        vaults[_token] = _vault;\n        tokens[_vault].push(_token);\n        emit TokenAdded(_vault, _token);\n    }\n\n    /**\n     * @notice Allows the strategist to pull tokens out of this contract\n     * @dev This contract should never hold tokens\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function recoverToken(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Removes a token from being able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function removeToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        uint256 k = tokens[_vault].length;\n        uint256 index;\n        bool found;\n\n        for (uint i = 0; i < k; i++) {\n            if (tokens[_vault][i] == _token) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        // TODO: Verify added check\n        if (found) {\n            tokens[_vault][index] = tokens[_vault][k-1];\n            tokens[_vault].pop();\n            delete vaults[_token];\n            emit TokenRemoved(_vault, _token);\n        }\n    }\n\n    /**\n     * @notice Sets the vault address for a controller\n     * @param _vault The address of the vault\n     * @param _controller The address of the controller\n     */\n    function setController(\n        address _vault,\n        address _controller\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!_vault\");\n        require(allowedControllers[_controller], \"!_controller\");\n        controllers[_vault] = _controller;\n        emit SetController(_vault, _controller);\n    }\n\n    /**\n     * @notice Sets the protocol as halted, disallowing all deposits forever\n     * @dev Withdraws will still work, allowing users to exit the protocol\n     */\n    function setHalted()\n        external\n        notHalted\n        onlyStrategist\n    {\n        halted = true;\n        emit Halted();\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns an array of token addresses for a given vault\n     * @param _vault The address of the vault\n     */\n    function getTokens(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return tokens[_vault];\n    }\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAXIS token address,\n     *     Treasury address,\n     *     Treasury fee\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (\n            yaxis,\n            treasury,\n            treasuryFee\n        );\n    }\n\n    modifier notHalted() {\n        require(!halted, \"halted\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == strategist, \"!strategist\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./IConverter.sol\";\nimport \"./IVaultManager.sol\";\n\n/**\n * @title MetaVaultNonConverter (StableSwap3PoolConverter)\n * @notice The StableSwap3PoolConverter is used to convert funds on Curve's 3Pool.\n * This is a safe version that does not allow the vault to be used for arbitrage.\n */\ncontract MetaVaultNonConverter is IConverter {\n    using SafeERC20 for IERC20;\n\n    IVaultManager public immutable vaultManager;\n    IERC20 public immutable token3CRV; // 3Crv\n\n    /**\n     * @param _token3CRV The address of the 3CRV token\n     * @param _vaultManager The address of the Vault Manager\n     */\n    constructor(\n        IERC20 _token3CRV,\n        IVaultManager _vaultManager\n    ) public {\n        token3CRV = _token3CRV;\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to enable or disable a strategy to use the converter\n     */\n    function setStrategy(address, bool) external override onlyGovernance {\n        return;\n    }\n\n    /**\n     * @notice Called by Governance to approve a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyGovernance {\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function token() external view override returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Converts the amount of input tokens to output tokens\n     */\n    function convert(\n        address,\n        address,\n        uint256\n    ) external override returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Checks the amount of input tokens to output tokens\n     */\n    function convert_rate(\n        address,\n        address,\n        uint256\n    ) external override view returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Converts stables of the 3Pool to 3CRV\n     */\n    function convert_stables(\n        uint256[3] calldata\n    ) external override returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Checks the amount of 3CRV given for the amounts\n     */\n    function calc_token_amount(\n        uint256[3] calldata,\n        bool\n    ) external override view returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Checks the amount of an output token given for 3CRV\n     */\n    function calc_token_amount_withdraw(\n        uint256,\n        address\n    ) external override view returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Allows Governance to withdraw tokens from the converter\n     * @dev This contract should never have any tokens in it at the end of a transaction\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to receive the tokens\n     */\n    function governanceRecoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external onlyGovernance {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @dev Throws if not called by a controller or governance\n     */\n    modifier onlyGovernance() {\n        require(vaultManager.controllers(msg.sender)\n            || msg.sender == vaultManager.governance(), \"!governance\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Manager.sol",
            "MetaVaultNonConverter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-14",
                "Location": [
                    "onlyGovernance",
                    "setHalted()"
                ],
                "Type": " Halting the protocol should be  onlyGovernance  and not  onlyStrategist ",
                "Description": "\nA malicious strategist can halt the entire protocol and force a permanent shutdown once they observe that governance is trying to set a new strategist and they do not agree with that decision. They may use the 7 day window to halt the protocol. The access control on setHalted() should be onlyGovernance.\n\nManager.sol#L515 L522(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L515-L522)\nManager.sol#L333 L345(https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L333-L345)\n\nManual Analysis\n\n",
                "Repair": "Change access control to onlyGovernance from onlyStrategist for setHalted()\n\nGainsGoblin (yAxis) acknowledged(https://github.com/code-423n4/2021-09-yaxis-findings/issues/47)\n\nuN2RVw5q commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/47#issuecomment-932978261):\n  Implemented in https://github.com/code-423n4/2021-09-yaxis/pull/35\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-09-yaxis-findings/issues/47#issuecomment-943481373):\n  Agree that such critical functionality should be limited to the highest permission access role.\n Sponsor has mitigated\n\n\n"
            }
        ]
    }
]