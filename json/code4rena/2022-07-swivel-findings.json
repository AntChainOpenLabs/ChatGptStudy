[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Protocols.sol'; // NOTE: if size restrictions become extreme we can use ints (implicit enum)\nimport './LibCompound.sol';\nimport './LibFuse.sol';\n\ninterface IErc4626 {\n  /// @dev Converts the given 'assets' (uint256) to 'shares', returning that amount\n  function convertToAssets(uint256) external view returns (uint256);\n}\n\ninterface ICompoundToken {\n  function exchangeRateCurrent() external view returns(uint256);\n}\n\ninterface IYearnVault {\n  function pricePerShare() external view returns (uint256);\n}\n\ninterface IAavePool {\n   /// @dev Returns the normalized income of the reserve given the address of the underlying asset of the reserve\n  function getReserveNormalizedIncome(address) external view returns (uint256);\n}\n\ninterface IAaveToken {\n  function POOL() external view returns (address);\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n\ninterface IEulerToken {\n  /// @notice Convert an eToken balance to an underlying amount, taking into account current exchange rate\n  function convertBalanceToUnderlying(uint256) external view returns(uint256);\n}\n\nlibrary Compounding {\n  /// @param p Protocol Enum value\n  /// @param c Compounding token address\n  function exchangeRate(uint8 p, address c) internal view returns (uint256) {\n    if (p == uint8(Protocols.Compound)) {\n      return LibCompound.viewExchangeRate(ICERC20(c));\n    } else if (p == uint8(Protocols.Rari)) { \n      return LibFuse.viewExchangeRate(ICERC20(c));\n    } else if (p == uint8(Protocols.Yearn)) {\n      return IYearnVault(c).pricePerShare();\n    } else if (p == uint8(Protocols.Aave)) {\n      IAaveToken aToken = IAaveToken(c);\n      return IAavePool(aToken.POOL()).getReserveNormalizedIncome(aToken.UNDERLYING_ASSET_ADDRESS());\n    } else if (p == uint8(Protocols.Euler)) {\n      // NOTE: the 1e26 const is a degree of precision to enforce on the return\n      return IEulerToken(c).convertBalanceToUnderlying(1e26);\n    } else {\n      // NOTE: the 1e26 const is a degree of precision to enforce on the return\n      return IErc4626(c).convertToAssets(1e26);\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IERC5095 {\n\n    event Redeem(address indexed from, address indexed to, uint256 amount);\n\n    function maturity() external view returns (uint256);\n    function underlying() external view returns (address);\n    function convertToUnderlying(uint256 principalAmount) external view returns (uint256);\n    function convertToPrincipal(uint256 underlyingAmount) external view returns (uint256);\n    function maxRedeem(address owner) external view returns (uint256);\n    function previewRedeem(uint256 principalAmount) external view returns (uint256);\n    function maxWithdraw(address owner) external view returns (uint256);\n    function previewWithdraw(uint256 principalAmount) external view returns (uint256);  \n\n    function withdraw(uint256 underlyingAmount, address receiver, address owner) external returns (uint256);\n    function redeem(uint256 principalAmount, address receiver, address owner) external returns (uint256);\n}\n\n",
        "CodeNames": [
            "Compounding.sol",
            "IERC5095.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "amount",
                    "shares",
                    "withdraw()"
                ],
                "Type": "  Mismatch in  withdraw()  between Yearn and other protocols can prevent Users from redeeming zcTokens and permanently lock funds",
                "Description": "\nAs defined in the docs for Euler, ERC4626, Compound and Aave, when withdrawing and depositing funds the amount specified corresponds excactly to how many of the underlying assets are deposited or withdrawn.\n\nHowever, as specified by Yearn(https://docs.yearn.finance/vaults/smart-contracts/vault#withdraw), the yearn withdraw amount parameter specifies how many shares are burnt instead of underlying assets retrieved. Two scenarios can occur from then on, if there are not enough shares then the transaction will revert and users will not be able to redeem the underlying assets from Yearn. If there are enough shares, then a higher number of assets will be withdrawn then expected (as assets per share will only increase). This means that once the user receives their underlying assets at a 1:1 peg the excess amounts will be permanently locked in the vault contract.\n\n\nAll scenarios use Yearn finance as the protocol, the other protocols are unaffected.\n\n\n1.  A yearn finance vault contains 50 shares and 200 uTokens all owned by Swivel.sol\n2.  A user opens a zcToken position and deposits 100 uTokens into yearn receiving 100 zcTokens (and possibly a premium)\n3.  100 / 200 * 50 = 25 shares are minted for the vault so we now have 75 shares and 300 uTokens in the yearn vault\n4.  After maturity is achieved, the user tries to redeem their 100 zcTokens for uTokens\n5.  The swivel.sol contract tries to withdraw the 100 uTokens, it instead withdraws 100 shares which is less than available so the transaction reverts and the user cannot withdraw all of their 100 uTokens and instead can only withdraw 75 uTokens.\n\n\n1.  A yearn finance vault contains 50 shares and 100 uTokens all owned by Swivel.sol\n2.  A user opens a zcToken position and deposits 100 uTokens into yearn receiving 100 zcTokens (and possibly a premium)\n3.  100 / 100 * 50 = 50 shares are minted for the vault so we now have 100 shares and 200 uTokens in the yearn vault\n4.  After maturity is achieved, the user tries to redeem their 100 zcTokens for uTokens\n5.  The contract tries to retrieve 100 uTokens but instead withdraws 100 shares which corresponds to 200 uTokens\n6.  User receives their 100 uTokens causing 100 uTokens to be left in the Swivel.sol contract which are now irretrievable\n7.  If any user tries to withdraw their funds then the transaction will fail as no shares are left in the yearn vault\n\n\nVS Code\n\n",
                "Repair": "\nIn the withdraw() function in Swivel.sol, calculating the price per share and use that to retrieve the correct number of underlying assets\ne.g.\n\nsolidity\nuint256 pricePerShare = IYearnVault(c).pricePerShare();\nreturn IYearnVault(c).withdraw(a / pricePerShare) = 0;\n\n\nJTraversa (Swivel) commented(https://github.com/code-423n4/2022-07-swivel-findings/issues/43#issuecomment-1186017117):\n  Duplicate of #30(https://github.com/code-423n4/2022-07-swivel-findings/issues/30).\n\nscaraven (warden) commented(https://github.com/code-423n4/2022-07-swivel-findings/issues/43#issuecomment-1186135113):\n  I do not understand how this is a duplicate of #30, #30(https://github.com/code-423n4/2022-07-swivel-findings/issues/30) talks about a problem with redeemUnderlying() in Compound while this issue talks about a problem with withdraw() when using yearn.\n\nJTraversa (Swivel) commented(https://github.com/code-423n4/2022-07-swivel-findings/issues/43#issuecomment-1186429670):\n  They both cannot be true at once however. Either the lib expects shares, or the lib expects assets. His suggestion notes inconsistency and recommends changing the compound redeem to align with yearn, while you note the inconsistency and recommend fixing the yearn math. At the end of the day the issue is the \"mismatch\".\n\nscaraven (warden) commented(https://github.com/code-423n4/2022-07-swivel-findings/issues/43#issuecomment-1186439163):\n  Fair enough, that makes sense. I would still disagree with their interpretation of the issue, it is clear from the code that a represents the underlying assets. If a does represent the number of shares then other functions such as authRedeemzcTokens would be plain wrong because it would be redeeming each zcToken as if it was one share not one underlying asset.\n\nJTraversa (Swivel) commented(https://github.com/code-423n4/2022-07-swivel-findings/issues/43#issuecomment-1186453137):\n  Yeah I actually kind of agree with you. We intended the implementation to align more with your finding. \n \n That said it *might* be worth a judge's input. \n \n If they think they're different, the other finding is invalid/should be disputed and this one is correct.\n\nbghughes (judge) commented(https://github.com/code-423n4/2022-07-swivel-findings/issues/43#issuecomment-1205884382):\n  Confirmed, good issue and marked #30(https://github.com/code-423n4/2022-07-swivel-findings/issues/30) as a duplicate.\n\nrobrobbins (Swivel) resolved(https://github.com/code-423n4/2022-07-swivel-findings/issues/43#issuecomment-1234639671):\n  Addressed: https://github.com/Swivel-Finance/gost/pull/437.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]